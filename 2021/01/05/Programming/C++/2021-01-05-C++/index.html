<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"islet.space","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta name="description" content="C++语法及基础 运算符 运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符：  算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 杂项运算符  位运算符 位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：    p q p &amp; q p | q p ^ q     0 0 0 0 0   0 1 0">
<meta property="og:type" content="article">
<meta property="og:title" content="C++">
<meta property="og:url" content="http://islet.space/2021/01/05/Programming/C++/2021-01-05-C++/index.html">
<meta property="og:site_name" content="Coder的孤岛">
<meta property="og:description" content="C++语法及基础 运算符 运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符：  算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 杂项运算符  位运算符 位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：    p q p &amp; q p | q p ^ q     0 0 0 0 0   0 1 0">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://islet.space/Users/liewzheng/Library/Application%20Support/typora-user-images/image-20210801144743194.png">
<meta property="og:image" content="https://pic.islet.space/2021/10/image-20211009225305135.png">
<meta property="og:image" content="https://pic.islet.space/2021/05/20210520154529.png">
<meta property="og:image" content="https://pic.islet.space/2021/05/20210520154609.png">
<meta property="og:image" content="https://pic.islet.space/2021/05/20210524195016.png">
<meta property="og:image" content="https://pic.islet.space/2021/05/20210520154637.png">
<meta property="og:image" content="https://pic.islet.space/2021/05/image-20210520232442191.png">
<meta property="og:image" content="https://pic.islet.space/2021/05/20210521163534.png">
<meta property="og:image" content="https://pic.islet.space/2021/05/20210524102039.png">
<meta property="og:image" content="https://pic.islet.space/2021/05/20210524102044.png">
<meta property="og:image" content="https://pic.islet.space/2021/05/20210524102048.png">
<meta property="og:image" content="https://pic.islet.space/2021/05/20210524102051.png">
<meta property="article:published_time" content="2021-01-05T15:58:32.000Z">
<meta property="article:modified_time" content="2021-10-10T23:11:29.788Z">
<meta property="article:author" content="Liewzheng">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://islet.space/Users/liewzheng/Library/Application%20Support/typora-user-images/image-20210801144743194.png">


<link rel="canonical" href="http://islet.space/2021/01/05/Programming/C++/2021-01-05-C++/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://islet.space/2021/01/05/Programming/C++/2021-01-05-C++/","path":"2021/01/05/Programming/C++/2021-01-05-C++/","title":"C++"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++ | Coder的孤岛</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Coder的孤岛</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">islet of the coder</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-文章"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>文章</a></li>
        <li class="menu-item menu-item-目录"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-简历"><a href="/resume/" rel="section"><i class="fa fa-address-card fa-fw"></i>简历</a></li>
        <li class="menu-item menu-item-友链"><a href="/friends/" rel="section"><i class="fa fa-group fa-fw"></i>友链</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#c%E8%AF%AD%E6%B3%95%E5%8F%8A%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">C++语法及基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.1.</span> <span class="nav-text">位运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mangling"><span class="nav-number">1.2.</span> <span class="nav-text">Mangling</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-number">1.2.1.</span> <span class="nav-text">函数重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#inherit"><span class="nav-number">1.3.</span> <span class="nav-text">Inherit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#inline-function"><span class="nav-number">1.4.</span> <span class="nav-text">Inline Function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constructor-and-destructor"><span class="nav-number">1.5.</span> <span class="nav-text">Constructor and Destructor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#friend-function"><span class="nav-number">1.6.</span> <span class="nav-text">Friend Function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#preprocessing"><span class="nav-number">1.7.</span> <span class="nav-text">Preprocessing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%B7"><span class="nav-number">1.7.1.</span> <span class="nav-text">预处理运算符号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#and"><span class="nav-number">1.7.1.1.</span> <span class="nav-text"># and</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.7.1.1.1.</span> <span class="nav-text">字符串化运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E7%B2%98%E8%B4%B4%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.7.1.1.2.</span> <span class="nav-text">标记粘贴运算符</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#differences-between-c-c"><span class="nav-number">1.8.</span> <span class="nav-text">Differences between C &amp; C++</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c11"><span class="nav-number">2.</span> <span class="nav-text">C++11</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="nav-number">2.1.</span> <span class="nav-text">定义与声明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.1.1.</span> <span class="nav-text">关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B6%E5%B1%82const"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">顶层const</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.2.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">2.3.</span> <span class="nav-text">命名空间</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E9%94%99%E8%AF%AF"><span class="nav-number">3.</span> <span class="nav-text">常见问题及错误</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#c%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">C++常见的内存错误及解决方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c%E4%B8%ADstruct%E4%B8%8Eclass%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.2.</span> <span class="nav-text">C++中struct与class的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E7%BB%93%E6%9E%84%E4%BD%93%E4%BC%A0%E9%80%92%E7%BB%99%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.</span> <span class="nav-text">如何将结构体传递给函数？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">3.4.</span> <span class="nav-text">如何从函数返回一个结构体？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E5%8C%BA%E5%88%86"><span class="nav-number">3.5.</span> <span class="nav-text">. | -&gt; | :: | :符号区分？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8A%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%8F%A5%E6%9F%84%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="nav-number">3.6.</span> <span class="nav-text">计算机上正在运行的句柄、线程、进程分别是什么意思？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91"><span class="nav-number">3.7.</span> <span class="nav-text">预编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#error-%E9%A2%84%E7%BC%96%E8%AF%91%E4%B8%AD%E6%96%AD%E5%8F%8A%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA"><span class="nav-number">3.7.1.</span> <span class="nav-text">#Error 预编译中断及错误提示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#encountered-with-text"><span class="nav-number">3.7.1.1.</span> <span class="nav-text">Encountered with text</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#symbol-could-not-be-resolved"><span class="nav-number">3.7.2.</span> <span class="nav-text">Symbol could not be resolved</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E5%AE%9A%E4%B9%89"><span class="nav-number">3.7.2.1.</span> <span class="nav-text">重复定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AA%E5%AE%9A%E4%B9%89"><span class="nav-number">3.7.2.2.</span> <span class="nav-text">未定义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#error-li1050---multiply-defined-symbol"><span class="nav-number">3.8.</span> <span class="nav-text">Error: li1050 - MULTIPLY DEFINED SYMBOL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E7%BC%96%E5%8F%B7"><span class="nav-number">3.8.1.</span> <span class="nav-text">错误编号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">3.8.2.</span> <span class="nav-text">解决方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5"><span class="nav-number">3.8.3.</span> <span class="nav-text">实践</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liewzheng</p>
  <div class="site-description" itemprop="description">笔记分享的旮旯孤岛而已</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">99</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">183</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="mailto:liewzheng@foxmail.com" title="E-Mail → mailto:liewzheng@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/01/05/Programming/C++/2021-01-05-C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-05 23:58:32" itemprop="dateCreated datePublished" datetime="2021-01-05T23:58:32+08:00">2021-01-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-10-11 07:11:29" itemprop="dateModified" datetime="2021-10-11T07:11:29+08:00">2021-10-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="c语法及基础">C++语法及基础</h1>
<h2 id="运算符">运算符</h2>
<p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>杂项运算符</li>
</ul>
<h3 id="位运算符">位运算符</h3>
<p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p>
<table>
<thead>
<tr class="header">
<th>p</th>
<th>q</th>
<th>p &amp; q</th>
<th>p | q</th>
<th>p ^ q</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：</p>
<blockquote>
<p>A = 0011 1100</p>
<p>B = 0000 1101</p>
</blockquote>
<p>-----------------</p>
<blockquote>
<p>A&amp;B = 0000 1100</p>
<p>A|B = 0011 1101</p>
<p>A^B = 0011 0001</p>
<p>~A = 1100 0011</p>
</blockquote>
<p>下表显示了 C 语言支持的位运算符。假设变量 <strong>A</strong> 的值为 60，变量 <strong>B</strong> 的值为 13，则：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 4%" />
<col style="width: 47%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="header">
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&amp;</td>
<td>按位与操作，按二进制位进行"与"运算。运算规则： <code>0&amp;0=0;    0&amp;1=0;     1&amp;0=0;      1&amp;1=1;</code></td>
<td>(A &amp; B) 将得到 12，即为 0000 1100</td>
</tr>
<tr class="even">
<td>|</td>
<td>按位或运算符，按二进制位进行"或"运算。运算规则： <code>0|0=0;    0|1=1;    1|0=1;     1|1=1;</code></td>
<td>(A | B) 将得到 61，即为 0011 1101</td>
</tr>
<tr class="odd">
<td>^</td>
<td>异或运算符，按二进制位进行"异或"运算。运算规则： <code>0^0=0;    0^1=1;    1^0=1;   1^1=0;</code></td>
<td>(A ^ B) 将得到 49，即为 0011 0001</td>
</tr>
<tr class="even">
<td>~</td>
<td>取反运算符，按二进制位进行"取反"运算。运算规则： <code>~1=-2;    ~0=1;</code></td>
<td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>
</tr>
<tr class="odd">
<td>&lt;&lt;</td>
<td>二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</td>
<td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td>
</tr>
<tr class="even">
<td>&gt;&gt;</td>
<td>二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</td>
<td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td>
</tr>
</tbody>
</table>
<h2 id="mangling">Mangling</h2>
<p><strong>重载</strong>，包括 <strong>函数重载</strong> 和 <strong>操作符重载</strong> 。</p>
<h3 id="函数重载">函数重载</h3>
<blockquote>
<p><strong>函数重载</strong> 也叫 <strong>方法重载</strong>。是编译器通过把原方法名称与其参数相结合产生一个独特的内部名字来取代原方法名称的技术。</p>
<p>基本上，支持函数重载的语言都需要进行Name Mangling。Mangling的目的就是为了给重载的函数不同的签名，以避免调用时的二义性调用。</p>
</blockquote>
<p><strong>Name Mangling</strong> 不是一个非常新的技术，在C语言中也有，***在汇编C语言时经常看到的以 下划线“_”开头的函数名，其实就是C编译器将函数名进行了 Name Mangling*** 。</p>
<p>但是在C++中Name-mangling要复杂的多。 因为C++中支持 <strong><em>overload</em></strong> 和 <strong><em>override</em></strong> ，这就导致了C++编译器必须要有完成的Name-mangling把函数名或者变量名进行调整。</p>
<p>在面向对象编程语言出现之前，如果你想要打印不同类型的数据,需要写多个方法 ,象是 <code>PrintInteger(int i)</code> ，<code>PrintString(string s)</code> 和 <code>PrintFloat(float f)</code> 。也就是说必须<strong>通过命名来区别行为和数据类型</strong>，因为 OOP语言出现前，任一语言都（像是C）不允许使用相同的名字命名函数， 即使参数类型不同。</p>
<p>但在C++中，像是 Print(int i)、Print(string s) 和 Print(float f)，编译器自会准确调用特定的Print方法。当调用 <code>Print(1)</code> 的时候, 编译器可能在内部用源于参数类型的前缀重命名Print方法，这样一来 <code>Print(1)</code> 可能就变成 <code>i_Print (1)</code> 。</p>
<p>下面是更详细的例子：</p>
<p>C++编译器实际上将下面这些重载函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">float</span> f)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>* s)</span></span>;</span><br></pre></td></tr></table></figure>
<p>编译为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_print_int</span><br><span class="line">_print_char</span><br><span class="line">_print_float</span><br><span class="line">_pirnt_string</span><br></pre></td></tr></table></figure>
<p>这样的函数名，来唯一标识每个函数。</p>
<p><strong>注：</strong>不同的编译器实现可能不一样，但是都是利用这种机制。所以当连接是调用 <code>print(3)</code> 时，它会去查找 <code>_print_int(3)</code> 这样的函数。下面说个题外话，正是因为这点，重载被认为不是多态，多态是运行时动态绑定（“一种接口多种实现”），<strong>如果硬要认为重载是多态，它顶多是编译时“多态”。</strong></p>
<p>C++中的变量，编译也类似，如全局变量可能编译g_xx，类变量编译为c_xx等。连接是也是按照这种机制去查找相应的变量。</p>
<blockquote>
<p><code>方法重载</code> 仅是多态性的一种情形。</p>
<p><code>名称重整</code> 是一种支持方法重载的机制。更普遍的情况下，多态性是与继承相联系。</p>
</blockquote>
<h2 id="inherit">Inherit</h2>
<blockquote>
<p>继承就是一个新类 (称为子类) 从被继承类（称为父类或超类）取得自身的部分定义同时增加一些自己的新的信息。</p>
</blockquote>
<p>如果你在相同的类中重载方法, 数据类型必须是不同的。如果你在继承关系下重载方法, 子类与父类的方法可能完全相同，而且名称重整器生成同样的重整名称。</p>
<p>举例来说，假设一个超类定义一个 <code>Print(int i)</code> 方法而一个从它继承的子类也定义了一个 <code>Print(int i)</code> 方法。当你有一个子类的实例时，运用多态性调用 <code>Child.Print(int)</code> ；而当你产生一个父类的实例时运用多态性调用 <code>Parent.Print(int)</code> 。这就是继承多态性：相同的名字和签字但是类却不同。</p>
<p><code>继承多态性</code> 是通过使用一种与名称重整相关的另外一种机制实现的。编译器把方法放置在一个被称为虚拟方法表（其实是一个方法数组）的地方。每一个方法在VMT中都有一个索引, 如此当 <code>Print(int)</code> 被调用的时候, 编译器将被路由到VMT处找寻Print方法和类的内在索引。这样一来，编译器就可以调用正确的方法实现。由编译器负责管理所有的VMT索引和类偏移量。</p>
<p>简言之，多态性使你能够用非常相似的名字定义许多方法，这里的名字往往都是直观易记的。 OOP编译器自会根据调用者类理解到底该调用哪个方法。</p>
<p>Only one version of an overloaded function can appear within the extern C block. The code in the following example would result in an error.</p>
<p>While you can use name overloading in your SYS/BIOS C++ applications, only one version of the overloaded function can be called from the configuration.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> “C” &#123; <span class="comment">// Example causes ERROR</span></span><br><span class="line">	<span class="function">Int <span class="title">addNums</span><span class="params">(Int x, Int y)</span></span>;</span><br><span class="line">	<span class="function">Int <span class="title">addNums</span><span class="params">(Int x, Int y, Int z)</span></span>; <span class="comment">// error, only one version of addNums is allowed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="inline-function">Inline Function</h2>
<p><strong>内联方法 </strong>即内联函数，成员函数，inline functions，是指定义在类体内的函数。</p>
<p>该函数可以在类体内被声明和定义，也可以在类体内声明同时在体外使用 <code>inline</code> 关键字进行定义，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">angle</span>&#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">double</span> value;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">SetValue</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">angle::SetValue</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;                <span class="comment">//定义内联函数</span></span><br><span class="line">	value = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>内联函数无法递归。</p>
<h2 id="constructor-and-destructor">Constructor and Destructor</h2>
<p><strong>构造函数(Constructor Function)</strong> 在调用时会为对象开辟储存空间、作初始化 及 其他管理操作。</p>
<ul>
<li>如果为编写，则系统默认生成</li>
<li>可以接受参数不能有返回值</li>
<li>可以有多个构造函数，因此可以接受名称重载（Name Mangling）。</li>
</ul>
<p><strong>析构函数(Destructor Function)</strong> 仅在释放对象的内存空间时使用，如 <strong><em>程序超出类对象的作用域</em></strong> 或 <strong><em>类指针运行delete运算符</em></strong> 时。</p>
<h2 id="friend-function">Friend Function</h2>
<p><strong>友元函数</strong> 是指 <code>在类内部声明</code>，可以 <code>自由访问该类的私有部分</code> 并且 <code>不属于类成员</code> 的 <strong>函数</strong>或<strong>类</strong>。</p>
<p>在友元函数声明时定义一个该类的对象，可以通过引用该对象作为参数进行对类的访问。</p>
<p>为了确保数据完整性并遵循数据封装和隐藏的原则，因尽量少用或不用友元。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Student;</span><br><span class="line">class Teacher&#123;</span><br><span class="line">	public:</span><br><span class="line">		&#x2F;&#x2F;....</span><br><span class="line">&#125;</span><br><span class="line">	protected:</span><br><span class="line">		int NoOfStudent;</span><br><span class="line">		Student * pList[100];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Student&#123;</span><br><span class="line">	public:</span><br><span class="line">		friend class Teacher;             &#x2F;&#x2F;友元类声明</span><br><span class="line">		&#x2F;&#x2F;....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="preprocessing">Preprocessing</h2>
<p><strong>定义</strong></p>
<p>预处理是指将源文件的文本作为翻译的第一阶段操作的文本处理步骤。 预处理不会分析源文本，但会为了查找宏调用而将源文本细分为标记。 主要包括了下面三个方面：</p>
<ul>
<li>预处理指令</li>
<li>预处理运算符</li>
<li>预定义宏，这个有很多了，比如__FILE__、__LINE__和__DATA__等。</li>
</ul>
<p><strong>常识</strong> - 预处理并不是编译，也不是“预编译” - 预处理并不是每个语言都有 - C/C++预处理仅仅是把源程序划分和整理成一个个的段（phase），并不进行编译。 - 预处理器在UNIX传统中通常缩写为PP，在自动构建脚本中C预处理器被缩写为CPP的宏指代。为了不造成歧义，C++(c-plus-plus) 经常并不是缩写为CPP，而改成CXX</p>
<p><strong>Preprocessing Directives 预处理指令</strong></p>
<table>
<tbody>
<tr class="odd">
<td>#include</td>
<td>#import</td>
<td>#using</td>
<td>#progma</td>
</tr>
<tr class="even">
<td>#if</td>
<td>#ifdef</td>
<td>#ifndef</td>
<td>#elif</td>
</tr>
<tr class="odd">
<td>#lese</td>
<td>#endif</td>
<td>#define</td>
<td>#undef</td>
</tr>
<tr class="even">
<td>#error</td>
<td>#line</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="预处理运算符号">预处理运算符号</h3>
<table>
<thead>
<tr class="header">
<th>运算符</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>字符串化运算符（#）</td>
<td>导致对应的实参括在双引号内</td>
</tr>
<tr class="even">
<td>Charizing运算符（#@）</td>
<td></td>
</tr>
<tr class="odd">
<td>标记粘贴运算符（##）</td>
<td></td>
</tr>
<tr class="even">
<td>定义的运算符</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="and"># and</h4>
<h5 id="字符串化运算符">字符串化运算符</h5>
<p><code>#</code> 除了是 <strong><em>预处理符号</em></strong>，也是一种 <strong>运算符</strong> ，即 <strong>字符串化运算符</strong>，只能出现在带参的宏的替换文本中，<strong>将跟在后面的参数转换成一个字符串常量</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_INT(i) printf(#i<span class="meta-string">&quot;=%d\n&quot;</span>,i)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">100</span>;</span><br><span class="line">    PF_INT(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>预处理后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span><span class="string">&quot;=%d\n&quot;</span>,x);</span><br></pre></td></tr></table></figure>
<p>C语言常将相邻的字符串合并处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d\n&quot;</span>,x);</span><br></pre></td></tr></table></figure>
<h5 id="标记粘贴运算符">标记粘贴运算符</h5>
<p><code>##</code> 是一种 <strong>运算符</strong> ，即 <strong>标记粘贴运算符</strong>，是将两个 <strong>运算对象</strong> 连接（拼接）在一起，只能出现在带参宏定义的替换文本中。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM(h,t,u)  h##t##u</span></span><br></pre></td></tr></table></figure>
<p>假设u代表个位，t代表十位，h代表百位，则x=NUM(1,2,3)后,x=123。</p>
<p><strong>注：</strong><code>##</code>也可以用于拼接一些开头一样，尾巴不一样的宏，这样的宏一般用于描述代表特定意义的对象的不同状态等。宏开头固定，根据不同条件则选择拼接不同尾巴，最后拼接的字符串代表一个具体的状态等。</p>
<h2 id="differences-between-c-c">Differences between C &amp; C++</h2>
<ul>
<li>从语法要求来说，C++的语法要求更为严格，编译器对参数变量的检查要求更高，更容易报错；很多在C中可以被顺利编译的语句，在C++中会被严厉拒绝，例如，在C++中，当形参为unsigned char，而实参为const char时会报错。</li>
<li>C是面向过程语言，代码复用复杂。C++是面向对象语言。</li>
</ul>
<h1 id="c11">C++11</h1>
<h2 id="定义与声明">定义与声明</h2>
<p><strong>变量</strong> 只可以被定义（definition）一次，但是可以被多次声明（declaration）。</p>
<p><code>extern</code> 是跨文件编译（分离式编译，seperate compilation）的 <strong>变量声明符</strong>，只要没有显式（explicitly）地初始化变量，如<code>extern int num  = 100</code> 就可以，<mark>任何包含了显式初始化的声明，即成为了定义</mark>。</p>
<h3 id="关键字">关键字</h3>
<p>关于用户自定义的标识符，需要注意的是：</p>
<ul>
<li>不能连续出现两个下划线。</li>
<li>不能以下划线紧连大写字母开头。</li>
<li>定义在函数体外的标识符不能以下划线开头。</li>
</ul>
<figure>
<img src="/Users/liewzheng/Library/Application%20Support/typora-user-images/image-20210801144743194.png" alt="image-20210801144743194" /><figcaption aria-hidden="true">image-20210801144743194</figcaption>
</figure>
<h4 id="顶层const">顶层const</h4>
<p>指针本身是一个对象，指针本身可以指向另一个对象。</p>
<p>“指针本身是不是常量” 和 “指针所指的是不是一个常量” 是两个互相独立的问题。</p>
<p><strong>顶层const</strong>（top-level const）表示 <strong><em>指针本身是个常量</em></strong>。</p>
<p><strong>底层const</strong>（low-level const）表示 <strong><em>指针所指的对象是一个常量</em></strong>。</p>
<h2 id="初始化">初始化</h2>
<p>C++语言定义了初始化的好几种不同 <strong><em>形式</em></strong>，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sold = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sold = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sold&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sold</span><span class="params">(<span class="number">0</span>)</span></span>;  <span class="comment">//亲测可用</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<mark>初始化并不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义把对象的当前值擦除，并用一个新的值来替代</mark>。</p>
<p><strong>拷贝初始化</strong>（Copy Initialization）：使用等号（=）初始化一个变量，编译器把等号右侧的初始值拷贝到新创建的对象上去。</p>
<p><strong>直接初始化</strong>（Direct Initialization）：不使用等号进行初始化。</p>
<p><strong>列表初始化</strong>（List Initialization）：无论是为对象初始化或赋新值，都可以使用一组由花括号括起来的初始值。</p>
<h2 id="命名空间">命名空间</h2>
<figure>
<img src="https://pic.islet.space/2021/10/image-20211009225305135.png" alt="image-20211009225305135" /><figcaption aria-hidden="true">image-20211009225305135</figcaption>
</figure>
<p>这里说的头文件 <strong>不应包含</strong>，是只说不建议包含，</p>
<h1 id="常见问题及错误">常见问题及错误</h1>
<h2 id="c常见的内存错误及解决方法">C++常见的内存错误及解决方法</h2>
<p><strong>（1）内存分配未成功，却使用了它。</strong></p>
<blockquote>
<p>在使用内存之前先检查指针是否是NULL。如果是用malloc来申请内存，应该用if(p == NULL)或if（p != NULL）进行防错处理。如果是new来申请内存，申请失败会抛出异常，所以应该捕捉异常来进行防错处理。</p>
</blockquote>
<p><strong>（2）内存虽然分配成功，但尚未初始化就引用它。</strong></p>
<blockquote>
<p>尽管有时候缺省时会自动初始化，但无论什么时候创建对象均要对其进行初始化，即使是赋0值也是不可忽略的。</p>
</blockquote>
<p><strong>（3）内存分配成功，但访问越界</strong></p>
<blockquote>
<p>对数组for循环时要把握越界，否则可能会导致数组越界。</p>
</blockquote>
<p><strong>（4）忘记释放内存，导致内存泄漏</strong></p>
<blockquote>
<p>动态内存的申请和释放必须配对，new-delete和malloc-free其使用次数必须相等。</p>
</blockquote>
<p><strong>（5）已经释放内存还在使用它</strong></p>
<blockquote>
<p>free或delete后 ，没有将指针设为NULL，产生“野指针”。</p>
</blockquote>
<h2 id="c中struct与class的区别是什么">C++中struct与class的区别是什么？</h2>
<p>如果没有多态和虚拟继承，在C++中，struct和class的存取效率完全相同，存取class的数据成员与非虚函数效率和struct完全相同，不管该数据成员是定义在基类还是派生类。</p>
<p>class的数据成员在内存中的布局不一定是数据成员的声明顺序，C++只保证处于同一个access section的数据成员按照声明顺序排列。</p>
<p>C++中，class和struct做类型定义是只有两点区别：</p>
<ul>
<li>默认继承权限不同，<strong>class继承默认是private继承，而struct默认是public继承</strong>。</li>
<li>class还可用于定义模板参数，像typename，但是关键字struct不能同于定义模板参数。</li>
</ul>
<p>C++保留struct关键字，原因：</p>
<ul>
<li>保证与C语言的向下兼容性，C++必须提供一个struct。</li>
<li>C++中的struct定义必须百分百地保证与C语言中的struct的向下兼容性，把C++中的最基本的对象单元规定为class而不是struct，就是为了避免各种兼容性要求的限制。</li>
<li>对struct定义的扩展使C语言的代码能够更容易的被移植到C++中。</li>
</ul>
<h2 id="如何将结构体传递给函数">如何将结构体传递给函数？</h2>
<p>与类对象一样，结构体变量也可以通过值、引用和常量引用传递给函数。</p>
<p>默认情况下，它们通过值传递，这意味着需要生成整个原始结构的副本并传递给函数。</p>
<p>因为不希望浪费时间来复制整个结构体，所以，除非结构很小，否则一般会通过 <strong>引用</strong> 将结构体传递给函数。但是，这样意味着函数可以访问原始结构的成员变量，从而可能更改它们。</p>
<p>如果不想让函数更改任何成员变量值，那么可以考虑将结构体变量作为一个 <strong>常量引用</strong> 传递给函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Invltem</span>                       // <span class="title">Holds</span> <span class="title">data</span> <span class="title">for</span> <span class="title">an</span> <span class="title">inventory</span> <span class="title">item</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> partNum;                     <span class="comment">// Part number</span></span><br><span class="line">    <span class="built_in">string</span> description;              <span class="comment">// Item description</span></span><br><span class="line">    <span class="keyword">int</span> onHand;                      <span class="comment">// Units on hand</span></span><br><span class="line">    <span class="keyword">double</span> price;                    <span class="comment">// Unit price</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Function prototypes</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getltemData</span><span class="params">(InvItem &amp;)</span> </span>;        <span class="comment">//普通引用，函数可能会对结构体数据造成影响</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showItem</span><span class="params">(<span class="keyword">const</span> InvItem &amp;)</span></span>;      <span class="comment">//常量引用，不会让函数对结构体造成数据变化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InvItem part;                    <span class="comment">// Define an Invltem structure variable.</span></span><br><span class="line">    getItemData(part);</span><br><span class="line">    showItem(part);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getItemData</span><span class="params">(InvItem &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the part number: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; item.partNum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the part description: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">    getline (<span class="built_in">cin</span>, item.description);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the quantity on hand: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; item.onHand;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the unit price: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; item.price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showItem</span><span class="params">(<span class="keyword">const</span> InvItem &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Part Number : &quot;</span> &lt;&lt; item.partNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Description : &quot;</span> &lt;&lt; item.description &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Units On Hand : &quot;</span> &lt;&lt; item.onHand &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Price : $&quot;</span> &lt;&lt; item.price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Enter the part number: 800</span><br><span class="line">Enter the part description: Screwdriver</span><br><span class="line">Enter the quantity on hand: 135</span><br><span class="line">Enter the unit price: 1.25</span><br><span class="line"></span><br><span class="line">Part Number : 800</span><br><span class="line">Description : Screwdriver</span><br><span class="line">Units On Hand: 135</span><br><span class="line">Price : $1.25</span><br></pre></td></tr></table></figure>
<h2 id="如何从函数返回一个结构体">如何从函数返回一个结构体？</h2>
<p>也可以从函数返回结构体变量。在这种情况下，函数的返回类型是结构体的名称。可以改写程序 1 以允许 getItemData 函数创建 Invltem 结构体的局部实例，将数据值放入其成员变量中，然后将其传递回 main，而不是将其作为引用变量从 main 接收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InvItem <span class="title">getItemData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InvItem item;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the part number:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; item.partNum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the part description: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">    getline(<span class="built_in">cin</span>, item.description);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the quantity on hand: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; item.onHand;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the unit price: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; item.price;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是从 main 中调用它的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">part = getItemData();</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> <em>C++ 只允许从函数返回单个值。然而，结构体提供了解决这一限制的方法。即使一个结构体可能有几个成员，它在技术上还是一个单一的对象。通过在结构体中打包多个值，可以从函数返回任意数量的值。</em></p>
<h2 id="符号区分">. | -&gt; | :: | :符号区分？</h2>
<ol type="1">
<li><p>A.B则A为对象或者结构体；</p></li>
<li><p>A-&gt;B则A为指针，-&gt;是成员提取，A-&gt;B是提取A中的成员B，A只能是指向类、结构、联合的指针；</p></li>
<li><p>:: 是作用域运算符，A::B表示作用域A中的名称B，A可以是名字空间、类、结构；</p></li>
<li><p>: 一般用来表示继承；</p></li>
</ol>
<h2 id="计算机上正在运行的句柄线程进程分别是什么意思">计算机上正在运行的句柄、线程、进程分别是什么意思？</h2>
<p>https://www.cnblogs.com/bluestorm/p/5712238.html</p>
<blockquote>
<p>所谓 <code>句柄</code> 实际上是一个数据，是一个Long (整长型)的数据。</p>
<p>句柄是WONDOWS用来标识被应用程序所建立或使用的对象的唯一整数，WINDOWS使用各种各样的句柄标识诸如应用程序实例，窗口，控制，位图，GDI对象等等。WINDOWS句柄有点像C语言中的文件句柄。</p>
</blockquote>
<p>从上面的定义中的我们可以看到，句柄是一个 <code>标识符</code>，是拿来标识对象或者项目的，它就像我们的姓名一样，每个人都会有一个，不同的人的姓名不一样，但是，也可能有一个名字和你一样的人。从数据类型上来看它只是一个 <strong>16位的无符号整数</strong> 。<strong><em>应用程序几乎总是通过调用一个WINDOWS函数来获得一个句柄，之后其他的WINDOWS函数就可以使用该句柄，以引用相应的对象。</em></strong></p>
<p>句柄是一种 <code>指向指针的指针</code>。所谓指针是一种内存地址。应用程序启动后，组成这个程序的各对象是驻留在内存的。如果简单地理解，似乎只要获知这个内存的首地址，那么就可以随时用这个地址访问对象。但是非也，<strong>Windows是一个以虚拟内存为基础的操作系统</strong>。在这种系统环境下，Windows内存管理器经常在内存中来回移动对象，依此来满足各种应用程序的内存需要。对象被移动意味着它的地址变化了。如果地址总是如此变化，该到哪里去找该对象呢?</p>
<p>为了解决这个问题，Windows操作系统为各应用程序腾出一些 <code>内存储地址</code>，用来专门登记各应用对象在内存中的地址变化，而这个<strong>地址(存储单元的位置)本身是不变的</strong>。<strong>Windows内存管理器在移动对象在内存中的位置后，把对象新的地址告知这个句柄地址来保存。这样我们只需记住这个句柄地址就可以间接地知道对象具体在内存中的哪个位置。</strong>这个地址是在对象装载(Load)时由系统分配给的，当系统卸载时(Unload)又释放给系统。</p>
<p>句柄地址(稳定)→记载着对象在内存中的地址→对象在内存中的地址(不稳定)→实际对象</p>
<p><strong>本质：</strong>WINDOWS程序中并不是用物理地址来标识一个内存块，文件，任务或动态装入模块的，相反的，WINDOWS API给这些项目分配确定的句柄，并将句柄返回给应用程序，然后通过句柄来进行操作。</p>
<p>但是必须注意的是程序每次从新启动，系统不能保证分配给这个程序的句柄还是原来的那个句柄，而且绝大多数情况的确不一样的。假如我们把进入电影院看电影看成是一个应用程序的启动运行，那么系统给应用程序分配的句柄总是不一样，这和每次电影院售给我们的门票总是不同的一个座位是一样的道理。</p>
<p><code>线程</code> 是指程序的一个指令执行序列，WIN32 平台支持多线程程序，允许程序中存在多个线程。 在单 CPU 系统中，系统把 CPU 的时间片按照调度算法分配给各个线程，因此各线程实际上是分时执行的，在多 CPU 的 Windows NT 系统中， 同一个程序的不同线程可以被分配到不同的 CPU 上去执行。<em>由于一个程序的各线程是在相同的地址空间运行的，因此设及到了如何共享内存， 如何通信等问题，这样便需要处理各线程之间的同步问题，这是多线程编程中的一个难点。</em></p>
<blockquote>
<p>线程,也被称为轻量进程（lightweight processes）。计算机科学术语，指运行中的程序的调度单位。</p>
<p>线程是进程中的实体，一个进程可以拥有多个线程，一个线程必须有一个父进程。线程不拥有系统资源，只有运行必须的一些数据结构；它与父进程的其它线程共享该进程所拥有的全部资源。线程可以创建和撤消线程，从而实现程序的并发执行。一般，线程具有 <code>就绪</code> 、 <code>阻塞</code> 和 <code>运行</code> 三种基本状态。</p>
</blockquote>
<p>在多中央处理器的系统里，不同线程可以同时在不同的中央处理器上运行，甚至当它们属于同一个进程时也是如此。<strong><em>大多数支持多处理器的操作系统都提供编程接口来让进程可以控制自己的线程与各处理器之间的关联度（affinity）。</em></strong></p>
<p><code>进程</code> 是程序在一个数据集合上运行的过程(注:一个程序有可能同时属于多个进程),它是操作系统进行资源分配和调度的一个独立单位,进程可以简单的分为 <code>系统进程</code> (包括一般Windows程序和服务进程)和 <code>用户进程</code> 。</p>
<h2 id="预编译">预编译</h2>
<h3 id="error-预编译中断及错误提示">#Error 预编译中断及错误提示</h3>
<h4 id="encountered-with-text">Encountered with text</h4>
<p>错误信息会在预编译期遇到错误的时候停止并给出，也就是错误信息的上一条执行代码出现了错误。</p>
<p>而上一条代码是 <code>#if !defined( __BYTE_ADDRESSING__ ) &amp;&amp; defined ( __ADSPSHARC__ )</code> ，需要综合给出的错误提示 “Only Byte addressing mode is supported” 。</p>
<figure>
<img src="https://pic.islet.space/2021/05/20210520154529.png" alt="image-20210520154525815" /><figcaption aria-hidden="true">image-20210520154525815</figcaption>
</figure>
<h3 id="symbol-could-not-be-resolved">Symbol could not be resolved</h3>
<p>此类情况都是 “未定义” 或 “定义重复”。按住 <code>左ctrl</code> 并点击该定义可快速查看，是否定义或重复定义。</p>
<h4 id="重复定义">重复定义</h4>
<p>以下错误的出现则是因为出现了两处重复定义：</p>
<figure>
<img src="https://pic.islet.space/2021/05/20210520154609.png" alt="image-20210520154603077" /><figcaption aria-hidden="true">image-20210520154603077</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/05/20210524195016.png" alt="image-20210521093104044" /><figcaption aria-hidden="true">image-20210521093104044</figcaption>
</figure>
<h4 id="未定义">未定义</h4>
<p>NULL通常在 <code>&lt;stddef.h&gt;</code> （标准定义）头文件中给出，通常这些文件也被 <code>&lt;stdlib.h&gt;</code> 和 <code>&lt;stdio.h&gt;</code> 头文件引用。</p>
<figure>
<img src="https://pic.islet.space/2021/05/20210520154637.png" alt="image-20210520154631949" /><figcaption aria-hidden="true">image-20210520154631949</figcaption>
</figure>
<p>也可以进行自定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>以下代码源自 <code>&lt;stddef.h&gt;</code> :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (__cplusplus) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	</span></span><br></pre></td></tr></table></figure>
<p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/7433448/eclipse-cdt-symbol-null-could-not-be-resolved"><em>Eclipse CDT “Symbol NULL could not be resolved”</em></a></p>
<figure>
<img src="https://pic.islet.space/2021/05/image-20210520232442191.png" alt="image-20210520232442191" /><figcaption aria-hidden="true">image-20210520232442191</figcaption>
</figure>
<h2 id="error-li1050---multiply-defined-symbol">Error: li1050 - MULTIPLY DEFINED SYMBOL</h2>
<h3 id="错误编号">错误编号</h3>
<p><code>Error li1050</code></p>
<h3 id="解决方法">解决方法</h3>
<p>将错误提示中所涉及到的变量（<code>Tx_Count</code>）或函数（<code>initPLL_SDRAM()</code> 和 <code>Init_TWI()</code>）分离至单独的一个 <code>.c</code> 文件中，在名称对应的头文件中，仅做函数及变量的声明，详细内容不要写在头文件中。</p>
<p><mark>头文件中不能声明全局变量。</mark></p>
<figure>
<img src="https://pic.islet.space/2021/05/20210521163534.png" alt="image-20210521163422688" /><figcaption aria-hidden="true">image-20210521163422688</figcaption>
</figure>
<h3 id="实践">实践</h3>
<p>将错误提示中的变量或函数逐一移动到新的同名 <code>.c</code> 文件后，错误提示也在变少：</p>
<p><strong>减少一个</strong>：<img src="https://pic.islet.space/2021/05/20210524102039.png" alt="image-20210524100548198" /></p>
<p><strong>减少两个</strong>：<img src="https://pic.islet.space/2021/05/20210524102044.png" alt="image-20210524100816631" /></p>
<p><strong>问题解决</strong>：<img src="https://pic.islet.space/2021/05/20210524102048.png" alt="image-20210524101126445" /></p>
<p>解决方法的灵感来源于EZ论坛上的发言（以下回答其实也没细看）：</p>
<p><a target="_blank" rel="noopener" href="https://ez.analog.com/dsp/blackfin-processors/bf70x/f/q-a/12919/error-li1050-multiply-defined-symbol-in-processor-p0"><img src="https://pic.islet.space/2021/05/20210524102051.png" alt="image-20210524101743988" /></a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>感谢您的支持和鼓励</div>
  <button>
    Donate
  </button>
  <div class="post-reward">
      <div>
        <img src="https://photo.islet.space/2021/00/IMG_4588.JPG" alt="Liewzheng WeChat Pay">
        <span>WeChat Pay</span>
      </div>
      <div>
        <img src="https://photo.islet.space/2021/00/IMG_4590.JPG" alt="Liewzheng Alipay">
        <span>Alipay</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        

  <div id="vcomments" style="margin: 1rem 0 0 0;"></div>
  <script>
    new Valine({
      el: '#vcomments',
      appId: 'vRGM12EcYxDSM2lat5qjjSeY-gzGzoHsz',
      appKey: 'WBgAb6NTAFQ7DYtgH0uOPNNh'
    })
  </script>
          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/01/01/Others/2021-01-01-Phrases/" rel="prev" title="Phrases in Development">
                  <i class="fa fa-chevron-left"></i> Phrases in Development
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/01/15/Networking/2021-01-15-C-Socket/" rel="next" title="C socket">
                  C socket <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备19004822号 </a>
  </div>

<div class="copyright">
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liewzheng</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":"enable","tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
