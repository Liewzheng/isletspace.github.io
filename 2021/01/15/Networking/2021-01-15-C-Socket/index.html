<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://code.islet.space/font//css?family=/CascadiaCode/CascadiaCode:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"islet.space","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/db.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>
<meta name="description" content="TCP 在TCP&#x2F;IP协议族中，网络层IP提供的是一种不可靠的服务。也就是说，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。而另一方面，TCP在不可靠的IP层上提供了一个可靠的运输层。为了提供这种可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。由此可见，运输层和网络层分别负责不同的功能。 在四层网络结构，由下之上分别是：数据链路层、网络层、传输层及应用">
<meta property="og:type" content="article">
<meta property="og:title" content="C socket">
<meta property="og:url" content="http://islet.space/2021/01/15/Networking/2021-01-15-C-Socket/index.html">
<meta property="og:site_name" content="Coder的孤岛">
<meta property="og:description" content="TCP 在TCP&#x2F;IP协议族中，网络层IP提供的是一种不可靠的服务。也就是说，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。而另一方面，TCP在不可靠的IP层上提供了一个可靠的运输层。为了提供这种可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。由此可见，运输层和网络层分别负责不同的功能。 在四层网络结构，由下之上分别是：数据链路层、网络层、传输层及应用">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/TCPIP-01.png">
<meta property="og:image" content="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/20210218-03.png">
<meta property="og:image" content="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/20210218-02.png">
<meta property="og:image" content="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/20210218-01.png">
<meta property="og:image" content="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/70.jpg">
<meta property="og:image" content="http://tc.sinaimg.cn/maxwidth.2048/tc.service.weibo.com/community_emc_com/8ccefb660da3f07e9a83e0625c6c7f19.png">
<meta property="og:image" content="http://tc.sinaimg.cn/maxwidth.2048/tc.service.weibo.com/community_emc_com/1b59377ebee4107bed8557a6a4a9d35f.png">
<meta property="article:published_time" content="2021-01-15T15:58:32.000Z">
<meta property="article:modified_time" content="2021-10-14T16:12:40.360Z">
<meta property="article:author" content="Liewzheng">
<meta property="article:tag" content="Socket">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/TCPIP-01.png">


<link rel="canonical" href="http://islet.space/2021/01/15/Networking/2021-01-15-C-Socket/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://islet.space/2021/01/15/Networking/2021-01-15-C-Socket/","path":"2021/01/15/Networking/2021-01-15-C-Socket/","title":"C socket"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C socket | Coder的孤岛</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Coder的孤岛</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">islet of the coder</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-文章"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>文章</a></li>
        <li class="menu-item menu-item-目录"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-简历"><a href="/resume/" rel="section"><i class="fa fa-address-card fa-fw"></i>简历</a></li>
        <li class="menu-item menu-item-友链"><a href="/friends/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>友链</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#tcp"><span class="nav-number">1.</span> <span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-introduce"><span class="nav-number">1.1.</span> <span class="nav-text">TCP Introduce</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-structure20210218-03"><span class="nav-number">1.1.1.</span> <span class="nav-text">TCP Structure</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-flags"><span class="nav-number">1.1.2.</span> <span class="nav-text">TCP Flags</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-three-way-handshake"><span class="nav-number">1.2.</span> <span class="nav-text">TCP Three-Way Handshake</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#the-steps-of-three-way-handshake"><span class="nav-number">1.2.1.</span> <span class="nav-text">The Steps of Three-Way Handshake</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#the-meaning-of-three-way-handshake"><span class="nav-number">1.2.2.</span> <span class="nav-text">The Meaning of Three-way handshake</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-four-way-wavehand"><span class="nav-number">1.3.</span> <span class="nav-text">TCP Four-Way-Wavehand</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#the-meaning-of-four-way-wavehand"><span class="nav-number">1.3.1.</span> <span class="nav-text">The Meaning of Four-Way-Wavehand</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#the-steps-of-four-way-wavehand"><span class="nav-number">1.3.2.</span> <span class="nav-text">The Steps of Four-Way-Wavehand</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rst"><span class="nav-number">1.3.3.</span> <span class="nav-text">RST</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#differences-between-fin-and-rst"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">Differences between FIN and RST</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#why-do-we-send-rst"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">Why do we send RST?</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#wireshark-tutorial"><span class="nav-number">2.</span> <span class="nav-text">Wireshark Tutorial</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#capturing-filters-%E6%8D%95%E8%8E%B7%E8%BF%87%E6%BB%A4"><span class="nav-number">2.1.</span> <span class="nav-text">Capturing Filters 捕获过滤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#filtering-packets-while-capturing-%E6%8D%95%E8%8E%B7%E6%97%B6%E5%8F%AF%E7%94%A8%E7%9A%84%E8%BF%87%E6%BB%A4%E7%BB%84%E4%BB%B6"><span class="nav-number">2.1.1.</span> <span class="nav-text">Filtering packets while capturing 捕获时可用的过滤组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#some-common-examples-%E4%B8%80%E4%BA%9B%E9%80%9A%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">Some common examples 一些通用示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#capture-filter-syntax-%E6%8D%95%E8%8E%B7%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A0%87%E5%BF%97"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">Capture Filter Syntax 捕获过滤器标志</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#capturing-%E6%8D%95%E8%8E%B7"><span class="nav-number">2.2.</span> <span class="nav-text">Capturing 捕获</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#capture-options-%E6%8D%95%E8%8E%B7%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.2.1.</span> <span class="nav-text">Capture options 捕获设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#input-options-%E8%BE%93%E5%85%A5%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.2.2.</span> <span class="nav-text">Input options 输入设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filtering-options-%E8%BF%87%E6%BB%A4%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.2.3.</span> <span class="nav-text">Filtering options 过滤设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#storing-options-%E5%AD%98%E5%82%A8%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.2.4.</span> <span class="nav-text">Storing options 存储设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stop-condition-options-%E7%BB%88%E6%AD%A2%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.2.5.</span> <span class="nav-text">Stop condition options 终止设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#display-while-capturing-options"><span class="nav-number">2.2.6.</span> <span class="nav-text">Display while capturing options</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#high-performance-capturing-%E9%AB%98%E6%80%A7%E8%83%BD%E6%A8%A1%E5%BC%8F%E6%8D%95%E8%8E%B7"><span class="nav-number">2.2.7.</span> <span class="nav-text">High performance capturing 高性能模式捕获</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#long-term-capturing-%E9%95%BF%E6%9C%9F%E6%8D%95%E8%8E%B7"><span class="nav-number">2.2.8.</span> <span class="nav-text">Long term capturing 长期捕获</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#display-filter-%E6%98%BE%E7%A4%BA%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">2.3.</span> <span class="nav-text">Display Filter 显示过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#filtering-packets-while-viewing-%E8%A7%82%E5%AF%9F%E6%97%B6%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E7%BB%84%E4%BB%B6"><span class="nav-number">2.3.1.</span> <span class="nav-text">Filtering packets while viewing 观察时的过滤器组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6"><span class="nav-number">2.3.2.</span> <span class="nav-text">特殊字符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#constains-%E5%92%8C-matches"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">constains 和 matches</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#some-common-examples-%E4%B8%80%E4%BA%9B%E9%80%9A%E7%94%A8%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">2.3.3.</span> <span class="nav-text">Some common examples 一些通用示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hint"><span class="nav-number">2.3.4.</span> <span class="nav-text">Hint</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wireshark%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%87%E5%BF%97tcp"><span class="nav-number">2.4.</span> <span class="nav-text">WIRESHARK中的各种标志（TCP）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#out-of-order"><span class="nav-number">2.4.1.</span> <span class="nav-text">OUT OF ORDER</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#previous-segment-not-captured"><span class="nav-number">2.4.2.</span> <span class="nav-text">Previous segment not captured</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-dup-ack"><span class="nav-number">2.4.3.</span> <span class="nav-text">TCP DUP ACK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-fast-retransmission"><span class="nav-number">2.4.4.</span> <span class="nav-text">TCP Fast Retransmission</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-spurious-retransmission"><span class="nav-number">2.4.5.</span> <span class="nav-text">TCP Spurious Retransmission</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-retransmission"><span class="nav-number">2.4.6.</span> <span class="nav-text">TCP Retransmission</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-acked-unseen-segment"><span class="nav-number">2.4.7.</span> <span class="nav-text">TCP ACKed unseen segment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-zerowindow"><span class="nav-number">2.4.8.</span> <span class="nav-text">TCP Zerowindow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-window-update"><span class="nav-number">2.4.9.</span> <span class="nav-text">TCP Window Update</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">2.5.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ipv4%E6%98%A0%E5%B0%84"><span class="nav-number">2.5.1.</span> <span class="nav-text">IPv4映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E9%80%81%E5%9C%B0%E5%9D%80"><span class="nav-number">2.5.2.</span> <span class="nav-text">回送地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80"><span class="nav-number">2.5.3.</span> <span class="nav-text">专用网络地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#name"><span class="nav-number">2.5.4.</span> <span class="nav-text">Name</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#socket-in-posix"><span class="nav-number">3.</span> <span class="nav-text">Socket in Posix</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#headerfiles"><span class="nav-number">3.1.</span> <span class="nav-text">Headerfiles</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#socket-in-texas-instruments-sysbios"><span class="nav-number">4.</span> <span class="nav-text">Socket in Texas Instrument’s SysBIOS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#netctrl.h-%E5%8F%8A-socket.h"><span class="nav-number">4.1.</span> <span class="nav-text">NETCTRL.H 及 SOCKET.H</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#netctrl-api"><span class="nav-number">4.1.1.</span> <span class="nav-text">NETCTRL API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socket-api"><span class="nav-number">4.2.</span> <span class="nav-text">SOCKET API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#universal_tcp"><span class="nav-number">4.2.1.</span> <span class="nav-text">UNIVERSAL_TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#defined-in-ws2def.h"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">defined in &lt;ws2def.h&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defined-in-ti-socket.h"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">defined in TI &lt;socket.h&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ipv4%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.2.1.2.1.</span> <span class="nav-text">IPv4套接字地址数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%94%A8%E5%9C%B0%E5%9D%80%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.2.1.2.2.</span> <span class="nav-text">内核用地址存储数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80%E5%82%A8%E5%AD%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.2.1.2.3.</span> <span class="nav-text">通用套接字地址储存数据结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket-api-in-client"><span class="nav-number">4.2.2.</span> <span class="nav-text">SOCKET API IN CLIENT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">套接字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">文件描述符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#fd%E9%9B%86"><span class="nav-number">4.2.2.2.1.</span> <span class="nav-text">FD集</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E9%A1%BA%E5%BA%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.2.3.</span> <span class="nav-text">字节顺序转换函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timeval%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">4.2.2.4.</span> <span class="nav-text">timeval结构体</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket-api-in-server"><span class="nav-number">4.2.3.</span> <span class="nav-text">SOCKET API IN SERVER</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket-api-in-server-linux-c"><span class="nav-number">4.2.4.</span> <span class="nav-text">SOCKET API IN SERVER (LINUX C)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#daemon-api"><span class="nav-number">4.2.5.</span> <span class="nav-text">Daemon API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#netcfg.h"><span class="nav-number">4.3.</span> <span class="nav-text">NETCFG.H</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#configif.h"><span class="nav-number">4.4.</span> <span class="nav-text">CONFIGIF.H</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#configuration-%E7%89%B9%E6%80%A7"><span class="nav-number">4.4.1.</span> <span class="nav-text">Configuration 特性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#socket-in-windows"><span class="nav-number">5.</span> <span class="nav-text">Socket in Windows</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#send-blocking"><span class="nav-number">6.</span> <span class="nav-text">SEND() BLOCKING</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E5%8F%8A%E6%B5%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3io"><span class="nav-number">7.</span> <span class="nav-text">套接字及流输入输出接口(IO)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#open-fd-session"><span class="nav-number">7.1.</span> <span class="nav-text">Open FD Session</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liewzheng</p>
  <div class="site-description" itemprop="description">笔记分享的旮旯孤岛而已</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">106</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">195</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="mailto:liewzheng@foxmail.com" title="E-Mail → mailto:liewzheng@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/01/15/Networking/2021-01-15-C-Socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C socket
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-15 23:58:32" itemprop="dateCreated datePublished" datetime="2021-01-15T23:58:32+08:00">2021-01-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-10-15 00:12:40" itemprop="dateModified" datetime="2021-10-15T00:12:40+08:00">2021-10-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Networking/" itemprop="url" rel="index"><span itemprop="name">Networking</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="tcp">TCP</h1>
<p>在TCP/IP协议族中，网络层IP提供的是一种不可靠的服务。也就是说，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。而另一方面，TCP在不可靠的IP层上提供了一个可靠的运输层。为了提供这种可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。由此可见，运输层和网络层分别负责不同的功能。</p>
<p>在四层网络结构，由下之上分别是：<code>数据链路层</code>、<code>网络层</code>、<code>传输层</code>及<code>应用层</code>。</p>
<p><strong>数据链路层 </strong>协议典型如：Ethernet、ARP、ICMP</p>
<p><strong>网络层</strong> 协议典型如：IP</p>
<p><strong>传输层 </strong>协议典型如：TCP、UDP</p>
<p><strong>应用层</strong> 协议典型如：HTTP、FTP等</p>
<figure>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/TCPIP-01.png" alt="TCPIP-01" /><figcaption aria-hidden="true">TCPIP-01</figcaption>
</figure>
<p style="text-align: center; color: #999; font-weight: 600;">
图1-4 TCP/IP协议族中不同层次的协议
</p>
<p>为协议ICMP和IGMP定位一直是一件很棘手的事情。在图1-4中，把它们与IP放在同一层上，那是因为事实上它们是IP的附属协议。但是在这里，又把它们放在IP层的上面，这是因为ICMP和IGMP报文都被封装在IP数据报中。</p>
<p>使用TCP/IP协议的应用程序通常采用两种应用编程接口（API）：socket和TLI（运输层接口：Transport Layer Interface）。前者有时称作“Berkeley Socket”，表明它是从 <strong>伯克利</strong> 版发展而来的。后者起初是由AT&amp;T开发的，有时称作XTI（X/Open运输层接口），以承认X/Open这个自己定义标准的国际计算机生产商所做的工作。XTI实际上是TLI的一个超集。</p>
<h2 id="tcp-introduce">TCP Introduce</h2>
<p>TCP(Transmission Control Protocol)传输控制协议，是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。</p>
<h3 id="tcp-structure20210218-03">TCP Structure<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/20210218-03.png" alt="20210218-03" /></h3>
<figure>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/20210218-02.png" alt="20210218-02" /><figcaption aria-hidden="true">20210218-02</figcaption>
</figure>
<table>
<colgroup>
<col style="width: 44%" />
<col style="width: 11%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Definitions</th>
<th style="text-align: left;">Length</th>
<th>Explain</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">源端口 Source Port</td>
<td style="text-align: left;">16bits（2bytes）</td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: left;">目的端口 Destination Port</td>
<td style="text-align: left;">16bits（2bytes）</td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>序号 Sequence Number</strong></td>
<td style="text-align: left;">32bits（4bytes）</td>
<td>指定了当前数据分片中分配给 <mark>第一字节数据</mark> 的序列号。<strong><em>在TCP传输流中每一个字节为一个序号</em></strong>。如果TCP报文中flags标志位为SYN，该序列号表示 <strong><em>初始化序列号(ISN)</em></strong>，此时第一个数据应该是从序列号ISN+1开始。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>确认号 Acknowledgement Number</strong></td>
<td style="text-align: left;">32bits（4bytes）</td>
<td>表示TCP发送者期望接受下一个数据分片的序列号。该序号在TCP分片中Flags标志位为ACK时生效。序列号分片的方向和流的方向同方向，而确认序列号分片方向和流方向反方向。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><em>偏移量 Data-Offset</em></td>
<td style="text-align: left;">4bits</td>
<td>数据偏移也叫首部长度。<br/>因为首部长度实际也说明了数据区在分片中的起始偏移值。它表示TCP头包含了多少个32-bit的words。因为4bits在十进制中能表示的最大值为15，32bits表示4个字节，那么Data Offset的最大可表示<code>15*4=60</code>个字节（bytes）。<br />所以TCP报头长度最大为60字节。如果<code>options field</code>为0的话，报文头长度为20个字节。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>保留域 Reserved field</em></td>
<td style="text-align: left;">3bits（或6bits）</td>
<td>值全为零</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>标志位 Flags</strong></td>
<td style="text-align: left;">9bits（或6bits）</td>
<td>表示TCP包特定的连接状态，一个标签位占一个bit。</td>
</tr>
<tr class="even">
<td style="text-align: left;">窗口 Window</td>
<td style="text-align: left;">16bits（2bytes）</td>
<td>表示滑动窗口的大小，用来告诉发送端接收端的buffer space的大小。接收端buffer大小用来控制发送端的发送数据数率，从而达到流量控制。最大值为65535.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">检验和 Checksum</td>
<td style="text-align: left;">16bits（2bytes）</td>
<td>用来检查TCP头在传输中是否被修改。</td>
</tr>
<tr class="even">
<td style="text-align: left;">紧急指针 Urgent Pointer</td>
<td style="text-align: left;">16bits（2bytes）</td>
<td>表示TCP片中第一个紧急数据字节的指针。只有当URG标志置1时紧急指针才有效。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong><em>可变部分 Options Field</em></strong> 和 <strong><em>填充部分 Padding Field</em></strong></td>
<td style="text-align: left;">可变长度。</td>
<td>表示TCP可选选项以及填充位。当选项不足32bits时，填充字段加入额外的0填充。</td>
</tr>
</tbody>
</table>
<h3 id="tcp-flags">TCP Flags</h3>
<p>对于旧版本的TCP头定义，Flags有6bits，新版TCP头对flags扩展了3bits。每个TCP flag对应于1bit 。所以旧版TCP头flags值有6个，新版扩展了3个值。</p>
<p>从低位到高位分别是：</p>
<table>
<colgroup>
<col style="width: 49%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Definition</th>
<th>Declaration</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>FIN</strong><br/> (finished 结束)</td>
<td>表示发送者以及发送完数据。通常用在发送者发送完数据的最后一个包中。</td>
</tr>
<tr class="even">
<td><strong>SYN</strong><br/> (synchronous 建立联机)</td>
<td></td>
</tr>
<tr class="odd">
<td><strong>RST</strong><br/>(reset 重置)</td>
<td>重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。<br />或者发送包发送到一个不是期望的目的主机时，接收端发送reset 重置连接标志的包。</td>
</tr>
<tr class="even">
<td><strong>PSH</strong><br/> (push 传送)</td>
<td>通知接收端处理接收的报文，而不是将报文缓存到buffer中。</td>
</tr>
<tr class="odd">
<td><strong>ACK</strong><br/>(acknowledgement 确认)</td>
<td></td>
</tr>
<tr class="even">
<td><strong>URG</strong><br/> (urgent 紧急)</td>
<td>通知接收端处理在处理其他包前优先处理接收到的紧急报文。</td>
</tr>
<tr class="odd">
<td><strong>ECE</strong><br/> (Explicit Congestion Notification Echo) 【新】</td>
<td>表示TCP peer有ECN能力。</td>
</tr>
<tr class="even">
<td><strong>CWR</strong><br/>(Congestion Window Reduced)【新】</td>
<td>发送者在接收到一个带有ECE flag包时，将会使用CWR flag。</td>
</tr>
<tr class="odd">
<td><strong>NS</strong><br/> (Nonce Sum)【新】</td>
<td>该标签用来保护不受发送者发送的突发的恶意隐藏报文的侵害。</td>
</tr>
</tbody>
</table>
<p>TCP 连接的建立都是采用<code>客户-服务器(Client-Server)</code>方式：</p>
<ul>
<li>主动发起连接建立的应用进程叫做客户(client)。</li>
<li>被等待连接建立的应用进程叫做服务器(server)。</li>
</ul>
<p>传输连接就有三个阶段，即：<strong>连接建立</strong>、<strong>数据传输</strong> 和 <strong>连接释放</strong> 。</p>
<p>TCP 采用全双工模式，在连接建立后和连接释放前进行数据传输。数据传输是单向的，从发送端传输给接受端。TCP通过序列号能够保证数据被接受端接受。TCP建立连接是通过三次握手的方式来建立连接的。</p>
<h2 id="tcp-three-way-handshake">TCP Three-Way Handshake</h2>
<blockquote>
<p><strong>注意</strong>： 不管是大小写，<code>ack</code> ( 或 <code>Ack</code> )和 <code>ACK</code> 都是 <strong>确认</strong> 的意思， 不同之处在于：</p>
<ul>
<li>在TCP首部中，<code>ACK</code>为确认标志位 ——占 1 字节，只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。；</li>
<li><code>Ack</code>为确认号字段（Ack Number）——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。</li>
</ul>
</blockquote>
<h3 id="the-steps-of-three-way-handshake">The Steps of Three-Way Handshake</h3>
<p><strong>第一次握手：</strong>Client发送位码为<code>SYN＝1</code> ，随机产生 <code>seq number=1234567</code> 的数据包到服务器，Server收到 <code>SYN=1</code>，知道Client要求建立联机；</p>
<p><strong>第二次握手：</strong>Server收到请求后要确认联机信息，向Client发送<code>ack number=(Client的seq+1)</code>，<code>SYN=1</code>， <code>ACK=1</code> ，随机产生 <code>seq number=7654321</code> 的包；</p>
<p><strong>第三次握手：</strong>Client 收到后检查 <code>ack number</code> 是否正确，即第一次发送的seq number+1，以及位码 <code>ACK</code>是否为 1，若正确，Client 会再发送 <code>ack number=(主机B的seq+1)</code> ，<code>ACK=1</code>，Server 收到后确认<code>seq number</code> 值与<code>ACK=1</code>则连接建立成功。</p>
<p>完成三次握手，主机A与主机B开始传送数据。</p>
<pre class="mermaid">sequenceDiagram
Client ->> Server: SYN=1  [seq number=1234567]
Server -->> Client: SYN = 1, ACK = 1  [ack number = 1234568，seq number = 7654321]
Client ->> Server: ACK = 1 [ack number = 7654322]</pre>
<p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。 <strong>第一次握手：</strong>建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； <strong>第二次握手：</strong>服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； <strong>第三次握手：</strong>客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据.</p>
<h3 id="the-meaning-of-three-way-handshake">The Meaning of Three-way handshake</h3>
<p>向客户端确认这个请求，这两个数据包（前两次握手）足以证明客户端与服务器之间的网络是畅通的，并且协商数据通信所需要的参数。比如协商接收窗口大小，所支持的数据包最大字节数等。</p>
<p>如果没有最后一个数据包确认（第三次握手），A先发出一个建立连接的请求数据包，由于网络原因绕远路了。A经过设定的超时时间后还未收到B的确认数据包，于是发出第二个建立连接的请求数据包，这次网路通畅，数据包很快到达B，B的确认数据包也很快就到达A。于是A与B开始传输数据，过了一会A第一次发出的建立连接的请求数据包到达了B，B以为是再次建立连接，所以又发出一个确认数据包。由于A已经收到了一个确认数据包，所以会忽略B发来的第二个确认数据包，但是B发出确认数据包之后就要一直等待A的回复，而A永远也不会回复。由此造成服务器资源浪费，这种情况多了B计算机可能就停止响应了。</p>
<p>第三次握手（第三个数据包）作用在于，告诉B计算机，B第二次握手发给A的确认数据包A收到了，是有效的。避免B计算机等待造成资源浪费。随后A与B可进行下一步的通信。</p>
<p><strong>连接建立 </strong>过程中要解决以下三个问题：</p>
<ul>
<li>要使每一方能够确知对方的存在。</li>
<li>要允许双方协商一些参数（如 <code>最大报文段长度</code>，<code>最大窗口大小</code>，<code>服务质量</code> 等）。</li>
<li>能够对运输实体资源（如 <code>缓存大小</code>，<code>连接表中的项目</code> 等）进行分配。</li>
</ul>
<p><strong>连接建立过程中，客户端存在以下状态：</strong></p>
<p><strong>SYN-SENT：</strong>在未与目标服务器建立连接之前始终处于此状态，并将不断向目标服务器发送请求，直到 <code>收到</code> 并 <code>回复</code> 来自服务器的信息后，方进入下一个状态。 <strong>ESTABLISHED：</strong>稳定连接状态。</p>
<p><strong>连接建立过程中，服务器存在以下状态：</strong></p>
<p><strong>LISTEN：</strong> 在未与客户端建立连接之前，始终处于此状态，在收到客户端的连接请求后答复其请求，并进入下一个状态。 <strong>SYN-RCVD：</strong> 等待SYN信息到达后进入下一个状态。 <strong>ESTABLISHED：</strong>稳定连接状态。</p>
<figure>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/20210218-01.png" alt="20210218-01" /><figcaption aria-hidden="true">20210218-01</figcaption>
</figure>
<p><strong>连接建立文字图解：</strong></p>
<blockquote>
<p>Client 发出 <code>同步数据包（请求建立连接的数据包）</code> 并进入SYN-SENT状态。</p>
<ul>
<li>SYN = 1， 表示该为一个连接建立请求数据包；</li>
<li>ACK = 0，说明数据包确认号无效，省略；</li>
<li>Seq=x，x为所传送数据的第一个字节的序号。</li>
</ul>
<p>Server 收到Client发出的 <code>同步数据包</code> 后结束LISTEN状态，进入SYN-RCVD状态并向A发出 <code>确认同步数据包</code>。</p>
<ul>
<li>SYN=1；</li>
<li>ACK=1；</li>
<li>seq=y，y的值由B指定表示B发送数据时的 <strong><em>第一个数据字节的序号</em></strong> ；</li>
<li>ack=x+1，表示已经收到A发送的x个字节数据，并告诉A下次应从数据的第x+1个字节开始发送。</li>
</ul>
<p>Client 收到<code>确认同步数据包</code>之后，向B答复 <code>确认数据包</code> ，结束 SYN-SENT 状态，进入 ESTABLISHED 状态。</p>
<ul>
<li>SYN=0，表示双方已同意建立连接；</li>
<li>ACK=1，表示收到B的确认数据包；</li>
<li>seq=x+1，表示发出的数据包就是数据的第x+1个字节；</li>
<li>ack=y+1，表示收到了B发送y字节数据，并告诉B下次应从数据的第y+1个字节开始发送。</li>
</ul>
<p>Server 收到 Client 的 <code>确认数据包</code> 之后，结束SYN-RCVD状态，进入ESTABLISHED状态。</p>
</blockquote>
<h2 id="tcp-four-way-wavehand">TCP Four-Way-Wavehand</h2>
<p>结束连接时，不管是Client或Server均可以主动发起结束信标FIN或RST。此处称主动发起结束信标的一方为主动方，另一方为被动方。</p>
<h3 id="the-meaning-of-four-way-wavehand">The Meaning of Four-Way-Wavehand</h3>
<p>当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。</p>
<p>但未必被动方所有的数据都完整的发送给了主动方，所以 <mark>被动方不会马上关闭SOCKET</mark>，它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。</p>
<h3 id="the-steps-of-four-way-wavehand">The Steps of Four-Way-Wavehand</h3>
<ol type="1">
<li><p><strong>第一次挥手：</strong>Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入 <code>FIN_WAIT_1</code> 状态。</p></li>
<li><p><strong>第二次挥手：</strong>Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入`<code>CLOSE_WAIT</code> 状态。</p></li>
<li><p><strong>第三次挥手：</strong>Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入 <code>LAST_ACK</code> 状态。</p></li>
<li><p><strong>第四次挥手：</strong>Client收到FIN后，Client进入`<code>TIME_WAIT</code> 状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入 <code>CLOSED</code> 状态，完成四次挥手</p></li>
</ol>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/70.jpg" style="zoom:50%;" /></p>
<h3 id="rst">RST</h3>
<h4 id="differences-between-fin-and-rst">Differences between FIN and RST</h4>
<blockquote>
<p><strong>关键字：</strong> 主动释放、有序释放、终止释放</p>
</blockquote>
<p><strong>释放</strong> 即发送方和接收方终止连接，解除连接状态。</p>
<p>发送方和接收方均可主动释放。最常见的是，主动释放端会发送<code>FIN</code>包，并且因为TCP是双工的， 仅关闭一个方向上的数据流，从而TCP连接处于<strong>半关闭状态</strong>，继续完成四次挥手完成连接释放。</p>
<p>上述挥手是一种 <strong>有序释放</strong> ， 即，标志位为<code>FIN</code>的TCP报文会在之前所有排队的数据发送完之后，才会发送，在socket缓冲区和窗口中的数据也能保证发送成功。</p>
<p>通常我们调用 <code>shutdown()</code> , <code>close()</code> 函数后， TCP会发送<code>FIN</code>报文。</p>
<blockquote>
<p>shutdown 和 close 的区别：</p>
<ul>
<li>shutdown是关闭一个socket， 可以关闭读、写、读写；</li>
<li>close是关闭一个linux系统的文件描述符fd。</li>
</ul>
</blockquote>
<p>除了“有序释放”， 还有一种 <strong>终止释放</strong> ，比如进程异常退出，用来关闭异常连接使用，是通过 <code>RST</code> 标志位实现的。 标志位为 <code>RST</code> 的TCP报文，会立即发送，<u>而之前所有在缓存区排队的数据都将被RST发送方丢弃。</u></p>
<p><mark>FIN报文需要应答 <code>ACK</code> , RST报文不需要应答 <code>ACK</code>。</mark></p>
<p><strong>半开连接</strong>：如果发生断点，或网络条件很差，其中一端发送 <code>RST</code> 后会立马关闭连接；而另一端可能感知不到，仍然认为连接正常，造成一种半开连接的状态。</p>
<h4 id="why-do-we-send-rst">Why do we send RST?</h4>
<p>RST标志位被发送，通常是因为一下几种原因：</p>
<blockquote>
<ol type="1">
<li>A向B发起连接，但B之上并没有应用监听相应的端口，这时B操作系统上的TCP处理程序会发RST包。</li>
<li>请求超时，即由于主动连接端连接请求超时，主动发起RST关闭连接。</li>
<li>在一个已关闭的socket上收到数据</li>
<li>字节流接收不完全</li>
</ol>
</blockquote>
<p><strong>情况二：</strong> 有89、27两台主机。主机89向主机27发送了一个SYN，表示希望连接8888端口，主机27回应了主机89一个SYN表示可以连接。但是主机89却很不友好，莫名其妙的发送了一个RST表示我不想连接你了。 后来经过排查发现，在主机89上的程序在建立了socket之后，用setsockopt的SO_RCVTIMEO选项设置了recv的超时时间为100ms。而我们看上面的抓包结果表示，从主机89发出SYN到接收SYN的时间多达110ms。（从15:01:27.799961到15:01:27.961886， 小数点之后的单位是微秒）。因此主机89上的程序认为接收超时，所以发送了RST拒绝进一步发送数据。</p>
<p><strong>情况三：</strong> 比如，AB正常建立连接了，正在通讯时，A向B发送了FIN包要求关连接，B发送ACK后，网断了，A通过若干原因排查后放弃了这个连接（例如进程重启）。网通了后，B又开始发数据包，A收到后表示压力很大，不知道这野连接哪来的，就发了个RST包强制把连接关了，B收到后会出现connect reset by peer错误。</p>
<h1 id="wireshark-tutorial">Wireshark Tutorial</h1>
<p>Wireshark是一款可以监听和捕捉网络通信数据的软件，对捕获的数据自下而上进行解码和分析至已知协议。如(Ethernet II -- IP -- TCP 或 Ethernet II -- IP -- TCP -- HTTP)。</p>
<p>Wireshark主要通过 <strong>捕获过滤</strong> 和 <strong>显示过滤</strong> 对所有数据进行 <strong>捕获时过滤</strong> 或 <strong>捕获后显示过滤</strong>。</p>
<h2 id="capturing-filters-捕获过滤">Capturing Filters 捕获过滤</h2>
<h3 id="filtering-packets-while-capturing-捕获时可用的过滤组件">Filtering packets while capturing 捕获时可用的过滤组件</h3>
<p>Capture Filters are used to filter out uninteresting packets already at capture time. This is done to reduce the size of the resulting capture (file) and is especially useful on high traffic networks or for long term capturing.</p>
<p>Wireshark uses the pcap (libpcap/WinPcap) filter language for capture filters. This language is explained in the tcpdump man page under "expression" (http://www.tcpdump.org and search for "selects which").</p>
<p>Note: This capture filter language is different from the one used for the Wireshark display filters!</p>
<p>捕获过滤器的使用方式为：菜单栏上的 <code>捕获</code> --&gt; <code>选项</code> --&gt; <code>所选择接口的捕获过滤器</code> 中输入对应的过滤条件。</p>
<hr />
<h4 id="some-common-examples-一些通用示例">Some common examples 一些通用示例</h4>
<p><strong>Example Ethernet:</strong> capture all traffic to and from the Ethernet address 08:00:08:15:ca:fe</p>
<p>ether <code>host 08:00:08:15:ca:fe</code></p>
<p><strong>Example IP:</strong> capture all traffic to and from the IP address 192.168.0.10</p>
<p><code>host 192.168.0.10</code></p>
<p><strong>Example TCP:</strong> capture all traffic to and from the TCP port 80 (http) of all machines</p>
<p><code>tcp port 80</code></p>
<p><strong>Examples combined:</strong> capture all traffic to and from 192.168.0.10 except http</p>
<p><code>host 192.168.0.10 and not tcp port 80</code></p>
<p>Beware: if you capture TCP/IP traffic with the primitives "host" or "port", you will not see the ARP traffic belonging to it!</p>
<hr />
<h4 id="capture-filter-syntax-捕获过滤器标志">Capture Filter Syntax 捕获过滤器标志</h4>
<p>The following is a short description of the capture filter language syntax. For a further reference, have a look at: http://www.tcpdump.org/tcpdump_man.html</p>
<p>A capture filter takes the form of a series of <strong>primitive expressions</strong>, connected by conjunctions (and/or) and optionally preceded by not:</p>
<p><strong>[not] primitive [and|or [not] primitive ...]</strong></p>
<p>A primitive is simply one of the following:</p>
<p><strong>[src|dst] host <host></strong></p>
<p>This primitive allows you to filter on a host IP address or name. You can optionally precede the primitive with the keyword <code>src|dst</code> to specify that you are only interested in source or destination addresses. If these are not present, packets where the specified address appears as either the source or the destination address will be selected.</p>
<p><strong>ether [src|dst] host <ehost></strong></p>
<p>This primitive allows you to filter on Ethernet host addresses. You can optionally include the keyword <code>src|dst</code> between the keywords ether and host to specify that you are only interested in source or destination addresses. If these are not present, packets where the specified address appears in either the source or destination address will be selected.</p>
<p><strong>gateway host <host></strong></p>
<p>This primitive allows you to filter on packets that used host as a gateway. That is, where the Ethernet source or destination was host but neither the source nor destination IP address was host.</p>
<p><strong>[src|dst] net <net> [{mask <mask>}|{len <len>}]</strong></p>
<p>This primitive allows you to filter on network numbers. You can optionally precede this primitive with the keyword <code>src|dst</code> to specify that you are only interested in a source or destination network. If neither of these are present, packets will be selected that have the specified network in either the source or destination address. In addition, you can specify either the netmask or the <strong>CIDR</strong> <em>(Classless Inter-Domain Routing)</em> prefix for the network if they are different from your own.</p>
<p><strong>[tcp|udp] [src|dst] port <port></strong></p>
<p>This primitive allows you to filter on TCP and UDP port numbers. You can optionally precede this primitive with the keywords src|dst and tcp|udp which allow you to specify that you are only interested in source or destination ports and TCP or UDP packets respectively. The keywords tcp|udp must appear before src|dst. If these are not specified, packets will be selected for both the TCP and UDP protocols and when the specified address appears in either the source or destination port field.</p>
<p><strong>less|greater <length></strong></p>
<p>This primitive allows you to filter on packets whose length was less than or equal to the specified length, or greater than or equal to the specified length, respectively.</p>
<p><strong>ip|ether proto <protocol></strong></p>
<p>This primitive allows you to filter on the specified protocol at either the Ethernet layer or the IP layer.</p>
<p>ether|ip broadcast|multicast</p>
<p>This primitive allows you to filter on either Ethernet or IP broadcasts or multicasts.</p>
<p><strong><expr> relop <expr></strong></p>
<p>This primitive allows you to create complex filter expressions that select bytes or ranges of bytes in packets. Please see the tcpdump man pages for more details.</p>
<h2 id="capturing-捕获">Capturing 捕获</h2>
<p>This section will explain the capturing options and give hints on what to do in some special cases.</p>
<h3 id="capture-options-捕获设置">Capture options 捕获设置</h3>
<p>The capture options can be logically divided into the following categories:</p>
<p>-input -filtering -stop conditions -storing -display while capturing</p>
<h3 id="input-options-输入设置">Input options 输入设置</h3>
<p><strong>-Interface</strong>: You have to choose which interface (network card) will be used to capture packets from. Be sure to select the correct one, as it's a common mistake to select the wrong interface.</p>
<p><strong>-Link-layer header type</strong>: unless you are in the rare case that you will need this, just keep the default.</p>
<h3 id="filtering-options-过滤设置">Filtering options 过滤设置</h3>
<p><strong>-Capture packets in promiscuous mode</strong>: Usually a network card will only capture the traffic to its own network address. If you want to capture all traffic that the network card can "see", mark this option. See the FAQ for some more details of capturing packets from a switched network.</p>
<p><strong>-Limit each packet to xy bytes</strong>: Will limit the maximum size to be captured of each packet, this includes the link-layer header and all subsequent headers. This can be useful when an error is known to be in the first 20 bytes of a packet, for example, as the size of the resulting capture file will be reduced.</p>
<p><strong>-Capture Filter</strong>: Use a capture filter to reduce the amount of packets to be captured. See "Capture Filters" in this help for further information how to use it.</p>
<h3 id="storing-options-存储设置">Storing options 存储设置</h3>
<p><strong>-File</strong>: You can choose the file to which captured data will be written. If you don't enter something here a temporary file will be used.</p>
<p><strong>-Use multiple files</strong>: Instead of using a single capture file, multiple files will be created. The generated filenames will contain an incrementing number and the start time of the capture. For example, if you choose "/foo.cap" in the "File" field, files like "/foo_00001_20040205110102.cap", "/foo_00002_20040205110102.cap", ... will be created. This feature can be useful if you do long term capturing, as working with a single capture file of several GB usually isn't very fast.</p>
<h3 id="stop-condition-options-终止设置">Stop condition options 终止设置</h3>
<p>These three fields should be obvious; the capture process will be automatically stopped if one of the selected conditions is exceeded.</p>
<h3 id="display-while-capturing-options">Display while capturing options</h3>
<p>-Update list of packets in real time: Using this will show the captured packets immediately on the main screen. Please note: this will slow down capturing, so increased packet drops might appear.</p>
<p>-Automatic scrolling in live capture: This will scroll the "Packet List" automatically to the latest captured packet, when the "Update List of packets in real time" option is used.</p>
<p>-Name resolution: perform the corresponding name resolution while capturing.</p>
<h3 id="high-performance-capturing-高性能模式捕获">High performance capturing 高性能模式捕获</h3>
<p>When your network traffic is high, you might need to take some steps to ensure Wireshark doesn't get behind on its capture, particularly if you're running it on a slow computer.</p>
<p>When Wireshark cannot keep up, packets are dropped. To help avoid this as much as possible:</p>
<ol type="a">
<li><p>Don't use the "Update list of packets in real time" option (see above). This has a significant performance penalty.</p></li>
<li><p>Close other programs that might slow down your system, such as virus scanner software, server processes, etc.</p></li>
<li><p>It might be a good idea not to use a capture filter. This will depend on the task you have to do. As a rule of thumb: if you want to see most of the packets and only filter a small number out, don't use a capture filter (you can use a display filter later). If you only want to capture a small proportion of the packets, it might be better to set a capture filter, as this will reduce the number of packets that have to be saved.</p></li>
<li><p>If you still get packet drops, it might be an idea to use a tool dedicated to packet capturing and only use Wireshark for displaying and analyzing the packets.</p></li>
</ol>
<p>Have a look at tshark, the command line variant of wireshark, which is included in this package. XXX: add a list of possibly useful standalone capture programs.</p>
<h3 id="long-term-capturing-长期捕获">Long term capturing 长期捕获</h3>
<p>By "Long term capturing", it's meant to capture data from a network for several hours or even days. Long term capturing will usually result in huge capture files, being hundreds of MB's or even several GB's in size!</p>
<p>Before doing a long term capture, get familiar with the options to use for it, as you might not get what you desire. Doing a long term capture not getting the results needed, is usually wasting a lot of time. ;-)</p>
<p>Rules of thumb for this task: -Use the ring buffer feature when you expect very large capture files. -Don't use the "Update list of packets in real time" option. -Set an appropriate capture filter, when you are only interested in some special packets from the net.</p>
<h2 id="display-filter-显示过滤器">Display Filter 显示过滤器</h2>
<h3 id="filtering-packets-while-viewing-观察时的过滤器组件">Filtering packets while viewing 观察时的过滤器组件</h3>
<p>After capturing packets or loading some network traffic from a file, Wireshark will display the packet data immediately on the screen.</p>
<p>Using display filters, you can choose which packets should (not) be shown on the screen. This is useful to reduce the "noise" usually on the network, showing only the packets you want to. So you can concentrate on the things you are really interested in.</p>
<p>The display filter will not affect the data captured, it will only select which packets of the captured data are displayed on the screen.</p>
<p>Every time you change the filter string, all packets will be reread from the capture file (or from memory), and processed by the display filter "machine". Packet by packet, this "machine" is asked, if this particular packet should be shown or not.</p>
<p>Wireshark offers a very powerful display filter language for this. It can be used for a wide range of purposes, from simply: "show only packets from a specific IP address", or on the other hand, to very complex filters like: "find all packets where a special application specific flag is set".</p>
<p>Note: This display filter language is different from the one used for the Wireshark capture filters!</p>
<h3 id="特殊字符">特殊字符</h3>
<h4 id="constains-和-matches">constains 和 matches</h4>
<p><strong>contains</strong> 用来判断是否包含一个值，<strong>matches</strong> 用来判断是否匹配一个表达式</p>
<hr />
<h3 id="some-common-examples-一些通用示例-1">Some common examples 一些通用示例</h3>
<p><strong>Example Ethernet</strong>: display all traffic to and from the Ethernet address 08.00.08.15.ca.fe</p>
<p><code>eth.addr==08.00.08.15.ca.fe</code></p>
<p><strong>Example IP</strong>: display all traffic to and from the IP address 192.168.0.10</p>
<p><code>ip.addr==192.168.0.10</code></p>
<p><strong>Example TCP</strong>: display all traffic to and from the TCP port 80 (http) of all machines</p>
<p><code>tcp.port==80</code></p>
<p><strong>Examples combined</strong>: display all traffic to and from 192.168.0.10 except http</p>
<p><code>ip.addr==192.168.0.10 &amp;&amp; tcp.port!=80</code></p>
<p>Beware: The filter string builds a logical expression, which must be true to show the packet. The &amp;&amp; is a "logical and", "A &amp;&amp; B" means: A must be true AND B must be true to show the packet (it doesn't mean: A will be shown AND B will be shown).</p>
<hr />
<h3 id="hint">Hint</h3>
<p>Filtering can lead to side effects, which are sometimes not obvious at first sight. Example: If you capture TCP/IP traffic with the primitive "ip", you will not see the ARP traffic belonging to it, as this is a lower protocol layer than IP!</p>
<h2 id="wireshark中的各种标志tcp">WIRESHARK中的各种标志（TCP）</h2>
<h3 id="out-of-order">OUT OF ORDER</h3>
<p><code>TCP Out-of-Order</code></p>
<p><strong>正常情况：</strong>在TCP传输过程中，同一台主机发出的数据段应该是连续的，即后一个包的 <code>Seq</code> 号等于前一 个包的 <code>Seq</code> + <code>Len</code> （三次握手和四次挥手是例外）。</p>
<p>异常情况：当Wireshark发现后一个包的 <code>Seq</code> 号 <mark>小于</mark> 前一个包的 <code>Seq</code> + <code>Len</code> 时，就会认为是乱序了，因此提示 <code>TCP Out-of-Order</code> 。</p>
<h3 id="previous-segment-not-captured">Previous segment not captured</h3>
<p><code>Previous segment not capturedd</code> ，即报文缺失，指存在未抓取的数据包</p>
<p><strong>正常情况：</strong>在TCP传输过程中，同一台主机发出的数据段应该是连续的，即后一个包的 <code>Seq</code> 号等于前一个包的 <code>Seq</code> + <code>Len</code> （三次握手和四次挥手是例外）。</p>
<p><strong>异常情况：</strong>如果Wireshark发现后一个包的 <code>Seq</code> 号大于前一个包的 <code>Seq</code> + <code>Len</code> ，就知道中间缺失了一段数据。假如缺失的那段数据在整个网络包中都找不到（即排除了乱序），就会提示<code>TCP Previous segment not captured</code> 。</p>
<blockquote>
<p><strong>TCP Previous segment lost</strong> - Occurs when a packet arrives with a sequence number greater than the "next expected sequence number" on that connection, indicating that one or more packets prior to the flagged packet did not arrive. This event is a good indicator of packet loss and will likely be accompanied by "TCP Retransmission" events.</p>
<p>-- Wireshark</p>
</blockquote>
<h3 id="tcp-dup-ack">TCP DUP ACK</h3>
<p><code>Tcp Dup Ack xxx#y</code> ，即重复确认。</p>
<p>当乱序或者丢包发生时，接收方会收到一些Seq号比期望值大的包。</p>
<p><u>接收方每收到一个这种包就会进行答复，<code>Ack</code> 一次期望的 <code>Seq</code> 值，以此方式来提醒发送方，于是就产生了一些重复的 <code>Ack</code> 。</u></p>
<p>Wireshark会在这种重复的Ack上标记 <code>TCP Dup ACK</code> ，代表了数据段丢失 TCP 状态，<code>xxx</code> 代表数据丢失的位置， <code>y</code> 后代表第几次丢失报文。</p>
<h3 id="tcp-fast-retransmission">TCP Fast Retransmission</h3>
<p>快速重传，当发送方收到来自接收方的3个或以上<code>TCP Dup ACK</code> ，就意识到之前发的包可能丢了，于是发送方快速重传该数据（这是RFC的规定）。</p>
<h3 id="tcp-spurious-retransmission">TCP Spurious Retransmission</h3>
<h3 id="tcp-retransmission">TCP Retransmission</h3>
<p>超时重传。</p>
<p>如果一个包真的丢了，且无后续包，则可以在接收方触发 <code>Dup Ack</code> ，就不会快速重传。</p>
<p>这种情况下发送方只好等到超时了再重传，此类重传包就会被Wireshark标上 <code>TCP Retransmission</code> 。</p>
<h3 id="tcp-acked-unseen-segment">TCP ACKed unseen segment</h3>
<p>抓取遗漏。</p>
<p>当Wireshark发现被Ack的那个包没被抓到，就会提示 <code>TCP ACKed unseen  segment</code>， 即此为由于抓包不到造成的报错。</p>
<p><em>这可能是最常见的Wireshark提示了，幸好它几乎是永远可以忽略的。</em></p>
<p>以图3为例，32号包的<code>Seq=6889</code> <code>Len=1448</code> ，相加得 8337，说明服务器发出的下一个包应该是 <code>Seq=8337</code>。而我们看到的却是35号包的<code>Seq=11233</code>，这意味着 8337～11232 这段数据没有被抓到。这段数据本应该出现在34号之前，所以Wireshark提示了<code>TCP ACKed unseen segment</code>。</p>
<p><img src="http://tc.sinaimg.cn/maxwidth.2048/tc.service.weibo.com/community_emc_com/8ccefb660da3f07e9a83e0625c6c7f19.png" style="zoom:150%;" /></p>
<h3 id="tcp-zerowindow">TCP Zerowindow</h3>
<p>窗口清零。</p>
<p>TCP包中的 <code>win=</code> 代表接收窗口的大小，即表示这个包的发送方当前还有多少缓存区可以接收数据。</p>
<p>当Wireshark在一个包中发现 <code>win=0</code> 时，就会给它打上 <code>TCP  zerowindow</code> 的标志，表示缓存区已满，不能再接受数据了。下图就是服务器的缓存区已满，所以通知客户端不要再发数据了。我们甚至可以在3258～3263这几个包中看出它的窗口逐渐减少的过程，即从 <code>win=15872</code> 减小到 <code>win=1472</code> 。</p>
<p><img src="http://tc.sinaimg.cn/maxwidth.2048/tc.service.weibo.com/community_emc_com/1b59377ebee4107bed8557a6a4a9d35f.png" style="zoom:150%;" /></p>
<h3 id="tcp-window-update">TCP Window Update</h3>
<h2 id="其他">其他</h2>
<p>Sockets API和Internet在许多 <strong><em>竞争性协议族</em></strong>（包括 <em>IPX</em>、<em>AppleTalk</em>、<em>DECNet</em>、<em>OSI</em>、<em>SNA</em> 及 <em>TCP</em>/IP）的世界中逐渐成长起来，并且 <mark>Sockets被设计成支持所有这些协议</mark> 。</p>
<h3 id="ipv4映射">IPv4映射</h3>
<p>IPv4映射的地址是通过在IPv4地址前添加4个字节的前缀 <code>::fff:</code> 而构成。</p>
<p>如，<code>132.3.23.7</code> 的IPv4地址映射至IPv6即 <code>::ffff:132.3.32.7</code> 。</p>
<p>协议互操作性</p>
<h3 id="回送地址">回送地址</h3>
<p>IPv4的回送地址是<code>127.0.0.1</code></p>
<p>IPv6的回送地址是 <code>0:0:0:0:0:0:0:1</code></p>
<h3 id="专用网络地址">专用网络地址</h3>
<p>以 <code>10</code> 、<code>192.168</code> 、<code>172.16</code>~<code>172.31</code>开头的地址最初被指定在不属于全球Internet的专用网络中使用。</p>
<h3 id="name">Name</h3>
<p>Hostname是指 <em>计算机名称</em> ，Domain Name是指 <em>域名</em> 。</p>
<p>通常情况下，一个name都是指Hostname。</p>
<h1 id="socket-in-posix">Socket in Posix</h1>
<h2 id="headerfiles">Headerfiles</h2>
<p>在Posix标准中，以下文件被用于在Unix/Linux/Mac中进行网络编程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>各文件包含的内容如下：</p>
<ul>
<li><p><code>&lt;sys/types.h&gt;</code> 定义了在socket网络编程中用到的数据类型；</p></li>
<li><p><code>&lt;sys/socket.h&gt;</code> 定义了接口类型（socket types）、接口标志（socket flags）、额外设置（addtional options）、地址簇（address family）和地址存储结构体（address storage structure）特定机器的一些设定。</p></li>
<li><p><code>&lt;netinet/in.h&gt;</code> 定义了RFC协议（protocol），和IP网络层相关的宏定义。其中 <code>in</code> 是 internet 的缩写。</p></li>
<li><p><code>&lt;arpa/inet.h&gt;</code> 则定义了对网络层操作的函数，例如，“将host地址与net地址互相转换” 的 <code>htonl()</code> 、 <code>htons()</code> 、 <code>ntohl()</code> 、<code>ntohs()</code> 都定义在里面，还有 <code>inet_addr()</code> 、 <code>*inet_ntoa()</code>、<code>*inet_ntop()</code> 、<code>inet_pton()</code> 等操作</p></li>
<li><p><code>&lt;netdb.h&gt;</code> 定义了网络数据库（network database）的操作， 相关手册可以查看 Michael 的 <a target="_blank" rel="noopener" href="https://www.man7.org/linux/man-pages/man0/netdb.h.0p.html">在线手册</a>。</p></li>
<li><p><code>&lt;unistd.h&gt;</code> 定义了系统线程、文件读取等的操作和宏定义。</p></li>
<li><p><code>&lt;errno.h&gt;</code> 定义了 普通文件操作和网路文件操作的错误码（error codes）。</p></li>
</ul>
<h1 id="socket-in-texas-instruments-sysbios">Socket in Texas Instrument’s SysBIOS</h1>
<h2 id="netctrl.h-及-socket.h">NETCTRL.H 及 SOCKET.H</h2>
<p>以下两句话是TI官方对<code>&lt;netctrl.h&gt;</code> 的描述，即简易控制网络开断的包装函数，以此类方法实现接口的目的是隐藏可以被调用的HAL/STACK功能</p>
<blockquote>
<ul>
<li>Shell functions for simplified net startup and shutdown</li>
<li>The idea behind this API is to hide the user callable HAL/STACK functions</li>
</ul>
</blockquote>
<p><code>&lt;netctrl.h&gt;</code> 是用于初始化和维护服务的。为了完成此功能，其调用了NETTOOLS库提供的配置管理器。要注意的是，此处的配置定义和结构声明是对针对NETCTRL 的，而不是针对 CONFIG。</p>
<blockquote>
<p>NETCTRL is used to initialize the stack and maintain services. To accomplish this, it makes use of the configuration manager provided in the NETTOOLS library. Note that the configuration definitions and structures defined here are specific to NETCTRL, not CONFIG.</p>
</blockquote>
<h3 id="netctrl-api">NETCTRL API</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化运行环境</span></span><br><span class="line"><span class="function">_extern <span class="keyword">int</span>  <span class="title">NC_SystemOpen</span><span class="params">( <span class="keyword">int</span> Priority, <span class="keyword">int</span> OpMode )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数可选择任务等级高或任务等级低</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_PRIORITY_LOW             OS_SCHEDULER_LOWPRI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_PRIORITY_HIGH            OS_SCHEDULER_HIGHPRI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义打开模式为POLLING或中断</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPMODE_POLLING           1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPMODE_INTERRUPT         2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NC_SystemOpen()的返回结果</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPEN_SUCCESS             0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPEN_ILLEGAL_PRIORITY    -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPEN_ILLEGAL_OPMODE      -2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPEN_MEMINIT_FAILED      -3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPEN_EVENTINIT_FAILED    -4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭运行环境</span></span><br><span class="line"><span class="function">_extern <span class="keyword">void</span> <span class="title">NC_SystemClose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用提供的配置信息开启网络</span></span><br><span class="line"><span class="function">_extern <span class="keyword">int</span> <span class="title">NC_NetStart</span><span class="params">( HANDLE hCfg, <span class="keyword">void</span> (*NetStart)(),</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">void</span> (*NetStop)(), <span class="keyword">void</span> (*NetIP)(IPN,uint,uint) )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开网络</span></span><br><span class="line"><span class="function">_extern <span class="keyword">void</span> <span class="title">NC_NetStop</span><span class="params">( <span class="keyword">int</span> rc )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当Boot线程完成时被调用</span></span><br><span class="line"><span class="function">_extern <span class="keyword">void</span> <span class="title">NC_BootComplete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当IP地址被添加或移除时被调用</span></span><br><span class="line"><span class="function">_extern <span class="keyword">void</span> <span class="title">NC_IPUpdate</span><span class="params">( IPN IPAddr, uint IfIdx, uint fAdd )</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="socket-api">SOCKET API</h2>
<h3 id="universal_tcp">UNIVERSAL_TCP</h3>
<h4 id="defined-in-ws2def.h">defined in <code>&lt;ws2def.h&gt;</code></h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                 ai_flags;       <span class="comment">// AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST</span></span><br><span class="line">    <span class="keyword">int</span>                 ai_family;      <span class="comment">// PF_xxx</span></span><br><span class="line">    <span class="keyword">int</span>                 ai_socktype;    <span class="comment">// SOCK_xxx</span></span><br><span class="line">    <span class="keyword">int</span>                 ai_protocol;    <span class="comment">// 0 or IPPROTO_xxx for IPv4 and IPv6</span></span><br><span class="line">    <span class="keyword">size_t</span>              ai_addrlen;     <span class="comment">// Length of ai_addr</span></span><br><span class="line">    <span class="keyword">char</span> *              ai_canonname;   <span class="comment">// Canonical name for nodename</span></span><br><span class="line">    _Field_size_bytes_(ai_addrlen) <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *   <span class="title">ai_addr</span>;</span>        <span class="comment">// Binary address</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *   <span class="title">ai_next</span>;</span>        <span class="comment">// Next structure in linked list</span></span><br><span class="line">&#125;</span><br><span class="line">ADDRINFOA, *PADDRINFOA;</span><br></pre></td></tr></table></figure>
<h4 id="defined-in-ti-socket.h">defined in <strong><em>TI</em></strong> <code>&lt;socket.h&gt;</code></h4>
<h5 id="ipv4套接字地址数据结构">IPv4套接字地址数据结构</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AF_INET family (IPv4) Socket address data structure.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    UINT8   sin_len;            <span class="comment">// total length</span></span><br><span class="line">    UINT8   sin_family;         <span class="comment">// address family</span></span><br><span class="line">    UINT16  sin_port;           <span class="comment">// port</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span></span><br><span class="line">    INT8    sin_zero[<span class="number">8</span>];        <span class="comment">// fixed length address value</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="内核用地址存储数据结构">内核用地址存储数据结构</h5>
<p>这个套娃里还有个套娃 <code>in_addr</code> ，这个结构体供内核调用，以储存更多地址数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Structure used by kernel to store most addresses.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    UINT32  s_addr;             <span class="comment">// 32 bit long IP address, net order</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="通用套接字地址储存数据结构">通用套接字地址储存数据结构</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generic Socket address storage data structure.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    UINT8    sa_len;            <span class="comment">// Length </span></span><br><span class="line">    UINT8    sa_family;         <span class="comment">// address family</span></span><br><span class="line">    <span class="keyword">char</span>     sa_data[<span class="number">14</span>];       <span class="comment">// socket data</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>      <span class="title">SA</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>      *<span class="title">PSA</span>;</span></span><br></pre></td></tr></table></figure>
<p>以下为Socket <strong>接口协议簇</strong> 、 <strong>接口类型</strong>、 <strong>接口协议</strong> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Socket address families</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_TASK         1               <span class="comment">// Intertask Communication</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_INET         2               <span class="comment">// Internet: UDP, TCP, etc.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_INET6        10              <span class="comment">// IPV6</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _INCLUDE_NIMU_CODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_RAWETH       12              <span class="comment">// Raw Ethernet Protocol</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Socket Types</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_STREAM     1               <span class="comment">// stream socket</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_DGRAM      2               <span class="comment">// datagram socket</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_RAW        3               <span class="comment">// raw-protocol interface</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_STREAMNC   4               <span class="comment">// non-copy stream socket</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _INCLUDE_NIMU_CODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_RAWETH     5               <span class="comment">// non-copy raw eth socket</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Protocols</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_IP      0               <span class="comment">// IP Placeholder</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_ICMP    1               <span class="comment">// ICMP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_IGMP    2               <span class="comment">// IGMP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_TCP     6               <span class="comment">// TCP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_UDP     17              <span class="comment">// UDP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_IPV6    41              <span class="comment">// IPV6 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_ICMPV6  58              <span class="comment">// ICMPV6 Header.</span></span></span><br></pre></td></tr></table></figure>
<p>以下Socket接口均以Ti NDK为载体，以C为实现方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Socket Oriented Functions</span></span><br><span class="line"><span class="function">SOCKET <span class="title">accept</span><span class="params">( SOCKET s, PSA pName, <span class="keyword">int</span> *plen )</span></span>;	<span class="comment">//接受一个套接字的连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">bind</span><span class="params">( SOCKET s, PSA pName, <span class="keyword">int</span> len )</span></span>;	<span class="comment">//给套接字绑定一个名字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">connect</span><span class="params">( SOCKET s, PSA pName, <span class="keyword">int</span> len )</span></span>;		<span class="comment">//在一个套接字上初始化连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">getpeername</span><span class="params">( SOCKET s, PSA pName, <span class="keyword">int</span> *plen )</span></span>;	<span class="comment">//在已连接的peer上返回名称地址</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">getsockname</span><span class="params">( SOCKET s, PSA pName, <span class="keyword">int</span> *plen )</span></span>;	<span class="comment">//返回套接字的本地名称地址</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">getsockopt</span><span class="params">( SOCKET s, <span class="keyword">int</span> level, <span class="keyword">int</span> op, <span class="keyword">void</span> *pbuf, <span class="keyword">int</span> *pbufsize )</span></span>;	<span class="comment">//获取套接字设置信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">listen</span><span class="params">( SOCKET s, <span class="keyword">int</span> maxcon )</span></span>;		<span class="comment">//监听数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">recv</span><span class="params">( SOCKET s, <span class="keyword">void</span> *pbuf, <span class="keyword">int</span> size, <span class="keyword">int</span> flags )</span></span>;		<span class="comment">//接收数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">recvfrom</span><span class="params">( SOCKET s, <span class="keyword">void</span> *pbuf, <span class="keyword">int</span> size, <span class="keyword">int</span> flags, PSA pName, <span class="keyword">int</span> *plen )</span></span>;		<span class="comment">//从指定对象处接收信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">recvnc</span><span class="params">( SOCKET s, <span class="keyword">void</span> **ppbuf, <span class="keyword">int</span> flags, HANDLE *pHandle )</span></span>;	<span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">recvncfrom</span><span class="params">( SOCKET s, <span class="keyword">void</span> **ppbuf, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                           PSA pName, <span class="keyword">int</span> *plen, HANDLE *pHandle )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">recvncfree</span><span class="params">( SOCKET Handle )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">send</span><span class="params">( SOCKET s, <span class="keyword">void</span> *pbuf, <span class="keyword">int</span> size, <span class="keyword">int</span> flags )</span></span>;		<span class="comment">//发送信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">sendto</span><span class="params">( SOCKET s, <span class="keyword">void</span> *pbuf, <span class="keyword">int</span> size, <span class="keyword">int</span> flags, PSA pName, <span class="keyword">int</span> len )</span></span>;	<span class="comment">//在未连接的套接字上往指定目的地发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">setsockopt</span><span class="params">( SOCKET s, <span class="keyword">int</span> level, <span class="keyword">int</span> op, <span class="keyword">void</span> *pbuf, <span class="keyword">int</span> bufsize )</span></span>;	<span class="comment">//设置套接字设置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">shutdown</span><span class="params">( SOCKET s, <span class="keyword">int</span> how )</span></span>;	<span class="comment">//关闭一半的套接字连接</span></span><br><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">( <span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol )</span></span>;	<span class="comment">//创建套接字</span></span><br></pre></td></tr></table></figure>
<h3 id="socket-api-in-client">SOCKET API IN CLIENT</h3>
<hr />
<div class="Step" style="font-size: 20px; font-weight: 700;">
第一步 创建套接字
</div>
<p><code>SOCKET socket( int domain, int type, int protocol );</code></p>
<p>如果创建成功，则返回一个代表套接字的文件描述符。否则就返回一个 <code>INVALID_SOCKET</code> 值，并且可以调用 <code>fdError()</code> 来诊断错误原因。</p>
<blockquote>
<p><code>domain</code>是指链路层类型IPv4还是IPv6，分别书写为 <strong>AF_INET</strong> | <strong>AF_INET6</strong></p>
<p><code>type</code>是指传输层套接字类型，共有 <strong>报文数据</strong>、<strong>流式数据</strong>、<strong>原始数据</strong> 三种可选，分别是 <strong>SOCK_DGRAM</strong> | <strong>SOCK_STREAM</strong> | <strong>SOCK_RAW</strong></p>
<p><code>protocol</code>是指网络层协议类型，IPPROTO_TCP | IPPROTO_UDP，在套接字类型是原始数据时可以任意指定，如果是套接字类型是 <strong>SOCK_STREAM</strong>，则协议需要指定为 <strong>IPPROTO_TCP</strong></p>
</blockquote>
<div class="Step" style="font-size: 20px; font-weight: 700;">
第二步 设定套接字参数
</div>
<p>通常在套接字创建之后，使用Pv4套接字地址数据结构 <code>sockaddr_in</code>设定参数，以下实例是下位机做客户端时的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bzero(&amp;sin1, <span class="keyword">sizeof</span>(struct sockaddr_in));            <span class="comment">/* Set Port, IP address = IPAddrSend */</span></span><br><span class="line">sin1.sin_family = AF_INET;</span><br><span class="line">sin1.sin_len    = <span class="keyword">sizeof</span>(sin1);</span><br><span class="line">sin1.sin_addr.s_addr = inet_addr(REMOTE_IPADDR_STRING);          <span class="comment">//连接服务器的地址</span></span><br><span class="line">sin1.sin_port   = htons(TCP_CLIENT_PORT);</span><br></pre></td></tr></table></figure>
<div class="Step" style="font-size: 20px; font-weight: 700;">
第三步 连接
</div>
<p><code>int    connect( SOCKET s, PSA pName, int len );</code></p>
<blockquote>
<p><code>PSA</code> 是 <code>sockaddr</code> 结构体的 <strong><em>指针</em></strong> 对象类型，定义为 <code>typedef struct sockaddr      *PSA;</code></p>
<p>另，<code>SA</code> 是 <code>sockaddr</code> 结构体的对象类型。</p>
</blockquote>
<p><code>sockaddr</code> 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用套接字地址存储数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    UINT8    sa_len;            <span class="comment">//套接字长度</span></span><br><span class="line">    UINT8    sa_family;         <span class="comment">//套接字类型，AF_INET</span></span><br><span class="line">    <span class="keyword">char</span>     sa_data[<span class="number">14</span>];       <span class="comment">//套接字数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实际连接时，通常设置一定时间的任务休眠以等待网络稳定后再行连接，且连接次数自定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(count = <span class="number">0</span>; count &lt; <span class="number">30</span>; count ++)&#123;</span><br><span class="line">        res = connect(stcp, (PSA) &amp;sin1, <span class="keyword">sizeof</span>(sin1));</span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            ConsoleWarning(<span class="string">&quot;网络连接失败！\n&quot;</span>);</span><br><span class="line">            TaskSleep(SLEEPTIME);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ConsoleWarning(<span class="string">&quot;网络连接成功！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过特定配置设置，打开网络。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_extern <span class="keyword">int</span> <span class="title">NC_NetStart</span><span class="params">( HANDLE hCfg,   <span class="keyword">void</span> (*NetStart)(),   <span class="keyword">void</span> (*NetStop)(),    <span class="keyword">void</span> (*NetIP)(IPN,uint,uint) )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="套接字">套接字</h4>
<p>HANDLE is a <em>void pointer*</em> defined in the <code>&lt;usertype.h&gt;</code>.</p>
<blockquote>
<p>在<code>&lt;socket.h&gt;</code>中，<strong>SOCKET</strong>类型其实是个HANDLE，而<strong>HANDLE</strong>其实是<code>void*</code>数据。</p>
<p><code>typedef HANDLE           SOCKET;          // OS Socket Type</code></p>
<p><code>typedef void *         HANDLE;</code></p>
</blockquote>
<h4 id="文件描述符">文件描述符</h4>
<blockquote>
<p>文件描述符，即 <strong><em>File Descriptor</em></strong>，其实一个是 <code>void*</code>类型</p>
</blockquote>
<h5 id="fd集">FD集</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Select uses bit masks of file descriptors.  These macros</span></span><br><span class="line"><span class="comment">// manipulate handle lists. FD_SETSIZE can be modified as</span></span><br><span class="line"><span class="comment">// needed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_SETSIZE      16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fd_set</span> &#123;</span></span><br><span class="line">    uint    count;</span><br><span class="line">    HANDLE  fd[FD_SETSIZE];</span><br><span class="line">&#125; fd_set;</span><br></pre></td></tr></table></figure>
<h4 id="字节顺序转换函数">字节顺序转换函数</h4>
<p>在C/C++写网络程序的时候，往往会遇到字节的网络顺序和主机顺序的问题。这是就可能用到<code>htons()</code> , <code>ntohl()</code> , <code>ntohs()</code>，<code>htons()</code>这4个函数。</p>
<p>网络字节顺序与本地字节顺序之间的转换函数：</p>
<blockquote>
<p><code>htonl()</code>--"Host to Network Long" <code>ntohl()</code>--"Network to Host Long" <code>htons()</code>--"Host to Network Short" <code>ntohs()</code>--"Network to Host Short"</p>
</blockquote>
<p><strong><em>网络字节顺序(NBO, Network Byte Order):</em></strong> 按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。</p>
<p><strong><em>主机字节顺序(HBO, Host Byte Order):</em></strong> 不同的机器HBO不相同，与CPU设计有关，数据的顺序是由cpu决定的,而与操作系统无关。</p>
<blockquote>
<p>如 Intel x86结构下, short型数 <code>0x1234</code> 表示为<code>34 12</code>, int型数 <code>0x12345678</code> 表示为<code>78 56 34 12</code></p>
<p>如 IBM power PC结构下, short型数<code>0x1234</code> 表示为 <code>12 34</code> , int型数 <code>0x12345678</code> 表示为 <code>12 34 56 78</code></p>
</blockquote>
<p>由于这个原因不同体系结构的机器之间无法通信,所以要转换成一种约定的数序,也就是网络字节顺序,其实就是如同power pc那样的顺序. 在PC开发中有ntohl和htonl函数可以用来进行网络字节和主机字节的转换.</p>
<h4 id="timeval结构体">timeval结构体</h4>
<blockquote>
<p>Ti SysBios中，<code>timeval</code> 是在 <code>&lt;SOCKET.H&gt;</code> 中被定义，被 <code>fdSelect()</code> 使用的；</p>
</blockquote>
<p>结构体定义与Linux C中的一致</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    INT32 tv_sec;	<span class="comment">//Second Level</span></span><br><span class="line">    INT32 tv_usec;	<span class="comment">//Microsecond Level</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <strong><em>Linux C</em></strong> 中，<code>timeval</code> 与 <code>timezone</code> 结构体都隶属于 <code>sys/time.h</code> 头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> tz_minuteswest;</span><br><span class="line"><span class="keyword">int</span> tz_dsttime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Linux C 中对 TIMEVAL 使用的补充资料：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct timeval*tv, struct timezone *tz)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其参数tv是保存获取时间结果的结构体，参数tz用于保存时区结果，tz 参数若不使用则传入NULL即可。</p>
<p><code>gettimeofday()</code> 使用举例-1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv_begin</span>, <span class="title">tv_end</span> ;</span></span><br><span class="line">gettimeofday(&amp;tv_begin, <span class="literal">NULL</span>);</span><br><span class="line">foo();</span><br><span class="line">gettimeofday(&amp;tv_end, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p><code>gettimeofday()</code> 使用举例-2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;time %u:%u\n&quot;</span>,tv.tv_sec,tv.tv_usec);</span><br><span class="line">      sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><em>源自：http://www.cnblogs.com/Neddy/archive/2012/01/31/2332957.html</em></p>
<h3 id="socket-api-in-server">SOCKET API IN SERVER</h3>
<div class="Step" style="font-size: 20px; font-weight: 700;">
第一步 创建套接字
</div>
<p>同client，略</p>
<div class="Step" style="font-size: 20px; font-weight: 700;">
第二步 监听套接字
</div>
<p><code>int    listen( SOCKET s, int maxcon );</code></p>
<blockquote>
<p><code>maxcon</code> 参数用于定义最大的阻塞数，如果阻塞值最高，则会发送一个 <code>ECONNREFUSED</code> 错误给客户端</p>
</blockquote>
<ul>
<li><p><code>listen()</code> 监听套接字上的连接请求。为了连接请求，需要先由<code>socket()</code> 函数创建套接字。</p></li>
<li><p><code>listen()</code> 函数用于等待设备接入并声明有限接入数的队列。</p></li>
<li><p>新连接接入时需要调用 <code>accept()</code> 函数。</p></li>
</ul>
<div class="Step" style="font-size: 20px; font-weight: 700;">
第三步 从套接字接收数据
</div>
<p><code>int    recv( SOCKET s, void *pbuf, int size, int flags );</code></p>
<blockquote>
<p><code>pbuf</code> 参数用于储存数据</p>
<p><code>size</code> 为欲接收数据的大小</p>
<p><code>flags</code> 为接收不到数据时的行为定义</p>
</blockquote>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr class="header">
<th>FLAGS</th>
<th>CONDITIONS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MSG_DONTWAIT</td>
<td>Requests that the operation not block when no data is available</td>
</tr>
<tr class="even">
<td>MSG_OOB</td>
<td>Requests receipt of out-of-band data that would not be received in the normal data stream. Some protocols place expedited data at the head of the normal data queue, and thus, this flag cannot be used with such protocols.</td>
</tr>
<tr class="odd">
<td>MSG_PEEK</td>
<td>Causes the receive operation to return data from the beginning of the receive queue without removing that data from the queue. Thus, a subsequent receive call will return the same data.</td>
</tr>
<tr class="even">
<td>MSG_WAITALL</td>
<td>Requests that the operation block until the full request is satisfied. However, the call may still return less data than requested if an error or disconnect occurs, or the next data to be received is of a different type than that returned.</td>
</tr>
</tbody>
</table>
<h3 id="socket-api-in-server-linux-c">SOCKET API IN SERVER (LINUX C)</h3>
<div class="Step" style="font-size: 20px; font-weight: 700;">
第一步 创建套接字
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> servSock;  <span class="comment">//Socket descriptor for server</span></span><br><span class="line"><span class="keyword">if</span>( ( servSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP ) ) &lt; <span class="number">0</span> ) <span class="built_in">printf</span>(<span class="string">&quot;socket() failed.\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<div class="Step" style="font-size: 20px; font-weight: 700;">
第二步 套接字地址初始化
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servAddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;servAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>( servAddr ) );</span><br><span class="line">servAddr.sin_family = AF_INET;</span><br><span class="line">servAddr.sin_addr.s_addr = htonl( INADDR_ANY );</span><br><span class="line">servAddr.sin_port = htons( servPort );</span><br></pre></td></tr></table></figure>
<div class="Step" style="font-size: 20px; font-weight: 700;">
第三步 绑定套接字
</div>
<p><strong>注意：</strong> <strong>客户端</strong>把服务器的地址提供给 <code>connect()</code> 以供连接至服务器，而 <strong>服务器</strong> 必须将自己的地址指定给 <code>bind()</code> 进行绑定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( ( bind( servSock, (struct sockaddr*) &amp;servAddr, <span class="keyword">sizeof</span>( servAddr ) ) ) &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;bind() failed.\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<div class="Step" style="font-size: 20px; font-weight: 700;">
第四步 监听套接字
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> MAXPENDING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span>( ( listen( servSock, MAXPENDING ) ) &lt; <span class="number">0</span> ) <span class="built_in">printf</span>(<span class="string">&quot;listen() failed.\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<div class="Step" style="font-size: 20px; font-weight: 700;">
第四步 处理程序
<div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaaddr_in</span> <span class="title">cintAddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clntAddrLen = <span class="keyword">sizeof</span>( clntAddr );</span><br><span class="line">    <span class="keyword">int</span> clntSock = accept( servSock, (struct sockaddr*)&amp;clntAddr, &amp;clntAddrLen );</span><br><span class="line">    <span class="keyword">if</span>( clntSock &lt; <span class="number">0</span> ) <span class="built_in">printf</span>(<span class="string">&quot;accept() failed.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> clntName[ INET_ADDRSTRLEN ];</span><br><span class="line">    <span class="keyword">if</span>( inet_ntop( AF_INET, &amp;clntAddr.sin_addr.s_addr, clntName, <span class="keyword">sizeof</span>( clntName ) ) != <span class="literal">NULL</span> ) <span class="built_in">printf</span>(<span class="string">&quot;Handling client %s/%d.\n&quot;</span>, clntName, ntohs( clntAddr.sin_port ));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Unable to get client address.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    HandleTCPClient(clntSock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="daemon-api">Daemon API</h3>
<p>DAEMON，即TCP/UDP Server Daemon Support。</p>
<p>A server daemon is a <strong>single network task</strong> that <strong>monitors the socket status of multiple network servers</strong>. When activity is detected, the <strong>daemon creates a task thread specifically to handle the new activity</strong>. This is more efficient than having multiple servers, <strong>each with their own listening thread</strong>.</p>
<p>要使用服务器守护，首先要创建入口(entry)，创建成功时会返回一个句柄，失败则返回NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">DaemonNew</span><span class="params">(<span class="keyword">uint32_t</span> Type, <span class="keyword">uint32_t</span> LocalAddress, <span class="keyword">uint32_t</span> LocalPort, <span class="keyword">int</span>(*pCb)(SOCKET,<span class="keyword">uint32_t</span>), </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">uint32_t</span> Priority, <span class="keyword">uint32_t</span> StackSize, <span class="keyword">uint32_t</span> Argument, <span class="keyword">uint32_t</span> MaxSpawn)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Type</code> Socket type (SOCK_STREAM, SOCK_STREAMNC, or SOCK_DGRAM) <code>LocalAddress</code> Local IP address (set to NULL for wildcard) <code>LocalPort</code> Local Port to serve (cannot be NULL) <code>pCb</code> Pointer to callback to handle server event (connection or activity) <code>Priority</code> Priority of new task to create for callback function <code>StackSize</code> Stack size of new task to create for callback function <code>Argument</code> Argument (besides socket) to pass to callback function <code>MaxSpawn</code> Maximum number of callback function instances (must be 1 for UDP)</p>
</blockquote>
<p>在TCP环境中，当新连接稳定时，新任务线程会被创建，套接字Session会被打开。在新的任务线程上，用户的回调函数会被调用以供新连接上的套接字和调用的指定参数使用。回调函数可以一直维护套接字和任务线程。一旦完成连接它将从回调任务中返回。该任务能够判断是否关闭套接字（或翻译成：该任务能够在需要时关闭套接字）。</p>
<p>In the case of TCP, when a new connection is established, a new task thread is created, and a socket session is opened. Then the user's callback function is called on the new task thread, being supplied with both the socket to the new connection and the caller specified argument (as supplied to DaemonNew()). The callback function can keep the socket and task thread for as long as necessary. It returns from the callback once it is done with the connection. The function can choose to close the socket if desired. The return code informs the daemon whether the socket has been closed (0) or is still open (1).</p>
<h2 id="netcfg.h">NETCFG.H</h2>
<blockquote>
<p><code>CI</code> means <code>Configuration Item</code> , and <code>CFG</code> means <code>Configuration</code> .</p>
</blockquote>
<p>Data-type <code>UINT32</code> and <code>IPN</code> are both defined in the header file <code>&lt;usertype.h&gt;</code> .</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>   UINT32;</span><br><span class="line"><span class="keyword">typedef</span> UINT32         IPN;             <span class="comment">// IP Address in NETWORK format</span></span><br></pre></td></tr></table></figure>
<p>Structure <code>CI_IPNET</code> and structure <code>CI_ROUTE</code> are different from each other.</p>
<p>Structure <code>CI_IPNET</code> is as follow:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPNet Instance</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ci_ipnet</span> &#123;</span></span><br><span class="line">        uint    NetType;                <span class="comment">// 网络地址类型标志</span></span><br><span class="line">        IPN     IPAddr;                 <span class="comment">// 32bits地址((2^8)*4)</span></span><br><span class="line">        IPN     IPMask;                 <span class="comment">// 子网掩码</span></span><br><span class="line">        HANDLE  hBind;                  <span class="comment">// 绑定句柄</span></span><br><span class="line">        <span class="keyword">char</span>    Domain[CFG_DOMAIN_MAX]; <span class="comment">// 域名</span></span><br><span class="line">        &#125; CI_IPNET;</span><br></pre></td></tr></table></figure>
<p>Structure <code>CI_ROUTE</code> is as follow:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Route Instance</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ci_route</span> &#123;</span></span><br><span class="line">        IPN     IPDestAddr;             <span class="comment">// 目的地址</span></span><br><span class="line">        IPN     IPDestMask;             <span class="comment">// 目的地址掩码</span></span><br><span class="line">        IPN     IPGateAddr;             <span class="comment">// 默认网关地址</span></span><br><span class="line">        HANDLE  hRoute;                 <span class="comment">// Route handle (resets to NULL)</span></span><br><span class="line">        &#125; CI_ROUTE;</span><br></pre></td></tr></table></figure>
<h2 id="configif.h">CONFIGIF.H</h2>
<p>请先阅读 <em>&lt;spru524k.pdf&gt;</em></p>
<h3 id="configuration-特性">Configuration 特性</h3>
<ul>
<li>任何对（已激活）配置的作用都将立即生效。</li>
</ul>
<blockquote>
<p><em>The configuration is based on an active database. That is, any change to the database can cause an immediate reaction in the system. For example, if a route is added to the configuration, it is added to the system route table. If the route is then removed from the configuration, it is removed from the system route table.</em></p>
</blockquote>
<ul>
<li>配置存在激活与失效两种状态。</li>
</ul>
<blockquote>
<p><em>Configurations can be set active or inactive. When a configuration is active, any change to the configuration results in a change in the system. When a configuration is inactive, it behaves like a standard database. Part of the main initialization sequence is to make the system configuration active, and then inactive when shutting down.</em></p>
</blockquote>
<ul>
<li>配置(Configurations)和配置入口(Configuration Entries)都使用句柄(handle)来映射，但不同的是，配置使用CfgHandle，而配置入口使用Cfg<em>Entry</em>Handle，所以不能混淆。</li>
</ul>
<blockquote>
<p><em>Both the configurations and configuration entries are referenced by a generic handle. Configuration functions (named as <code>CfgXxx()</code>) take a configuration handle parameter, while configuration entry functions (name as <code>CfgEntryXxx()</code>) take a configuration entry handle parameter. These handles are not interchangeable.</em></p>
</blockquote>
<ul>
<li>配置条目(Entry)包含着<em>(contains)</em> 一个内部引用计数(Internal Reference Count)，即如果有任务想使用它，它就不能被其他任务销毁。配置条目被引用一次，引用计数就会加一。</li>
</ul>
<blockquote>
<p><em>Configuration entry handles are referenced. This means that each handle contains an internal reference count so that the handle is not destroyed by one task while another task expects it to stay valid. Functions that return a configuration entry handle supply a referenced handle in that its reference count has already been incremented for the caller.</em></p>
</blockquote>
<ul>
<li>理论上句柄能够被无限持有，一旦释放则将被dereference。</li>
</ul>
<blockquote>
<p><em>The caller can hold this handle indefinitely, but should dereference it when it is through.</em></p>
</blockquote>
<p><code>IF</code> 是指 Interface。<code>ifconfig</code> 是unix系统上的ip接口查看语句。而 <code>CONFIGIF</code> 是配置管理接口的意思。</p>
<p><code>DeRef</code> ，即 <em>Dereference</em> 之意。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_extern <span class="keyword">int</span>  <span class="title">CfgAddEntry</span><span class="params">( HANDLE hCfg, uint Tag, uint Item, uint Mode, <span class="keyword">int</span> Size, UINT8 *pData, HANDLE *phCfgEntry )</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>HANDLE hCfg</code></p>
<p><code>uint Tag</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Defined Configuration Tags</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_OS               0x0001          <span class="comment">// OS Configuration</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_IP               0x0002          <span class="comment">// IP Stack Configuration</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_SERVICE          0x0003          <span class="comment">// Service</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_IPNET            0x0004          <span class="comment">// IP Network</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_ROUTE            0x0005          <span class="comment">// Gateway Route</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_CLIENT           0x0006          <span class="comment">// DHCPS Client</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_SYSINFO          0x0007          <span class="comment">// System Information</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_ACCT             0x0008          <span class="comment">// User Account</span></span></span><br></pre></td></tr></table></figure>
<p><code>uint Item</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Currently Used DHCP Compatible Items</span></span><br><span class="line"><span class="comment">// Multiple instances are always to be stored as multiple config entries, not a concatenated byte string in a single config entry.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_DHCP_DOMAINNAMESERVER   6       <span class="comment">// Stack&#x27;s DNS servers</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_DHCP_HOSTNAME           12      <span class="comment">// Stack&#x27;s host name</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_DHCP_NBNS               44      <span class="comment">// Stack&#x27;s NBNS servers</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_DHCP_CLIENT_OPTION		61		<span class="comment">// Stack DHCP Client Identifier</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_SYSINFO_REALM1          256     <span class="comment">// Realm Name 1 (max 31 chars)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_SYSINFO_REALM2          257     <span class="comment">// Realm Name 2 (max 31 chars)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_SYSINFO_REALM3          258     <span class="comment">// Realm Name 3 (max 31 chars)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_SYSINFO_REALM4          259     <span class="comment">// Realm Name 4 (max 31 chars)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_SYSINFO_REALMPPP        260     <span class="comment">// Realm Name PPP (max 31 chars)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_SYSINFO_EVALCALLBACK    261    <span class="comment">// Callback function to notify</span></span></span><br><span class="line">                                               <span class="comment">// application 5 min before</span></span><br><span class="line">                                               <span class="comment">// end of stack evaluation period         </span></span><br></pre></td></tr></table></figure>
<p><code>uint Mode</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add Entry Flags</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFG_ADDMODE_UNIQUE      0x0001  <span class="comment">// Replace all previous instances</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFG_ADDMODE_DUPLICATE   0x0002  <span class="comment">// Allow duplicate data entry</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFG_ADDMODE_NOSAVE      0x0004  <span class="comment">// Don&#x27;t include this entry in CfgSave</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="socket-in-windows">Socket in Windows</h1>
<p>Windows Sockets可以保证应用程序在任何支持Windows Sockets API 的网络内正常通信。</p>
<p>流式Socket：基于TCP，数据无差错且无重复发送；</p>
<p>数据报Socket：基于UDP，不能保证数据按发送顺序接收，可能丢失或重复。</p>
<p>真正与客户端Socket对象通信都不是服务器 Socket对象，而是新创建的“临时”Socket对象</p>
<blockquote>
<p>构造函数：CAsyncSocket();</p>
<p>Create();【成功返回非0，失败返回0】 //SOCK_DGRAM 数据报</p>
<p>GetSockName(); //用于获取Socket对象的本地名称（自己的信息），ip地址及端口号，或</p>
<p>GetPeerName(); //用于获取连接的Socket对象名称（对方的信息）</p>
<p>Listen(); //面向流式使用，参数范围1~5，表示等待连接队列的最大长度</p>
<p>Accept(); //用以接收等待队列中存在的连接请求</p>
<p>Connect(); //建立连接请求函数</p>
<p>Send(); //</p>
</blockquote>
<p>除字符型与布尔型外，其余整型用于表示（可能）不同尺寸的整数。</p>
<p>C++规定一个int（最小16bit）至少和一个short（16bit）一样大，一个long（最小32bit）至少和一个int一样大，一个long long（64bit）至少和一个long一样大。</p>
<p>其中，long long 是在C++ 11中新定义的。</p>
<p>尽管字符型char有三种（char、signed char、unsigned char），但是字符的表现形式只有2种，signed或unsigned。类型char实际上会表现为其中一种，具体由编译器决定。</p>
<p>字面值常量</p>
<blockquote>
<p>20 //十进制</p>
<p>020 //0开头的为8进制</p>
<p>0x20 //0x开头的为16进制</p>
</blockquote>
<h1 id="send-blocking">SEND() BLOCKING</h1>
<blockquote>
<p>In some cases where send() would block, it instead returns without copying all of the data as requested.</p>
<p>In this case, the return value of send() indicates how many bytes were actually copied. One example of this is if your program is blocking on send() and then receives a signal from the operating system.</p>
<p>In these cases, it is up to caller to try again with any remaining data.</p>
</blockquote>
<h1 id="套接字及流输入输出接口io">套接字及流输入输出接口(IO)</h1>
<p><strong>TOPIC</strong></p>
<blockquote>
<ul>
<li>文件描述符环境</li>
<li>文件描述符编程接口</li>
<li>套接字编程接口</li>
<li>元以太网套接字编程接口</li>
<li>全双工管道编程接口</li>
<li>因特网群组管理协议(IGMP)</li>
</ul>
</blockquote>
<p>在各嵌入式系统中，对文件描述符的支持都大相径庭。大部分情况，都只支持基本功能（bare minimum functionality）， 通常都以通用名称命名和提供被修剪过的函数(trimmed down support functions)。</p>
<p>TI NDK支持标准套接字接口函数，这些函数也要求文件描述符的支持，堆栈提供一个小型文件系统。</p>
<p>在堆栈代码内部的基本构建块是一个对象句柄。在其内部，套接字和管道都通过对象句柄寻址。然而，在应用层，套接字和管道都被当做文件描述符看待。文件描述符内涵附加状态信息（additional state information），允许根据套接字活动阻塞和解除阻塞任务。</p>
<p><strong>注意：</strong>尽管文件描述符能够在传统函数中使用，如select()， 但在这种实现方式中，他们仍然是句柄，而不是整型。</p>
<p>出于兼容性考虑，网络程序必须使用NDK头文件，然后使用INVALID_SOCKET作为错误情况判定，并且在检查SOCKET有效性时，不要直接与（&lt;0）比较。</p>
<p>使用文件描述符前，需要一个任务首先创建一个文件描述符表格（FD table / session）。只需要在应用层调用文件描述符函数 <code>fdOpenSession()</code> 来完成。</p>
<p>当任务结束使用FD接口，或被关闭时，调用 <code>fdCloseSession()</code> 。</p>
<p>为确保堆栈操作正确，每个任务在使用FD相关的函数前，都应创建FD session，在使用完毕后关闭它。</p>
<h2 id="open-fd-session">Open FD Session</h2>
<ol type="1">
<li><p>最简单的方式就是用 <code>TaskCreate()</code> ，他可以（自动）在内部打开和关闭FD session。</p></li>
<li><p>另一种方式就是在函数调用的最开头进行session创建，在函数结束的末尾进行session关闭。如下：</p></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">socket_task</span><span class="params">(<span class="keyword">int</span> IPAddr, <span class="keyword">int</span> TcpPort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        SOCKET s;</span><br><span class="line">        <span class="comment">// Open the file session</span></span><br><span class="line">        fdOpenSession(TaskSelf());</span><br><span class="line">       <span class="comment">// &lt; socket application code &gt;</span></span><br><span class="line">        <span class="comment">// Close the file session</span></span><br><span class="line">        fdCloseSession(TaskSelf());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>另一种方式就是创建子线程。注意的是，父线程需要保证子线程的任务被执行前打开子线程的session。可通过任务优先级或信标来完成，但会增加任务创建复杂度，并不是理想方案。</li>
<li>也可以通过让子任务调用session创建函数，并且由父线程来监控和关闭子线程门。</li>
</ol>
<p>栈库支持一些通常被认为是文件函数的功能，因此套接字应用程序可以在更传统的意义上编程。</p>
<blockquote>
<p>The stack library supports a handful of what are normally considered file functions, so that sockets applications can be programmed in a more traditional sense.</p>
</blockquote>
<p><code>fdPoll()</code> 远比 <code>fdSelect()</code> 来得更有效率。它轮询提供的套接字列表，并指定以毫秒为单位的超时(或使用<em>POLLINFTIM</em> 来设置无限超时)。拥有 <code>fdSelect()</code> 的优点，即对原始文件描述符列表（或者套接字）的检验不会被结果所改写，因此可以不用重建便多次使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fdpollitem</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *fd;  <span class="comment">//the fd or socket to check</span></span><br><span class="line">    <span class="keyword">uint16_t</span> eventsRequested;  <span class="comment">//a set of flags for requested events</span></span><br><span class="line">    <span class="keyword">uint16_t</span> eventsDetected;  <span class="comment">//a set of resulting flags for a detected event</span></span><br><span class="line">&#125; FDPOLLITEM;</span><br></pre></td></tr></table></figure>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="man7.org">Michael Kerrisk</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>感谢您的支持和鼓励</div>
  <button>
    Donate
  </button>
  <div class="post-reward">
      <div>
        <img src="https://photo.islet.space/2021/00/IMG_4588.JPG" alt="Liewzheng WeChat Pay">
        <span>WeChat Pay</span>
      </div>
      <div>
        <img src="https://photo.islet.space/2021/00/IMG_4590.JPG" alt="Liewzheng Alipay">
        <span>Alipay</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Socket/" rel="tag"># Socket</a>
          </div>

        

  <div id="vcomments" style="margin: 1rem 0 0 0;"></div>
  <script>
    new Valine({
      el: '#vcomments',
      appId: 'vRGM12EcYxDSM2lat5qjjSeY-gzGzoHsz',
      appKey: 'WBgAb6NTAFQ7DYtgH0uOPNNh'
    })
  </script>
          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/01/05/Programming/C++/2021-01-05-C++/" rel="prev" title="C++">
                  <i class="fa fa-chevron-left"></i> C++
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/02/10/Programming/CSS/2021-02-10-CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="CSS学习笔记">
                  CSS学习笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备19004822号 </a>
  </div>

<div class="copyright">
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liewzheng</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@8.12.0/dist/mermaid.min.js","integrity":"sha256-0dD7vUjUCTGJjeLnPotQQJIcSzug5fO6WDMYYyNIX4c="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  <script src="/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":"enable","tags":"all","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
