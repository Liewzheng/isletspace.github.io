[{"title":"利用Hexo搭建GitHub托管的个人博客","url":"/2019/01/04/Blog/2019-01-04-%E5%88%A9%E7%94%A8Hexo%E6%90%AD%E5%BB%BAGitHub%E6%89%98%E7%AE%A1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"<p>心血来潮，2019年伊始的第四天，我要搭建我自己的个人博客，作为个人工作学习和生活的一种记录方式。</p>\n<p>这前面的路或许会有困难，但我喜欢“挑战成功”的快感！</p>\n<p>本博文部分语句和教程是适用于Windows平台的，mac及其他平台请依据官方文档进行操作，本博文较长，请耐心阅读并多多实践。欢迎大家留言，提出问题，ありがとうございます。</p>\n<h1 id=\"一前置准备工作\">一、前置准备工作</h1>\n<p>本博文将叙述如何基于Hexo静态博客生成器快速搭建托管于GitHub的自建博客。</p>\n<p>首先，我们要在本地电脑端配置环境，并完成本地个人博客的搭建，然后申请GitHub账户和仓库，并上传本地个人博客到仓库，最后申请域名“XXXXX.com/XXXXX.cn” 并解析到对应的GitHub地址“XXXXX.github.io” 。</p>\n<p>本文所示操作方法都是在Windows环境下利用Git Bash Shell进行的。</p>\n<p>本文中出现的所有下载连接如果无法进行下载或下载速度极慢时，可以到文末找到对应的百度云盘链接。</p>\n<p>首先我们要安装几个工具：Git、Node.js、hexo和hexo-git（第二节 3.2中）上传工具。</p>\n<h2 id=\"基础知识\">1. 基础知识</h2>\n<p>个人博客，可以分为传统博客和自建博客两种。</p>\n<p>传统博客像是新浪博客、网易博客和QQ空间等，主要依托于自身强大的博客门户运营能力，能够为用户提供安全便捷的博客环境，缺点就是兼容性不够强，并且个性化定制能力稍差。</p>\n<p>自建博客根据服务器管理方式也可以分为两种。一种是基于第三方服务器托管的自建博客，像GitHub这种；另一种是基于自有服务器的博客。</p>\n<p>自建博客根据博客生成器来分也可以分为两种，分别是动态博客和静态博客。其中，动态博客以WordPress、FarBox、Ghost等为代表。静态博客以Hexo、Jekyll、Octopress、Hugo为代表。</p>\n<p>以下为动态博客和静态博客的几点主要区别：</p>\n<ul>\n<li>资源占用上，静态的相比动态占用服务器资源少，还可以托管在Github Pages上；</li>\n<li>发布更新操作上，由于静态博客没有管理后台，所以发布更新内容要比动态博客繁琐；</li>\n<li>访问速度上，由于静态博客没有数据库，所以访问速度更快；</li>\n<li>安全性上，静态博客相比动态博客免疫了很多Web攻击套路；</li>\n</ul>\n<p>除了Hexo以外，还有其他的静态博客生成器推荐，见文章《<a href=\"http://topspeedsnail.com/static-website-generators_or_tools/\">11个最流行的静态(博客)网站生成工具</a>》。</p>\n<h2 id=\"git配置\">2. Git配置</h2>\n<h3 id=\"git-bash-shell下载\">2.1 Git Bash Shell下载</h3>\n<p>Windows平台： <a href=\"https://gitforwindows.org/\" class=\"uri\">https://gitforwindows.org/</a> Hexo提供的Git-SCM网址的Git Bash shell: <a href=\"https://git-scm.com/downloads\" class=\"uri\">https://git-scm.com/downloads</a></p>\n<h3 id=\"git安装验证\">2.2 Git安装验证</h3>\n<p>为了确保安装成功，我们可以在Bash Shell或Windows CMD中，使用以下代码进行验证： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git version</span><br></pre></td></tr></table></figure> 若成功安装，则会提示以下结果： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git version 2.20.1.windows.1</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"node.js配置\">3. Node.js配置</h2>\n<h3 id=\"node.js下载\">3.1 Node.js下载</h3>\n<p>Windows平台： <a href=\"https://nodejs.org/en/\" class=\"uri\">https://nodejs.org/en/</a></p>\n<h3 id=\"node.js安装验证\">3.2 Node.js安装验证</h3>\n<p>为了确保安装成功，我们可以在Bash Shell或Windows CMD中，使用以下代码进行验证： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">node -v</span><br></pre></td></tr></table></figure></p>\n<p>若成功安装，则会提示以下结果： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">v10.15.0</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"hexo配置\">4. Hexo配置</h2>\n<h3 id=\"hexo安装\">4.1 Hexo安装</h3>\n<p>成功安装Git和Node.js之后，（关闭窗口并重启命令终端）则可以使用npm命令语句安装Hexo： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"hexo初始化\">4.2 Hexo初始化</h3>\n<p>为本地博客创建文件夹，以下代码中的”XXXXX”为该文件夹的名称，为避免出错，请勿输入中文。 <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd ~&#x2F;                          &#x2F;&#x2F;跳转到根目录</span><br><span class=\"line\">mkdir XXXXX                    &#x2F;&#x2F;创建一个文件夹</span><br><span class=\"line\">hexo init XXXXX                &#x2F;&#x2F;初始化该服务器文件夹</span><br><span class=\"line\">cd XXXXX                       &#x2F;&#x2F;跳转到该服务器文件夹</span><br><span class=\"line\">npm install                    &#x2F;&#x2F;博客环境安装</span><br><span class=\"line\">hexo g                         &#x2F;&#x2F;博客生成</span><br><span class=\"line\">hexo s                         &#x2F;&#x2F;博客服务器开启（本地预览用）</span><br></pre></td></tr></table></figure> ### 4.3 注意事项 在每次重新打开命令窗口，并生成本地服务器预览页面之前，都必须跳转到该服务器的文件夹中。即： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd XXXXX                       &#x2F;&#x2F;跳转到该服务器文件夹</span><br></pre></td></tr></table></figure></p>\n<p>到此步骤为止，本地服务器配置已经全部完成。可以根据hexo官方文档给出的参数格式说明来对博客进行个性修改，这些请看第3节。</p>\n<h1 id=\"二上传到github仓库\">二、上传到GitHub仓库</h1>\n<p>在这部分中，我们将会申请到一个Github账户，并建立好对应博客代码的储存仓库，也会将本地生成的公钥SSH Key中。</p>\n<h2 id=\"github账户申请及repository仓库建立\">1. GitHub账户申请及Repository（仓库）建立</h2>\n<h3 id=\"github注册\">1.1 GitHub注册</h3>\n<p>在这里偷个懒，引用别人的文章作为参考： 《<a href=\"http://wiki.jikexueyuan.com/project/github-basics/sign-up.html\">GitHub注册</a>》 GitHub官方网址：<a href=\"https://github.com\" class=\"uri\">https://github.com</a></p>\n<h3 id=\"repository建立\">1.2 Repository建立</h3>\n<p>在创建Repository的时候一定要注意，仓库名应该为：<strong>XXXXX.github.io</strong>。 这个XXXXX使用你的GitHub帐号名称代替，这是固定写法。</p>\n<p>比如我的名字是liewzheng，则我对应的仓库名称应该是：liewzheng.githug.io 不然在后续上传本地博客到仓库之后，会发现仓库无法打开的情况，因为DNS寻址会不成功。</p>\n<h2 id=\"ssh-key配置\">2. SSH Key配置</h2>\n<p>此步骤是为了让Github给你的电脑访问授权，如果没有此步骤，则无法上传到Github。</p>\n<h3 id=\"本地生成ssh-key\">2.1 本地生成SSH Key</h3>\n<p>请执行以下命令： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-keygen</span><br></pre></td></tr></table></figure> 三次回车之后，可以生成id_rsa.pub文件，这里面就是SSH key的内容，然后使用Vim编辑器打开这个文件，复制里面的<strong>全部内容</strong>！ <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure> 然后在键盘上敲击以下命令并回车退出Vim编辑器： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">:q</span><br></pre></td></tr></table></figure> 附带Vim编辑器的其他使用教程： 1. 《Vim入门基础》：<a href=\"https://www.jianshu.com/p/bcbe916f97e1\" class=\"uri\">https://www.jianshu.com/p/bcbe916f97e1</a></p>\n<h3 id=\"拷贝到github记录该key\">2.2 拷贝到GitHub记录该Key</h3>\n<p>在自己的GitHub主页，点击右上角<strong>头像</strong>，点击<strong>Setting</strong>，点击左侧边栏的<strong>SSH and GPG keys</strong>,点击<strong>New SSH key</strong>。</p>\n<p>然后将SSH-key粘贴到Key文本框中，在Title文本框键入对该Key的备注并保存即可。</p>\n<h3 id=\"验证ssh-key\">2.3 验证SSH Key</h3>\n<p>回到命令行，输入： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -T git@github.com</span><br></pre></td></tr></table></figure> 如果得到以下提示，则说明你已经配置好SSH-Key了。 <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hi! You&#39;ve successfully authenticated, but GitHub</span><br><span class=\"line\">does not provide shell access.</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"上传到github仓库\">3. 上传到GitHub仓库</h2>\n<h3 id=\"本地参数修改\">3.1 本地参数修改</h3>\n<p>首先找到本地博客的服务器文件夹下的_config.yml文件，然后打开并滑动到最底下，其原始文件应该是如下的： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type:</span><br></pre></td></tr></table></figure></p>\n<p>然后我们要对其进行上传参数修改，XXXXX为你对应的账户名： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git                   #为Git，旧写法为github</span><br><span class=\"line\">  repo: git@github.com:XXXXX&#x2F;XXXXX.github.io.git        #输入你对应的Git仓库地址，SSH写法</span><br><span class=\"line\">  branch: master              #可以为其他分支，默认为master</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"上传插件安装\">3.2 上传插件安装</h3>\n<p>接下来安装hexo对应Github的上传插件： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure> 显示如下文字说明插件安装成功了： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">  npm WARN deprecated swig@1.4.2: This package is no longer maintained</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; fsevents@1.2.4 install &#x2F;Users&#x2F;apple&#x2F;liewzheng&#x2F;node_modules&#x2F;fsevents</span><br><span class=\"line\">&gt; node install</span><br><span class=\"line\"></span><br><span class=\"line\">[fsevents] Success: &quot;&#x2F;Users&#x2F;apple&#x2F;liewzheng&#x2F;node_modules&#x2F;fsevents&#x2F;lib&#x2F;binding&#x2F;Release&#x2F;node-v64-darwin-x64&#x2F;fse.node&quot; already installed</span><br><span class=\"line\">Pass --update-binary to reinstall or --build-from-source to recompile</span><br><span class=\"line\">+ hexo-deployer-git@0.3.1</span><br><span class=\"line\">added 68 packages from 33 contributors, updated 1 package and audited 5870 packages in 12.563s</span><br><span class=\"line\">found 1 low severity vulnerability</span><br><span class=\"line\">  run &#96;npm audit fix&#96; to fix them, or &#96;npm audit&#96; for details</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"用户名称及邮箱配置\">3.3 用户名称及邮箱配置</h3>\n<p><em>（更新日期：2021年2月5日）</em></p>\n<p>向cmd或者terminal内设置两个变量，分别是 <code>user.name</code> 和 <code>user.email</code> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git config --global user.email &quot;you@example.com&quot;</span><br><span class=\"line\">git config --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"三博客主题配置\">三、博客主题配置</h1>\n<h2 id=\"选择博客主题\">1. 选择博客主题</h2>\n<p>本步骤需要在<a href=\"https://hexo.io/themes/\">Hexo的官网</a>上进行主题挑选及预览，然后再跳转到对应的GitHub仓库中下载主题Zip包，并解压放在对应的位置/themes/下面。</p>\n<p>然后在根目录下找到文件<code>_config.yml</code></p>\n<p>并在其文件下方XXXXX处替换刚下载好的主题名称（其文件夹名称）: <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">theme:   XXXXX</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"主题配置\">2. 主题配置</h2>\n<p>请打开对应的主题文件夹下的<code>\\_config.yml</code>文件，如： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">XXXXX\\themes\\hexo-theme-pln-master\\_config.yml</span><br></pre></td></tr></table></figure> 然后对照着Hexo对config.yml文件的说明进行编辑。</p>\n<p>官方文档如下： 《<a href=\"https://hexo.io/zh-cn/docs/configuration\">配置</a>》</p>\n<h2 id=\"注意事项\">3. 注意事项</h2>\n<p>大概是因为Hexo免费的原因，其主题很多都是资源上传，且无人维护的，因此需要多下载几个主题，一个一个进行尝试，在本地博客服务器上尝试到<strong>所有网页跳转正常</strong>且<strong>无BUG</strong>之后再进行主题配置，按需修改。</p>\n<h1 id=\"四博客撰写及文件更新\">四、博客撰写及文件更新</h1>\n<h2 id=\"博客撰写\">1. 博客撰写</h2>\n<p>使用Hexo创建的静态网页之后，在编写博文之时，一般都是使用<strong>轻量级标记语言</strong>（MarkDown,文件名如：XXXX.md）来编写的。然后利用脚本语言将md格式文件自动转换成html5文件，并上传到服务器仓库。</p>\n<p>这时候，熟练使用MarkDown这种纯文本文档语言来编写博客，是为广大博客爱好者提供了便利的。</p>\n<p>由于MarkDown是纯文本文档，在文章撰写中无法使用图片直接插入和预览功能，因此最好选择合适的稳定的图库网站来保存自己的图片，并生成对应url，再使用如下引用方法来插入图片： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">![说明](url地址)</span><br></pre></td></tr></table></figure> url地址的填项也可以是相对(物理)地址。</p>\n<p><strong>科普</strong> 相对地址和绝对地址（相对路径和绝对路径）。 这一点，学计算机和电子的人可能会比较懂。 详细科普还是请参考链接6吧。</p>\n<p>另外，推荐使用Atom文本编辑器对本博文中出现的各种文件进行编辑，自带各种显示优化，地址如下： <a href=\"https://atom.io/\" class=\"uri\">https://atom.io/</a></p>\n<p>更多MarkDown的使用方法，请循： 1. 《<a href=\"https://blog.csdn.net/LoveJavaYDJ/article/details/73692917\">Markdown编辑器editor.md的使用</a>》 2. 《<a href=\"https://www.jianshu.com/p/34dd741932eb\">Github上README.md的简单使用方法</a>》</p>\n<h2 id=\"文件更新利用git-bash-shell\">2. 文件更新（利用Git Bash Shell）</h2>\n<p>再次更新本地服务器文件，并保存生成预览之后，如果想要更新对应git仓库里的文件，最好每一次都按照以下代码进行操作，避免出现不必要的意外。 <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure> 之所以强调需要每一次都这样操作，是因为本人就有过偷懒，在本地博客预览成功后选择直接部署，都没有提示错误，也没有部署成功（输入对应网址后无法显示更新）。</p>\n<h2 id=\"注意事项-1\">3. 注意事项</h2>\n<p>可以在本地博客服务器开启的情况下，实时修改服务器文件并刷新网页进行查看，这样创建文章和预览网页的效率有极大的提升。</p>\n<h1 id=\"五博客展示\">五、博客展示</h1>\n<h2 id=\"域名申请\">1. 域名申请</h2>\n<p>域名申请比较靠谱的，可以选择国内的阿里云、百度云和腾讯云等等。</p>\n<p>由于此步骤较为简单，不做多介绍。域名申请参考文章如下： 1. 《<a href=\"https://blog.csdn.net/www203203/article/details/76284258\">免费申请域名</a>》 2. 《<a href=\"https://blog.csdn.net/xd_wangkai/article/details/28097947\">教你如何申请域名和解析域名</a>》</p>\n<h2 id=\"域名解析\">2. 域名解析</h2>\n<p>域名解析是指将指定的域名与指定的服务器或其他地址绑定在一起，能够在DNS服务器中被检索得到，通过输入域名A并跳转到指定位置。</p>\n<p>有两种方法可以用来将自己的域名指向到Github Pages: - A类型解析：将域名定向解析到一个IPv4地址，只要将获取到个人博客的IPv4地址就可以定向解析了 - CNAME类型解析：将自己的域名（定向域名或子域名）指向另一个域名（博客地址）</p>\n<p>本人使用阿里云域名解析服务，具体步骤请参考以下链接： 1. 《<a href=\"https://github.com/HuYuee/blog/issues/13\">github pages+阿里云域名绑定搭建个人博客</a>》 2. 《<a href=\"https://www.jianshu.com/p/d92ea8542673\">github pages 绑定阿里云域名</a>》 3. 《<a href=\"https://www.zhihu.com/question/31377141\">github怎么绑定自己的域名？</a>》</p>\n<h1 id=\"六博客个性化\">六、博客个性化</h1>\n<h2 id=\"图床服务器\">1. 图床服务器</h2>\n<p>对于博客而言，有两项因素关乎着“我是否需要图床服务器”这项问题： 1. 本博客是否有数量庞大的访客； 2. 本博客是否有插入数量庞大的多媒体（动画、视频和图片等等）；</p>\n<p>对于以上两种因素而言，图床服务器都能够很好的减轻博客服务器的访客压力，减少因为访客众多或者多媒体加载时的网页载入缓慢或崩溃。对于自有服务器的博客而言，图床服务器能够降低租用服务器的流量消耗，加快访问速度。</p>\n<p>理论上说，只要另外申请一个服务器，专门用来存放图片的，就能被称作图床服务器。 因此图床服务器也有自建服务器和门户服务器的区别。 你也可以上传到微博相册或者QQ空间相册，然后引用超链接到.md文件里。</p>\n<p>本人用<strong>阿里云OSS</strong>（Object Storage Service，对象存储服务），搭配Mac平台的 <strong>iPic插件</strong> ，有兴趣也可以参考一下： 《<a href=\"https://help.aliyun.com/product/31815.html\">对象存储OSS</a>》 《<a href=\"https://toolinbox.net/iPic/AddAliOSS.html\">在 iPic 中添加阿里云 OSS</a>》</p>\n<p>然后再推荐个口碑不错的<strong>七牛云</strong>，注册和使用方法请遵循技术文档吧，链接如下： <a href=\"https://www.qiniu.com/\">七牛云</a></p>\n<p>推荐网友Mashiro的自建图床服务器： 《<a href=\"https://2heng.xin/2017/11/24/chevereto/\">搭了一个图床</a>》</p>\n<p>其他推荐链接： 《<a href=\"https://lai.yuweining.cn/pic.html\">免费图床</a>》</p>\n<h2 id=\"yml\">2. .YML</h2>\n<p>.YML是YAML语言的文件格式。</p>\n<p><em>YAML是\"YAML Ain't a Markup Language\"（YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\"Yet Another Markup Language\"（仍是一种标记语言），但为了强调这种语言以数据做为中心，而不是以标记语言为重点，而用反向缩略语重命名。</em>——摘自wikipedia.org</p>\n<p>请自行以Hexo官方针对<strong><em>_config.yml</em></strong>文件做出的解释进行.yml学习，并针对个人博客进行适当的修改即可。</p>\n<h1 id=\"七后续总结\">七、后续总结</h1>\n<h2 id=\"如何github自建博客和自有服务器博客的区别\">1. 如何GitHub自建博客和自有服务器博客的区别</h2>\n<p>这个问题，相当于我给自己挖了个坑，之前打算长篇大论来着，发现自己也并没有那么深的体会。</p>\n<p>自由服务器博客最大的问题是，一般都会有自己的系统。 这样的服务器系统分为两类：应用镜像和系统镜像。</p>\n<p>应用镜像的代表是：WordPress、LAMP、Drupal、Node.js、ECShop等等。 系统镜像的代表是：CentOS、Ubuntu、Debian和Windows。</p>\n<p>自己管理服务器的话，最好是有一个自己的博客应用镜像，如WordPress，WordPress也是基于CentOS打造的，是功能非常强大的博客和内容管理工具平台。</p>\n<p>而GitHub的话更多的是静态博客的搭建，没有操作系统这种东西。</p>\n<h2 id=\"做好更换设备前的备份工作\">2. 做好更换设备前的备份工作</h2>\n<p>对了，值得一提的是，如果你准备在多台电脑之间编辑你的博文，最好是能够把本地博客服务器拷贝到U盘或者移动硬盘上面。</p>\n<p>假如，尝试着从GitHub再次git clone到本地的话，你会发现里面的内容和本地博客服务器的内容完全不一样。这是因为本地博客服务器使用.md文件进行编辑，之后在hexo d的过程中会把.md文件转换成.html文件，而使用.html文件编辑的话会变得更加复杂。</p>\n<p>因此，为了避免在转移到另一台电脑上编辑的时候出现这种尴尬问题，还是备份到U盘更方便。</p>\n<h1 id=\"参考链接\">参考链接</h1>\n<ol type=\"1\">\n<li>《<a href=\"https://zhuanlan.zhihu.com/p/26625249\">GitHub+Hexo 搭建个人网站详细教程</a>》</li>\n<li>《<a href=\"https://www.jianshu.com/p/f2285d63b3a8\">在github上搭建hexo个人博客（Linux-Ubuntu）</a>》</li>\n<li>《<a href=\"https://zhuanlan.zhihu.com/p/25744686\">搭建个人博客，你需要知道这些</a>》</li>\n<li>《<a href=\"https://hexo.io/zh-cn/docs\">Hexo官方帮助文档</a>》</li>\n<li>《<a href=\"https://zh.wikipedia.org/wiki/Markdown\">MarkDown</a>》</li>\n<li>《<a href=\"https://blog.csdn.net/yeoman92/article/details/52736504\">相对路径和绝对路径</a>》</li>\n</ol>\n<h1 id=\"下载链接\">下载链接</h1>\n<ol type=\"1\">\n<li>《<a href=\"https://pan.baidu.com/s/1VW7s2HCntyE5B9gkuiplvw\">安装工具合集（更新时间2019/01/05）</a>》 提取码：28wj</li>\n</ol>\n","categories":["Blog"],"tags":["BlogSet-up"]},{"title":"Hexo和博客评论系统","url":"/2019/01/25/Blog/2019-01-25-Hexo%E5%92%8C%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/","content":"<p>为了让大家能在博文下评论两句也是费了老大劲儿了，各种搜评论系统和倒腾。 本篇博文在Hexo静态博客系统的基础上添加评论系统。</p>\n<h1 id=\"博客评论系统\">1. 博客评论系统</h1>\n<p>现在知道的博客评论系统也不多，有所了解的是：<a href=\"https://disqus.com/\">Disqus</a>和Valine。目前也就只掌握了Disqus系统，下次有空学了其他评论系统的部署之后再来编辑吧。</p>\n<h1 id=\"disqus\">2. Disqus</h1>\n<p>Disqus因为是国外的评论系统，因此最好是常在墙外的人使用，好像支持匿名评论。跟我国互联网的相关法规相违背，因此在国内使用的话，会加载不出来，因为被屏蔽了。当然，如果都是墙外的人，那就无所谓了。 <strong>注意</strong> 首先确认一下你的<strong>博客主题</strong>本身已经默认支持Disqus评论系统了，否则你可能会因为不懂js语言而被折腾得半死。至于怎么确认是否支持呢？主题文件夹中的<code>readme.md</code>文件或者<code>_config.yml</code>，看看里面是否有disqus支持字样及相关说明，确认完支持之后请继续下列步骤。 对了，如果你翻了墙也打不开Disqus官网，记得在你的SS软件中的PAC配置文件里，讲disqus.com代理相关语句添加进去。同理，如果你点进来看见没有评论系统，那说明你没有科学上网成功啊。</p>\n<h2 id=\"注册账号\">2.1 注册账号</h2>\n<ol type=\"1\">\n<li>打开Disqus主页， 并点选<code>GET STARTED</code>。 <img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/25/Hexo和博客评论系统/WX20190125-111541.png\" alt=\"Disqus主页\" /></li>\n<li>根据提示注册。 <img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/25/Hexo和博客评论系统/031851.png\" alt=\"Disqus账号注册\" /></li>\n</ol>\n<h2 id=\"shortname获取\">2.2 Shortname获取</h2>\n<ol type=\"1\">\n<li>注册完之后，点选<code>I want to install Disqus on my site</code>网站会提示你输入Website Name。 后续我们会用到一个<strong>Shortname</strong>，区别于<strong>Website Name</strong>，Shortname是用来确保后续hexo部署的时候能够准确跟你的账户连接上的。（我当时好像没填Shortname，应该是自动生成的吧~） <img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/25/Hexo和博客评论系统/032303.png\" /> <img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/25/Hexo和博客评论系统/032455.png\" /></li>\n<li>找到Disqus右上角头像处，<code>Install on Site</code>选项。然后在左侧<code>SITE</code>栏目中找到<code>General</code>选项。从这里可以看到要找到Shortname。（下图中被圈中的马赛克部分就是你的Shortname） <img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/25/Hexo和博客评论系统/032751.png\" /> <img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/25/Hexo和博客评论系统/034605.png\" /></li>\n</ol>\n<h2 id=\"config.yml设置\">2.3 _config.yml设置</h2>\n<p>找到你的博客主题<code>/themes/hexo-theme-XXXXX-master/</code>下的<code>_config.yml</code>文件，然后修改或添加如下语句：（下列语句中，XXXXX为你的Shortname） <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">disqus_shortname: XXXXX</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"commont.ejs编辑\">2.4 commont.ejs编辑</h2>\n<ol type=\"1\">\n<li>找到与<code>_config.yml</code>文件同级目录底下的<code>layout/_partial/post/</code>中的<code>comment.ejs</code>文件。先复制一份到别处，做备份之用，修改坏了也不着急。然后讲源文件下的所有语句删除，复制以下语句并粘贴（没错，要复制粘贴的这段代码只有两行，因为等下要复制粘贴另外一段代码到这两行代码中间，表示”在非主页的时候执行评论系统“）： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;% if(!index)&#123; %&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></li>\n<li>找到步骤2.2中的第2步骤里的页面，同为左侧<code>SITE</code>栏目中的<code>Installation</code>，下图所示： <img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/25/Hexo和博客评论系统/040155.png\" /> 然后滑动到底下，点选<code>Universal Code</code>，Disqus会自动生成连接到你账户的代码，复制中间部分的代码。（该区域的代码是有滑动条的，记得<strong>全选复制</strong>！） <img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/25/Hexo和博客评论系统/040248.png\" /> <img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/25/Hexo和博客评论系统/040459.png\" /> 接着在刚刚的文件中，粘贴到那两行代码中间，完成后如下所示： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;% if(!index)&#123; %&gt;</span><br><span class=\"line\">&lt;div id&#x3D;&quot;disqus_thread&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\">*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.</span><br><span class=\"line\">*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https:&#x2F;&#x2F;disqus.com&#x2F;admin&#x2F;universalcode&#x2F;#configuration-variables*&#x2F;</span><br><span class=\"line\">&#x2F;*</span><br><span class=\"line\">var disqus_config &#x3D; function () &#123;</span><br><span class=\"line\">this.page.url &#x3D; PAGE_URL;  &#x2F;&#x2F; Replace PAGE_URL with your page&#39;s canonical URL variable</span><br><span class=\"line\">this.page.identifier &#x3D; PAGE_IDENTIFIER; &#x2F;&#x2F; Replace PAGE_IDENTIFIER with your page&#39;s unique identifier variable</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">*&#x2F;</span><br><span class=\"line\">(function() &#123; &#x2F;&#x2F; DON&#39;T EDIT BELOW THIS LINE</span><br><span class=\"line\">var d &#x3D; document, s &#x3D; d.createElement(&#39;script&#39;);</span><br><span class=\"line\">s.src &#x3D; &#39;https:&#x2F;&#x2F;blog-liewzheng-cn.disqus.com&#x2F;embed.js&#39;;</span><br><span class=\"line\">s.setAttribute(&#39;data-timestamp&#39;, +new Date());</span><br><span class=\"line\">(d.head || d.body).appendChild(s);</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;noscript&gt;Please enable JavaScript to view the &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;disqus.com&#x2F;?ref_noscript&quot;&gt;comments powered by Disqus.&lt;&#x2F;a&gt;&lt;&#x2F;noscript&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script id&#x3D;&quot;dsq-count-scr&quot; src&#x3D;&quot;&#x2F;&#x2F;blog-liewzheng-cn.disqus.com&#x2F;count.js&quot; async&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"执行\">2.5 执行</h2>\n<p>全部保存，重新运行以下语句便可进行网页预览啦！ <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure> <img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/25/Hexo和博客评论系统/041910.png\" /></p>\n<h1 id=\"参考资料\">参考资料</h1>\n<ol type=\"1\">\n<li>《<a href=\"http://moxfive.xyz/2016/01/02/hexo-comments/\">为 Hexo 主题添加评论模块 — Disqus, 多说, 友言</a>》</li>\n<li>《<a href=\"https://valine.js.org/quickstart.html\">快速开始</a>》</li>\n<li>《<a href=\"https://zhuanlan.zhihu.com/p/31411607\">Hexo Next 主题点击加载 Disqus 和来必力双评论系统</a>》</li>\n<li>《<a href=\"https://www.jianshu.com/p/d68de067ea74\">Hexo搭建博客系列：（六）Hexo添加Disqus评论</a>》</li>\n</ol>\n","categories":["Blog"],"tags":["Comment","Disqus","Hexo"]},{"title":"解决新版hexo没有目录和标签页的问题","url":"/2021/08/06/Blog/2021-08-06-%E8%A7%A3%E5%86%B3%E6%96%B0%E7%89%88hexo%E6%B2%A1%E6%9C%89%E7%9B%AE%E5%BD%95%E5%92%8C%E6%A0%87%E7%AD%BE%E9%A1%B5%E7%9A%84%E9%97%AE%E9%A2%98/","content":"<p>新版hexo安装之后没有标签页，解决方法大致三步：</p>\n<ol type=\"1\">\n<li><p>需要自行在 <code>/source/</code> 文件夹下添加一个 <code>categories</code> 和 <code>tags</code> 文件夹，然后往文件夹中分别写入一个 <code>index.md</code> 文件。</p></li>\n<li><p>然后在对应的 <code>index.md</code> 中写入 <em>YAML</em> 信息。</p></li>\n<li><p>在对应的主题配置文件，例如 <code>_config.yml</code> 中填写好配置。</p></li>\n</ol>\n<h1 id=\"新建目录和页面\">新建目录和页面</h1>\n<p>可以通过两句语句来运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new page categories</span><br><span class=\"line\">hexo new page tags</span><br></pre></td></tr></table></figure>\n<h1 id=\"添加type属性\">添加type属性</h1>\n<p>编辑 <code>index.md</code>，修改信息如下，日期随意：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: 目录</span><br><span class=\"line\"><span class=\"built_in\">type</span>: categories</span><br><span class=\"line\">date: 2020-08-06 23:32:00</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>注意上面写的一个属性 <code>type</code>，千万不能写错。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: 标签</span><br><span class=\"line\"><span class=\"built_in\">type</span>: tags</span><br><span class=\"line\">date: 2020-08-06 23:32:00</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<h1 id=\"设置配置文件\">设置配置文件</h1>\n<p>如下图所示修改即可：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210806235851123.png\" alt=\"image-20210806235851123\" /><figcaption aria-hidden=\"true\">image-20210806235851123</figcaption>\n</figure>\n<p>最后重新清空、运行和预览即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo generate</span><br><span class=\"line\">hexo site</span><br></pre></td></tr></table></figure>\n","categories":["Blog"],"tags":["categories","tag"]},{"title":"hexo必装插件及安装脚本","url":"/2021/12/27/Blog/2021-12-27-hexo%E5%BF%85%E8%A3%85%E6%8F%92%E4%BB%B6/","content":"<p>请先确保电脑上已经安装了必须的软件，如 <code>node.js</code> 和 <code>git</code> ，因为日常需要使用 <strong>代码</strong>、<strong>数学公式</strong>、<strong>流程图</strong>、<strong>搜索</strong> 等工具，所以下方的插件安装也主要是与此相关的。</p>\n<p><strong>注意</strong>：以下仅适用于 <code>hexo-next</code> 主题。</p>\n<h1 id=\"插件安装\">插件安装</h1>\n<p>先放一个博客 islet.space 需要使用到的插件，都需要使用 <code>npm</code> 进行安装。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211227103125833.png\" alt=\"本博客使用到的一些插件\" /><figcaption aria-hidden=\"true\">本博客使用到的一些插件</figcaption>\n</figure>\n<p>将下方这段脚本保存至 <code>hexo_install.sh</code> 文件中，并使用 <code>chmod +x hexo_install.sh</code> 命令为其添加执行权限，并使用 <code>./hexo_install.sh</code> 进行执行即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> uninstall the unnecessary renderer,like marked and kramed</span></span><br><span class=\"line\">sudo npm uninstall hexo-renderer-marked --save</span><br><span class=\"line\">sudo npm uninstall hexo-renderer-kramed --save</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> install the necessary plugins <span class=\"keyword\">for</span> hexo</span></span><br><span class=\"line\">sudo npm install @fancyapps/fancybox --save</span><br><span class=\"line\">sudo npm install @fortawesome/fontawesome-free --save</span><br><span class=\"line\">sudo npm install @next-theme/pjax --save</span><br><span class=\"line\">sudo npm install @next-theme/plugins --save</span><br><span class=\"line\">sudo npm install hexo-deployer-git --save</span><br><span class=\"line\">sudo npm install hexo-filter-mermaid-diagrams --save</span><br><span class=\"line\">sudo npm install hexo-generator-searchdb --save</span><br><span class=\"line\">sudo npm install hexo-math --save</span><br><span class=\"line\">sudo npm install hexo-renderer-ejs --save</span><br><span class=\"line\">sudo npm install hexo-renderer-pandoc --save</span><br><span class=\"line\">sudo npm install hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"插件启用\">插件启用</h1>\n<h2 id=\"pandoc\">pandoc</h2>\n<p>若要启用pandoc进行渲染，除了之前必须要卸载旧的渲染器（如 <code>marked</code> 和 <code>kramed</code> 外），还需要去github页面下载一个pandoc的渲染器软件并进行安装。</p>\n<p><strong>pandoc下载链接</strong>：https://github.com/jgm/pandoc/releases</p>\n<h2 id=\"mermaid\">mermaid</h2>\n<p>mermaid需要显示的话也需要安装插件，需要在hexo-next主题文件夹下的 <code>_config.yml</code> 文件中进行启用，如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211227105005422.png\" alt=\"mermaid在主题配置文件中的启用\" /><figcaption aria-hidden=\"true\">mermaid在主题配置文件中的启用</figcaption>\n</figure>\n<h2 id=\"latex\">latex</h2>\n<p>latex数学公式可以由 <code>pandoc</code> 渲染器进行渲染，只需要在hexo-next主题文件夹下的 <code>_config.yml</code> 文件中启用 <code>mathjax</code> ，如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211227104717614.png\" alt=\"数学公式在主题配置文件中的启用\" /><figcaption aria-hidden=\"true\">数学公式在主题配置文件中的启用</figcaption>\n</figure>\n<h2 id=\"search\">search</h2>\n<p>搜索功能功能不仅需要安装插件，还需要分别在博客文件夹根目录中的 <code>_config.yml</code> 和 hexo-next主题文件夹下的 <code>_config.yml</code> 文件中进行启用，如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211227105545754.png\" alt=\"博客根目录配置文件下的启用\" /><figcaption aria-hidden=\"true\">博客根目录配置文件下的启用</figcaption>\n</figure>\n<p><strong>注意</strong>：此处的 <code>db.json</code> 需要在 <code>public</code> 文件夹中也有一份的时候启用；如果 <code>db.json</code> 无法使用，则更换为 <code>search.xml</code> 。因为 <code>db.json</code> 或 <code>search.xml</code> 是由插件生成的搜索数据库（可以这么看）。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211227105510478.png\" alt=\"hexo主题配置文件下的启用\" /><figcaption aria-hidden=\"true\">hexo主题配置文件下的启用</figcaption>\n</figure>\n","categories":["Blog"],"tags":["hexo","shell"]},{"title":"串行通信（Serial Communication）","url":"/2019/01/06/Communication/2019-01-06-%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1/","content":"<p>在计算机系统中，CPU和外部通信有两种通信方式：<strong>并行通信</strong> 和 <strong>串行通信</strong> 。 而按照串行数据的时钟控制方式，串行通信又可分为 <strong>同步通信</strong> 和 <strong>异步通信</strong>。</p>\n<p>数据层标准：I2C、SPI、UART、USB、SATA 硬件层标准：RS232、TTL</p>\n<p>某些协议可能对于数据层或硬件层有着不同的规定，因此请自行了解并加以区分。</p>\n<h1 id=\"串行通信\">串行通信</h1>\n<p>Serial communication，指所有的串行的通信协议。是相对<strong>并行通信（Parallel communication)</strong> 而言的。</p>\n<h2 id=\"同步串行通信\">同步串行通信</h2>\n<p>Synchronous serial communication，指发送端在发送串行数据的同时，提供一个时钟信号，并按照一定的约定（例如在时钟信号的上升沿的时候，将数据发送出去）发送数据，接收端根据发送端提供的时钟信号，以及大家的约定，接收数据的。</p>\n<p>如：I2C、SPI。</p>\n<h2 id=\"异步串行通信\">异步串行通信</h2>\n<p>Asynchronous serial communication，指发送端在数据发送之前和之后，通过特定形式的信号（例如START信号和STOP信号），告诉接收端，可以开始（或者停止）接收数据了。与此同时，收发两方会约定一个数据发送的速度（波特率），发送端在发送START信号之后，就按照固定的节奏发送串行数据，与此同时，接收端在收到START信号之后，也按照固定的节奏接收串行数据。</p>\n<p>如：UART、USB。</p>\n<p>在传送数据的过程中，字符与字符之间的传送是完全异步的，位与位之间的传送基本上是同步的，其特点可以概括为： 1. 以字符为单位传送信息。 2. 相邻两字符间的间隔是任意长。 3. 因为一个字符中的比特位长度有限，所以需要的接收时钟和发送时钟只要相近就可以。 4. 异步方式特点简单的说就是：字符间异步，字符内部各位同步。</p>\n<h1 id=\"串行协议标准介绍\">串行协议标准介绍</h1>\n<p>本节仅对SPI、I2C、UART、RS232、TTL及COM接口做详细介绍，其他标准作为粗略的补充或拓展之用。</p>\n<h2 id=\"spi\">SPI</h2>\n<p>Serial Peripheral Interface Bus，串行外设接口。是一种用于短程通信的串行通信同步接口规范，也是一种<strong>同步串行通信协议</strong>，主要应用于单片机系统中。</p>\n<p>典型应用包含SD卡、液晶显示器、RFID读卡模块MFRC-522。 SPI设备之间使用全双工模式通信，包含一个主机和一个或多个从机。主机产生待读或待写的帧数据，多个从机通过一个片选线路 决定哪个来响应主机的请求。 有时SPI接口被称作四线程接口，SPI准确来讲称为同步串行接口，但是与同步串行接口协议（SSI）不同，SSI是一个四线程 同步通信协议，但是使用差分信号输入同时仅提供一个单工通信信道。</p>\n<p>SPI总线规定了4个保留逻辑信号接口： - <strong>SCLK</strong>（Serial Clock）：串列时脉，由主机发出 - <strong>MOSI</strong>（Master Output,Slave Input）：主机输出从机输入信号，由主机发出 - <strong>MISO</strong>（Master Input,Slave Output）：主机输入从机输出信号，由从机发出 - <strong>SS</strong>（Slave Selected）：选择信号，由主机发出，一般是低电位有效</p>\n<p>尽管上面的引脚名称是最常用的，但在过去，有时会使用其他引脚命名约定，因此旧IC产品的SPI端口引脚名称可能有所不同。</p>\n<figure>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/e/ed/SPI_single_slave.svg/1920px-SPI_single_slave.svg.png\" alt=\"SPI总线：单一主机对单一从机\" /><figcaption aria-hidden=\"true\">SPI总线：单一主机对单一从机</figcaption>\n</figure>\n<figure>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/fc/SPI_three_slaves.svg/1280px-SPI_three_slaves.svg.png\" alt=\"SPI总线：单一主机对复合从机\" /><figcaption aria-hidden=\"true\">SPI总线：单一主机对复合从机</figcaption>\n</figure>\n<h2 id=\"i²c\">I²C</h2>\n<p>Inter-Integrated Circuit，字面上的意思是集成电路之间，是I²C Bus简称。也称集成电路总线，它是一种<strong>同步串行通信协议</strong>，使用多主从架构总线。</p>\n<figure>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/3/3e/I2C.svg/1920px-I2C.svg.png\" alt=\"I2C bus\" /><figcaption aria-hidden=\"true\">I2C bus</figcaption>\n</figure>\n<h2 id=\"uart\">UART</h2>\n<p>Universally Asynchronous Receiver/Transmitter，通用异步接收/传输器，是指以某个固定的速率（1200bps、9600bps、115200bps等）进行数据传输，且一次只能传输一个bit（所以叫做串行传输）的<strong>异步串行通信协议</strong> 。 有时候UART会与TTL（Transistor-Transistor Logic）Serial混为一谈，这是因为TTL虽然可以采用其他串行通信协议（如I2C和SPI），但很多PC硬件上支持服务复杂，所以一般用UART协议导致的。 常见的微控制器中，都有内置UART协议接口。</p>\n<h2 id=\"rs232\">RS232</h2>\n<p>RS232或者RS485，相较于UART是通信协议的标准，RS232或RS485d规定的是电路的<strong>物理层协议</strong>（电平标准）。 因为它规定了电气特性和各个引脚的功能定义，如 用-3V— -15V之间的任意电平表示逻辑“1” ；用+3V — +15V电平表示逻辑“0”，这里采用的是负逻辑。</p>\n<h2 id=\"ttl\">TTL</h2>\n<p>Transistor-transistor Logic， 晶体管-晶体管逻辑集成电路，这种串行通信对应的物理电平始终是在0V和Vcc之间，其中常见的Vcc是5V或3.3V。 TTL指的是电路的 <strong>物理层协议</strong> （电平标准）。电压&gt;=2.4V时代表高电平1，电压&lt;=0.5V时代表低电平0（对于5V或3.3V电源电压），这里是正逻辑。TTL接口在Minnow板子上如图： <img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/06/SerialCommunication/%E5%9B%BE%E7%89%873.png\" alt=\"pic3\" /></p>\n<p>在TTL与RS232的互相转换中，使用的芯片是MAX3232（3.3V）或者MAX232（5V），里面就只涉及到电压转换的问题了，没有数据的改变和封装，因为他们在数据层的协议是一样的。 比如，对于同样传输0b01010101来说，RS232和TTL的时序对比如下图所示。 <img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/06/SerialCommunication/%E5%9B%BE%E7%89%874.png\" alt=\"pic4\" /> 当然，RS232和TTL之间的转换，不仅仅是简单的电平转换，还要考虑到其他一些因素，比如调节和矫正一些电平（提高或降低对应的电平），确保可能的有害的RS232电压不会破坏微控制器的串口针脚。</p>\n<p><strong>如何分辨究竟是TTL还是RS232呢？</strong> - 一般来说，由SOC芯片引脚直接引出的一般是TTL，其高低电平不需要任何转换，可以由芯片之间驱动，节省费用；而中间接有转换芯片的可能就是RS232了，可以根据电路图的芯片型号google即可。 - 另一个原则是RS232通常出现在传统的PC和服务器领域，TTL通常用于嵌入式设备。</p>\n<h2 id=\"com接口\">COM接口</h2>\n<p>Cluster Communication Port，串行通讯端口，简称串口。微机上的串口通常是9针（如下图示），也有25针的接口，最大速率115200bps。 <img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/06/SerialCommunication/%E5%9B%BE%E7%89%871.png\" alt=\"pic1\" /> PC计算机背板的COM口通常采用RS232标准，其高电平定义为-12V，低电平定义为+12V。 在嵌入式设备上的4针杜邦线接口也算COM接口，采用的是TTL标准或RS232标准。<strong>但如果谈论到COM接口，一般是指RS232标准的PC背板的9pin的COM口。</strong> <img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/06/SerialCommunication/%E5%9B%BE%E7%89%872.png\" alt=\"pic2\" /></p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>转换方式</th>\n<th>芯片型号</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>TTL-RS232</td>\n<td>MAX3232 或者 ST3232</td>\n</tr>\n<tr class=\"even\">\n<td>USB-TTL</td>\n<td>PL2303HX 或者 CP2102</td>\n</tr>\n</tbody>\n</table>\n<p>如果要转换USB-RS232的话，则要使用USB-TTL和TTL-RS232两种芯片。</p>\n<h2 id=\"其他\">其他</h2>\n<h3 id=\"usb\">USB</h3>\n<p>Universal Serial Bus，通用串行总线。是连接计算机系统与外部设备的一种串口总线标准，也是一种输入输出接口的技术规范。 USB使用NRZI编码方式：当数据为0时，电平翻转；数据为1时，电平不翻转。为了防止出现过长时间电平不变化现象，在发送数据时采用位填充处理。具体过程如下： - 当遇见连续6个高电平时，就强制插入一个0。 - 经过位填充后的数据由串行接口引擎（SIE）将数据串行化和NRZI编码后，发送到USB的差分数据线上。 - 接收端完成的过程和发送端刚好相反。</p>\n<h3 id=\"sata\">SATA</h3>\n<p>Serial Advanced Technology Attachment，串行高级技术附件。 是一种计算机总线，负责主板和大容量存储设备（如硬盘及光盘驱动器）之间的数据传输，主要用于个人计算机，用以取代PATA或称IDE接口。 串行ATA与串列SCSI（SAS: Serial Attached SCSI）的两者排线兼容，SATA硬盘可接上SAS接口。</p>\n<h1 id=\"参考资料\">参考资料</h1>\n<ol type=\"1\">\n<li>《<a href=\"https://zh.wikipedia.org/wiki/%E5%BA%8F%E5%88%97%E5%91%A8%E9%82%8A%E4%BB%8B%E9%9D%A2\">Serial Peripheral Interface</a>》</li>\n<li>《<a href=\"https://blog.csdn.net/seashine_yan/article/details/71192283\">同步串口和异步串口的区别及使用情况</a>》</li>\n<li>《<a href=\"https://zhuanlan.zhihu.com/p/25893717\">UART、RS232、TTL关系浅析</a>》</li>\n<li>《<a href=\"https://fanzheng.org/archives/39\">UART、TTL、RS232等概念的区别与联系</a>》</li>\n<li>《<a href=\"https://wenku.baidu.com/view/a5df03bb856a561253d36f4e.html\">串口、COM口、TTL、RS-232、RS-485区别详解</a>》</li>\n<li>《<a href=\"http://www.elecfans.com/yuanqijian/yinjiaotu/20180418664020.html\">一文看懂sp3232与max3232区别</a>》</li>\n<li>《<a href=\"https://zh.wikipedia.org/wiki/USB\">USB</a>》</li>\n</ol>\n","categories":["Communication"],"tags":["Serial","Terminology"]},{"title":"蓝牙术语","url":"/2019/01/07/Communication/2019-01-07-%E8%93%9D%E7%89%99%E6%9C%AF%E8%AF%AD/","content":"<p>蓝牙有超过20种不同的配置文件，涵盖了从手机到打印机，耳机，麦克风，笔记本电脑，车辆以及现在用于物联网/ M2M应用的蓝牙的各种不同类型的蓝牙设备，它还涵盖了各种可能的设备在这些场景中也会遇到。</p>\n<h1 id=\"a2dp\">A2DP</h1>\n<p>Advanced Audio Distribution Profile，蓝牙音频传输模型协定。</p>\n<h1 id=\"l2cap\">L2CAP</h1>\n<p>Logic Link Control and Adaptation Protocol, 逻辑链路控制和适配协议。是蓝牙系统中的核心协议，负责适配基带中的上层协议。</p>\n<h1 id=\"gap-gatt\">GAP &amp; GATT</h1>\n<p>GAP（Generic Access Profile，通用访问协议）、GATT（Generic Attribute Profile，通用属性协议）。 两个协议都隶属于Host层，直接关系到应用层开发，与BLE开发人员的关系比较密切，其分别负责连接前数据广播和连接后的数据传输。</p>\n<h1 id=\"spp\">SPP</h1>\n<p>Serial Port Profile，蓝牙串口协议，用于蓝牙设备和其他设备之间的串口数据传输。</p>\n<h1 id=\"spi\">SPI</h1>\n<p>Serial peripheral interface, 串行外围设备接口，是由Motorola首先在其MC68HCxx系列单片机上定义的，基于高速全双工总线的通讯协议。</p>\n<h1 id=\"vfs\">VFS</h1>\n<p>Virtual File System，虚拟文件系统组件。为可以对类文件对象执行操作的驱动程序提供统一接口。这可以是真实的文件系统（FAT、SPIFFS等），也可以是暴露文件类接口的驱动程序。</p>\n<h1 id=\"initiator-acceptor\">Initiator &amp; Acceptor</h1>\n<p>BT SPP Initiator 和 BT SPP Acceptor，就是蓝牙串口数据发送端和蓝牙串口数据接收端，跟GATT服务有关。</p>\n<p>引用原文《<a href=\"https://www.espressif.com/sites/default/files/documentation/btble_coexistence_demo_en.pdf\">ESP32 BT &amp; BLE Dual-mode Bluetooth</a>》 &gt; After the initialization of both the controller and the host, the BT SPP acceptor and the BLE GATT server are initialized. &gt; After the DEV_A is powered on, the functions of the BT SPP initiator and the BLE GATT client are initialized.</p>\n<h1 id=\"mtu-size\">MTU size</h1>\n<p>Maximum Transmission Unit，最大传输单元，是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。最大传输单元这个参数通常与通信接口有关（网络接口卡、串口等）。</p>\n<h1 id=\"ble-scan-duplicate-options\">BLE Scan Duplicate Options</h1>\n<p>The maximum number of devices in scan duplicate filter depends on the free heap size.</p>\n<h1 id=\"eddystone\">Eddystone</h1>\n<p>Eddystone是由Google开发的开放式信标（Beacon）格式，其设计考虑了透明度和稳健性。</p>\n<h1 id=\"ibeacon\">iBeacon</h1>\n<p>iBeacon是苹果公司提出的“一种可以让附近手持电子设备检测到的一种新的低功耗、低成本信号传送器”的一套可用于室内定位系统的协议。</p>\n<h1 id=\"ibeacon和eddystone的比较\">iBeacon和EddyStone的比较</h1>\n<figure>\n<img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/07/%E8%93%9D%E7%89%99%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D/%E5%9B%BE%E7%89%871.png\" alt=\"iBeacon和EddyStone的比较\" /><figcaption aria-hidden=\"true\">iBeacon和EddyStone的比较</figcaption>\n</figure>\n<h1 id=\"hid\">HID</h1>\n<p>Human Interface Device, 人类接口设备，或称人体学输入设备，是一种与人类在直接交互的计算设备，通常提供一种人类可用的输入方法，以及可能将输出信息传递给人类。</p>\n<h1 id=\"uuid\">UUID</h1>\n<p>Universally Unique Identifier, 通用唯一识别码，是用于计算机体系中以识别信息数目的一个128位标识符。</p>\n<h1 id=\"guid\">GUID</h1>\n<p>Global Unique Indentifier，全局唯一标识符。</p>\n<h1 id=\"参考链接\">参考链接</h1>\n<ol type=\"1\">\n<li>《<a href=\"https://www.electronics-notes.com/articles/connectivity/bluetooth/profiles.php\">蓝牙配置文件</a>》</li>\n<li>《<a href=\"https://en.wikipedia.org/wiki/List_of_Bluetooth_protocols\">List of Bluetooth protocols</a>》</li>\n<li>《<a href=\"https://www.cnblogs.com/hzl6255/p/3801732.html\">Bluetooth L2CAP介绍</a>》</li>\n</ol>\n","categories":["Communication"],"tags":["Terminology","Bluetooth"]},{"title":"iBeacon专有名词","url":"/2019/01/09/Communication/2019-01-09-iBeacon%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D/","content":"<h1 id=\"adv_pdu-type\">ADV_PDU Type</h1>\n<h2 id=\"pdu\">PDU</h2>\n<p>Protocol Data Unit, 协议数据单元。</p>\n<h1 id=\"adv_ind\">ADV_IND</h1>\n<p>可连接的无向广告</p>\n<h1 id=\"adv_nonconn_ind\">ADV_NONCONN_IND</h1>\n<p>不可连接的无向广告</p>\n<h1 id=\"adv_dir_ind\">ADV_DIR_IND</h1>\n<h1 id=\"adv_disc\">ADV_DISC</h1>\n<h1 id=\"adv_connreq\">ADV_CONNREQ</h1>\n<h1 id=\"adv_scanreq\">ADV_SCANREQ</h1>\n<h1 id=\"adv_scanrsp\">ADV_SCANRSP</h1>\n<h1 id=\"参考链接\">参考链接</h1>\n<ol type=\"1\">\n<li>《<a href=\"https://support.kontakt.io/hc/en-gb/articles/201492492-iBeacon-advertising-packet-structure\">iBeacon advertising packet structure</a>》</li>\n</ol>\n","categories":["Communication"],"tags":["Terminology","Bluetooth","iBeacon"]},{"title":"了解不同类型的BLE Beacon","url":"/2019/01/09/Communication/2019-01-09-%E4%BA%86%E8%A7%A3%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84BLE_Beacon/","content":"<p><a href=\"https://os.mbed.com/blog/entry/BLE-Beacons-URIBeacon-AltBeacons-iBeacon/\">原文</a>中的URIBeacon已被Google Eddystone替代，因此本文并非完全由原文转载，有小幅度更改。</p>\n<h1 id=\"蓝牙低功耗ble信标\">蓝牙低功耗（BLE）信标</h1>\n<p>有几种类型（Eddystone，AltBeacon，iBeacon），每种类型都有自己的标准和优势。有些是开放和免费的，有些是封闭的，需要花钱。本文将介绍可用信标的三种主要类型，它们的优点，缺点，衍生物以及有关信标如何工作的一些低级实现细节。确保查看所有可用作BLE信标的已启用mbed的BLE平台。</p>\n<h1 id=\"概观\">概观</h1>\n<p>蓝牙低功耗（BLE）能够以两种状态之一交换数据：连接和广告模式。连接模式使用通用属性（GATT）层以一对一的方式传输数据。广告模式使用通用访问配置文件（GAP）层向正在收听的任何人广播数据。广告模式是一对多转移，无法保证数据的一致性。</p>\n<p>BLE Beacons利用GAP广告模式以定期的，特殊格式的广告包广播数据。每种类型的信标都使用自定义规范来对广告数据进行分区，从而赋予其意义。我将看看三种现有类型的信标，URI Beacons，iBeacons和AltBeacons。mbed BLE团队页面支持所有信标类型，如果您想尝试它们，请提供包含文档的示例项目。</p>\n<h1 id=\"ibeacon\">iBeacon</h1>\n<p>Apple的iBeacon是第一款出现的BLE Beacon技术，因此大多数信标都从iBeacon数据格式中获取灵感。iBeacons在几个Apple SDK中启用，可以从任何支持BLE的iDevice读取和广播。iBeacon是一种专有的封闭式标准。iBeacons有一个庞大的生态系统，并为开发人员提供了大量资源，但您必须成为Apple开发人员社区的一员。</p>\n<h2 id=\"数据规格\">数据规格</h2>\n<p>iBeacons播放了四条信息： 1. 标识信标的UUID。 2. 标识大组中信标子集的主要编号。 3. 标识特定信标的次要编号。 4. TX功率电平为2的补码，表示距设备一米的信号强度。必须由用户或制造商为每个设备校准此编号。</p>\n<p>扫描应用程序读取UUID，主要编号和次要编号，并针对数据库引用它们以获取有关信标的信息; 信标本身不包含描述性信息 - 它要求此外部数据库有用。TX功率字段与测量的信号强度一起使用以确定信标距智能电话的距离。请注意，用户必须在信标的基础上校准TxPower才能准确。</p>\n<figure>\n<img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/09/%E4%BA%86%E8%A7%A3%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84BLE_Beacon/diagramredo.png\" alt=\"iBeacon-Diagramredo\" /><figcaption aria-hidden=\"true\">iBeacon-Diagramredo</figcaption>\n</figure>\n<p>iBeacon前缀包含十六进制数据：0x02 01 06 1A FF 00 4C 02 15。这分解如下：</p>\n<ul>\n<li>0x020106将广告包定义为BLE General Discoverable和BR / EDR高速不兼容。实际上它说它只是广播，而不是连接。</li>\n<li>0x1AFF表示以下数据长度为26个字节，并且是制造商特定数据。</li>\n<li>0x004C是Apple的蓝牙Sig ID，是该规范的一部分，使其依赖于Apple。</li>\n<li>0x02是表示邻近信标的辅助ID，由所有iBeacons使用。</li>\n<li>0x15将剩余长度定义为21个字节（16 + 2 + 2 + 1）。</li>\n</ul>\n<p>其余的字段相当自我解释。邻近UUID是标准的16byte / 128bit BLE UUID，通常是公司独有的。主要和次要数字用于表示UUID内的资产; 常见用途是主要数字是商店（因此可能有65,536个商店），其中次要数字是商店内的单个标签（每个商店还有65,536个可能的标签）。</p>\n<h2 id=\"例子\">例子</h2>\n<ol type=\"1\">\n<li>一家咖啡店在一个咖啡架和一个寄存器上放置了iBeacons。当顾客走进咖啡店足够近时，智能手机应用程序会看到iBeacon，搜索咖啡店的iBeacon数据库，将iBeacon识别为属于coffeeShop X，然后看到咖啡有效的优惠券，并通知优惠券的用户。</li>\n<li>iDevices可以广播iBeacon。这可用于在活动中自动登记并跟踪整个场地的移动。</li>\n<li>请参阅mbed iBeacon设备页面上的嵌入式设备代码。</li>\n</ol>\n<p>这是如何设置iBeacon设备以使用mbed BLE_API广播具有主要和次要号码的UUID的示例。请注意，tx功率水平应根据设备的1米测量用户校准。 <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;mbed.h&quot;</span><br><span class=\"line\">#include &quot;iBeaconService.h&quot;</span><br><span class=\"line\">...</span><br><span class=\"line\">BLEDevice ble;</span><br><span class=\"line\">const uint8_t uuid[] &#x3D; &#123;0xE2, 0x0A, 0x39, 0xF4, 0x73, 0xF5, 0x4B, 0xC4,     &#x2F;&#x2F; 16Byte UUID</span><br><span class=\"line\">                        0xA1, 0x2F, 0x17, 0xD1, 0xAD, 0x07, 0xA9, 0x61</span><br><span class=\"line\">                       &#125;;</span><br><span class=\"line\">uint16_t majorNumber &#x3D; 1122;  &#x2F;&#x2F; 2 byte major number</span><br><span class=\"line\">uint16_t minorNumber &#x3D; 3344;  &#x2F;&#x2F; 2 byte minor number</span><br><span class=\"line\">uint16_t txPower &#x3D; 0xC8;      &#x2F;&#x2F; 1 byte tx power level</span><br><span class=\"line\">...</span><br><span class=\"line\">int main(void)&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    iBeaconService ibeacon(ble, uuid, majorNumber, minorNumber, txPower);</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    while(1)&#123;</span><br><span class=\"line\">        ble.waitForEvent();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"思考\">思考</h2>\n<p>iBeacons非常酷，得到广泛支持，因为它们是Apple产品，所以每个人都在与它们合作，生态系统尽可能健壮。唯一的限制是需要数据库来为iBeacon数据赋予意义。没有数据库，UUID就毫无意义。你可以在这里找到mbed iBeacon的例子。</p>\n<h2 id=\"衍生品\">衍生品</h2>\n<p>一个流行的衍生产品是用不同的公司代码替换0x004C代码，例如分配给Nordic Semiconductor的0x0059。该NRF烽火台应用和nrf51822蓝牙智能灯塔套件就是这样的例子。 一些公司提供的示例未明确使用iBeacon规范。</p>\n<h1 id=\"altbeacon\">AltBeacon</h1>\n<p>AltBeacons是Radius Networks提供的开放式免费信标设计。它似乎正在获得一些动力。AltBeacon规范似乎是对Apple正在使用的闭源iBeacon规范的直接反应; 它涵盖了与iBeacon相同的功能，但不是公司特定的。也就是说，它尚未获得广泛支持。</p>\n<p>值得注意的是，虽然iBeacons有20个27字节可用于用户数据（UUID + Major + Minor），但AltBeacons有28个28字节可用（MFG ID，BeaconCode，BeaconID，MFG RSVD）。这意味着每条消息可以传送更多数据。</p>\n<h2 id=\"数据规格-1\">数据规格</h2>\n<p>所述AltBeacon规格是28bytes（26B是用户可修改的）。AltBeacon的前两个字节不是用户可修改的，而是由BLE堆栈设置的。ADV长度为0x1B，ADV类型为0xFF; 这些将分别指定广告数据包的长度和类型作为制造数据。之后，一切都由用户决定，可以推送到广告制造商数据字段。请注意，在大多数情况下，MFG ID将与Bluetooth Sig分配的号码文档相关联。</p>\n<figure>\n<img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/09/%E4%BA%86%E8%A7%A3%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84BLE_Beacon/altbeacon-spec-exploded-view.png\" alt=\"altbeacon-spec-exploded-view\" /><figcaption aria-hidden=\"true\">altbeacon-spec-exploded-view</figcaption>\n</figure>\n<h2 id=\"例子-1\">例子</h2>\n<p>用于iBeacons的相同示例适用于AltBeacons，具有以下修改：</p>\n<ol type=\"1\">\n<li>具有不同制造商ID的能力。</li>\n<li>具有不同信标码的能力。</li>\n<li>最后保留数据的一个字节，用于保存特定的制造商信息。</li>\n</ol>\n<p>使用AltBeacon，可以使用特定于应用程序的UUID而不是特定于公司的UUID，从而可以更改公司ID。虽然目前没有任何东西正在利用这一点，但我可以想象信标广播UUID用于信标服务，比如温度服务，然后提供制造公司的信息和温度，这样提供任何人的温度值。步行可以查看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;mbed.h&quot;</span><br><span class=\"line\">#include &quot;AltBeaconService.h&quot;</span><br><span class=\"line\">...</span><br><span class=\"line\">BLEDevice ble;</span><br><span class=\"line\">uint8_t beaconID[] &#x3D; &#123;  0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,     &#x2F;&#x2F; 16B of UUID + 4B subdivided as needed.</span><br><span class=\"line\">                        0x10,0x11,0x12,0x13,0x14,0x15,0x00,0x01,0x00,0x02 &#125;;</span><br><span class=\"line\">uint16_t manufacturerID &#x3D; 0x5900; &#x2F;&#x2F;Nordic SIG ID</span><br><span class=\"line\">int8_t rssi &#x3D; -122;</span><br><span class=\"line\">...</span><br><span class=\"line\">int main(void)&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    AltBeaconService altbeacon(ble, manufacturerID, beaconID, rssi); &#x2F;&#x2F; Add AltBeacon service to BLE object</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    while(1)&#123;</span><br><span class=\"line\">        ble.waitForEvent();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"思考-1\">思考</h2>\n<p>AltBeacons有很大的可能性。它们充分利用了它们所拥有的空间，或多或少地向后兼容iBeacons，并且是开源的。这说它是一个非常新的规范，几乎没有人使用它，并且它与iBeacons的市场渗透作斗争是一场艰苦的战斗。我认为，越来越多的人会使用AltBeacons，因为他们可以携带更多的数据并拥有更广泛的用例 - 这是开放式蛋糕上的一个樱桃。您可以在此处找到mbed AltBeacon示例代码。</p>\n<h1 id=\"eddystone\">Eddystone</h1>\n<p><a href=\"https://github.com/google/eddystone\">Eddystone</a>前身为<a href=\"https://github.com/google/uribeacon\">URIBeacon</a>（发音为YUR-ee-BEE-kun）</p>\n<p>Eddystone是由Google开发的开放式信标格式，其设计考虑了透明度和稳健性。Android和iOS设备都可以检测到Eddystone。Eddystone格式建立在现有部署中与行业合作伙伴合作的经验教训的基础上，以及更广泛的灯塔社区。帧格式中可以包含几种不同类型的有效载荷，包括：</p>\n<ul>\n<li>Eddystone-UID：一个唯一的静态ID，带有一个10字节的命名空间组件和一个6字节的实例组件。</li>\n<li>Eddystone-URL：经过解析和解压缩后，可由客户端直接使用的压缩URL。</li>\n<li>Eddystone-TLM：信标状态数据，可用于信标队维护，并为Google Proximity Beacon API的诊断端点提供支持。-TLM应与识别帧交错，例如Eddystone-UID或Eddystone-EID（加密的eTLM版本保留安全性）。</li>\n<li>Eddystone-EID：时变信标帧，可通过链接解析器（例如Proximity Beacon API）解析为稳定标识符。</li>\n</ul>\n<p>此外，Eddystone还包括配置服务和品牌材料。为确保您的部署完全支持Google信标平台，您应该使用Eddystone-UID或-EID设置信标，并可选择添加-URL和-TLM。</p>\n","categories":["Communication"],"tags":["Bluetooth","Beacon"]},{"title":"I^2^C、SPI、TDM及I2S","url":"/2021/05/14/Communication/2021-05-14-I2C%E3%80%81SPI%E3%80%81TDM%E5%8F%8AI2S/","content":"<h1 id=\"i2c\">I<sup>2</sup>C</h1>\n<p><strong>标准</strong>：<a href=\"https://www.nxp.com/docs/en/user-guide/UM10204.pdf\">《NXP_UM10204_I<sup>2</sup>C-bus specification and user manual》</a></p>\n<blockquote>\n<p><em>I<sup>2</sup>C总线是一个事实上的世界标准，现在已经在50多家公司生产的1000多种不同的IC中实施。</em></p>\n<p><em>此外，多功能的I<sup>2</sup>C总线被用于各种控制架构，如系统管理总线（SMBus）、电源管理总线（PMBus）、智能平台管理接口（IPMI）、显示数据通道（DDC）和高级电信计算架构（ATCA）。</em></p>\n<p><em>本文件帮助设备和系统设计者了解I<sup>2</sup>C总线的工作原理并实现工作应用。描述了各种操作模式。它包含了对I<sup>2</sup>C<strong>总线数据传输</strong>、握手和总线仲裁方案的全面介绍。详细的章节涵盖了I<sup>2</sup>C总线在每种工作模式下的时序和电气规范。</em></p>\n<p><em>I<sup>2</sup>C兼容芯片的设计者应将该文件作为参考，并确保新设备满足该文件中规定的所有限制。包含I<sup>2</sup>C器件的系统的设计者应审查本文件，并参考各个组件的数据表。</em></p>\n<p>——翻译自标准文件</p>\n</blockquote>\n<p>I<sup>2</sup>C(Inter－Integrated Circuit)是一种通用的总线协议。它是由Philips(飞利浦)公司，现NXP(恩智浦)半导体开发的一种简单的双向两线制总线协议标准。</p>\n<p>对于硬件设计人员来说，只需要2个管脚，极少的连接线和面积，就可以实现芯片间的通讯，对于软件开发者来说，可以使用同一个I<sup>2</sup>C驱动库，来实现实现不同器件的驱动，大大减少了软件的开发时间。极低的工作电流，降低了系统的功耗，完善的应答机制大大增强通讯的可靠性。</p>\n<h2 id=\"术语\">术语</h2>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210514111033910.png\" alt=\"image-20210514111033910\" style=\"zoom: 67%;\" /></p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>术语</th>\n<th>释义</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>总线</td>\n<td>传输数据的通路</td>\n</tr>\n<tr class=\"even\">\n<td>传送者</td>\n<td>传输数据至总线的设备</td>\n</tr>\n<tr class=\"odd\">\n<td>接收者</td>\n<td>从总线上接受数据的设备</td>\n</tr>\n<tr class=\"even\">\n<td>主（机）</td>\n<td>主动开启传输、生成时钟信号 并 主动结束传输的设备</td>\n</tr>\n<tr class=\"odd\">\n<td>从（机）</td>\n<td>由主机寻址的设备</td>\n</tr>\n<tr class=\"even\">\n<td>多主（机）</td>\n<td>在不损坏数据传输的情况下允许多主机可以试图同时控制总线</td>\n</tr>\n<tr class=\"odd\">\n<td>仲裁</td>\n<td>确保在有多个主机同时试图控制总线的情况下，只允许一个主机这样做，而且仲裁成功的信息不会被（其他设备）破坏的程序。</td>\n</tr>\n<tr class=\"even\">\n<td>同步</td>\n<td>确保两个及以上设备其时钟信号的同步</td>\n</tr>\n</tbody>\n</table>\n<p>以下这个图应该可以较好地解释“多主机”的概念，多个主机可以同时向外发出传输数据的申请，也可以主动结束其数据传输。虽然，I<sup>2</sup>C降低了总线复用的成本，但仍需要“仲裁”机制来解决多个主机之间的无序竞争状态。</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210514112114667.png\" alt=\"image-20210514112114667\" style=\"zoom:67%;\" /></p>\n<h2 id=\"总线特征\">总线特征</h2>\n<h3 id=\"总线硬件要求\">总线硬件要求</h3>\n<p>通过 <strong>串行数据</strong>（SDA，Serial Data）和 <strong>串行时钟</strong>（SCL，Serial Clock）两条线路对设备进行连接。</p>\n<p>每个设备都通过自身的通信设备地址进行互相辨别，且每个设备都可以当发送者或接收者，取决于设备自身的功能定义。</p>\n<h3 id=\"标准传输速率\">标准传输速率</h3>\n<p>各模式、速率及其传输方向见下方表格。</p>\n<blockquote>\n<p>Data on the I<sup>2</sup>C-bus can be transferred at rates of up to 100 kbit/s in the Standard-mode, up to 400 kbit/s in the Fast-mode, up to 1 Mbit/s in Fast-mode Plus, or up to 3.4 Mbit/s in the High-speed mode.</p>\n</blockquote>\n<table>\n<thead>\n<tr class=\"header\">\n<th>MODE</th>\n<th>RATE</th>\n<th>TRANSFER DIRECTION</th>\n<th>DOWNWARD COMPATIBLE WITH</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>STANDARD</td>\n<td>100 Kbit/s</td>\n<td>bidirectional</td>\n<td>/</td>\n</tr>\n<tr class=\"even\">\n<td>FAST</td>\n<td>400 Kbit/s</td>\n<td>bidirectional</td>\n<td>STANDARD</td>\n</tr>\n<tr class=\"odd\">\n<td>FAST-PLUS</td>\n<td>1 Mbit/s</td>\n<td>bidirectional</td>\n<td>STANDARD / FAST</td>\n</tr>\n<tr class=\"even\">\n<td>HIGH-SPEED</td>\n<td>3.4 Mbit/s</td>\n<td>bidirectional</td>\n<td>STANDARD / FAST / FAST-PLUS</td>\n</tr>\n<tr class=\"odd\">\n<td>ULTRA-FAST</td>\n<td>5 Mbit/s</td>\n<td>unidirectional</td>\n<td>/</td>\n</tr>\n</tbody>\n</table>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210522182927364.png\" alt=\"image-20210522182927364\" /><figcaption aria-hidden=\"true\">image-20210522182927364</figcaption>\n</figure>\n<h2 id=\"协议要求\">协议要求</h2>\n<p>以下协议要求适用于双向通信模式（不包括ULTRA-FAST模式下的单向通信）</p>\n<h3 id=\"逻辑电平规定\">逻辑电平规定</h3>\n<p>由于I<sup>2</sup>C的接入设备众多（如CMOS、NMOS、Bipolar等），因此逻辑电平0和逻辑电平1（的电压）并不是固定不变的，这取决于VDD的电平。</p>\n<p>输入参考电平会被控制在VDD电平的30%~70%之间。 V<sub>IL</sub> = 0.3 * V<sub>DD</sub>；V<sub>IH</sub> = 0.7 * V<sub>DD</sub> 。</p>\n<p>某些传统设备的输入电平会被固定在1.5V（V<sub>IL</sub>）和3.0V（V<sub>IH</sub>），但新设备都要求是 30%V<sub>DD</sub> 及 70%V<sub>DD</sub> 。</p>\n<p><strong>注意</strong>：V<sub>IL</sub>、V<sub>IH</sub>、V<sub>OL</sub>、V<sub>OH</sub>都是以参考电压作为基准的，即要达到某个电压的百分之多少时，才能够被认为是 <strong>逻辑电平0</strong> 或 <strong>逻辑电平1</strong> 。例如，可将V<sub>IL</sub> 视作当V<sub>DD</sub>下降到只有30%及以下时，为逻辑电平0，30%V<sub>DD</sub>是其逻辑电平的最高阈值；同理可得 V<sub>IH</sub> ；超过这个值而未到达70%的中间态则为不确定态。</p>\n<blockquote>\n<p>Due to the variety of different technology devices (CMOS, NMOS, bipolar) that can be connected to the I<sup>2</sup>C-bus, the levels of the logical ‘0’ (LOW) and ‘1’ (HIGH) are not fixed and depend on the associated level of VDD . Input reference levels are set as 30 % and 70 % of VDD ; VIL is 0.3VDD and VIH is 0.7V DD .</p>\n<p>See Figure 38, timing diagram. Some legacy device input levels were fixed at V<sub>IL</sub> = 1.5 V and V<sub>IH</sub> = 3.0 V, but all new devices require this 30 %/70 % specification.</p>\n</blockquote>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210514134830615.png\" alt=\"image-20210514134830615\" style=\"zoom: 67%;\" /></p>\n<h3 id=\"时序正确性\">时序正确性</h3>\n<ul>\n<li>SDA上的数据必须在SCL高电平期间保持稳定，即不能在SCL高电平期间发生翻转（后见原因），只有在SCL低电平时可以翻转。</li>\n<li>时钟脉冲信号生成要先于数据传送。</li>\n</ul>\n<blockquote>\n<p>The data on the SDA line must be stable during the HIGH period of the clock. The HIGH or LOW state of the data line can only change when the clock signal on the SCL line is LOW (see Figure 4). One clock pulse is generated for each data bit transferred.</p>\n</blockquote>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210514141512136.png\" alt=\"image-20210514141512136\" style=\"zoom: 80%;\" /></p>\n<h3 id=\"开始及结束标志\">开始及结束标志</h3>\n<ul>\n<li><p>传输开始时必须以一个 <strong>开始</strong> 信号作为标志，结束时必须以一个 <strong>结束</strong> 信号作为标志。</p></li>\n<li><p><strong>开始信号 </strong>是以SCL为高电平时的 <strong>SDA电平的由高转低</strong> 作为标志，<strong>结束信号</strong> 是以SCL高电平时的 <strong>SDA电平的由低转高</strong> 作为标志。</p></li>\n<li><p>开始和结束标志必须由主设备控制。</p></li>\n</ul>\n<blockquote>\n<p>All transactions begin with a START (S) and are terminated by a STOP (P) (see Figure 5). A HIGH to LOW transition on the SDA line while SCL is HIGH defines a START condition. A LOW to HIGH transition on the SDA line while SCL is HIGH defines a STOP condition.</p>\n</blockquote>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210514142116674.png\" alt=\"image-20210514142116674\" style=\"zoom: 80%;\" /></p>\n<h4 id=\"开始字节\">开始字节</h4>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210515150526897.png\" alt=\"image-20210515150526897\" style=\"zoom:67%;\" /></p>\n<blockquote>\n<p>dummy acknowledge (HIGH) : 无声确认？？？</p>\n</blockquote>\n<h3 id=\"总线状态\">总线状态</h3>\n<p>总线具有两种状态，<strong>繁忙</strong>（Busy）和 <strong>空闲</strong>（Free），即 SDA电平 “开始” 后，总线进入繁忙状态， SDA电平 “结束” 后，总线进入空闲状态。</p>\n<p><strong>注意</strong>：在总线繁忙期间，发生重复的“开始”状态（而不是“结束”状态），由于“重复开始”和 “开始” 功能相同，为了方便，统称为 “开始”，除非特殊说明为 “重复开始”。</p>\n<blockquote>\n<p>The bus stays busy if a repeated START (Sr) is generated instead of a STOP condition. In this respect, the START (S) and repeated START (Sr) conditions are functionally identical. For the remainder of this document, therefore, the S symbol is used as a generic term to represent both the START and repeated START conditions, unless Sr is particularly relevant.</p>\n</blockquote>\n<h3 id=\"传输比特位\">传输比特位</h3>\n<ul>\n<li>SDA线上的字节传输必须满足8位长度。</li>\n<li>每次传输数据的字节数不受限制。</li>\n<li>每个字节数后都需要跟一个<strong>确认位（Acknowledge bit）</strong>。</li>\n<li>当从机无法完整接收或传输一个完整的数据字节时，例如正在产生内部中断等，除非其完成内部的某些功能，否则该从机将能够一直拉低SCL的电平，<strong>强制让主机一直处于等待状态</strong>。只有当从机准备好接收下一个完整的字节并释放SCL时，数据传输才会继续。</li>\n</ul>\n<blockquote>\n<p>Every byte put on the SDA line must be eight bits long. The number of bytes that can be transmitted per transfer is unrestricted. Each byte must be followed by an Acknowledge bit.</p>\n<p><strong>Data is transferred with the Most Significant Bit (MSB) first</strong> (see Figure 6). If a slave cannot receive or transmit another complete byte of data until it has performed some other function, for example servicing an internal interrupt, it can hold the clock line SCL LOW to force the master into a wait state. Data transfer then continues when the slave is ready for another byte of data and releases clock line SCL.</p>\n</blockquote>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210514144620803.png\" alt=\"image-20210514144620803\" style=\"zoom:80%;\" /></p>\n<h3 id=\"确认标志\">确认标志</h3>\n<ul>\n<li>每个字节（8比特）后都跟着一个确认位，即前8位数据，第9位确认。</li>\n<li><strong>SCL上的时钟信号由主机产生，包括确认位的的第九个时钟脉冲</strong>。</li>\n<li>SDA线并不是由主机一直占有的，每发送完一个完整字节后，主机都会释放SDA线，由从机进行数据确认。</li>\n<li>发送者在确认时钟脉冲期间释放SDA线，以便接收者可以将SDA线拉低，并且在该时钟脉冲的高电平期间保持稳定的低电平（见图4）。</li>\n<li>对于设置（set-up）和保持（Hold）的时间，都应该依照表10中只针对各种不同模式的要求进行设置。</li>\n<li>如果SDA电平在第九个时钟脉冲时仍保持高电平，则被定义为 “未确认状态”。则此时主机可以发送一个“结束”标志来结束当前连接，或发送一个“开始”标志来开启一次新的传送。</li>\n</ul>\n<p><img src=\"/home/kali/.config/Typora/typora-user-images/image-20210514154506246.png\" alt=\"image-20210514154506246\" style=\"zoom: 80%;\" /></p>\n<blockquote>\n<p>The acknowledge takes place after every byte. The acknowledge bit allows the receiver to signal the transmitter that the byte was successfully received and another byte may be sent. The master generates all clock pulses, including the acknowledge ninth clock pulse.</p>\n<p>The Acknowledge signal is defined as follows: the transmitter releases the SDA line during the acknowledge clock pulse so the <strong><em>receiver can pull the SDA line LOW</em></strong> and it remains stable LOW during the HIGH period of this clock pulse (see Figure 4). Set-up and hold times (specified in Section 6) must also be taken into account.</p>\n<p>When SDA remains HIGH during this ninth clock pulse, this is defined as the Not Acknowledge signal. The master can then generate either a STOP condition to abort the transfer, or a repeated START condition to start a new transfer.</p>\n</blockquote>\n<p><strong>以下为五种“未确认/未应答”的可能情况</strong>：There are five conditions that lead to the generation of a NACK:</p>\n<ol type=\"1\">\n<li><strong>传输地址错误</strong>：No receiver is present on the bus with the transmitted address so there is no device to respond with an acknowledge.</li>\n<li><strong>实时处理中</strong>：The receiver is unable to receive or transmit because it is performing some real-time function and is not ready to start communication with the master.</li>\n<li><strong>数据/代码未定义</strong>：During the transfer, the receiver <strong>gets data or commands that it does not understand.</strong></li>\n<li><strong>正在传输中</strong>：During the transfer, the receiver <strong>cannot receive any more data bytes</strong>.</li>\n<li><strong>未收到结束信号（收发身份未转换）</strong>：A master-receiver must signal the end of the transfer to the slave transmitter.</li>\n</ol>\n<h3 id=\"时钟同步\">时钟同步</h3>\n<p>任意几个主机都可能同时发起数据传输请求，此时只有一个主机和一个从机可以掌握总线进行通信，此时需要通过 <strong>时间同步</strong> 和 <strong>仲裁</strong> 完成对总线的调配。</p>\n<p><strong>在单机系统（Single Master System）中，不需要时钟同步和仲裁。</strong></p>\n<p>时钟同步是通过I<sup>2</sup>C接口与SCL线的有线-AND连接进行的。</p>\n<p>这意味着SCL线上的高电平到低电平的转换会导致相关的主站开始对其低电平周期进行计数（如图7的CLK<sub>2</sub>），一旦一个主站时钟 CLK<sub>1</sub> 变为低电平，它就会将SCL线电平拉低，并保持在这个状态，直到另一个时钟 CLK<sub>2</sub> 达到高电平状态。</p>\n<p>然而，如果时钟 CLK<sub>2</sub> 仍在其低电平周期内，CLK<sub>1</sub> 的低电平到高电平转换可能不会改变SCL线的状态。</p>\n<p>因为SCL线被具有最长的低电平周期的主站 CLK<sub>2</sub> 保持为低电平，而在这段时间内，低电平周期较短的主站 CLK<sub>1</sub> 进入高电平等待状态。</p>\n<blockquote>\n<p>Clock synchronization is performed using the wired-AND connection of I<sup>2</sup>C interfaces to the SCL line. This means that a HIGH to LOW transition on the SCL line causes the masters concerned to start counting off their LOW period and, once a master clock has gone LOW, it holds the SCL line in that state until the clock HIGH state is reached (see Figure 7). However, if another clock is still within its LOW period, the LOW to HIGH transition of this clock may not change the state of the SCL line. The SCL line is therefore held LOW by the master with the longest LOW period. Masters with shorter LOW periods enter a HIGH wait-state during this time.</p>\n</blockquote>\n<p>当所有相关的主控器都结束了他们的低电平周期，时钟线被释放并变成高电平。</p>\n<p>然后，在主站时钟和SCL线的状态之间没有差异，所有的主站开始计算他们的高电平周期。</p>\n<p><strong>第一个完成其高电平周期的主站再次将SCL线拉到低电平</strong>。这样，就产生了一个<strong>同步的SCL时钟</strong>，<strong>其低电平周期由具有最长时钟低电平周期的主站决定</strong>，<strong>其高电平周期由具有最短时钟高电平周期的主站决定</strong>。</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210514170202184.png\" alt=\"image-20210514170202184\" style=\"zoom: 67%;\" /></p>\n<h3 id=\"竞争仲裁\">竞争仲裁</h3>\n<p>仲裁和同步一样，是指只有在系统中使用一个以上的主站时才需要的协议的一个部分。注意，从机不参与仲裁程序。</p>\n<p>一个主站只有在总线空闲时才可以开始传输。两个主站可以在START条件的最小保持时间（tHD;STA）内产生一个START条件，从而在总线上产生一个有效的START条件。然后需要进行仲裁，以确定哪个主站将完成其传输。</p>\n<p>仲裁是逐位进行的。在每个比特期间，当SCL为高电平时，每个主站检查SDA电平是否与其所发送的内容相符，期间可能需要很多比特，只要传输的内容相同，两个主站实际上可以无误地完成整个信息传输过程。</p>\n<p><mark>当一个主站第一次试图发送一个高电平，但检测到SDA电平为低电平时，主站知道它已经失去了仲裁，并关闭其SDA输出驱动器</mark>。在其他主站被仲裁过程中，正在传输其信息的主站将继续其传输，没有信息丢失。</p>\n<p>失去仲裁的主站可以产生时钟脉冲，直到它失去仲裁的字节结束，并且必须在总线空闲时重新尝试传输。</p>\n<p><mark>如果一个主站也包含了一个从站功能，并且它在寻址阶段失去了仲裁，有可能获胜的主站正试图对它进行寻址。因此，失败的主站必须立即切换到其从站模式。</mark></p>\n<p>图8显示了两个主站的仲裁程序。可能涉及更多，这取决于有多少个主站连接到总线上。</p>\n<p><mark>当产生DATA1的主站的内部数据电平与SDA线上的实际电平有差异时，DATA1的输出被关闭。这并不影响由获胜主站发起的数据传输。</mark></p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210515142633906.png\" alt=\"image-20210515142633906\" style=\"zoom: 67%;\" /></p>\n<h3 id=\"时间拉伸\">时间拉伸</h3>\n<h3 id=\"从机地址和读取位\">从机地址和读取位</h3>\n<h3 id=\"位寻址\">10位寻址</h3>\n<h3 id=\"反转地址\">反转地址</h3>\n<h3 id=\"通用寻址\">通用寻址</h3>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210515172907284.png\" alt=\"image-20210515172907284\" /><figcaption aria-hidden=\"true\">image-20210515172907284</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210515172945861.png\" alt=\"image-20210515172945861\" /><figcaption aria-hidden=\"true\">image-20210515172945861</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210515172958184.png\" alt=\"image-20210515172958184\" /><figcaption aria-hidden=\"true\">image-20210515172958184</figcaption>\n</figure>\n<h3 id=\"软复位\">软复位</h3>\n<p>在发送general call (0000 0000)后，再发送一个 0000 0110 (06h) ，这样两个具有先后顺序的字节来定义软复位。</p>\n<p>首先，这种软复位是可选 ，并不是所有设备都会对软复位指令进行响应。</p>\n<p>在收到这2个字节的序列时，所有被设计为响应一般调用地址的设备都会复位，并接收其地址的可编程部分。</p>\n<blockquote>\n<p>On receiving this 2-byte sequence, all devices designed to respond to the general call address reset and take in the programmable part of their address.</p>\n</blockquote>\n<p>必须采取预防措施，确保设备在施加电源电压后没有拉低SDA或SCL线，因为这些低电平会阻断总线。</p>\n<h3 id=\"总线复位\">总线复位</h3>\n<p>SCK信号一直卡在低电平的事件较少发生。</p>\n<ul>\n<li>如果I<sup>2</sup>C总线设备拥有硬件复位输入，则可以通过优先程序启用硬件中断复位来重置总线。</li>\n<li>如果没有硬件复位输入，则通过给设备循环供电，激活强制性的内部开机复位（POR）电路。</li>\n</ul>\n<p>SDA信号如果一直卡在低电平。</p>\n<ul>\n<li><p>则主机应该发送九次SCL时钟脉冲，此时令SDA保持低电平的设备在收到九次脉冲后应主动释放总线。</p></li>\n<li><p>如果九次脉冲没有用，则启用硬件中断复位或循环供电来清除总线。</p></li>\n</ul>\n<h3 id=\"设备id\">设备ID</h3>\n<p>可选的3字节只读设备ID编码（an optional 3-byte read-only ）：</p>\n<ul>\n<li>12位是设备制造商编号，具有独一无二性</li>\n<li>9位零件ID，由设备制造商写入</li>\n<li>3位模具/晶元版本，由设备制造商写入</li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210515152141963.png\" alt=\"image-20210515152141963\" style=\"zoom:67%;\" /></p>\n<ol type=\"1\">\n<li><p>启动条件</p></li>\n<li><p>主站发送保留设备ID的 I<sup>2</sup>C 总线地址，后面的R/W位设置为<code>0</code>（写）：<code>1111 1000</code>。</p></li>\n<li><p>主站发送从属地址。LSB是一个 \"不关心\"的值，只有一个设备必须确认这个字节（拥有I<sup>2</sup>C总线从属地址的设备）。</p></li>\n<li><p>主站发送一个 Re-START 条件。</p></li>\n</ol>\n<blockquote>\n<p>备注：在 STOP 条件之后，再加上一个 START 条件，就会重置从属状态机，无法进行设备ID读取。另外，在 STOP 条件或 Re-START 条件之后，对另一个从属设备的访问也会重置从属状态机，无法执行Device ID读取。</p>\n</blockquote>\n<ol start=\"5\" type=\"1\">\n<li><p>主站发送保留设备ID的 I<sup>2</sup>C 总线地址，后面的R/W位设置为 <code>1</code>（读）：<code>1111 1001</code>。</p></li>\n<li><p>可以进行设备ID读取，从12个制造商位开始（第一个字节+第二个字节的4个MSB），然后是9个部件识别位（第二个字节的4个LSB+第三个字节的5个MSB），然后是三个芯片修订位（第三个字节的3个LSB）。</p></li>\n<li><p>主站通过NACKing最后一个字节来结束读取序列，从而重置从属设备的状态机，允许主站发送 STOP 条件。</p>\n<blockquote>\n<p>备注：设备ID的读取可以随时通过发送NACK来停止。</p>\n</blockquote></li>\n</ol>\n<p>如果主站在第三个字节之后继续ACK，从站就会滚回第一个字节，并继续发送设备ID序列，直到检测到 NACK。</p>\n<h1 id=\"spi\">SPI</h1>\n<p>标准：</p>\n<h2 id=\"术语-1\">术语</h2>\n<h2 id=\"spi和i2c的对比\">SPI和I<sup>2</sup>C的对比</h2>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>SPI</th>\n<th>I<sup>2</sup>C</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>通信模式</td>\n<td>全双工<br><em>（是指单主从设备之间的全双工，从设备之间无法进行通信）</em></td>\n<td>半双工<br><em>（任意主从设备可以分时复用同一条通信线路）</em></td>\n</tr>\n<tr class=\"even\">\n<td>主从模式</td>\n<td>一主多从</td>\n<td>多主多从</td>\n</tr>\n<tr class=\"odd\">\n<td>引脚占用</td>\n<td>从设备越多，对主机占用的引脚较多<br>主设备占用引脚：3+n<br>从设备占用引脚：4<br><em>（n为从设备数）</em></td>\n<td>主从设备均占用：2</td>\n</tr>\n<tr class=\"even\">\n<td>应答响应</td>\n<td>无</td>\n<td>有</td>\n</tr>\n<tr class=\"odd\">\n<td>传输速率</td>\n<td>最高：</td>\n<td>最高：3.4Mbps</td>\n</tr>\n<tr class=\"even\">\n<td>从机选择</td>\n<td>通过 <strong>CS(SS)选择引脚</strong> 来选择</td>\n<td>通过 <strong>器件地址</strong> 来选择</td>\n</tr>\n<tr class=\"odd\">\n<td>数据采样</td>\n<td>在SCLK边沿采样</td>\n<td>在SCL高电平采样</td>\n</tr>\n<tr class=\"even\">\n<td>通信距离</td>\n<td>短</td>\n<td>短</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"uart\">UART</h1>\n<p>标准：</p>\n<h1 id=\"tdm\">TDM</h1>\n<p>标准：</p>\n<h1 id=\"i2s\">I<sup>2</sup>S</h1>\n<p>标准：</p>\n","categories":["Communication"],"tags":["I^2^C","SPI","TDM","I2S"]},{"title":"I2C通信","url":"/2021/05/14/Communication/2021-05-14-I2C%E9%80%9A%E4%BF%A1/","content":"<h1 id=\"i2c基本通信规则\">I2C基本通信规则</h1>\n<p><strong>标准</strong>：<a href=\"https://www.nxp.com/docs/en/user-guide/UM10204.pdf\">《NXP_UM10204_I2C-bus specification and user manual》</a></p>\n<blockquote>\n<p><em>I<sup>2</sup>C总线是一个事实上的世界标准，现在已经在50多家公司生产的1000多种不同的IC中实施。</em></p>\n<p><em>此外，多功能的I<sup>2</sup>C总线被用于各种控制架构，如系统管理总线（SMBus）、电源管理总线（PMBus）、智能平台管理接口（IPMI）、显示数据通道（DDC）和高级电信计算架构（ATCA）。</em></p>\n<p><em>本文件帮助设备和系统设计者了解I<sup>2</sup>C总线的工作原理并实现工作应用。描述了各种操作模式。它包含了对I<sup>2</sup>C<strong>总线数据传输</strong>、握手和总线仲裁方案的全面介绍。详细的章节涵盖了I<sup>2</sup>C总线在每种工作模式下的时序和电气规范。</em></p>\n<p><em>I<sup>2</sup>C兼容芯片的设计者应将该文件作为参考，并确保新设备满足该文件中规定的所有限制。包含I<sup>2</sup>C器件的系统的设计者应审查本文件，并参考各个组件的数据表。</em></p>\n<p>——翻译自标准文件</p>\n</blockquote>\n<p>I<sup>2</sup>C(Inter－Integrated Circuit)是一种通用的总线协议。它是由Philips(飞利浦)公司，现NXP(恩智浦)半导体开发的一种简单的双向两线制总线协议标准。</p>\n<p>对于硬件设计人员来说，只需要2个管脚，极少的连接线和面积，就可以实现芯片间的通讯，对于软件开发者来说，可以使用同一个I<sup>2</sup>C驱动库，来实现实现不同器件的驱动，大大减少了软件的开发时间。极低的工作电流，降低了系统的功耗，完善的应答机制大大增强通讯的可靠性。</p>\n<h2 id=\"术语\">术语</h2>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210514111033910.png\" alt=\"image-20210514111033910\" style=\"zoom: 67%;\" /></p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>术语</th>\n<th>释义</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>总线</td>\n<td>传输数据的通路</td>\n</tr>\n<tr class=\"even\">\n<td>传送者</td>\n<td>传输数据至总线的设备</td>\n</tr>\n<tr class=\"odd\">\n<td>接收者</td>\n<td>从总线上接受数据的设备</td>\n</tr>\n<tr class=\"even\">\n<td>主（机）</td>\n<td>主动开启传输、生成时钟信号 并 主动结束传输的设备</td>\n</tr>\n<tr class=\"odd\">\n<td>从（机）</td>\n<td>由主机寻址的设备</td>\n</tr>\n<tr class=\"even\">\n<td>多主（机）</td>\n<td>在不损坏数据传输的情况下允许多主机可以试图同时控制总线</td>\n</tr>\n<tr class=\"odd\">\n<td>仲裁</td>\n<td>确保在有多个主机同时试图控制总线的情况下，只允许一个主机这样做，而且仲裁成功的信息不会被（其他设备）破坏的程序。</td>\n</tr>\n<tr class=\"even\">\n<td>同步</td>\n<td>确保两个及以上设备其时钟信号的同步</td>\n</tr>\n</tbody>\n</table>\n<p>以下这个图应该可以较好地解释“多主机”的概念，多个主机可以同时向外发出传输数据的申请，也可以主动结束其数据传输。虽然，I<sup>2</sup>C降低了总线复用的成本，但仍需要“仲裁”机制来解决多个主机之间的无序竞争状态。</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210514112114667.png\" alt=\"image-20210514112114667\" style=\"zoom:67%;\" /></p>\n<h2 id=\"硬件要求\">硬件要求</h2>\n<h3 id=\"电气特性\">电气特性</h3>\n<p>根据要求，I2C的高电平有效值要达到输入参考电压（一般是VDD）的0.7倍以上，低电平有效值需要达到输入参考电压的0.3倍以下。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210618143441.png\" alt=\"image-20210618143438565\" /><figcaption aria-hidden=\"true\">image-20210618143438565</figcaption>\n</figure>\n<h3 id=\"总线硬件要求\">总线硬件要求</h3>\n<p>通过 <strong>串行数据</strong>（SDA，Serial Data）和 <strong>串行时钟</strong>（SCL，Serial Clock）两条线路对设备进行连接。</p>\n<p>每个设备都通过自身的通信设备地址进行互相辨别，且每个设备都可以当发送者或接收者，取决于设备自身的功能定义。</p>\n<h3 id=\"标准传输速率\">标准传输速率</h3>\n<p>各模式、速率及其传输方向见下方表格。</p>\n<blockquote>\n<p>Data on the I<sup>2</sup>C-bus can be transferred at rates of up to 100 kbit/s in the Standard-mode, up to 400 kbit/s in the Fast-mode, up to 1 Mbit/s in Fast-mode Plus, or up to 3.4 Mbit/s in the High-speed mode.</p>\n</blockquote>\n<table>\n<thead>\n<tr class=\"header\">\n<th>MODE</th>\n<th>RATE</th>\n<th>TRANSFER DIRECTION</th>\n<th>DOWNWARD COMPATIBLE WITH</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>STANDARD</td>\n<td>100 Kbit/s</td>\n<td>bidirectional</td>\n<td>/</td>\n</tr>\n<tr class=\"even\">\n<td>FAST</td>\n<td>400 Kbit/s</td>\n<td>bidirectional</td>\n<td>STANDARD</td>\n</tr>\n<tr class=\"odd\">\n<td>FAST-PLUS</td>\n<td>1 Mbit/s</td>\n<td>bidirectional</td>\n<td>STANDARD / FAST</td>\n</tr>\n<tr class=\"even\">\n<td>HIGH-SPEED</td>\n<td>3.4 Mbit/s</td>\n<td>bidirectional</td>\n<td>STANDARD / FAST / FAST-PLUS</td>\n</tr>\n<tr class=\"odd\">\n<td>ULTRA-FAST</td>\n<td>5 Mbit/s</td>\n<td>unidirectional</td>\n<td>/</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"编码协议\">编码协议</h2>\n<p>以下协议要求适用于双向通信模式（不包括ULTRA-FAST模式下的单向通信）</p>\n<h3 id=\"逻辑电平规定\">逻辑电平规定</h3>\n<p>由于I<sup>2</sup>C的接入设备众多（如CMOS、NMOS、Bipolar等），因此逻辑电平0和逻辑电平1（的电压）并不是固定不变的，这取决于VDD的电平。</p>\n<p>输入参考电平会被控制在VDD电平的30%~70%之间。 V<sub>IL</sub> = 0.3 * V<sub>DD</sub>；V<sub>IH</sub> = 0.7 * V<sub>DD</sub> 。</p>\n<p>某些传统设备的输入电平会被固定在1.5V（V<sub>IL</sub>）和3.0V（V<sub>IH</sub>），但新设备都要求是 30%V<sub>DD</sub> 及 70%V<sub>DD</sub> 。</p>\n<p><strong>注意</strong>：V<sub>IL</sub>、V<sub>IH</sub>、V<sub>OL</sub>、V<sub>OH</sub>都是以参考电压作为基准的，即要达到某个电压的百分之多少时，才能够被认为是 <strong>逻辑电平0</strong> 或 <strong>逻辑电平1</strong> 。例如，可将V<sub>IL</sub> 视作当V<sub>DD</sub>下降到只有30%及以下时，为逻辑电平0，30%V<sub>DD</sub>是其逻辑电平的最高阈值；同理可得 V<sub>IH</sub> ；超过这个值而未到达70%的中间态则为不确定态。</p>\n<blockquote>\n<p>Due to the variety of different technology devices (CMOS, NMOS, bipolar) that can be connected to the I<sup>2</sup>C-bus, the levels of the logical ‘0’ (LOW) and ‘1’ (HIGH) are not fixed and depend on the associated level of VDD . Input reference levels are set as 30 % and 70 % of VDD ; VIL is 0.3VDD and VIH is 0.7V DD .</p>\n<p>See Figure 38, timing diagram. Some legacy device input levels were fixed at V<sub>IL</sub> = 1.5 V and V<sub>IH</sub> = 3.0 V, but all new devices require this 30 %/70 % specification.</p>\n</blockquote>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210514134830615.png\" alt=\"image-20210514134830615\" style=\"zoom: 67%;\" /></p>\n<h3 id=\"时序正确性\">时序正确性</h3>\n<ul>\n<li>SDA上的数据必须在SCL高电平期间保持稳定，即不能在SCL高电平期间发生翻转（后见原因），只有在SCL低电平时可以翻转。</li>\n<li>时钟脉冲信号生成要先于数据传送。</li>\n</ul>\n<blockquote>\n<p>The data on the SDA line must be stable during the HIGH period of the clock. The HIGH or LOW state of the data line can only change when the clock signal on the SCL line is LOW (see Figure 4). One clock pulse is generated for each data bit transferred.</p>\n</blockquote>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210514141512136.png\" alt=\"image-20210514141512136\" style=\"zoom: 80%;\" /></p>\n<h3 id=\"开始及结束标志\">开始及结束标志</h3>\n<ul>\n<li><p>传输开始时必须以一个 <strong>开始</strong> 信号作为标志，结束时必须以一个 <strong>结束</strong> 信号作为标志。</p></li>\n<li><p><strong>开始信号 </strong>是以SCL为高电平时的 <strong>SDA电平的由高转低</strong> 作为标志，<strong>结束信号</strong> 是以SCL高电平时的 <strong>SDA电平的由低转高</strong> 作为标志。</p></li>\n<li><p>开始和结束标志必须由主设备控制。</p></li>\n</ul>\n<blockquote>\n<p>All transactions begin with a START (S) and are terminated by a STOP (P) (see Figure 5). A HIGH to LOW transition on the SDA line while SCL is HIGH defines a START condition. A LOW to HIGH transition on the SDA line while SCL is HIGH defines a STOP condition.</p>\n</blockquote>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210514142116674.png\" alt=\"image-20210514142116674\" style=\"zoom: 80%;\" /></p>\n<h4 id=\"开始字节\">开始字节</h4>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210515150526897.png\" alt=\"image-20210515150526897\" style=\"zoom:67%;\" /></p>\n<blockquote>\n<p>dummy acknowledge (HIGH) : 无声确认？？？</p>\n</blockquote>\n<h3 id=\"总线状态\">总线状态</h3>\n<p>总线具有两种状态，<strong>繁忙</strong>（Busy）和 <strong>空闲</strong>（Free），即 SDA电平 “开始” 后，总线进入繁忙状态， SDA电平 “结束” 后，总线进入空闲状态。</p>\n<p><strong>注意</strong>：在总线繁忙期间，发生重复的“开始”状态（而不是“结束”状态），由于“重复开始”和 “开始” 功能相同，为了方便，统称为 “开始”，除非特殊说明为 “重复开始”。</p>\n<blockquote>\n<p>The bus stays busy if a repeated START (Sr) is generated instead of a STOP condition. In this respect, the START (S) and repeated START (Sr) conditions are functionally identical. For the remainder of this document, therefore, the S symbol is used as a generic term to represent both the START and repeated START conditions, unless Sr is particularly relevant.</p>\n</blockquote>\n<h3 id=\"传输比特位\">传输比特位</h3>\n<ul>\n<li>SDA线上的字节传输必须满足8位长度。</li>\n<li>每次传输数据的字节数不受限制。</li>\n<li>每个字节数后都需要跟一个<strong>确认位（Acknowledge bit）</strong>。</li>\n<li>当从机无法完整接收或传输一个完整的数据字节时，例如正在产生内部中断等，除非其完成内部的某些功能，否则该从机将能够一直拉低SCL的电平，<strong>强制让主机一直处于等待状态</strong>。只有当从机准备好接收下一个完整的字节并释放SCL时，数据传输才会继续。</li>\n</ul>\n<blockquote>\n<p>Every byte put on the SDA line must be eight bits long. The number of bytes that can be transmitted per transfer is unrestricted. Each byte must be followed by an Acknowledge bit.</p>\n<p><strong>Data is transferred with the Most Significant Bit (MSB) first</strong> (see Figure 6). If a slave cannot receive or transmit another complete byte of data until it has performed some other function, for example servicing an internal interrupt, it can hold the clock line SCL LOW to force the master into a wait state. Data transfer then continues when the slave is ready for another byte of data and releases clock line SCL.</p>\n</blockquote>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210514144620803.png\" alt=\"image-20210514144620803\" style=\"zoom:80%;\" /></p>\n<h3 id=\"确认标志\">确认标志</h3>\n<ul>\n<li>每个字节（8比特）后都跟着一个确认位，即前8位数据，第9位确认。</li>\n<li><strong>SCL上的时钟信号由主机产生，包括确认位的的第九个时钟脉冲</strong>。</li>\n<li>SDA线并不是由主机一直占有的，每发送完一个完整字节后，主机都会释放SDA线，由从机进行数据确认。</li>\n<li>发送者在确认时钟脉冲期间释放SDA线，以便接收者可以将SDA线拉低，并且在该时钟脉冲的高电平期间保持稳定的低电平。</li>\n<li>对于设置（set-up）和保持（Hold）的时间，都应该依照表10中只针对各种不同模式的要求进行设置。</li>\n<li>如果SDA电平在第九个时钟脉冲时仍保持高电平，则被定义为 “未确认状态”。则此时主机可以发送一个“结束”标志来结束当前连接，或发送一个“开始”标志来开启一次新的传送。</li>\n</ul>\n<p><mark>即，此时（第9个脉冲时）SDA的控制权已经被mater释放了，但仍为高电平，slave可以在这第9个时钟脉冲高电平期间获得控制权，如果确认收到数据，则将电平拉低，否则不拉低。</mark></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/image-20210607141115024.png\" alt=\"image-20210607141115024\" /><figcaption aria-hidden=\"true\">image-20210607141115024</figcaption>\n</figure>\n<blockquote>\n<p>The acknowledge takes place after every byte. The acknowledge bit allows the receiver to signal the transmitter that the byte was successfully received and another byte may be sent. The master generates all clock pulses, including the acknowledge ninth clock pulse.</p>\n<p>The Acknowledge signal is defined as follows: the transmitter releases the SDA line during the acknowledge clock pulse so the <strong><em>receiver can pull the SDA line LOW</em></strong> and it remains stable LOW during the HIGH period of this clock pulse (see Figure 4). Set-up and hold times (specified in Section 6) must also be taken into account.</p>\n<p>When SDA remains HIGH during this ninth clock pulse, this is defined as the Not Acknowledge signal. The master can then generate either a STOP condition to abort the transfer, or a repeated START condition to start a new transfer.</p>\n</blockquote>\n<p><strong>以下为五种“未确认/未应答”的可能情况</strong>：There are five conditions that lead to the generation of a NACK:</p>\n<ol type=\"1\">\n<li><strong>传输地址错误</strong>：No receiver is present on the bus with the transmitted address so there is no device to respond with an acknowledge.</li>\n<li><strong>实时处理中</strong>：The receiver is unable to receive or transmit because it is performing some real-time function and is not ready to start communication with the master.</li>\n<li><strong>数据/代码未定义</strong>：During the transfer, the receiver <strong>gets data or commands that it does not understand.</strong></li>\n<li><strong>正在传输中</strong>：During the transfer, the receiver <strong>cannot receive any more data bytes</strong>.</li>\n<li><strong>未收到结束信号（收发身份未转换）</strong>：A master-receiver must signal the end of the transfer to the slave transmitter.</li>\n</ol>\n<h3 id=\"时钟同步\">时钟同步</h3>\n<p>任意几个主机都可能同时发起数据传输请求，此时只有一个主机和一个从机可以掌握总线进行通信，此时需要通过 <strong>时间同步</strong> 和 <strong>仲裁</strong> 完成对总线的调配。</p>\n<p><strong>在单机系统（Single Master System）中，不需要时钟同步和仲裁。</strong></p>\n<p>时钟同步是通过I<sup>2</sup>C接口与SCL线的有线-AND连接进行的。</p>\n<p>这意味着SCL线上的高电平到低电平的转换会导致相关的主站开始对其低电平周期进行计数（如图7的CLK<sub>2</sub>），一旦一个主站时钟 CLK<sub>1</sub> 变为低电平，它就会将SCL线电平拉低，并保持在这个状态，直到另一个时钟 CLK<sub>2</sub> 达到高电平状态。</p>\n<p>然而，如果时钟 CLK<sub>2</sub> 仍在其低电平周期内，CLK<sub>1</sub> 的低电平到高电平转换可能不会改变SCL线的状态。</p>\n<p>因为SCL线被具有最长的低电平周期的主站 CLK<sub>2</sub> 保持为低电平，而在这段时间内，低电平周期较短的主站 CLK<sub>1</sub> 进入高电平等待状态。</p>\n<blockquote>\n<p>Clock synchronization is performed using the wired-AND connection of I<sup>2</sup>C interfaces to the SCL line. This means that a HIGH to LOW transition on the SCL line causes the masters concerned to start counting off their LOW period and, once a master clock has gone LOW, it holds the SCL line in that state until the clock HIGH state is reached (see Figure 7). However, if another clock is still within its LOW period, the LOW to HIGH transition of this clock may not change the state of the SCL line. The SCL line is therefore held LOW by the master with the longest LOW period. Masters with shorter LOW periods enter a HIGH wait-state during this time.</p>\n</blockquote>\n<p>当所有相关的主控器都结束了他们的低电平周期，时钟线被释放并变成高电平。</p>\n<p>然后，在主站时钟和SCL线的状态之间没有差异，所有的主站开始计算他们的高电平周期。</p>\n<p><strong>第一个完成其高电平周期的主站再次将SCL线拉到低电平</strong>。这样，就产生了一个<strong>同步的SCL时钟</strong>，<strong>其低电平周期由具有最长时钟低电平周期的主站决定</strong>，<strong>其高电平周期由具有最短时钟高电平周期的主站决定</strong>。</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210514170202184.png\" alt=\"image-20210514170202184\" style=\"zoom: 67%;\" /></p>\n<h3 id=\"竞争仲裁\">竞争仲裁</h3>\n<p>仲裁和同步一样，是指只有在系统中使用一个以上的主站时才需要的协议的一个部分。注意，从机不参与仲裁程序。</p>\n<p>一个主站只有在总线空闲时才可以开始传输。两个主站可以在START条件的最小保持时间（tHD;STA）内产生一个START条件，从而在总线上产生一个有效的START条件。然后需要进行仲裁，以确定哪个主站将完成其传输。</p>\n<p>仲裁是逐位进行的。在每个比特期间，当SCL为高电平时，每个主站检查SDA电平是否与其所发送的内容相符，期间可能需要很多比特，只要传输的内容相同，两个主站实际上可以无误地完成整个信息传输过程。</p>\n<p><mark>当一个主站第一次试图发送一个高电平，但检测到SDA电平为低电平时，主站知道它已经失去了仲裁，并关闭其SDA输出驱动器</mark>。在其他主站被仲裁过程中，正在传输其信息的主站将继续其传输，没有信息丢失。</p>\n<p>失去仲裁的主站可以产生时钟脉冲，直到它失去仲裁的字节结束，并且必须在总线空闲时重新尝试传输。</p>\n<p><mark>如果一个主站也包含了一个从站功能，并且它在寻址阶段失去了仲裁，有可能获胜的主站正试图对它进行寻址。因此，失败的主站必须立即切换到其从站模式。</mark></p>\n<p>图8显示了两个主站的仲裁程序。可能涉及更多，这取决于有多少个主站连接到总线上。</p>\n<p><mark>当产生DATA1的主站的内部数据电平与SDA线上的实际电平有差异时，DATA1的输出被关闭。这并不影响由获胜主站发起的数据传输。</mark></p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210515142633906.png\" alt=\"image-20210515142633906\" style=\"zoom: 67%;\" /></p>\n<h3 id=\"通用寻址\">通用寻址</h3>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210515172907284.png\" alt=\"image-20210515172907284\" /><figcaption aria-hidden=\"true\">image-20210515172907284</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210515172945861.png\" alt=\"image-20210515172945861\" /><figcaption aria-hidden=\"true\">image-20210515172945861</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210515172958184.png\" alt=\"image-20210515172958184\" /><figcaption aria-hidden=\"true\">image-20210515172958184</figcaption>\n</figure>\n<h3 id=\"软复位\">软复位</h3>\n<p>在发送general call (0000 0000)后，再发送一个 0000 0110 (06h) ，这样两个具有先后顺序的字节来定义软复位。</p>\n<p>首先，这种软复位是可选 ，并不是所有设备都会对软复位指令进行响应。</p>\n<p>在收到这2个字节的序列时，所有被设计为响应一般调用地址的设备都会复位，并接收其地址的可编程部分。</p>\n<blockquote>\n<p>On receiving this 2-byte sequence, all devices designed to respond to the general call address reset and take in the programmable part of their address.</p>\n</blockquote>\n<p>必须采取预防措施，确保设备在施加电源电压后没有拉低SDA或SCL线，因为这些低电平会阻断总线。</p>\n<h3 id=\"总线复位\">总线复位</h3>\n<p>SCK信号一直卡在低电平的事件较少发生。</p>\n<ul>\n<li>如果I<sup>2</sup>C总线设备拥有硬件复位输入，则可以通过优先程序启用硬件中断复位来重置总线。</li>\n<li>如果没有硬件复位输入，则通过给设备循环供电，激活强制性的内部开机复位（POR）电路。</li>\n</ul>\n<p>SDA信号如果一直卡在低电平。</p>\n<ul>\n<li><p>则主机应该发送九次SCL时钟脉冲，此时令SDA保持低电平的设备在收到九次脉冲后应主动释放总线。</p></li>\n<li><p>如果九次脉冲没有用，则启用硬件中断复位或循环供电来清除总线。</p></li>\n</ul>\n<h3 id=\"设备id\">设备ID</h3>\n<p>可选的3字节只读设备ID编码（an optional 3-byte read-only ）：</p>\n<ul>\n<li>12位是设备制造商编号，具有独一无二性</li>\n<li>9位零件ID，由设备制造商写入</li>\n<li>3位模具/晶元版本，由设备制造商写入</li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210515152141963.png\" alt=\"image-20210515152141963\" style=\"zoom:67%;\" /></p>\n<ol type=\"1\">\n<li><p>启动条件</p></li>\n<li><p>主站发送保留设备ID的 I<sup>2</sup>C 总线地址，后面的R/W位设置为<code>0</code>（写）：<code>1111 1000</code>。</p></li>\n<li><p>主站发送从属地址。LSB是一个 \"不关心\"的值，只有一个设备必须确认这个字节（拥有I<sup>2</sup>C总线从属地址的设备）。</p></li>\n<li><p>主站发送一个 Re-START 条件。</p></li>\n</ol>\n<blockquote>\n<p>备注：在 STOP 条件之后，再加上一个 START 条件，就会重置从属状态机，无法进行设备ID读取。另外，在 STOP 条件或 Re-START 条件之后，对另一个从属设备的访问也会重置从属状态机，无法执行Device ID读取。</p>\n</blockquote>\n<ol start=\"5\" type=\"1\">\n<li><p>主站发送保留设备ID的 I<sup>2</sup>C 总线地址，后面的R/W位设置为 <code>1</code>（读）：<code>1111 1001</code>。</p></li>\n<li><p>可以进行设备ID读取，从12个制造商位开始（第一个字节+第二个字节的4个MSB），然后是9个部件识别位（第二个字节的4个LSB+第三个字节的5个MSB），然后是三个芯片修订位（第三个字节的3个LSB）。</p></li>\n<li><p>主站通过NACKing最后一个字节来结束读取序列，从而重置从属设备的状态机，允许主站发送 STOP 条件。</p>\n<blockquote>\n<p>备注：设备ID的读取可以随时通过发送NACK来停止。</p>\n</blockquote></li>\n</ol>\n<p>如果主站在第三个字节之后继续ACK，从站就会滚回第一个字节，并继续发送设备ID序列，直到检测到 NACK。</p>\n<h1 id=\"adi-codec-i2c开发\">ADI-Codec I2C开发</h1>\n<p>ADI</p>\n<h2 id=\"物理接口\">物理接口</h2>\n<p>存在由ADI官方提供的评估板（和MediaWorks的板） 和 开发第一板（量产板）之间的引脚定义差别，一开始使用的是评估板的DPI 11 和 12引脚，即 <strong>DPI_P11</strong> 为 <strong><em>SDA</em></strong>，<strong>DPI_P12</strong> 为 <strong><em>SCLK</em></strong>。后来发现作为时钟引脚的DPI无法被控制，转而使用 DPI 11 和 13。即 <strong>DPI_P11</strong> 为 <strong><em>SDA</em></strong>，<strong>DPI_P13</strong> 为 <strong><em>SCLK</em></strong>。</p>\n<p><img src=\"https://pic.islet.space/2021/05/20210527144920.png\" alt=\"image-20210524112141809\" style=\"zoom:67%;\" /></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210621154130.png\" alt=\"image-20210615083241938\" /><figcaption aria-hidden=\"true\">image-20210615083241938</figcaption>\n</figure>\n<p>MediaWorks核心板J3引脚排示意图</p>\n<p>以下描述均以评估板为例，DIY板不一定适用。</p>\n<h2 id=\"插口jumper定义\">插口（Jumper）定义</h2>\n<p><img src=\"https://pic.islet.space/2021/04/image-20210427165847934.png\" alt=\"image-20210427165847934\" style=\"zoom: 67%;\" /></p>\n<h2 id=\"时钟及pll\">时钟及PLL</h2>\n<ol type=\"1\">\n<li>1772的工作频率为12.288兆赫，而如果过要设置PLL，<strong>PLL输出一定是24.576兆赫。</strong></li>\n<li>通过 <code>MCLKIN</code> 端为codec提供核心时钟信号，可接入8至27兆赫信号。</li>\n<li>通过对 <code>0x0000</code> 到 <code>0x0005</code> 的寄存器进行写入修改PLL。</li>\n<li>PLL模式要被设置为分数或整数，则取决于MCLK的输入频率。</li>\n<li>在时钟信号达到PLL前，时钟信号会经过整数时间分频器以确保时钟频率符合要求；可以通过设置 0x0005 的bit[2:1]来设置其分频率。</li>\n<li>要使用PLL时，<strong>首先要明确PLL输出频率是多少</strong>，当PLL信号与时钟信号是整数倍关系时才需要使用整数分频器。</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210513093158863.png\" alt=\"image-20210513093158863\" /><figcaption aria-hidden=\"true\">image-20210513093158863</figcaption>\n</figure>\n<p>以下列举了整数型及分数型分频器的参数设置：</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210513093047973.png\" alt=\"image-20210513093047973\" style=\"zoom:67%;\" /></p>\n<h3 id=\"评估板电路图\">评估板电路图</h3>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210513092007130.png\" alt=\"image-20210513092007130\" style=\"zoom:67%;\" /></p>\n<h2 id=\"输入输出\">输入输出</h2>\n<h3 id=\"评估板电路图-1\">评估板电路图</h3>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210513090414605.png\" alt=\"image-20210513090414605\" style=\"zoom: 67%;\" /></p>\n<h3 id=\"第0及第1通道\">第0及第1通道</h3>\n<p>以下为codec芯片对引脚的定义，在提供一个接地端，构成TRS是完全没有问题，但是codec的定义和其评估板的外围电路设计有所区别。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210513083636462.png\" alt=\"image-20210513083636462\" /><figcaption aria-hidden=\"true\">image-20210513083636462</figcaption>\n</figure>\n<p>正常3.5mm音频接口为TRS接口，其中T虽然为VCC（通常是），R作为音频信号输入，而S为接地端，且T和R可共同作为左右声道分别进行输入。（也有T和S定义相反的设计）</p>\n<p>但是按上述电路进行接线时，相当于TS接口（单声道）接线模式，却又不完全相同：</p>\n<ul>\n<li>使用 MICBIAS<sub>x</sub> 对14接口进行供电，此时Tip端是VCC。</li>\n<li>Ring端接13接口，充当Sleeve端（而实际上的Sleeve端因已经接地，可以不进行连接）。</li>\n<li>由Ring(AIN1REF)和Tip(AIN1)共同构成了TS单声道接线模式。</li>\n</ul>\n<h3 id=\"第2及第3通道\">第2及第3通道</h3>\n<ul>\n<li>2/3输入通道是复用立体声通道，即1通道和0通道都可以单独接入音源，在物理音频接口上独立，但第2/3通道是在一起的，共用一个物理通道。UG第7页中也有提到。</li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/04/image-20210427104818097.png\" alt=\"image-20210427104818097\" style=\"zoom:50%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/04/image-20210427105655639.png\" alt=\"image-20210427105655639\" style=\"zoom:67%;\" /></p>\n<ul>\n<li>有四个单端输入通道可以设置为麦克风信号或线路信号，一个双立体声数字输入信号通道和也可被用于单端输出的两个差分(differential)输出。</li>\n</ul>\n<h2 id=\"i2c通信\">I2C通信</h2>\n<h3 id=\"时序\">时序</h3>\n<p>图85展示了 <strong>单字主写模式</strong> 的时序。每9个时钟脉冲，1772都会拉低一次SDA的电平以表示确认收到。</p>\n<p>图86展示了 多字主写模式 的时序。此图展示了2个字节大小数据（例如程序）的写入过程。<mark>1772会在每两个字节后增加一次子地址寄存器，因为被使用的子地址对应着 2字节 长度的寄存器或内存区域</mark>。</p>\n<p>图87展示了 单字主写模式后转变为 单字主读模式 的时序。1772作为从机接受数据后发送确认标志，主机立即发起重复开始的 单字主读模式，由从机发送至主机。</p>\n<p>图88展示了 多字主读模式 的时序，展示了读取目标字节为2bytes的示例。<em><u>此处上述黄底字重复</u></em>。其他地址范围可能有不同的字长，从一个到四个字节不等。ADAU1772总是对子地址进行解码，并设置自动递增电路，使地址在适当的字节数后递增。</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210518105918652.png\" alt=\"image-20210518105918652\" style=\"zoom: 67%;\" /></p>\n<blockquote>\n<p>S = 开始 标志</p>\n<p>P = 停止 标志</p>\n<p>AM = 主机确认标志</p>\n<p>AS = 从机确认标志</p>\n</blockquote>\n<h3 id=\"接口\">接口</h3>\n<h4 id=\"usbi接口\">USBi接口</h4>\n<p>​ 《SigmaStudio_USBi_to_EZ-Board_Adapter_Schematic-Rel_0.1.pdf》中对接口的定义，总共需要4个引脚，分别是1、3、4、10，对应着 SCL / SDA / VCC / GND；</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210518112823329.png\" alt=\"image-20210518112823329\" style=\"zoom:67%;\" /></p>\n<h4 id=\"接口-1\">1772接口</h4>\n<p>需要用到的接口是 <code>SCL/SCLK</code> 和 <code>SDA/MISO</code> 。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210601105623.png\" alt=\"image-20210518192233133\" /><figcaption aria-hidden=\"true\">image-20210518192233133</figcaption>\n</figure>\n<p>ADDR0 和 ADDR1 分别对应的是控制接口（CONTROL PORT）上的 <strong><em>CLATCH</em></strong> 和 <strong><em>CDATA</em></strong> 针脚。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210607150001.png\" alt=\"image-20210607145600052\" /><figcaption aria-hidden=\"true\">image-20210607145600052</figcaption>\n</figure>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210518112823329.png\" alt=\"image-20210518112823329\" style=\"zoom:67%;\" /></p>\n<table>\n<colgroup>\n<col style=\"width: 6%\" />\n<col style=\"width: 6%\" />\n<col style=\"width: 6%\" />\n<col style=\"width: 6%\" />\n<col style=\"width: 6%\" />\n<col style=\"width: 28%\" />\n<col style=\"width: 29%\" />\n<col style=\"width: 9%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>BIT_6</th>\n<th>BIT_5</th>\n<th>BIT_4</th>\n<th>BIT_3</th>\n<th>BIT_2</th>\n<th>BIT_1 / ADDR1 / CDATA</th>\n<th>BIT_0 / ADDR0 / CLATCH</th>\n<th>ADDRESS</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>0x3C</td>\n</tr>\n<tr class=\"even\">\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>0x3D</td>\n</tr>\n<tr class=\"odd\">\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>0x3E</td>\n</tr>\n<tr class=\"even\">\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0x3F</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"接口-2\">21479接口</h4>\n<p>《ADSP-21479 EZ-Board Evaluation System Manual》，需要用到的接口是 <code>SPI_CLK(DPI_P3)</code> 和 <code>SPI_MISO(DPI_P2)</code> 。</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210518113240492.png\" alt=\"image-20210518113240492\" style=\"zoom:67%;\" /></p>\n<p>对应评估板上的针脚接口如下图示 24（DPI_P3） 和 27（DPI_P2） 接口。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210519114409.png\" alt=\"image-20210519114333234\" /><figcaption aria-hidden=\"true\">image-20210519114333234</figcaption>\n</figure>\n<h3 id=\"设备地址\">设备地址</h3>\n<p>主机每次发送8位数据，其中最低的一位由主机发送标识读/写位。逻辑电平1是读，逻辑电平0是写。</p>\n<p>通过I2C方式进行连接的从机，其设备地址是7位数（1-7，对应表21是<code>bit0-bit6</code>），表21提供了1772的设备地址，<strong>ADDR1</strong> 和 <strong>ADDR0</strong> 位置可以通过接入pin的方式自由设置，即输入引脚的电平不同，每个1772都能够拥有4个独特的地址。此类方式允许多块1772接入同一I2C总线。</p>\n<ul>\n<li>即，默认情况下从机地址为 <code>0x3C</code> ，可以设置成其他：<code>0x3D</code> , <code>0x3E</code>, <code>0x3F</code>。</li>\n<li>每个SDA和SCL线都应该接入一个2.0KΩ的升压电阻，但不应该高过IOVDD。</li>\n</ul>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210601105537.png\" alt=\"image-20210519093557617\" /><figcaption aria-hidden=\"true\">image-20210519093557617</figcaption>\n</figure>\n<p><img src=\"https://pic.islet.space/2021/06/20210601105628.png\" alt=\"image-20210519094454381\" style=\"zoom: 67%;\" /></p>\n<h2 id=\"相关问答\">相关问答</h2>\n<p><strong>Q</strong>: what is the macro SIGMA_WRITE_DELAY supposed to do? Is it a simple delay? Why are there parameters regarding the device I2C address, data and length? <strong>A</strong>: This macro is used for applications that need to pause the data writes for a specific purpose. For example, if you <strong><em>need time for the PLL to be set before starting to write to the rest of the registers</em></strong>. It could be used as a simple delay, you’ll need to specify the device address always because some applications can require more than one DSP; the length is just the address byte length (could be 1 or 2 byte length) and data is the value in hex that represents the total time in milliseconds (that is up to the micro controller clock speed). The reason length is used, is that some DSPs work with one and some other require two address bytes.</p>\n<p><code>&lt;SigmaStudioFW.h&gt;</code> contains a lot of macros to be defined. What I found by examinating all the code is that what macros need to be defined depend on what you want to perform with your microcontroller.</p>\n<p>If you only need to load a DSP program with a call to default_download(), well, you only need (at least for the ADAU1761)</p>\n<p>to implement the two macros:</p>\n<ul>\n<li><p>SIGMA_WRITE_REGISTER_BLOCK</p></li>\n<li><p>SIGMA_WRITE_DELAY</p></li>\n</ul>\n<p>The first one is the basis of all the loading of data into <strong><em>program ram</em></strong>, <strong><em>parameter ram</em></strong>, and <strong><em>registers</em></strong>. The second one is only a delay (to be exact it serves to wait for the PLL to lock, in any case <strong><em>most of the times it can be implemented as a simple delay</em></strong>).</p>\n<p>If you want to use sequences, that is to implement some control of the DSP running with your microcontroller, you will probably need to implement the other macros. In particular if you will control volume sliders you will need to implement the conversion macros for integer or float to the internal 5.23 representation. You can search elsewhere on the forum, I saw some of this code.</p>\n<h1 id=\"开发代码\">开发代码</h1>\n<p>ADI和Codec之间的I2C通信可以通过两种方式进行，第一种是操作21478上面的TWI寄存器，需要查看《HWR》以获取更多信息。第二种是学会控制引脚高低电平，通过高低电平模拟寄存器操控来读取和写入I2C设备。</p>\n<p>在开发过程中，先使用的第一种方式对TWI寄存器进行操控，但发现21479中有某个寄存器无法写入，故放弃。下面提供第二种方式中需要用到的三个文件，分别是 <code>TWI.h</code> 、 <code>TWI.c</code> 、<code>SigmaStudioFW.h</code> 。经调试，以下代码可以正常收发数据，实现对从设备的读/写。</p>\n<h2 id=\"twi.c\">TWI.c</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * TWI.C</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  Created on: 2021年6月16日</span></span><br><span class=\"line\"><span class=\"comment\"> *      Author: 431240</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;TWI.H&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> HWDELAY &#123;HWDelay(MINDT);&#125;  <span class=\"comment\">//延时函数</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MTWACK &#123;TWIMWaitAck();&#125;       <span class=\"comment\">//Master Transmitter Wait Ack</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ------------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// 全局变量声明</span></span><br><span class=\"line\">DADDR tempDevAddr = <span class=\"number\">0x00</span>;  <span class=\"comment\">//临时设备地址存储比对变量，及其初始化</span></span><br><span class=\"line\">RADDR tempRegAddr = <span class=\"number\">0x00</span>;  <span class=\"comment\">//临时寄存器地址存储对比变量，及其初始化</span></span><br><span class=\"line\">TWIDATA bit = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> TWIDATA dataRead = <span class=\"number\">0</span>;  <span class=\"comment\">//用于观察数据写入后再读取的状态</span></span><br><span class=\"line\"><span class=\"comment\">//static TWIDATA addrAckRead = 0;  //调试观察用</span></span><br><span class=\"line\"><span class=\"comment\">//static TWIDATA regAckRead = 0;  //调试观察用</span></span><br><span class=\"line\"><span class=\"comment\">//static TWIDATA dataAckRead = 0;  //调试观察用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> DADDR targetAddr = <span class=\"number\">0x00</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ------------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// 函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">TWITimerIsr</span><span class=\"params\">(<span class=\"keyword\">int</span> delayTime)</span></span>&#123;  <span class=\"comment\">//用于产生中断高/低电平延时的定时器中断（句柄）</span></span><br><span class=\"line\"> <span class=\"comment\">//需要自定义，涉及到定时器调用相关函数，请自行查阅手册</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">HWDelay</span><span class=\"params\">(<span class=\"keyword\">float</span> hwDelayTime)</span></span>&#123;  <span class=\"comment\">// 定义硬件延时（单位微秒）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> HWDELAY_CORETIMER</span></span><br><span class=\"line\">\ttimer_set(<span class=\"number\">6400</span>*hwDelayTime, <span class=\"number\">6400</span>*hwDelayTime);</span><br><span class=\"line\">\ttimer_on();</span><br><span class=\"line\">\ttimer_off();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> HWDELAY_SYSWAITNOP</span></span><br><span class=\"line\">\tSysWaitNOP(HW_SYSWAITNOP_TIME);  <span class=\"comment\">//此处使用循环函数进行延时</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">TWIInit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;  <span class=\"comment\">//初始化函数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> EVA_21479</span></span><br><span class=\"line\">\tSRU(FLAG13_O,DPI_PB13_I);</span><br><span class=\"line\">\tSRU(FLAG11_O,DPI_PB11_I);</span><br><span class=\"line\"></span><br><span class=\"line\">\tSRU(HIGH,DPI_PBEN13_I);</span><br><span class=\"line\">\tSRU(HIGH,DPI_PBEN11_I);</span><br><span class=\"line\"></span><br><span class=\"line\">\tsysreg_bit_set( sysreg_FLAGS, (FLG11O|FLG13O) );</span><br><span class=\"line\">\tsysreg_bit_clr( sysreg_FLAGS, (FLG11|FLG13) );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\tSRU(FLAG8_O,DPI_PB08_I);</span><br><span class=\"line\">\tSRU(FLAG7_O,DPI_PB07_I);</span><br><span class=\"line\"></span><br><span class=\"line\">\tSRU(HIGH,DPI_PBEN08_I);</span><br><span class=\"line\">\tSRU(HIGH,DPI_PBEN07_I);</span><br><span class=\"line\"></span><br><span class=\"line\">\tsysreg_bit_set( sysreg_FLAGS, (FLG7O|FLG8O) );</span><br><span class=\"line\">\tsysreg_bit_clr( sysreg_FLAGS, (FLG7|FLG8) );</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\tSDA_OUT;</span><br><span class=\"line\">\tSCL_OUT;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> <span class=\"title\">TWIStart</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;  <span class=\"comment\">//启动函数</span></span><br><span class=\"line\">\tSDA_OUT;  <span class=\"comment\">//设置为数据输出方向</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tS_SDA;</span><br><span class=\"line\">\tS_SCL;</span><br><span class=\"line\">\tHWDELAY;</span><br><span class=\"line\"></span><br><span class=\"line\">\tC_SDA;</span><br><span class=\"line\">\tHWDELAY;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">TWIReStart</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;  <span class=\"comment\">//重启动函数</span></span><br><span class=\"line\">\tSDA_OUT;</span><br><span class=\"line\"></span><br><span class=\"line\">\tC_SCL;</span><br><span class=\"line\">\tHWDELAY;</span><br><span class=\"line\"></span><br><span class=\"line\">\tS_SDA;</span><br><span class=\"line\">\tS_SCL;</span><br><span class=\"line\">\tHWDELAY;</span><br><span class=\"line\"></span><br><span class=\"line\">\tC_SDA;</span><br><span class=\"line\">\tHWDELAY;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">TWIStop</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;  <span class=\"comment\">//停止</span></span><br><span class=\"line\">\tSDA_OUT;</span><br><span class=\"line\"></span><br><span class=\"line\">\tC_SCL;  <span class=\"comment\">//modified by liewzheng</span></span><br><span class=\"line\">\tC_SDA;  <span class=\"comment\">//在时钟信号拉高之前先拉低数据信号</span></span><br><span class=\"line\">\tHWDELAY;  <span class=\"comment\">//modified by liewzheng</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tS_SCL;</span><br><span class=\"line\">\tHWDELAY;</span><br><span class=\"line\"></span><br><span class=\"line\">\tS_SDA;  <span class=\"comment\">//在时钟信号高电平时拉高数据信号</span></span><br><span class=\"line\">\tHWDELAY;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">SendWithoutAck</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;  <span class=\"comment\">//发送无需确认</span></span><br><span class=\"line\">\tSDA_OUT;</span><br><span class=\"line\"></span><br><span class=\"line\">\tC_SDA;</span><br><span class=\"line\">\tHWDELAY;</span><br><span class=\"line\"></span><br><span class=\"line\">\tS_SCL;</span><br><span class=\"line\">\tHWDELAY;</span><br><span class=\"line\"></span><br><span class=\"line\">\tC_SCL;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSDA_IN;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> TWIDATA <span class=\"title\">TWIMWaitAck</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;  <span class=\"comment\">//等待从机确认并读取确认信号</span></span><br><span class=\"line\">\tC_SCL;</span><br><span class=\"line\">\tSDA_IN;</span><br><span class=\"line\">\tHWDELAY;</span><br><span class=\"line\"></span><br><span class=\"line\">\tS_SCL;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!READ_SDA)&#123;</span><br><span class=\"line\">\t\tHWDELAY;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\tHWDELAY;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">TWISendByte</span><span class=\"params\">(TWIDATA SentByte)</span></span>&#123;  <span class=\"comment\">//发送一个字节</span></span><br><span class=\"line\">\tTWIDATA bit_count = <span class=\"number\">8</span>;</span><br><span class=\"line\">\tSDA_OUT;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(bit_count--)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(SentByte &amp; <span class=\"number\">0x80</span>)&#123;</span><br><span class=\"line\">\t\t\tC_SCL;  <span class=\"comment\">//先拉低SCL</span></span><br><span class=\"line\">\t\t\tS_SDA;  <span class=\"comment\">//1则置高</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tC_SCL;  <span class=\"comment\">//先拉低SCL</span></span><br><span class=\"line\">\t\t\tC_SDA;  <span class=\"comment\">//0则置低</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tSentByte &lt;&lt;= <span class=\"number\">1</span>;  <span class=\"comment\">//前移一位</span></span><br><span class=\"line\">\t\tHWDELAY;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tS_SCL;</span><br><span class=\"line\">\t\tHWDELAY;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">TWIWriteByte</span><span class=\"params\">(DADDR DevAddr, RADDR RegAddr, TWIDATA *Data)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(TWIStart() != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tTWISendByte(DevAddr);</span><br><span class=\"line\">\t\t\tMTWACK;</span><br><span class=\"line\"><span class=\"comment\">//\t\t\taddrAckRead = TWIMWaitAck();  //测试时使用</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tTWISendByte(RegAddr&gt;&gt;<span class=\"number\">8</span>);  <span class=\"comment\">//采用16bit寻址空间，先发送高8位地址，在发送低8位地址</span></span><br><span class=\"line\">\t\t\tMTWACK;</span><br><span class=\"line\"><span class=\"comment\">//\t\t\tregAckRead = TWIMWaitAck();</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tTWISendByte(RegAddr);</span><br><span class=\"line\">\t\t\tMTWACK;</span><br><span class=\"line\"><span class=\"comment\">//\t\t\tregAckRead = TWIMWaitAck();</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tTWISendByte(*(Data+<span class=\"number\">0</span>));</span><br><span class=\"line\">\t\t\tMTWACK;</span><br><span class=\"line\"><span class=\"comment\">//\t\t\tdataAckRead = TWIMWaitAck();</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tTWIStop();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">TWIWriteByteContinuly</span><span class=\"params\">(DADDR DevAddr, RADDR RegAddr, <span class=\"keyword\">int</span> length, TWIDATA *Data)</span></span>&#123;  <span class=\"comment\">//连续发送数据，相同设备无暂停</span></span><br><span class=\"line\">\t\tTWIStart();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tTWISendByte(DevAddr);</span><br><span class=\"line\">\t\tMTWACK;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tTWISendByte(RegAddr&gt;&gt;<span class=\"number\">8</span>);  <span class=\"comment\">//采用16bit寻址空间，先发送高8位地址，在发送低8位地址</span></span><br><span class=\"line\">\t\tMTWACK;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tTWISendByte(RegAddr);</span><br><span class=\"line\">\t\tMTWACK;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt;length; i++)&#123;</span><br><span class=\"line\">\t\t\tTWISendByte(*(Data+i));</span><br><span class=\"line\">\t\t\tMTWACK;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tTWIStop();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> DADDR <span class=\"title\">TWIDAddrTest</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;  <span class=\"comment\">// 设备地址测试验证</span></span><br><span class=\"line\">\tDADDR MAXADDR = <span class=\"number\">0x7F</span>;  <span class=\"comment\">//设置最大地址为0x7F，此处仅测试7bit设备地址，10bit不测试</span></span><br><span class=\"line\">\tDADDR tempAddress = <span class=\"number\">0x00</span>;  <span class=\"comment\">//设置设备最小值</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(; tempAddress &lt;= MAXADDR; tempAddress++)  <span class=\"comment\">//设置for循环</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tTWISendByte((TWIDATA) tempAddress);<span class=\"comment\">//发送设备地址</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(TWIMWaitAck()) <span class=\"keyword\">return</span> tempAddress;  <span class=\"comment\">//等待应答，如果应答，则返回正确的设备地址</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0xFF</span>;  <span class=\"comment\">//否则（运行结束时）返回0xFF。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">TWISCL</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;  <span class=\"comment\">//Only used in Test mode</span></span><br><span class=\"line\">\tC_SCL;</span><br><span class=\"line\">\tS_SDA;</span><br><span class=\"line\">\tHWDELAY;</span><br><span class=\"line\">\tS_SCL;</span><br><span class=\"line\">\tC_SDA;</span><br><span class=\"line\">\tHWDELAY;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ------------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// 以下函数未使用。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">MRSendAck</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;  <span class=\"comment\">//Only in Master-receiver mode, 发送确认信号给slave，仅在主-收模式时使用</span></span><br><span class=\"line\">\tSDA_OUT;</span><br><span class=\"line\"></span><br><span class=\"line\">\tC_SDA;</span><br><span class=\"line\">\tHWDELAY;</span><br><span class=\"line\"></span><br><span class=\"line\">\tS_SCL;</span><br><span class=\"line\">\tHWDELAY;</span><br><span class=\"line\"></span><br><span class=\"line\">\tC_SCL;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSDA_IN;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> TWIDATA <span class=\"title\">TWI_read_byte</span><span class=\"params\">(DADDR DevAddr, RADDR RegAddr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> TWIDATA RetVal = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tTWIStart();</span><br><span class=\"line\"></span><br><span class=\"line\">\tTWISendByte( DevAddr );  <span class=\"comment\">//发送设备地址和W标志位，等待确认，据Figure87</span></span><br><span class=\"line\">\tMTWACK;</span><br><span class=\"line\"></span><br><span class=\"line\">\tTWISendByte(RegAddr&gt;&gt;<span class=\"number\">8</span>);  <span class=\"comment\">//发送MSB寄存器地址</span></span><br><span class=\"line\">\tMTWACK;</span><br><span class=\"line\">\tTWISendByte(RegAddr);  <span class=\"comment\">//放LSB寄存器地址</span></span><br><span class=\"line\">\tMTWACK;</span><br><span class=\"line\"></span><br><span class=\"line\">\tTWIReStart();  <span class=\"comment\">//重启动并发送设备地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tTWISendByte( DevAddr+<span class=\"number\">1</span> );  <span class=\"comment\">//发送设备地址和R标志位，等待确认</span></span><br><span class=\"line\">\tMTWACK;</span><br><span class=\"line\"></span><br><span class=\"line\">\tRetVal = TWIReceiveByte();</span><br><span class=\"line\">\tSendWithoutAck();</span><br><span class=\"line\"></span><br><span class=\"line\">\tTWIStop();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> RetVal;  <span class=\"comment\">//返回目标寄存器的值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">TWI_write_2_byte</span><span class=\"params\">(DADDR DevAddr, RADDR RegAddr, TWIDATA Data1, TWIDATA Data2)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (TWIStart() != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\tTWISendByte(DevAddr); <span class=\"comment\">//1、发送设备地址</span></span><br><span class=\"line\">\t\tMTWACK;</span><br><span class=\"line\">\t\tTWISendByte(RegAddr); <span class=\"comment\">//2、发送寄存器地址</span></span><br><span class=\"line\">\t\tMTWACK;</span><br><span class=\"line\">\t\tTWISendByte(Data1); <span class=\"comment\">//3、发送寄存器数据 for PORT 0</span></span><br><span class=\"line\">\t\tMTWACK;</span><br><span class=\"line\">\t\tTWISendByte(Data2); <span class=\"comment\">//4、发送下一个寄存器数据 for PORT 1</span></span><br><span class=\"line\">\t\tMTWACK</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tTWIStop();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> TWIDATA <span class=\"title\">TWIReceiveByte</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;  <span class=\"comment\">//作为主机，读取从机字节</span></span><br><span class=\"line\">\tTWIDATA Byte_count = <span class=\"number\">8</span>;</span><br><span class=\"line\">\tTWIDATA RetVal = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tC_SCL;</span><br><span class=\"line\">\tHWDELAY;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSDA_IN;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (Byte_count--)&#123;</span><br><span class=\"line\">\t\tS_SCL;</span><br><span class=\"line\">\t\tRetVal &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (READ_SDA)&#123;</span><br><span class=\"line\">\t\t\tRetVal = RetVal | <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tHWDELAY;</span><br><span class=\"line\">\t\tC_SCL;</span><br><span class=\"line\">\t\tHWDELAY;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> RetVal;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> DADDR <span class=\"title\">TWIDevAddrTest</span><span class=\"params\">(<span class=\"keyword\">char</span> addressBit)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span>(addressBit)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> (<span class=\"number\">7</span>):</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(targetAddr = <span class=\"number\">0x00</span> ; targetAddr &lt; <span class=\"number\">0x7F</span>; targetAddr++)&#123;</span><br><span class=\"line\">\t\t\t\tTWIStart();</span><br><span class=\"line\">\t\t\t\tTWISendByte(targetAddr&lt;&lt;<span class=\"number\">1</span>);  <span class=\"comment\">//尝试过target和target&lt;&lt;1都不行</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(!TWIMWaitAck() ) &#123;</span><br><span class=\"line\">\t\t\t\t\tTWIStop();</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> targetAddr;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> TWIStop();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> (<span class=\"number\">10</span>):  <span class=\"comment\">//此处需要自定义</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (<span class=\"number\">0x00</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"number\">0x00</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"twi.h\">TWI.h</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * TWI.H</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  Created on: 2021年6月16日</span></span><br><span class=\"line\"><span class=\"comment\"> *      Author: 431240</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sru21479.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;def21479.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cdef21479.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;signal.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;21479.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//#include &quot;Common.h&quot;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;ADDS_21479_EzKit.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 调试用宏定义</span></span><br><span class=\"line\"><span class=\"comment\"> -----------------------------------------------------------------------------------*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NACK 0   <span class=\"comment\">//不用从机确认</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ACK 1  <span class=\"comment\">//需要从机进行确认</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//#define HWDELAY_CORETIMER</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> HWDELAY_SYSWAITNOP</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//#define EVA_21479 1  //如果是评估板</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 数据类型定义</span></span><br><span class=\"line\"><span class=\"comment\"> -----------------------------------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> DADDR;  <span class=\"comment\">//设备地址数据类型定义</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> RADDR;  <span class=\"comment\">//寄存器地址数据类型定义</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> TWIDATA;  <span class=\"comment\">//数据发送的数据类型定义</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ------------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">//  引脚定义：RST 定义为 DPI_12  ，  SDA 定义为 DPI_11  ，  SCL 定义为 DPI_13</span></span><br><span class=\"line\"><span class=\"comment\">// 在试制板中，两块codec均与21479的第7、8引脚连接，DPI_07定义为SDA, DPI_08定义为SCL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RST_OUT &#123;SRU(HIGH, DPI_PBEN12_I); &#125;   <span class=\"comment\">//设置复位信号输出方向</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S_RST  &#123;SRU(LOW, DPI_PB12_I); &#125;   <span class=\"comment\">//拉低电平以设置复位信号</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> C_RST  &#123;SRU(HIGH, DPI_PB12_I);&#125;   <span class=\"comment\">//拉高电平以释放复位信号</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> EVA_21479</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SDA_OUT &#123;SRU(HIGH, DPI_PBEN11_I); &#125;   <span class=\"comment\">//设置SDA输出方向</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SDA_IN  &#123;SRU(LOW, DPI_PBEN11_I); &#125;   <span class=\"comment\">//设置SDA输入方向</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> C_SDA  &#123;SRU(LOW, DPI_PB11_I); &#125;   <span class=\"comment\">//拉低SDA以清除数据</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S_SDA  &#123;SRU(HIGH, DPI_PB11_I); &#125;   <span class=\"comment\">//拉高SDA</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SCL_OUT  &#123; SRU(HIGH, DPI_PBEN13_I); &#125;   <span class=\"comment\">//SCL设定为输出方向的定义</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> C_SCL &#123;SRU(LOW, DPI_PB13_I); &#125;   <span class=\"comment\">//拉低SCL以清除时钟</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S_SCL &#123;SRU(HIGH, DPI_PB13_I); &#125;   <span class=\"comment\">//拉高SCL以设置时钟</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> READ_SDA (*pDPI_PIN_STAT &amp; DPI_PB11)   <span class=\"comment\">//从SDA读取数据</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> READ_SCL  (*pDPI_PIN_STAT &amp; DPI_PB13)  <span class=\"comment\">//从SCL读取数据</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>  <span class=\"comment\">//量产版</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SDA_OUT &#123;SRU(HIGH, DPI_PBEN07_I); &#125;   <span class=\"comment\">//设置SDA输出方向</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SDA_IN  &#123;SRU(LOW, DPI_PBEN07_I); &#125;   <span class=\"comment\">//设置SDA输入方向</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> C_SDA  &#123;SRU(LOW, DPI_PB07_I); &#125;   <span class=\"comment\">//拉低SDA以清除数据</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S_SDA  &#123;SRU(HIGH, DPI_PB07_I); &#125;   <span class=\"comment\">//拉高SDA</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SCL_OUT  &#123; SRU(HIGH, DPI_PBEN08_I); &#125;   <span class=\"comment\">//SCL设定为输出方向的定义</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> C_SCL &#123;SRU(LOW, DPI_PB08_I); &#125;   <span class=\"comment\">//拉低SCL以清除时钟</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S_SCL &#123;SRU(HIGH, DPI_PB08_I); &#125;   <span class=\"comment\">//拉高SCL以设置时钟</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> READ_SDA (*pDPI_PIN_STAT &amp; DPI_PB07)   <span class=\"comment\">//从SDA读取数据</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> READ_SCL  (*pDPI_PIN_STAT &amp; DPI_PB08)  <span class=\"comment\">//从SCL读取数据</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//提示：靠近功放的codec，其ADDR1为1电平，ADDR0为高电平，其I2C地址是0x3E</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 数据宏定义</span></span><br><span class=\"line\"><span class=\"comment\"> -----------------------------------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MINDT 1   <span class=\"comment\">//定义延迟最小时间 Minimal delay time</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> HWDELAY_SYSWAITNOP</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> HW_SYSWAITNOP_TIME 100  <span class=\"comment\">//定义使用SYSWAITNOP的延迟时间，默认90</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 函数声明</span></span><br><span class=\"line\"><span class=\"comment\"> -----------------------------------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">TWITimerIsr</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;  <span class=\"comment\">//用于产生中断高/低电平延时的定时器中断（句柄）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">HWDelay</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span></span>;  <span class=\"comment\">// 定义硬件延时（单位微秒）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">TWIInit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;  <span class=\"comment\">//初始化函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> <span class=\"title\">TWIStart</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;  <span class=\"comment\">//启动函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">TWIReStart</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;  <span class=\"comment\">//重启动函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">TWIStop</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;  <span class=\"comment\">//停止</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">SendWithoutAck</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;  <span class=\"comment\">//发送无需确认</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> TWIDATA <span class=\"title\">TWIMWaitAck</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;  <span class=\"comment\">//等待从机确认并读取确认信号</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">TWISendByte</span><span class=\"params\">(TWIDATA)</span></span>;  <span class=\"comment\">//发送一个字节</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">TWIWriteByte</span><span class=\"params\">(DADDR, RADDR, TWIDATA*)</span></span>;  <span class=\"comment\">//单次发送数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">TWIWriteByteContinuly</span><span class=\"params\">(DADDR, RADDR , <span class=\"keyword\">int</span>, TWIDATA *)</span></span>;  <span class=\"comment\">//连续发送数据，相同设备无暂停</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> DADDR <span class=\"title\">TWIDAddrTest</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;  <span class=\"comment\">// 设备地址测试验证</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">TWISCL</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;  <span class=\"comment\">//Only used in Test mode</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下函数未使用。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">MRSendAck</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;  <span class=\"comment\">//Only in Master-receiver mode, 发送确认信号给slave，仅在主-收模式时使用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> TWIDATA <span class=\"title\">TWI_read_byte</span><span class=\"params\">(DADDR, RADDR)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">TWI_write_2_byte</span><span class=\"params\">(DADDR, RADDR, TWIDATA, TWIDATA)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> TWIDATA <span class=\"title\">TWIReceiveByte</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;  <span class=\"comment\">//作为主机，读取从机字节</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> DADDR <span class=\"title\">TWIDevAddrTest</span><span class=\"params\">(<span class=\"keyword\">char</span> addressBit)</span></span>;  <span class=\"comment\">// 从机地址遍历测试</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"sigmastudiofw.h\">SigmaStudioFW.h</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Modified by Liewzheng in June 9th, 2021</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __SIGMASTUDIOFW_H__</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __SIGMASTUDIOFW_H__</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 头文件</span></span><br><span class=\"line\"><span class=\"comment\"> -----------------------------------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;TWI.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;ADDS_21479_EzKit.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 数据类型定义</span></span><br><span class=\"line\"><span class=\"comment\"> -----------------------------------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> ADI_DATA_U16;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>  ADI_REG_TYPE;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 宏定义</span></span><br><span class=\"line\"><span class=\"comment\"> -----------------------------------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIGMASTUDIOTYPE_FIXPOINT \t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIGMASTUDIOTYPE_INTEGER \t1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置时钟分频，有且仅有一个能被启用</span></span><br><span class=\"line\"><span class=\"comment\">//#define CLK_DIV_1</span></span><br><span class=\"line\"><span class=\"comment\">//#define CLK_DIV_2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CLK_DIV_3</span></span><br><span class=\"line\"><span class=\"comment\">//#define CLK_DIV_4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> testPLL[<span class=\"number\">5</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 宏定义——函数声明</span></span><br><span class=\"line\"><span class=\"comment\"> -----------------------------------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIGMA_WRITE_REGISTER( devAddress, address, dataLength, data ) &#123;<span class=\"comment\">/*<span class=\"doctag\">TODO:</span> implement macro or define as function*/</span>&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIGMA_READ_REGISTER( devAddress, address, length, pData ) &#123;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIGMA_SET_REGSITER_FIELD( regVal, fieldVal, fieldMask, fieldShift )  \\</span></span><br><span class=\"line\">\t\t&#123; (regVal) = (((regVal) &amp; (~(fieldMask))) | (((fieldVal) &lt;&lt; (fieldShift)) &amp;&amp; (fieldMask))) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIGMA_GET_REGSITER_FIELD( regVal, fieldMask, fieldShift )  \\</span></span><br><span class=\"line\">\t\t&#123; ((regVal) &amp; (fieldMask)) &gt;&gt; (fieldShift) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIGMASTUDIOTYPE_FIXPOINT_CONVERT( _value ) &#123;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIGMASTUDIOTYPE_INTEGER_CONVERT( _value ) &#123;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 函数定义</span></span><br><span class=\"line\"><span class=\"comment\"> -----------------------------------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"comment\">// modified by liewzheng, in June 15th, 2021</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> SIGMA_WRITE_REGISTER_BLOCK(  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> devAddress,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> address,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> length,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tADI_REG_TYPE *pData ) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(length == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tTWIWriteByte(devAddress, address, pData);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(length &gt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\tTWIWriteByteContinuly(devAddress, (address), length, pData);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSysWaitNOP(<span class=\"number\">100</span>);   <span class=\"comment\">//可以注释掉</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// modified by liewzheng, in June 15th, 2021</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SIGMA_WRITE_DELAY</span><span class=\"params\">(  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> devAddress,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> length,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *pData )</span> </span>&#123;</span><br><span class=\"line\">\tSysWaitNOP(<span class=\"number\">10000000</span>);</span><br><span class=\"line\">\tSysWaitNOP(<span class=\"number\">10000000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li><a href=\"https://www.nxp.com/docs/en/user-guide/UM10204.pdf\">《NXP_UM10204_I2C-bus specification and user manual》</a></li>\n</ol>\n","categories":["Communication"],"tags":["I2C"]},{"title":"I2S通信","url":"/2021/06/28/Communication/2021-06-28-I2S%E9%80%9A%E4%BF%A1/","content":"<p>数字音频信号的传输标准，如：</p>\n<ul>\n<li><strong><em>I2S</em></strong>、<strong><em>PCM</em></strong> (Pulse Code Modulation) 和 <strong><em>PDM</em></strong> (Pulse Density Modulation)主要用于同一块电路板上芯片之间音频信号的传输；</li>\n<li><strong><em>Intel HDA</em></strong> (Intel High Definition Audio) 用于PC的Audio子系统（声卡）应用；</li>\n<li><strong><em>S/PDIF</em></strong> 和 <strong><em>Ethernet AVB</em></strong> 主要应用于板间长距离及需要电缆连接的场合。</li>\n</ul>\n<h1 id=\"philips-i2s-标准\">Philips I2S 标准</h1>\n<p>I2S的标准文件源自 <strong>飞利浦半导体</strong>（Philips Semiconductors）发表于1986年的《<strong>I2S bus specification</strong>（1996年修订版）》。</p>\n<blockquote>\n<p>I2S（Inter-IC Sound）采用了独立的导线传输时钟与数据信号的设计，通过将数据和时钟信号分离，避免了因时差诱发的失真，为用户节省了购买抵抗音频抖动的专业设备的费用。</p>\n</blockquote>\n<p><strong>需要注意</strong>：I2S是一种音频编码协议，同时也是一种音频接口，因此采用I2S接口方式的不一定采用I2S编码，还可以采用 <strong>左对齐</strong>（Left Justifying）编码 或 <strong>右对齐</strong>（Right Justifying）编码。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210629145837.png\" alt=\"image-20210629145800027\" /><figcaption aria-hidden=\"true\">image-20210629145800027</figcaption>\n</figure>\n<h2 id=\"特点\">特点</h2>\n<ol type=\"1\">\n<li><p>支持全双工/半双工</p></li>\n<li><p>支持主/从模式</p></li>\n<li><p>和PCM相比，I2S更适合立体声系统。当然，I2S的变体也支持多通道的时分复用，因此可以支持多声道。</p></li>\n</ol>\n<h2 id=\"硬件特性\">硬件特性</h2>\n<h3 id=\"总线介绍\">总线介绍</h3>\n<blockquote>\n<p>To minimize the number of pins required and to keep wiring simple, a <strong><em>3-line serial bus is used</em></strong> consisting of a line for <strong><em>two time-multiplexed data channels</em></strong>, <strong><em>a word select line</em></strong>(WS) and <strong><em>a clock line</em></strong> (SCK).</p>\n</blockquote>\n<p><img src=\"https://pic.islet.space/2021/06/20210629172149.png\" alt=\"image-20210629112429113\" style=\"zoom:67%;\" /></p>\n<p>从上图得知，I2S总线共需要三个引脚：</p>\n<ul>\n<li>连续串行时钟线（<strong>SCK</strong> / <strong>SCLK</strong> / <strong>BCLK</strong>），也叫位时钟，即对应数字音频的每一位数据，SCLK都有1个脉冲。SCLK的频率=2×采样频率×采样位数。</li>\n<li>字选择线（<strong>WS</strong> / <strong>LRCLK</strong>），也叫帧时钟，用于切换左右声道的数据。LRCK为“1”表示正在传输的是右声道的数据，为“0”则表示正在传输的是左声道的数据。LRCK的频率等于采样频率。</li>\n<li>时分多路复用（简称 TDM）数据线，即串行数据（<strong>SD</strong> 或 <strong>SDATA</strong>），就是<mark>用二进制补码表示的</mark>音频数据。</li>\n</ul>\n<p>另，有时为了使系统间能够更好地同步，还需要另外传输一个信号MCLK，称为<strong>主时钟</strong>，也叫系统时钟（Sys Clock），<mark>是采样频率的256倍或384倍</mark>。</p>\n<p><strong><em>注意</em></strong>：能够生成SCK和WS的就是主设备（Master）。</p>\n<h3 id=\"电压要求\">电压要求</h3>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>VL</th>\n<th>VH</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>输出电平</td>\n<td>&lt;0.4V</td>\n<td>&gt;2.4V</td>\n</tr>\n<tr class=\"even\">\n<td>输入电平</td>\n<td>0.8V</td>\n<td>2.0V</td>\n</tr>\n</tbody>\n</table>\n<p>这是使用的TTL电平标准，随着其他IC（LSI）的流行，其他电平也会支持。</p>\n<h2 id=\"串行数据\">串行数据</h2>\n<blockquote>\n<p>I2S格式的信号无论有多少位有效数据，数据的最高位总是出现在LRCK变化（也就是一帧开始）后的第2个SCLK脉冲处。这就使得<mark>接收端与发送端的有效位数可以不同</mark>。如果接收端能处理的有效位数少于发送端，可以放弃数据帧中多余的低位数据；如果接收端能处理的有效位数多于发送端，可以自行补足剩余的位。这种同步机制使得数字音频设备的互连更加方便，而且不会造成数据错位。</p>\n<p>随着技术的发展，在统一的 <strong>I2S接口</strong> 下，出现了多种不同的数据格式。根据SDATA数据相对于LRCK和SCLK的位置不同，分为左对齐（较少使用）、I2S格式（即飞利浦规定的格式）和右对齐（也叫日本格式、普通格式）。</p>\n<p>为了保证数字音频信号的正确传输，发送端和接收端应该采用相同的数据格式和长度。当然，对I2S格式来说数据长度可以不同。</p>\n</blockquote>\n<h2 id=\"字选择\">字选择</h2>\n<p>字选择（word select），也可以叫命令选择线，表明了正在被传输的声道。</p>\n<ul>\n<li><code>WS=0</code> ，表示正在传输的是 <strong>左声道</strong> 的数据。</li>\n<li><code>WS=1</code> ，表示正在传输的是 <strong>右声道</strong> 的数据。</li>\n</ul>\n<p>WS可以在串行时钟的上升沿或者下降沿发生改变，并且WS信号不需要一定是对称的。在从属装置端，WS<mark>在时钟信号的上升沿发生改变</mark>。WS总是<mark>在最高位传输前的一个时钟周期发生改变</mark>，这样可以使从属装置得到与被传输的串行数据同步的时间，并且使接收端存储当前的命令以及为下次的命令清除空间。</p>\n<h1 id=\"adi-codec-i2s移植\">ADI-Codec I2S移植</h1>\n<p>以下文章/教程仅针对官方提供的例程《AD1939_I2S_Sample_Based_Talkthru》进行修改。</p>\n<blockquote>\n<ul>\n<li><code>&lt;ad1939.h&gt;</code> 定义了ADAU1939的宏定义，包括锁相环、时钟、DAC、ADC等的寄存器，与直接从SigmaStudio导出的文件并没有太大差别，应该经过精简。</li>\n<li></li>\n</ul>\n</blockquote>\n<p>首先，需要清晰认识1939和1772的硬件差异。ADAU1939和ADAU1772硬件上的异同，都有4个差分输入，但是1939有8个差分输出，1772有2个双声道输出（4个差分输出）。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210628095302.png\" alt=\"image-20210628095252103\" /><figcaption aria-hidden=\"true\">image-20210628095252103</figcaption>\n</figure>\n<blockquote>\n<p><strong><em>SPORTS</em></strong> ，即Serial Ports的简称，串行接口。</p>\n</blockquote>\n<p>在<code>&lt;ADDS_21479_EzKit.h&gt;</code> 头文件里，以下声明适用于21479和1939的音频通信通道，定义了 <strong><em>2个双声道输入</em></strong> 和 <strong><em>4个双声道输出</em></strong> ，正好符合1939的 <strong><em>4个差分输入</em></strong> 和 <strong><em>8个差分输出</em></strong> 的硬件描述，对应修改到1772时需要减少输出的声音通道。本文件仅对一些全局变量、声音通道、函数等做出声明，具体应用在其他.c文件或.asm文件中。</p>\n<p>通过 <strong><em>Sport1 A</em></strong> 从Codec接收数据，并通过 <strong><em>Sport0 A/B</em></strong> 和 <strong><em>Sport2 A/B</em></strong> 将音频数据传输至Codec的四个立体声DAC接口。Sport1 接收中断服务程序以在 DMA接收缓存 <code>rx1a_buf</code> 上完成算术运算（arithmetic computations），并将计算结果存放至 DMA传输缓存 <code>tx0a_buf</code> 。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/******************************************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">/                                                                                                     /</span></span><br><span class=\"line\"><span class=\"comment\">/                            AD1939 - SPORT1 RX INTERRUPT SERVICE ROUTINE                             /</span></span><br><span class=\"line\"><span class=\"comment\">/                                                                                                     /</span></span><br><span class=\"line\"><span class=\"comment\">/    Receives input data from the AD1939 ADCs via SPORT1 A and transmits processed audio data         /</span></span><br><span class=\"line\"><span class=\"comment\">/    back out to the four AD1939 Stereo DACs/Line Outputs through SPORT0 A/B and SPORT2 A/B           /</span></span><br><span class=\"line\"><span class=\"comment\">/                                                                                                     /</span></span><br><span class=\"line\"><span class=\"comment\">/                                                                                                     /</span></span><br><span class=\"line\"><span class=\"comment\">/   This Serial Port 1 Recieve Interrupt Service Routine performs arithmetic computations on          /</span></span><br><span class=\"line\"><span class=\"comment\">/   the SPORT1 receive DMA buffer (rx1a_buf) and places results to SPORT0 transmit                    /</span></span><br><span class=\"line\"><span class=\"comment\">/   DMA buffer (tx0a_buf)                                                                             /</span></span><br><span class=\"line\"><span class=\"comment\">/                                                                                                     /</span></span><br><span class=\"line\"><span class=\"comment\">/  rx1a_buf[2] - DSP SPORT0 A receive buffer - AD1939 ASDATA1                                         /</span></span><br><span class=\"line\"><span class=\"comment\">/  Slot # Description                             DSP Data Memory Address                             /</span></span><br><span class=\"line\"><span class=\"comment\">/  ------ --------------------------------------  --------------------------------------------------  /</span></span><br><span class=\"line\"><span class=\"comment\">/  0      Internal ADC 0 Left Channel             DM(_rx1a_buf + 0) = DM(_rx1a_buf + Internal_ADC_L1) /</span></span><br><span class=\"line\"><span class=\"comment\">/  1      Internal ADC 0 Right Channel            DM(_rx1a_buf + 1) = DM(_rx1a_buf + Internal_ADC_R1) /</span></span><br><span class=\"line\"><span class=\"comment\">/                                                                                                     /</span></span><br><span class=\"line\"><span class=\"comment\">/  rx1b_buf[2] - DSP SPORT0 B receive buffer - AD1939 ASDATA2                                         /</span></span><br><span class=\"line\"><span class=\"comment\">/  Slot # Description                             DSP Data Memory Address                             /</span></span><br><span class=\"line\"><span class=\"comment\">/  ------ --------------------------------------  --------------------------------------------------  /</span></span><br><span class=\"line\"><span class=\"comment\">/  0      Internal ADC 1 Left Channel             DM(_rx1b_buf + 2) = DM(_rx1b_buf + Internal_ADC_L2) /</span></span><br><span class=\"line\"><span class=\"comment\">/  1      Internal ADC 1 Right Channel            DM(_rx1b_buf + 3) = DM(_rx1b_buf + Internal_ADC_R2) /</span></span><br><span class=\"line\"><span class=\"comment\">/                                                                                                     /</span></span><br><span class=\"line\"><span class=\"comment\">/  tx0a_buf[2] - DSP SPORT0 A transmit buffer - AD1939 DSDATA1                                        /</span></span><br><span class=\"line\"><span class=\"comment\">/  Slot # Description                             DSP Data Memory Address                             /</span></span><br><span class=\"line\"><span class=\"comment\">/  ------ --------------------------------------  --------------------------------------------------  /</span></span><br><span class=\"line\"><span class=\"comment\">/  0      Internal DAC 1 Left Channel             DM(_tx0a_buf + 0) = DM(_tx0a_buf + Internal_DAC_L1) /</span></span><br><span class=\"line\"><span class=\"comment\">/  1      Internal DAC 1 Right Channel            DM(_tx0a_buf + 1) = DM(_tx0a_buf + Internal_DAC_R1) /</span></span><br><span class=\"line\"><span class=\"comment\">/                                                                                                     /</span></span><br><span class=\"line\"><span class=\"comment\">/  tx0a_buf[2] - DSP SPORT0 B transmit buffer - AD1939 DSDATA2                                        /</span></span><br><span class=\"line\"><span class=\"comment\">/  Slot # Description                             DSP Data Memory Address                             /</span></span><br><span class=\"line\"><span class=\"comment\">/  ------ --------------------------------------  --------------------------------------------------  /</span></span><br><span class=\"line\"><span class=\"comment\">/  2      Internal DAC 2 Left Channel             DM(_tx0b_buf + 2) = DM(_tx0b_buf + Internal_DAC_L2) /</span></span><br><span class=\"line\"><span class=\"comment\">/  3      Internal DAC 2 Right Channel            DM(_tx0b_buf + 3) = DM(_tx0b_buf + Internal_DAC_R2) /</span></span><br><span class=\"line\"><span class=\"comment\">/                                                                                                     /</span></span><br><span class=\"line\"><span class=\"comment\">/  tx2a_buf[2] - DSP SPORT2 A transmit buffer - AD1939 DSDATA3                                        /</span></span><br><span class=\"line\"><span class=\"comment\">/  Slot # Description                             DSP Data Memory Address                             /</span></span><br><span class=\"line\"><span class=\"comment\">/  ------ --------------------------------------  --------------------------------------------------  /</span></span><br><span class=\"line\"><span class=\"comment\">/  4      Internal DAC 3 Left Channel             DM(_tx2a_buf + 4) = DM(_tx2a_buf + Internal_DAC_L3) /</span></span><br><span class=\"line\"><span class=\"comment\">/  5      Internal DAC 3 Right Channel            DM(_tx2a_buf + 5) = DM(_tx2a_buf + Internal_DAC_R3) /</span></span><br><span class=\"line\"><span class=\"comment\">/                                                                                                     /</span></span><br><span class=\"line\"><span class=\"comment\">/  tx2b_buf[2] - DSP SPORT2 B transmit buffer - AD1939 DSDATA4                                        /</span></span><br><span class=\"line\"><span class=\"comment\">/  Slot # Description                             DSP Data Memory Address                             /</span></span><br><span class=\"line\"><span class=\"comment\">/  ------ --------------------------------------  --------------------------------------------------  /</span></span><br><span class=\"line\"><span class=\"comment\">/  6      Internal DAC 4 Left Channel             DM(_tx2b_buf + 6) = DM(_tx2b_buf + Internal_DAC_L4) /</span></span><br><span class=\"line\"><span class=\"comment\">/  7      Internal DAC 4 Right Channel            DM(_tx2b_buf + 7) = DM(_tx2b_buf + Internal_DAC_R4) /</span></span><br><span class=\"line\"><span class=\"comment\">/                                                                                                     /</span></span><br><span class=\"line\"><span class=\"comment\">******************************************************************************************************/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"sptcl寄存器操作\">SPTCL寄存器操作</h2>\n<p>下方代码是官方示例给出，并经过唐昊整合修改过，其寄存器设置的功能解读和验证如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">*pSPCTL0 = (SPTRAN | OPMODE | SLEN32 | SPEN_A | SCHEN_A | SDEN_A | SPEN_B | SCHEN_B | SDEN_B);</span><br><span class=\"line\">*pSPCTL1 = (OPMODE | SLEN32 | SPEN_A | SCHEN_A | SDEN_A | SPEN_B | SCHEN_B | SDEN_B);</span><br><span class=\"line\">*pSPCTL2 = (OPMODE | SLEN32 | SPEN_A | SCHEN_A | SDEN_A | SPEN_B | SCHEN_B | SDEN_B);</span><br></pre></td></tr></table></figure>\n<p><strong>SPTRAN</strong>: Serial port Data Transfer Direction. Transfer / Receive from both Channel A and Channel B. 需要注意的是，传输和接收功能只有一个会在 <code>SOPRTx_CLK</code> 和 <code>SPORTx_FS</code> 控制 <strong><em>传输/接收位移寄存器</em></strong>（Transmit/Receive shift register） 时被激活。</p>\n<p><strong>OPMODE</strong>: SPORT Operation Mode, <strong><em>I2S</em></strong> / <strong><em>packed</em></strong>, <strong><em>left-justified</em></strong> mode</p>\n<p><strong>SLEN32</strong>: Serial port word length, in I2S / left-justified mode , we used SLEN8 ~ SLEN32. <mark>但实际上，1772输出的I2S声道字长度是24bits</mark>。</p>\n<p><strong>SPEN_A</strong>: Serial port <strong><em>Channel A DMA</em></strong> enabled.</p>\n<p><strong>SCHEN_A</strong>: Serial port <strong><em>Channel A DMA Chainning</em></strong> enabled.</p>\n<p><strong>SDEN_A</strong>: Serial port <strong><em>Channel A DMA</em></strong> enabled.</p>\n<p><strong>SPEN_B</strong>: Serial port <strong><em>Channel B DMA</em></strong> enabled.</p>\n<p><strong>SCHEN_B</strong>: Serial port <strong><em>Channel B DMA Chainning</em></strong> enabled.</p>\n<p><strong>SDEN_B</strong>: Serial port <strong><em>Channel B DMA</em></strong> enabled.</p>\n<p>通过查询表《HWR》中的表A-84可知，SPORT 0 ~ 2 的设置符合 0用于传输，1和2用于接收的要求。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/20210702110602.png\" alt=\"image-20210702110559930\" /><figcaption aria-hidden=\"true\">image-20210702110559930</figcaption>\n</figure>\n<p>需要尽可能拉高逻辑分析仪的采样频率，如24MHz以上。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/20210702111537.png\" alt=\"image-20210702111535166\" /><figcaption aria-hidden=\"true\">image-20210702111535166</figcaption>\n</figure>\n<p>1772下I2S的数据深度为16 ~ 24bit，后面的长度都会由0补齐，采集显示设置时可以设置32bit或24bit皆可。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/20210702113337.png\" alt=\"image-20210702113249646\" /><figcaption aria-hidden=\"true\">image-20210702113249646</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/20210702113543.png\" alt=\"image-20210702113540262\" /><figcaption aria-hidden=\"true\">image-20210702113540262</figcaption>\n</figure>\n<h1 id=\"asrc-of-adau1772\">ASRC OF ADAU1772</h1>\n<p>ADAU1772 master clock input, but the LRCLK and BCLK must be synchronous to each other. The LRCLK and BCLK pins are used to clock both the serial input and output ports.</p>\n<p>ADAU1772 can be set to be either the master or the slave in a system. <mark>Because there is only one set of serial data clocks, the input and output ports must always both be either master or slave.</mark></p>\n<p>It is <mark>recommended to use the high drive settings on the serial port pins</mark>.</p>\n<p>串行音频接口的通信时序说明图如下，</p>\n<p>其中， t<sub>SOD</sub> 是指：ADC_SDATAx delay; time from BCLK falling (master and slave modes)。从下图中看出PDM（ LJ / RJ / I2S ）都有 t<sub>SOD</sub> 。</p>\n<p><img src=\"https://pic.islet.space/2021/07/20210702135103.png\" alt=\"image-20210702111739875\" style=\"zoom: 80%;\" /></p>\n<p>虽然同样是I2S，且LJ的标准和飞利浦I2S的标准都是左端对齐，但是飞利浦的数据会比LRCLK延时一个完整的时钟周期。而标准LJ则是LRCLK、BCLK 和 SDATA 完全对齐。</p>\n<h2 id=\"通信时钟要求\">通信时钟要求</h2>\n<p>量产版采用统一的 <code>16.6MHz</code> 为2个codecs和1个DSP主芯片提供时钟。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210705151852538.png\" alt=\"image-20210705151852538\" /><figcaption aria-hidden=\"true\">image-20210705151852538</figcaption>\n</figure>\n<p>异步设备通信开发顺利的前提要求是两者的通信时钟能否保持一致，即最关键的通信时钟信号（<strong><em>BCLK</em></strong> / <strong><em>LRCLK</em></strong>）是否符合设定要求(3.072MHz / 48KHz)。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/20210705084415.png\" alt=\"image-20210705084133066\" /><figcaption aria-hidden=\"true\">image-20210705084133066</figcaption>\n</figure>\n<p>使用逻辑分析仪去测量音频设备的输出 <strong>帧时钟</strong>（LRCLK） 频率，如果其时钟输出结果符合设置的 <code>48KHz</code> 要求，则说明正确。其 <strong>位时钟频率要求</strong> 应等于 <code>帧时钟长度 * 数据深度 * 2</code> ，如 帧时钟频率为48KHz的 位时钟频率为 <code>48KHz * 32bits * 2</code> ，大致等于 <code>3.072 MHz</code> 。</p>\n<p><strong>注意</strong>：逻辑分析仪能否清晰测量和指示波形周期，仍需要该设备自身支持较高频率的采样速率，最好采样速率能与需要采样的目标速率成倍数关系。如果速率过低，则会出现采样变形。如下图中的位时钟采样和测量为 <code>3MHz</code> ，中途会偶然出现 <code>3.429MHz</code>。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/20210705095045.png\" alt=\"image-20210705095017424\" /><figcaption aria-hidden=\"true\">image-20210705095017424</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/20210705095205.png\" alt=\"image-20210705095203461\" /><figcaption aria-hidden=\"true\">image-20210705095203461</figcaption>\n</figure>\n<p>在设置错误时，会出现如下情况：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/20210705085250.png\" alt=\"image-20210705085041206\" /><figcaption aria-hidden=\"true\">image-20210705085041206</figcaption>\n</figure>\n<p>在21479上设置好I2S的 slave端 代码，被动接收master端音频并转发回给master端，而ADAU1772在使用USBi单独通信设置好通信频率48KHz后，成功与21479实现全双工音频转发。</p>\n<p>在评估版用户手册中，提示需要16.625MHz的时钟提供给DSP21479。通过修改量产板上codec的PLL寄存器设置，发现 <code>16.625MHz</code> 无效，设置时不起作用，因为与所提供的时钟频率（16.6MHz）不符。</p>\n<p><img src=\"https://pic.islet.space/2021/07/20210705134121.png\" alt=\"image-20210705104426587\" style=\"zoom: 50%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210705143238320.png\" alt=\"image-20210705143238320\" style=\"zoom: 80%;\" /></p>\n<p>设置成 <code>16.6MHz</code> 则可以工作，能够顺利采集到数据（暂停时刻查看缓存数据）。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210705143246050.png\" alt=\"image-20210705143246050\" style=\"zoom: 80%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210705143606164.png\" alt=\"image-20210705143606164\" style=\"zoom:67%;\" /></p>\n<p>仔细阅读以下寄存器信息。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210705145709904.png\" alt=\"image-20210705145709904\" /><figcaption aria-hidden=\"true\">image-20210705145709904</figcaption>\n</figure>\n<p><strong>注意</strong>：SigmaStudio中，设置 <strong>输入时钟信号</strong>（MCLK input）和 <strong>输出时钟信号</strong>（VCO Output）后，仅有 <strong>输入信号分频</strong>（input clock divider，下简称 <strong><em>ICD</em></strong>）是可以设置的，其他参数由 <code>load parameters</code> 自动计算。在 <strong><em>输入频率</em></strong> <code>16.6MHz</code> 和 <strong><em>输出频率</em></strong> <code>24.576MHz</code> 不变的情况下，改变 输入信号分频 以生成下表：</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>ICD = 1</th>\n<th>ICD = 2</th>\n<th>ICD = 3</th>\n<th>ICD = 4</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>PLL_CTRL0</td>\n<td>0x08</td>\n<td>0x08</td>\n<td>0x08</td>\n<td>0x08</td>\n</tr>\n<tr class=\"even\">\n<td>PLL_CTRL1</td>\n<td>0x1B</td>\n<td>0x1B</td>\n<td>0x1B</td>\n<td>0x1B</td>\n</tr>\n<tr class=\"odd\">\n<td>PLL_CTRL2</td>\n<td>0x07</td>\n<td>0x07</td>\n<td>0x17</td>\n<td>0x1F</td>\n</tr>\n<tr class=\"even\">\n<td>PLL_CTRL3</td>\n<td>0xCA</td>\n<td>0x79</td>\n<td>0x5E</td>\n<td>0x28</td>\n</tr>\n<tr class=\"odd\">\n<td>PLL_CTRL4</td>\n<td>0x11</td>\n<td>0x2B</td>\n<td>0x35</td>\n<td>0x47</td>\n</tr>\n<tr class=\"even\">\n<td>PLL_CTRL5</td>\n<td>0x01</td>\n<td>0x01</td>\n<td>0x01</td>\n<td>0x01</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>PLL_CTRL0</code> 和 <code>PLL_CTRL1</code> 分别构成 PLL分母（denominator）的高位和低位。</li>\n<li><code>PLL_CTRL2</code> 和 <code>PLL_CTRL3</code> 分别构成 PLL分子（numerator）的高位和低位。</li>\n<li><code>PLL_CTRL4</code> 控制着 <strong>PLL类型</strong>（整数型/分数型）、<strong>输入时钟分频</strong>（1 - 4）和 PLL设置的 <strong>整数部分</strong>。</li>\n<li><code>PLL_CTRL5</code> 目前只能是 <code>0x00</code> 或 <code>0x01</code> 。</li>\n</ul>\n<p>以下为PLL_CTRL4寄存器的位描述：n</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210706101429733.png\" alt=\"image-20210706101429733\" /><figcaption aria-hidden=\"true\">image-20210706101429733</figcaption>\n</figure>\n<p>至于 <code>CLK_CONTROL</code> 寄存器，主要是数值 <code>0x89</code> 和 <code>0x8F</code> 的差别。见下表可知，是关于PLL分频的问题。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210705153843902.png\" alt=\"image-20210705153843902\" /><figcaption aria-hidden=\"true\">image-20210705153843902</figcaption>\n</figure>\n<p>通过自行编写的代码，遍历所有可更改的系数进行计算求解，取得小数点后9位精度，并且符合要求的系数如下（含1/2系数）：</p>\n<p>根据PLL_CTRL4寄存器，ICD=3、IS=8时，该寄存器的值为 <code>01000101</code> ，即 <code>0x45</code> 。（下图IDC更正为ICD）</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210706001243698.png\" alt=\"image-20210706001243698\" /><figcaption aria-hidden=\"true\">image-20210706001243698</figcaption>\n</figure>\n<p>以下为不含1/2系数的结果：</p>\n<p>根据PLL_CTRL4寄存器，ICD=3、IS=4时，该寄存器的值为 <code>00100101</code> ，即 <code>0x25</code> 。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210706001350802.png\" alt=\"image-20210706001350802\" /><figcaption aria-hidden=\"true\">image-20210706001350802</figcaption>\n</figure>\n<ul>\n<li>CLK_IN mean value is 16.6Mhz</li>\n<li>LRCLK mean value is 45.92Khz</li>\n</ul>\n<h1 id=\"anc主板硬件量产\">ANC主板硬件（量产）</h1>\n<p>以下为ADAU1772的特征：</p>\n<p><strong>Master clock</strong> = <strong>core clock</strong> = 12.288 MHz</p>\n<p><strong>serial input sample rate</strong> = 48 kHz</p>\n<p><strong>measurement bandwidth</strong> = 20 Hz to 20 kHz</p>\n<p><strong>word width</strong> = 24 bits</p>\n<p><strong>ambient temperature</strong> = 25°C</p>\n<p><strong>outputs line loaded</strong> with 10 kΩ</p>\n<p>Codec A是接了DAC输出的，Codec B没有，其地址分别为 <code>0x3D</code> 与 <code>0x3E</code>。</p>\n<h2 id=\"twi-i2c\">TWI (I2C)</h2>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>Codec A</th>\n<th>Codec B</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>SCK</td>\n<td>DPI_P08</td>\n<td>DPI_P08</td>\n</tr>\n<tr class=\"even\">\n<td>SDA</td>\n<td>DPI_P07</td>\n<td>DPI_P07</td>\n</tr>\n<tr class=\"odd\">\n<td>ADDR0</td>\n<td>+3.3VA</td>\n<td>AGND</td>\n</tr>\n<tr class=\"even\">\n<td>ADDR1</td>\n<td>AGND</td>\n<td>+3.3VA</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"i2s\">I2S</h2>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>Codec A</th>\n<th>Codec B</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>ADC_SDATA_0</td>\n<td>DAI_P13</td>\n<td>DAI_P15</td>\n</tr>\n<tr class=\"even\">\n<td>ADC_SDATA_1 <em>(clock)</em></td>\n<td>DAI_P03</td>\n<td>DAI_P16</td>\n</tr>\n<tr class=\"odd\">\n<td>LRCLK</td>\n<td>DAI_P02</td>\n<td>DAI_P11 (<em>useless</em>)</td>\n</tr>\n<tr class=\"even\">\n<td>BCLK</td>\n<td>DAI_P01</td>\n<td>DAI_P12 (<em>useless</em>)</td>\n</tr>\n<tr class=\"odd\">\n<td>DAC_SDATA</td>\n<td>DAI_P07</td>\n<td>/</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://pic.islet.space/2021/07/20210702100719.png\" alt=\"image-20210702100716720\" style=\"zoom:80%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/07/20210702101017.png\" alt=\"image-20210702100920210\" style=\"zoom:67%;\" /><img src=\"https://pic.islet.space/2021/07/20210702101020.png\" alt=\"image-20210702101004870\" style=\"zoom:67%;\" /></p>\n<h2 id=\"spi\">SPI</h2>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>FLASH</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>SPI_SOMI</td>\n<td>DPI_P01</td>\n</tr>\n<tr class=\"even\">\n<td>SPI_SIMO</td>\n<td>DPI_P02</td>\n</tr>\n<tr class=\"odd\">\n<td>SPI_CLK</td>\n<td>DPI_P03</td>\n</tr>\n<tr class=\"even\">\n<td>SPI_SCS</td>\n<td>DPI_P05</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li><p>《<a href=\"\">I2S bus specification</a>》</p></li>\n<li><p><a href=\"https://baike.baidu.com/item/I2S/3443390\">I2S</a></p></li>\n<li><p><a href=\"https://blog.csdn.net/q2519008/article/details/80413695\">【音频】I2S协议详解</a></p></li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/353520173\">I2S/PCM</a></p></li>\n</ol>\n","categories":["Communication"],"tags":["I2S","ADI"]},{"title":"JTAG通信","url":"/2021/07/10/Communication/2021-07-10-JTAG%E9%80%9A%E4%BF%A1/","content":"<h1 id=\"入门\">入门</h1>\n<p>以下为 B站up主——“蛋饼的爹地” 制作上传的JTAG科普视频。</p>\n<iframe src=\"//player.bilibili.com/player.html?aid=503270942&amp;bvid=BV1iN411Z7jk&amp;cid=346887915&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\">\n</iframe>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li><a href=\"https://xploreqa.ieee.org/stampPDF/getPDF.jsp?tp=&amp;arnumber=6515989&amp;ref=aHR0cHM6Ly94cGxvcmVxYS5pZWVlLm9yZy9kb2N1bWVudC82NTE1OTg5\">《IEEE 1149.1-2013 Test Access Port and Boundary Scan Architecture》</a></li>\n</ol>\n","categories":["Communication"],"tags":["debug","JTAG"]},{"title":"SPI通信","url":"/2021/08/18/Communication/2021-08-18-SPI%E9%80%9A%E4%BF%A1/","content":"<h1 id=\"串行外设接口\">串行外设接口</h1>\n<p><strong>串行外设接口</strong>（Serial Peripheral Interface，SPI）是微控制器和外围IC（如传感器、ADC、DAC、移位寄存器、SRAM等）之间使用最广泛的接口之一。</p>\n<p>SPI是一种同步、全双工、主从式接口。来自主机或从机的数据在时钟<mark>上升沿或下降沿同步</mark>。主机和从机可以同时传输数据。SPI接口可以是 <strong>3线式</strong> 或 <strong>4线式</strong>。后述中重点介绍常用的4线SPI接口。</p>\n<p>与I2C的 <strong>多主多从</strong> 模式不同，SPI协议为 <strong>一主多从</strong> 模式。SPI所消耗的接口数也大大提升。</p>\n<h2 id=\"接口介绍\">接口介绍</h2>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819075248043.png\" alt=\"image-20210819075248043\" style=\"zoom: 33%;\" /></p>\n<div style=\"font-weight: 900; text-align: center;\">\n图1. 含主机和从机的SPI配置\n</div>\n<p>4线SPI器件有四个信号：</p>\n<ul>\n<li>时钟(SPI CLK, SCLK)</li>\n<li>片选(CS)</li>\n<li>主机输出、从机输入(MOSI)</li>\n<li>主机输入、从机输出(MISO)</li>\n</ul>\n<p>产生时钟信号的器件称为主机。主机和从机之间传输的数据与主机产生的时钟同步。同I2C接口相比，SPI器件支持更高的时钟频率。查阅相关产品数据手册以了解SPI接口的时钟频率规格。</p>\n<p><mark style=\"font-weight: 900;\">SPI接口只能有一个主机，但可以有一个或多个从机。</mark>图1显示了主机和从机之间的SPI连接。</p>\n<p>来自主机的片选信号用于选择从机。这 <mark style=\"font-weight: 900;\">通常是一个低电平有效信号，拉高时从机与SPI总线断开连接</mark>。当使用多个从机时，主机需要为每个从机提供单独的片选信号。<u>本文中</u> 的片选信号始终是低电平有效信号。</p>\n<p>MOSI和MISO是数据线。MOSI将数据从主机发送到从机，MISO将数据从从机发送到主机。</p>\n<h2 id=\"数据传输\">数据传输</h2>\n<p>要开始SPI通信，主机必须发送时钟信号，并通过使能CS信号选择从机。片选通常是低电平有效信号。因此，主机必须在该信号上发送逻辑0以选择从机。SPI是全双工接口，主机和从机可以分别通过MOSI和MISO线路同时发送数据。在SPI通信期间，数据的发送（串行移出到MOSI/SDO总线上）和接收（采样或读入总线(MISO/SDI)上的数据）同时进行。串行时钟沿同步数据的移位和采样。SPI接口允许用户灵活选择时钟的上升沿或下降沿来采样和/或移位数据。</p>\n<p><strong>需要注意</strong>：SPI接口传输的 <strong>数据位数</strong> 仍需查阅器件数据手册。</p>\n<h2 id=\"时钟极性和时钟相位\">时钟极性和时钟相位</h2>\n<p>在SPI中，主机可以选择 <strong>时钟极性</strong>（Clock Polarity，<strong>CPOL</strong>）和 <strong>时钟相位</strong>（Clock Phase，<strong>CPHA</strong>）。</p>\n<p>在空闲状态期间，CPOL 控制 时钟极性。空闲状态是指传输开始时CS为高电平且在向低电平转变的期间，以及传输结束时CS为低电平且在向高电平转变的期间。</p>\n<p>CPHA 控制 时钟相位。<mark>根据CPHA位的状态，使用时钟上升沿或下降沿来采样和/或移位数据</mark>。主机必须 <mark>根据从机的要求选择时钟极性和时钟相位</mark>。根据CPOL和CPHA位的选择，有四种SPI模式可用，如下表：</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>SPI 模式</th>\n<th>CPOL</th>\n<th>CPHA</th>\n<th>空闲状态下的时钟极性</th>\n<th>用于采样和/或移位数据的时钟相应</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>逻辑低电平</td>\n<td>数据在上升沿采样，在下降沿移出</td>\n</tr>\n<tr class=\"even\">\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>逻辑低电平</td>\n<td>数据在下降沿采样，在上升沿移出</td>\n</tr>\n<tr class=\"odd\">\n<td>2</td>\n<td>1</td>\n<td>1</td>\n<td>逻辑低电平</td>\n<td>数据在下降沿采样，在上升沿移出</td>\n</tr>\n<tr class=\"even\">\n<td>3</td>\n<td>1</td>\n<td>0</td>\n<td>逻辑低电平</td>\n<td>数据在上升沿采样，在下降沿移出</td>\n</tr>\n</tbody>\n</table>\n<p>下图为TI公司F280049芯片的SPI时钟模式：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210819084200284.png\" alt=\"image-20210819084200284\" /><figcaption aria-hidden=\"true\">image-20210819084200284</figcaption>\n</figure>\n<p>下图为ADI公司ADSP21479芯片的SPI时钟模式：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210819084447672.png\" alt=\"image-20210819084447672\" /><figcaption aria-hidden=\"true\">image-20210819084447672</figcaption>\n</figure>\n<p>后述 图2 至 图5 显示了四种SPI模式下的通信示例。</p>\n<p>在这些示例中，数据显示在MOSI和MISO线上。传输的开始和结束用绿色虚线表示，采样边沿用橙色虚线表示，移位边沿用蓝色虚线表示。请注意，这些图形仅供参考。要成功进行SPI通信，用户须参阅产品数据手册并确保满足器件的时序规格。</p>\n<p><img src=\"https://pic.islet.space/2021/08/205973_fig_02.png\" alt=\"图2. SPI模式0，CPOL = 0，CPHA = 0：CLK空闲状态 = 低电平，数据在上升沿采样，并在下降沿移出\" style=\"zoom: 60%;\" /></p>\n<div style=\"font-weight: 900; text-align: center;\">\n图2. SPI模式0，CPOL = 0，CPHA = 0：CLK空闲状态 = 低电平，数据在上升沿采样，并在下降沿移出\n</div>\n<p>图3给出了SPI模式1的时序图。在此模式下，时钟极性为0，表示时钟信号的空闲状态为低电平。此模式下的时钟相位为1，表示数据在下降沿采样（由橙色虚线显示），并且数据在时钟信号的上升沿移出（由蓝色虚线显示）。</p>\n<p><img src=\"https://www.analog.com/-/media/images/analog-dialogue/en/volume-52/number-3/articles/introduction-to-spi-interface/205973_fig_03.png?la=en&vs=1\" alt=\"图3. SPI模式1，CPOL = 0，CPHA = 1：CLK空闲状态 = 低电平，数据在下降沿采样，并在上升沿移出\" style=\"zoom:50%;\" /></p>\n<div style=\"font-weight: 900; text-align: center;\">\n图3. SPI模式1，CPOL = 0，CPHA = 1：CLK空闲状态 = 低电平，数据在下降沿采样，并在上升沿移出\n</div>\n<p>图4给出了SPI模式2的时序图。在此模式下，时钟极性为1，表示时钟信号的空闲状态为高电平。此模式下的时钟相位为1，表示数据在下降沿采样（由橙色虚线显示），并且数据在时钟信号的上升沿移出（由蓝色虚线显示）。</p>\n<p><img src=\"https://www.analog.com/-/media/images/analog-dialogue/en/volume-52/number-3/articles/introduction-to-spi-interface/205973_fig_04.png?la=en&vs=1\" alt=\"图4. SPI模式2，CPOL = 1，CPHA = 1：CLK空闲状态 = 高电平，数据在下降沿采样，并在上升沿移出\" style=\"zoom:50%;\" /></p>\n<div style=\"font-weight: 900; text-align: center;\">\n图4. SPI模式2，CPOL = 1，CPHA = 1：CLK空闲状态 = 高电平，数据在下降沿采样，并在上升沿移出。\n</div>\n<p>图5给出了SPI模式3的时序图。在此模式下，时钟极性为1，表示时钟信号的空闲状态为高电平。此模式下的时钟相位为0，表示数据在上升沿采样（由橙色虚线显示），并且数据在时钟信号的下降沿移出（由蓝色虚线显示）。</p>\n<p><img src=\"https://www.analog.com/-/media/images/analog-dialogue/en/volume-52/number-3/articles/introduction-to-spi-interface/205973_fig_05.png?la=en&vs=1\" alt=\"图5. SPI模式3，CPOL = 1，CPHA = 0：CLK空闲状态 = 高电平，数据在上升沿采样，并在下降沿移出\" style=\"zoom:50%;\" /></p>\n<div style=\"font-weight: 900; text-align: center;\">\n图5. SPI模式3，CPOL = 1，CPHA = 0：CLK空闲状态 = 高电平，数据在上升沿采样，并在下降沿移出\n</div>\n<h2 id=\"多从机配置\">多从机配置</h2>\n<p>多个从机可与单个SPI主机一起使用。从机可以采用常规模式连接，或采用菊花链模式连接。</p>\n<h3 id=\"常规spi模式\">常规SPI模式</h3>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210819075431419.png\" alt=\"image-20210819075431419\" /><figcaption aria-hidden=\"true\">image-20210819075431419</figcaption>\n</figure>\n<div style=\"font-weight: 900; text-align: center;\">\n图6. 多从机SPI配置\n</div>\n<p>在常规模式下，主机需要为每个从机提供单独的片选信号。一旦主机使能（拉低）片选信号，MOSI/MISO线上的时钟和数据便可用于所选的从机。如果使能多个片选信号，则MISO线上的数据会被破坏，因为主机无法识别哪个从机正在传输数据。</p>\n<p>从图6可以看出，随着从机数量的增加，来自主机的片选线的数量也增加。这会快速增加主机需要提供的输入和输出数量，并限制可以使用的从机数量。可以使用其他技术来增加常规模式下的从机数量，例如使用多路复用器产生片选信号。</p>\n<h3 id=\"菊花链模式\">菊花链模式</h3>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819075542602.png\" alt=\"image-20210819075542602\" style=\"zoom:67%;\" /></p>\n<div style=\"font-weight: 900; text-align: center;\">\n图7. 多从机SPI菊花链配置\n</div>\n<p>在菊花链模式下，所有从机的片选信号连接在一起，数据从一个从机传播到下一个从机。在此配置中，所有从机同时接收同一SPI时钟。来自主机的数据直接送到第一个从机，该从机将数据提供给下一个从机，依此类推。</p>\n<p><mark style=\"font-weight: 900;\">使用该方法时，由于数据是从一个从机传播到下一个从机，所以传输数据所需的时钟周期数与菊花链中的从机位置成比例（成比例倍增）。</mark></p>\n<p>例如在图7所示的8位系统中，<mark>为使第3个从机能够获得数据，需要24个时钟脉冲，而常规SPI模式下只需8个时钟脉冲</mark>。图8显示了时钟周期和通过菊花链的数据传播。并非所有SPI器件都支持菊花链模式。请参阅产品数据手册以确认菊花链是否可用。</p>\n<p><img src=\"https://www.analog.com/-/media/images/analog-dialogue/en/volume-52/number-3/articles/introduction-to-spi-interface/205973_fig_08.png?la=en&vs=1\" alt=\"图8. 菊花链配置：数据传播\" style=\"zoom: 50%;\" /></p>\n<div style=\"font-weight: 900; text-align: center;\">\n图8. 菊花链配置：数据传播\n</div>\n<h1 id=\"adi公司支持spi的模拟开关与多路转换器\">ADI公司支持SPI的模拟开关与多路转换器</h1>\n<p>ADI公司最新一代支持SPI的开关可在不影响精密开关性能的情况下显著节省空间。本文的这一部分将讨论一个案例研究，说明支持SPI的开关或多路复用器如何能够大大简化系统级设计并减少所需的GPIO数量。</p>\n<p><a href=\"https://www.analog.com/cn/products/adg1412.html\">ADG1412</a> 是一款四通道、单刀单掷(SPST)开关，需要四个GPIO连接到每个开关的控制输入。图9显示了微控制器和一个ADG1412之间的连接。</p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819075642098.png\" alt=\"image-20210819075642098\" style=\"zoom: 80%;\" /></p>\n<div style=\"font-weight: 900; text-align: center;\">\n图9. 微控制器GPIO用作开关的控制信号\n</div>\n<p>随着电路板上开关数量的增加，所需GPIO的数量也会显著增加。例如，当设计一个测试仪器系统时，会使用大量开关来增加系统中的通道数。在4×4交叉点矩阵配置中，使用四个ADG1412。此系统需要16个GPIO，限制了标准微控制器中的可用GPIO。图10显示了使用微控制器的16个GPIO连接四个ADG1412。</p>\n<p><img src=\"https://www.analog.com/-/media/images/analog-dialogue/en/volume-52/number-3/articles/introduction-to-spi-interface/205973_fig_10.png?la=en&vs=1\" alt=\"图10. 在多从机配置中，所需GPIO的数量大幅增加\" style=\"zoom:50%;\" /></p>\n<div style=\"font-weight: 900; text-align: center;\">\n图10. 在多从机配置中，所需GPIO的数量大幅增加\n</div>\n<p>为了减少GPIO数量，一种方法是使用串行转并行转换器，如图11所示。该器件输出的并行信号可连接到开关控制输入，器件可通过串行接口SPI配置。此方法的缺点是外加器件会导致物料清单增加。</p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819075735043.png\" alt=\"image-20210819075735043\" style=\"zoom:67%;\" /></p>\n<div style=\"font-weight: 900; text-align: center;\">\n图11. 使用串行转并行转换器的多从机开关\n</div>\n<p>另一种方法是使用SPI控制的开关。此方法的优点是可减少所需GPIO的数量，并且还能消除外加串行转并行转换器的开销。如图12所示，不需要16个微控制器GPIO，只需要7个微控制器GPIO就可以向4个ADGS1412提供SPI信号。</p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819080000988.png\" alt=\"image-20210819080000988\" style=\"zoom: 67%;\" /></p>\n<div style=\"font-weight: 900; text-align: center;\">\n图12. 支持SPI的开关节省微控制器GPIO\n</div>\n<p>开关可采用菊花链配置，以进一步优化GPIO数量。在菊花链配置中，无论系统使用多少开关，都只使用主机（微控制器）的四个GPIO。</p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819080021307.png\" alt=\"image-20210819080021307\" style=\"zoom:67%;\" /></p>\n<div style=\"font-weight: 900; text-align: center;\">\n图13. 菊花链配置的SPI开关可进一步优化GPIO\n</div>\n<p>图13用于说明目的。ADGS1412数据手册建议在SDO引脚上使用一个上拉电阻。有关菊花链模式的更多信息，请参阅ADGS1412数据手册。为简单起见，此示例使用了四个开关。随着系统中开关数量的增加，电路板简单和节省空间的优点很重要。在6层电路板上放置8个四通道SPST开关，采用4×8交叉点配置时，ADI公司支持SPI的开关可节省20%的总电路板空间。文章《<a href=\"https://www.analog.com/cn/analog-dialogue/articles/precision-spi-switch-configuration-increases-channel-density.html\">精密SPI开关配置提高通道密度</a>》详细说明了精密SPI开关配置如何提高通道密度。</p>\n<h1 id=\"术语\">术语</h1>\n<p><strong>MISO</strong> / <strong>SOMI</strong> / <strong>SDO</strong>： Master Input and Slaver Output / Slaver Output and Master Input / Slaver Data Output</p>\n<p><strong>MOSI</strong> / <strong>SIMO</strong> / <strong>SDI</strong>： Master Output and Slaver Input / Salver Input and Master Output / Slaver Data Input</p>\n<p><strong>SCLK</strong>： Serial Clock</p>\n<p><strong>CS</strong> / <strong>STE</strong>： Chip Select / Slaver Transmit Enable</p>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li><a href=\"https://www.analog.com/cn/analog-dialogue/articles/introduction-to-spi-interface.html\">SPI接口简介</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/150121520\">SPI通信协议详解（spi总线）</a></li>\n<li><a href=\"http://www.microchip.com.cn/community/Uploads/Download/Library/39699a_cn.pdf\">第23 章 串行外设接口(SPI)</a></li>\n</ol>\n","categories":["Communication"],"tags":["SPI"]},{"title":"UART通信","url":"/2021/09/10/Communication/2021-09-10-UART%E9%80%9A%E4%BF%A1/","content":"<h1 id=\"rs-serial-port\">RS Serial Port</h1>\n<p>RS系列（RS-232/RS-422/RS-485）标准（RS，即Recommend Standard，<strong>推荐标准</strong> 之意 ）是常用的（异步）串行通信接口标准，该系列标准由美国电子工业协会（EIA）牵头开发。</p>\n<p>RS系列标准只对 <strong>接口</strong> 的 <strong>电气特性</strong>（Electric Specification of Interface）进行规定，并不涉及插件、电缆或协议，再次基础上，用户可以建立自己的接头、插座形状 以及 高层通信协议 。</p>\n<h2 id=\"rs-232\">RS-232</h2>\n<p>RS-232标准接口（又称EIA RS-232）是由美国电子工业协会(EIA)联合贝尔系统公司、调制解调器厂家及计算机终端生产厂家于1970年共同制定，其全名是“数据终端设备( DTE)和数据通信设备(DCE)之间串行二进制数据交换接口技术标准”。</p>\n<p>RS232协议 和 TTL协议更多是电气特性（如电平标准和电压），二者在软件协议层面是一样的，如对于同样传输 <code>0b01010101</code> 来说，RS232 和 TTL的时序对比如下图所示：</p>\n<p><img src=\"https://pic.islet.space/2021/09/20210915110402.png\" alt=\"img\" style=\"zoom:67%;\" /></p>\n<div style=\"font-size: 0.8rem; text-align: center; font-weight: 900;\">\n图 RS232标准和TTL标准的时序对比\n</div>\n<p>当然，RS232和TTL/CMOS之间的转换，不仅仅是简单的电平转换，还要考虑到其他一些因素，比如 <strong>调节</strong> 和 <strong>矫正</strong> 一些电平（提高或降低对应的电平），确保可能的有害的RS232电压不会破坏微控制器的串口针脚。较为成熟的方案是通过MAX3232之类的芯片，把TTL电平转为RS232电平，或者在淘宝购买TTL转RS232电缆即可。</p>\n<p>由于RS-232采取 <strong>不平衡传输</strong> 方式，即所谓 <strong>单端通讯</strong>。收（RX）、发（TX） 端的数据信号是相对于信号地（GND）。典型的RS-232信号在正负电平之间摆动，</p>\n<ul>\n<li>在发送数据时，发送端驱动器输出正电平在+5<sub>+15V，负电平在-5</sub>-15V电平。</li>\n<li>当无数据传输时，线上为TTL，从开始传送数据到结束，线上电平从TTL电平到RS-232电平再返回TTL电平。</li>\n</ul>\n<p>接收器典型的工作电平在 <code>+3~+12V</code> 与 <code>-3~-12V</code> 。<mark>由于发送电平与接收电平的差仅为2V至3V左右，所以其共模抑制能力差</mark>，再加上双绞线上的分布电容，其传送距离最大为约15米，最高速率为20Kbps。RS-232是为 <strong>单节点通讯</strong>（即点对点，用一对收、发设备）而设计的，其驱动器负载为3kΩ~7kΩ。所以RS-232适合本地设备之间的通信。</p>\n<h2 id=\"rs-422\">RS-422</h2>\n<p>RS-422、RS-485与RS-232不一样，数据信号采用差分传输方式，也称作 <strong>平衡传输</strong>，它使用一对双绞线，将其中一线定义为A，另一线定义为B。通常情况下，发送驱动器A、B之间的正电平在+2<sub>+6V，是一个逻辑状态，负电平在-2V</sub>6V，是另一个逻辑状态。另有一个信号地C，在RS-485中还有一“使能”端，而在RS-422中这是可用可不用的。“使能”端是用于控制发送驱动器与传输线的切断与连接。当“使能”端起作用时，发送驱动器处于高阻状态，称作“第三态”，即它是有别于逻辑“1”与“0”的第三态。</p>\n<p>由于接收器采用高输入阻抗和发送驱动器比RS232更强的驱动能力，故允许在相同传输线上连接多个接收节点，<strong>最多可接10个节点</strong>。即一个主设备（Master），其余为从设备（Salve），从设备之间不能通信，所以RS-422支持点对多的双向通信。RS-422四线接口由于采用单独的发送和接收通道，因此不必控制数据方向，各装置之间任何必须的信号交换均可以按软件方式（XON/XOFF握手）或硬件方式（一对单独的双绞线）实现。RS-422的最大传输距离为4000英尺（约1219米），最大传输速率为10Mbps。其平衡双绞线的长度与传输速率成反比，在100Kbps速率以下，才可能达到最大传输距离。只有在很短的距离下才能获得最高速率传输。一般100米长的双绞线上所能获得的最大传输速率仅为1Mbps。RS-422需要一终接电阻，要求其阻值约等于传输电缆的特性阻抗。在矩距离传输时可不需终接电阻，即一般在300米以下不需终接电阻。终接电阻接在传输电缆的最远端。</p>\n<h2 id=\"rs-485\">RS-485</h2>\n<p>RS-485 标准只对 <strong>接口</strong> 的 <strong>电气特性</strong>（Electric Specification of Interface）进行规定，并不涉及插件、电缆或协议，再次基础上，用户可以建立自己的接头、插座形状 以及 高层通信协议 。</p>\n<p>RS-485 的 <strong>通信距离</strong> 和 <strong>通信速率</strong> 是负相关的，</p>\n<p>RS485有 <strong>两线制</strong> 和 <strong>四线制</strong>，四线制只能实现点对点的通信方式，现很少采用。</p>\n<h2 id=\"接口标准对比\">接口（标准）对比</h2>\n<p>以下仅从RS的硬件要求进行横向对比：</p>\n<div style=\"font-size: 0.8rem; text-align: center; font-weight: 900;\">\n表 RS系列标准对比\n</div>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>RS-232</th>\n<th>RS-422</th>\n<th>RS-485</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>半双工/全双工</td>\n<td>全双工</td>\n<td>全双工</td>\n<td>半双工</td>\n</tr>\n<tr class=\"even\">\n<td>波特率</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>传输速率范围</td>\n<td>300bps~100Kbps</td>\n<td>10Mbps</td>\n<td>10Mbps</td>\n</tr>\n<tr class=\"even\">\n<td>联网支持（多设备连接）</td>\n<td>不支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr class=\"odd\">\n<td>电压范围</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>差模/共模</td>\n<td>共模</td>\n<td>差模</td>\n<td>差模</td>\n</tr>\n<tr class=\"odd\">\n<td>最少信号线数量</td>\n<td>3根</td>\n<td>5根</td>\n<td>2根</td>\n</tr>\n<tr class=\"even\">\n<td>最大传输距离</td>\n<td>15m（波特率=9600时）</td>\n<td></td>\n<td>3900m</td>\n</tr>\n<tr class=\"odd\">\n<td>控制信号（DE，Drive Enable）</td>\n<td>无</td>\n<td>可选</td>\n<td>有</td>\n</tr>\n<tr class=\"even\">\n<td>输入阻抗</td>\n<td>3～7kΩ</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>使用RS422协议的设备间的引脚互相连接示意图：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/20210915110408.png\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<h1 id=\"uart-protocol\">UART Protocol</h1>\n<p><strong>UART</strong>，即Universal Asynchronous Receiver/Transmitter，<strong>通用异步收发</strong>。</p>\n<p>在通信和计算机科学中，Serial communication是一个通用概念，泛指所有的串行的通信协议，如RS232、USB、I2C、SPI、1-Wire、Ethernet等。这里的串行（serial），是相对并行通信（parallel communication）来说的，如下图：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/20210915110411.jpeg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>广义上讲，UART是指 支持RS系列（物理接口）标准和TLL电平 的 <strong>通信协议</strong>。</p>\n<p>因为UART更多关注规定编码格式的标准，如 <strong>波特率</strong>（baud rate）、<strong>帧格式</strong> 和 <strong>波特率误差</strong> 等等，所以了解UART时，不可避免需要先在电气特性上区分几个常用的概念，如 <strong>TLL电平</strong> 和 <strong>CMOS电平</strong>。</p>\n<blockquote>\n<p>TTL集成电路的主要型式为晶体管-晶体管逻辑门(transistor-transistor logic gate)，TTL大部分都采用5V电源。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>TTL电平（参考值）</th>\n<th>CMOS电平（参考值）</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>输入高电平</td>\n<td>≥ 2.4V</td>\n<td>≈ 0.7*VCC</td>\n</tr>\n<tr class=\"even\">\n<td>输入低电平</td>\n<td>≤ 0.4V</td>\n<td>≈ 0.3*VCC</td>\n</tr>\n<tr class=\"odd\">\n<td>输出高电平</td>\n<td>≥ 2.0V</td>\n<td>≈ VCC 或 ＜0.9*VCC</td>\n</tr>\n<tr class=\"even\">\n<td>输出低电平</td>\n<td>≤ 0.8V</td>\n<td>≈ GND 或 &lt; 0.1*VCC</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注</strong>：VCC的概念可以参考文章《<a href=\"https://islet.space/2021/07/10/Hardware/Circuit/2021-07-10-VCC%E3%80%81VDD%E3%80%81VEE%E3%80%81VSS%E7%9A%84%E5%8C%BA%E5%88%AB/\">VCC、VDD、VEE、VSS的区别</a>》，具体输入输出的高低电平范围需要参考芯片及电路的手册。</p>\n</blockquote>\n<h1 id=\"接口\">接口</h1>\n<p>以下介绍均为UART常用的物理接口。</p>\n<p><strong>D型数据接口连接器</strong>，用于连接电子设备（比如：计算机与外设）的接口标准。因形状类似于英文字母D，故得名D型接口。</p>\n<p>按照接口数量细分为A型（15针），B型（25针），C型（37针），D型（50针），E型（9针）。因此常见的计算机并口即为DB25针的连接器。而串口则应为DE9针连接器。</p>\n<p>由于早期的计算机的串口与并口都是使用DB25针连接器，而人们则习惯把字母B与D合在一起记了下来，当作D型接口的共同名字，以至于后来计算机串口改用9针接口以后，人们更多的使用DB9而不是DE9来称呼9针的接口。这一习惯进一步推广的结果就是如今人们使用DBxx来代表D型接口，数字xx则为接口的针数。</p>\n<h2 id=\"db9\">DB9</h2>\n<p>COM口是指针对串行通信协议的一种端口，是PC上异步串行通信口的简写，大部分为9针孔D型。</p>\n<p>因此 <strong>DB9</strong> 就和 <strong>COM口</strong> 混用了，但是COM口里又进一步区分RS232，RS422和RS485，传输功能依次递增。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/20210915110415.png\" alt=\"image-20210915103057209\" /><figcaption aria-hidden=\"true\">image-20210915103057209</figcaption>\n</figure>\n<div style=\"font-size: 0.8rem; text-align: center; font-weight: 900;\">\n图 DB9/COM口在各RS标准下的引脚使用和定义\n</div>\n<p>但由于历史原因，IBM的PC外部接口配置为RS232，成为实际上的PC界默认标准。所以，<strong>现在PC机的COM口的物理标准均为RS232</strong>。DB9/COM口的公头和母头实际外观如下：</p>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/09/image-20210915093214837.png\" alt=\"image-20210915093214837\" style=\"zoom:80%;\" /><img src=\"https://pic.islet.space/2021/09/image-20210915104612002.png\" alt=\"image-20210915104612002\" style=\"zoom:70%;\" />\n</div>\n<div style=\"font-size: 0.8rem; text-align: center; font-weight: 900;\">\n图 DB9/COM口的公头（左）和母头（右）外观\n</div>\n<h2 id=\"端子\">端子</h2>\n<p>端子，Terminal，也称为 <strong>接线终端</strong> / <strong>接线端子</strong>。</p>\n<p>种类分单孔，双孔，插口，挂钩等，从材料分，铜镀银，铜镀锌，铜，铝，铁等。它们的作用主要传递电信号或导电用。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/20210915212912.jpeg\" alt=\"端子排型号\" /><figcaption aria-hidden=\"true\">端子排型号</figcaption>\n</figure>\n<h1 id=\"转换器\">转换器</h1>\n<h2 id=\"usb转ttl\">USB转TTL</h2>\n<p>常见的USB转TTL的芯片，如CP2101 / CP2102 / CH340 / CH341 / FT232BM / FT232RL / PL2303 / PV8651等，尤其CH340和CP2102 的转换器最为常见。</p>\n<p><img src=\"https://pic.islet.space/2021/09/20210915113927.png\" alt=\"image-20210915113729086\" style=\"zoom:50%;\" /></p>\n<div style=\"font-size: 0.8rem; text-align: center; font-weight: 900;\">\n图 USB转TTL（CH340G芯片）转换器\n</div>\n<p><img src=\"https://pic.islet.space/2021/09/20210915210459.png\" alt=\"image-20210915114016213\" style=\"zoom:67%;\" /></p>\n<div style=\"font-size: 0.8rem; text-align: center; font-weight: 900;\">\n图 USB转TTL（FT232芯片）转换器\n</div>\n<h2 id=\"usb转db9rs232\">USB转DB9(RS232)</h2>\n<p><img src=\"https://pic.islet.space/2021/09/20210915110421.png\" alt=\"image-20210915095451523\" style=\"zoom:67%;\" /></p>\n<div style=\"font-size: 0.8rem; text-align: center; font-weight: 900;\">\n图 USB转DB9数据线\n</div>\n<h2 id=\"rj45和db9\">RJ45和DB9</h2>\n<p>这种转换器通常用在交换器和路由器的调试工作上，</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/20210915110424.png\" alt=\"image-20210915105657103\" /><figcaption aria-hidden=\"true\">image-20210915105657103</figcaption>\n</figure>\n<div style=\"font-size: 0.8rem; text-align: center; font-weight: 900;\">\n图 RJ45母 转 DB9公\n</div>\n<p><img src=\"https://pic.islet.space/2021/09/20210915110427.png\" alt=\"image-20210915105821577\" style=\"zoom:67%;\" /></p>\n<div style=\"font-size: 0.8rem; text-align: center; font-weight: 900;\">\n图 RJ45公 转 DB9母\n</div>\n<h2 id=\"rj45转端子\">RJ45转端子</h2>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/09/20210915112733.jpeg\" alt=\"img\" style=\"zoom:100%;\" /><img src=\"https://pic.islet.space/2021/09/20210915112736.jpeg\" alt=\"img\" style=\"zoom:100%;\" /><img src=\"https://pic.islet.space/2021/09/20210915112738.jpeg\" alt=\"img\" style=\"zoom:100%;\" />\n</div>\n<div style=\"font-size: 0.8rem; text-align: center; font-weight: 900;\">\n图 RJ45公 转 2/3/4引脚端子\n</div>\n<h2 id=\"rs-232转rs-485\">RS-232转RS-485</h2>\n<p>目前主流的家用台式机上已经逐渐取消DB9接口，在某些旧台式电脑主机或者商用台式电脑主机上可能仍有DB9端口可以适配 RS-232（DB9公/母）/RS-485（端子） 转换器，然后再利用一根双绞线（可以用网线制作）连接转换器的 <code>A+</code> / <code>B-</code> 端子 和 通信设备。如下图所示：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/20210915210514.png\" alt=\"image-20210915091142748\" /><figcaption aria-hidden=\"true\">image-20210915091142748</figcaption>\n</figure>\n<div style=\"font-size: 0.8rem; text-align: center; font-weight: 900;\">\n图 DB9公（RS232）转3引脚端子(RS485)\n</div>\n<p>由于该转换器为电气隔离设计，<mark>需要使用独立的VCC/GND/T/R来进行供电，因此不能只连接两根信号线。</mark></p>\n<p>该类转换器同样按照DB9接口的公/母来区分引脚/信号定义，下表为深圳市宇泰科技出品的UT-2201转换器说明书中的内容：</p>\n<p><img src=\"https://pic.islet.space/2021/09/20210915210523.png\" alt=\"image-20210915142023932\" style=\"zoom:67%;\" /></p>\n<p>下图为RS485和转换器之间的连接示意，转换器和单点之间的连接：</p>\n<p><img src=\"https://pic.islet.space/2021/09/20210915210526.png\" alt=\"image-20210915141402305\" style=\"zoom:50%;\" /></p>\n<p>转换器和多点的连接：</p>\n<p><img src=\"https://pic.islet.space/2021/09/20210915210528.png\" alt=\"image-20210915141728889\" style=\"zoom:50%;\" /></p>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li>《串行通信技术 面向嵌入式系统开发》 周云波 著 中国工信出版集团 电子工业出版社</li>\n<li><a href=\"http://www.farnell.com/datasheets/2254540.pdf\">《ANALOG DEVICE-5 V Low PowerEIA RS-485 Transceiver》</a></li>\n<li><a href=\"https://www.ti.com/lit/an/slla036d/slla036d.pdf\">《InterfaceCircuitsforTIA/EIA-485(RS-485)》</a></li>\n<li><a href=\"https://item.taobao.com/item.htm?id=546418892634\">聚英JY-CON503 RS232转RS485/RS422 宽压DC7-30V供电 全隔离设计</a></li>\n<li><a href=\"https://www.cnblogs.com/yeshenmeng/p/10729070.html\">DB9针和DB25针串口的引脚定义</a></li>\n<li><a href=\"http://www.360doc.com/content/20/0803/20/44130189_928354146.shtml\">为什么越来越多人使用RS232接口，却还分不清DB9、DB25的引脚定义？</a></li>\n<li><a href=\"https://baike.baidu.com/item/RS-232/2022036?fromtitle=rs232&amp;fromid=3555506&amp;fr=aladdin\">RS-232</a></li>\n<li><a href=\"https://baike.baidu.com/item/DB9/1360191?fr=aladdin\">DB9</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/89240672\">串口、COM口、UART口, TTL、RS-232、RS-485区别详解</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25893717\">UART、RS232、TTL关系浅析</a></li>\n<li><a href=\"https://blog.csdn.net/shuziluoji1988/article/details/22413497\">RS232、RS422、RS485、TTL电平</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/66241216\">一文搞懂Modbus与RS485通信协议</a></li>\n</ol>\n","categories":["Communication"],"tags":["serial","Communication"]},{"title":"无线通信网络","url":"/2021/09/20/Communication/2021-09-20-%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C/","content":"<h1 id=\"前置知识\">前置知识</h1>\n<ul>\n<li>带宽及传输速率转换</li>\n<li>TCP/IP网络协议</li>\n<li>硬件功耗计算和测量</li>\n</ul>\n<h1 id=\"概述\">概述</h1>\n<p>将从通信速率、通信距离、通信功耗、组网能力/网路容量、 应用场景 及 安全性 等各方面来区分无线通信各种技术。</p>\n<h2 id=\"通信距离和通信速率\">通信距离和通信速率</h2>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>超近距离<br>10公分以内</th>\n<th>近距离<br>1米以内</th>\n<th>近距离<br>20米以内</th>\n<th>中距离<br>20至100米</th>\n<th>远距离<br>1公里以内</th>\n<th>超远距离<br>1公里以上</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong>超高速率</strong><br>&gt; 100Mbps</td>\n<td></td>\n<td>RFID</td>\n<td>WiFi</td>\n<td></td>\n<td>5G</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td><strong>高速率</strong><br>&lt; 100Mbps</td>\n<td></td>\n<td>RFID</td>\n<td>WiFi</td>\n<td></td>\n<td>3G/4G</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td><strong>中速率</strong><br>&lt; 10Mbps</td>\n<td></td>\n<td></td>\n<td>WiFi<br>Bluethooth</td>\n<td>Bluethooth</td>\n<td>CMDA2K1X<br>2G</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td><strong>低速率</strong><br>&lt; 1Mbps</td>\n<td>NFC</td>\n<td></td>\n<td></td>\n<td>ZigBee<br>Z-Ware</td>\n<td>《IEEE 802.11 ah》</td>\n<td>Lora<br>NB-IOT（基于MTC）<br>GPRS</td>\n</tr>\n<tr class=\"odd\">\n<td><strong>超低速率</strong><br>&lt; 1Kbps</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>Sigfox</td>\n</tr>\n</tbody>\n</table>\n<p>还有很多躺在历史垃圾堆角落里，没有得到使用和普及的通信协议，如 WiMax（IEEE 802.16），</p>\n<h2 id=\"通信功耗\">通信功耗</h2>\n<p><strong>超高功耗</strong>：&gt; 100mA</p>\n<p><strong>高功耗</strong>：30~100mA</p>\n<p><strong>中功耗</strong>：&lt; 30mA</p>\n<p><strong>低功耗</strong>：&lt; 20mA</p>\n<p><strong>超低功耗</strong>：&lt; 10mA</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>超低功耗</th>\n<th>低功耗</th>\n<th>中功耗</th>\n<th>高功耗</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"组网能力网路容量\">组网能力/网路容量</h2>\n<h2 id=\"应用场景\">应用场景</h2>\n<h2 id=\"lpwanlpwa\">LPWAN/LPWA</h2>\n<p><strong>LPWAN</strong>， Low Power Wide Area Network，低功耗广域网络，也可以缩写为LPWA。</p>\n<p>LPWAN 不是指任何一种特定技术，而是作为任何网络的通用术语，这些网络旨在以比其他网络（如蜂窝、卫星或 WiFi）更低的功率进行无线通信。此外，与其他使用蓝牙或 NFC 的低功耗网络相比，LPWAN 的通信距离更远。</p>\n<p>LPWA 网络非常有限的带宽不适合大多数消费者和商业应用，例如语音、视频、音频甚至文本消息。因此，LPWA 网络几乎完全由物联网 (IoT) 和 M2M（机器对机器）通信中的设备使用。</p>\n<p>虽然冰箱、灯泡或 Nest 温度计等家用或商用设备都可以轻松搭载家庭或办公室 WiFi 连接，但某些设备不能依赖这种连接。</p>\n<p>LoRa、SigFox、NB-IoT 都属于 LPWA 的范畴，LoRa 不需要 SIM 卡，NB-IoT 需要 SIM 卡。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210920171429124.png\" alt=\"image-20210920171429124\" /><figcaption aria-hidden=\"true\">image-20210920171429124</figcaption>\n</figure>\n<h1 id=\"lora\">LoRa</h1>\n<p>LoRa是美国Semtech公司的专有技术，实际是一种采用扩频方案的无线调制解调技术。Semtech在2012年通过并购法国Cycleo公司获得LoRa的IP产权，以此设计制造射频芯片并进行市场销售，是一家纯半导体公司，垄断LoRa芯片的供货。目前Semtech虽然也进行少量LoRa的IP授权，如国内的阿里，但IP是Semtech专有，没有授权任何公司无法设计制造LoRa芯片，所以客户的选择余地很小。</p>\n<p>LoRa使用的也是公共频段进行射频信号传输，上层协议及规范由LoRaWan定义，LoRa联盟负责发布和维护。任何人可以购买LoRa芯片或者模块来设计LoRa终端和网关设备，也可以设计或者购买设备来搭建LoRa网络，所以目前多数的LoRa网络都是小区域和私有的，很少有全国性的通用物联网络，而设备和网络间的兼容也是一个很大的挑战。</p>\n<p>LoRa通过扩频技术实现高灵敏度，从而能够进行远距离传输，但是网络容量有限，无法高效实现大批量设备信息的并行接收和处理，这对于大面积或全国性的部署是个巨大挑战。</p>\n<h1 id=\"术语\">术语</h1>\n<h2 id=\"link-budget\">Link Budget</h2>\n<p>A link budget is used to compute cell coverage by accounting for all the factors that determine the cell coverage to balance the system cost against the required cell capacity. Link budget factors controlled by the RF engineer include transmitter-radiated power, antenna gain, noise figures, and co-channel interference (i.e., reuse factor <em>N</em>). Factors that cannot be controlled directly, but must be considered in the link budget, include propagation path loss and system bandwidth.</p>\n<p>链路预算是用来计算小区覆盖率的，它考虑了决定小区覆盖率的所有因素，以平衡系统成本和所需小区容量。由射频工程师控制的链路预算因素包括发射器辐射功率、天线增益、噪声数字和同信道干扰（即重用系数N）。不能直接控制，但必须在链路预算中考虑的因素包括传播路径损耗和系统带宽。</p>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li>《无线传感网络》杨博雄/倪玉华</li>\n<li><a href=\"http://www.elecfans.com/iot/631444_a.html\">物联网通信标准分类 谁最有优势？</a></li>\n<li><a href=\"https://www.zhihu.com/question/19687054/answer/632679689\">为什么WIMAX没有普及？</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/79948173\">什么是LPWA</a></li>\n<li><a href=\"https://www.hisilicon.com/cn/techtalk/nb-iot\">NB-IoT 通往智能世界的基础联接技术</a></li>\n<li><a href=\"https://www.sciencedirect.com/topics/engineering/link-budget\">Link Budget - an overview | ScienceDirect Topics</a></li>\n<li><a href=\"https://cloud.tencent.com/product/lpwa\">LPWA 物联网络</a></li>\n</ol>\n","categories":["Communication"],"tags":["Lora","Wireless"]},{"title":"计算机网络体系结构与现场总线","url":"/2021/10/02/Communication/2021-10-02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%8E%B0%E5%9C%BA%E6%80%BB%E7%BA%BF/","content":"<h1 id=\"计算机网络体系结构\">计算机网络体系结构</h1>\n<p>计算机网络是计算机技术和通信技术相结合的技术领域。由若干计算机用通信信道连接至一起，互相交换信息共享资源，形成计算机网络。</p>\n<h2 id=\"osi-五层模型\">OSI 五层模型</h2>\n<p>在国际标准化组织（ISO）提出 <strong>开放系统互联</strong>（OSI，Open System Interconnection）参考模型中，网络系统结构划分为7层。</p>\n<p>该OSI模型由上至下分别是 <strong>应用层</strong>、<strong>表示层</strong>、<strong>会话层</strong>、<strong>传输层</strong>、<strong>网络层</strong>、<strong>数据链路层</strong> 和 <strong>物理层</strong>。</p>\n<p><img src=\"https://pic.islet.space/2021/10/17849411-6cad6d1b0aafdd22.png\" alt=\"img\" style=\"zoom:67%;\" /></p>\n<p>在本模型中，<strong>物理层</strong>、<strong>数据链路层</strong> 和 <strong>网络层</strong> 是 <strong>面向网络通信</strong> 的层级；<strong>会话层</strong>、<strong>表示层</strong> 和 <strong>应用层</strong> 是 <strong>面向信息处理</strong> 的层级。</p>\n<h3 id=\"应用层\">应用层</h3>\n<p><strong>应用层</strong>，即Application Layer。OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。</p>\n<blockquote>\n<p>实际公司A的老板就是我们所述的用户，而他要发送的商业报价单，就是应用层提供的一种网络服务，当然，老板也可以选择其他服务，比如说，发一份商业合同，发一份询价单，等等。</p>\n</blockquote>\n<p>OSI七层模型中，除了应用层以外，其他功能层级都与用户实际应用没有什么直接联系，能够直接为用户提供各种应用服务的是应用层。应用层可以包含各种应用程序，有些由于使用普遍而实行了标准化，进而形成了应用层上的各种应用协议，诸如SMTP、POP3、WWW、TELNET、FTP、HTTP、HTTPS等。</p>\n<h3 id=\"表示层\">表示层</h3>\n<p><strong>表示层</strong>，即 Presentation Layer。其提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p>\n<blockquote>\n<p>由于公司A和公司B是不同国家的公司，他们之间的商定统一用英语作为交流的语言，所以此时表示层（公司的文秘），就是将应用层的传递信息转翻译成英语。同时为了防止别的公司看到，公司A的人也会对这份报价单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等。</p>\n</blockquote>\n<h3 id=\"会话层\">会话层</h3>\n<p><strong>会话层</strong>，即 Section Layer。负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</p>\n<blockquote>\n<p>会话层的同事拿到表示层的同事转换后资料，（会话层的同事类似公司的外联部），会话层的同事那里可能会掌握本公司与其他好多公司的联系方式，这里公司就是实际传递过程中的实体。他们要管理本公司与外界好多公司的联系会话。当接收到表示层的数据后，会话层将会建立并记录本次会话，他首先要找到公司B的地址信息，然后将整份资料放进信封，并写上地址和联系方式。准备将资料寄出。等到确定公司B接收到此份报价单后，此次会话就算结束了，外联部的同事就会终止此次会话。</p>\n</blockquote>\n<h3 id=\"传输层\">传输层</h3>\n<p><strong>传输层</strong>，即 Transport Layer。负责建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括 <strong>处理差错控制</strong> 和 <strong>流量控制</strong> 等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP/UDP就是在这一层。端口号既是这里的“端”。</p>\n<blockquote>\n<p>传输层就相当于公司中的负责快递邮件收发的人，公司自己的投递员，他们负责将上一层的要寄出的资料投递到快递公司或邮局。</p>\n</blockquote>\n<p>传输层位于第三层和高三层之间，也是 <strong>面向网路通信</strong> 和 <strong>面向信息处理</strong> 之间的重要层级，是整个协议层次的核心。</p>\n<p>传输层的任务是为高层从源端机到目的机提供可靠、经济的数据传输服务，而与具体网络无关。</p>\n<p>为了向用户提供经济有效的服务，传输层还提供多路复用和分流的功能。</p>\n<h3 id=\"网络层\">网络层</h3>\n<p><strong>网络层</strong>，即 Network Layer。负责通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</p>\n<blockquote>\n<p>网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说，从深圳发往北京的顺丰快递（陆运为例啊，空运好像直接就飞到北京了），首先要到顺丰的深圳集散中心，从深圳集散中心再送到武汉集散中心，从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点。</p>\n</blockquote>\n<h3 id=\"数据链路层\">数据链路层</h3>\n<p><strong>数据链路层</strong>，即 Data Linker Layer。负责将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。</p>\n<p>这个没找到合适的例子</p>\n<p>在物理线路上，由于噪声干扰、信号衰减畸变等原因，传输过程中常常出现差错，物理层只负责透明传输无结构的原始比特流，不能进行任何差错控制。</p>\n<p>因此，在一条线路上传输数据时，除了必须有一条物理线路外，还需要必要规程来控制数据传输。把这些规程的软件/硬件加到链路上，就构成了数据链路层（Data Linker Layer）。</p>\n<p><strong>作用</strong>：通过一系列数据链路层协议，在不可靠的物理链路上实现可靠的数据传输。</p>\n<p>为此，通常将原始数据分割成一定长度的数据单元（帧），一帧内包含 <strong>同步信号</strong>、<strong>差错控制</strong>、<strong>流量控制</strong>、<strong>控制信息</strong>、<strong>数据信息</strong>、<strong>寻址</strong> 等。</p>\n<h4 id=\"差错控制\">差错控制</h4>\n<p>差错控制涉及两方面的问题，即 <strong>如何检测错误</strong> 和 <strong>如何纠正错误</strong>。</p>\n<p><strong>检查错误</strong>：要判断一个数据块是否存在错误，发送端必须在数据块中加入冗余信息，使得数据块和冗余信息间存在某种关联，接收端通过验证其关联性来判断数据是否出错。<mark>在数据块中加入冗余信息的过程称为 <strong>差错编码</strong>。</mark></p>\n<p>差错编码有两种策略，即 <strong>仅带有检错能力的检错码</strong> 和 <strong>带有纠错能力的检错码/纠错码</strong>。但任何一种检/纠错码的能力都是有限的，即 <strong>不能检/纠出所有的错误</strong>。一般检错码的能力越强，所需的冗余信息就会越多，编码效率会随之降低。</p>\n<p>常见的差错编码有：</p>\n<ol type=\"1\">\n<li><strong>海明码</strong>，即 Hamming Code。由 Richard Hamming 于1950年提出，可纠正一个 bit 错误的编码。</li>\n<li><strong>循环冗余码</strong>，即 Cyclic Redundancy Code，又名 多项式码。最广泛使用的编码，但 <strong>漏检率很低</strong>，只需要简单电路即可实现。</li>\n<li><strong>奇偶校验码</strong>，即 Parity Check Code。 最常见也最简单的编码，只需要一个比特，但只能检出奇数个错误，<strong>漏检率达50%</strong>。</li>\n<li><strong>校验和码</strong>，即 Checksum Code。也是最常见的检错方式，是传输的数据块中 <strong>各字节累加</strong> 后得到的 一个字节 或 按字“异或”运算 的结果。</li>\n</ol>\n<h3 id=\"物理层\">物理层</h3>\n<p><strong>物理层</strong>，即 Physical Layer。实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>\n<blockquote>\n<p>快递寄送过程中的交通工具，就相当于我们的物理层，例如汽车，火车，飞机，船。</p>\n</blockquote>\n<p>其中物理层有几个概念需要了解和区分，包括 <strong>传输速率</strong>、<strong>信道容量</strong>、<strong>传输媒体</strong>、<strong>调制解调</strong>、<strong>交换技术</strong>、<strong>网络拓扑</strong> 和 <strong>多路复用</strong>。</p>\n<h4 id=\"传输速率\">传输速率</h4>\n<p><strong>比特率</strong>：每秒传输的二进制位数。</p>\n<p><strong>波特率</strong>：每秒传输的码元率。</p>\n<p><strong>码元</strong>：单位携带的比特信息量。</p>\n<blockquote>\n<p>如果码元率为1比特，则波特率和比特率数值上相等。</p>\n</blockquote>\n<h4 id=\"信道容量\">信道容量</h4>\n<p>信道容量，即信道能支持的最大数据传输速率，由信道带宽和信噪比决定。</p>\n<h4 id=\"传输媒体\">传输媒体</h4>\n<p>传输媒体，即传输电信号的物理介质。可以是有线、无线、双绞线、同轴电缆 或 光纤 等。</p>\n<h4 id=\"调制解调\">调制解调</h4>\n<p>调制解调，即一种数据转换成适合在信道上传输的某种电信号形式。</p>\n<p>数字信号转换为模拟信号有 <strong>调幅</strong>、<strong>调频</strong>、<strong>调相</strong> 等方式。</p>\n<p>数字信号的信道编码方式有 <strong>单极型脉冲</strong> 和 <strong>双极性脉冲编码</strong> （有归零码 和 不归零码 之分）及 <strong>曼彻斯特编码</strong> 等（信道编码）。</p>\n<h4 id=\"交换技术\">交换技术</h4>\n<p>物理层的交换技术有三种：<strong>电路交换</strong>、<strong>报文交换</strong> 和 <strong>分组交换</strong>。</p>\n<table>\n<colgroup>\n<col style=\"width: 4%\" />\n<col style=\"width: 32%\" />\n<col style=\"width: 32%\" />\n<col style=\"width: 30%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>TYPE</th>\n<th>PRINCIPLE</th>\n<th>ADVANTAGES</th>\n<th>DISADVANTAGES</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>电路交换</td>\n<td>要求通信双方之间建立一条实际的物理通道，并在整个通信过程中 <strong>通路独占</strong>。</td>\n<td>数据在中间环节无停留，传输可靠，实时效应好；</td>\n<td>电路不共享，资源浪费大，同时电路的建立和撤出的时间较长。</td>\n</tr>\n<tr class=\"even\">\n<td>报文交换</td>\n<td>一个 <strong>大报文</strong>（长度无限制的数据块）在通过从源站到目的站之间的中间站时采用 <strong>存储-转发</strong> 方式（有缓冲区）。</td>\n<td>提高线路利用率</td>\n<td>大报文延迟时间长，出错率高。</td>\n</tr>\n<tr class=\"odd\">\n<td>分组交换</td>\n<td>将一个大报文分割成一定长度的信息单元（分组），各单元以此编号，以分组为单位进行 <strong>存储-转发</strong>。</td>\n<td>除了线路共享外，要求中间环节的缓存区减少，也减少了分组在网络中的延迟时间。<br/>由于各分组在网络中可以走不同路径，该并行传输降低了报文的传输时间。分组长度变短同时降低了出错率（发现出错时重发数据所需时间也缩短）。</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"网络拓扑\">网络拓扑</h4>\n<p><strong>网络拓扑</strong>（Network Topology）即网络中节点的互联结构形式，主要分为 <strong>星型结构</strong>、<strong>总线型结构</strong>、<strong>树型结构</strong>、<strong>环型结构</strong> 和 <strong>网型结构</strong>。（网络上很多文章都有 <strong>混合型结构</strong> 这一拓扑类型）</p>\n<p><img src=\"https://pic.islet.space/2021/10/1002_1.jpg\" alt=\"1002_1\" style=\"zoom: 25%;\" /></p>\n<table style=\"width:100%;\">\n<colgroup>\n<col style=\"width: 5%\" />\n<col style=\"width: 30%\" />\n<col style=\"width: 4%\" />\n<col style=\"width: 30%\" />\n<col style=\"width: 30%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>TYPE</th>\n<th>PRINCIPLE</th>\n<th>SWITCHING</th>\n<th>ADVANTAGES</th>\n<th>DISADVANTAGES</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>星型结构</td>\n<td>通过点对点连接至中央节点，任意两点的通信都依赖中央节点。</td>\n<td>电路交换</td>\n<td>任意节点故障都只会影响本站，而不影响全网。</td>\n<td>极大以来中央节点，对中央节点的可靠性和容量要求很高，同时因为需要中央节点连接，耗费大量电缆。</td>\n</tr>\n<tr class=\"even\">\n<td>总线型结构</td>\n<td>采用单一信道作为传输介质，所有站点通过相应硬件结构接到公共信道（总线）上，任意站点发送的信息，所有其他站都能收到。</td>\n<td>分组交换</td>\n<td>所需电缆长度短，布线容易。<br>且总线仅仅是传输信道，无任何处理功能，属于无源器件，可靠性高，增加或减少站点都相对方便。</td>\n<td>由于所有节点共享一条公共信道，当多点同时发送信号时，信号会因相互碰撞而造成传输失败，称之为 <strong>冲突</strong>。<br>系统范围受到限制（传输速率和传输距离相互制约）。<mark>一个站点的故障可能影响整个网络，故障检测需要在各站点上进行。（待考究）</mark></td>\n</tr>\n<tr class=\"odd\">\n<td>树形结构</td>\n<td>由总线型结构演化而来，从树根开始，每一个节点向下都可以由许多分支。</td>\n<td></td>\n<td>故障比较容易隔离和检查。</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>环型结构</td>\n<td>站点和连接站点的点-点链路组成一个闭合环路，每个站点从一条链路上接受数据，然后以相同的速率从另一条链路上发送出去。<br>链路大多数是单方向的，即数据沿一个方向在网上环行。</td>\n<td></td>\n<td>所需介质长度较短，由于链路单方向性，可以用光纤作为传输介质；</td>\n<td>与总线型结构一样存在冲突问题，一个站点故障会引起全网故障。</td>\n</tr>\n<tr class=\"odd\">\n<td>网型结构</td>\n<td>每个站点都有一条或几条链路同其他站点连接。</td>\n<td></td>\n<td>由于站点间存在多条路径，数据传输时可以选择空闲站点或绕开故障点，因而 <strong>网络资源利用较为充分</strong>；<br>但站点或线路故障对网络整体影响较小，<strong>可靠性较高</strong>。</td>\n<td>结构较为复杂，成本较高。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"多路复用技术\">多路复用技术</h4>\n<p>传输媒体的能力（频带宽）往往很强，对传输资源能力的应用（复用）是指将多路信号组合在一条物理信道上进行传输，然后接收端再将各路信号分离开。常见的多路复用技术如 <strong>频分多路复用</strong>（FDM）、<strong>时分多路复用</strong>（TDM） 和 <strong>码分多址</strong>（CDMA）等。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>TYPE</th>\n<th>PRINCIPLE</th>\n<th>ADVANTAGES</th>\n<th>DISADVANTAGES</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>频分多路复用</td>\n<td>将信道带宽按频率分割为若干子信道，每个子信道用来传输一路信号。</td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>时分多路复用</td>\n<td>将使用信道的时间分成一个个时间片，按一定规律将时间片分配给各路信号，每路信号只能在自己的时间片内独占信道进行传输。</td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>码分多址</td>\n<td>允许所有站点在同一时间使用整个信道进行数据传输。</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>以上三类多路复用技术可以形象地比喻为多个人要发言讨论不同问题时，如何使用同一个会议厅（信道）。</p>\n<ul>\n<li><p>可以把会议厅分成几个小厅（好比频分多路复用），各小厅同时进行各自不同的发言，互不干扰；</p></li>\n<li><p>可以在一个厅内让各议题在固定的时间片内轮流发言（好比时分多路复用）；</p></li>\n<li><p>可以在一个厅内让各自议题同时发言，但是要用不同的语言（好比码分多址），对某个议题的人来说只能听懂自己的语言，而其他语言被视为随机噪音，可以排除。</p></li>\n</ul>\n</blockquote>\n<h2 id=\"tcpip-五层模型\">TCP/IP 五层模型</h2>\n<p>实际TCP/IP使用的是5层模型，其中OSI模型中的 应用层、表示层 和 会话层 都用一层 应用层 进行表示，如下图。在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。</p>\n<p><img src=\"https://pic.islet.space/2021/10/202110021438076.webp\" alt=\"img\" style=\"zoom:67%;\" /></p>\n<p>在每一层实现的协议也各不同，即每一层的服务也不同，下图列出了每层主要的协议。</p>\n<p><img src=\"https://pic.islet.space/2021/10/202110021438379.webp\" alt=\"img\" style=\"zoom:67%;\" /></p>\n<h1 id=\"现场总线\">现场总线</h1>\n<p>在工业数据通信领域，<strong>总线</strong> 是指由导线组成的传输线束，连接多个传感器和执行器，实现各部件之间传送信息的公共通信干线。</p>\n<p>然后再来看国际电工技术委员会（IEC）在IEC 61158中对现场总线的标准定义：<mark><strong>现场总线</strong> 是安装在制造或过程区域的现场装置与控制室内的自动控制装置之间的数字式、串行、多点通信的数据总线。</mark></p>\n<p>从定义中可以看到，现场总线是一种数据总线技术，是一种通信协议，且该通信是数字式、串行、多节点的。</p>\n<p>目前，在工控领域，车间现场应用最广泛的是 <strong>工业以太网</strong> 技术和 <strong>工业现场总线</strong> 技术，为工厂实现自动化带来有力推动。</p>\n<p>现场总线应当是应用在生产最底层的一种总线型拓扑网络，即该总线是用于现场控制系统，直接与所有受控（设备）节点串行相连的通信网络。</p>\n<p>工业自动化控制的现场一般可以从一台家电设备到一个车间、一个工厂。控制设备和网络所处的环境以及报文结构都有其特殊性，对信号的干扰往往是多方面的，而要求控制必须实时性很强。</p>\n<h2 id=\"现场总线技术\">现场总线技术</h2>\n<p><strong>现场总线</strong>（Fieldbus）是电气工程及其自动化领域发展起来的一种工业数据总线，它主要解决工业现场的智能化仪器仪表、控制器、执行机构等现场设备间的数字通信以及这些现场控制设备和高级控制系统之间的信息传递问题。由于现场总线简单、可靠、经济实用等一系列突出的优点，因而受到了许多标准团体和计算机厂商的高度重视</p>\n<p>传统控制系统难以实现设备之间 以及 系统与外界之间的信息交换，是一个“信息孤岛”。要满足自动化控制技术现代化的要求，同时实现整个企业的信息集成，实施综合自动化，就必须设计出一种能在工业设备之间的多点数字通信，实现底层现场设备之间以及生产现场与外界的信息交换。</p>\n<p>现场总线控制系统（Field Control System，FCS）既是一个开放通信网络，又是一种全分布控制系统。作为智能设备的联系纽带，把挂接在总线上、作为网络节点的智能设备连接为网络系统，并进一步构成合成系统，实现基本控制、补偿计算、参数修改、报警、显示、监控、优化 及 管控一体化的综合自动化功能。</p>\n<p><mark style=\"font-weight: 900;\">现场总线技术是一项集嵌入式系统、控制、计算机、数字通信、网络为一体的综合技术。</mark></p>\n<h3 id=\"局限性\">局限性</h3>\n<p>也可以说现场总线是工业控制和计算机网络两者的边缘产物。从纯理论的角度看，它应属于网络范畴。但是现有的网络技术不能完全适应工业现场控制系统的要求，无论是从网络的结构、协议、实时性，还是从适应性、灵活性、可靠性 乃至 成本 上进行考虑，工业控制的底层都有它的特殊性。</p>\n<p>现场总线其规模应属于局域网、总线型结构，简单但能满足现场使用需求，所传输信息短小且实时性很强、可靠性高（网络结构层次少，信息帧短小有利于提高实时性和降低受干扰的概率）。然而现场的环境干扰因数众多，有些很强烈且带突发性。</p>\n<h2 id=\"现场总线发展\">现场总线发展</h2>\n<p>一般把50年代前的气动信号控制系统PCS称作 <strong>第一代</strong>，把4～20mA等电动模拟信号控制系统称为 <strong>第二代</strong>，把数字计算机集中式控制系统称为 <strong>第三代</strong>，而把70年代中期以来的集散式分布控制系统DCS称作 <strong>第四代</strong>。</p>\n<p>现场总线控制系统FCS作为新一代控制系统，一方面，突破了DCS系统采用通信专用网络的局限，采用了基于公开化、标准化的解决方案，克服了封闭系统所造成的缺陷；另一方面把DCS的集中与分散相结合的集散系统结构，变成了新型全分布式结构，把控制功能彻底下放到现场。可以说，开放性、分散性与数字通讯是现场总线系统最显著的特征。</p>\n<ul>\n<li>1984年美国Intel公司提出一种 <strong>计算机分布式控制系统-位总线</strong>（BITBUS），它主要是将低速的面向过程的 <strong>输入输出通道与高速的计算机多总线</strong>（MULTIBUS）分离，形成了现场总线的最初概念。</li>\n<li>80年代中期，美国Rosemount 公司开发了一种可寻址的远程传感器（HART）通信协议。采用在4～20mA模拟量叠加了一种频率信号，用双绞线实现数字信号传输。HART协议已是现场总线的雏形。</li>\n<li>1985年由Honeywell和Bailey等大公司发起，成立了World FIP制定了FIP协议。</li>\n<li>1987年，以Siemens，Rosemount，横河等几家著名公司为首也成立了一个专门委员会互操作系统协议（ISP）并制定了PROFIBUS协议。后来美国仪器仪表学会也制定了现场总线标准IEC/ISA SP50。</li>\n<li>随着时间的推移，世界逐渐形成了两个针锋相对的互相竞争的现场总线集团：一个是以Siemens、Rosemount，横河为首的ISP集团；另一个是由Honeywell、Bailey等公司牵头的WorldFIP集团。1994年，两大集团宣布合并，融合成现场总线基金会（Fieldbus Foundation）简称FF。对于现场总线的技术发展和制定标准，基金委员会取得以下共识：共同制定遵循IEC/ISA SP50协议标准；商定现场总线技术发展阶段时间表。</li>\n</ul>\n<h2 id=\"现场总线能力\">现场总线能力</h2>\n<p>部分应用场景或产品开发时，会对现场总线的能力提出如下要求：</p>\n<p><strong>本质安全防爆</strong>：<strong>本质安全</strong> 是指通过设计等手段使生产设备或生产系统本身具有安全性，即使在误操作或发生故障的情况下也不会造成事故的功能。具体包括 <strong>失误—安全</strong>（误操作不会导致事故发生或自动阻止误操作）和 <strong>故障—安全</strong> 功能（设备、工艺发生故障时还能暂时正常工作或自动转变安全状态）。</p>\n<blockquote>\n<p>本质安全型电气设备的防爆原理：通过限制电气设备电路的各种参数，或采取保护措施来限制电路的火花放电能量和热能，使其在正常工作和规定的故障状态下产生的电火花和热效应均不能点燃周围环境的爆炸性混合物，从而实现了电气防爆，这种电气设备的电路本身就具有防爆性能，也就是从“本质”上就是安全的。</p>\n</blockquote>\n<h2 id=\"现场总线分类\">现场总线分类</h2>\n<p>国际上有40多种现场总线，但没有任何一种现场总线能覆盖所有的应用面，按其传输数据的大小可分为3类：</p>\n<ol type=\"1\">\n<li><strong>传感器总线</strong>（sensor bus），属于位传输；</li>\n<li><strong>设备总线</strong>（device bus），属于字节传输；</li>\n<li><strong>现场总线</strong>，属于数据流传输。</li>\n</ol>\n<h3 id=\"ff\">FF</h3>\n<p>FF，即 Foundation Field bus，基金会现场总线。</p>\n<p>是以美国Fisher-Rouse mount公司为首的联合了横河、ABB、西门子、英维斯等80家公司制定的ISP协议和以Honeywell公司为首的联合欧洲等地150余家公司制定的World FIP协议于1994年9月合并的。该总线在过程自动化领域得到了广泛的应用，具有良好的发展前景。</p>\n<p>FF 总线采用国际标准化组织ISO的开放化系统互联OSI的简化模型(1，2，7层)，即物理层、数据链路层、应用层，另外增加了用户层。</p>\n<p>FF 分低速H1和高速H2两种通信速率，前者传输速率为31.25Kbit/秒，通信距离可达1900m，可支持总线供电和本质安全防爆环境。后者传输速率为1Mbit/秒和2.5Mbit/秒，通信距离为750m和500m，支持双绞线、光缆和无线发射，协议符号IEC1158-2标准。</p>\n<p>FF 的物理媒介的传输信号采用曼切斯特编码。</p>\n<h3 id=\"can\">CAN</h3>\n<p>CAN，即Controller Area Network，控制器局域网络。</p>\n<p>最早由德国BOSCH公司推出，它广泛用于离散控制领域，其总线规范已被ISO国际标准组织制定为国际标准，得到了Intel、Motorola、NEC等公司的支持。CAN协议分为二层：物理层和数据链路层。CAN的信号传输采用短帧结构，传输时间短，具有自动关闭功能，具有较强的抗干扰能力。CAN支持多主工作方式，并采用了非破坏性总线仲裁技术，通过设置优先级来避免冲突，通讯距离最远可达10KM/5Kbps/s，通讯速率最高可达40M/1Mbp/s，网络节点数实际可达110个。目前已有多家公司开发了符合CAN协议的通信芯片。</p>\n<h3 id=\"lonworks\">LonWorks</h3>\n<p>由美国Echelon公司推出，并由Motorola、Toshiba公司共同倡导。它采用ISO/OSI模型的全部7层通讯协议，采用面向对象的设计方法，通过网络变量把网络通信设计简化为参数设置。支持双绞线、同轴电缆、光缆和红外线等多种通信介质，通讯速率从300bit/s至1.5M/s不等，直接通信距离可达2700m(78Kbit/s)，被誉为通用控制网络。Lonworks技术采用的Lon Talk协议被封装到Neuron(神经元)的芯片中，并得以实现。采用LonWorks技术和神经元芯片的产品，被广泛应用在楼宇自动化、家庭自动化、保安系统、办公设备、交通运输、工业过程控制等行业。</p>\n<h3 id=\"device-net\">Device Net</h3>\n<p>Device Net是一种低成本的通信连接也是一种简单的网络解决方案，有着开放的网络标准。Device Net具有的直接互联性不仅改善了设备间的通信而且提供了相当重要的设备级阵地功能。Device Net基于CAN技术，传输率为125Kbit/s至500Kbit/s，每个网络的最大节点为64个，其通信模式为：生产者/客户(Producer/Consumer)，采用多信道广播信息发送方式。位于Device Net网络上的设备可以自由连接或断开，不影响网上的其他设备，而且其设备的安装布线成本也较低。Device Net总线的组织结构是Open Device Net Vendor Association(开放式设备网络供应商协会，简称“ODVA”)。</p>\n<h3 id=\"profibus\">PROFIBUS</h3>\n<p>PROFIBUS是德国标准(DIN19245)和欧洲标准(EN50170)的现场总线标准。由PROFIBUS--DP、PROFIBUS-FMS、PROFIBUS-PA系列组成。DP用于分散外设间高速数据传输，适用于加工自动化领域。FMS适用于纺织、楼宇自动化、可编程控制器、低压开关等。PA用于过程自动化的总线类型，服从IEC1158-2标准。PROFIBUS支持主-从系统、纯主站系统、多主多从混合系统等几种传输方式。PROFIBUS的传输速率为9.6Kbit/s至12Mbit/s，最大传输距离在9.6Kbit/s下为1200m，在12Mbit/s小为200m，可采用中继器延长至10km，传输介质为双绞线或者光缆，最多可挂接127个站点。</p>\n<h3 id=\"hart\">HART</h3>\n<p>HART，即 Highway Addressable Remote Transducer，高速可寻址远程传感器。</p>\n<p>最早由Rosemount公司开发。其特点是在现有模拟信号传输线上实现数字信号通信，属于模拟系统向数字系统转变的过渡产品。其通信模型采用物理层、数据链路层和应用层三层，支持点对点主从应答方式和多点广播方式。由于它采用模拟数字信号混和，难以开发通用的通信接口芯片。</p>\n<p>HART能利用总线供电，可满足本质安全防爆的要求，并可用于由手持编程器与管理系统主机作为主设备的双主设备系统。</p>\n<h3 id=\"cc-link\">CC-Link</h3>\n<p>CC-Link是Control&amp;Communication Link(控制与通信链路系统)的缩写，在1996年11月，由三菱电机为主导的多家公司推出，其增长势头迅猛，在亚洲占有较大份额。在其系统中，可以将控制和信息数据同是以10Mbit/s高速传送至现场网络，具有性能卓越、使用简单、应用广泛、节省成本等优点。其不仅解决了工业现场配线复杂的问题，同时具有优异的抗噪性能和兼容性。CC-Link是一个以设备层为主的网络，同时也可覆盖较高层次的控制层和较低层次的传感层。2005年7月CC-Link被中国国家标准委员会批准为中国国家标准指导性技术文件。</p>\n<h3 id=\"world-fip\">World FIP</h3>\n<p>World FIP的北美部分与ISP合并为FF以后，World FIP的欧洲部分仍保持独立，总部设在法国。其在欧洲市场占有重要地位，特别是在法国占有率大约为60%。World FIP的特点是具有单一的总线结构来适用不同的应用领域的需求，而且没有任何网关或网桥，用软件的办法来解决高速和低速的衔接。World FIP与FFHSE可以实现“透明联接”，并对FF的H1进行了技术拓展，如速率等。在与IEC61158第一类型的连接方面，World FIP做得最好，走在世界前列。</p>\n<p>此外较有影响的现场总线还有丹麦公司Process-Data A/S提出的P-Net，该总线主要应用于农业、林业、水利、食品等行业；Swift Net现场总线主要使用在航空航天等领域，还有一些其他的现场总线这里就不再赘述了。</p>\n<h3 id=\"interbus\">INTERBUS</h3>\n<p>INTERBUS是德国Phoenix公司推出的较早的现场总线，2000年2月成为国际标准IEC61158。INTERBUS采用国际标准化组织ISO的开放化系统互联OSI的简化模型(1，2，7层)，即物理层、数据链路层、应用层，具有强大的可靠性、可诊断性和易维护性。其采用集总帧型的数据环通信，具有低速度、高效率的特点，并严格保证了数据传输的同步性和周期性;该总线的实时性、抗干扰性和可维护性也非常出色。INTERBUS广泛地应用到汽车、烟草、仓储、造纸、包装、食品等工业，成为国际现场总线的领先者。</p>\n<h2 id=\"其他\">其他</h2>\n<p>RS-485和现场总线同属于总线；ModBus和现场总线同属于通信协议；</p>\n<p>严格来讲，RS-485≠现场总线，ModBus≠现场总线，RS-485+ModBus（还有其他什么的）才构成现场总线，其中RS-485工作在现场总线的物理层，ModBus工作在现场总线的应用层；</p>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li>《现场总线CAN原理与技术应用》第二版，北京航空航天大学出版社，饶运涛、邹继军、王进宏、郑勇芸 编著</li>\n<li><a href=\"https://baike.baidu.com/item/现场总线/304020\">现场总线</a></li>\n<li><a href=\"https://www.jianshu.com/p/f32cfd6c208b\">OSI网络模型</a></li>\n<li><a href=\"https://baike.baidu.com/item/本质安全/1078274\">本质安全</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/87868499\">本质安全型电气设备防爆原理</a></li>\n</ol>\n","categories":["Communication"],"tags":["现场总线"]},{"title":"版本控制术语整理","url":"/2019/01/14/Computer/2019-01-14-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%20%E6%9C%AF%E8%AF%AD%E6%95%B4%E7%90%86/","content":"<p>以下为本人在学习开发途中的一些关于版本控制的资料整理。</p>\n<h1 id=\"版本控制\">版本控制</h1>\n<p>版本控制（Revision control）是维护工程蓝图的标准作法，能追踪工程蓝图从诞生一直到定案的过程。此外，版本控制也是一种软件工程技巧，借此能在软件开发的过程中，确保由不同人所编辑的同一程序文件都得到同步。</p>\n<h2 id=\"基线baseline\">基线（Baseline）</h2>\n<p>基线是软件文档或源码（或其它产出物）的一个稳定版本，它是进一步开发的基础。[1]</p>\n<h2 id=\"文件库repository\">文件库（Repository）</h2>\n<p>存储文件的新版本还有历史数据的地方，通常是在服务器上。有时候也叫Depot（像是在SVK、AccuRev还有Perforce中）</p>\n<h2 id=\"工作复本working-copy\">工作复本（Working copy）</h2>\n<p>从文件库中取出一个本地端（客户端）的复制，针对一个特定的时间或是版本。所有在文件库中的文件更动，都是从一个工作版本中修改而来的，这也是这名称的由来。观念上，这是一个沙盒。</p>\n<h2 id=\"提交commit\">提交（Commit）</h2>\n<p>将本地端的修改送回档案库。（由版本控制软件处理“跟上次更动相比，哪个文件又被更动”的事）</p>\n<h2 id=\"变更change\">变更（Change）</h2>\n<p>对一份文件作的特定更动。</p>\n<h2 id=\"变更记录change-list\">变更记录（Change List）</h2>\n<h2 id=\"取出check-out\">取出（Check-Out）</h2>\n<p>从文件库取出文件到本地端（客户端）。</p>\n<h2 id=\"更新update\">更新（Update）</h2>\n<p>将文件库的修改送到本地端（与提交相反）</p>\n<h2 id=\"合并merge-integration\">合并（Merge / Integration）</h2>\n<p>合并各个改变。</p>\n<h2 id=\"版次revision\">版次（Revision）</h2>\n<p>一个revision或version指的是一系列版本变迁的其中之一。</p>\n<h2 id=\"导入import\">导入（Import）</h2>\n<h2 id=\"导出export\">导出（Export）</h2>\n<h2 id=\"冲突conflict\">冲突（Conflict）</h2>\n<p>当两方更动同一份文件会发生冲突。</p>\n","categories":["Computer"],"tags":["VersionControl","Git","VCS"]},{"title":"Fixed Point and Floating Point Number Representations","url":"/2021/05/01/Computer/2021-05-01-Fixed-Point-and-Floating-Point-Number-Representations/","content":"<p>​</p>\n<p><a href=\"https://www.tutorialspoint.com/fixed-point-and-floating-point-number-representations#:~:text=In%20fixed%20point%20notation%2C%20there%20are%20a%20fixed,varying%20number%20of%20digits%20after%20the%20decimal%20point.\">tutorialspoint.com</a></p>\n<p><em>Arjun Thakur</em></p>\n<p>Digital Computers use Binary number system to represent all types of information inside the computers. Alphanumeric characters are represented using binary bits (i.e., 0 and 1). Digital representations are easier to design, storage is easy, accuracy and precision are greater.</p>\n<p>There are various types of number representation techniques for digital number representation, for example: Binary number system, octal number system, decimal number system, and hexadecimal number system etc. But Binary number system is most relevant and popular for representing numbers in digital computer system.</p>\n<h1 id=\"storing-real-number\">Storing Real Number</h1>\n<p>These are structures as following below −</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/36_1.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>There are two major approaches to store real numbers (i.e., numbers with fractional component) in modern computing. These are (i) Fixed Point Notation and (ii) Floating Point Notation.</p>\n<p><mark>In fixed point notation, there are a fixed number of digits after the decimal point, whereas floating point number allows for a varying number of digits after the decimal point.</mark> 在定点表示法中，小数点后有固定位数，而浮点数允许小数点后有不同位数。</p>\n<h1 id=\"fixed-point-representation\">Fixed-Point Representation</h1>\n<p>This representation has fixed number of bits for integer part and for fractional part. For example, if given fixed-point representation is <code>IIII.FFFF</code>, then you can store minimum value is <code>0000.0001</code> and maximum value is <code>9999.9999</code>. There are three parts of a fixed-point number representation: <strong><em>the sign field</em></strong>, <strong><em>integer field</em></strong>, and <strong><em>fractional field</em></strong>.</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/36_2.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>We can represent these numbers using:</p>\n<ul>\n<li>Signed representation: range from -(2<sup>(k-1)</sup>-1) to (2<sup>(k-1)</sup>-1), for k bits.</li>\n<li>1’s complement representation: range from -(2<sup>(k-1)</sup>-1) to (2<sup>(k-1)</sup>-1), for k bits.</li>\n<li>2’s complementation representation: range from -(2<sup>(k-1)</sup>) to (2<sup>(k-1)</sup>-1), for k bits.</li>\n</ul>\n<p>2’s complementation representation is preferred in computer system because of unambiguous property and easier for arithmetic operations.</p>\n<h3 id=\"example\">Example</h3>\n<p>Assume number is using 32-bit format which reserve 1 bit for the sign, 15 bits for the integer part and 16 bits for the fractional part.</p>\n<p>Then, <code>-43.625</code> is represented as following:</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/36_3.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>Where, <mark>0 is used to represent plus(+) and 1 is used to represent minus(-) </mark>. 000000000101011 is 15 bit binary value for decimal 43 and 1010000000000000 is 16 bit binary value for fractional 0.625.</p>\n<p>The advantage of using a fixed-point representation is performance and disadvantage is relatively limited range of values that they can represent. So, <mark>it is usually inadequate for numerical analysis as it does not allow enough numbers and accuracy</mark>. A number whose representation exceeds 32 bits would have to be stored inexactly.</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/36_4.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>These are above smallest positive number and largest positive number which can be store in 32-bit representation as given above format. Therefore, the smallest positive number is 2<sup>-16</sup> ≈ 0.000015 approximate and the largest positive number is (2<sup>15</sup>-1)+(1-2<sup>-16</sup>)=2<sup>15</sup>(1-2<sup>-16</sup>) =32768, and gap between these numbers is 2<sup>-16</sup>.</p>\n<p>We can move the radix point either left or right with the help of only integer field is 1.</p>\n<h1 id=\"floating-point-representation\">Floating-Point Representation</h1>\n<p>This representation does not reserve a specific number of bits for the integer part or the fractional part. Instead it reserves a certain number of bits for the number (called the mantissa or significand) and a certain number of bits to say where within that number the decimal place sits (called the exponent).</p>\n<p>The floating number representation of a number has two part: the first part represents a signed fixed point number called mantissa. The second part of designates the position of the decimal (or binary) point and is called the exponent. The fixed point mantissa（定点尾数） may be fraction or an integer. Floating -point is always interpreted to represent a number in the following form: Mxr<sup>e</sup>.</p>\n<p>Only the mantissa m and the exponent e are physically represented in the register (including their sign). A floating-point binary number is represented in a similar manner except that is uses base 2 for the exponent. A floating-point number is said to be normalized if the most significant digit of the mantissa is <code>1</code>.</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/36_5.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>So, actual number is (-1)<sup>s</sup> (1+m) x2<sup>(e-Bias)</sup>, where <em>s</em> is the sign bit, <em>m</em> is the mantissa, <em>e</em> is the exponent value, and <em>Bias</em> is the bias number.</p>\n<p>Note that signed integers and exponent are represented by either sign representation, or one’s complement representation, or two’s complement representation.</p>\n<p>The floating point representation is more flexible. Any non-zero number can be represented in the normalized form of ±(1.b<sub>1</sub>b<sub>2</sub>b<sub>3</sub> ...)<sub>2</sub> x2<sup>n</sup> This is normalized form of a number <code>x</code>.</p>\n<h3 id=\"example-1\">Example</h3>\n<p>Suppose number is using 32-bit format: the 1 bit sign bit（符号位）, 8 bits for signed exponent（符号数）, and 23 bits for the fractional part（小数）. The leading bit 1 is not stored (as it is always 1 for a normalized number) and is referred to as a <em>“hidden bit</em>”.</p>\n<p>Then −53.5 is normalized as -53.5=(-110101.1)<sub>2</sub>=(-1.101011) x2<sup>5</sup> , which is represented as following below,</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/36_6.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>Where <code>00000101</code> is the 8-bit binary value of exponent value <code>+5</code>.</p>\n<p>Note that 8-bit exponent ﬁeld is used to store integer exponents <code>-126 ≤  n ≤ 127</code>.</p>\n<p>The smallest normalized positive number that ﬁts into 32 bits is (1.000,000,000,000,000,000,000,00)2x26<sup>-126</sup>=2<sup>-126</sup>≈1.18x10<sup>-38</sup> , and largest normalized positive number that ﬁts into 32 bits is (1.111,111,111,111,111,111,111,11)2x2<sup>127</sup>=(224-1)x2<sup>104</sup> ≈ 3.40x10<sup>38</sup>. These numbers are represented as following below,</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/36_7.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>The precision of a ﬂoating-point format is the number of positions reserved for binary digits plus one (for the hidden bit). In the examples considered here the precision is <code>23+1=24</code>.</p>\n<p>The gap between 1 and the next normalized ﬂoating-point number is known as machine epsilon. the gap is (1+2<sup>-23</sup>)-1=2<sup>-23</sup> for above example, but this is same as the smallest positive ﬂoating-point number because of non-uniform spacing unlike in the ﬁxed-point scenario.</p>\n<p>Note that non-terminating binary numbers can be represented in floating point representation, e.g., 1/3 = (0.010101 ...)<sup>2</sup> cannot be a ﬂoating-point number as its binary representation is non-terminating.</p>\n<h1 id=\"ieee-floating-point-number-representation\">IEEE Floating point Number Representation</h1>\n<p>IEEE (Institute of Electrical and Electronics Engineers) has standardized Floating-Point Representation as following diagram.</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/36_8.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>So, actual number is (-1)<sup>s</sup>(1+m)x2<sup>(e-Bias)</sup>, where <em>s</em> is the sign bit, <em>m</em> is the mantissa, <em>e</em> is the exponent value, and <em>Bias</em> is the bias number. The sign bit is 0 for positive number and 1 for negative number. Exponents are represented by or two’s complement representation.</p>\n<p><strong>According to IEEE 754 standard, the floating-point number is represented in following ways:</strong></p>\n<ul>\n<li>Half Precision (16 bit): 1 sign bit, 5 bit exponent, and 10 bit mantissa</li>\n<li>Single Precision (32 bit): 1 sign bit, 8 bit exponent, and 23 bit mantissa</li>\n<li>Double Precision (64 bit): 1 sign bit, 11 bit exponent, and 52 bit mantissa</li>\n<li>Quadruple Precision (128 bit): 1 sign bit, 15 bit exponent, and 112 bit mantissa</li>\n</ul>\n<h1 id=\"special-value-representation\"><strong>Special Value Representation</strong></h1>\n<p>There are some special values depended upon different values of the exponent and mantissa in the IEEE 754 standard.</p>\n<ul>\n<li>All the exponent bits 0 with all mantissa bits 0 represents 0. If sign bit is 0, then +0, else -0.</li>\n<li>All the exponent bits 1 with all mantissa bits 0 represents infinity. If sign bit is 0, then +∞, else -∞.</li>\n<li>All the exponent bits 0 and mantissa bits non-zero represents <strong>denormalized number</strong>.</li>\n<li>All the exponent bits 1 and mantissa bits non-zero represents <strong>error</strong>.</li>\n</ul>\n","categories":["Computer"],"tags":["fixe","float"]},{"title":"数据库学习笔记","url":"/2021/05/11/Computer/2021-05-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"<h1 id=\"数据库入门\">数据库入门</h1>\n<h4 id=\"数据库相关从业\">数据库相关从业</h4>\n<p><strong>前面五种</strong>：重点是设计和应用，侧重于软件和数据逻辑层面。</p>\n<p>数据库应用开发 (application development) &gt; 除了基本的SQL方面的知识，还要对开发流程，软件工程，各种框架和开发工具等等 &gt; 数据库应用开发这个方向上的机会最多，职位最多</p>\n<p>数据建模专家 (data modeler) &gt; 除了基本的SQL方面的知识，非常熟悉数据库原理，数据建模 &gt; 负责将用户对数据的需求转化为数据库物理设计和物理设计 &gt; 这个方向上在大公司（金融，保险，研究，软件开发商等）有专门职位， &gt; 在中小公司则可能由程序员承担。</p>\n<p>商业智能专家 (business intelligence - BI) &gt; 主要从商业应用，最终用户的角度去从数据中获得有用的信息， &gt; 涉及OLAP (online analytical processing) &gt; 需要使用SSRS, cognos, crystal report等报表工具，或者其他一些数据挖掘，统计方面的软件工具</p>\n<p>ETL开发 (ETL Developer) &gt; 使用ETL工具或者自己编写程序在不同的数据源之间对数据进行导入，导出，转换， &gt; 所接触的数据库一般数据量非常大，要求进行的数据转换也比较复杂。 &gt; 和数据仓库和商业智能的关系比较密切。</p>\n<blockquote>\n<p>在一些数据库应用规模很大的公司里面有专门的职位， 中小公司里面则可能由程序员或者DBA负责这方面的工作。</p>\n</blockquote>\n<p>数据构架师 (Data Architect) &gt; 主要从全局上制定和控制关于数据库在逻辑这一层的大方向， &gt; 也包括数据可用性，扩展性等长期性战略， &gt; 协调数据库的应用开发，建模，DBA之间的工作。 &gt; 这个方向上在大公司（金融，保险，研究，软件开发商等）有专门职位， &gt; 在中小公司或者没有这个职位，或者由开发人员，DBA负责。</p>\n<p><strong>后面五种</strong>：重点是运营和维护，侧重与硬件和数据物理层面。</p>\n<p>数据库管理员 (database administrator - DBA) &gt; 数据库的安装，配置，调优，备份/恢复，监控，自动化等， &gt; 协助应用开发（有些职位还要求优化SQL，写存储过程和函数等） &gt; 这个方向上的职位相对少一些，但一般有点规模的公司还是会有这样的职位</p>\n<p>数据仓库专家 (data warehouse - DW) &gt; 应付超大规模的数据，历史数据的存储，管理和使用， &gt; 和商业智能关系密切，很多时候BI和DW是放在一个大类里面的， &gt; 但是我觉得DW更侧重于硬件和物理层上的管理和优化。</p>\n<p>存储工程师 (storage engineer) &gt; 专门负责提供数据存储方案，使用各种存储技术满足数据访问和存储需求， &gt; 和DBA的工作关系比较密切。 &gt; 对高可用性有严格要求（比如通信，金融，数据中心等）的公司通常有这种职位， &gt; 这种职位也非常少。</p>\n<p>性能优化工程师 (performance engineer) &gt; 专长数据库的性能调试和优化，为用户提供解决性能瓶颈方面的问题。 &gt; 我知道至少IBM, 微软和Oracle都有专门的数据库性能实验室(database performance lab）, &gt; 也有专门的性能优化工程师，负责为其数据库产品和关键应用提供这方面的技术支持。 &gt; 对数据库性能有严格要求的公司（比如金融行业）可能会有这种职位。 &gt; 因为针对性很强，甚至要求对多种数据库非常熟悉，所以职位极少。</p>\n<p>高级数据库管理员 (senior DBA) &gt; 在DBA的基础上，还涉及上面3种职位的部分工作，具体包括下面这些： &gt; 对应用系统的数据（布局，访问模式，增长模式，存储要求等）比较熟悉。 &gt; 对性能优化非常熟悉，可以发现并优化从SQL到硬件I/O，网络等各个层面上的瓶颈 &gt; 对于存储技术相对熟悉，可能代替存储工程师的一些工作， &gt; 对数据库的高可用性技术非常熟悉（比如MSSQL的集群，ORACLE RAC/FailSafe, IBM的DPF, HADR等） &gt; 对大规模数据库有效进行物理扩展（比如表分区）或者逻辑扩展（比如数据库分区，联合数据库等） &gt; 熟悉各种数据复制技术，比如单向，双向，点对点复制技术，以满足应用要求。 &gt; 灾难数据恢复过程的建立，测试和执行 &gt; 这种职位一般只在对数据库要求非常高并且规模非常大（比如金融，电信，数据中心等）的公司需要， &gt; 而且这种公司一般有一个专门独立负责数据库的部门或组。</p>\n<h1 id=\"关系型数据库\">关系型数据库</h1>\n<p>说到关系型数据库，不仅仅是涉及计算机概念，也涉及一些数学概念，例如表格的概念、包含关系、关系运算及关系代数等。</p>\n<h2 id=\"关系模型术语\">关系模型术语</h2>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210512085059008.png\" alt=\"image-20210512085059008\" style=\"zoom:67%;\" /></p>\n<ol type=\"1\">\n<li><strong>表</strong>：关系型数据库由表集合而成，<strong>表是关系型数据库的一个基本组成</strong>，每个表具有唯一的名字。</li>\n<li><strong>关系</strong>：在关系型数据库中，<strong>关系</strong> 指代 <strong>表</strong> 的概念，即一般可认为 <strong>关系 = 表</strong>。</li>\n<li><strong>元组</strong>：在关系型数据库中，<strong>元组</strong> 指代 <strong>行</strong> 的概念，即一般可认为 <strong>元组 = 行</strong>。</li>\n<li><strong>属性</strong>：在关系型数据库中，<strong>属性</strong> 指代 <strong>列</strong> 的概念，即一般可认为 <strong>属性 = 列</strong>。</li>\n<li><strong>域</strong>：属性下所有元素的可取值范围或取值类型。</li>\n<li><strong>原子域</strong>：域中的元素不可再分，则称为原子域。</li>\n<li><strong>空值</strong>：属性下元素为空(NULL)。</li>\n<li><strong>关系实例</strong>：即表实例，严谨说法是 “表示一个关系的特定实例，也就是所包含的一组特定的行”，就是不仅仅只有属性这一行，还具有特定的某些具体数据的表格。</li>\n<li><strong>关系模式</strong>：即表模式，严谨说法是“关系模式由属性序列及各属性对应域组成”，通俗地说就是，没有具体数据，而仅定义了属性和域的表格。</li>\n<li><strong>数据库模式</strong>：对数据库的逻辑设计。</li>\n<li><strong>数据库实例</strong>：对数据库中数据的快照。</li>\n<li><strong>超码</strong>：是一个或多个属性的集合，超码内的一个或多个属性组合可以唯一区分和标识一个元组。</li>\n<li><strong>候选码</strong>：最小超码。</li>\n<li><strong>主码</strong>：主码是候选码的一种，最重要的是，<strong>主码由设计者选中，具有人为性</strong>。</li>\n<li><strong>外码</strong>：用于表示关系之间的引用和被引用关系。即关系A中的某项属性来自于关系B中的某项属性，则称该引用过来的属性为外码。<strong>但据课本，是被引用的主码称为外码。</strong></li>\n<li><img src=\"https://pic.islet.space/2021/05/image-20210512134116409.png\" title=\"fig:\" alt=\"image-20210512134116409\" /></li>\n</ol>\n<h2 id=\"结构化查询语言sql\">结构化查询语言SQL</h2>\n<h3 id=\"发展历史\">发展历史</h3>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210512192241572.png\" alt=\"image-20210512192241572\" style=\"zoom:67%;\" /></p>\n<blockquote>\n<p><a href=\"https://developer.aliyun.com/article/745815#:~:text=SQL%E6%A0%87%E5%87%86%E6%98%AF%E7%94%B1%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86%E5%8C%96%E7%BB%84%E7%BB%87%EF%BC%88ISO%EF%BC%89%E3%80%81%E7%BE%8E%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E5%A7%94%E5%91%98%E4%BC%9AANSI%E7%AD%89%E5%88%B6%E5%AE%9A%E7%9A%84%EF%BC%8C%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%9F%E4%B8%80%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E3%80%82%20SQL%20%E6%98%AF%20Structured%20Query%20Language%20%E7%9A%84%E7%BC%A9%E5%86%99%EF%BC%8C%E8%A7%84%E8%8C%83%E7%9A%84%E5%8F%91%E9%9F%B3%E6%98%AF%20%E2%80%9C%CB%8C%C9%9Bs%CB%8Ckju%CB%90%CB%88%C9%9Bl%E2%80%9D%E3%80%82,%E6%98%AF%20SQL%20Query%20Language%20%E7%9A%84%E7%BC%A9%E5%86%99%E3%80%82%20IBM%E5%AF%B9%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%A5%E5%8F%8ASQL%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BD%A2%E6%88%90%E5%92%8C%E8%A7%84%E8%8C%83%E5%8C%96%E4%BA%A7%E7%94%9F%E4%BA%86%E9%87%8D%E5%A4%A7%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%8C%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84SQL%E6%A0%87%E5%87%86SQL86%E5%B0%B1%E6%98%AF%E5%9F%BA%E4%BA%8ESystem%20R%E7%9A%84%E6%89%8B%E5%86%8C%E8%80%8C%E6%9D%A5%E7%9A%84%E3%80%82%20Oracle%E5%9C%A81979%E5%B9%B4%E7%8E%87%E5%85%88%E6%8E%A8%E5%87%BA%E4%BA%86%E6%94%AF%E6%8C%81SQL%E7%9A%84%E5%95%86%E7%94%A8%E4%BA%A7%E5%93%81%E3%80%82\">数据库必知词汇：SQL标准</a></p>\n<p>SQL标准是由国际标准化组织（ISO）、美国国家标准委员会ANSI等制定的，对数据库管理系统的统一操作方式。</p>\n<p>SQL 是 Structured Query Language 的缩写，规范的发音是 “ˌɛsˌkjuːˈɛl”。但是它的前身是著名的关系数据库原型系统 System R 所采用的 SEQUEL 语言，这也是为什么有很多人将其读作 “ˈsiːkwəl” 的来源。也有人类比 GNU 这个词的定义（GNU’s Not UNIX），认为 SQL 是 SQL Query Language 的缩写。</p>\n<p>IBM对关系数据库以及SQL语言的形成和规范化产生了重大的影响，第一个版本的SQL标准SQL86就是基于System R的手册而来的。Oracle在1979年率先推出了支持SQL的商用产品。随着数据库技术和应用的发展，为不同RDBMS提供一致的语言成了一种现实需要。</p>\n<p>对SQL标准影响最大的机构自然是那些著名的数据库产商，而具体的制订者则是一些非营利机构，例如国际标准化组织ISO、美国国家标准委员会ANSI等。各国通常会按照ISO标准和ANSI标准制定自己的国家标准。</p>\n<p>“美国国家标准化组织(ANSI)”是一个核准多种行业标准的组织。SQL作为关系型数据库所使用的标准语言，最初是基于IBM的实现在1986年被批准的。1987年，“国际标准化组织(ISO)”把ANSI SQL作为国际标准。</p>\n<p>SQL发展的简要历史： 1986年，ANSI X3.135-1986，ISO/IEC 9075:1986，SQL-86 1989年，ANSI X3.135-1989，ISO/IEC 9075:1989，SQL-89 1992年，ANSI X3.135-1992，ISO/IEC 9075:1992，SQL-92（SQL2） 1999年，ISO/IEC 9075:1999，SQL:1999（SQL3） 2003年，ISO/IEC 9075:2003，SQL:2003 2008年，ISO/IEC 9075:2008，SQL:2008 2011年，ISO/IEC 9075:2011，SQL:2011 补充 1986 年，ANSI X3.135-1986，ISO/IEC 9075:1986，SQL-86。这是 ANSI 首次将 SQL 语言标准化的版本。 1989 年，ANSI X3.135-1989，ISO/IEC 9075:1989，SQL-89。增加了完整性约束。 1992 年，ANSI X3.135-1992，ISO/IEC 9075:1992，SQL-92（SQL2）。最重要的一个版本。 引入了标准的分级概念。 1999 年，ISO/IEC 9075:1999，SQL:1999（SQL3）。变动最大的一个版本。改变了标准符合程度的定义；增加了面向对象特性、正则表达式、存储过程、Java 等支持。 2003 年，ISO/IEC 9075:2003，SQL:2003。引入了 XML、Window 函数等。 2008 年，ISO/IEC 9075:2008，SQL:2008。引入了 TRUNCATE 等。 2011 年，ISO/IEC 9075:2011，SQL:2011。引入了时序数据等。 2016 年，ISO/IEC 9075:2016，SQL:2016。引入了 JSON 等。</p>\n<p>绝大多数人提起SQL标准，涉及的内容其实是SQL92里头最基本或者说最核心的一部分。SQL92本身是分级的，包括入门级、过度级、中间级和完全级，推荐泛读SQL92，增量式式阅读其他标准。而随着SQL标准的发展，其包含的内容实在太多了，而且有很多特性对新的SQL产品而言也越来越不重要了。从SQL99之后，标准中符合程度的定义就不再分级，而是改成了核心兼容性和特性兼容性；也没有机构来推出权威的SQL标准符合程度的测试认证了。</p>\n</blockquote>\n<h3 id=\"作用\">作用</h3>\n<ol type=\"1\">\n<li>数据库查询</li>\n<li>定义数据结构</li>\n<li>修改数据</li>\n<li>说明安全性约束条件</li>\n</ol>\n<h3 id=\"基本数据类型\">基本数据类型</h3>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210512192708528.png\" alt=\"image-20210512192708528\" style=\"zoom:67%;\" /></p>\n<p><strong><em>以上所有类型都可能包含一个被称作空值的特殊值。NULL表示一个缺失的值，即表示该值可能存在但并不为人所知，或者可能根本不存在。</em></strong></p>\n<h4 id=\"关于char-varchar-nvarchar的比较\">关于char / varchar / nvarchar的比较</h4>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210512193208247.png\" alt=\"image-20210512193208247\" style=\"zoom:67%;\" /></p>\n<h3 id=\"sql完整性约束\">SQL完整性约束</h3>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210512201050138.png\" alt=\"image-20210512201050138\" style=\"zoom:67%;\" /></p>\n<p>例如，上方教员的名称为 “张三”， 我想删除后保存，会破坏 <code>instructor</code> 关系下 <code>name</code> 的非空约束，SQL不通过这种操作。</p>\n<h3 id=\"数据库操作\">数据库操作</h3>\n<h4 id=\"新建表格\">新建表格</h4>\n<p>数据表格新建格式及样例如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210512193506987.png\" alt=\"image-20210512193506987\" /><figcaption aria-hidden=\"true\">image-20210512193506987</figcaption>\n</figure>\n<blockquote>\n<p>其中r是关系名，即表名；A<sub>x</sub>是属性名，即列名；D<sub>x</sub>是属性的域，即指定了A的类型及可选约束，用于限制所允许的A<sub>x</sub>取值的集合。</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*部门关系*/</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> department(</span><br><span class=\"line\">    dept_name <span class=\"type\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">    building <span class=\"type\">varchar</span>(<span class=\"number\">15</span>),</span><br><span class=\"line\">    budget <span class=\"type\">numeric</span>(<span class=\"number\">12</span>,<span class=\"number\">2</span>),</span><br><span class=\"line\">    <span class=\"keyword\">primary</span> key(dept_name)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*课程关系*/</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> course(</span><br><span class=\"line\">    coourse_id <span class=\"type\">varchar</span>(<span class=\"number\">7</span>),</span><br><span class=\"line\">    title <span class=\"type\">varchar</span>(<span class=\"number\">50</span>),</span><br><span class=\"line\">    dept_name <span class=\"type\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">    credits <span class=\"type\">numeric</span>(<span class=\"number\">2</span>,<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"keyword\">primary</span> key(course_id),</span><br><span class=\"line\">    <span class=\"keyword\">foreign</span> key (dept_name) <span class=\"keyword\">references</span> department</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*教员关系*/</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> instructor(</span><br><span class=\"line\">\tID <span class=\"type\">varchar</span>(<span class=\"number\">5</span>),</span><br><span class=\"line\">    name <span class=\"type\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">    dept_name <span class=\"type\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">    salary <span class=\"type\">numeric</span>(<span class=\"number\">8</span>,<span class=\"number\">2</span>),</span><br><span class=\"line\">    <span class=\"keyword\">primary</span> key(ID),</span><br><span class=\"line\">    <span class=\"keyword\">foreign</span> key(dept_name) <span class=\"keyword\">references</span> department</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*（课程）章节关系*/</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> section(</span><br><span class=\"line\">\tcourse_id <span class=\"type\">varchar</span>(<span class=\"number\">8</span>),</span><br><span class=\"line\">    sec_id <span class=\"type\">varchar</span>(<span class=\"number\">8</span>),</span><br><span class=\"line\">    semester <span class=\"type\">varchar</span>(<span class=\"number\">6</span>),</span><br><span class=\"line\">    <span class=\"keyword\">year</span> <span class=\"type\">numeric</span>(<span class=\"number\">4</span>,<span class=\"number\">0</span>),</span><br><span class=\"line\">    building <span class=\"type\">varchar</span>(<span class=\"number\">7</span>),</span><br><span class=\"line\">    time_slot_id <span class=\"type\">varchar</span>(<span class=\"number\">4</span>),</span><br><span class=\"line\">    <span class=\"keyword\">primary</span> key(course_id, sec_id, semester, <span class=\"keyword\">year</span>),</span><br><span class=\"line\">    <span class=\"keyword\">foreign</span> key(course_id) <span class=\"keyword\">references</span> course</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*教师关系*/</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> teachers(</span><br><span class=\"line\">\tID <span class=\"type\">varchar</span>(<span class=\"number\">5</span>),</span><br><span class=\"line\">    course_id <span class=\"type\">varchar</span>(<span class=\"number\">8</span>),</span><br><span class=\"line\">    sec_id <span class=\"type\">varchar</span>(<span class=\"number\">8</span>),</span><br><span class=\"line\">    semester <span class=\"type\">varchar</span>(<span class=\"number\">6</span>),</span><br><span class=\"line\">    <span class=\"keyword\">year</span> <span class=\"type\">numeric</span>(<span class=\"number\">4</span>,<span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"keyword\">primary</span> key(ID, course_id, sec_id, semester, <span class=\"keyword\">year</span>),</span><br><span class=\"line\">    <span class=\"keyword\">foreign</span> key(course_id, sec_id, semester, <span class=\"keyword\">year</span>) <span class=\"keyword\">references</span> section,</span><br><span class=\"line\">    <span class=\"keyword\">foreign</span> key(ID) <span class=\"keyword\">references</span> instructor</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>foreign key 可以拿来当 primary key，如章节关系中所示。</p>\n<p><code>not null</code> 关键字约束表明 “在该属性上不允许空值” 。</p>\n</blockquote>\n<h4 id=\"插入\">插入</h4>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210512201338050.png\" alt=\"image-20210512201338050\" /><figcaption aria-hidden=\"true\">image-20210512201338050</figcaption>\n</figure>\n<p>插入值过程中，所给出的值的顺序应与关系模式中的属性顺序一致。</p>\n<h4 id=\"删除\">删除</h4>\n<p><code>delete</code> 命令可以用于删除元组。</p>\n<ul>\n<li>如果直接使用命令 <code>delete from student</code> ， 则将从 <em>student</em> 关系中删除所有元组。</li>\n<li>使用其他语句可以执行特定删除，如：\n<ul>\n<li>使用命令 <code>delete from instructor where salary between 13000 and 150000;</code> ，删除所有工资在13000到15000美元之间的教师</li>\n<li>其他操作……</li>\n</ul></li>\n</ul>\n<h4 id=\"丢弃表格\">丢弃表格</h4>\n","categories":["Computer"],"tags":["database","tencent"]},{"title":"内存地址对齐","url":"/2021/05/17/Computer/2021-05-17-%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E5%AF%B9%E9%BD%90/","content":"<p><a href=\"https://www.cnblogs.com/mhq-martin/p/11537873.html\">cnblogs.com</a></p>\n<h1 id=\"对齐定义\">对齐定义</h1>\n<p>内存地址对齐，是一种在计算机内存中排列数据、访问数据的一种方式。</p>\n<h1 id=\"对齐分类\">对齐分类</h1>\n<p>内存地址对齐包含了两种相互独立又相互关联的部分：<strong>基本数据对齐</strong> 和 <strong>结构体数据对齐</strong>。</p>\n<p>当今的计算机在计算机内存中读写数据时都是 <mark>按字(word)大小块来进行操作</mark> 的。在32位系统中，数据总线宽度为32位，每次能读取4bytes，地址总线宽度为32，因此最大的寻址空间为2<sup>32</sup>bits=4GB，但是最低2位A[0]、A[1]是不用于寻址，A[2-31]才能存储器相连，因此只能访问4的倍数地址空间，但是总的寻址空间还是2<sup>30</sup>bits字长=4GB，因此在 <mark>内存中所有存放的基本类型数据的首地址的最低两位都是0，除结构体中的成员变量</mark> 。</p>\n<blockquote>\n<p>基本类型数据对齐就是数据在内存中的 <mark>偏移地址必须等于一个字的倍数</mark>，按这种存储数据的方式，可以提升系统在读取数据时的性能。<mark>为了对齐数据，可能必须在上一个数据结束和下一个数据开始的地方插入一些没有用处字节，这就是结构体数据对齐</mark>。</p>\n</blockquote>\n<h2 id=\"基本数据对齐示例\">基本数据对齐示例</h2>\n<p>例如，假设计算机的字大小为4bytes，因此变量在内存中的首地址都是满足4地址对齐，CPU只能对4的倍数的地址进行读取，而每次能读取4个字节大小的数据。</p>\n<p>假设有一个整型的数据a的首地址不是4的倍数(如下图所示)，不妨设为 <code>0X00FFFFF3</code>，则该整型数据存储在地址范围为<code>0X00FFFFF3</code> ~<code>0X00FFFFF6</code>的存储空间中，而CPU每次只能对4的倍数内存地址进行读取，因此想读取a的数据，CPU要分别在 <code>0X00FFFFF0</code> 和 <code>0X00FFFFF4</code> 进行两次内存读取，而且还要对两次读取的数据进行处理才能得到a的数据，而一个程序的瓶颈往往不是CPU的速度，而是取决于内存的带宽，因为CPU得处理速度要远大于从内存中读取数据的速度，因此减少对内存空间的访问是提高程序性能的关键。从上例可以看出，采取内存地址对齐策略是提高程序性能的关键。</p>\n<p><mark>也就是说，不对齐内存地址的话会造成CPU对内存中数据访问范围的增大，造成性能浪费。</mark></p>\n<h2 id=\"结构体对齐示例\">结构体对齐示例</h2>\n<p>首先我们先看看下面的C语言的结构体：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef struct MemAlign</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int a;</span><br><span class=\"line\">    char b[3];</span><br><span class=\"line\">    int c;</span><br><span class=\"line\">&#125;MemAlign;</span><br></pre></td></tr></table></figure>\n<p>以上这个结构体占用内存多少空间呢？</p>\n<p>也许你会说，这个简单，计算每个类型的大小，将它们相加就行了，以32bit平台为例，int类型占4bytes，char占用1byte，所以：4 + 3 + 4 = 11bytes，那么这个结构体一共占用11字节空间。</p>\n<p>实际上用sizeof运算符来求出这个结构体占用内存空间大小，sizeof(MemAlign)，出乎意料的是，结果居然为12？</p>\n<p>是因为这个结构体被优化了，这个优化有个另外一个名字叫“对齐”，那么这个对齐到底做了什么样的优化呢。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/1231881-20190917224404418-1265388453.png\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>相信学过汇编的朋友都很熟悉这张图，这张图就是CPU与内存如何进行数据交换的模型，其中，左边蓝色的方框是CPU，右边绿色的方框是内存，内存上面的0～3是内存地址。</p>\n<p>上图以32位CPU作为代表，<mark>32位CPU是以双字（DWORD）为单位进行数据传输的</mark>，因此 <mark>在32位系统中，无论是8位、16位还是32位都是以双字进行数据传输</mark> 。</p>\n<h2 id=\"非32位数据非对齐传输示例\">非32位数据非对齐传输示例</h2>\n<p>8位或16位一样可以传输，但是事情并非像我们想象的那么简单。</p>\n<p>一个int类型4字节的数据如果放在上图内存地址1开始的位置，那么这个数据占用的内存地址为1～4，那么这个数据就被分为了2个部分，一个部分在地址0～3中，另外一部分在地址4～7中，又由于32位CPU以双字进行传输，所以，CPU会分2次进行读取，一次先读取地址0～3中内容，再一次读取地址4～7中数据，最后CPU提取并组合出正确的int类型数据，舍弃掉无关数据。那么反过来，如果我们把这个int类型4字节的数据放在上图从地址0开始的位置会怎样呢？读到这里，也许你明白了，CPU只要进行一次读取就可以得到这个int类型数据了。没错，就是这样，这次CPU只用了一个周期就得到了数据，由此可见，对内存数据的摆放是多么重要啊，<mark>摆放正确位置可以减少CPU的使用资源</mark>。</p>\n<h1 id=\"对齐原则\">对齐原则</h1>\n<ul>\n<li><p>第一个成员的首地址为0</p></li>\n<li><p>每个成员的首地址是自身大小的整数倍</p>\n<ul>\n<li>以4bytes对齐为例，如果自身大小大于4bytes，都以4bytes整数倍为基准对齐。</li>\n</ul></li>\n<li><p>最后以结构总体对齐。</p>\n<ul>\n<li>以4字节bytes为例，取结构体中最大成员类型倍数，如果超过4字节，都以4字节整数倍为基准对齐。（其中这一条还有个名字叫：“补齐”，补齐的目的就是多个结构变量挨着摆放的时候也满足对齐的要求。）</li>\n</ul></li>\n</ul>\n<h2 id=\"基本数据对齐与结构补齐示例\">基本数据对齐与结构补齐示例</h2>\n<p>上述的三原则听起来还是比较抽象，那么接下来我们通过一个例子来加深对内存对齐概念的理解，下面是一个结构体，我们动手算出下面结构体一共占用多少内存？假设我们以32位平台并且以4字节对齐方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#pragma pack(4)</span><br><span class=\"line\">typedef struct MemAlign</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    char a[18];</span><br><span class=\"line\">    double b;    </span><br><span class=\"line\">    char c;</span><br><span class=\"line\">    int d;    </span><br><span class=\"line\">    short e;    </span><br><span class=\"line\">&#125;MemAlign;</span><br></pre></td></tr></table></figure>\n<p>下图为对齐后结构如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/1231881-20190917224631323-2009020349.png\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>我们就以这个图来讲解是如何对齐的：</p>\n<p>第一个成员（char a[18]）：首先，假设我们把它放到内存开始地址为0的位置，由于第一个成员占18个字节，所以第一个成员占用内存地址范围为0～18。</p>\n<p>第二个成员（double b）：由于double类型占8字节，又因为8字节大于4字节，所以就以4字节对齐为基准。由于第一个成员结束地址为18，那么地址18并不是4的整数倍，我们需要再加2个字节，也就是从地址20开始摆放第二个成员。</p>\n<p>第三个成员（char c）：由于char类型占1字节，任意地址是1字节的整数倍，所以我们就直接将其摆放到紧接第二个成员之后即可。</p>\n<p>第四个成员（int d）：由于int类型占4字节，但是地址29并不是4的整数倍，所以我们需要再加3个字节，也就是从地址32开始摆放这个成员。</p>\n<p>第五个成员（short e）：由于short类型占2字节，地址36正好是2的整数倍，这样我们就可以直接摆放，无需填充字节,紧跟其后即可。</p>\n<p>这样我们内存对齐就完成了。但是离成功还差那么一步，那是什么呢？对，是对整个结构体补齐，接下来我们就补齐整个结构体。那么，先让我们回顾一下补齐的原则：“以4字节对齐为例，取结构体中最大成员类型倍数，如果超过4字节，都以4字节整数倍为基准对齐。”在这个结构体中最大类型为double类型（占8字节），又由于8字节大于4字 节，所以我们还是以4字节补齐为基准，整个结构体结束地址为38，而地址38并不是4的整数倍，所以我们还需要加额外2个字节来填充结构体，如下图红色的就是补齐出来的空间：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/1231881-20190917224653471-2076639760.png\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>到此为止，我们内存对齐与补齐就完毕了！接下来我们用实验来证明真理，程序如下：</p>\n<figure>\n<img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\" /><figcaption aria-hidden=\"true\">复制代码</figcaption>\n</figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;memory.h&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F; 由于VS2010默认是8字节对齐，我们</span><br><span class=\"line\">&#x2F;&#x2F; 通过预编译来通知编译器我们以4字节对齐</span><br><span class=\"line\">#pragma pack(4)</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F; 用于测试的结构体</span><br><span class=\"line\">typedef struct MemAlign</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    char a[18];    &#x2F;&#x2F; 18 bytes</span><br><span class=\"line\">    double b;    &#x2F;&#x2F; 08 bytes    </span><br><span class=\"line\">    char c;        &#x2F;&#x2F; 01 bytes</span><br><span class=\"line\">    int d;        &#x2F;&#x2F; 04 bytes</span><br><span class=\"line\">    short e;    &#x2F;&#x2F; 02 bytes</span><br><span class=\"line\">&#125;MemAlign;</span><br><span class=\"line\"> </span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 定义一个结构体变量</span><br><span class=\"line\">    MemAlign m;</span><br><span class=\"line\">    &#x2F;&#x2F; 定义个以指向结构体指针</span><br><span class=\"line\">    MemAlign *p &#x3D; &amp;m;</span><br><span class=\"line\">    &#x2F;&#x2F; 依次对各个成员进行填充，这样我们可以</span><br><span class=\"line\">    &#x2F;&#x2F; 动态观察内存变化情况</span><br><span class=\"line\">    memset( &amp;m.a, 0x11, sizeof(m.a) );</span><br><span class=\"line\">    memset( &amp;m.b, 0x22, sizeof(m.b) );</span><br><span class=\"line\">    memset( &amp;m.c, 0x33, sizeof(m.c) );</span><br><span class=\"line\">    memset( &amp;m.d, 0x44, sizeof(m.d) );</span><br><span class=\"line\">    memset( &amp;m.e, 0x55, sizeof(m.e) );</span><br><span class=\"line\">    &#x2F;&#x2F; 由于有补齐原因，所以我们需要对整个</span><br><span class=\"line\">    &#x2F;&#x2F; 结构体进行填充，补齐对齐剩下的字节</span><br><span class=\"line\">    &#x2F;&#x2F; 以便我们可以观察到变化</span><br><span class=\"line\">    memset( &amp;m, 0x66, sizeof(m) );</span><br><span class=\"line\">    &#x2F;&#x2F; 输出结构体大小</span><br><span class=\"line\">    printf( &quot;sizeof(MemAlign) &#x3D; %d&quot;, sizeof(m) );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\" /><figcaption aria-hidden=\"true\">复制代码</figcaption>\n</figure>\n<p>程序运行过程中，查看内存如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/1231881-20190917225512389-1581088258.png\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>其中，各种颜色带下划线的代表各个成员变量，蓝色方框的代表为内存对齐时候填补的多余字节，由于这里看不到补齐效果，我们接下来看下图，下图篮框包围的字节就是与上图的交集以外的部分就是补齐所填充的字节。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/1231881-20190917225534651-684741719.png\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>在最后，我在谈一谈关于补齐的作用，<mark>补齐其实就是为了让这个结构体定义的数组变量时候，数组内部，也同样满足内存对齐的要求</mark>，为了更好的理解这点，我做了一个跟本例子相对照的图：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/1231881-20190917225553591-1418591054.png\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<h1 id=\"参考链接\">参考链接</h1>\n<p>https://blog.csdn.net/donkeylong/article/details/4909720</p>\n<p>https://blog.csdn.net/cyousui/article/details/17655051</p>\n<p>​</p>\n","categories":["Computer"],"tags":["address","align"]},{"title":"汇编语言","url":"/2021/05/17/Computer/2021-05-17-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","content":"<h1 id=\"x86指令集介绍\">X86指令集介绍</h1>\n<h2 id=\"x86指令集的基本特色\">X86指令集的基本特色</h2>\n<ul>\n<li>向下兼容</li>\n<li>变长指令\n<ul>\n<li>1-15字节，多为2-3字节长度</li>\n</ul></li>\n<li>多种寻址方式（可访问不对齐内存地址）</li>\n</ul>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210517203416861.png\" alt=\"image-20210517203416861\" /><figcaption aria-hidden=\"true\">image-20210517203416861</figcaption>\n</figure>\n<h2 id=\"x86寄存器\">X86寄存器</h2>\n<p>指令集的通用寄存器个数有限</p>\n<blockquote>\n<p>X86-32下指令集通用寄存器数量为8个，x86-64下为16个</p>\n</blockquote>\n<p>至多只有一个操作数在内存中，另一个操作数为立即数或寄存器</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210517204354665.png\" alt=\"image-20210517204354665\" /><figcaption aria-hidden=\"true\">image-20210517204354665</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210517204446891.png\" alt=\"image-20210517204446891\" /><figcaption aria-hidden=\"true\">image-20210517204446891</figcaption>\n</figure>\n<p><em>源自 网络PDF</em>——<a href=\"https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwimmc7O39DwAhV5yYsBHdS2CHMQFjAAegQIAxAD&amp;url=http%3A%2F%2Fimages.china-pub.com%2Febook4930001-4935000%2F4934543%2Fch02.pdf&amp;usg=AOvVaw0yJuRWmzjtj41FR6ld_Vmm\">X86处理器架构</a></p>\n<h1 id=\"sharc汇编\">SHARC汇编</h1>\n<p><a href=\"\">《Assembler and Preprocessor Manual(including the ADSP-BFxxx, ADSP-21xxx, ADSP-TSxxx)》</a></p>\n<h2 id=\"visualdsp\">VisualDSP++</h2>\n<p>以下是ADI官网对VisualDSP++（以下简称VDSP）的解释，本质上是个集成软件开发和调试环境（IDDE）。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210520005659254.png\" alt=\"image-20210520005659254\" /><figcaption aria-hidden=\"true\">image-20210520005659254</figcaption>\n</figure>\n<p>汇编器的操作取决于两种类型的控制：汇编器指令和汇编器开关。</p>\n<blockquote>\n<p>Assembler operations depend on two types of controls: <strong>assembler directives</strong> and <strong>assembler switches</strong>.</p>\n</blockquote>\n<p>VDSP支持以下三种不同的汇编器：</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210520010438229.png\" alt=\"image-20210520010438229\" style=\"zoom: 67%;\" /></p>\n<p>DSP汇编开发者需要先熟悉以下内容：</p>\n<blockquote>\n<ul>\n<li><p>“<em>Writing Assembly Programs</em>” on page 1-3</p></li>\n<li><p>“<em>Using Assembler Support for C Structs</em>” on page 1-21</p></li>\n<li><p>“<em>Preprocessing a Program</em>” on page 1-24</p></li>\n<li><p>“<em>Using Assembler Feature Macros</em>” on page 1-25</p></li>\n<li><p>“<em>Generating Make Dependencies</em>” on page 1-37</p></li>\n<li><p>“<em>Reading a Listing File</em>” on page 1-38</p></li>\n<li><p>“<em>Enabling Statistical Profiling for Assembly Functions</em>” on page 1-38</p></li>\n<li><p>“<em>Specifying Assembler Options in VisualDSP++</em>” on page 1-173</p></li>\n</ul>\n</blockquote>\n<h2 id=\"总览\">总览</h2>\n<p>汇编器 将 <strong>汇编源(.asm)</strong>、<strong>数据(.dat)</strong> 和 <strong>头文件(.h)</strong> 三者整理成可执行可链接的格式（ELF），也就是一个标准的 <strong>二进制文件(.doj)</strong>。</p>\n<p>另外，汇编器还将生成一个 <strong>列表文件(.lst)</strong>，展示二进制文件和源文件之间的联系。</p>\n<p>也就是说，编译成功后，.doj和.lst文件就是其编译结果。</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210520011656751.png\" alt=\"image-20210520011656751\" style=\"zoom:67%;\" /></p>\n<blockquote>\n<p>Figure 1-1 shows a graphical overview of the assembly process. The figure shows the preprocessor processing the assembly source (.asm) and header (.h) files.</p>\n<p>By default, the assembler processes an intermediate file to produce a binary object file (.doj) and an optional listing file (.lst).</p>\n</blockquote>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210520012328329.png\" alt=\"image-20210520012328329\" style=\"zoom:67%;\" /></p>\n<h2 id=\"编写\">编写</h2>\n<ul>\n<li><p>Assembler directives are coded in assembly source files.</p></li>\n<li><p>The directives allow you to <strong>define variables</strong>, <strong>set up hardware features</strong>, and <strong>identify program sections</strong> for placement within processor memory.</p></li>\n<li><p>The assembler uses directives for guidance as it translates a source program into object code.</p></li>\n</ul>\n<p>注意：</p>\n<blockquote>\n<ul>\n<li><p>Do not use a <strong><em>word processor</em></strong> that embeds special control codes in the text.</p></li>\n<li><p>Use an <code>.asm</code> extension to source file names to identify them as assembly source files.</p></li>\n</ul>\n</blockquote>\n<p>可以使用像 <code>batch-file</code> 和 <code>makefile</code> 这样的命令行工具来汇编你的源文件。</p>\n<p>列表文件还提供了关于导入的C语言数据结构的信息。</p>\n<h2 id=\"问题解决\">问题解决</h2>\n<h3 id=\"问题一\">问题一</h3>\n<p><strong>现象</strong>：出现如下图所示的头文件缺少</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210520095711.png\" alt=\"image-20210520090023689\" /><figcaption aria-hidden=\"true\">image-20210520090023689</figcaption>\n</figure>\n<p><strong>原因</strong>：<code>.boj</code>文件和其所依赖的 <code>.h</code> 头文件相对路径不一致，或项目文件的绝对路径与原来创建时不一致。</p>\n<p><strong>例如</strong>：从文件 <code>Debug/system/startup_Idf/app_IVT.doj</code> 中可以看出，该文件的创作者是将其放置在 <code>D:\\ADSP\\workspace\\LED_test\\Debug</code> 下的，因此需要改变该项目文件的位置。</p>\n<p><strong>解决方法</strong>：在原创作者的绝对路径下放置该项目文件。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210520095708.png\" alt=\"image-20210520090936369\" /><figcaption aria-hidden=\"true\">image-20210520090936369</figcaption>\n</figure>\n","categories":["Computer"],"tags":["assembly","x86"]},{"title":"给Mac Big Sur修改外接显示器的分辨率","url":"/2022/01/23/Computer/2022-01-23-%E7%BB%99Mac-Big-Sur%E4%BF%AE%E6%94%B9%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8%E7%9A%84%E5%88%86%E8%BE%A8%E7%8E%87/","content":"<p>本文参考 《<a href=\"https://zhangzi.life/articles/1605255382000\">Mac 外接显示器色彩问题</a>》和 《<a href=\"https://sspai.com/post/57549#!\">为 macOS 10.15 开启 HiDPI，让 2K 显示器更舒适</a>》两篇文章。</p>\n<p>刚买来新的 HUAWEI Mateview 无线版，显示器分辨率为 <code>3840*2560</code> ，该死的 <code>3:2</code> 屏幕啊，我图啥......</p>\n<p>外接2015年的Macbook Air的MiniDP口输出准4K分辨率。</p>\n<p>但是，但是，但是~~Air只能输出 <code>16:9</code> 和 <code>16:10</code> 的分辨率，让我搞了整整一下午来调整这个分辨率，4个小时啊。</p>\n<p>算了，总结一下吧。</p>\n<h1 id=\"关闭sip\">关闭SIP</h1>\n<p>Big sur 和之前版本不同，需要的操作如下：</p>\n<ol type=\"1\">\n<li>关机</li>\n<li>长按 <code>Command</code> 键 和 <code>R</code> 键（都不要松开），短按 开机电源键，直到出现进度条才能松开。</li>\n<li>找到终端，然后输入 <code>csrutil authenticated-root disable</code> ，出现 <code>successfully</code> 字样就算是成功了。（之前的版本是 <code>csrutil disable</code> ）</li>\n</ol>\n<h1 id=\"查询设备号\">查询设备号</h1>\n<ol type=\"1\">\n<li>先断开显示器，输入如下代码：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ioreg -l | grep <span class=\"string\">&quot;DisplayVendorID&quot;</span></span><br><span class=\"line\">ioreg -l | grep <span class=\"string\">&quot;DisplayProductID&quot;</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\" type=\"1\">\n<li>再插上显示器，再次运行上方代码。</li>\n<li>两次得出来的不同的设备号就可以区分哪个 <code>VendorID</code> 和 <code>ProductID</code> 是外接显示器的。</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220123175000229.png\" alt=\"image-20220123175000229\" /><figcaption aria-hidden=\"true\">image-20220123175000229</figcaption>\n</figure>\n<ol start=\"4\" type=\"1\">\n<li>记下那串代码，并将外接显示器的两个ID转换成对应的十六进制数， 如 <code>8950</code> 即 <code>22f6</code> , <code>28194</code> 即 <code>66e2</code></li>\n</ol>\n<h1 id=\"生成配置参数\">生成配置参数</h1>\n<ol type=\"1\">\n<li>在用户目录 ，即 <code>~</code> 下，使用 <code>DisplayVendorID-xxxx</code> （<code>xxxx</code> 即对应外接显示器 Vendor 号的16进制 ）创建一个文件夹。</li>\n<li>然后在对应文件夹下创建一个 使用 <code>DisplayProductID-yyyy</code> （ yyyy` 即对应外接显示器 Product 号的16进制 ）创建一个无后缀名的文件。</li>\n<li>到 <a href=\"https://codeclou.github.io/Display-Override-PropertyList-File-Parser-and-Generator-with-HiDPI-Support-For-Scaled-Resolutions/\">Scaled Resolution for your Mac</a> 网站生成配置参数，在红色框中分别填入你外接显示器的对应参数，和你想使你的显示器所呈现的分辨率参数。</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220123175609151.png\" alt=\"image-20220123175609151\" /><figcaption aria-hidden=\"true\">image-20220123175609151</figcaption>\n</figure>\n<ol start=\"4\" type=\"1\">\n<li>复制右侧的 xml 代码至刚刚的 <code>DisplayProductID-yyyy</code> 文件中，并保存。</li>\n</ol>\n<h1 id=\"导入系统\">导入系统</h1>\n<p>在Big Sur系统下，根目录 <code>/</code> 是禁止写入的，需要稍微用点技巧（走点弯路）。</p>\n<ol type=\"1\">\n<li>新建一个文件夹，将解除SIP之后的 <code>/</code> 挂载到某个地方，如下方所示：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir ~/nvme</span><br><span class=\"line\">sudo mount -o nobrowse -t apfs /dev/disk1s5 ~/nvme/</span><br></pre></td></tr></table></figure>\n<p>其中，<code>/dev/disk1s5</code> 中的 <code>/disk1s5</code> 要通过 <strong>磁盘工具</strong> 各自查看自己的 <strong>设备</strong> ，最后面的 <code>s1</code> 去掉不写。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220123173550666.png\" alt=\"image-20220123173550666\" /><figcaption aria-hidden=\"true\">image-20220123173550666</figcaption>\n</figure>\n<ol start=\"2\" type=\"1\">\n<li>然后就可以 <code>cd</code> 进去查看对应目录下的文件内容，但是所有读写操作都需要加上 <code>sudo</code> 才可以。</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~/nvme/System/Library/Displays/Contents/Resources/Overrides</span><br><span class=\"line\">ls</span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220123173806535.png\" alt=\"image-20220123173806535\" /><figcaption aria-hidden=\"true\">image-20220123173806535</figcaption>\n</figure>\n<ol start=\"3\" type=\"1\">\n<li>把 <code>~/DisplayVendorID-xxxx</code> 复制到 <code>~/nvme/System/Library/Displays/Contents/Resources/Overrides</code> 里面：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo cp -r ~/DisplayVendorID-22f6 ~/nvme/System/Library/Displays/Contents/Resources/Overrides/DisplayVendorID-22f6</span><br></pre></td></tr></table></figure>\n<p>复制完毕之后可以再 <code>ls</code> 查看，就存在了。</p>\n<ol start=\"4\" type=\"1\">\n<li>但是这种复制只是一种暂时的，重启之后就会被镜像文件所覆盖，所以要重新 snapshot 一下。<mark style=\"font-weight: 900;\">注意，这一步一定要做，否则重启就失效了。</mark></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo bless --folder ~/nvme/System/Library/Displays/Contents/Resources/Overrides --bootefi --create-snapshot</span><br></pre></td></tr></table></figure>\n","categories":["Computer"],"tags":["mac","Big Sur","外接显示器"]},{"title":"Type-C 扩展器 方案指南（DP Alternative Mode 篇）","url":"/2021/05/25/Hardware/2021-05-25-Type-C-%E6%89%A9%E5%B1%95%E5%99%A8-%E6%96%B9%E6%A1%88%E6%8C%87%E5%8D%97%EF%BC%88DP-Alternative-Mode-%E7%AF%87%EF%BC%89/","content":"<p>收藏转载自：<a href=\"https://zhuanlan.zhihu.com/p/342165494\">zhuanlan.zhihu.com</a></p>\n<h1 id=\"前言\">前言</h1>\n<p>本篇还是USB-C 转接器指南贴，由于硬件上的不同，后续还会有一篇雷电专用的指南作为区分</p>\n<p>这篇内容其实在2016年的时候就有写的意向了（笑），当时12寸 Macbook 刚推出，Macbook Pro 也刚更新为全Type-C模具。</p>\n<p>当时对先进转接器需求最强烈的其实还是12英寸的用户，由于12英寸Macbook 只搭载了一个Type-C，还不是雷电（是的，Mac全系列唯一有Type-C却不是雷电的机型），导致接口丰富兼顾充电的雷电Dock产品无法正常使用，造成了外设和充电你死我活的尴尬境地</p>\n<p>所幸戴尔WD15的推出缓解了这个尴尬局面，然而17年之后Macbook 产品线再次被放弃，于此同时市面上类似的单Type-C 模具笔记本极为稀少，后继的Macbook Pro和 Macbook Air 都可以通过 PD充电+DA300的方式满足便携扩展需求，因此 放弃了在便携扩展器领域的进一步探索</p>\n<p>然而有趣的是从17年到20年，居然没有一个便携转接器能够在功能参数上全面追赶DA300，甚至有某品牌转接器烧毁Macbook 接口的负面新闻广为流传，抽了闲暇时间做了一定程度的调查，借此机会把目光重新放回了转接器领域</p>\n<p>这篇文章依然会是按照我先前的风格，从IC层面对市面上绝大部分的产品进行分类和归纳，从IC层面做出指南</p>\n<p><strong>不会对具体的产品进行推荐，适合自己的才是最好的，没空一一了解消费能力和理念，请见谅</strong></p>\n<p><strong>本文长达近 一万七千字，由于转接器硬件需求复杂，建议还是通读</strong></p>\n<h1 id=\"目录\">目录</h1>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-2cfa4f5dd53c8f74f80203245dca1435_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<h1 id=\"总结与指南\">总结与指南</h1>\n<p>总的来说转接器产品有两大特点不同于 朴素认知</p>\n<ul>\n<li>作为转接器的核心部件PD控制器并不影响转接器的主要功能（视频转换和USB、扩展）</li>\n<li>转接器接口多寡并不和其 成本 呈正相关 （原本可以给的接口会被阉割，市场内的常见手段），将多种接口整合变少才是本事（就像你用来扩展的Type C口）</li>\n</ul>\n<p>因此通过接口多寡来计算性价比（价格/接口）基本只能陷入坑货泥潭</p>\n<p>下图是目前常见的 支持 DP Alt Mode的控制器总结，由于PD控制器门槛不高，陆续会有MCU厂家涉足该领域，但和主流硬件选用相比不足为提。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-b6b31e69d199a7bfcfc997f6c5d87cb6_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>此外 新款芯片一般至少需要一年的周期才能真正被采用到新产品里面，因此盲目追新 方案大可不必</p>\n<hr />\n<ul>\n<li><strong>推荐</strong></li>\n</ul>\n<p>尽管各头部厂商 由于历史原因或者其他的一些因素多少都有一些坑货，而下面的白莲花制造商也少之又少，即使是 Belkin 也能找出一些 智商税产品</p>\n<p>但是原则上依然推荐 HP，Dell，苹果，微软的新品转接器，这些厂子的转接器不分高端低端，出手即是代表性产品，但也导致开发成本以及最终价格极高</p>\n<p>这些头部厂商的产品也会有一个共性的缺点就是不会在自己的产品上集成读卡器功能</p>\n<p>其余的，功能和做工就拉不开多少差距了，很难说有完美的，各方面都做的很优秀的产品</p>\n<p>总结一下本文提到的带有拆解文章的产品，转接器功能需求复杂，产品或多或少存有不足，仅作参考，长期更新</p>\n<p>依然不建议依赖该表，建议通读</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-8660a99fbe26365d9a3d7488288971f6_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<hr />\n<ul>\n<li><strong>排雷</strong></li>\n</ul>\n<p>这个市场内显著的坑货有两大类</p>\n<p>一类是长得像 Belkin 的 非Belkin 产品</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-ed0fcb1bc9f15717df5a0549ff865e81_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-395b6b257e5b4bfba528ae61084b04d9_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>这类产品一般都是VIA 的VL100系公模产品， 本来做的像样的也有，比如在我的专栏中拆过的Satechi</p>\n<p>但由于对压缩成本的追求，VIA的公版设计被无限压缩，导致市面上一大批的公模VIA产品坑点奇多，下面的雷至少踩两个：</p>\n<ul>\n<li>质劣价高（物料成本20块左右，直接抄公版设计无需研发成本，防护全无的扩展坞可以卖到150以上，200，300 也是常见）</li>\n<li>供电稀烂，带不动一块移动机械硬盘的读写耗电</li>\n<li>屏蔽基本无，是一个巨大的2.4Ghz污染源，干扰附近的蓝牙，WIFI设备的正常工作</li>\n<li>工厂品控稀烂</li>\n</ul>\n<p>涉及品牌包括 绿联，Orico，飞利浦（转接器业务已经被别家收购），Unitek，倍思</p>\n<p>国内能叫的上名字的配件厂几乎全部中枪，同样是 VL100系主控，没一家的做工和防护能比得上Satechi（苹果合作款）</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-3dfff693a1575ca58b5c3b089f8c59c5_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-fd6a19341d4d279adceae25faa1f4837_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>另一类是长得像苹果的非苹果产品</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-222af6d53c029fc372a794c438375936_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>这类产品同样有VIA 阵营的VL100系产品牵涉其中</p>\n<p>但在低端攻城掠地的 龙讯LT8711H ，安格 AG9321 同样也籍由这样的外型活得滋润（物料成本估计 10块左右，售价一般在30，40元水平）</p>\n<p>此外 Fresco 的 FL5002 公版设计也是籍由这种 外形活得滋润，例如 小米ZJQ01TM[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_1\">1]</a> ，联想也是[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_2\">2]</a>，尽管TVS防护尚可，但是绝对不会装配 屏蔽罩，另外FL5002 发热较大</p>\n<p>还有一类较隐蔽坑货就是自己做标致的外壳，内藏稀烂的硬件</p>\n<p>外形就请自行想象了，以下三款图内PCBA的售价都在10元内</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-59012a67ebb1e0efd1eb6c053219cb6d_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-17fd6a55704998d450f3a29924a272f2_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-ceb7df6aa2250a6a365ee70f3d83296d_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<h1 id=\"qa扫盲\">Q&amp;A扫盲</h1>\n<p>Q：为什么转接器标明的可以支持4K 60Hz显示输出，我买了以后不管怎么鼓捣都只能4K 30Hz？</p>\n<p>A：这类问题基本是由于转接器 在DP1.4下支持4K 60Hz，在DP1.2 下支持到4K 30Hz，你的Type-C接口只支持到DP1.2 造成了跟描述不同的问题，下文会有详细的原理说明和计算来解释原理和区别</p>\n<p>Q：为什么我的转接器插上东西之后，WIFI/蓝牙/无线接收器就卡的不行？</p>\n<p>A：老生常谈的问题，由于转接器的电磁屏蔽差劲，导致USB3.0工作时辐射出来的2.4GHz 射频信号[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_3\">3]</a>干扰了处于相近频段的无线设备，2.4GHz WIFI，蓝牙，无线接收器都处于这一频道；总之建议更换配件一劳永逸；凑合的办法是用金属箔包住转接器可以减少干扰</p>\n<p>Q：这些USB转接器不是都从USB转接而来的吗？据我所知USB3.0只有5Gbps速度，怎么做到输出4K@60Hz的？</p>\n<p>A：那种纯靠USB转接视频输出的应用叫做Display Link，已经是比较有年岁的技术了。本篇涉及的主要技术是所谓的 Display Alt Mode，是将DP 信号直接跟USB一起塞到了 Type-C接口里，二者井水不犯河水。DP Alt Mode 借助 Power Delivery 报文[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_4\">4]</a>来对Type-C 接口进行具体的配置，平常时Type-C只是一个普通的USB接口，链接特殊的配件可以把 ”可选模式“唤醒， 即 ”Alternative Mode“ ，从而在Type-C中直接引入DP信号输出视频，而不是通过USB转接</p>\n<p>Q：为什么要将USB-C 和雷电的转接器做区分呢，二者有什么区别？</p>\n<p>A：雷电转接器仅能配合雷电接口正常工作，设备会印有雷电logo，而多功能 USB-C 适配范围要广泛的多，除了雷电接口以外，常规计算机搭载的 多功能Type-C 不仅在Windows或者Mac OS，在Chrome OS, Ubuntu, RHEL 8都能使用，甚至 苹果 安卓阵营的移动平台（比如iPad Pro 以及 一加7 Pro，三星S7手机等）以及 Switch（注意兼容稀烂），都可以使用相同的硬件设计来完成转接任务</p>\n<p>目前最先进的单口Type-C 方案可以支持 单 8K@30Hz或者双4K<span class=\"citation\" data-cites=\"60Hz\">@60Hz</span> 输出，尽管比 JHL7440雷电方案 的40Gbps 输出能力还是逊色，但是满足日常的使用需求已经完全不成问题，因此这里先从 USB-C转接器进行归类介绍</p>\n<p>Q：是否能传输视频信号能充电的Type-C接口就是多功能Type-C？</p>\n<p>A：本文的多功能Type-C指狭义的，支持DP Alt Mode 的Type-C 接口（下文会有进阶介绍），包括雷电3雷电4接口也支持这个技术，本文介绍的所有配件都可以在雷电接口上使用。</p>\n<p>然而这里有几个盲区，1.除了DP Alt Mode，HDMI Alt Mode[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_5\">5]</a>在技术层面上也是存在的，然而没有厂商支持该模式 。 2. 如上文提到过的Display Link 技术可以在通过常规的USB接口（无论Type-A，Type-B，Type-C）传输视频信号，但是需要额外的驱动，在Windows，Mac OS，Linux，Chrome OS，以及Android 都有广泛的支持，比如目前比较热门的VR头显 Oculus Quest2 用的串流技术即是 Display Link而非高端设备采用的 Alt Mode USB。</p>\n<p>此外还有MHL技术以及支持MHL技术的 Alt Mode也可以通过USB 物理接口直接传输视频信号，但基本限于手机应用，而 MHL Alt Mode 同样也没厂商做，所以不提了</p>\n<p>Q：那么DP Alt Mode 的 Type-C配件一般是什么样的呢？</p>\n<p>A：本次的分类几乎涵盖了所有类别的 非雷电非DisplayLink产品（Display Link 有空也许会在后期也更新进来），Alt Mode 配件和 Display Link配件的区别在于，Display Link的配件可以在 Type-A接口上正常工作，在系统中需要安装Display Link 驱动（Chrome OS已集成） 才能输出视频信号，而 DP Alt Mode配件不需要驱动就可以外接显示器，但只能在支持的 Type-C 主机接口上运行正常。（咋一看Display Link 确实适用范围更广，但是性能缺陷是绕不开的问题）</p>\n<p>涉及的产品主要形态如下：</p>\n<p>1.Type C 转换为任意视频接口的单转单线缆</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-90fca4eddcbd18bb79b5168133732cc6_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>2.便携型适配器，无论有或没有PD Pass Through 功能，都可以无需外接电源使用</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-10d2580b3567724941d4a97daacaa186_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<ol start=\"3\" type=\"1\">\n<li>坞站，通常需要大型的外置DC电源支持才能使用</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-430f652dde5f98949f553f875a9dd2f8_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<h1 id=\"前置进阶科普\">前置进阶科普</h1>\n<p>这里就不啰嗦接口和协议的区分问题了，直接进入正题</p>\n<p>要先了解 全功能Type-C的大致机理，才能了解其配件的运作模式</p>\n<p>更进一步地，了解配件功能上限/功能潜力，也能把握未来配件的发展方向</p>\n<ul>\n<li><strong>DP Alt Mode Type-C性能维度</strong></li>\n</ul>\n<p>Type-C 的DP Alt Mode 模式被激活后可以维持三大功能同时正常运作，分别是供电、DP传输以及USB 传输，因此本文中Type-C的的性能按照 供电能力、DP输出能力、USB传输能力 这三条作为三维来衡量性能，以下为三维分别的分级：</p>\n<p><strong>供电能力</strong>：</p>\n<p>由于桌面平台的 多功能Type-C/雷电 不支持电源输入，因此无法与移动平台比较，本文只会罗列参数而不会具体比较</p>\n<p><strong>USB 带宽</strong>：</p>\n<p>在先前的移动硬盘指南中提及过目前先进的USB协议类型，Type-C Alt Mode 中常见的USB 带宽模式有以下几种</p>\n<p>USB3.2 Gen1 （5Gbps） 比如15~17年的12英寸 Macbook，比如华为Matebook 13，14 包括一加 7 Pro 等手机应用</p>\n<p>USB3.2 Gen2 （10Gbps） 比如所有计算机搭载的雷电3及雷电4接口，桌面PC 可以使用的UPD2018 DP alt mode Type C扩展卡，Surface Laptop 3 等应用</p>\n<p>理论上目前的技术是可以使Alt Mode支持 仅USB2.0 以及USB3.2 Gen2x2 模式的，但并没有实际产品可以参考</p>\n<p><strong>视频带宽</strong>：</p>\n<p>既然名为DP Alt Mode，那么在激活状态下输出的视频信号则为DP 信号</p>\n<p>类似于USB协议，DP协议的迭代也可以提高相同接口下的传输速率</p>\n<p>HBR2（DP1.2） 每Lane 5.4Gbps的理论传输速率，由于8b/10b编码，有效带宽为4.32Gbps</p>\n<p>HBR3（DP1.3&amp;DP1.4） 每Lane 8.1Gbps [<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_6\">6]</a>的理论传输速率，由于8b/10b编码，有效带宽为6.48Gbps</p>\n<p>常见显示分辨率所需带宽如下[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_7\">7]</a>：</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>分辨率</th>\n<th>所需的最小带宽</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>1 x FHD (1920 x 1080) 显示屏 <span class=\"citation\" data-cites=\"60\">@60</span> Hz</td>\n<td>3.2 Gbps</td>\n</tr>\n<tr class=\"even\">\n<td>1 x QHD (2560 x 1440) 显示屏 <span class=\"citation\" data-cites=\"60\">@60</span> Hz</td>\n<td>5.6 Gbps</td>\n</tr>\n<tr class=\"odd\">\n<td>1 x 4K (3840 x 2160) 显示屏 <span class=\"citation\" data-cites=\"30\">@30</span> Hz</td>\n<td>6.2 Gbps</td>\n</tr>\n<tr class=\"even\">\n<td>1 x 4K (3840 x 2160) 显示屏 <span class=\"citation\" data-cites=\"60\">@60</span> Hz</td>\n<td>12.5 Gbps</td>\n</tr>\n</tbody>\n</table>\n<p>可以看到，4K@60Hz所需带宽仅需2 Lane 的 HBR3 DP 通道即可满足，而HBR2 则不行。这是买了 支持 4k@60Hz实际却只能30Hz 这个问题的核心所在</p>\n<ul>\n<li><strong>DP Alt mode 主机口构成</strong></li>\n</ul>\n<p>多功能Type-C 主机接口本质上只要把USB和DP的线路塞在一个Type-C插头里就可以。但是为了灵活调用和防止Type-C正反插酿成悲剧，在接口屁股上又加了multiplexer（多路复用器，以下简称MUX）[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_8\">8]</a>将USB和DP信号的物理线路随心所欲地排布在Type-C接口中，另外也增加了PD控制器用来控制MUX；同时这个控制器可以跟下游的PD控制器沟通，一旦对上暗号，那么两端就可以按照商量好的 DP Alt Mode 来控制MUX拍好输出线路的顺序，这样就可以USB 归USB，DP归DP了。</p>\n<p>可以从下图的功能框图看到，MUX和PD控制器的上游，则是主机的USB Host（USB主控）以及 DP Source（DP信号源）， Type-C的性能三维就是由这些上游的应用以及MUX本身的性能所决定的了（MUX走USB和DP信号，会影响这二维的性能）</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-322b8700e520c9d7f46d2c077d9c675e_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>举具体的例子</p>\n<p>例如USB 带宽方面，12英寸Macbook 之所以只能支持到 5Gbps的USB 3.2 Gen1 传输，是因为上游的USB Host只支持到 5Gbps。而UPD2018 的上游USB Host采用的是 ASM1142，一颗 USB3.2 Gen2主控，因此可以支持到10Gbps，但是Host上游的PCIe带宽只给了PCIe 3.0 X1，因此实际上也是不满10Gbps的</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-4b2043b71e05f2e51ab65dded0cf3516_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>DP （视频）带宽方面，很简单粗暴，直接看主机GPU的DP支持就可以了</p>\n<p>例如英特尔10代之前的移动端处理器核显仅支持DP1.2（HBR2）输出，因此导致18年19年款的13英寸 Macbook Pro 即使装备了支持DP1.4（HBR3）的Titan Ridge 雷电控制器，由于核显的拖累，依旧只能DP1.2 输出（笑）</p>\n<p>MUX支持方面，缺少比较直观的例子，拿雷电设备举例：早期的雷电3设备（Alpine Ridge时期的JHL/DSL6x40 系列）由于只支持 DP1.2 的信号源，在触发为DP Alt Mode之后也是只支持DP 1.2 输出；USB 也会受制于MUX ，比如 普瑞科技 的 PS8743 和 PS8750 作为母口端的MUX只支持USB3.2 Gen1 以及 HBR2 [<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_9\">9]</a></p>\n<ul>\n<li><strong>DP Alt mode 设备口构成</strong></li>\n</ul>\n<p>如下图所示[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_8\">8]</a>总体来说跟主机口没什么区别，也还是 PD 控制器加上 MUX的形式，区别只在于这里的MUX是解复用功能</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-9ced86eb508a76eefd11c9ffaeec4aa4_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>但是，但是啊，我们已经拆过不少 Type-C转接器了，这些转接器里面 除了 DockCase DPR01S （DeMUX为PS8822）以外，<strong>为什么只有PD控制器而没有MUX？！</strong>这不是跟指导文档背道而驰吗</p>\n<p><a href=\"https://www.zhihu.com/column/c_1326635507015319552\">先进型 Type-C 扩展设备拆解存档</a></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-b6546a28845e426a25b971ce7fcab919_ipico.jpg\" alt=\"图标\" /><figcaption aria-hidden=\"true\">图标</figcaption>\n</figure>\n<p>但其实文档介绍的是基于完整的 Type-C 接口所设计的结构，即设备端是具有完整的Type-C接口，需要独立的线缆进行连接的情况</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-88b4440cae89d86b165ebdf938fee0ca_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>在常规情况下，如果采用的是尿袋式的设计,比如下面这种Type-C 定义直接焊死而不是给一个Type-C 口随意插，那么在设计时就不需要 MUX来应对Type-C正反插情况了，在Cypress的指导中也有提及[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_10\">10]</a></p>\n<blockquote>\n<p>If you are using type-C receptacle and plug combination you will not need a switch. If you have both USB-C connectors as receptacles, connected via a type-C cable (EMCA) then you will require a switch. DP source (FPGA) &lt;----&gt;Switch&lt;------&gt; USB-C receptacle &lt;---------------------&gt; USB-C plug &lt;------&gt; DP sink (FPGA) otherwise, DP source (FPGA) &lt;-----&gt; Switch &lt;-----&gt; USB-C receptacle &lt;---------- USB-C cable ----------&gt; USB-C receptacle &lt;-----&gt; Switch &lt;-----&gt; DP sink (FPGA)</p>\n</blockquote>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-26ab46bc6d083bd1a166199a4080a03e_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>当然，设备端的MUX也会影响最终性能，就如水路一样，最后的出水速度是受到整条链路上所有环节的影响的</p>\n<p>经过了设备端的解复用之后，留给下游的又是简单纯粹的 USB 协议口和 DP 协议口（USB2.0 和 DP的 Configuration 通道仍需要 PD控制器转发来保证正常功能），在原先开发的各种USB 玩法 以及 DP玩法 可以直接捡起来套上去，不得不说这样的Type-C 开发出来对原先的硬件环境十分友好，和先前仅有的区别是，原本井水不犯河水的 USB 和DP 配件，如今由于 DP Alt Mode的存在被整合到一块电路板上了。</p>\n<p>当然，遗憾也是有的，由于对广大的兼容性（免驱）考虑，很多应用难以得到推广</p>\n<p>比如转 4G无线网卡的应用</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-8f57bae7c539aade5bd5e273dce8664d_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>另外也是出于成本的考虑以及对 苹果模式的一味模仿，尿袋式的转接器设计依然大行其道。好好设计一个线缆收纳很难吗？</p>\n<ul>\n<li><strong>USB与DP 进阶硬件认识</strong></li>\n</ul>\n<p>在硬件上将 PD 控制器和 MUX 融入 Type-C以后，事实上 Type-C就可以被凹成各种形状了，但主流 的模式其实就两种（按性能分为两种，实际VESA对应定义了6种[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_4\">4]</a>）</p>\n<p>首先我们需要对 USB 和 DP 有 基本的硬件认知</p>\n<p>目前的信号传输依然主要依靠铜线缆，差分对则是经典的用于铜缆系统的抗干扰硬件设计[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_11\">11]</a></p>\n<p>简单的来说，我们使用两根线来传输一个信号，即一个差分对一个传输通道</p>\n<p>在USB3.2 Gen1和Gen2 中，他们使用一组两个差分对四根线分别实现 5Gbps 和 10Gbps 的收发活动即SSTX 差分对和SSRX 差分对</p>\n<p>R→Receive 收</p>\n<p>T→Transmit 发</p>\n<p>因此在USB中 一组收发 可以实现 10Gbps的 双向传输，USB3.2 Gen2x2可以启用两组共四对信号，因此可以实现 20Gbps 双向传输（是的，Gen2不需要D+D-来传输，Gen2 跟 Gen2x2 只是量变，Gen1 到 Gen2 才是质变，而只使用D+D- 的USB2.0则跟USB3.0可以算是两个物种了）</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-393f880610f4e5cd987f606c436ae1ee_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>一个完整的DP接口同样含有4对主要连接差分对，Mian Link Lane 0~3 (以下简称ML）</p>\n<p>在HBR2下可以完成 每Lane 5.4Gbps的单向传输，HBR3下则是8.1Gbps</p>\n<p>除此之外，DP接口还内置了Configuration 1&amp;2 用于协议配置，Auxiliary Channel +&amp;- （以下简称Aux对）用于音频传输，有趣的是，DP同样可以在仅 ML0，ML1 两条Lane的模式下工作</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-c339e6274c4434320a960af7ddb4e3e9_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>那么，把USB 限制在 2对差分模式，DP也限制在2对差分模式，可以拼在一起吗？</p>\n<ul>\n<li><strong>DP Alt Mode 主要模式</strong></li>\n</ul>\n<p>答案是肯定的</p>\n<p>用于通讯握手的PD协议必须占用一条 Configuration Channel（以下简称CC），电源线和接地定义也不能动，不过剩下的也足够其他协议分的了</p>\n<p>常规情况 USB 模式时 Type-C 的针脚分布如下</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-bb880cb32b70197fb69aa5e48e7c759a_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>当激活 DP Alt Mode 2Lane （Multi-Function DisplayPort,MFDP) 时，针脚功能如下</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-9d8fe2b6caf88d296c112dd79dbfcb7f_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>当激活成 DP Alt Mode 4Lane 时：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-bffd5ba676c6ec65ec536294f20c4311_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>有没有觉得USB2.0 由于正反插支持占用了4个针脚，只有两个有效，而且480Mbps这么孱弱的速度塞进Type-C实在是丢人？</p>\n<p>如果把USB2.0的针脚设定为USB3.2 Gen1或者Gen2 就好了，这样的模式也是有的，被称为Virtual Link，是为VR应用所开发的，Nvidia 的2000系 和AMD 的6000系显卡所搭载的Type-C 就支持该模式[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_12\">12]</a></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-18ecc3a36f700f8677e5990b3aa7fa8e_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>注意了，此模式不在 DP Alt Mode的范畴，常规设备是不支持也触发不了这个模式的。这个模式抛弃了USB2.0 链路导致该状态下是无法正常支持键鼠之类的应用。当然，作为专机专用模式也不用在意这种问题了</p>\n<p>在Virtual Link 模式下，Type-C和常规 Type-C线缆可以达到非雷电模式下的最高速度，高达4*8.1+10=<strong>42.4Gbps的输出带宽外加10Gbps的数据接收带宽</strong>，尽管相比标称<strong>双向40Gbps</strong>的雷电3和雷电4仍然有显著差距，但是满足绝大部分应用是完全不成问题的了。</p>\n<ul>\n<li><strong>如何触发 DP Alt Mode</strong></li>\n</ul>\n<p>如上文提到的， 不管是DP Alt Mode 还是上面提到的 Virtual Link，抑或是雷电，都是作为Alt Mode 触发的，而触发方式，都是通过Power Delivery 的通信功能</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-4945c8109a8ac189e840096ceec01824_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>Type-C Alt Mode 大致配置流程如下：</p>\n<ol type=\"1\">\n<li>USB 连接 通过CC侦测到</li>\n<li>VBUS 引脚 提供默认电源配置 5V@500mA</li>\n<li>VBUS 所需的额外USB电力传输可以进行协商，Battery Charge 1.2（BC 1.2）或USB PD 都可以选择</li>\n<li>使用 结构化 供应商定义报文（VDM） 需要USB PD 来发送来协商 Alt Mode 握手</li>\n<li>USB 枚举</li>\n<li>如果 DP Alt Mode 协商已经完成，继续进行DP link training来建立DP连接</li>\n<li>USB和DP频道准备就绪进行Type-C 数据和视频信号传输。</li>\n</ol>\n<p>更具体的 PD 报文内容和触发逻辑不是本篇重点，想具体了解的推荐TI的文档或者去VESA翻更具体的资料</p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//www.ti.com/lit/an/slva844b/slva844b.pdf%3Fts%3D1614791986776%26ref_url%3Dhttps%253A%252F%252Fwww.ti.com%252Fsitesearch%252Fdocs%252Funiversalsearch.tsp%253FsearchTerm%253DAlternate%2BMode%2BSupport\">PD Alternate Mode: DisplayPort</a></p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//www.ti.com/lit/an/slva844b/slva844b.pdf%3Fts%3D1614791986776%26ref_url%3Dhttps%253A%252F%252Fwww.ti.com%252Fsitesearch%252Fdocs%252Funiversalsearch.tsp%253FsearchTerm%253DAlternate%2BMode%2BSupport\">www.ti.com</a></p>\n<h1 id=\"产品实现\">产品实现</h1>\n<p>了解了 DP Alt Mode Type-C 的原理那么就可以观察他是怎么在产品上实现的了</p>\n<ul>\n<li><strong>典型 2Lane DP Alt Mode + DP1.2 产品拓补</strong></li>\n</ul>\n<p>直接用在国内销量极大的Type-C 转接器方案 VL100 系列所为案例了</p>\n<p>这是一个典型的VL103 转接器拓补，黄色 USB-C 为链接主机的上游接口，兰绿色为充放电专用的下游Type-C，典型应用可以参照Satechi 的多口Type-C转接器[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_13\">13]</a></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-60d85aec0bf111a1b96a72244a2f5400_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-cfaeb19dc5eb541b350a0c6fa38a0926_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic2.zhimg.com/v2-0941dac75faafcaddc4997a371b05f25_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>在这个应用中，VL103就是作为PD 控制器，负责下游Type-C 的PD和QC等协议的调度（因此充电Type-C口会有USB2.0定义用于握手，但其实不能挂载USB设备）</p>\n<p>同时VL103作为PD控制器也负责DP Alt Mode的调度，但VL103完全不干预USB3.0 和DP 链路的走线，直接连接USB Hub芯片VL817 和 DP to HDMI芯片PS176，而读卡器芯片则是挂在VL817下游，提供了两个读卡器口。</p>\n<p>此外，作为固定尿袋外形的转接器，这个拓补方案不需要MUX芯片</p>\n<p>需要注意的是，这类典型应用需要兼顾USB3.0接口，因此只能选择 2 Lane DP Alt Mode 模式，，再加上PS176只能支持DP1.2的问题，导致转出的HDMI接口同样只能支持到 2Lane DP1.2的支持上限 4K 30Hz</p>\n<p>相似类型的还有采用 Fresco FL7102 PD控制器为主控的绿联功能扩展坞（带SD卡槽版）[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_14\">14]</a></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-ef2d0e97afef9b1a26d267dd741d1faf_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>硬件拓补和上面的Satechi 基本相同，但又有略微的区别</p>\n<p>阳联 IT6564 对应 上个产品中的PS176，但 IT6564 可以将DP1.2 转换为 VGA和 HDMI两个输出（又是只支持 2Lane 的 DP1.2 输入，导致HDMI只能4k 30Hz输出。在绿联 CM260中 IT6564 可以获得 满血 4Lane DP1.2 输入 因此可以支持 4K 60Hz HDMI输出）</p>\n<p>在本应用中有 3<em>Type-A+ 一套转接器+网口共5个数据口，而常规USB3.0 hub 只能将一个USB扩展为 4个下游 USB，因此本应用中 套了两层GL3510（一个GL3510套在另一个下游，提供了共2</em>4-1=7个有效USB3.0接口） 一个被RTL8153B转为千兆网口，还有一个被GL224 转换为一套读卡器，有5个剩余USB下游口但只有3个被做出来，有两个被浪费了（笑）</p>\n<p>本应用中同样为了确保下游USB3.0 功能只能选择 2 Lane DP Alt Mode 触发，再由于IT6564只能支持DP1.2，因此HDMI还是只能支持到4k 30Hz</p>\n<p>使用该类型拓补的转接器是过去几年中的销售主力，兼顾USB3.x应用与4K 30Hz输出的转接器或者坞站基本都是这类结构，举几个常见的</p>\n<ol type=\"1\">\n<li>华为MateDock 2[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_15\">15]</a></li>\n<li>米物 Type-C 七合一多功能转接器 MWCMA01[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_16\">16]</a></li>\n<li>惠普HP USB-C to Multi-Port Hub USB-C多端口集线器[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_17\">17]</a></li>\n<li>ROG Phone (ZS600KL) ASUS Professional Dock[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_18\">18]</a></li>\n<li>小米 ZJQ01TM USB-C至HDMI多功能转接器[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_1\">1]</a></li>\n</ol>\n<ul>\n<li><strong>典型 2Lane DP Alt Mode + DP1.4（HBR3）产品拓补</strong></li>\n</ul>\n<p>DP1.2这么菜，导致 2 Lane DP模式只能支持输出4K 30Hz，那么我们引进DP1.4就能支持更高的带宽和分辨率了</p>\n<p>比如说DockCase DPR01S 支持到4K 60Hz 和 USB3.0应用共存[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_19\">19]</a></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-c14f66052bca51b903261fa9ca68be02_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>这里采用的PD控制器FL7112是绿联系列采用的FL7102的后继型号，此外由于搭载了完整的正反插Type-C，使用了 PS882 MUX芯片进行支持； 总体结构和上文的 FL7102 转接器差别不大，但是从MUX到 DP转换器都 选用了支持 DP1.4（HBR3）的型号，PS176 换成了 PS186 用以支持将 2Lane DP1.4 转换为 HDMI 1.4，从而支持4K 60 Hz 输出，当然，前提是主机的Type-C也支持 DP1.4 输出</p>\n<p>该类型的转接器同样已经很比较普遍了，目前市面上既支持USB3.x 扩展又支持到4K 60Hz的转接器基本都是这个类型的拓补应用，举一些常见的例子</p>\n<ol type=\"1\">\n<li>戴尔DA300[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_20\">20]</a></li>\n<li>戴尔DA310[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_21\">21]</a></li>\n<li>苹果 A2119[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_22\">22]</a></li>\n</ol>\n<ul>\n<li><strong>典型4 Lane DP Alt Mode 产品拓补</strong></li>\n</ul>\n<p>上面两类拓补都是由于保证USB 3.0/USB3.2 Gen2 应用，导致被迫选择 2Lane DP模式，在只能支持DP1.2 的情境下极大限制了 视频传输的带宽，即使转接器支持到 HBR3，也由于大量主机只支持DP1.2 输出（比如雷电接口只能核显输出）导致最终只能被多功能转接器锁在4K 30Hz，因此在 Type-C HBR3 输出尚未普及的时候，选择4Lane DP Alt Mode 比升级到 HBR3 更明智一些</p>\n<p>于是大量的 4 Lane Mode专注于视频转接的线缆型单对单设备应运而生，比如 Nvidia USB-C to DisplayPort Adapter[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_23\">23]</a></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-3814f250fd70c1e0171891cc398e0732_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-b8485a62056f17a0e3b787a1c9bfc669_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-ad3301d173bce644fc40e11de4b3ab82_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-420fcfeb486e5c98d986324eab578b78_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>该配件全机仅有一个功能性配件，即VL103，与上文的Satechi 配件采用的PD主控是一样的， 但在这里被配置为触发的4Lane 模式，可以清晰地看到有四对差分线的走线从上游线直通DP 接口，即ML0~ML3，PD控制器仅负责对DP Alt Mode的触发，完全不干涉DP信号自身；理论上这款线缆在HBR3支持下是可以支持8K 30Hz的输出能力的</p>\n<p>在这样的4Lane 触发基础上加上DP信号转换即可以制作成各式各样的Type-C 转视频接口线，例如华为的CP76，Type-C转HDMI线缆[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_24\">24]</a></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-ad8aeafa0ce502ef34f2df340be10e82_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>采用的，其实还是 VL103 + PS176 的硬件组合，与上文的 Satechi 主体相同，VL103 同样被设置为触发 4Lane 模式，PS176 即使只支持 DP1.2，也凭借着翻倍的带宽支持到了4K 60Hz，发挥了Type-C口完整的 DP输出能力，然而代价是牺牲掉了USB 3.0应用</p>\n<p>如果将PS176更换为PS186 设计，支持HBR3 的DP转换，那么HDMI的输出分辨率支持就能高达8K 30Hz了</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-e8c09344ceb408b843341959ba4e46ff_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-a99ad2572163711133df31bee162ac7c_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>然而 4 Lane DP Alt Mode 相对于 2Lane 模式仅仅是牺牲了 USB3.x 的支持，照理来说USB2.0 和PD 功能依然健在，做出跟常规转接器形态一致的设备并不是难事。</p>\n<p>确实如此，只不过比较稀少，比如小米的 Type-C 转 Mini DP设备[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_25\">25]</a></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-deec7db196937f5b5fc1759901fe7c45_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>PD控制器采用的是FL7102，可以清晰地看到4对 差分线地走线从Type-C直奔 下游的Mini DP，尽管USB Hub采用的是支持USB3.2 gen1 的FL5000，但上游的走线只给了USB2.0的D+D-定义，因此两个扩展的USB接口被迫限制在在USB2.0模式；此外装备了PD输入口，也算功能齐全了。这款转接器理论上在HBR3支持下也是可以支持到8K分辨率输出，只不过 mini DP的走线过长，抗干扰能力能否满足要求就不得而知了。</p>\n<p>目前市面上销售的 Type-C 转单视频口输出的应用可以说全都是应用了这个类型的结构，但是目前依然以支持到DP1.2 转换的为主流，支持到HBR3转换的较少（支持HBR3/DP1.4仍然可以向下兼容HBR2/DP1.2转换，图省事直接购买高规格的即可），支持4Lane 转换的多口转接器除上文提到的以外可以再举几个例子：</p>\n<ol type=\"1\">\n<li>戴尔 USB-C 转 HDMI/DP 适配器[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_26\">26]</a></li>\n</ol>\n<ul>\n<li><strong>可切换带宽型拓补</strong></li>\n</ul>\n<p>那么，既然4Lane 2Lane各有好处，我用什么的时候切什么不好么，再加上HBR3支持，那岂不是香的不行？</p>\n<p>其实也是有的，但是非常稀少。翻阅VL102，VL103的文档时，VIA Tech已经给出了实现该功能的拓补（同时也给出了将USB与充电C口融合的参考，然而做的厂家也非常稀少）</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-5e04ecfc898b01b77a6d97e6a229cefe_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>可以看到相对于上文的拓补，本案例中多出来了类似MUX的芯片VL170，该芯片就是可以用于把设备在2 Lane 与 4Lane 模式之间来回切换的关键</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-d606ef4c0362b25a358b2b3839fd7374_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>感谢 提供的机型线索</p>\n<p>这类拓补的应用实物之一就是 Startech DK30C2DAGPD， 很遗憾这里就没有拆解参考了</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-fa87401c31ca6f3bb52ffc4074495a42_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-5a82fd7b9e0bfee74b9d7389a32adada_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-0618d8ef8ed93e037e5b90c79d68d207_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>根据 Startach 本身提供的信息来看，采用的主要IC如下</p>\n<p>VIA/VLI - VL102</p>\n<p>VIA/VLI - VL170</p>\n<p>VIA/VLI - VL817</p>\n<p>MegaChips - STDP4320</p>\n<p>RealTek - RTL8153</p>\n<p>负责视频输出的 STDP4320 支持双DP++输出，只是可惜作为 仅支持DP1.2 输入的方案，最高也就支持到 单口4K 60Hz 或者双 4K 30Hz 输出了</p>\n<blockquote>\n<p>Dual DisplayPort displays: Up to 4096 x 2160p @ 24Hz or 3840 x 2160p @ 30Hz Single DisplayPort display: Up to 4096 x 2160p @ 60Hz or 3840 x 2160p @ 60Hz</p>\n</blockquote>\n<p>此外还有 Kensington 的 SD4820P USB-C 10Gbps Dual Video Driverless Docking Station 可惜这次连使用的芯片信息都没有了</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-1b2d7f13dfb8a4de886cca67fd4e364d_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-f3d06ce5afcd1135c490f6255cf345dc_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>但是根据Kensington 的手册介绍，扩展坞在4 Lane Mode 下支持单 4k 60Hz 或者 双 4K 30Hz 输出，似乎也不支持 HBR3 应用，甚是可惜</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-c2503d9d9a6546e221326150a10394aa_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>除以上两例以外，目前暂时找不到更多类似拓补了，因此举不了更多实例了</p>\n<ul>\n<li><strong>再复用接口 拓补</strong></li>\n</ul>\n<p>还记得我们在起初的时候对 DP Alt Mode 主机口的认识吗</p>\n<p>多功能Type-C 主机口只要上游有 完整的USB通道和DP 信号源就可以以添加 PD控制器和MUX的方式组建了</p>\n<p>那么在经过设备的 Type-C 端口，Type C 传输信号被重新分解为 DP 与 USB之后，可以将USB信号复制之后再次和 DP信号 结合成 DP Alt Mode Type-C吗</p>\n<figure>\n<img src=\"https://pic3.zhimg.com/v2-8580acd1b17f56740c1f1745be4fa78a_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>答案依然是肯定的，DA310 就通过 增加 MUX 芯片的方式 在 Type-C 扩展器里实现了信号的重新结合，为下游提供了一个 多功能Type-C[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_21\">21]</a></p>\n<p>然而美中不足的是该接口似乎吃了 2Lane 和 HBR2 两个DeBuff，最高只能支持到 4K 30hz 输出，装备了 支持 HBR3 的主机端MUX 芯片 PS8802 后表现这么拉跨只能说比较遗憾了</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-68bd1cc3e9713d420baa55432e7d7e45_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>但这些缺陷在戴尔的新 WD19DCS中都被解决了</p>\n<p>代价是连接主机的一个上游端口变为两根</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-7d4014fd7cafa7c5d1cc6a92c0249ef4_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-0230b0e5f9fddf62bffb4cb17f0af7f4_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>单Type-C口可以支持到 8K 30Hz输出，显然是完成了4Lane HBR3 的支持，然而没有 拆解图观察还是比较可惜的。</p>\n<h1 id=\"硬件选用\">硬件选用</h1>\n<ul>\n<li><strong>PD控制器概览</strong></li>\n</ul>\n<p>上文介绍的案例都是采用的专用PD控制器</p>\n<p>作为转接器核心部件的PD控制器其实门槛并不高，常规的MCU即可实现PD控制器的功能</p>\n<p>例如 STM 就基于自家的STM32F072 推出了STEVAL-USBC2DP 配件，希望能从 Type-C市场分一杯羹，上文提过的惠普HP USB-C to Multi-Port Hub USB-C多端口集线器[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_17\">17]</a> 也是用的这个主控</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-775a929a96ed14fb25ac2f3a15c7b555_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>然而非专用化的设计必然在外部电路复杂度，功能开发，成本上处于弱势，因此使用这类主控的产品还是风毛菱角</p>\n<p>但是PD控制器只能做PD 控制器吗？跟USB Hub 甚至 视频转换 做在一起不行吗？</p>\n<p>可以的，也是有产品的</p>\n<p>比如 Fresco 的 FL5002 即是 PD控制器 + USB 3.0集线器 （小米，联想有成品，皆是公版仿苹果A2119外形）</p>\n<p>Genesys Logic 的GL3510 也是 PD控制器+USB3.0 集线器（米物 转接器）</p>\n<p>更进一步的比如 龙讯 LT8711H，安格 AG9321 ，一颗芯片就可完成视频转换，PD充电 的功能</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-7ea776cc7b2541fa2b06a28b6ee53b17_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<ul>\n<li><strong>主控产品格局</strong></li>\n</ul>\n<p>介绍一下主控在Type-C 转接器市场中的主要IC和格局</p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//docs.qq.com/sheet/DWmZoUFJpTmVXRkVa\">腾讯文档</a></p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//docs.qq.com/sheet/DWmZoUFJpTmVXRkVa\">docs.qq.com</a></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-1e8f184208cc70de95edd04e901f402c_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>Texas Instrument 我想EE背景的同学就算没用过应该也都听说过，它对电源，信号类的应用市场有着统治级的影响力，其 产品和企业价值观 对全球的 EE 领域从业者都有着深远影响；各位如果拆开自己的笔记本，九成九都可以在主板上发现 TI的芯片。</p>\n<p>Cypress 不像 Texas Instrument 那么巨无霸，但在消费电子领域也是巨头，为各类应用都提供了可靠高效的解决方案</p>\n<p>这两家巨头 所提供的IC 基本代表了 Type-C 转接设备的顶级产品方案（不止DP Alt Mode，雷电也是）作为头部计算机制造商 HP，Dell 甚至 微软，Apple 的产品使用的都是来自这两大巨头的主控，唯一的遗憾可能就是 TI的主控至今都没有支持 PD Pass through的产品，只有 DC供电的坞站形态或者无供电转接器形态</p>\n<p>比如</p>\n<p>Dell DA300[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_20\">20]</a> （TPS65988 ，Texas Instrument）</p>\n<p>Dell DA310[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_21\">21]</a> （CYPD4226+CY7C65219，Cypress）</p>\n<p>Dell WD15 （TPS65982，Texas Instruments）</p>\n<p>戴尔 USB-C 转 HDMI/DP 适配器[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_26\">26]</a>（CYPD4226+CY7C65219，Cypress）</p>\n<p>Surface Dock2[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_27\">27]</a> （非Type-C 配件，TPS65988，Texas Instrument）</p>\n<p>Apple A2119[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_22\">22]</a> （CYPD5225+CY7C65211，Cypress）</p>\n<p>中高端&amp;中端：Parade/Fresco</p>\n<p>Fresco 已经被Parade 收购，两家的产品也完成了进一步的整合，目前的第三方新转接器产品基本都使用的该公司主控，并且整体设计方案和防护设计基本都到位，目前综合价格和性能来看还是比较理想的选择</p>\n<p>中端：Genesys Logic</p>\n<p>因为这家厂子隐藏自家产品资料并且广签NDA导致可获得的资料极少</p>\n<p>产品还可以但真正使用Genesys 作为核心设计的产品并不多，基本是以 USB Hub 主控活跃在各家转接器上（苹果与微软的转接器都有用到）</p>\n<p>中端&amp;中低端：VIA Tech</p>\n<p>VIA算是我们的老朋友了，VIA与国内的第三方厂商联系甚密，产品特点是下限有一定保证，但基本没有再次开发的空间（下限可以且上下限差距极小）</p>\n<p>低端：Lontium（龙讯），Algoltek（安格）</p>\n<p>虽然两家的 LT8711H 以及 AG9321 公版设计 就是奔着缩成本去的简陋和稀烂，但是低价产品对市场带来的冲击是巨大的。</p>\n<p>国内30+元，海外4.5USD，为上述中端产品的生存带来了巨大的压力</p>\n<ul>\n<li><strong>常见下级视频类应用</strong></li>\n</ul>\n<p>在上文所举例的应用中，我们已经可以看到一些转换器常见的转换应用，比如PS176，PS186，都是基于DP输出的单对单视频转换，由于苹果的采用才在第三方转接器中风行开来</p>\n<p>单对单转换的意思是........ 单入单出，那么单个DP输入像USB分线器那样扩展成多屏应用可以吗</p>\n<p>也可以的，使用的技术主要是 DP MST （DP菊花链）根据所设置的分辨率（占用带宽）决定显示器扩展数量的上限，分配比例灵活，可以独立设置每个屏幕，但下游的单个显示器也有带宽限制</p>\n<p>这里由于转换类型和应用太多所以暂时不做表了</p>\n<ul>\n<li><strong>可靠外围设计示例</strong></li>\n</ul>\n<p>由于转接器使用环境复杂，比如：</p>\n<ul>\n<li>大功耗外围（USB等）设备需要电源设计来保证供电，亦需要应对过流等预期外情况设计保险</li>\n<li>信号线本身工作时载有高频跳变的电压，可以将线路当作天线辐射出射频信号，会干扰周围无线设备或被外界干扰，因此也需要无线屏蔽/隔断设计</li>\n<li>人体（或其他物体）触摸转接器时可能带有高水平的电荷（静电）从而造成放电现象，放电过程会有极高可能性损坏转接器芯片，甚至损坏连接的主机接口</li>\n</ul>\n<p>这些情景却并不是单靠上文提到过的芯片本身的设计指南所能搞定的，需要PCB设计，相关安全器件和设计，产品设计一同来保障</p>\n<p>第一点一般会有专用的器件来搞定，比如在DA310 中内置的 TPS2554 作为电流保险</p>\n<figure>\n<img src=\"https://pic3.zhimg.com/v2-fd1fddbd162751ea3a0260a9d2519202_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>第二点一般利用法拉第笼的原理在转接器外围造一层金属罩进行无线屏蔽</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-68a8b3984897e0937f3446f56b255dea_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-e4e71c2210d763b837b9cee71ee442e5_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>第三点则较为复杂，尽管目前多数IC都会内置 ESD （electrical state discharge）防护，然而并不能确保芯片可以在较恶劣的环境下存活下来，因此外挂各种防护措施还是有价值的，毕竟要是把主机口也挂了那麻烦就大了</p>\n<p>其中TVS管就是最常用的方式</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-0cb4401a831b61646eaed46f15b20eca_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>其他的防护措施这里就不一一介绍了，可以参考该文 <a href=\"https://link.zhihu.com/?target=https%3A//acroname.com/blog/industrial-usb-hub-teardown-esd-robustness\">INDUSTRIAL USB HUB TEARDOWN: ESD ROBUSTNESS</a> 仅作参考，该文是较为典型的过分堆料</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-98c67086b6a85d7b4014e261e778443e_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>一般情况下只要做到像TI参考设计的程度就足够了，即 使用TVS管作为ESD防护以及电源总线上附带过流保险</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-f402b8767c2e6bbfdb96f8a06921c8b3_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-c79f4ee4605017330e342cd9edb71679_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>此外，PCB的走线也会影响 ESD效果以及对外的无线干扰辐射[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_28\">28]</a>，总之转接器PCB做工是一件比较复杂的考量事项。</p>\n<h1 id=\"总结与指南-1\">总结与指南</h1>\n<p>总的来说转接器产品有两大特点不同于 朴素认知</p>\n<ul>\n<li>作为转接器的核心部件PD控制器并不影响转接器的主要功能（视频转换和USB、扩展）</li>\n<li>转接器接口多寡并不和其 成本 呈正相关 （原本可以给的接口会被阉割，市场内的常见手段），将多种接口整合变少才是本事（就像你用来扩展的Type C口）</li>\n</ul>\n<p>因此通过接口多寡来计算性价比（价格/接口）基本只能陷入坑货泥潭</p>\n<p>此外 新款芯片一般至少需要一年的周期才能真正被采用到新产品里面，因此盲目追新 方案大可不必</p>\n<hr />\n<ul>\n<li><strong>推荐</strong></li>\n</ul>\n<p>尽管各头部厂商 由于历史原因或者其他的一些因素多少都有一些坑货，而下面的白莲花制造商也少之又少，即使是 Belkin 也能找出一些 智商税产品</p>\n<p>但是原则上依然推荐 HP，Dell，苹果，微软的新品转接器，这些厂子的转接器不分高端低端，出手即是代表性产品，但也导致</p>\n<p>这些头部厂商的产品也会有一个共性的缺点就是不会在自己的产品上集成读卡器功能</p>\n<p>其余的，功能和做工就拉不开多少差距了，很难说有完美的，各方面都做的很优秀的产品</p>\n<p>总结一下本文提到的带有拆解文章的产品，转接器功能需求复杂，产品或多或少存有不足，仅作参考，长期更新</p>\n<p>依然不建议依赖该表，建议通读</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/v2-8660a99fbe26365d9a3d7488288971f6_b-20210526000705763.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<hr />\n<ul>\n<li><strong>排雷</strong></li>\n</ul>\n<p>这个市场内显著的坑货有两大类</p>\n<p>一类是长得像 Belkin 的 非Belkin 产品</p>\n<figure>\n<img src=\"https://pic2.zhimg.com/v2-ed0fcb1bc9f15717df5a0549ff865e81_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic2.zhimg.com/v2-395b6b257e5b4bfba528ae61084b04d9_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>这类产品一般都是VIA 的VL100系公模产品， 本来做的像样的也有，比如在我的专栏中拆过的Satechi</p>\n<p>但由于对压缩成本的追求，VIA的公版设计被无限压缩，导致市面上一大批的公模VIA产品坑点奇多，下面的雷至少踩两个：</p>\n<ul>\n<li>质劣价高（物料成本20块左右，直接抄公版设计无需研发成本，防护全无的扩展坞可以卖到150以上，200，300 也是常见）</li>\n<li>供电稀烂，带不动一块移动机械硬盘的读写耗电</li>\n<li>屏蔽基本无，是一个巨大的2.4Ghz污染源，干扰附近的蓝牙，WIFI设备的正常工作</li>\n<li>工厂品控稀烂</li>\n</ul>\n<p>涉及品牌包括 绿联，Orico，飞利浦（转接器业务已经被别家收购），Unitek，倍思</p>\n<p>国内能叫的上名字的配件厂几乎全部中枪，同样是 VL100系主控，没一家的做工和防护能比得上Satechi（苹果合作款）</p>\n<figure>\n<img src=\"https://pic2.zhimg.com/v2-3dfff693a1575ca58b5c3b089f8c59c5_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic4.zhimg.com/v2-fd6a19341d4d279adceae25faa1f4837_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>另一类是长得像苹果的非苹果产品</p>\n<figure>\n<img src=\"https://pic3.zhimg.com/v2-222af6d53c029fc372a794c438375936_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>这类产品同样有VIA 阵营的VL100系产品牵涉其中</p>\n<p>但在低端攻城掠地的 龙讯LT8711H ，安格 AG9321 同样也籍由这样的外型活得滋润（物料成本估计 10块左右，售价一般在30，40元水平）</p>\n<p>此外 Fresco 的 FL5002 公版设计也是籍由这种 外形活得滋润，例如 小米ZJQ01TM[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_1\">1]</a> ，联想也是[<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_2\">2]</a>，尽管TVS防护尚可，但是绝对不会装配 屏蔽罩，另外FL5002 发热较大</p>\n<p>还有一类较隐蔽坑货就是自己做标致的外壳，内藏稀烂的硬件</p>\n<p>外形就请自行想象了，以下三款图内PCBA的售价都在10元内</p>\n<figure>\n<img src=\"https://pic2.zhimg.com/v2-59012a67ebb1e0efd1eb6c053219cb6d_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic3.zhimg.com/v2-17fd6a55704998d450f3a29924a272f2_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic2.zhimg.com/v2-ceb7df6aa2250a6a365ee70f3d83296d_b.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li><a href=\"#fn1\" class=\"footnote-ref\" id=\"fnref1\" role=\"doc-noteref\"><sup>1</sup></a>(about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_1_0)<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_1_1\">b</a><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_1_2\">c</a>全网首拆：小米USB-C至HDMI多功能转接器ZJQ01TM拆解 http://consumer.linxee.cn/CPLT/132.html</li>\n<li><a href=\"#fn2\" class=\"footnote-ref\" id=\"fnref2\" role=\"doc-noteref\"><sup>2</sup></a>(about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_2_0)<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_2_1\">b</a>拆解报告：联想USB-C迷你集线器 https://www.chongdiantou.com/wp/archives/27256.html</li>\n<li><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_3_0\">^</a>INTEL 对USB3.0 射频干扰的测试和相关建议 https://www.intel.com/content/www/us/en/products/docs/io/universal-serial-bus/usb3-frequency-interference-paper.html</li>\n<li><a href=\"#fn3\" class=\"footnote-ref\" id=\"fnref3\" role=\"doc-noteref\"><sup>3</sup></a>(about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_4_0)<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_4_1\">b</a>TI文档，PD Alternative Mode：Display Port <a href=\"https://www.ti.com/lit/an/slva844b/slva844b.pdf?ts=1614791986776&amp;ref_url=https%3A%2F%2Fwww.ti.com%2Fsitesearch%2Fdocs%2Funiversalsearch.tsp%3FsearchTerm%3DAlternate%2BMode%2BSupport\">https://www.ti.com/lit/an/slva844b/slva844b.pdf?ts=1614791986776&amp;ref_url=https%253A%252F%252Fwww.ti.com%252Fsitesearch%252Fdocs%252Funiversalsearch.tsp%253FsearchTerm%253DAlternate%2BMode%2BSupport</a></li>\n<li><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_5_0\">^</a>HDMI组织官网对HDMI Alt Mode 的介绍 https://www.hdmi.org/spec/typec</li>\n<li><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_6_0\">^</a>视频标准电子协会 VESA 的说明 [https://vesa.org/featured-articles/vesa-rolls-out-early-certification-program-for-video-source-and-display-products-using-hbr3-high-bandwidth-link-rate/#:<sub>:text=DisplayPort's%20new%20HBR3%20data%20rate,at%208.1%20Gbps%20per%20lane](https://vesa.org/featured-articles/vesa-rolls-out-early-certification-program-for-video-source-and-display-products-using-hbr3-high-bandwidth-link-rate/#:</sub>:text=DisplayPort's new HBR3 data rate,at 8.1 Gbps per lane)</li>\n<li><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_7_0\">^</a>Dell官方 关于显示带宽的说明 <a href=\"https://www.dell.com/support/manuals/zh-cn/dell-wd19dcs-dock/wd19dcs_user_guide/显示带宽?guid=guid-f73113c5-ee42-47fe-a849-d669e93440e2&amp;lang=zh-cn\">https://www.dell.com/support/manuals/zh-cn/dell-wd19dcs-dock/wd19dcs_user_guide/%E6%98%BE%E7%A4%BA%E5%B8%A6%E5%AE%BD?guid=guid-f73113c5-ee42-47fe-a849-d669e93440e2&amp;lang=zh-cn</a></li>\n<li><a href=\"#fn4\" class=\"footnote-ref\" id=\"fnref4\" role=\"doc-noteref\"><sup>4</sup></a>(about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_8_0)<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_8_1\">b</a>TI 文档 Alternative Mode on Type-C https://zhuanlan.zhihu.com/p/335164290</li>\n<li><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_9_0\">^</a>普瑞科技主控产品清单 https://www.paradetech.com/products/</li>\n<li><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_10_0\">^</a>Cypress， 提问是否需要在设备端使用MUX https://community.cypress.com/t5/USB-EZ-PD-Type-C/do-we-need-a-switch-like-PS8740B-on-both-the-source-and-sink/td-p/187782?start=0&amp;tstart=0</li>\n<li><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_11_0\">^</a>TI中文社区对差分对的介绍 https://e2echina.ti.com/blogs_/archives/b/signal_integrity_/archive/2015/05/13/51961</li>\n<li><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_12_0\">^</a>Wiki 关于 Virtual Link https://en.wikipedia.org/wiki/VirtualLink</li>\n<li><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_13_0\">^</a>Satechi 多口转接器拆解 https://zhuanlan.zhihu.com/p/155895919</li>\n<li><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_14_0\">^</a>充电头网 拆解报告：UGREEN绿联3A1C四口多功能扩展坞（带SD卡槽版） https://www.chongdiantou.com/wp/archives/44723.html</li>\n<li><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_15_0\">^</a>华为MateDock2扩展坞拆解 http://blog.sina.com.cn/s/blog_702183da0102xf73.html</li>\n<li><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_16_0\">^</a>拆解报告：米物3A1C七合一多功能扩展坞MWCMA01 https://www.chongdiantou.com/wp/archives/61247.html</li>\n<li><a href=\"#fn5\" class=\"footnote-ref\" id=\"fnref5\" role=\"doc-noteref\"><sup>5</sup></a>(about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_17_0)<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_17_1\">b</a>售完存档：全新原装惠普HP USB-C to Multi-Port Hub USB-C多端口集线器外接HDMI USB-C USB3.0 1BG94AA 918965-001 919666-001 https://qzxx.com/49896.html</li>\n<li><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_18_0\">^</a>售完存档：全新散装华硕ROG Phone (ZS600KL) ASUS Professional Dock Type-C 游戏手机 电脑 Macbook PD供电 HDMI USB3.0 千M网口 USB-C接口五合一扩展坞ADSU001 https://qzxx.com/44938.html</li>\n<li><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_19_0\">^</a>【TearDown】DockCase DPR01S 可视化扩展坞 4K@60Hz 分线款 拆解 https://zhuanlan.zhihu.com/p/345184683</li>\n<li><a href=\"#fn6\" class=\"footnote-ref\" id=\"fnref6\" role=\"doc-noteref\"><sup>6</sup></a>(about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_20_0)<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_20_1\">b</a>【Teardown】Dell 配件 DA300 拆解 https://zhuanlan.zhihu.com/p/339830297</li>\n<li><a href=\"#fn7\" class=\"footnote-ref\" id=\"fnref7\" role=\"doc-noteref\"><sup>7</sup></a>(about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_21_0)<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_21_1\">b</a><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_21_2\">c</a>【TearDown】 Dell DA310 初步测试和拆解 https://zhuanlan.zhihu.com/p/350808731</li>\n<li><a href=\"#fn8\" class=\"footnote-ref\" id=\"fnref8\" role=\"doc-noteref\"><sup>8</sup></a>(about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_22_0)<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_22_1\">b</a>拆解报告：苹果最新USB-C 数字影音多端口转换器A2119 https://www.chongdiantou.com/wp/archives/38952.html</li>\n<li><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_23_0\">^</a>售完存档：原装Nvidia 雷电3 USB-C to DisplayPort Adapter USB-C转DP显卡转换线 支持3840*2160 4K 60Hz 030-1036-00 DJ8A5T-4000-10H https://qzxx.com/44009.html</li>\n<li><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_24_0\">^</a> 拆解报告：华为高清投屏连接线（CP76） https://www.chongdiantou.com/wp/archives/27141.html</li>\n<li><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_25_0\">^</a>小米第二款DOCK转换器拆解：支持DP，用料残暴 https://www.sohu.com/a/150498171_296845</li>\n<li><a href=\"#fn9\" class=\"footnote-ref\" id=\"fnref9\" role=\"doc-noteref\"><sup>9</sup></a>(about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_26_0)<a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_26_1\">b</a>拆解报告：DELL戴尔Type-C三合一多功能扩展坞 https://www.chongdiantou.com/wp/archives/66590.html</li>\n<li><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_27_0\">^</a>Surface Dock 2 teardown https://dancharblog.wordpress.com/2020/05/28/surface-dock-2-teardown/comment-page-1/#comment-7200</li>\n<li><a href=\"about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_28_0\">^</a>ESD Protection Layout Guide <a href=\"https://www.ti.com/lit/an/slva680/slva680.pdf?ts=1616140396901&amp;ref_url=https%3A%2F%2Fwww.google.com%2F\">https://www.ti.com/lit/an/slva680/slva680.pdf?ts=1616140396901&amp;ref_url=https%253A%252F%252Fwww.google.com%252F</a></li>\n</ol>\n<p>​</p>\n<section class=\"footnotes footnotes-end-of-document\" role=\"doc-endnotes\">\n<hr />\n<ol>\n<li id=\"fn1\" role=\"doc-endnote\"><p>a<a href=\"#fnref1\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\n<li id=\"fn2\" role=\"doc-endnote\"><p>a<a href=\"#fnref2\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\n<li id=\"fn3\" role=\"doc-endnote\"><p>a<a href=\"#fnref3\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\n<li id=\"fn4\" role=\"doc-endnote\"><p>a<a href=\"#fnref4\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\n<li id=\"fn5\" role=\"doc-endnote\"><p>a<a href=\"#fnref5\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\n<li id=\"fn6\" role=\"doc-endnote\"><p>a<a href=\"#fnref6\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\n<li id=\"fn7\" role=\"doc-endnote\"><p>a<a href=\"#fnref7\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\n<li id=\"fn8\" role=\"doc-endnote\"><p>a<a href=\"#fnref8\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\n<li id=\"fn9\" role=\"doc-endnote\"><p>a<a href=\"#fnref9\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\n</ol>\n</section>\n","categories":["Hardware"],"tags":["TypeC","Thunderbolt"]},{"title":"Semiconductor","url":"/2021/07/14/Hardware/2021-07-14-Semiconductor/","content":"<p>本文章用于记录半导体（晶体管的工作原理等blablabla的知识）。</p>\n<h1 id=\"半导体的定义\">半导体的定义</h1>\n<p><strong>半导体</strong> 是指常温下导电性能介于导体与绝缘体之间的材料。 按照国际通行的半导体产品标准方式进行分类，半导体可以分为四类：<strong>集成电路</strong>（Integer Circuit），<strong>分立器件</strong>（Discrete Device），<strong>传感器</strong>（Sensor） 和 <strong>光电子器件</strong>（Optoelectronic Devices） ，统称为半导体元件。</p>\n<p>分立器件按照功率转换进行分类，可以分为 <strong>功率器件</strong> 和 <strong>非功率器件</strong>，其中，<strong>传感器</strong> 和 <strong>光电器件</strong> 属于 分立器件下的 <strong>非功率器件</strong>，剩下的均是 <strong>功率器件</strong>，包含大部分晶体管，如 Zener Diode、BJT、IGFET、IGBT、Thyristor等。</p>\n<p><strong>注意</strong>：功率器件的概念很大，不仅在分立器件中存在功率半导体，在IC中也存在功率半导体的产品。</p>\n<h2 id=\"本征半导体\">本征半导体</h2>\n<p><mark>导电性介于导体与绝缘体之间的物质</mark>称为 <strong>半导体</strong>。</p>\n<p><strong>导体</strong>：如铁、铝、铜等金属元素等低价元素，其最外层电子在外电场作用下很容易产生定向移动，形成电流。</p>\n<p><strong>绝缘体</strong>：如惰性气体、橡胶等，其原子的最外层电子受原子核的束缚力很强，只有在外电场强到一定程度时才可能导电。</p>\n<p><strong>半导体</strong>：如硅（Si）、锗（Ge），均为四价元素，它们原子的最外层电子受原子核的束缚力介于导体与绝缘体之间。</p>\n<p><strong>本征半导体</strong>：intrinsic semiconductor， 是 <strong>纯净</strong>（Purity）的 <strong>晶体结构</strong>（Crystal Texture）的 半导体；intrinsic 具有 “本质，固有” 之意。<strong>纯净</strong>，即无杂质之意；<strong>晶体结构</strong>，即稳定的结构。</p>\n<h2 id=\"pn型半导体\">P/N型半导体</h2>\n<p>纯净的硅晶体不带电荷，不显示出任何导电特性。</p>\n<p><strong>自由电子</strong>（Electron）：由于热运动，具有足够能量的价电子挣脱共价键的束缚而成为自由电子</p>\n<p><strong>空穴</strong>（Hole）：自由电子的产生使共价键中留有一个空位置</p>\n<p><strong>复合</strong>：自由电子与空穴相碰同时消失</p>\n<p><strong>电荷</strong>：电子和空穴都是电荷，电子呈现负电荷，空穴呈现正电荷</p>\n<p><strong>载流子</strong>（Carrier）：运载电荷的粒子称为载流子</p>\n<p><strong>导电性</strong>：物体呈现出的传导电流的能力</p>\n<p><strong>多数载流子</strong>：在纯净硅晶体中掺杂数量较多的电荷称为多数载流子。</p>\n<p><strong>少数载流子</strong>：在纯净硅晶体中掺杂数量较少的电荷称为少数载流子。</p>\n<p>外加电场时，带负电的自由电子和带正电的空穴均参与导电，且运动方向相反。由于载流子数目很少，故导电性很差。温度升高，热运动加剧，载流子浓度增大，导电性增强。热力学温度0K时不导电。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210714204623205.png\" alt=\"image-20210714204623205\" style=\"zoom: 33%;\" /></p>\n<div style=\"text-align: center; font-weight:900;\">\n图 N型半导体结构\n</div>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210714204653816.png\" alt=\"image-20210714204653816\" style=\"zoom: 33%;\" /></p>\n<div style=\"text-align: center; font-weight:900;\">\n图 P型半导体结构\n</div>\n<p>往纯净的硅晶体中掺杂一定浓度的 <strong>磷</strong>（P）或 <strong>硼</strong>（B）即可获得 使得硅晶半导体带上电子或空穴，即获得了 <strong>N型半导体</strong> 和 <strong>P型半导体</strong>。</p>\n<p><strong>杂质半导体</strong>：在本征的基础上掺杂其他元素。</p>\n<p><strong>P型半导体</strong>：掺杂了硼元素的硅晶体，空穴为多数载流子。</p>\n<p><strong>N型半导体</strong>：掺杂了磷元素的硅晶体。自由电子为多数载流子。</p>\n<h2 id=\"pn结\">PN结</h2>\n<p><strong>结</strong>：即 Junction，在纯净硅晶体中掺杂两种不同电荷所形成的杂质接触截面。</p>\n<p><strong>扩散运动</strong>：物质 <mark>因浓度差而产生</mark> 的运动。气体、液体、固体均有之。扩散运动使靠近接触面P区的空穴浓度降低、靠近接触面N区的自由电子浓度降低，产生内电场。</p>\n<p><strong>漂移运动</strong>：因 <mark>电场作用</mark> 所产生的运动。</p>\n<p><strong>动态平衡</strong>：结处因空穴和电子一刻不停地复合和分离（官方：参与扩散运动和漂移运动的载流子数目相同）而形成 “无多数载流子” 的状态。</p>\n<blockquote>\n<p><strong>注意</strong>：扩散运动和漂移运动是相反的，</p>\n</blockquote>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210714210922380.png\" alt=\"image-20210714210922380\" style=\"zoom:50%;\" /></p>\n<div style=\"text-align: center; font-weight:900;\">\n图 扩散运动\n</div>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210714210942004.png\" alt=\"image-20210714210942004\" style=\"zoom:67%;\" /></p>\n<div style=\"text-align: center; font-weight:900;\">\n图 漂移运动\n</div>\n<p><strong>耗尽层</strong>：PN结处，因动态平衡而达到的“无多数载流子”的状态，该结的大小称为耗尽层。</p>\n<p>如果此时让P区的多数载流子，即空穴尽量往N区移动，让N区的多数载流子，即自由电子尽量往P区移动，则两种电荷进行复合，形成更宽的耗尽层，此时因为耗尽层因为没有多数载流子而呈现不导电特性。</p>\n<p>反之，让P区的多数载流子尽量往P区靠拢，让N区的多数载流子尽量往N区靠拢（注意，这里用的是“靠拢”，因为中间已经有耗尽层的形成，此时的“靠拢”是让耗尽层中已经复合消失的电子和空穴重新拆开，分别往各自原来的反向回归。），耗尽层的宽度会逐渐缩小，显现出导电特性。</p>\n<p><strong>正向</strong>：电源的正、负极分别对准半导体的P、N极进行连接。</p>\n<p><strong>反向</strong>：电源的正、负极分别对准半导体的N、P极进行连接。</p>\n<p><strong>正向导通</strong>：耗尽层变窄，扩散运动加剧，由于外电源的作用，形成扩散电流，PN结处于导通状态。</p>\n<p><strong>反向截止</strong>：耗尽层变宽，阻止扩散运动，有利于漂移运动，形成漂移电流。由于电流很小，故可近似认为其截止。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210714212136379.png\" alt=\"image-20210714212136379\" style=\"zoom:33%;\" /></p>\n<div style=\"text-align: center; font-weight:900;\">\n图 正向导通\n</div>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210714212143706.png\" alt=\"image-20210714212143706\" style=\"zoom:33%;\" /></p>\n<div style=\"text-align: center; font-weight:900;\">\n图 反向截止\n</div>\n<h3 id=\"电容效应\">电容效应</h3>\n<p><strong>势垒电容</strong>：PN结外加电压变化时，空间电荷区的宽度将发生变化，有电荷的积累和释放的过程，与电容的充放电相同，其等效电容称为势垒电容Cb。</p>\n<p><strong>扩散电容</strong>：PN结外加的正向电压变化时，在扩散路程中载流子的浓度及其梯度均有变化，也有电荷的积累和释放的过程，其等效电容称为扩散电容Cd。</p>\n<p><strong>结电容</strong>：等于 势垒电容 与 扩散电容 之和。但 <mark>结电容不是常量！</mark> 若PN结外加电压频率高到一定程度，则失去单向导电性！</p>\n<h1 id=\"二极管\">二极管</h1>\n<p>The diode is the most used semiconductor device in electronics circuits. <strong><em>It is a two-terminal electrical check valve that allows the flow of current in one direction.</em></strong> They are mostly made up of <strong><em>silicon</em></strong> but <strong><em>germanium</em></strong> is also used. Usually, they are used for <strong><em>rectification</em></strong>. But there are different properties &amp; characteristics of diodes which can be used for different application. These characteristics are modified to form different types of diodes.</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210713102126884.png\" alt=\"image-20210713102126884\" /><figcaption aria-hidden=\"true\">image-20210713102126884</figcaption>\n</figure>\n<p><img src=\"https://pic.islet.space/2021/07/Types-of-Diodes-and-Their-Applications.jpg\" alt=\"Types of Diodes and Their Applications\" style=\"zoom:67%;\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n图 二极管的几种外形\n</div>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210713102141393.png\" alt=\"image-20210713102141393\" /><figcaption aria-hidden=\"true\">image-20210713102141393</figcaption>\n</figure>\n<div style=\"text-align: center; font-weight: 900;\">\n图 二极管的几种常见结构和符号\n</div>\n<h2 id=\"主要特征参数\">主要特征参数</h2>\n<ol type=\"1\">\n<li>最大整流电流（Maximum Rectification Current）</li>\n<li>最高反向工作电压（Maximum Reverse Voltage）</li>\n<li>反向电流（Reverse Current）</li>\n<li>最高工作频率（Maximum Frequency）</li>\n</ol>\n<h2 id=\"自举二极管\">自举二极管</h2>\n<h1 id=\"晶体管\">晶体管</h1>\n<p>晶体管主要分为两种类型，BJT 和 FET。</p>\n<p><strong>工作区域</strong>：晶体管的导通状态，分为三种，分别是饱和、截止和放大，分别是指</p>\n<h2 id=\"bjt\">BJT</h2>\n<p>BJT，即 Bioplar Junction Transistor，双极性结型晶体管。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210714213248733.png\" alt=\"image-20210714213248733\" /><figcaption aria-hidden=\"true\">image-20210714213248733</figcaption>\n</figure>\n<div style=\"text-align: center; font-weight:900;\">\n图 晶体管内部结构和符号示意\n</div>\n<p><strong>注意</strong>：晶体管的符号示意中，箭头的方向永远是从P指向N的，此时先不用管c、b、e是怎么接，确定好。</p>\n<blockquote>\n<p>BJT结构特点：三极三区两PN结，发射区多子浓度高，基区多子浓度低且薄，集电区 面积大。</p>\n</blockquote>\n<p><strong>发射区</strong>：多数载流子较高的区域，自由电子流出的方向。</p>\n<p><strong>基区</strong>：多数载流子浓度较低且薄的区域。</p>\n<p><strong>集电区</strong>：面积大的区域，空穴流出的反向。</p>\n<blockquote>\n<p>某极 是根导线，与BJT中的物理区不同。</p>\n</blockquote>\n<p><strong>发射结</strong>：发射区和基区之间的PN结。</p>\n<p><strong>集电结</strong>：集电区和基区之间的PN结。</p>\n<blockquote>\n<p><strong>注意</strong>：以上多数载流子可以是 空穴 或 自由电子，因此 BJT 可以有 NPN 和 PNP 两种类型的BJT。</p>\n</blockquote>\n<p>联系到实际电路连接中，一般情况下，<strong>集电区</strong> 都是接 <strong>供电电源</strong> ， <strong>基区</strong> 都是接 <strong>控制电源</strong>， <strong>发射区</strong> 都是接 <strong>负端/地</strong>。控制电源的电压会低于供电电源的电压，但会大于发射区的电压。</p>\n<p>基区所连接的控制电源 为BJT提供 高电平或低电平 予以控制半导体的导通或截止，<mark>半导体所控制的负载的最大电压取决于发射极的供电电源电压 和 基区的控制电源电压</mark>。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210713104805683.png\" alt=\"image-20210713104805683\" style=\"zoom:67%;\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n图 BJT的几种常见外形\n</div>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210713105054978.png\" alt=\"image-20210713105054978\" style=\"zoom:67%;\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n图 BJT的结构和符号\n</div>\n<h3 id=\"工作原理\">工作原理</h3>\n<p>从下图可以看出，下图 BJT 为 NPN 型半导体，集电区接正电，发射区接地，基区接地。集电区与基区为反向截止状态，集电结的耗尽层增大，进一步阻止集电区和发射区之间的电流导通。</p>\n<p>若此时向基区施加正向电流，基区电压高于发射区电压，发射结正偏导通，发射区多子（电子）往基区流动，。发射区的电子能够顺利往集电区流动，集电区的电流往发射区流动，从而导通 该BJT。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210714215347959.png\" alt=\"image-20210714215347959\" style=\"zoom:33%;\" /></p>\n<div style=\"text-align: center; font-weight:900;\">\n图 BJT导通时的内部电荷流向示意\n</div>\n<p>集电极电流是漂移形成的，发射极电流是扩散形成的。</p>\n<p><strong>发射区电流</strong> I<span style=\"font-size: 0.8rem;\">E</span> 是由 扩散运动形成的。</p>\n<p><strong>基区电流</strong> I<span style=\"font-size: 0.8rem;\">B</span> 是由 复合运动形成的。</p>\n<p><strong>集电区电流</strong> I<span style=\"font-size: 0.8rem;\">C</span> 是由 漂移运动形成的。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210714222731446.png\" alt=\"image-20210714222731446\" style=\"zoom:33%;\" /></p>\n<div style=\"text-align: center; font-weight:900;\">\n图 BJT输入特性曲线\n</div>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210714222645318.png\" alt=\"image-20210714222645318\" style=\"zoom: 33%;\" /></p>\n<div style=\"text-align: center; font-weight:900;\">\n图 BJT输出特性曲线\n</div>\n<h3 id=\"工作区域\">工作区域</h3>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210714223024773.png\" alt=\"image-20210714223024773\" style=\"zoom:67%;\" /></p>\n<div style=\"text-align: center; font-weight:900;\">\n图 BJT工作区域\n</div>\n<h2 id=\"fet\">FET</h2>\n<p><strong>场效应晶体管</strong> 简称 <strong>场效应管</strong>。主要有 <strong>结型场效应管</strong>（JFET）和 <strong>金属氧化物半导体场效应管</strong>（MOSFET）两种类型。</p>\n<h3 id=\"jfet\">JFET</h3>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210713105852012.png\" alt=\"image-20210713105852012\" style=\"zoom:67%;\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n图 JFET的结构和符号\n</div>\n<h3 id=\"mosfet\">MOSFET</h3>\n<p>在MOS管工作原理图上可以看到，漏极和源极之间有一个寄生二极管。这个叫体二极管，在驱动感性负载(如马达)，这个二极管很重要。顺便说一句，体二极管只在单个的MOS管中存在，在集成电路芯片内部通常是没有的。</p>\n<p>下图a中，为增强型P衬底N沟道MOS，其栅极接 <u>高电平</u> 即导通。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210713110023509.png\" alt=\"image-20210713110023509\" style=\"zoom:67%;\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n图 N沟道增强型MOS管结构示意图 及 增强型MOS管的符号\n</div>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210713110146838.png\" alt=\"image-20210713110146838\" style=\"zoom:67%;\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n图 N沟道耗尽型MOS管结构示意图 及 耗尽型MOS管的符号\n</div>\n<h4 id=\"nmos工作原理\">NMOS工作原理</h4>\n<iframe src=\"//player.bilibili.com/player.html?aid=931455726&amp;bvid=BV1DM4y1T7Yx&amp;cid=363622918&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\">\n</iframe>\n<p>MOS管有4个端子，其符号也是四个端子组成的，以下用NMOS举例：</p>\n<p>NMOS底部端子连接到基板/主体（Substrate/Body），称为基板、衬底端子 或 <strong><em>主体端子</em></strong>。上方各有两个N沟道，各自连接 <strong><em>源极端子</em></strong> 和 <strong><em>漏极端子</em></strong>。两个端子中间添加了一层 薄绝缘体或电介质，在此层绝缘体上加了一个 <strong><em>栅极端子</em></strong>。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210716001316182.png\" alt=\"image-20210716001316182\" style=\"zoom:50%;\" /></p>\n<p>在NMOS内部构造中，源极端子 和 衬底端子 在内部连接，因此外露出来的端子只有三个。此时因 源极 和 衬底 的电位相同，阻止了任何电流从衬底流向源极。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210716001716986.png\" alt=\"image-20210716001716986\" style=\"zoom:50%;\" /></p>\n<p>在MOS中，希望电子从漏极流向源极，在两个极连接一个电源，其电压称为 V<span style=\"font-size: 0.6rem;\">DS</span> ，此时加大电压，电流却不会增大，因为漏极沟道附近的耗尽层不断增大。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210716002453710.png\" alt=\"image-20210716002453710\" style=\"zoom:50%;\" /></p>\n<p>栅极端子 和 主体端子 都有绝缘材料，当给栅极端子接电压较小的电压 V<span style=\"font-size: 0.6rem;\">GS</span> 时，两个绝缘材料形成电容效应，栅极处的多子不断吸引自由电子往栅极移动，暂时形成带自由电子较多的N区，从而导通了 源极 和 漏极，暂时形成了回路。因为 栅极处的N区是暂时连接 源极和漏极的通道，因此也被称为 N沟道。随着电压的增大或减小，沟道的大小也会随着变化。足以形成沟道的最低栅极电压被称为 <strong>阈值电压</strong>。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210716002900372.png\" alt=\"image-20210716002900372\" style=\"zoom:50%;\" /></p>\n<p>当不断增加栅极电压，漏极 和 衬底之间的耗尽层将因为 反向偏置 而不断增加。靠近漏极一侧的N沟道宽度将不断减小，直到某个电压点时，称为夹断效应。夹断下映实际上是说，沟道并未完全关闭，许多电子将保留通道，并不是停止了电流流动，而是出现了恒定的饱和电流，其电压被称为 饱和电压。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210716004255087.png\" alt=\"image-20210716004255087\" style=\"zoom:50%;\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n表 FET的符号和特性\n</div>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210713105437061.png\" alt=\"image-20210713105437061\" /><figcaption aria-hidden=\"true\">image-20210713105437061</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210713105533255.png\" alt=\"image-20210713105533255\" /><figcaption aria-hidden=\"true\">image-20210713105533255</figcaption>\n</figure>\n<h2 id=\"fet-and-bjt\">FET and BJT</h2>\n<p>FET 的 <strong>栅极</strong>、<strong>源极</strong> 和 <strong>漏极</strong> 对应 BJT的 <strong>基极</strong>、<strong>发射极</strong> 和 <strong>集电极</strong>，其作用类似。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>FET</th>\n<th>BJT</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>电流索取</td>\n<td>用“栅-源”电压控制漏极电流，栅极基本不取电流<br>【输入电阻高的电路选用】</td>\n<td>工作时基极总要索取一定的电流<br>【信号源若提供电流的选用】</td>\n</tr>\n<tr class=\"even\">\n<td>导电情况</td>\n<td>仅多子参与导电</td>\n<td>多子少子均参与导电</td>\n</tr>\n<tr class=\"odd\">\n<td>稳定性</td>\n<td>较好</td>\n<td>较差<br>【因少子数目受温度、辐射等因素影响较大，温度稳定性和抗辐射的能力较差些。】</td>\n</tr>\n<tr class=\"even\">\n<td>噪声系数</td>\n<td>小<br>【低噪声放大器的输入级和信噪比要求高的电路选用】</td>\n<td>大</td>\n</tr>\n<tr class=\"odd\">\n<td>源-漏互换</td>\n<td>可以互换，互换后特性变化不大</td>\n<td>互换后特性差异很大，特殊需求时互换</td>\n</tr>\n<tr class=\"even\">\n<td>电压范围</td>\n<td>宽</td>\n<td>窄</td>\n</tr>\n<tr class=\"odd\">\n<td>工艺</td>\n<td>简单</td>\n<td>复杂</td>\n</tr>\n<tr class=\"even\">\n<td>耗电</td>\n<td>低</td>\n<td>高</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>IGFET / MOS / MOSFET 是同一个东西，还有个词叫 MISFET（Metal-Insulated-Semiconductor Field Effect Transistor，金属绝缘半导体场效应管）</p>\n</blockquote>\n<h1 id=\"功率半导体\">功率半导体</h1>\n<p><strong>功率半导体</strong> 器件大致分为两类： <strong>可控功率半导体</strong> 和 <strong>不可控功率半导体</strong>。<strong>可控功率半导体</strong> 如 Thyristor（晶闸管）、BJT（双极型晶体管）、功率MOSFET 和 IGBT 。不可控功率半导体 包括各种类型的功率二极管。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210713112224602.png\" alt=\"image-20210713112224602\" style=\"zoom:67%;\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n图 常见功率半导体器件及其典型的功率范围、阻断电压和开关频率\n</div>\n<h1 id=\"igbt\">IGBT</h1>\n<p><strong>绝缘栅型双极晶体管</strong>，即 <strong>IGBT</strong>（Insulated Gate Bipolar Transistor），是由 <strong><em>BJT</em></strong>（双极型三极管)）和 <strong><em>MOS</em></strong>（绝缘栅型场效应管）组成的 <strong>复合全控型电压驱动式功率半导体</strong> 器件, 兼有 <strong>MOSFET</strong>的 <u>高输入阻抗</u> 和 <strong>GTR</strong>的 <u>低导通压降</u> 两方面的优点。IGBT综合了以上两种器件的优点，驱动功率小而饱和压降低。非常适合应用于直流电压为600V及以上的变流系统如交流电机、变频器、开关电源、照明电路、牵引传动等领域。</p>\n<blockquote>\n<p>GTR 具有饱和压降低，载流密度大，但驱动电流较大的优点；</p>\n<p>MOSFET 具有驱动功率很小，开关速度快，但导通压降大，载流密度小的优点。</p>\n</blockquote>\n<p><strong>IGBT模块</strong> 是由 IGBT（绝缘栅双极型晶体管芯片）与FWD（续流二极管芯片）通过特定的电路桥接封装而成的模块化半导体产品；封装后的IGBT模块直接应用于变频器、UPS不间断电源等设备上；IGBT模块 具有节能、安装维修方便、散热稳定等特点；当前市场上销售的多为此类模块化产品，一般所说的IGBT也指IGBT模块；随着节能环保等理念的推进，此类产品在市场上将越来越多见；</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210713142410853.png\" alt=\"image-20210713142410853\" style=\"zoom: 80%;\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n图 IGBT内部结构和等效电路\n</div>\n<p>因为IGBT的构造所致，最好还是不要让IGBT长期工作在放大区，会让其降低使用寿命，因开关开断时而进入放大区无可避免，仅工作在 饱和区 和 截止区 即可。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210715221251088.png\" alt=\"image-20210715221251088\" style=\"zoom:80%;\" /></p>\n<p>三个英文符号分别表示为 <strong>栅极</strong>（Gate）、<strong>集电极</strong>（Collector）、<strong>发射极</strong>（Emitter）。</p>\n<p>在漏极侧增加了高掺杂的P+层，称之为 <strong>集电极</strong>。</p>\n<ul>\n<li><p>当栅极接近 <u>负电压</u> 或 <u>零电压</u> 时，PN结 J2 阻断，发射极电压远低于集电极电压，IGBT 关断 （正向阻断）；但是此刻 结J1 和 结J3 <strong>正偏导通</strong>。</p></li>\n<li><p>当栅极接到 <u>正电压</u>（通常是15V）时，氧化层下方的 P区 建立 <strong>反型导电沟道</strong>，为 N-区 提供导电通路，电子从发射极到 N-区 降低了 N-区 的电位，PN结 J1导通，IGBT导通。</p></li>\n</ul>\n<p>如果栅极电压不够大，形成的反型层较弱，流入漂移区的电子数相对较少，IGBT压降增大，即进入特性曲线的 <strong>线性放大区</strong>。工作在线性放大区会加剧损耗或损坏 IGBT，因而除了开关瞬间，应避免进入线性放大区。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210713144038325.png\" alt=\"image-20210713144038325\" style=\"zoom:67%;\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n图 IGBT的输出特性\n</div>\n<p>IGBT 的关断电流分为 <strong>MOSFET关断阶段</strong> 和 <strong>BJT关断阶段</strong>。第一个阶段时，关断反型沟道，电流迅速下降；第二个阶段时，会产生持续时间较长的拖尾电流。</p>\n<p>拖尾电流使得 IGBT 的关断损耗 高于 MOSFET 的关断损耗。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210713144838981.png\" alt=\"image-20210713144838981\" style=\"zoom: 67%;\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n图 MOSFET和IGBT的主要开通和关断特性比较\n</div>\n<p>截止电压：</p>\n<p>饱和电压：</p>\n<p>击穿电压：</p>\n<p><strong>阈值电压</strong>：描述的是 <strong>栅极</strong> 和 <strong>发射极</strong> 之间刚好足以打开导流通道的电压。</p>\n<p><strong>漏电流</strong>：泄露电流，leakage current。主要是指栅极和发射极的在反向偏置状态的泄露电流，此处特性与二极管相近。</p>\n<h2 id=\"分类\">分类</h2>\n<p>IGBT可以分为 <strong>穿通型</strong>（PT）IGBT、<strong>非穿通型</strong>（NPT）IGBT、<strong>场终止型</strong>（FS）IGBT、<strong>沟槽栅</strong>（Trench）IGBT、<strong>载流子存储沟槽栅双极晶体管</strong>（CSTBT）、<strong>注入增强晶体管</strong>（IEGT）、<strong>沟槽栅终止</strong>（Trench-FS）IGBT、<strong>逆导型</strong>（RC）IGBT。</p>\n<p><strong>平面栅极结构</strong> 的IGBT设计，形成了JFET结构，以及发射极区软弱的电导调制效应，载流子的浓度从集电极到发射极之间逐步降低。</p>\n<p><strong>沟槽型栅极结构</strong> 的IGBT设计，在平面型的基础上保持载流子浓度平均分布或逐步增加载流子浓度，进一步降低通态损耗，而不影响拖尾电流和关断损耗。</p>\n<p>载流子越少越有助于降低关断损耗。</p>\n<table>\n<colgroup>\n<col style=\"width: 16%\" />\n<col style=\"width: 30%\" />\n<col style=\"width: 12%\" />\n<col style=\"width: 11%\" />\n<col style=\"width: 30%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>TYPE</th>\n<th>内部构造（原理）</th>\n<th>温度系数</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>PT-IGBT<BR>穿通型IGBT</td>\n<td><img src=\"https://pic.islet.space/2021/07/image-20210713112637086.png\" alt=\"image-20210713112637086\" style=\"zoom:67%;\" /></td>\n<td>正温度系数<br>负温度系数</td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>NPT-IGBT<BR>非穿通型IGBT</td>\n<td><img src=\"https://pic.islet.space/2021/07/image-20210713112654444.png\" alt=\"image-20210713112654444\" style=\"zoom:67%;\" /></td>\n<td>正温度系数</td>\n<td>1. 有利于IGBT并联</td>\n<td>1. 随着温度上升，损耗增大</td>\n</tr>\n<tr class=\"odd\">\n<td>FS-IGBT<BR>场终止型IGBT</td>\n<td><img src=\"https://pic.islet.space/2021/07/image-20210713112712678.png\" alt=\"image-20210713112712678\" style=\"zoom:67%;\" /></td>\n<td>正温度系数</td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>Trench-IGBT<br>沟槽栅IGBT</td>\n<td><img src=\"https://pic.islet.space/2021/07/image-20210713112728045.png\" alt=\"image-20210713112728045\" style=\"zoom:67%;\" /></td>\n<td></td>\n<td></td>\n<td>1. 更宽的导电沟道会增加IGBT短路时的电流</td>\n</tr>\n<tr class=\"odd\">\n<td>CSTBT<br>载流子存储沟槽双极晶体管</td>\n<td><img src=\"https://pic.islet.space/2021/07/image-20210713122039519.png\" alt=\"image-20210713122039519\" style=\"zoom:67%;\" /></td>\n<td></td>\n<td>1. 降低了IGBT的饱和压降</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>IEGT<BR>注入增强栅晶体管</td>\n<td><img src=\"https://pic.islet.space/2021/07/image-20210713112841613.png\" alt=\"image-20210713112841613\" style=\"zoom:67%;\" /></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>Trench-FS IGBT<br>沟槽栅终止IGBT</td>\n<td><img src=\"https://pic.islet.space/2021/07/image-20210713112933604.png\" alt=\"image-20210713112933604\" style=\"zoom:67%;\" /></td>\n<td></td>\n<td></td>\n<td>1. 保持鲁棒性，通态损耗和开关损耗降低<br>2. 功率密度提升，即电流密度增大<br>3. 单位IGBT所需硅材料降低</td>\n</tr>\n<tr class=\"even\">\n<td>RC-IGBT<BR>逆导型IGBT</td>\n<td><img src=\"https://pic.islet.space/2021/07/image-20210713122011473.png\" alt=\"image-20210713122011473\" style=\"zoom:67%;\" /></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"术语总结\">术语总结</h1>\n<p><strong>FET</strong>： Filed Effect Transistor，即 <strong>场效应管</strong>，是 <mark>利用输入回路的电场效应来控制输出回路电流</mark> 的一种半导体器件，故此得名。由于其仅靠半导体中的多数载流子导电，因此也称为 <strong>单极型晶体管</strong>。</p>\n<p><strong>JFET</strong>： Junction Filed Effect Transistor，即 <strong>结型场效应管</strong>，有 P沟道 和 N沟道 两种类型。</p>\n<p><strong>IGFET</strong>： Insulated Gate Field Effect Transistor，即 <strong>绝缘栅型场效应管</strong>。因栅极与源极、栅极与漏极之间均采用二氧化硅绝缘层进行阻隔而得名如此。又因栅极为金属铝，故又称为MOS管。具有 高输入阻抗、高开关频率 和 低驱动功率 的优点。</p>\n<p><strong>MOS</strong>： Metal-Oxide-Semiconductor，即 <strong>金属氧化物半导体</strong>。同上。</p>\n<p><strong>MOSFET</strong>： Metal-Oxide-Semiconductor Field Effect Transistor，即 <strong>金属氧化物半导体场效应管</strong>。同上。</p>\n<p><strong>BJT</strong>： Bipolar Junction Transistor， 即 <strong>双极结型晶体管</strong>。因带有两种不同极性电荷的载流子参与导电，故得名如此，或称 <strong>半导体三极管</strong>，简称 <strong>双极晶体管</strong> 或 <strong>晶体管</strong>。</p>\n<p><strong>UJT</strong>： Unijunction Transistor，即 <strong>单结晶体管</strong>。因有两个基极，也称为 <strong>双基极晶体管</strong>。</p>\n<p><strong>GTR</strong>： Giant Transistor，即 <strong>巨型晶体管</strong>。BJT的一种，亦称为 Power BJT（<strong>电力晶体管</strong>）。具有自关断、无须辅助关断电路、 高电流密度、低保和电压 和 耐高压 的优点。</p>\n<p><strong>IGBT</strong>： Insulated Gate Bipolar Transistor，即 <strong>绝缘栅双极型晶体管</strong>。</p>\n<p><strong>Thyristor</strong>：即 <strong>半导体闸流管</strong> 、<strong>晶闸管</strong>，又称为 <strong>硅可控元件</strong>（Silicon Controlled Rectifier）， 由按顺序排列的PNPN四层半导体组成。最外层的P区和N区构成了正负极，中间的P区构成了控制极（栅极），可以控制导通。具有耐压高、电流大、耐浪涌能力强 且 价格便宜 等优点。</p>\n<p><strong>GTO</strong>： Gate Turn-Off Thyristor，即 <strong>可关断晶闸管</strong>。是一种通过门极来控制器件导通和关断的电力半导体器件。具有 普通晶闸管 和 GTR的优点，是应用于高压大容量场合中的一种大功率开关器件。</p>\n<p><strong>PT</strong>： Power Transistor， 即 <strong>功率晶体管</strong> / <strong>功率管</strong>。</p>\n<p><strong>IPM</strong>： Intelligent Power Module，即 <strong>智能功率模块</strong>。具有GTR 和 MOSFET 的优点。而且IPM内部集成了逻辑、控制、检测和保护电路，使用起来方便,不仅减小了系统的体积以及开发时间，也大大增强了系统的可靠性。</p>\n<p><img src=\"https://pic.islet.space/2021/07/d4628535e5dde711c5d042b5a7efce1b9d166176\" alt=\"img\" style=\"zoom: 25%;\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n图 IPM器件示意\n</div>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li>《模拟电子技术基础》高等教育出版社，童师白</li>\n<li>《IGBT模块：技术、驱动和应用》机械工业出版社，Andreas Volke and Michael Hornkamp</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/366981878\">逆变器的分类方式有哪些</a></li>\n<li><a href=\"https://baike.baidu.com/item/IGBT/2078902?fromtitle=%E7%BB%9D%E7%BC%98%E6%A0%85%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1&amp;fromid=12731336\">IGBT</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1\">场效应管</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E6%99%B6%E4%BD%93%E4%BA%8C%E6%9E%81%E7%AE%A1\">晶体二极管</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E6%99%B6%E4%BD%93%E7%AE%A1/569042#:~:text=%E6%99%B6%E4%BD%93%E7%AE%A1%E6%9C%89%E6%97%B6%E5%A4%9A%E6%8C%87%E6%99%B6%E4%BD%93%E4%B8%89%E6%9E%81%E7%AE%A1%E3%80%82%20%E4%B8%89%E7%AB%AF%E5%AD%90%E6%99%B6%E4%BD%93%E7%AE%A1%E4%B8%BB%E8%A6%81%E5%88%86%E4%B8%BA%E4%B8%A4%E5%A4%A7%E7%B1%BB%EF%BC%9A%20%E5%8F%8C%E6%9E%81%E6%80%A7%E6%99%B6%E4%BD%93%E7%AE%A1,%EF%BC%88BJT%EF%BC%89%E5%92%8C%20%E5%9C%BA%E6%95%88%E5%BA%94%E6%99%B6%E4%BD%93%E7%AE%A1%20%EF%BC%88FET%EF%BC%8C%E5%8D%95%E6%9E%81%E6%80%A7%EF%BC%89%E3%80%82\">晶体管</a></li>\n<li><a href=\"https://circuitglobe.com/difference-between-diode-and-transistor.html\">Difference Between Diode &amp; Transistor</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/150177944\">半导体分类知识大全</a></li>\n<li><a href=\"https://xueqiu.com/3593206238/153075165\">IGBT—功率半导体皇冠上的明珠</a></li>\n<li><a href=\"https://www.electricaltechnology.org/2018/12/types-of-diodes-their-applications.html\">Types of Diodes and Their Applications - 24 Types of Diodes</a></li>\n</ol>\n","categories":["Semiconductor"],"tags":["Semiconductor"]},{"title":"Equipments in Debian Linux(KALI)","url":"/2021/05/22/Linux/2021-05-21-Equipments_in_debian_linux/","content":"<h1 id=\"介绍\">介绍</h1>\n<p>作为一个日常开发的程序员，三大平台都在日常使用的软件（生产力工具及娱乐工具）如下：</p>\n<ul>\n<li>utools</li>\n<li>typora</li>\n<li>visual studio code</li>\n<li>picgo</li>\n<li>sogou pinyin</li>\n<li>snipaste(win) / flameshot(linux) / ishot(mac)</li>\n<li>cosbrowser</li>\n<li>nodejs 及 npm</li>\n<li>hexo</li>\n<li>qqmusic</li>\n</ul>\n<p>win和mac安装软件都相对简单，linux安装需要使用者自身具有一定的耐心和排除困难的经验，为了更好地体验linux的方便，这里对linux装机后的生产力工具安装做个简单记录，以下安装均在 <strong>KALI</strong> （Kali也属于Debian系Linux）上进行。</p>\n<p>使用Linux系统的最大好处是 “一个终端即可解决即可开启大部分软件和解决日常事务，最多再开启一个utools”。</p>\n<p>Linux上的软件安装方式通常分为四种方式：</p>\n<ul>\n<li>通过 <code>dpkg</code> 命令安装 <code>.deb</code> 文件</li>\n<li>通过 <code>apt</code> 或其他软件的软件安装命令（如，<code>npm</code> 和 <code>pip</code>）来安装</li>\n<li>通过 <code>ln</code> 链接将程序绑定至全局变量来 “安装” 和使用</li>\n<li>通过直接调用 <code>AppImage</code> 的方式直接使用软件，此类方式需要一般需要手动双击执行</li>\n</ul>\n<p>其中前三种方式的困难因系统而异，所说的困难是可能出现所安装的软件依赖不存在，需要使用者自行去定位（包括下载和添加源）和安装，或者链接方式错误等。而Linux源众多，每个节点的速度及其更新情况都不太一样，需要使用者判断。</p>\n<h1 id=\"utools-flameshot\">uTools &amp; Flameshot</h1>\n<p><a href=\"https://res.u-tools.cn/currentversion/utools_1.3.5_amd64.deb\">uTools</a> 使用的是 <code>.deb</code> 安装包安装，flameshot 使用 <code>apt</code> 命令进行安装。</p>\n<p><strong>依赖文件</strong>：</p>\n<ol type=\"1\">\n<li><code>libspdlog1-fmt7</code> 是 flameshot所需文件</li>\n<li><code>libappindicator3-1</code> 是 utools所需文件</li>\n</ol>\n<h2 id=\"libspdlog1\">libspdlog1</h2>\n<p>尝试安装utools和flameshot后，apt会提示缺少文件。使用 <code>sudo apt-get install libspdlog1-fmt7</code> 来安装 <code>libspdlog1-fmt7</code> 。</p>\n<p>如果触发安装破损修复，使用<code>apt --fix-broken install</code> 可以让apt自动修复安装错误，自动补全依赖文件。</p>\n<h2 id=\"libappindicator3\">libappindicator3</h2>\n<p><code>libappindicator3-1</code> 文件需要使用者往 <code>/etc/apt/source.list</code> 中添加debian源，需要使用者掌握基本的 <code>vim</code> 软件使用方法（包括插入、保存和退出）。</p>\n<ul>\n<li><p>使用 <code>sudo vim /etc/apt/sources.list</code> 命令打开 <code>source.list</code> 。</p></li>\n<li><p>按 <code>i</code> 进入 <strong>插入模式</strong>，复制粘贴 <code>deb http://ftp.de.debian.org/debian sid main</code> 至空白处，按 <code>ESC</code> 键，再依次输入 <code>:wq</code> 进行保存和退出。</p></li>\n<li><p>在终端输入 <code>sudo apt-get update</code> 进行源库软件列表更新，再次尝试 <code>sudo apt-get install libappindicator3</code> 来安装</p>\n<p><code>libappindicator3-1</code> and <code>libappindicator3-7</code> 。</p></li>\n</ul>\n<p>最后再次尝试以下两条语句即可成功安装 utools 和 flameshot 。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo dpkg -i utools_1.3.5_amd64.deb</span><br><span class=\"line\">sudo apt-get install flameshot</span><br></pre></td></tr></table></figure>\n<h1 id=\"typora\">Typora</h1>\n<p><a href=\"https://tyopra.io\">TYPORA.IO</a> 官方提供的安装代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span><br><span class=\"line\">sudo add-apt-repository <span class=\"string\">&#x27;deb https://typora.io/linux ./&#x27;</span></span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install typora</span><br></pre></td></tr></table></figure>\n<p>其中，向apt中添加源的第二条语句 <code>add-apt-repository</code> 会因缺乏 <code>PPA</code> 而无法执行，可以参考 <a href=\"https://ywnz.com/linuxjc/7953.html#:~:text=%E6%9C%89%E4%BA%9B%E7%94%A8%E6%88%B7%E5%9C%A8UOS%E3%80%81Deepin%E7%AD%89%E6%9F%90%E4%BA%9BLinux%E5%8F%91%E8%A1%8C%E7%89%88%E7%BB%88%E7%AB%AF%E4%B8%AD%E8%BE%93%E5%85%A5PPA%E5%91%BD%E4%BB%A4%E6%97%B6%E4%BC%9A%E6%8F%90%E7%A4%BA%E2%80%9Csudo%3A%20add-apt-repository%EF%BC%9A%E6%89%BE%E4%B8%8D%E5%88%B0%E5%91%BD%E4%BB%A4%EF%BC%88command,not%20found%EF%BC%89%E2%80%9D%EF%BC%8C%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BA%E6%B2%A1%E6%9C%89%E5%AE%89%E8%A3%85PPA%E6%89%80%E8%87%B4%EF%BC%8C%E6%8A%8A%E5%AE%83%E5%AE%89%E8%A3%85%E4%B8%8A%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%B8%AD%E8%BF%90%E8%A1%8C%E4%B8%89%E6%9D%A1%E5%91%BD%E4%BB%A4%E3%80%82\">sudo: add-apt-repository：找不到命令的解决方法</a> 进行安装。</p>\n<p>也可以参考 <code>libappindicator3</code> 的源添加方法，往 <code>source.list</code> 文件中添加 <code>deb https://typora.io/linux ./</code> 来添加源。</p>\n<p>添加成功后即可成功安装tyopra。</p>\n<h1 id=\"sogou-pinyin\">Sogou Pinyin</h1>\n<p>从搜狗官方下载的 <a href=\"https://ime.sogoucdn.com/dl/index/1612260778/sogoupinyin_2.4.0.3469_amd64.deb?st=USANnSZV6afzzi2u6c8J-g&amp;e=1621603885&amp;fn=sogoupinyin_2.4.0.3469_amd64.deb\">Sogou</a> 安装包，需要用 <code>sudo dpkg -i sogoupinyin_2.4.0.3469_amd64.deb</code> 命令进行安装，会遇到以下缺乏库的提示，主要是因为缺少 <code>fcitx</code> 的提示。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">dpkg: 依赖关系问题使得 sogoupinyin 的配置工作不能继续：</span><br><span class=\"line\"> sogoupinyin 依赖于 fcitx (&gt;= 1:4.2.8)；然而：</span><br><span class=\"line\">  未安装软件包 fcitx</span><br><span class=\"line\"> sogoupinyin 依赖于 fcitx-frontend-gtk2；然而：</span><br><span class=\"line\">  未安装软件包 fcitx-frontend-gtk2。</span><br><span class=\"line\"> sogoupinyin 依赖于 fcitx-frontend-gtk3；然而：</span><br><span class=\"line\">  未安装软件包 fcitx-frontend-gtk3。</span><br><span class=\"line\"> sogoupinyin 依赖于 fcitx-frontend-qt5；然而：</span><br><span class=\"line\">  未安装软件包 fcitx-frontend-qt5。</span><br><span class=\"line\"> sogoupinyin 依赖于 fcitx-module-kimpanel；然而：</span><br><span class=\"line\">  未安装软件包 fcitx-module-kimpanel。</span><br><span class=\"line\"> sogoupinyin 依赖于 fcitx-module-x11；然而：</span><br><span class=\"line\">  未安装软件包 fcitx-module-x11。</span><br><span class=\"line\"> sogoupinyin 依赖于 im-config；然而：</span><br><span class=\"line\">  未安装软件包 im-config。</span><br><span class=\"line\"> sogoupinyin 依赖于 fcitx-libs | libfcitx-config4；然而：</span><br><span class=\"line\">  未安装软件包 fcitx-libs。</span><br><span class=\"line\">  未安装软件包 libfcitx-config4。</span><br><span class=\"line\"> sogoupinyin 依赖于 fcitx-libs | libfcitx-qt0；然而：</span><br><span class=\"line\">  未安装软件包 fcitx-libs。</span><br><span class=\"line\">  未安装软件包 libfcitx-qt0。</span><br><span class=\"line\"> sogoupinyin 依赖于 fcitx-libs | libfcitx-utils0；然而：</span><br><span class=\"line\">  未安装软件包 fcitx-libs。</span><br><span class=\"line\">  未安装软件包 libfcitx-utils0。</span><br><span class=\"line\"> sogoupinyin 依赖于 fcitx-ui-classic；然而：</span><br><span class=\"line\">  未安装软件包 fcitx-ui-classic。</span><br><span class=\"line\"> sogoupinyin 依赖于 libqt5quickwidgets5；然而：</span><br><span class=\"line\">  未安装软件包 libqt5quickwidgets5。</span><br><span class=\"line\"> sogoupinyin 依赖于 qml-module-qtquick2；然而：</span><br><span class=\"line\">  未安装软件包 qml-module-qtquick2。</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Fcitx[ˈfaɪtɪks]是 (Free Chinese Input Toy for X) 的英文缩写，中文名为小企鹅输入法，是一个以 GPL 方式发布的输入法框架， 编写它的目是为桌面环境提供一个灵活的输入方案，彻底解决在GNU/Linux下没有一个好的中文输入法的问题。</p>\n</blockquote>\n<h2 id=\"fcitx\">FCITX</h2>\n<p>通过输入 <code>sudo apt-get install fcitx</code> 来尝试安装，会触发 apt fix broken install， 此时只要再次输入 <code>sudo apt --fix-broken install</code> 来修复。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">下列软件包有未满足的依赖关系：</span><br><span class=\"line\"> fcitx : 依赖: fcitx-bin 但是它将不会被安装</span><br><span class=\"line\">         依赖: fcitx-data 但是它将不会被安装</span><br><span class=\"line\">         依赖: fcitx-modules 但是它将不会被安装</span><br><span class=\"line\">         推荐: fcitx-config-gtk 但是它将不会被安装 或</span><br><span class=\"line\">                 kde-config-fcitx 但是它将不会被安装</span><br><span class=\"line\">         推荐: fcitx-frontend-all 但是它将不会被安装 或</span><br><span class=\"line\">                 fcitx-frontend-fbterm 但是它将不会被安装</span><br><span class=\"line\">         推荐: fcitx-ui-classic 但是它将不会被安装 或</span><br><span class=\"line\">                 fcitx-ui-light 但是它将不会被安装</span><br><span class=\"line\">         推荐: im-config (&gt;= 0.5) 但是它将不会被安装</span><br><span class=\"line\"> sogoupinyin : 依赖: fcitx-frontend-gtk2 但是它将不会被安装</span><br><span class=\"line\">               依赖: fcitx-frontend-gtk3 但是它将不会被安装</span><br><span class=\"line\">               依赖: fcitx-frontend-qt5 但是它将不会被安装</span><br><span class=\"line\">               依赖: fcitx-module-kimpanel 但是它将不会被安装</span><br><span class=\"line\">               依赖: fcitx-module-x11 但是它将不会被安装</span><br><span class=\"line\">               依赖: im-config 但是它将不会被安装</span><br><span class=\"line\">               依赖: fcitx-libs 但是它将不会被安装 或</span><br><span class=\"line\">                       libfcitx-config4 但是它将不会被安装</span><br><span class=\"line\">               依赖: fcitx-libs 但是它将不会被安装 或</span><br><span class=\"line\">                       libfcitx-qt0 但无法安装它</span><br><span class=\"line\">               依赖: fcitx-libs 但是它将不会被安装 或</span><br><span class=\"line\">                       libfcitx-utils0 但是它将不会被安装</span><br><span class=\"line\">               依赖: fcitx-ui-classic 但是它将不会被安装</span><br><span class=\"line\">               依赖: libqt5quickwidgets5 但是它将不会被安装</span><br><span class=\"line\">               依赖: qml-module-qtquick2 但是它将不会被安装</span><br><span class=\"line\">E: 有未能满足的依赖关系。请尝试不指明软件包的名字来运行“apt --fix-broken install”(也可以指定一个解决办法)。</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装成功\">安装成功</h2>\n<p>FIX-BROKEN 成功后，再次尝试安装 FCITX 就可以提示成功；接着安装sogou即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install fcitx                   </span><br><span class=\"line\">正在读取软件包列表... 完成</span><br><span class=\"line\">正在分析软件包的依赖关系树... 完成</span><br><span class=\"line\">正在读取状态信息... 完成                 </span><br><span class=\"line\">fcitx 已经是最新版 (1:4.2.9.8-3)。</span><br><span class=\"line\">fcitx 已设置为手动安装。</span><br><span class=\"line\">升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 136 个软件包未被升级。</span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo dpkg -i sogoupinyin_2.4.0.3469_amd64.deb</span><br><span class=\"line\">(正在读取数据库 ... 系统当前共安装有 270000 个文件和目录。)</span><br><span class=\"line\">准备解压 sogoupinyin_2.4.0.3469_amd64.deb  ...</span><br><span class=\"line\">正在解压 sogoupinyin (2.4.0.3469) 并覆盖 (2.4.0.3469) ...</span><br><span class=\"line\">正在设置 sogoupinyin (2.4.0.3469) ...</span><br><span class=\"line\">正在处理用于 mailcap (3.69) 的触发器 ...</span><br><span class=\"line\">正在处理用于 desktop-file-utils (0.26-1) 的触发器 ...</span><br><span class=\"line\">正在处理用于 hicolor-icon-theme (0.17-2) 的触发器 ...</span><br></pre></td></tr></table></figure>\n<h2 id=\"依赖库\">依赖库</h2>\n<p>sogou输入法依赖库具体如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">下列【新】软件包将被安装：</span><br><span class=\"line\">  dbus-x11 fcitx fcitx-bin fcitx-config-common fcitx-config-gtk fcitx-data</span><br><span class=\"line\">  fcitx-frontend-all fcitx-frontend-gtk2 fcitx-frontend-gtk3</span><br><span class=\"line\">  fcitx-frontend-qt5 fcitx-libs fcitx-module-dbus fcitx-module-kimpanel</span><br><span class=\"line\">  fcitx-module-lua fcitx-module-x11 fcitx-modules fcitx-ui-classic</span><br><span class=\"line\">  fcitx5-module-quickphrase-editor im-config libfcitx-config4</span><br><span class=\"line\">  libfcitx-core0 libfcitx-gclient1 libfcitx-qt5-1 libfcitx-qt5-data</span><br><span class=\"line\">  libfcitx-utils0 libgettextpo0 libpresage-data libpresage1v5</span><br><span class=\"line\">  libqt5qmlworkerscript5 libqt5quickwidgets5 libtinyxml2.6.2v5 presage</span><br><span class=\"line\">  qml-module-qtquick2</span><br></pre></td></tr></table></figure>\n<h1 id=\"nodejs-hexo\">NodeJS &amp; Hexo</h1>\n<p>使用 <code>sudo apt-get install nodejs</code> 或 <code>sudo apt-get install node.js</code> 均可以实现node.js 的安装，但是只能安装V12版。</p>\n<p>可以在官方下载 <a href=\"https://nodejs.org/dist/v16.2.0/node-v16.2.0-linux-x64.tar.xz\">node-v16.2.0-linux-x64.tar.xz</a> ，并使用以下命令进行解压：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">xz -d node-v16.2.0-linux-x64.tar.xz</span><br><span class=\"line\">tar -xvf node-v16.2.0-linux-x64.tar</span><br></pre></td></tr></table></figure>\n<p>解压完毕之后，以管理员身份将该文件移动至 <code>/usr/local/node</code> ，以下命令将 <code>node-v16.2.0-linux-x64</code> 拷贝的同时进行了 <strong>重命名</strong> 操作。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo mv /home/XXX/downloads/node-v16.2.0-linux-x64 /usr/<span class=\"built_in\">local</span>/node</span><br></pre></td></tr></table></figure>\n<p style=\"color: gray; font-style: italic;\">\n注：XXX是用户名\n</p>\n<p>然后进行软连接：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo ln -s /usr/<span class=\"built_in\">local</span>/node/bin/node /usr/<span class=\"built_in\">local</span>/bin</span><br><span class=\"line\">sudo ln -s /usr/<span class=\"built_in\">local</span>/node/bin/npm /usr/<span class=\"built_in\">local</span>/bin</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Linux ln（英文全拼：link files）命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。</p>\n<p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p>\n</blockquote>\n<p>以上是 <code>ln</code> 链接命令的解释，实际最重要的作用是将某个已下载的软件及其命令定义至全局，在终端的任意一个目录位置都可以使用该软件。</p>\n<h2 id=\"安装-成功\">“安装” 成功</h2>\n<p>实际上新版的nodejs并不涉及 前述 <code>dpkg</code> 或 <code>apt</code> 命令的安装，但软连接该文件目录至 <code>/usr/local/bin</code> 后，能实现安装效果，使用 <code>node -v</code> 及 <code>npm -v</code> 命令即可进行测试。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br><span class=\"line\">v16.2.0</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm -v                   </span><br><span class=\"line\">7.14.0</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他\">其他</h2>\n<p>对于使用此类安装方式进行安装的 依赖于nodejs的应用如果需要在全局进行使用可能也需要进行软连接，如 hexo。</p>\n<p>使用 <code>npm install hexo-cli -g</code> 成功安装hexo后提示如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ whereis hexo</span><br><span class=\"line\">hexo:</span><br></pre></td></tr></table></figure>\n<p>此时需要将 <code>/usr/local/node/bin</code> 文件夹下安装的程序也拉到全局变量中 <code>/usr/local/bin</code> 中。再次使用 <code>whereis</code> 命令检测时即可成功。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo ln -s /usr/<span class=\"built_in\">local</span>/node/bin/hexo /usr/<span class=\"built_in\">local</span>/bin/hexo</span><br><span class=\"line\">                                                                             </span><br><span class=\"line\">$ whereis hexo</span><br><span class=\"line\">hexo: /usr/<span class=\"built_in\">local</span>/bin/hexo</span><br></pre></td></tr></table></figure>\n<h1 id=\"visual-studio-code\">Visual Studio Code</h1>\n<p>VS code安装使用 <code>dpkg</code> 命令，最大的问题是微软的源下载太慢，以下提供个人下载点，安装过程不再记录。</p>\n<p>个人下载点： <a href=\"https://storage.islet.space/02_Softwares/02_Microsoft/VisualStudioCode/Linux/code_1.55.2-1618307277_amd64.deb\">Visual Studio Code Linux (deb)</a></p>\n<h1 id=\"picgo\">PicGo</h1>\n<p><a href=\"https://support.typora.io/Upload-Image/#picgo-core-command-line-opensource\">Typora_Picgo</a> 有 command-line 版 和 app 版，参考 <a href=\"https://picgo.github.io/PicGo-Doc/zh/\">PicGo官方文档</a> （GFW封锁了<strong><em>github.io</em></strong>域名后缀，需要梯子）进行安装吧。</p>\n<h1 id=\"qqmusic-cosbrowser\">QQmusic &amp; cosbrowser</h1>\n<p>这两个软件都是腾讯家产品，下载、安装和使用都很方便。</p>\n<p>其中，QQMusic使用 <code>dpkg</code> 命令进行安装即可， <code>cosbrowser</code> 是 <code>AppImage</code> 格式文件，直接打开即可使用，无需安装。</p>\n<p><strong>彩蛋</strong>：<code>sudo apt-get install cmatrix</code></p>\n<p>---EOF---</p>\n","categories":["Linux"],"tags":["equipments","linux","debian","kali"]},{"title":"WSL and Baidu Netdisk","url":"/2021/10/27/Linux/2021-10-27-WSL-and-Baidu-Netdisk/","content":"<h1 id=\"wsl\">WSL</h1>\n<p>在windows的 linux子系统下安装的具有图形界面的软件都可以在windows上打开，但是如果直接在MS商店安装的 kali linux 子系统是最精简版本，很多开发者需要用的软件（如 gcc / make / vim 等）都不存在，需要使用官方提供的完整安装命令去安装一些必须程序。</p>\n<p>按照官方指示安装完必要程序后，可以在文件管理器里看到 linux 子系统的根目录，一定程度上很方便windows的用户使用linux系统并用图形化界面管理其文件。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211027104148.png\" alt=\"image-20211027103100831\" /><figcaption aria-hidden=\"true\">image-20211027103100831</figcaption>\n</figure>\n<h1 id=\"百度云盘安装\">百度云盘安装</h1>\n<p>百度云盘是个人经常使用到的工具，在linux系统上也会安装，但wsl系统的话，多少可能会因为某些依赖文件缺失导致安装失败。</p>\n<p>缺失的文件可以通过先更新源库（<code>sudo apt update</code>）再进行安装的方式解决，但有些时候可能是源库的问题，导致该依赖的包不存在（如下）。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211027104146.png\" alt=\"image-20211027104129827\" /><figcaption aria-hidden=\"true\">image-20211027104129827</figcaption>\n</figure>\n<p>因此需要通过手动下载（利用 <code>wget</code> ）该依赖包，然后自行安装（利用 <code>sudo dpkg -i</code> ）的方式来解决，其中百度云盘缺失的依赖文件及其包连接如下：</p>\n<ul>\n<li><code>libappindicator3-1</code>：http://mirrors.ustc.edu.cn/debian/pool/main/liba/libappindicator/libappindicator3-1_0.4.92-3.1_amd64.deb</li>\n<li><code>libindicator3-7</code>：http://mirrors.ustc.edu.cn/debian/pool/main/libi/libindicator/libindicator3-7_0.5.0-2_amd64.deb</li>\n<li><code>libdbusmenu-glib4</code>：http://ftp.br.debian.org/debian/pool/main/libd/libdbusmenu/libdbusmenu-glib4_18.10.20180917~bzr490+repack1-1_amd64.deb</li>\n<li><code>libdbusmenu-gtk3-4</code>：http://ftp.br.debian.org/debian/pool/main/libd/libdbusmenu/libdbusmenu-gtk3-4_18.10.20180917~bzr490+repack1-1_amd64.deb</li>\n</ul>\n<p>安装完毕之后即可正常进行软件使用了，虽然 wsl 的界面还是差强人意了些，哈哈。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211027104142.png\" alt=\"image-20211027104032244\" /><figcaption aria-hidden=\"true\">image-20211027104032244</figcaption>\n</figure>\n","categories":["Linux"],"tags":["Linux","Netdisk","dpkg","wget","wsl"]},{"title":"customize vscode font in debian linux","url":"/2022/01/22/Linux/2022-01-22-customize-vscode-font-in-debian-linux/","content":"<h1 id=\"install-fonts-on-debian-linux\">INSTALL FONTS ON DEBIAN LINUX</h1>\n<p>We can install <strong><em>True Type</em></strong> or <strong><em>Open Type</em></strong> fonts(<code>.ttf</code> / <code>.otf</code> / <code>.ttc</code>) in <em>DEBIAN LINUX</em>, like ubuntu or kali.</p>\n<h2 id=\"download-font-from-website\">DOWNLOAD FONT FROM WEBSITE</h2>\n<ol type=\"1\">\n<li>Download <code>Cascadia Code</code> from <code>https://github.com/microsoft/cascadia-code/releases</code> and unzip it.</li>\n<li>We got 3 folders here: <code>/otf/</code> , <code>/ttf/</code> and <code>woff2</code> , and we only need `ttf</li>\n</ol>\n<h2 id=\"copy-files-to-system-font-directory\">COPY FILES TO SYSTEM FONT DIRECTORY</h2>\n<p>Font fils are generally installed in either the system font directory on the path <code>/usr/share/fonts/</code> or in a user font directory that is frequently on one of the following paths:</p>\n<ul>\n<li><code>~/.local/share/fonts/</code></li>\n<li><code>~/usr/local/share/fonts/</code></li>\n</ul>\n<ol type=\"1\">\n<li>Execute the following command to copy the fonts to system path</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo cp -r ttf /usr/share/fonts/CascadiaCode</span><br></pre></td></tr></table></figure>\n<h2 id=\"generate-font-chache\">GENERATE FONT CHACHE</h2>\n<p>We need to build font infomation caches for apps using fontconfig for their font handling.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/share/fonts/CascadiaCode</span><br><span class=\"line\">fc-cache -f -v</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong><em>NOTE</em></strong></p>\n<p>If you cannot execute <code>fc-cache</code> command , copy and execute the following command in terminal.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt install fontconfig</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"verify-the-font-installation\">VERIFY THE FONT INSTALLATION</h2>\n<p>Confirm that the fonts are installed by displaying the paths and style definitions with <code>fc-list</code> command filtered on the font family name with <code>grep</code> .</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">fc-list | grep <span class=\"string\">&quot;Cascadia Code&quot;</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"customize-vscode\">CUSTOMIZE VSCODE</h1>\n<ol type=\"1\">\n<li>Get to <code>Setting</code></li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220122161611892.png\" alt=\"image-20220122161611892\" /><figcaption aria-hidden=\"true\">image-20220122161611892</figcaption>\n</figure>\n<ol start=\"2\" type=\"1\">\n<li>Search <code>font</code> in the bar</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220122161750043.png\" alt=\"image-20220122161750043\" /><figcaption aria-hidden=\"true\">image-20220122161750043</figcaption>\n</figure>\n<ol start=\"3\" type=\"1\">\n<li>Add <code>'Cascadia Code',</code> to the <code>Editor: Font Family</code> .</li>\n<li>Restart vscode.</li>\n</ol>\n","categories":["Linux"],"tags":["linux","vscode","font"]},{"title":"C socket","url":"/2021/01/15/Networking/2021-01-15-C-Socket/","content":"<h1 id=\"tcp\">TCP</h1>\n<p>在TCP/IP协议族中，网络层IP提供的是一种不可靠的服务。也就是说，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。而另一方面，TCP在不可靠的IP层上提供了一个可靠的运输层。为了提供这种可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。由此可见，运输层和网络层分别负责不同的功能。</p>\n<p>在四层网络结构，由下之上分别是：<code>数据链路层</code>、<code>网络层</code>、<code>传输层</code>及<code>应用层</code>。</p>\n<p><strong>数据链路层 </strong>协议典型如：Ethernet、ARP、ICMP</p>\n<p><strong>网络层</strong> 协议典型如：IP</p>\n<p><strong>传输层 </strong>协议典型如：TCP、UDP</p>\n<p><strong>应用层</strong> 协议典型如：HTTP、FTP等</p>\n<figure>\n<img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/TCPIP-01.png\" alt=\"TCPIP-01\" /><figcaption aria-hidden=\"true\">TCPIP-01</figcaption>\n</figure>\n<p style=\"text-align: center; color: #999; font-weight: 600;\">\n图1-4 TCP/IP协议族中不同层次的协议\n</p>\n<p>为协议ICMP和IGMP定位一直是一件很棘手的事情。在图1-4中，把它们与IP放在同一层上，那是因为事实上它们是IP的附属协议。但是在这里，又把它们放在IP层的上面，这是因为ICMP和IGMP报文都被封装在IP数据报中。</p>\n<p>使用TCP/IP协议的应用程序通常采用两种应用编程接口（API）：socket和TLI（运输层接口：Transport Layer Interface）。前者有时称作“Berkeley Socket”，表明它是从 <strong>伯克利</strong> 版发展而来的。后者起初是由AT&amp;T开发的，有时称作XTI（X/Open运输层接口），以承认X/Open这个自己定义标准的国际计算机生产商所做的工作。XTI实际上是TLI的一个超集。</p>\n<h2 id=\"tcp-introduce\">TCP Introduce</h2>\n<p>TCP(Transmission Control Protocol)传输控制协议，是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。</p>\n<h3 id=\"tcp-structure20210218-03\">TCP Structure<img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/20210218-03.png\" alt=\"20210218-03\" /></h3>\n<figure>\n<img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/20210218-02.png\" alt=\"20210218-02\" /><figcaption aria-hidden=\"true\">20210218-02</figcaption>\n</figure>\n<table>\n<colgroup>\n<col style=\"width: 44%\" />\n<col style=\"width: 11%\" />\n<col style=\"width: 44%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: left;\">Definitions</th>\n<th style=\"text-align: left;\">Length</th>\n<th>Explain</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">源端口 Source Port</td>\n<td style=\"text-align: left;\">16bits（2bytes）</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">目的端口 Destination Port</td>\n<td style=\"text-align: left;\">16bits（2bytes）</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><strong>序号 Sequence Number</strong></td>\n<td style=\"text-align: left;\">32bits（4bytes）</td>\n<td>指定了当前数据分片中分配给 <mark>第一字节数据</mark> 的序列号。<strong><em>在TCP传输流中每一个字节为一个序号</em></strong>。如果TCP报文中flags标志位为SYN，该序列号表示 <strong><em>初始化序列号(ISN)</em></strong>，此时第一个数据应该是从序列号ISN+1开始。</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><strong>确认号 Acknowledgement Number</strong></td>\n<td style=\"text-align: left;\">32bits（4bytes）</td>\n<td>表示TCP发送者期望接受下一个数据分片的序列号。该序号在TCP分片中Flags标志位为ACK时生效。序列号分片的方向和流的方向同方向，而确认序列号分片方向和流方向反方向。</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><em>偏移量 Data-Offset</em></td>\n<td style=\"text-align: left;\">4bits</td>\n<td>数据偏移也叫首部长度。<br/>因为首部长度实际也说明了数据区在分片中的起始偏移值。它表示TCP头包含了多少个32-bit的words。因为4bits在十进制中能表示的最大值为15，32bits表示4个字节，那么Data Offset的最大可表示<code>15*4=60</code>个字节（bytes）。<br />所以TCP报头长度最大为60字节。如果<code>options field</code>为0的话，报文头长度为20个字节。</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><em>保留域 Reserved field</em></td>\n<td style=\"text-align: left;\">3bits（或6bits）</td>\n<td>值全为零</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><strong>标志位 Flags</strong></td>\n<td style=\"text-align: left;\">9bits（或6bits）</td>\n<td>表示TCP包特定的连接状态，一个标签位占一个bit。</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">窗口 Window</td>\n<td style=\"text-align: left;\">16bits（2bytes）</td>\n<td>表示滑动窗口的大小，用来告诉发送端接收端的buffer space的大小。接收端buffer大小用来控制发送端的发送数据数率，从而达到流量控制。最大值为65535.</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">检验和 Checksum</td>\n<td style=\"text-align: left;\">16bits（2bytes）</td>\n<td>用来检查TCP头在传输中是否被修改。</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">紧急指针 Urgent Pointer</td>\n<td style=\"text-align: left;\">16bits（2bytes）</td>\n<td>表示TCP片中第一个紧急数据字节的指针。只有当URG标志置1时紧急指针才有效。</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><strong><em>可变部分 Options Field</em></strong> 和 <strong><em>填充部分 Padding Field</em></strong></td>\n<td style=\"text-align: left;\">可变长度。</td>\n<td>表示TCP可选选项以及填充位。当选项不足32bits时，填充字段加入额外的0填充。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"tcp-flags\">TCP Flags</h3>\n<p>对于旧版本的TCP头定义，Flags有6bits，新版TCP头对flags扩展了3bits。每个TCP flag对应于1bit 。所以旧版TCP头flags值有6个，新版扩展了3个值。</p>\n<p>从低位到高位分别是：</p>\n<table>\n<colgroup>\n<col style=\"width: 49%\" />\n<col style=\"width: 50%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Definition</th>\n<th>Declaration</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong>FIN</strong><br/> (finished 结束)</td>\n<td>表示发送者以及发送完数据。通常用在发送者发送完数据的最后一个包中。</td>\n</tr>\n<tr class=\"even\">\n<td><strong>SYN</strong><br/> (synchronous 建立联机)</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td><strong>RST</strong><br/>(reset 重置)</td>\n<td>重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。<br />或者发送包发送到一个不是期望的目的主机时，接收端发送reset 重置连接标志的包。</td>\n</tr>\n<tr class=\"even\">\n<td><strong>PSH</strong><br/> (push 传送)</td>\n<td>通知接收端处理接收的报文，而不是将报文缓存到buffer中。</td>\n</tr>\n<tr class=\"odd\">\n<td><strong>ACK</strong><br/>(acknowledgement 确认)</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td><strong>URG</strong><br/> (urgent 紧急)</td>\n<td>通知接收端处理在处理其他包前优先处理接收到的紧急报文。</td>\n</tr>\n<tr class=\"odd\">\n<td><strong>ECE</strong><br/> (Explicit Congestion Notification Echo) 【新】</td>\n<td>表示TCP peer有ECN能力。</td>\n</tr>\n<tr class=\"even\">\n<td><strong>CWR</strong><br/>(Congestion Window Reduced)【新】</td>\n<td>发送者在接收到一个带有ECE flag包时，将会使用CWR flag。</td>\n</tr>\n<tr class=\"odd\">\n<td><strong>NS</strong><br/> (Nonce Sum)【新】</td>\n<td>该标签用来保护不受发送者发送的突发的恶意隐藏报文的侵害。</td>\n</tr>\n</tbody>\n</table>\n<p>TCP 连接的建立都是采用<code>客户-服务器(Client-Server)</code>方式：</p>\n<ul>\n<li>主动发起连接建立的应用进程叫做客户(client)。</li>\n<li>被等待连接建立的应用进程叫做服务器(server)。</li>\n</ul>\n<p>传输连接就有三个阶段，即：<strong>连接建立</strong>、<strong>数据传输</strong> 和 <strong>连接释放</strong> 。</p>\n<p>TCP 采用全双工模式，在连接建立后和连接释放前进行数据传输。数据传输是单向的，从发送端传输给接受端。TCP通过序列号能够保证数据被接受端接受。TCP建立连接是通过三次握手的方式来建立连接的。</p>\n<h2 id=\"tcp-three-way-handshake\">TCP Three-Way Handshake</h2>\n<blockquote>\n<p><strong>注意</strong>： 不管是大小写，<code>ack</code> ( 或 <code>Ack</code> )和 <code>ACK</code> 都是 <strong>确认</strong> 的意思， 不同之处在于：</p>\n<ul>\n<li>在TCP首部中，<code>ACK</code>为确认标志位 ——占 1 字节，只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。；</li>\n<li><code>Ack</code>为确认号字段（Ack Number）——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。</li>\n</ul>\n</blockquote>\n<h3 id=\"the-steps-of-three-way-handshake\">The Steps of Three-Way Handshake</h3>\n<p><strong>第一次握手：</strong>Client发送位码为<code>SYN＝1</code> ，随机产生 <code>seq number=1234567</code> 的数据包到服务器，Server收到 <code>SYN=1</code>，知道Client要求建立联机；</p>\n<p><strong>第二次握手：</strong>Server收到请求后要确认联机信息，向Client发送<code>ack number=(Client的seq+1)</code>，<code>SYN=1</code>， <code>ACK=1</code> ，随机产生 <code>seq number=7654321</code> 的包；</p>\n<p><strong>第三次握手：</strong>Client 收到后检查 <code>ack number</code> 是否正确，即第一次发送的seq number+1，以及位码 <code>ACK</code>是否为 1，若正确，Client 会再发送 <code>ack number=(主机B的seq+1)</code> ，<code>ACK=1</code>，Server 收到后确认<code>seq number</code> 值与<code>ACK=1</code>则连接建立成功。</p>\n<p>完成三次握手，主机A与主机B开始传送数据。</p>\n<pre class=\"mermaid\">sequenceDiagram\nClient ->> Server: SYN=1  [seq number=1234567]\nServer -->> Client: SYN = 1, ACK = 1  [ack number = 1234568，seq number = 7654321]\nClient ->> Server: ACK = 1 [ack number = 7654322]</pre>\n<p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。 <strong>第一次握手：</strong>建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； <strong>第二次握手：</strong>服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； <strong>第三次握手：</strong>客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据.</p>\n<h3 id=\"the-meaning-of-three-way-handshake\">The Meaning of Three-way handshake</h3>\n<p>向客户端确认这个请求，这两个数据包（前两次握手）足以证明客户端与服务器之间的网络是畅通的，并且协商数据通信所需要的参数。比如协商接收窗口大小，所支持的数据包最大字节数等。</p>\n<p>如果没有最后一个数据包确认（第三次握手），A先发出一个建立连接的请求数据包，由于网络原因绕远路了。A经过设定的超时时间后还未收到B的确认数据包，于是发出第二个建立连接的请求数据包，这次网路通畅，数据包很快到达B，B的确认数据包也很快就到达A。于是A与B开始传输数据，过了一会A第一次发出的建立连接的请求数据包到达了B，B以为是再次建立连接，所以又发出一个确认数据包。由于A已经收到了一个确认数据包，所以会忽略B发来的第二个确认数据包，但是B发出确认数据包之后就要一直等待A的回复，而A永远也不会回复。由此造成服务器资源浪费，这种情况多了B计算机可能就停止响应了。</p>\n<p>第三次握手（第三个数据包）作用在于，告诉B计算机，B第二次握手发给A的确认数据包A收到了，是有效的。避免B计算机等待造成资源浪费。随后A与B可进行下一步的通信。</p>\n<p><strong>连接建立 </strong>过程中要解决以下三个问题：</p>\n<ul>\n<li>要使每一方能够确知对方的存在。</li>\n<li>要允许双方协商一些参数（如 <code>最大报文段长度</code>，<code>最大窗口大小</code>，<code>服务质量</code> 等）。</li>\n<li>能够对运输实体资源（如 <code>缓存大小</code>，<code>连接表中的项目</code> 等）进行分配。</li>\n</ul>\n<p><strong>连接建立过程中，客户端存在以下状态：</strong></p>\n<p><strong>SYN-SENT：</strong>在未与目标服务器建立连接之前始终处于此状态，并将不断向目标服务器发送请求，直到 <code>收到</code> 并 <code>回复</code> 来自服务器的信息后，方进入下一个状态。 <strong>ESTABLISHED：</strong>稳定连接状态。</p>\n<p><strong>连接建立过程中，服务器存在以下状态：</strong></p>\n<p><strong>LISTEN：</strong> 在未与客户端建立连接之前，始终处于此状态，在收到客户端的连接请求后答复其请求，并进入下一个状态。 <strong>SYN-RCVD：</strong> 等待SYN信息到达后进入下一个状态。 <strong>ESTABLISHED：</strong>稳定连接状态。</p>\n<figure>\n<img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/20210218-01.png\" alt=\"20210218-01\" /><figcaption aria-hidden=\"true\">20210218-01</figcaption>\n</figure>\n<p><strong>连接建立文字图解：</strong></p>\n<blockquote>\n<p>Client 发出 <code>同步数据包（请求建立连接的数据包）</code> 并进入SYN-SENT状态。</p>\n<ul>\n<li>SYN = 1， 表示该为一个连接建立请求数据包；</li>\n<li>ACK = 0，说明数据包确认号无效，省略；</li>\n<li>Seq=x，x为所传送数据的第一个字节的序号。</li>\n</ul>\n<p>Server 收到Client发出的 <code>同步数据包</code> 后结束LISTEN状态，进入SYN-RCVD状态并向A发出 <code>确认同步数据包</code>。</p>\n<ul>\n<li>SYN=1；</li>\n<li>ACK=1；</li>\n<li>seq=y，y的值由B指定表示B发送数据时的 <strong><em>第一个数据字节的序号</em></strong> ；</li>\n<li>ack=x+1，表示已经收到A发送的x个字节数据，并告诉A下次应从数据的第x+1个字节开始发送。</li>\n</ul>\n<p>Client 收到<code>确认同步数据包</code>之后，向B答复 <code>确认数据包</code> ，结束 SYN-SENT 状态，进入 ESTABLISHED 状态。</p>\n<ul>\n<li>SYN=0，表示双方已同意建立连接；</li>\n<li>ACK=1，表示收到B的确认数据包；</li>\n<li>seq=x+1，表示发出的数据包就是数据的第x+1个字节；</li>\n<li>ack=y+1，表示收到了B发送y字节数据，并告诉B下次应从数据的第y+1个字节开始发送。</li>\n</ul>\n<p>Server 收到 Client 的 <code>确认数据包</code> 之后，结束SYN-RCVD状态，进入ESTABLISHED状态。</p>\n</blockquote>\n<h2 id=\"tcp-four-way-wavehand\">TCP Four-Way-Wavehand</h2>\n<p>结束连接时，不管是Client或Server均可以主动发起结束信标FIN或RST。此处称主动发起结束信标的一方为主动方，另一方为被动方。</p>\n<h3 id=\"the-meaning-of-four-way-wavehand\">The Meaning of Four-Way-Wavehand</h3>\n<p>当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。</p>\n<p>但未必被动方所有的数据都完整的发送给了主动方，所以 <mark>被动方不会马上关闭SOCKET</mark>，它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。</p>\n<h3 id=\"the-steps-of-four-way-wavehand\">The Steps of Four-Way-Wavehand</h3>\n<ol type=\"1\">\n<li><p><strong>第一次挥手：</strong>Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入 <code>FIN_WAIT_1</code> 状态。</p></li>\n<li><p><strong>第二次挥手：</strong>Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入`<code>CLOSE_WAIT</code> 状态。</p></li>\n<li><p><strong>第三次挥手：</strong>Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入 <code>LAST_ACK</code> 状态。</p></li>\n<li><p><strong>第四次挥手：</strong>Client收到FIN后，Client进入`<code>TIME_WAIT</code> 状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入 <code>CLOSED</code> 状态，完成四次挥手</p></li>\n</ol>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/70.jpg\" style=\"zoom:50%;\" /></p>\n<h3 id=\"rst\">RST</h3>\n<h4 id=\"differences-between-fin-and-rst\">Differences between FIN and RST</h4>\n<blockquote>\n<p><strong>关键字：</strong> 主动释放、有序释放、终止释放</p>\n</blockquote>\n<p><strong>释放</strong> 即发送方和接收方终止连接，解除连接状态。</p>\n<p>发送方和接收方均可主动释放。最常见的是，主动释放端会发送<code>FIN</code>包，并且因为TCP是双工的， 仅关闭一个方向上的数据流，从而TCP连接处于<strong>半关闭状态</strong>，继续完成四次挥手完成连接释放。</p>\n<p>上述挥手是一种 <strong>有序释放</strong> ， 即，标志位为<code>FIN</code>的TCP报文会在之前所有排队的数据发送完之后，才会发送，在socket缓冲区和窗口中的数据也能保证发送成功。</p>\n<p>通常我们调用 <code>shutdown()</code> , <code>close()</code> 函数后， TCP会发送<code>FIN</code>报文。</p>\n<blockquote>\n<p>shutdown 和 close 的区别：</p>\n<ul>\n<li>shutdown是关闭一个socket， 可以关闭读、写、读写；</li>\n<li>close是关闭一个linux系统的文件描述符fd。</li>\n</ul>\n</blockquote>\n<p>除了“有序释放”， 还有一种 <strong>终止释放</strong> ，比如进程异常退出，用来关闭异常连接使用，是通过 <code>RST</code> 标志位实现的。 标志位为 <code>RST</code> 的TCP报文，会立即发送，<u>而之前所有在缓存区排队的数据都将被RST发送方丢弃。</u></p>\n<p><mark>FIN报文需要应答 <code>ACK</code> , RST报文不需要应答 <code>ACK</code>。</mark></p>\n<p><strong>半开连接</strong>：如果发生断点，或网络条件很差，其中一端发送 <code>RST</code> 后会立马关闭连接；而另一端可能感知不到，仍然认为连接正常，造成一种半开连接的状态。</p>\n<h4 id=\"why-do-we-send-rst\">Why do we send RST?</h4>\n<p>RST标志位被发送，通常是因为一下几种原因：</p>\n<blockquote>\n<ol type=\"1\">\n<li>A向B发起连接，但B之上并没有应用监听相应的端口，这时B操作系统上的TCP处理程序会发RST包。</li>\n<li>请求超时，即由于主动连接端连接请求超时，主动发起RST关闭连接。</li>\n<li>在一个已关闭的socket上收到数据</li>\n<li>字节流接收不完全</li>\n</ol>\n</blockquote>\n<p><strong>情况二：</strong> 有89、27两台主机。主机89向主机27发送了一个SYN，表示希望连接8888端口，主机27回应了主机89一个SYN表示可以连接。但是主机89却很不友好，莫名其妙的发送了一个RST表示我不想连接你了。 后来经过排查发现，在主机89上的程序在建立了socket之后，用setsockopt的SO_RCVTIMEO选项设置了recv的超时时间为100ms。而我们看上面的抓包结果表示，从主机89发出SYN到接收SYN的时间多达110ms。（从15:01:27.799961到15:01:27.961886， 小数点之后的单位是微秒）。因此主机89上的程序认为接收超时，所以发送了RST拒绝进一步发送数据。</p>\n<p><strong>情况三：</strong> 比如，AB正常建立连接了，正在通讯时，A向B发送了FIN包要求关连接，B发送ACK后，网断了，A通过若干原因排查后放弃了这个连接（例如进程重启）。网通了后，B又开始发数据包，A收到后表示压力很大，不知道这野连接哪来的，就发了个RST包强制把连接关了，B收到后会出现connect reset by peer错误。</p>\n<h1 id=\"wireshark-tutorial\">Wireshark Tutorial</h1>\n<p>Wireshark是一款可以监听和捕捉网络通信数据的软件，对捕获的数据自下而上进行解码和分析至已知协议。如(Ethernet II -- IP -- TCP 或 Ethernet II -- IP -- TCP -- HTTP)。</p>\n<p>Wireshark主要通过 <strong>捕获过滤</strong> 和 <strong>显示过滤</strong> 对所有数据进行 <strong>捕获时过滤</strong> 或 <strong>捕获后显示过滤</strong>。</p>\n<h2 id=\"capturing-filters-捕获过滤\">Capturing Filters 捕获过滤</h2>\n<h3 id=\"filtering-packets-while-capturing-捕获时可用的过滤组件\">Filtering packets while capturing 捕获时可用的过滤组件</h3>\n<p>Capture Filters are used to filter out uninteresting packets already at capture time. This is done to reduce the size of the resulting capture (file) and is especially useful on high traffic networks or for long term capturing.</p>\n<p>Wireshark uses the pcap (libpcap/WinPcap) filter language for capture filters. This language is explained in the tcpdump man page under \"expression\" (http://www.tcpdump.org and search for \"selects which\").</p>\n<p>Note: This capture filter language is different from the one used for the Wireshark display filters!</p>\n<p>捕获过滤器的使用方式为：菜单栏上的 <code>捕获</code> --&gt; <code>选项</code> --&gt; <code>所选择接口的捕获过滤器</code> 中输入对应的过滤条件。</p>\n<hr />\n<h4 id=\"some-common-examples-一些通用示例\">Some common examples 一些通用示例</h4>\n<p><strong>Example Ethernet:</strong> capture all traffic to and from the Ethernet address 08:00:08:15:ca:fe</p>\n<p>ether <code>host 08:00:08:15:ca:fe</code></p>\n<p><strong>Example IP:</strong> capture all traffic to and from the IP address 192.168.0.10</p>\n<p><code>host 192.168.0.10</code></p>\n<p><strong>Example TCP:</strong> capture all traffic to and from the TCP port 80 (http) of all machines</p>\n<p><code>tcp port 80</code></p>\n<p><strong>Examples combined:</strong> capture all traffic to and from 192.168.0.10 except http</p>\n<p><code>host 192.168.0.10 and not tcp port 80</code></p>\n<p>Beware: if you capture TCP/IP traffic with the primitives \"host\" or \"port\", you will not see the ARP traffic belonging to it!</p>\n<hr />\n<h4 id=\"capture-filter-syntax-捕获过滤器标志\">Capture Filter Syntax 捕获过滤器标志</h4>\n<p>The following is a short description of the capture filter language syntax. For a further reference, have a look at: http://www.tcpdump.org/tcpdump_man.html</p>\n<p>A capture filter takes the form of a series of <strong>primitive expressions</strong>, connected by conjunctions (and/or) and optionally preceded by not:</p>\n<p><strong>[not] primitive [and|or [not] primitive ...]</strong></p>\n<p>A primitive is simply one of the following:</p>\n<p><strong>[src|dst] host <host></strong></p>\n<p>This primitive allows you to filter on a host IP address or name. You can optionally precede the primitive with the keyword <code>src|dst</code> to specify that you are only interested in source or destination addresses. If these are not present, packets where the specified address appears as either the source or the destination address will be selected.</p>\n<p><strong>ether [src|dst] host <ehost></strong></p>\n<p>This primitive allows you to filter on Ethernet host addresses. You can optionally include the keyword <code>src|dst</code> between the keywords ether and host to specify that you are only interested in source or destination addresses. If these are not present, packets where the specified address appears in either the source or destination address will be selected.</p>\n<p><strong>gateway host <host></strong></p>\n<p>This primitive allows you to filter on packets that used host as a gateway. That is, where the Ethernet source or destination was host but neither the source nor destination IP address was host.</p>\n<p><strong>[src|dst] net <net> [{mask <mask>}|{len <len>}]</strong></p>\n<p>This primitive allows you to filter on network numbers. You can optionally precede this primitive with the keyword <code>src|dst</code> to specify that you are only interested in a source or destination network. If neither of these are present, packets will be selected that have the specified network in either the source or destination address. In addition, you can specify either the netmask or the <strong>CIDR</strong> <em>(Classless Inter-Domain Routing)</em> prefix for the network if they are different from your own.</p>\n<p><strong>[tcp|udp] [src|dst] port <port></strong></p>\n<p>This primitive allows you to filter on TCP and UDP port numbers. You can optionally precede this primitive with the keywords src|dst and tcp|udp which allow you to specify that you are only interested in source or destination ports and TCP or UDP packets respectively. The keywords tcp|udp must appear before src|dst. If these are not specified, packets will be selected for both the TCP and UDP protocols and when the specified address appears in either the source or destination port field.</p>\n<p><strong>less|greater <length></strong></p>\n<p>This primitive allows you to filter on packets whose length was less than or equal to the specified length, or greater than or equal to the specified length, respectively.</p>\n<p><strong>ip|ether proto <protocol></strong></p>\n<p>This primitive allows you to filter on the specified protocol at either the Ethernet layer or the IP layer.</p>\n<p>ether|ip broadcast|multicast</p>\n<p>This primitive allows you to filter on either Ethernet or IP broadcasts or multicasts.</p>\n<p><strong><expr> relop <expr></strong></p>\n<p>This primitive allows you to create complex filter expressions that select bytes or ranges of bytes in packets. Please see the tcpdump man pages for more details.</p>\n<h2 id=\"capturing-捕获\">Capturing 捕获</h2>\n<p>This section will explain the capturing options and give hints on what to do in some special cases.</p>\n<h3 id=\"capture-options-捕获设置\">Capture options 捕获设置</h3>\n<p>The capture options can be logically divided into the following categories:</p>\n<p>-input -filtering -stop conditions -storing -display while capturing</p>\n<h3 id=\"input-options-输入设置\">Input options 输入设置</h3>\n<p><strong>-Interface</strong>: You have to choose which interface (network card) will be used to capture packets from. Be sure to select the correct one, as it's a common mistake to select the wrong interface.</p>\n<p><strong>-Link-layer header type</strong>: unless you are in the rare case that you will need this, just keep the default.</p>\n<h3 id=\"filtering-options-过滤设置\">Filtering options 过滤设置</h3>\n<p><strong>-Capture packets in promiscuous mode</strong>: Usually a network card will only capture the traffic to its own network address. If you want to capture all traffic that the network card can \"see\", mark this option. See the FAQ for some more details of capturing packets from a switched network.</p>\n<p><strong>-Limit each packet to xy bytes</strong>: Will limit the maximum size to be captured of each packet, this includes the link-layer header and all subsequent headers. This can be useful when an error is known to be in the first 20 bytes of a packet, for example, as the size of the resulting capture file will be reduced.</p>\n<p><strong>-Capture Filter</strong>: Use a capture filter to reduce the amount of packets to be captured. See \"Capture Filters\" in this help for further information how to use it.</p>\n<h3 id=\"storing-options-存储设置\">Storing options 存储设置</h3>\n<p><strong>-File</strong>: You can choose the file to which captured data will be written. If you don't enter something here a temporary file will be used.</p>\n<p><strong>-Use multiple files</strong>: Instead of using a single capture file, multiple files will be created. The generated filenames will contain an incrementing number and the start time of the capture. For example, if you choose \"/foo.cap\" in the \"File\" field, files like \"/foo_00001_20040205110102.cap\", \"/foo_00002_20040205110102.cap\", ... will be created. This feature can be useful if you do long term capturing, as working with a single capture file of several GB usually isn't very fast.</p>\n<h3 id=\"stop-condition-options-终止设置\">Stop condition options 终止设置</h3>\n<p>These three fields should be obvious; the capture process will be automatically stopped if one of the selected conditions is exceeded.</p>\n<h3 id=\"display-while-capturing-options\">Display while capturing options</h3>\n<p>-Update list of packets in real time: Using this will show the captured packets immediately on the main screen. Please note: this will slow down capturing, so increased packet drops might appear.</p>\n<p>-Automatic scrolling in live capture: This will scroll the \"Packet List\" automatically to the latest captured packet, when the \"Update List of packets in real time\" option is used.</p>\n<p>-Name resolution: perform the corresponding name resolution while capturing.</p>\n<h3 id=\"high-performance-capturing-高性能模式捕获\">High performance capturing 高性能模式捕获</h3>\n<p>When your network traffic is high, you might need to take some steps to ensure Wireshark doesn't get behind on its capture, particularly if you're running it on a slow computer.</p>\n<p>When Wireshark cannot keep up, packets are dropped. To help avoid this as much as possible:</p>\n<ol type=\"a\">\n<li><p>Don't use the \"Update list of packets in real time\" option (see above). This has a significant performance penalty.</p></li>\n<li><p>Close other programs that might slow down your system, such as virus scanner software, server processes, etc.</p></li>\n<li><p>It might be a good idea not to use a capture filter. This will depend on the task you have to do. As a rule of thumb: if you want to see most of the packets and only filter a small number out, don't use a capture filter (you can use a display filter later). If you only want to capture a small proportion of the packets, it might be better to set a capture filter, as this will reduce the number of packets that have to be saved.</p></li>\n<li><p>If you still get packet drops, it might be an idea to use a tool dedicated to packet capturing and only use Wireshark for displaying and analyzing the packets.</p></li>\n</ol>\n<p>Have a look at tshark, the command line variant of wireshark, which is included in this package. XXX: add a list of possibly useful standalone capture programs.</p>\n<h3 id=\"long-term-capturing-长期捕获\">Long term capturing 长期捕获</h3>\n<p>By \"Long term capturing\", it's meant to capture data from a network for several hours or even days. Long term capturing will usually result in huge capture files, being hundreds of MB's or even several GB's in size!</p>\n<p>Before doing a long term capture, get familiar with the options to use for it, as you might not get what you desire. Doing a long term capture not getting the results needed, is usually wasting a lot of time. ;-)</p>\n<p>Rules of thumb for this task: -Use the ring buffer feature when you expect very large capture files. -Don't use the \"Update list of packets in real time\" option. -Set an appropriate capture filter, when you are only interested in some special packets from the net.</p>\n<h2 id=\"display-filter-显示过滤器\">Display Filter 显示过滤器</h2>\n<h3 id=\"filtering-packets-while-viewing-观察时的过滤器组件\">Filtering packets while viewing 观察时的过滤器组件</h3>\n<p>After capturing packets or loading some network traffic from a file, Wireshark will display the packet data immediately on the screen.</p>\n<p>Using display filters, you can choose which packets should (not) be shown on the screen. This is useful to reduce the \"noise\" usually on the network, showing only the packets you want to. So you can concentrate on the things you are really interested in.</p>\n<p>The display filter will not affect the data captured, it will only select which packets of the captured data are displayed on the screen.</p>\n<p>Every time you change the filter string, all packets will be reread from the capture file (or from memory), and processed by the display filter \"machine\". Packet by packet, this \"machine\" is asked, if this particular packet should be shown or not.</p>\n<p>Wireshark offers a very powerful display filter language for this. It can be used for a wide range of purposes, from simply: \"show only packets from a specific IP address\", or on the other hand, to very complex filters like: \"find all packets where a special application specific flag is set\".</p>\n<p>Note: This display filter language is different from the one used for the Wireshark capture filters!</p>\n<h3 id=\"特殊字符\">特殊字符</h3>\n<h4 id=\"constains-和-matches\">constains 和 matches</h4>\n<p><strong>contains</strong> 用来判断是否包含一个值，<strong>matches</strong> 用来判断是否匹配一个表达式</p>\n<hr />\n<h3 id=\"some-common-examples-一些通用示例-1\">Some common examples 一些通用示例</h3>\n<p><strong>Example Ethernet</strong>: display all traffic to and from the Ethernet address 08.00.08.15.ca.fe</p>\n<p><code>eth.addr==08.00.08.15.ca.fe</code></p>\n<p><strong>Example IP</strong>: display all traffic to and from the IP address 192.168.0.10</p>\n<p><code>ip.addr==192.168.0.10</code></p>\n<p><strong>Example TCP</strong>: display all traffic to and from the TCP port 80 (http) of all machines</p>\n<p><code>tcp.port==80</code></p>\n<p><strong>Examples combined</strong>: display all traffic to and from 192.168.0.10 except http</p>\n<p><code>ip.addr==192.168.0.10 &amp;&amp; tcp.port!=80</code></p>\n<p>Beware: The filter string builds a logical expression, which must be true to show the packet. The &amp;&amp; is a \"logical and\", \"A &amp;&amp; B\" means: A must be true AND B must be true to show the packet (it doesn't mean: A will be shown AND B will be shown).</p>\n<hr />\n<h3 id=\"hint\">Hint</h3>\n<p>Filtering can lead to side effects, which are sometimes not obvious at first sight. Example: If you capture TCP/IP traffic with the primitive \"ip\", you will not see the ARP traffic belonging to it, as this is a lower protocol layer than IP!</p>\n<h2 id=\"wireshark中的各种标志tcp\">WIRESHARK中的各种标志（TCP）</h2>\n<h3 id=\"out-of-order\">OUT OF ORDER</h3>\n<p><code>TCP Out-of-Order</code></p>\n<p><strong>正常情况：</strong>在TCP传输过程中，同一台主机发出的数据段应该是连续的，即后一个包的 <code>Seq</code> 号等于前一 个包的 <code>Seq</code> + <code>Len</code> （三次握手和四次挥手是例外）。</p>\n<p>异常情况：当Wireshark发现后一个包的 <code>Seq</code> 号 <mark>小于</mark> 前一个包的 <code>Seq</code> + <code>Len</code> 时，就会认为是乱序了，因此提示 <code>TCP Out-of-Order</code> 。</p>\n<h3 id=\"previous-segment-not-captured\">Previous segment not captured</h3>\n<p><code>Previous segment not capturedd</code> ，即报文缺失，指存在未抓取的数据包</p>\n<p><strong>正常情况：</strong>在TCP传输过程中，同一台主机发出的数据段应该是连续的，即后一个包的 <code>Seq</code> 号等于前一个包的 <code>Seq</code> + <code>Len</code> （三次握手和四次挥手是例外）。</p>\n<p><strong>异常情况：</strong>如果Wireshark发现后一个包的 <code>Seq</code> 号大于前一个包的 <code>Seq</code> + <code>Len</code> ，就知道中间缺失了一段数据。假如缺失的那段数据在整个网络包中都找不到（即排除了乱序），就会提示<code>TCP Previous segment not captured</code> 。</p>\n<blockquote>\n<p><strong>TCP Previous segment lost</strong> - Occurs when a packet arrives with a sequence number greater than the \"next expected sequence number\" on that connection, indicating that one or more packets prior to the flagged packet did not arrive. This event is a good indicator of packet loss and will likely be accompanied by \"TCP Retransmission\" events.</p>\n<p>-- Wireshark</p>\n</blockquote>\n<h3 id=\"tcp-dup-ack\">TCP DUP ACK</h3>\n<p><code>Tcp Dup Ack xxx#y</code> ，即重复确认。</p>\n<p>当乱序或者丢包发生时，接收方会收到一些Seq号比期望值大的包。</p>\n<p><u>接收方每收到一个这种包就会进行答复，<code>Ack</code> 一次期望的 <code>Seq</code> 值，以此方式来提醒发送方，于是就产生了一些重复的 <code>Ack</code> 。</u></p>\n<p>Wireshark会在这种重复的Ack上标记 <code>TCP Dup ACK</code> ，代表了数据段丢失 TCP 状态，<code>xxx</code> 代表数据丢失的位置， <code>y</code> 后代表第几次丢失报文。</p>\n<h3 id=\"tcp-fast-retransmission\">TCP Fast Retransmission</h3>\n<p>快速重传，当发送方收到来自接收方的3个或以上<code>TCP Dup ACK</code> ，就意识到之前发的包可能丢了，于是发送方快速重传该数据（这是RFC的规定）。</p>\n<h3 id=\"tcp-spurious-retransmission\">TCP Spurious Retransmission</h3>\n<h3 id=\"tcp-retransmission\">TCP Retransmission</h3>\n<p>超时重传。</p>\n<p>如果一个包真的丢了，且无后续包，则可以在接收方触发 <code>Dup Ack</code> ，就不会快速重传。</p>\n<p>这种情况下发送方只好等到超时了再重传，此类重传包就会被Wireshark标上 <code>TCP Retransmission</code> 。</p>\n<h3 id=\"tcp-acked-unseen-segment\">TCP ACKed unseen segment</h3>\n<p>抓取遗漏。</p>\n<p>当Wireshark发现被Ack的那个包没被抓到，就会提示 <code>TCP ACKed unseen  segment</code>， 即此为由于抓包不到造成的报错。</p>\n<p><em>这可能是最常见的Wireshark提示了，幸好它几乎是永远可以忽略的。</em></p>\n<p>以图3为例，32号包的<code>Seq=6889</code> <code>Len=1448</code> ，相加得 8337，说明服务器发出的下一个包应该是 <code>Seq=8337</code>。而我们看到的却是35号包的<code>Seq=11233</code>，这意味着 8337～11232 这段数据没有被抓到。这段数据本应该出现在34号之前，所以Wireshark提示了<code>TCP ACKed unseen segment</code>。</p>\n<p><img src=\"http://tc.sinaimg.cn/maxwidth.2048/tc.service.weibo.com/community_emc_com/8ccefb660da3f07e9a83e0625c6c7f19.png\" style=\"zoom:150%;\" /></p>\n<h3 id=\"tcp-zerowindow\">TCP Zerowindow</h3>\n<p>窗口清零。</p>\n<p>TCP包中的 <code>win=</code> 代表接收窗口的大小，即表示这个包的发送方当前还有多少缓存区可以接收数据。</p>\n<p>当Wireshark在一个包中发现 <code>win=0</code> 时，就会给它打上 <code>TCP  zerowindow</code> 的标志，表示缓存区已满，不能再接受数据了。下图就是服务器的缓存区已满，所以通知客户端不要再发数据了。我们甚至可以在3258～3263这几个包中看出它的窗口逐渐减少的过程，即从 <code>win=15872</code> 减小到 <code>win=1472</code> 。</p>\n<p><img src=\"http://tc.sinaimg.cn/maxwidth.2048/tc.service.weibo.com/community_emc_com/1b59377ebee4107bed8557a6a4a9d35f.png\" style=\"zoom:150%;\" /></p>\n<h3 id=\"tcp-window-update\">TCP Window Update</h3>\n<h2 id=\"其他\">其他</h2>\n<p>Sockets API和Internet在许多 <strong><em>竞争性协议族</em></strong>（包括 <em>IPX</em>、<em>AppleTalk</em>、<em>DECNet</em>、<em>OSI</em>、<em>SNA</em> 及 <em>TCP</em>/IP）的世界中逐渐成长起来，并且 <mark>Sockets被设计成支持所有这些协议</mark> 。</p>\n<h3 id=\"ipv4映射\">IPv4映射</h3>\n<p>IPv4映射的地址是通过在IPv4地址前添加4个字节的前缀 <code>::fff:</code> 而构成。</p>\n<p>如，<code>132.3.23.7</code> 的IPv4地址映射至IPv6即 <code>::ffff:132.3.32.7</code> 。</p>\n<p>协议互操作性</p>\n<h3 id=\"回送地址\">回送地址</h3>\n<p>IPv4的回送地址是<code>127.0.0.1</code></p>\n<p>IPv6的回送地址是 <code>0:0:0:0:0:0:0:1</code></p>\n<h3 id=\"专用网络地址\">专用网络地址</h3>\n<p>以 <code>10</code> 、<code>192.168</code> 、<code>172.16</code>~<code>172.31</code>开头的地址最初被指定在不属于全球Internet的专用网络中使用。</p>\n<h3 id=\"name\">Name</h3>\n<p>Hostname是指 <em>计算机名称</em> ，Domain Name是指 <em>域名</em> 。</p>\n<p>通常情况下，一个name都是指Hostname。</p>\n<h1 id=\"socket-in-posix\">Socket in Posix</h1>\n<h2 id=\"headerfiles\">Headerfiles</h2>\n<p>在Posix标准中，以下文件被用于在Unix/Linux/Mac中进行网络编程。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>各文件包含的内容如下：</p>\n<ul>\n<li><p><code>&lt;sys/types.h&gt;</code> 定义了在socket网络编程中用到的数据类型；</p></li>\n<li><p><code>&lt;sys/socket.h&gt;</code> 定义了接口类型（socket types）、接口标志（socket flags）、额外设置（addtional options）、地址簇（address family）和地址存储结构体（address storage structure）特定机器的一些设定。</p></li>\n<li><p><code>&lt;netinet/in.h&gt;</code> 定义了RFC协议（protocol），和IP网络层相关的宏定义。其中 <code>in</code> 是 internet 的缩写。</p></li>\n<li><p><code>&lt;arpa/inet.h&gt;</code> 则定义了对网络层操作的函数，例如，“将host地址与net地址互相转换” 的 <code>htonl()</code> 、 <code>htons()</code> 、 <code>ntohl()</code> 、<code>ntohs()</code> 都定义在里面，还有 <code>inet_addr()</code> 、 <code>*inet_ntoa()</code>、<code>*inet_ntop()</code> 、<code>inet_pton()</code> 等操作</p></li>\n<li><p><code>&lt;netdb.h&gt;</code> 定义了网络数据库（network database）的操作， 相关手册可以查看 Michael 的 <a href=\"https://www.man7.org/linux/man-pages/man0/netdb.h.0p.html\">在线手册</a>。</p></li>\n<li><p><code>&lt;unistd.h&gt;</code> 定义了系统线程、文件读取等的操作和宏定义。</p></li>\n<li><p><code>&lt;errno.h&gt;</code> 定义了 普通文件操作和网路文件操作的错误码（error codes）。</p></li>\n</ul>\n<h1 id=\"socket-in-texas-instruments-sysbios\">Socket in Texas Instrument’s SysBIOS</h1>\n<h2 id=\"netctrl.h-及-socket.h\">NETCTRL.H 及 SOCKET.H</h2>\n<p>以下两句话是TI官方对<code>&lt;netctrl.h&gt;</code> 的描述，即简易控制网络开断的包装函数，以此类方法实现接口的目的是隐藏可以被调用的HAL/STACK功能</p>\n<blockquote>\n<ul>\n<li>Shell functions for simplified net startup and shutdown</li>\n<li>The idea behind this API is to hide the user callable HAL/STACK functions</li>\n</ul>\n</blockquote>\n<p><code>&lt;netctrl.h&gt;</code> 是用于初始化和维护服务的。为了完成此功能，其调用了NETTOOLS库提供的配置管理器。要注意的是，此处的配置定义和结构声明是对针对NETCTRL 的，而不是针对 CONFIG。</p>\n<blockquote>\n<p>NETCTRL is used to initialize the stack and maintain services. To accomplish this, it makes use of the configuration manager provided in the NETTOOLS library. Note that the configuration definitions and structures defined here are specific to NETCTRL, not CONFIG.</p>\n</blockquote>\n<h3 id=\"netctrl-api\">NETCTRL API</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化运行环境</span></span><br><span class=\"line\"><span class=\"function\">_extern <span class=\"keyword\">int</span>  <span class=\"title\">NC_SystemOpen</span><span class=\"params\">( <span class=\"keyword\">int</span> Priority, <span class=\"keyword\">int</span> OpMode )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第一个参数可选择任务等级高或任务等级低</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NC_PRIORITY_LOW             OS_SCHEDULER_LOWPRI</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NC_PRIORITY_HIGH            OS_SCHEDULER_HIGHPRI</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义打开模式为POLLING或中断</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NC_OPMODE_POLLING           1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NC_OPMODE_INTERRUPT         2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NC_SystemOpen()的返回结果</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NC_OPEN_SUCCESS             0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NC_OPEN_ILLEGAL_PRIORITY    -1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NC_OPEN_ILLEGAL_OPMODE      -2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NC_OPEN_MEMINIT_FAILED      -3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NC_OPEN_EVENTINIT_FAILED    -4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 关闭运行环境</span></span><br><span class=\"line\"><span class=\"function\">_extern <span class=\"keyword\">void</span> <span class=\"title\">NC_SystemClose</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用提供的配置信息开启网络</span></span><br><span class=\"line\"><span class=\"function\">_extern <span class=\"keyword\">int</span> <span class=\"title\">NC_NetStart</span><span class=\"params\">( HANDLE hCfg, <span class=\"keyword\">void</span> (*NetStart)(),</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        <span class=\"keyword\">void</span> (*NetStop)(), <span class=\"keyword\">void</span> (*NetIP)(IPN,uint,uint) )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 断开网络</span></span><br><span class=\"line\"><span class=\"function\">_extern <span class=\"keyword\">void</span> <span class=\"title\">NC_NetStop</span><span class=\"params\">( <span class=\"keyword\">int</span> rc )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当Boot线程完成时被调用</span></span><br><span class=\"line\"><span class=\"function\">_extern <span class=\"keyword\">void</span> <span class=\"title\">NC_BootComplete</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当IP地址被添加或移除时被调用</span></span><br><span class=\"line\"><span class=\"function\">_extern <span class=\"keyword\">void</span> <span class=\"title\">NC_IPUpdate</span><span class=\"params\">( IPN IPAddr, uint IfIdx, uint fAdd )</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-api\">SOCKET API</h2>\n<h3 id=\"universal_tcp\">UNIVERSAL_TCP</h3>\n<h4 id=\"defined-in-ws2def.h\">defined in <code>&lt;ws2def.h&gt;</code></h4>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">addrinfo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>                 ai_flags;       <span class=\"comment\">// AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>                 ai_family;      <span class=\"comment\">// PF_xxx</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>                 ai_socktype;    <span class=\"comment\">// SOCK_xxx</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>                 ai_protocol;    <span class=\"comment\">// 0 or IPPROTO_xxx for IPv4 and IPv6</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span>              ai_addrlen;     <span class=\"comment\">// Length of ai_addr</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *              ai_canonname;   <span class=\"comment\">// Canonical name for nodename</span></span><br><span class=\"line\">    _Field_size_bytes_(ai_addrlen) <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr</span> *   <span class=\"title\">ai_addr</span>;</span>        <span class=\"comment\">// Binary address</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">addrinfo</span> *   <span class=\"title\">ai_next</span>;</span>        <span class=\"comment\">// Next structure in linked list</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ADDRINFOA, *PADDRINFOA;</span><br></pre></td></tr></table></figure>\n<h4 id=\"defined-in-ti-socket.h\">defined in <strong><em>TI</em></strong> <code>&lt;socket.h&gt;</code></h4>\n<h5 id=\"ipv4套接字地址数据结构\">IPv4套接字地址数据结构</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AF_INET family (IPv4) Socket address data structure.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> &#123;</span></span><br><span class=\"line\">    UINT8   sin_len;            <span class=\"comment\">// total length</span></span><br><span class=\"line\">    UINT8   sin_family;         <span class=\"comment\">// address family</span></span><br><span class=\"line\">    UINT16  sin_port;           <span class=\"comment\">// port</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span>  <span class=\"title\">in_addr</span> <span class=\"title\">sin_addr</span>;</span></span><br><span class=\"line\">    INT8    sin_zero[<span class=\"number\">8</span>];        <span class=\"comment\">// fixed length address value</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"内核用地址存储数据结构\">内核用地址存储数据结构</h5>\n<p>这个套娃里还有个套娃 <code>in_addr</code> ，这个结构体供内核调用，以储存更多地址数据。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Structure used by kernel to store most addresses.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">in_addr</span> &#123;</span></span><br><span class=\"line\">    UINT32  s_addr;             <span class=\"comment\">// 32 bit long IP address, net order</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"通用套接字地址储存数据结构\">通用套接字地址储存数据结构</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Generic Socket address storage data structure.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr</span> &#123;</span></span><br><span class=\"line\">    UINT8    sa_len;            <span class=\"comment\">// Length </span></span><br><span class=\"line\">    UINT8    sa_family;         <span class=\"comment\">// address family</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>     sa_data[<span class=\"number\">14</span>];       <span class=\"comment\">// socket data</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr</span>      <span class=\"title\">SA</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr</span>      *<span class=\"title\">PSA</span>;</span></span><br></pre></td></tr></table></figure>\n<p>以下为Socket <strong>接口协议簇</strong> 、 <strong>接口类型</strong>、 <strong>接口协议</strong> ：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Socket address families</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> AF_TASK         1               <span class=\"comment\">// Intertask Communication</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> AF_INET         2               <span class=\"comment\">// Internet: UDP, TCP, etc.</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> AF_INET6        10              <span class=\"comment\">// IPV6</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> _INCLUDE_NIMU_CODE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> AF_RAWETH       12              <span class=\"comment\">// Raw Ethernet Protocol</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Socket Types</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCK_STREAM     1               <span class=\"comment\">// stream socket</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCK_DGRAM      2               <span class=\"comment\">// datagram socket</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCK_RAW        3               <span class=\"comment\">// raw-protocol interface</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCK_STREAMNC   4               <span class=\"comment\">// non-copy stream socket</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> _INCLUDE_NIMU_CODE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCK_RAWETH     5               <span class=\"comment\">// non-copy raw eth socket</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Protocols</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IPPROTO_IP      0               <span class=\"comment\">// IP Placeholder</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IPPROTO_ICMP    1               <span class=\"comment\">// ICMP</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IPPROTO_IGMP    2               <span class=\"comment\">// IGMP</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IPPROTO_TCP     6               <span class=\"comment\">// TCP</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IPPROTO_UDP     17              <span class=\"comment\">// UDP</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IPPROTO_IPV6    41              <span class=\"comment\">// IPV6 </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IPPROTO_ICMPV6  58              <span class=\"comment\">// ICMPV6 Header.</span></span></span><br></pre></td></tr></table></figure>\n<p>以下Socket接口均以Ti NDK为载体，以C为实现方式。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Socket Oriented Functions</span></span><br><span class=\"line\"><span class=\"function\">SOCKET <span class=\"title\">accept</span><span class=\"params\">( SOCKET s, PSA pName, <span class=\"keyword\">int</span> *plen )</span></span>;\t<span class=\"comment\">//接受一个套接字的连接</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>    <span class=\"title\">bind</span><span class=\"params\">( SOCKET s, PSA pName, <span class=\"keyword\">int</span> len )</span></span>;\t<span class=\"comment\">//给套接字绑定一个名字</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>    <span class=\"title\">connect</span><span class=\"params\">( SOCKET s, PSA pName, <span class=\"keyword\">int</span> len )</span></span>;\t\t<span class=\"comment\">//在一个套接字上初始化连接</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>    <span class=\"title\">getpeername</span><span class=\"params\">( SOCKET s, PSA pName, <span class=\"keyword\">int</span> *plen )</span></span>;\t<span class=\"comment\">//在已连接的peer上返回名称地址</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>    <span class=\"title\">getsockname</span><span class=\"params\">( SOCKET s, PSA pName, <span class=\"keyword\">int</span> *plen )</span></span>;\t<span class=\"comment\">//返回套接字的本地名称地址</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>    <span class=\"title\">getsockopt</span><span class=\"params\">( SOCKET s, <span class=\"keyword\">int</span> level, <span class=\"keyword\">int</span> op, <span class=\"keyword\">void</span> *pbuf, <span class=\"keyword\">int</span> *pbufsize )</span></span>;\t<span class=\"comment\">//获取套接字设置信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>    <span class=\"title\">listen</span><span class=\"params\">( SOCKET s, <span class=\"keyword\">int</span> maxcon )</span></span>;\t\t<span class=\"comment\">//监听数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>    <span class=\"title\">recv</span><span class=\"params\">( SOCKET s, <span class=\"keyword\">void</span> *pbuf, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> flags )</span></span>;\t\t<span class=\"comment\">//接收数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>    <span class=\"title\">recvfrom</span><span class=\"params\">( SOCKET s, <span class=\"keyword\">void</span> *pbuf, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> flags, PSA pName, <span class=\"keyword\">int</span> *plen )</span></span>;\t\t<span class=\"comment\">//从指定对象处接收信息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>    <span class=\"title\">recvnc</span><span class=\"params\">( SOCKET s, <span class=\"keyword\">void</span> **ppbuf, <span class=\"keyword\">int</span> flags, HANDLE *pHandle )</span></span>;\t<span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>    <span class=\"title\">recvncfrom</span><span class=\"params\">( SOCKET s, <span class=\"keyword\">void</span> **ppbuf, <span class=\"keyword\">int</span> flags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           PSA pName, <span class=\"keyword\">int</span> *plen, HANDLE *pHandle )</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>   <span class=\"title\">recvncfree</span><span class=\"params\">( SOCKET Handle )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>    <span class=\"title\">send</span><span class=\"params\">( SOCKET s, <span class=\"keyword\">void</span> *pbuf, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> flags )</span></span>;\t\t<span class=\"comment\">//发送信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>    <span class=\"title\">sendto</span><span class=\"params\">( SOCKET s, <span class=\"keyword\">void</span> *pbuf, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> flags, PSA pName, <span class=\"keyword\">int</span> len )</span></span>;\t<span class=\"comment\">//在未连接的套接字上往指定目的地发送数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>    <span class=\"title\">setsockopt</span><span class=\"params\">( SOCKET s, <span class=\"keyword\">int</span> level, <span class=\"keyword\">int</span> op, <span class=\"keyword\">void</span> *pbuf, <span class=\"keyword\">int</span> bufsize )</span></span>;\t<span class=\"comment\">//设置套接字设置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>    <span class=\"title\">shutdown</span><span class=\"params\">( SOCKET s, <span class=\"keyword\">int</span> how )</span></span>;\t<span class=\"comment\">//关闭一半的套接字连接</span></span><br><span class=\"line\"><span class=\"function\">SOCKET <span class=\"title\">socket</span><span class=\"params\">( <span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol )</span></span>;\t<span class=\"comment\">//创建套接字</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"socket-api-in-client\">SOCKET API IN CLIENT</h3>\n<hr />\n<div class=\"Step\" style=\"font-size: 20px; font-weight: 700;\">\n第一步 创建套接字\n</div>\n<p><code>SOCKET socket( int domain, int type, int protocol );</code></p>\n<p>如果创建成功，则返回一个代表套接字的文件描述符。否则就返回一个 <code>INVALID_SOCKET</code> 值，并且可以调用 <code>fdError()</code> 来诊断错误原因。</p>\n<blockquote>\n<p><code>domain</code>是指链路层类型IPv4还是IPv6，分别书写为 <strong>AF_INET</strong> | <strong>AF_INET6</strong></p>\n<p><code>type</code>是指传输层套接字类型，共有 <strong>报文数据</strong>、<strong>流式数据</strong>、<strong>原始数据</strong> 三种可选，分别是 <strong>SOCK_DGRAM</strong> | <strong>SOCK_STREAM</strong> | <strong>SOCK_RAW</strong></p>\n<p><code>protocol</code>是指网络层协议类型，IPPROTO_TCP | IPPROTO_UDP，在套接字类型是原始数据时可以任意指定，如果是套接字类型是 <strong>SOCK_STREAM</strong>，则协议需要指定为 <strong>IPPROTO_TCP</strong></p>\n</blockquote>\n<div class=\"Step\" style=\"font-size: 20px; font-weight: 700;\">\n第二步 设定套接字参数\n</div>\n<p>通常在套接字创建之后，使用Pv4套接字地址数据结构 <code>sockaddr_in</code>设定参数，以下实例是下位机做客户端时的代码。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">bzero(&amp;sin1, <span class=\"keyword\">sizeof</span>(struct sockaddr_in));            <span class=\"comment\">/* Set Port, IP address = IPAddrSend */</span></span><br><span class=\"line\">sin1.sin_family = AF_INET;</span><br><span class=\"line\">sin1.sin_len    = <span class=\"keyword\">sizeof</span>(sin1);</span><br><span class=\"line\">sin1.sin_addr.s_addr = inet_addr(REMOTE_IPADDR_STRING);          <span class=\"comment\">//连接服务器的地址</span></span><br><span class=\"line\">sin1.sin_port   = htons(TCP_CLIENT_PORT);</span><br></pre></td></tr></table></figure>\n<div class=\"Step\" style=\"font-size: 20px; font-weight: 700;\">\n第三步 连接\n</div>\n<p><code>int    connect( SOCKET s, PSA pName, int len );</code></p>\n<blockquote>\n<p><code>PSA</code> 是 <code>sockaddr</code> 结构体的 <strong><em>指针</em></strong> 对象类型，定义为 <code>typedef struct sockaddr      *PSA;</code></p>\n<p>另，<code>SA</code> 是 <code>sockaddr</code> 结构体的对象类型。</p>\n</blockquote>\n<p><code>sockaddr</code> 的定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通用套接字地址存储数据结构</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr</span> &#123;</span></span><br><span class=\"line\">    UINT8    sa_len;            <span class=\"comment\">//套接字长度</span></span><br><span class=\"line\">    UINT8    sa_family;         <span class=\"comment\">//套接字类型，AF_INET</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>     sa_data[<span class=\"number\">14</span>];       <span class=\"comment\">//套接字数据</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>实际连接时，通常设置一定时间的任务休眠以等待网络稳定后再行连接，且连接次数自定。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(count = <span class=\"number\">0</span>; count &lt; <span class=\"number\">30</span>; count ++)&#123;</span><br><span class=\"line\">        res = connect(stcp, (PSA) &amp;sin1, <span class=\"keyword\">sizeof</span>(sin1));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(res &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            ConsoleWarning(<span class=\"string\">&quot;网络连接失败！\\n&quot;</span>);</span><br><span class=\"line\">            TaskSleep(SLEEPTIME);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ConsoleWarning(<span class=\"string\">&quot;网络连接成功！\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>通过特定配置设置，打开网络。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">_extern <span class=\"keyword\">int</span> <span class=\"title\">NC_NetStart</span><span class=\"params\">( HANDLE hCfg,   <span class=\"keyword\">void</span> (*NetStart)(),   <span class=\"keyword\">void</span> (*NetStop)(),    <span class=\"keyword\">void</span> (*NetIP)(IPN,uint,uint) )</span></span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"套接字\">套接字</h4>\n<p>HANDLE is a <em>void pointer*</em> defined in the <code>&lt;usertype.h&gt;</code>.</p>\n<blockquote>\n<p>在<code>&lt;socket.h&gt;</code>中，<strong>SOCKET</strong>类型其实是个HANDLE，而<strong>HANDLE</strong>其实是<code>void*</code>数据。</p>\n<p><code>typedef HANDLE           SOCKET;          // OS Socket Type</code></p>\n<p><code>typedef void *         HANDLE;</code></p>\n</blockquote>\n<h4 id=\"文件描述符\">文件描述符</h4>\n<blockquote>\n<p>文件描述符，即 <strong><em>File Descriptor</em></strong>，其实一个是 <code>void*</code>类型</p>\n</blockquote>\n<h5 id=\"fd集\">FD集</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Select uses bit masks of file descriptors.  These macros</span></span><br><span class=\"line\"><span class=\"comment\">// manipulate handle lists. FD_SETSIZE can be modified as</span></span><br><span class=\"line\"><span class=\"comment\">// needed.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FD_SETSIZE      16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fd_set</span> &#123;</span></span><br><span class=\"line\">    uint    count;</span><br><span class=\"line\">    HANDLE  fd[FD_SETSIZE];</span><br><span class=\"line\">&#125; fd_set;</span><br></pre></td></tr></table></figure>\n<h4 id=\"字节顺序转换函数\">字节顺序转换函数</h4>\n<p>在C/C++写网络程序的时候，往往会遇到字节的网络顺序和主机顺序的问题。这是就可能用到<code>htons()</code> , <code>ntohl()</code> , <code>ntohs()</code>，<code>htons()</code>这4个函数。</p>\n<p>网络字节顺序与本地字节顺序之间的转换函数：</p>\n<blockquote>\n<p><code>htonl()</code>--\"Host to Network Long\" <code>ntohl()</code>--\"Network to Host Long\" <code>htons()</code>--\"Host to Network Short\" <code>ntohs()</code>--\"Network to Host Short\"</p>\n</blockquote>\n<p><strong><em>网络字节顺序(NBO, Network Byte Order):</em></strong> 按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。</p>\n<p><strong><em>主机字节顺序(HBO, Host Byte Order):</em></strong> 不同的机器HBO不相同，与CPU设计有关，数据的顺序是由cpu决定的,而与操作系统无关。</p>\n<blockquote>\n<p>如 Intel x86结构下, short型数 <code>0x1234</code> 表示为<code>34 12</code>, int型数 <code>0x12345678</code> 表示为<code>78 56 34 12</code></p>\n<p>如 IBM power PC结构下, short型数<code>0x1234</code> 表示为 <code>12 34</code> , int型数 <code>0x12345678</code> 表示为 <code>12 34 56 78</code></p>\n</blockquote>\n<p>由于这个原因不同体系结构的机器之间无法通信,所以要转换成一种约定的数序,也就是网络字节顺序,其实就是如同power pc那样的顺序. 在PC开发中有ntohl和htonl函数可以用来进行网络字节和主机字节的转换.</p>\n<h4 id=\"timeval结构体\">timeval结构体</h4>\n<blockquote>\n<p>Ti SysBios中，<code>timeval</code> 是在 <code>&lt;SOCKET.H&gt;</code> 中被定义，被 <code>fdSelect()</code> 使用的；</p>\n</blockquote>\n<p>结构体定义与Linux C中的一致</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> &#123;</span></span><br><span class=\"line\">    INT32 tv_sec;\t<span class=\"comment\">//Second Level</span></span><br><span class=\"line\">    INT32 tv_usec;\t<span class=\"comment\">//Microsecond Level</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在 <strong><em>Linux C</em></strong> 中，<code>timeval</code> 与 <code>timezone</code> 结构体都隶属于 <code>sys/time.h</code> 头文件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timezone</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> tz_minuteswest;</span><br><span class=\"line\"><span class=\"keyword\">int</span> tz_dsttime;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Linux C 中对 TIMEVAL 使用的补充资料：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">gettimeofday</span><span class=\"params\">(struct timeval*tv, struct timezone *tz)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>其参数tv是保存获取时间结果的结构体，参数tz用于保存时区结果，tz 参数若不使用则传入NULL即可。</p>\n<p><code>gettimeofday()</code> 使用举例-1：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv_begin</span>, <span class=\"title\">tv_end</span> ;</span></span><br><span class=\"line\">gettimeofday(&amp;tv_begin, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">foo();</span><br><span class=\"line\">gettimeofday(&amp;tv_end, <span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure>\n<p><code>gettimeofday()</code> 使用举例-2：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc,<span class=\"keyword\">char</span> * argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv</span>;</span></span><br><span class=\"line\">   <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      gettimeofday(&amp;tv,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;time %u:%u\\n&quot;</span>,tv.tv_sec,tv.tv_usec);</span><br><span class=\"line\">      sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><em>源自：http://www.cnblogs.com/Neddy/archive/2012/01/31/2332957.html</em></p>\n<h3 id=\"socket-api-in-server\">SOCKET API IN SERVER</h3>\n<div class=\"Step\" style=\"font-size: 20px; font-weight: 700;\">\n第一步 创建套接字\n</div>\n<p>同client，略</p>\n<div class=\"Step\" style=\"font-size: 20px; font-weight: 700;\">\n第二步 监听套接字\n</div>\n<p><code>int    listen( SOCKET s, int maxcon );</code></p>\n<blockquote>\n<p><code>maxcon</code> 参数用于定义最大的阻塞数，如果阻塞值最高，则会发送一个 <code>ECONNREFUSED</code> 错误给客户端</p>\n</blockquote>\n<ul>\n<li><p><code>listen()</code> 监听套接字上的连接请求。为了连接请求，需要先由<code>socket()</code> 函数创建套接字。</p></li>\n<li><p><code>listen()</code> 函数用于等待设备接入并声明有限接入数的队列。</p></li>\n<li><p>新连接接入时需要调用 <code>accept()</code> 函数。</p></li>\n</ul>\n<div class=\"Step\" style=\"font-size: 20px; font-weight: 700;\">\n第三步 从套接字接收数据\n</div>\n<p><code>int    recv( SOCKET s, void *pbuf, int size, int flags );</code></p>\n<blockquote>\n<p><code>pbuf</code> 参数用于储存数据</p>\n<p><code>size</code> 为欲接收数据的大小</p>\n<p><code>flags</code> 为接收不到数据时的行为定义</p>\n</blockquote>\n<table>\n<colgroup>\n<col style=\"width: 16%\" />\n<col style=\"width: 83%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>FLAGS</th>\n<th>CONDITIONS</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>MSG_DONTWAIT</td>\n<td>Requests that the operation not block when no data is available</td>\n</tr>\n<tr class=\"even\">\n<td>MSG_OOB</td>\n<td>Requests receipt of out-of-band data that would not be received in the normal data stream. Some protocols place expedited data at the head of the normal data queue, and thus, this flag cannot be used with such protocols.</td>\n</tr>\n<tr class=\"odd\">\n<td>MSG_PEEK</td>\n<td>Causes the receive operation to return data from the beginning of the receive queue without removing that data from the queue. Thus, a subsequent receive call will return the same data.</td>\n</tr>\n<tr class=\"even\">\n<td>MSG_WAITALL</td>\n<td>Requests that the operation block until the full request is satisfied. However, the call may still return less data than requested if an error or disconnect occurs, or the next data to be received is of a different type than that returned.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"socket-api-in-server-linux-c\">SOCKET API IN SERVER (LINUX C)</h3>\n<div class=\"Step\" style=\"font-size: 20px; font-weight: 700;\">\n第一步 创建套接字\n</div>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> servSock;  <span class=\"comment\">//Socket descriptor for server</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>( ( servSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP ) ) &lt; <span class=\"number\">0</span> ) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;socket() failed.\\n&quot;</span>);</span><br></pre></td></tr></table></figure>\n<div class=\"Step\" style=\"font-size: 20px; font-weight: 700;\">\n第二步 套接字地址初始化\n</div>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">servAddr</span>;</span></span><br><span class=\"line\"><span class=\"built_in\">memset</span>(&amp;servAddr, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>( servAddr ) );</span><br><span class=\"line\">servAddr.sin_family = AF_INET;</span><br><span class=\"line\">servAddr.sin_addr.s_addr = htonl( INADDR_ANY );</span><br><span class=\"line\">servAddr.sin_port = htons( servPort );</span><br></pre></td></tr></table></figure>\n<div class=\"Step\" style=\"font-size: 20px; font-weight: 700;\">\n第三步 绑定套接字\n</div>\n<p><strong>注意：</strong> <strong>客户端</strong>把服务器的地址提供给 <code>connect()</code> 以供连接至服务器，而 <strong>服务器</strong> 必须将自己的地址指定给 <code>bind()</code> 进行绑定。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>( ( bind( servSock, (struct sockaddr*) &amp;servAddr, <span class=\"keyword\">sizeof</span>( servAddr ) ) ) &lt; <span class=\"number\">0</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;bind() failed.\\n&quot;</span>);</span><br></pre></td></tr></table></figure>\n<div class=\"Step\" style=\"font-size: 20px; font-weight: 700;\">\n第四步 监听套接字\n</div>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">short</span> MAXPENDING = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>( ( listen( servSock, MAXPENDING ) ) &lt; <span class=\"number\">0</span> ) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;listen() failed.\\n&quot;</span>);</span><br></pre></td></tr></table></figure>\n<div class=\"Step\" style=\"font-size: 20px; font-weight: 700;\">\n第四步 处理程序\n<div>\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">for</span>(;;)&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaaddr_in</span> <span class=\"title\">cintAddr</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">socklen_t</span> clntAddrLen = <span class=\"keyword\">sizeof</span>( clntAddr );</span><br><span class=\"line\">    <span class=\"keyword\">int</span> clntSock = accept( servSock, (struct sockaddr*)&amp;clntAddr, &amp;clntAddrLen );</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( clntSock &lt; <span class=\"number\">0</span> ) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;accept() failed.\\n&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">char</span> clntName[ INET_ADDRSTRLEN ];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( inet_ntop( AF_INET, &amp;clntAddr.sin_addr.s_addr, clntName, <span class=\"keyword\">sizeof</span>( clntName ) ) != <span class=\"literal\">NULL</span> ) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Handling client %s/%d.\\n&quot;</span>, clntName, ntohs( clntAddr.sin_port ));</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Unable to get client address.\\n&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    HandleTCPClient(clntSock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"daemon-api\">Daemon API</h3>\n<p>DAEMON，即TCP/UDP Server Daemon Support。</p>\n<p>A server daemon is a <strong>single network task</strong> that <strong>monitors the socket status of multiple network servers</strong>. When activity is detected, the <strong>daemon creates a task thread specifically to handle the new activity</strong>. This is more efficient than having multiple servers, <strong>each with their own listening thread</strong>.</p>\n<p>要使用服务器守护，首先要创建入口(entry)，创建成功时会返回一个句柄，失败则返回NULL。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">DaemonNew</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> Type, <span class=\"keyword\">uint32_t</span> LocalAddress, <span class=\"keyword\">uint32_t</span> LocalPort, <span class=\"keyword\">int</span>(*pCb)(SOCKET,<span class=\"keyword\">uint32_t</span>), </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">uint32_t</span> Priority, <span class=\"keyword\">uint32_t</span> StackSize, <span class=\"keyword\">uint32_t</span> Argument, <span class=\"keyword\">uint32_t</span> MaxSpawn)</span></span>;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Type</code> Socket type (SOCK_STREAM, SOCK_STREAMNC, or SOCK_DGRAM) <code>LocalAddress</code> Local IP address (set to NULL for wildcard) <code>LocalPort</code> Local Port to serve (cannot be NULL) <code>pCb</code> Pointer to callback to handle server event (connection or activity) <code>Priority</code> Priority of new task to create for callback function <code>StackSize</code> Stack size of new task to create for callback function <code>Argument</code> Argument (besides socket) to pass to callback function <code>MaxSpawn</code> Maximum number of callback function instances (must be 1 for UDP)</p>\n</blockquote>\n<p>在TCP环境中，当新连接稳定时，新任务线程会被创建，套接字Session会被打开。在新的任务线程上，用户的回调函数会被调用以供新连接上的套接字和调用的指定参数使用。回调函数可以一直维护套接字和任务线程。一旦完成连接它将从回调任务中返回。该任务能够判断是否关闭套接字（或翻译成：该任务能够在需要时关闭套接字）。</p>\n<p>In the case of TCP, when a new connection is established, a new task thread is created, and a socket session is opened. Then the user's callback function is called on the new task thread, being supplied with both the socket to the new connection and the caller specified argument (as supplied to DaemonNew()). The callback function can keep the socket and task thread for as long as necessary. It returns from the callback once it is done with the connection. The function can choose to close the socket if desired. The return code informs the daemon whether the socket has been closed (0) or is still open (1).</p>\n<h2 id=\"netcfg.h\">NETCFG.H</h2>\n<blockquote>\n<p><code>CI</code> means <code>Configuration Item</code> , and <code>CFG</code> means <code>Configuration</code> .</p>\n</blockquote>\n<p>Data-type <code>UINT32</code> and <code>IPN</code> are both defined in the header file <code>&lt;usertype.h&gt;</code> .</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>   UINT32;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> UINT32         IPN;             <span class=\"comment\">// IP Address in NETWORK format</span></span><br></pre></td></tr></table></figure>\n<p>Structure <code>CI_IPNET</code> and structure <code>CI_ROUTE</code> are different from each other.</p>\n<p>Structure <code>CI_IPNET</code> is as follow:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IPNet Instance</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">ci_ipnet</span> &#123;</span></span><br><span class=\"line\">        uint    NetType;                <span class=\"comment\">// 网络地址类型标志</span></span><br><span class=\"line\">        IPN     IPAddr;                 <span class=\"comment\">// 32bits地址((2^8)*4)</span></span><br><span class=\"line\">        IPN     IPMask;                 <span class=\"comment\">// 子网掩码</span></span><br><span class=\"line\">        HANDLE  hBind;                  <span class=\"comment\">// 绑定句柄</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span>    Domain[CFG_DOMAIN_MAX]; <span class=\"comment\">// 域名</span></span><br><span class=\"line\">        &#125; CI_IPNET;</span><br></pre></td></tr></table></figure>\n<p>Structure <code>CI_ROUTE</code> is as follow:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Route Instance</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">ci_route</span> &#123;</span></span><br><span class=\"line\">        IPN     IPDestAddr;             <span class=\"comment\">// 目的地址</span></span><br><span class=\"line\">        IPN     IPDestMask;             <span class=\"comment\">// 目的地址掩码</span></span><br><span class=\"line\">        IPN     IPGateAddr;             <span class=\"comment\">// 默认网关地址</span></span><br><span class=\"line\">        HANDLE  hRoute;                 <span class=\"comment\">// Route handle (resets to NULL)</span></span><br><span class=\"line\">        &#125; CI_ROUTE;</span><br></pre></td></tr></table></figure>\n<h2 id=\"configif.h\">CONFIGIF.H</h2>\n<p>请先阅读 <em>&lt;spru524k.pdf&gt;</em></p>\n<h3 id=\"configuration-特性\">Configuration 特性</h3>\n<ul>\n<li>任何对（已激活）配置的作用都将立即生效。</li>\n</ul>\n<blockquote>\n<p><em>The configuration is based on an active database. That is, any change to the database can cause an immediate reaction in the system. For example, if a route is added to the configuration, it is added to the system route table. If the route is then removed from the configuration, it is removed from the system route table.</em></p>\n</blockquote>\n<ul>\n<li>配置存在激活与失效两种状态。</li>\n</ul>\n<blockquote>\n<p><em>Configurations can be set active or inactive. When a configuration is active, any change to the configuration results in a change in the system. When a configuration is inactive, it behaves like a standard database. Part of the main initialization sequence is to make the system configuration active, and then inactive when shutting down.</em></p>\n</blockquote>\n<ul>\n<li>配置(Configurations)和配置入口(Configuration Entries)都使用句柄(handle)来映射，但不同的是，配置使用CfgHandle，而配置入口使用Cfg<em>Entry</em>Handle，所以不能混淆。</li>\n</ul>\n<blockquote>\n<p><em>Both the configurations and configuration entries are referenced by a generic handle. Configuration functions (named as <code>CfgXxx()</code>) take a configuration handle parameter, while configuration entry functions (name as <code>CfgEntryXxx()</code>) take a configuration entry handle parameter. These handles are not interchangeable.</em></p>\n</blockquote>\n<ul>\n<li>配置条目(Entry)包含着<em>(contains)</em> 一个内部引用计数(Internal Reference Count)，即如果有任务想使用它，它就不能被其他任务销毁。配置条目被引用一次，引用计数就会加一。</li>\n</ul>\n<blockquote>\n<p><em>Configuration entry handles are referenced. This means that each handle contains an internal reference count so that the handle is not destroyed by one task while another task expects it to stay valid. Functions that return a configuration entry handle supply a referenced handle in that its reference count has already been incremented for the caller.</em></p>\n</blockquote>\n<ul>\n<li>理论上句柄能够被无限持有，一旦释放则将被dereference。</li>\n</ul>\n<blockquote>\n<p><em>The caller can hold this handle indefinitely, but should dereference it when it is through.</em></p>\n</blockquote>\n<p><code>IF</code> 是指 Interface。<code>ifconfig</code> 是unix系统上的ip接口查看语句。而 <code>CONFIGIF</code> 是配置管理接口的意思。</p>\n<p><code>DeRef</code> ，即 <em>Dereference</em> 之意。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">_extern <span class=\"keyword\">int</span>  <span class=\"title\">CfgAddEntry</span><span class=\"params\">( HANDLE hCfg, uint Tag, uint Item, uint Mode, <span class=\"keyword\">int</span> Size, UINT8 *pData, HANDLE *phCfgEntry )</span></span>;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>HANDLE hCfg</code></p>\n<p><code>uint Tag</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Defined Configuration Tags</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFGTAG_OS               0x0001          <span class=\"comment\">// OS Configuration</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFGTAG_IP               0x0002          <span class=\"comment\">// IP Stack Configuration</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFGTAG_SERVICE          0x0003          <span class=\"comment\">// Service</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFGTAG_IPNET            0x0004          <span class=\"comment\">// IP Network</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFGTAG_ROUTE            0x0005          <span class=\"comment\">// Gateway Route</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFGTAG_CLIENT           0x0006          <span class=\"comment\">// DHCPS Client</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFGTAG_SYSINFO          0x0007          <span class=\"comment\">// System Information</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFGTAG_ACCT             0x0008          <span class=\"comment\">// User Account</span></span></span><br></pre></td></tr></table></figure>\n<p><code>uint Item</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Currently Used DHCP Compatible Items</span></span><br><span class=\"line\"><span class=\"comment\">// Multiple instances are always to be stored as multiple config entries, not a concatenated byte string in a single config entry.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFGITEM_DHCP_DOMAINNAMESERVER   6       <span class=\"comment\">// Stack&#x27;s DNS servers</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFGITEM_DHCP_HOSTNAME           12      <span class=\"comment\">// Stack&#x27;s host name</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFGITEM_DHCP_NBNS               44      <span class=\"comment\">// Stack&#x27;s NBNS servers</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFGITEM_DHCP_CLIENT_OPTION\t\t61\t\t<span class=\"comment\">// Stack DHCP Client Identifier</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFGITEM_SYSINFO_REALM1          256     <span class=\"comment\">// Realm Name 1 (max 31 chars)</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFGITEM_SYSINFO_REALM2          257     <span class=\"comment\">// Realm Name 2 (max 31 chars)</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFGITEM_SYSINFO_REALM3          258     <span class=\"comment\">// Realm Name 3 (max 31 chars)</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFGITEM_SYSINFO_REALM4          259     <span class=\"comment\">// Realm Name 4 (max 31 chars)</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFGITEM_SYSINFO_REALMPPP        260     <span class=\"comment\">// Realm Name PPP (max 31 chars)</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFGITEM_SYSINFO_EVALCALLBACK    261    <span class=\"comment\">// Callback function to notify</span></span></span><br><span class=\"line\">                                               <span class=\"comment\">// application 5 min before</span></span><br><span class=\"line\">                                               <span class=\"comment\">// end of stack evaluation period         </span></span><br></pre></td></tr></table></figure>\n<p><code>uint Mode</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Add Entry Flags</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFG_ADDMODE_UNIQUE      0x0001  <span class=\"comment\">// Replace all previous instances</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFG_ADDMODE_DUPLICATE   0x0002  <span class=\"comment\">// Allow duplicate data entry</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CFG_ADDMODE_NOSAVE      0x0004  <span class=\"comment\">// Don&#x27;t include this entry in CfgSave</span></span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<h1 id=\"socket-in-windows\">Socket in Windows</h1>\n<p>Windows Sockets可以保证应用程序在任何支持Windows Sockets API 的网络内正常通信。</p>\n<p>流式Socket：基于TCP，数据无差错且无重复发送；</p>\n<p>数据报Socket：基于UDP，不能保证数据按发送顺序接收，可能丢失或重复。</p>\n<p>真正与客户端Socket对象通信都不是服务器 Socket对象，而是新创建的“临时”Socket对象</p>\n<blockquote>\n<p>构造函数：CAsyncSocket();</p>\n<p>Create();【成功返回非0，失败返回0】 //SOCK_DGRAM 数据报</p>\n<p>GetSockName(); //用于获取Socket对象的本地名称（自己的信息），ip地址及端口号，或</p>\n<p>GetPeerName(); //用于获取连接的Socket对象名称（对方的信息）</p>\n<p>Listen(); //面向流式使用，参数范围1~5，表示等待连接队列的最大长度</p>\n<p>Accept(); //用以接收等待队列中存在的连接请求</p>\n<p>Connect(); //建立连接请求函数</p>\n<p>Send(); //</p>\n</blockquote>\n<p>除字符型与布尔型外，其余整型用于表示（可能）不同尺寸的整数。</p>\n<p>C++规定一个int（最小16bit）至少和一个short（16bit）一样大，一个long（最小32bit）至少和一个int一样大，一个long long（64bit）至少和一个long一样大。</p>\n<p>其中，long long 是在C++ 11中新定义的。</p>\n<p>尽管字符型char有三种（char、signed char、unsigned char），但是字符的表现形式只有2种，signed或unsigned。类型char实际上会表现为其中一种，具体由编译器决定。</p>\n<p>字面值常量</p>\n<blockquote>\n<p>20 //十进制</p>\n<p>020 //0开头的为8进制</p>\n<p>0x20 //0x开头的为16进制</p>\n</blockquote>\n<h1 id=\"send-blocking\">SEND() BLOCKING</h1>\n<blockquote>\n<p>In some cases where send() would block, it instead returns without copying all of the data as requested.</p>\n<p>In this case, the return value of send() indicates how many bytes were actually copied. One example of this is if your program is blocking on send() and then receives a signal from the operating system.</p>\n<p>In these cases, it is up to caller to try again with any remaining data.</p>\n</blockquote>\n<h1 id=\"套接字及流输入输出接口io\">套接字及流输入输出接口(IO)</h1>\n<p><strong>TOPIC</strong></p>\n<blockquote>\n<ul>\n<li>文件描述符环境</li>\n<li>文件描述符编程接口</li>\n<li>套接字编程接口</li>\n<li>元以太网套接字编程接口</li>\n<li>全双工管道编程接口</li>\n<li>因特网群组管理协议(IGMP)</li>\n</ul>\n</blockquote>\n<p>在各嵌入式系统中，对文件描述符的支持都大相径庭。大部分情况，都只支持基本功能（bare minimum functionality）， 通常都以通用名称命名和提供被修剪过的函数(trimmed down support functions)。</p>\n<p>TI NDK支持标准套接字接口函数，这些函数也要求文件描述符的支持，堆栈提供一个小型文件系统。</p>\n<p>在堆栈代码内部的基本构建块是一个对象句柄。在其内部，套接字和管道都通过对象句柄寻址。然而，在应用层，套接字和管道都被当做文件描述符看待。文件描述符内涵附加状态信息（additional state information），允许根据套接字活动阻塞和解除阻塞任务。</p>\n<p><strong>注意：</strong>尽管文件描述符能够在传统函数中使用，如select()， 但在这种实现方式中，他们仍然是句柄，而不是整型。</p>\n<p>出于兼容性考虑，网络程序必须使用NDK头文件，然后使用INVALID_SOCKET作为错误情况判定，并且在检查SOCKET有效性时，不要直接与（&lt;0）比较。</p>\n<p>使用文件描述符前，需要一个任务首先创建一个文件描述符表格（FD table / session）。只需要在应用层调用文件描述符函数 <code>fdOpenSession()</code> 来完成。</p>\n<p>当任务结束使用FD接口，或被关闭时，调用 <code>fdCloseSession()</code> 。</p>\n<p>为确保堆栈操作正确，每个任务在使用FD相关的函数前，都应创建FD session，在使用完毕后关闭它。</p>\n<h2 id=\"open-fd-session\">Open FD Session</h2>\n<ol type=\"1\">\n<li><p>最简单的方式就是用 <code>TaskCreate()</code> ，他可以（自动）在内部打开和关闭FD session。</p></li>\n<li><p>另一种方式就是在函数调用的最开头进行session创建，在函数结束的末尾进行session关闭。如下：</p></li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">socket_task</span><span class=\"params\">(<span class=\"keyword\">int</span> IPAddr, <span class=\"keyword\">int</span> TcpPort)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        SOCKET s;</span><br><span class=\"line\">        <span class=\"comment\">// Open the file session</span></span><br><span class=\"line\">        fdOpenSession(TaskSelf());</span><br><span class=\"line\">       <span class=\"comment\">// &lt; socket application code &gt;</span></span><br><span class=\"line\">        <span class=\"comment\">// Close the file session</span></span><br><span class=\"line\">        fdCloseSession(TaskSelf());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\" type=\"1\">\n<li>另一种方式就是创建子线程。注意的是，父线程需要保证子线程的任务被执行前打开子线程的session。可通过任务优先级或信标来完成，但会增加任务创建复杂度，并不是理想方案。</li>\n<li>也可以通过让子任务调用session创建函数，并且由父线程来监控和关闭子线程门。</li>\n</ol>\n<p>栈库支持一些通常被认为是文件函数的功能，因此套接字应用程序可以在更传统的意义上编程。</p>\n<blockquote>\n<p>The stack library supports a handful of what are normally considered file functions, so that sockets applications can be programmed in a more traditional sense.</p>\n</blockquote>\n<p><code>fdPoll()</code> 远比 <code>fdSelect()</code> 来得更有效率。它轮询提供的套接字列表，并指定以毫秒为单位的超时(或使用<em>POLLINFTIM</em> 来设置无限超时)。拥有 <code>fdSelect()</code> 的优点，即对原始文件描述符列表（或者套接字）的检验不会被结果所改写，因此可以不用重建便多次使用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fdpollitem</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *fd;  <span class=\"comment\">//the fd or socket to check</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> eventsRequested;  <span class=\"comment\">//a set of flags for requested events</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> eventsDetected;  <span class=\"comment\">//a set of resulting flags for a detected event</span></span><br><span class=\"line\">&#125; FDPOLLITEM;</span><br></pre></td></tr></table></figure>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li><a href=\"man7.org\">Michael Kerrisk</a></li>\n</ol>\n","categories":["Networking"],"tags":["Socket"]},{"title":"traceroute & tracert","url":"/2021/10/22/Networking/2021-10-22-traceroute-&-tracert/","content":"<p><a href=\"https://www.jianshu.com/p/75a5822d0eec\">Traceroute（路由追踪）的原理及实现</a></p>\n<p>traceroute 和 tracert 是Linux和Windows平台下用于追踪网络设备距离远近的工具，向目标设备发包，从 <code>TTL=1</code> 开始向外发包，逐渐增加 <code>TTL</code> 的值，直到目标主机。在介绍traceroute和tracert的原理之前，需要了解几个技术名词：</p>\n<blockquote>\n<p><strong>IP</strong>，协议是TCP/IP协议族中最核心的部分，它的作用是在两台主机之间传输数据，所有上层协议的数据（HTTP、TCP、UDP等）都会被封装在一个个的IP数据包中被发送到网络上。</p>\n</blockquote>\n<blockquote>\n<p><strong>ICMP</strong>，即 <em>Internet Control Message Protocol</em>，互联网控制报文协议，它常用于传递错误信息，ICMP协议是IP层的一部分，它的报文也是通过IP数据包来传输的。</p>\n</blockquote>\n<blockquote>\n<p><strong>TTL</strong>，即 <em>time-to-live</em>，是IP数据包中的一个字段，它指定了数据包最多能经过几次路由器。从我们源主机发出去的数据包在到达目的主机的路上要经过许多个路由器的转发，在发送数据包的时候源主机会设置一个TTL的值，每经过一个路由器TTL就会被减去一，当TTL为0的时候该数据包会被直接丢弃（不再继续转发），并发送一个超时ICMP报文给源主机。</p>\n</blockquote>\n<h1 id=\"实现方案\">实现方案</h1>\n<p>tracert （windows）只支持基于 ICMP 报文发送，而 traceroute（Linux/Mac） 支持多种报文协议（UDP、ICMP、TCP）的发送，但不带任何选项（Options）时默认使用的是UDP。（具体参数和选项自行请自行 <code>man</code> 以查看手册）</p>\n<p>下方所示图片分别为 tracert （windows）的帮助手册，以及在traceroute（Linux）上分别使用三种协议追踪 <code>baidu.com</code> 的结果截图。后续仅对UDP及ICMP追踪做较为详细的说明。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211022084346.png\" alt=\"tracert的帮助说明\" /><figcaption aria-hidden=\"true\">tracert的帮助说明</figcaption>\n</figure>\n<p>使用 TCP 报文的 traceroute：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211022085430.png\" alt=\"基于TCP报文的traceroute\" /><figcaption aria-hidden=\"true\">基于TCP报文的traceroute</figcaption>\n</figure>\n<p>使用 ICMP 报文的 traceroute：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211022085432.png\" alt=\"基于ICMP报文的traceroute\" /><figcaption aria-hidden=\"true\">基于ICMP报文的traceroute</figcaption>\n</figure>\n<p>使用 UDP 报文的 traceroute：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211022085433.png\" alt=\"基于UDP报文的traceroute\" /><figcaption aria-hidden=\"true\">基于UDP报文的traceroute</figcaption>\n</figure>\n<h2 id=\"基于udp实现\">基于UDP实现</h2>\n<p>在基于UDP的实现中，客户端发送的数据包是通过UDP协议来传输的，使用了一个大于 <code>30000</code> 的端口号，服务器在收到这个数据包的时候会返回一个<strong>端口不可达</strong>的ICMP错误信息，客户端通过判断收到的错误信息是TTL超时还是端口不可达来判断数据包是否到达目标主机，具体的流程如图：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211022085956.png\" alt=\"image-20211022085752243\" /><figcaption aria-hidden=\"true\">image-20211022085752243</figcaption>\n</figure>\n<h3 id=\"实现流程\">实现流程</h3>\n<ol type=\"1\">\n<li>客户端发送一个TTL为 <code>1</code> ，端口号大于 <code>30000</code> 的UDP数据包，到达第一站路由器之后TTL被减去 <code>1</code> ，返回了一个超时的ICMP数据包，客户端得到第一跳路由器的地址。</li>\n<li>客户端发送一个TTL为 <code>2</code> 的数据包，在第二跳的路由器节点处超时，得到第二跳路由器的地址。</li>\n<li>客户端发送一个TTL为 <code>3</code> 的数据包，数据包成功到达目标主机，返回一个<strong>端口不可达</strong>错误，traceroute结束。</li>\n</ol>\n<p>Linux和macOS系统自带了一个<code>traceroute</code>指令，可以结合Wireshark抓包来看看它的实现原理。首先对百度的域名进行traceroute：<code>traceroute www.baidu.com</code>，每一跳默认发送三个数据包，我们会看到下面这样的输出：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211022092354.png\" alt=\"image-20211022085720428\" /><figcaption aria-hidden=\"true\">image-20211022085720428</figcaption>\n</figure>\n<p>对该域名的IP：<code>115.239.210.27</code>进行traceroute，此时Wireshark抓包的结果如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211022092351.png\" alt=\"image-20211022085739900\" /><figcaption aria-hidden=\"true\">image-20211022085739900</figcaption>\n</figure>\n<h3 id=\"抓包结果\">抓包结果</h3>\n<p>注意看红框处的内容，跟第一张图对比，可以看到<code>traceroute</code>程序首先通过UDP协议向目标地址115.239.210.27发送了一个<strong>TTL为1</strong>的数据包，然后在第一个路由器中TTL超时，返回一个错误类型为<code>Time-to-live exceeded</code>的ICMP数据包，此时我们通过该数据包的源地址可知第一站路由器的地址为<code>10.242.0.1</code>。之后只需要不停增加TTL的值就能得到每一跳的地址了。</p>\n<p>然而一直跑下去会发现，traceroute并不能到达目的地，当TTL增加到一定大小之后就一直拿不到返回的数据包了：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211022092302.png\" alt=\"image-20211022085834275\" /><figcaption aria-hidden=\"true\">image-20211022085834275</figcaption>\n</figure>\n<p>结果全是丢失，其实这个时候数据包已经到达目标服务器了，但是因为安全问题大部分的应用服务器都不提供UDP服务（或者被防火墙挡掉），所以我们拿不到服务器的任何返回，程序就理所当然的认为还没有结束，一直尝试增加数据包的TTL。</p>\n<p>目前在网上找到许多开源iOS traceroute实现大多都是基于UDP的方案，实际用起来并不能达到想要的效果，所以我们需要采用另一种方案来实现。</p>\n<h2 id=\"基于icmp实现\">基于ICMP实现</h2>\n<p>上述方案失败的原因是由于服务器对于UDP数据包的处理，所以在这一种实现中我们不使用UDP协议，而是直接发送一个<strong>ICMP回显请求（echo request）</strong>数据包，服务器在收到回显请求的时候会向客户端发送一个<strong>ICMP回显应答（echo reply）</strong>数据包，在这之后的流程还是跟第一种方案一样。这样就避免了我们的traceroute数据包被服务器的防火墙策略墙掉。</p>\n<p>采用这种方案的实现流程如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211022085956.png\" alt=\"image-20211022085752243\" /><figcaption aria-hidden=\"true\">image-20211022085752243</figcaption>\n</figure>\n<h3 id=\"实现流程-1\">实现流程</h3>\n<ol type=\"1\">\n<li>客户端发送一个TTL为1的<strong>ICMP请求回显</strong>数据包，在第一跳的时候超时并返回一个ICMP超时数据包，得到第一跳的地址。</li>\n<li>客户端发送一个TTL为2的ICMP请求回显数据包，得到第二跳的地址。</li>\n<li>客户端发送一个TTL为3的ICMP请求回显数据包，到达目标主机，目标主机返回一个<strong>ICMP回显应答</strong>，traceroute结束。</li>\n</ol>\n<p>可以看出与第一种实现相比，区别主要在发送的数据包类型以及对于结束的判断上，大体的流程还是一致的。</p>\n","categories":["Networking"],"tags":["traceroute","tracert"]},{"title":"Unix domain socket 简介","url":"/2021/04/20/Networking/2021-04-20-Unix%20domain%20socket%20%E7%AE%80%E4%BB%8B/","content":"<p><a href=\"https://www.cnblogs.com/sparkdev/p/8359028.html\">cnblogs.com</a></p>\n<p><strong>Unix domain socket 又叫 IPC(inter-process communication 进程间通信) socket，用于实现同一主机上的进程间通信。</strong>socket 原本是为网络通讯设计的，但后来在 socket 的框架上发展出一种 IPC 机制，就是 UNIX domain socket。虽然网络 socket 也可用于同一台主机的进程间通讯(通过 loopback 地址 127.0.0.1)，但是 UNIX domain socket 用于 IPC 更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。这是因为，IPC 机制本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。 UNIX domain socket 是全双工的，API 接口语义丰富，相比其它 IPC 机制有明显的优越性，目前已成为使用最广泛的 IPC 机制，比如 X Window 服务器和 GUI 程序之间就是通过 UNIX domain socket 通讯的。 Unix domain socket 是 POSIX 标准中的一个组件，所以不要被名字迷惑，linux 系统也是支持它的。</p>\n<p>下面通过一个简单的 demo 来理解相关概念。程序分为服务器端和客户端两部分，它们之间通过 unix domain socket 进行通信。</p>\n<h1 id=\"服务器端程序\">服务器端程序</h1>\n<p>下面是一个非常简单的服务器端程序，它从客户端读字符，然后将每个字符转换为大写并回送给客户端：</p>\n<figure>\n<img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\" /><figcaption aria-hidden=\"true\">复制代码</figcaption>\n</figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;stdlib.h&gt;  </span><br><span class=\"line\">#include &lt;stdio.h&gt;  </span><br><span class=\"line\">#include &lt;stddef.h&gt;  </span><br><span class=\"line\">#include &lt;sys&#x2F;socket.h&gt;  </span><br><span class=\"line\">#include &lt;sys&#x2F;un.h&gt;  </span><br><span class=\"line\">#include &lt;errno.h&gt;  </span><br><span class=\"line\">#include &lt;string.h&gt;  </span><br><span class=\"line\">#include &lt;unistd.h&gt;  </span><br><span class=\"line\">#include &lt;ctype.h&gt;   </span><br><span class=\"line\"> </span><br><span class=\"line\">#define MAXLINE 80  </span><br><span class=\"line\"> </span><br><span class=\"line\">char *socket_path &#x3D; &quot;server.socket&quot;;  </span><br><span class=\"line\"> </span><br><span class=\"line\">int main(void)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    struct sockaddr_un serun, cliun;  </span><br><span class=\"line\">    socklen_t cliun_len;  </span><br><span class=\"line\">    int listenfd, connfd, size;  </span><br><span class=\"line\">    char buf[MAXLINE];  </span><br><span class=\"line\">    int i, n;  </span><br><span class=\"line\"> </span><br><span class=\"line\">    if ((listenfd &#x3D; socket(AF_UNIX, SOCK_STREAM, 0)) &lt; 0) &#123;  </span><br><span class=\"line\">        perror(&quot;socket error&quot;);  </span><br><span class=\"line\">        exit(1);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"> </span><br><span class=\"line\">    memset(&amp;serun, 0, sizeof(serun));  </span><br><span class=\"line\">    serun.sun_family &#x3D; AF_UNIX;  </span><br><span class=\"line\">    strcpy(serun.sun_path, socket_path);  </span><br><span class=\"line\">    size &#x3D; offsetof(struct sockaddr_un, sun_path) + strlen(serun.sun_path);  </span><br><span class=\"line\">    unlink(socket_path);  </span><br><span class=\"line\">    if (bind(listenfd, (struct sockaddr *)&amp;serun, size) &lt; 0) &#123;  </span><br><span class=\"line\">        perror(&quot;bind error&quot;);  </span><br><span class=\"line\">        exit(1);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    printf(&quot;UNIX domain socket bound\\n&quot;);  </span><br><span class=\"line\">      </span><br><span class=\"line\">    if (listen(listenfd, 20) &lt; 0) &#123;  </span><br><span class=\"line\">        perror(&quot;listen error&quot;);  </span><br><span class=\"line\">        exit(1);          </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    printf(&quot;Accepting connections ...\\n&quot;);  </span><br><span class=\"line\"> </span><br><span class=\"line\">    while(1) &#123;  </span><br><span class=\"line\">        cliun_len &#x3D; sizeof(cliun);         </span><br><span class=\"line\">        if ((connfd &#x3D; accept(listenfd, (struct sockaddr *)&amp;cliun, &amp;cliun_len)) &lt; 0)&#123;  </span><br><span class=\"line\">            perror(&quot;accept error&quot;);  </span><br><span class=\"line\">            continue;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">          </span><br><span class=\"line\">        while(1) &#123;  </span><br><span class=\"line\">            n &#x3D; read(connfd, buf, sizeof(buf));  </span><br><span class=\"line\">            if (n &lt; 0) &#123;  </span><br><span class=\"line\">                perror(&quot;read error&quot;);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">            &#125; else if(n &#x3D;&#x3D; 0) &#123;  </span><br><span class=\"line\">                printf(&quot;EOF\\n&quot;);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">              </span><br><span class=\"line\">            printf(&quot;received: %s&quot;, buf);  </span><br><span class=\"line\"> </span><br><span class=\"line\">            for(i &#x3D; 0; i &lt; n; i++) &#123;  </span><br><span class=\"line\">                buf[i] &#x3D; toupper(buf[i]);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            write(connfd, buf, n);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        close(connfd);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    close(listenfd);  </span><br><span class=\"line\">    return 0;  </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\" /><figcaption aria-hidden=\"true\">复制代码</figcaption>\n</figure>\n<p>简单介绍一下这段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int socket(int family, int type, int protocol);</span><br></pre></td></tr></table></figure>\n<p>使用 UNIX domain socket 的过程和网络 socket 十分相似，也要先调用 socket() 创建一个 socket 文件描述符. <strong>family</strong> 指定为 AF_UNIX，使用 AF_UNIX 会在系统上创建一个 socket 文件，不同进程通过读写这个文件来实现通信。 <strong>type</strong> 可以选择 SOCK_DGRAM 或 SOCK_STREAM。SOCK_STREAM 意味着会提供按顺序的、可靠、双向、面向连接的比特流。SOCK_DGRAM 意味着会提供定长的、不可靠、无连接的通信。 <strong>protocol</strong> 参数指定为 0 即可。 UNIX domain socket 与网络 socket 编程最明显的不同在于地址格式不同，用结构体 sockaddr_un 表示，网络编程的 socket 地址是 IP 地址加端口号，而 UNIX domain socket 的地址是一个 socket 类型的文件在文件系统中的路径，这个 socket 文件由 bind() 调用创建，如果调用 bind() 时该文件已存在，则 bind() 错误返回。因此，一般在调用 bind() 前会检查 socket 文件是否存在，如果存在就删除掉。 网络 socket 编程类似，在 bind 之后要 listen，表示通过 bind 的地址（也就是 socket 文件）提供服务。 接下来必须用 accept() 函数初始化连接。accept() 为每个连接创立新的套接字并从监听队列中移除这个连接。</p>\n<h1 id=\"客户端程序\">客户端程序</h1>\n<p>下面是客户端程序，它接受用户的输入，并把字符串发送给服务器，然后接收服务器返回的字符串并打印：</p>\n<figure>\n<img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\" /><figcaption aria-hidden=\"true\">复制代码</figcaption>\n</figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;stdlib.h&gt;  </span><br><span class=\"line\">#include &lt;stdio.h&gt;  </span><br><span class=\"line\">#include &lt;stddef.h&gt;  </span><br><span class=\"line\">#include &lt;sys&#x2F;socket.h&gt;  </span><br><span class=\"line\">#include &lt;sys&#x2F;un.h&gt;  </span><br><span class=\"line\">#include &lt;errno.h&gt;  </span><br><span class=\"line\">#include &lt;string.h&gt;  </span><br><span class=\"line\">#include &lt;unistd.h&gt;  </span><br><span class=\"line\"> </span><br><span class=\"line\">#define MAXLINE 80  </span><br><span class=\"line\"> </span><br><span class=\"line\">char *client_path &#x3D; &quot;client.socket&quot;;  </span><br><span class=\"line\">char *server_path &#x3D; &quot;server.socket&quot;;  </span><br><span class=\"line\"> </span><br><span class=\"line\">int main() &#123;  </span><br><span class=\"line\">    struct  sockaddr_un cliun, serun;  </span><br><span class=\"line\">    int len;  </span><br><span class=\"line\">    char buf[100];  </span><br><span class=\"line\">    int sockfd, n;  </span><br><span class=\"line\"> </span><br><span class=\"line\">    if ((sockfd &#x3D; socket(AF_UNIX, SOCK_STREAM, 0)) &lt; 0)&#123;  </span><br><span class=\"line\">        perror(&quot;client socket error&quot;);  </span><br><span class=\"line\">        exit(1);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    &#x2F;&#x2F; 一般显式调用bind函数，以便服务器区分不同客户端  </span><br><span class=\"line\">    memset(&amp;cliun, 0, sizeof(cliun));  </span><br><span class=\"line\">    cliun.sun_family &#x3D; AF_UNIX;  </span><br><span class=\"line\">    strcpy(cliun.sun_path, client_path);  </span><br><span class=\"line\">    len &#x3D; offsetof(struct sockaddr_un, sun_path) + strlen(cliun.sun_path);  </span><br><span class=\"line\">    unlink(cliun.sun_path);  </span><br><span class=\"line\">    if (bind(sockfd, (struct sockaddr *)&amp;cliun, len) &lt; 0) &#123;  </span><br><span class=\"line\">        perror(&quot;bind error&quot;);  </span><br><span class=\"line\">        exit(1);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"> </span><br><span class=\"line\">    memset(&amp;serun, 0, sizeof(serun));  </span><br><span class=\"line\">    serun.sun_family &#x3D; AF_UNIX;  </span><br><span class=\"line\">    strcpy(serun.sun_path, server_path);  </span><br><span class=\"line\">    len &#x3D; offsetof(struct sockaddr_un, sun_path) + strlen(serun.sun_path);  </span><br><span class=\"line\">    if (connect(sockfd, (struct sockaddr *)&amp;serun, len) &lt; 0)&#123;  </span><br><span class=\"line\">        perror(&quot;connect error&quot;);  </span><br><span class=\"line\">        exit(1);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"> </span><br><span class=\"line\">    while(fgets(buf, MAXLINE, stdin) !&#x3D; NULL) &#123;    </span><br><span class=\"line\">         write(sockfd, buf, strlen(buf));    </span><br><span class=\"line\">         n &#x3D; read(sockfd, buf, MAXLINE);    </span><br><span class=\"line\">         if ( n &lt; 0 ) &#123;    </span><br><span class=\"line\">            printf(&quot;the other side has been closed.\\n&quot;);    </span><br><span class=\"line\">         &#125;else &#123;    </span><br><span class=\"line\">            write(STDOUT_FILENO, buf, n);    </span><br><span class=\"line\">         &#125;    </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    close(sockfd);  </span><br><span class=\"line\">    return 0;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\" /><figcaption aria-hidden=\"true\">复制代码</figcaption>\n</figure>\n<p>与网络 socket 编程不同的是，UNIX domain socket 客户端一般要显式调用 bind 函数，而不依赖系统自动分配的地址。客户端 bind 一个自己指定的 socket 文件名的好处是，该文件名可以包含客户端的 pid 等信息以便服务器区分不同的客户端。</p>\n<h1 id=\"运行上面的程序\">运行上面的程序</h1>\n<p>分别把服务器端程序和客户端程序保存为 server.c 和 client.c 文件，并编译：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ gcc server.c -o server</span><br><span class=\"line\">$ gcc client.c -o client</span><br></pre></td></tr></table></figure>\n<p>先启动服务器端程序，然后启动客户端程序输入字符串并回车：</p>\n<figure>\n<img src=\"https://images2017.cnblogs.com/blog/952033/201801/952033-20180126125928506-239880118.png\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>还不错，客户端得到了服务器端返回的大写字符串。接下来看看当前目录下的文件：</p>\n<figure>\n<img src=\"https://images2017.cnblogs.com/blog/952033/201801/952033-20180126125951834-1641586991.png\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>哈哈，多了两个 socket 文件。</p>\n<h1 id=\"总结\">总结</h1>\n<p>Unix domain socket 主要用于同一主机上的进程间通信。与主机间的进程通信不同，它不是通过 \"IP地址 + TCP或UDP端口号\" 的方式进程通信，而是使用 socket 类型的文件来完成通信，因此在稳定性、可靠性以及效率方面的表现都很不错。</p>\n<p><strong>参考：</strong> <a href=\"http://docs.linuxtone.org/ebooks/C&amp;CPP/c/ch37s04.html\">UNIX Domain Socket IPC</a> [<a href=\"http://blog.csdn.net/tzshlyt/article/details/53391655\">linux] unix domain socket 例子</a></p>\n<p>​</p>\n","categories":["Networking"],"tags":["Socket","unix"]},{"title":"Networking","url":"/2021/04/20/Networking/2021-04-20-Networking/","content":"<h3 id=\"cdn\">CDN</h3>\n<blockquote>\n<p><em>内容分发网络（Content Delivery Network，CDN）是建立并覆盖在承载网上，由不同区域的服务器组成的分布式网络。将源站资源缓存到全国各地的边缘服务器，供用户就近获取，降低源站压力。</em></p>\n<p>——阿里云</p>\n<p><em>CDN是构建在现有网络基础之上的智能虚拟网络，依靠 <strong>部署在各地的边缘服务器</strong>，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</em></p>\n<p>——百度百科</p>\n</blockquote>\n<p>个人理解，实际部署CDN中最重要的概念即 <strong>节点</strong>、<strong>缓存服务器</strong> 和 <strong>中心平台</strong>。</p>\n<ul>\n<li>节点是指在足够广的范围内识别出合适数量的网络拓扑节点，这些节点往往处在网络所及最远之处的各地，能够有效分摊用户访问对主干网络的压力；</li>\n<li>而缓存服务器即“部署在各地的边缘服务器”，是指能够 <strong>制定规则</strong> <strong>自动识别并缓存数据</strong> 以供用户快速访问，分担主干网络压力的实体。</li>\n<li>中心平台可以对缓存服务器实现负载均衡、内容分发和调度等功能。</li>\n</ul>\n<h4 id=\"工作原理\">工作原理</h4>\n<blockquote>\n<p>假设您的加速域名为<code>www.a.com</code>，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下图所示。</p>\n<ol type=\"1\">\n<li>当终端用户（北京）向<code>www.a.com</code>下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。<br />\n</li>\n<li>LDNS检查缓存中是否有<code>www.a.com</code>的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。<br />\n</li>\n<li>当授权DNS解析<code>www.a.com</code>时，返回域名CNAME <code>www.a.tbcdn.com</code>对应IP地址。<br />\n</li>\n<li>域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。</li>\n<li>LDNS获取DNS返回的解析IP地址。</li>\n<li>用户获取解析IP地址。</li>\n<li>用户向获取的IP地址发起对该资源的访问请求。\n<ul>\n<li>如果该IP地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤7和8，请求结束。</li>\n<li>如果该IP地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。配置缓存策略的操作方法，请参见<a href=\"https://help.aliyun.com/document_detail/27136.htm?spm=a2c4g.11186623.2.3.694925b3RabzbR#concept-f24-32d-xdb\">缓存配置</a>。</li>\n</ul></li>\n</ol>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/p4886.png\" alt=\"img\" style=\"zoom: 67%;\" /></p>\n<p>——阿里云</p>\n</blockquote>\n<h4 id=\"应用场景\">应用场景</h4>\n<h5 id=\"场景概述\">场景概述</h5>\n<p>CDN的业务使用场景分为 <strong>静态内容加速</strong>、<strong>动态内容加速</strong> 和 <strong>安全加速</strong> 。</p>\n<blockquote>\n<p><strong>静态内容（静态资源）</strong></p>\n<p>静态内容是指在不同请求中访问到的数据都相同的静态文件。例如：图片、视频、网站中的文件（html、css、js）、软件安装包、apk文件、压缩包文件等。</p>\n<p>CDN加速的本质是 <strong>缓存加速</strong>。将您服务器上存储的静态内容缓存在阿里云CDN节点上，当您访问这些静态内容时，无需访问服务器源站，就近访问阿里云CDN节点即可获取相同内容。从而达到加速的效果，同时减轻服务器源站的压力。</p>\n<p><strong>动态内容（动态资源）</strong></p>\n<p>动态内容是指在不同请求中访问到的数据不相同的动态内容。例如：网站中的文件（asp、jsp、php、perl、cgi）、API接口、数据库交互请求等。</p>\n<p><strong>当您访问这些动态内容时，每次都需要访问您的服务器，由服务器动态生成实时的数据并返回给您。</strong>因此CDN的缓存加速不适用于加速动态内容，CDN无法缓存实时变化的动态内容。对于动态内容请求，CDN节点只能转发回您的服务器源站，没有加速效果。</p>\n<p>如果您的网站或App应用有较多动态内容，例如需要对各种API接口进行加速，则需要使用 <a href=\"https://www.alibabacloud.com/zh/product/dcdn\">阿里云全站加速</a> 产品。全站加速能同时加速动态和静态内容，加速方式如下：</p>\n<ul>\n<li>静态内容使用CDN加速。</li>\n<li>动态内容通过阿里云的 <strong>路由优化</strong>、<strong>传输优化</strong> 等动态加速技术以最快的速度访问您的服务器源站获取数据。从而达到全站加速的效果。</li>\n</ul>\n<p>——阿里云</p>\n</blockquote>\n<h5 id=\"全站加速\">全站加速</h5>\n<blockquote>\n<p>全站加速（Dynamic Route for Content Delivery Network）是阿里云自主研发的融合了动态加速和静态加速技术的CDN产品。该产品一站式解决了页面动静态资源混杂、跨运营商、网络不稳定、单线源站、突发流量、网络拥塞等诸多因素导致的响应慢、丢包、服务不稳定的问题，提升全站性能和用户体验。</p>\n<p><strong>工作原理</strong></p>\n<p>阿里云全站加速通过智能路由区分客户请求内容，实现动静态加速。通过架构图，您可以了解全站加速的工作原理。</p>\n<p><img src=\"https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/5931788951/p6063.png\" style=\"zoom: 40%;\" /></p>\n<ul>\n<li>智能区分动静态内容：域名接入阿里云全站加速后，通过域名访问的动静态内容将被智能识别并区分。</li>\n<li>动静态内容同时加速：静态内容使用阿里云CDN加速，缓存在CDN节点上，供您就近访问。动态内容通过 <strong>智能路由优化</strong>、<strong>协议优化</strong> 等动态加速技术快速回源获取。</li>\n</ul>\n<p><strong>全站加速与CDN对比</strong></p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210414100053078.png\" alt=\"image-20210414100053078\" style=\"zoom: 80%;\" /></p>\n</blockquote>\n<h3 id=\"ssh\">SSH</h3>\n<p>SSH is a program for logging into a remote machine and for excuting commands on a remote machine.</p>\n<p>It's intended to provide secure encrypted communications between two untrusted hosts over and insecure network.</p>\n<p>X11 connections, arbitrary TCP ports and UNIX-domain sockets can also be forwarded over the secure channel.</p>\n<h4 id=\"authentication\">Authentication</h4>\n<p>The OpenSSH SSH client supports SSH protocol 2.</p>\n<p>Five available authentication methods: GSSAPI-based / host-based / public key / challenge-response and password.</p>\n<h5 id=\"host-based\">Host-based</h5>\n<p>If the machine the user logs in from is listed in <code>/etc/hosts.equiv</code> or <code>/etc/ssh/shosts.equiv</code> on the remote machine, the user is non-root and the user names are the same on both sides, or if the files <code>~/.rhosts</code> or <code>~/.shosts</code> exist in the user's home directory on the remote machine and contain a line containing the name of the client machine and the name of the user on that machine, the user is considered for login. Additionally, the server must be able to verify the client's host key (see the description of <code>/etc/ssh/ssh_known_hosts</code> and <code>~/.ssh/known_hosts</code>, below) for login to be permitted. This authentication method closes security holes due to IP spoofing, DNS spoofing, and routing spoofing.</p>\n<p>[<strong>Note to the administrator</strong>: <code>/etc/hosts.equiv</code>, <code>~/.rhosts</code>, and the rlogin/rsh protocol in general, are inherently insecure and should be disabled if security is desired.]</p>\n<h5 id=\"public-key\">Public key</h5>\n<p>The scheme is based on public-key cryptography, using cryptosystems where encryption and decryption are done using separate keys, and it is unfeasible to derive the decryption key from the encryption key. The idea is that each user creates a public/private key pair for authentication purposes.</p>\n<p><strong><em>The server knows the public key, and only the user knows the private key.</em></strong> ssh implements public key authentication protocol automatically, using one of the <strong>DSA</strong>, <strong>ECDSA</strong>, <strong>Ed25519</strong> or <strong>RSA</strong> algorithms. The HISTORY section of ssl(8) <a href=\"http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8#HISTORY\">[i]</a> on non-OpenBSD systems contains a brief discussion of the DSA and RSA algorithms.</p>\n<p>The file <code>~/.ssh/authorized_keys</code> lists the public keys that are permitted for logging in. When the user logs in, the ssh program tells the server which key pair it would like to use for authentication. The client proves that it has access to the private key and the server checks that the corresponding public key is authorized to accept the account.</p>\n<p>The user should then <mark>copy the public key to <code>~/.ssh/authorized_keys</code> in his/her home directory on the remote machine.</mark> The authorized_keys file corresponds to the conventional <code>~/.rhosts</code> file, and has one key per line, though the lines can be very long. After this, the user can log in without giving the password.</p>\n<h6 id=\"ssh-keygen\">ssh-keygen</h6>\n<p>To generate a public key for ssh, we need to use:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-kegen -t rsa</span><br></pre></td></tr></table></figure>\n<p>The terminal will ask if <code>/root/.ssh/id_rsa</code> the file you save the key:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Generating public&#x2F;private rsa key pair.</span><br><span class=\"line\">Enter file in which to save the key (&#x2F;root&#x2F;.ssh&#x2F;id_rsa):</span><br></pre></td></tr></table></figure>\n<p>The terminal will require you to enter the <em>passphrase</em> twice.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Enter passphrase (empty for no passphrase):</span><br><span class=\"line\">Enter same passphrase again:</span><br></pre></td></tr></table></figure>\n<p><strong><em>Identification</em></strong> is the private key used by the server(the remote machine). And the <strong><em>public key</em></strong> is generated for the client to authenticate while logging in the server.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Your identification has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa</span><br><span class=\"line\">Your public key has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub</span><br><span class=\"line\">The key fingerprint is:</span><br><span class=\"line\">SHA256: *******</span><br><span class=\"line\">The key&#39;s randomart imge is:</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>The user creates his/her key pair by running ssh-keygen(1).</p>\n<p>This stores the <strong><em>private key</em></strong> in <code>~/.ssh/id_dsa</code> (DSA), <code>~/.ssh/id_ecdsa</code> (ECDSA), <code>~/.ssh/id_ecdsa_sk</code> (authenticator-hosted ECDSA), <code>~/.ssh/id_ed25519</code> (Ed25519), <code>~/.ssh/id_ed25519_sk</code> (authenticator-hosted Ed25519), or <code>~/.ssh/id_rsa</code> (RSA) .</p>\n<p>The the <strong><em>public key</em></strong> stores in <code>~/.ssh/id_dsa.pub</code> (DSA), <code>~/.ssh/id_ecdsa.pub</code> (ECDSA), <code>~/.ssh/id_ecdsa_sk.pub</code> (authenticator-hosted ECDSA), <code>~/.ssh/id_ed25519.pub</code> (Ed25519), <code>~/.ssh/id_ed25519_sk.pub</code> (authenticator-hosted Ed25519), or <code>~/.ssh/id_rsa.pub</code> (RSA) in the <strong>user's home directory</strong>.</p>\n</blockquote>\n<p>Check and copy your <code>.pub</code> file to the local computer.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~/.ssh/</span><br><span class=\"line\">vim id_rsa.pub</span><br></pre></td></tr></table></figure>\n<h6 id=\"permissions-0644\">Permissions 0644</h6>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210423135807684.png\" alt=\"image-20210423135807684\" style=\"zoom: 80%;\" /></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod 0600 ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>\n<h4 id=\"login-format\">Login Format</h4>\n<p><code>user@hostname</code> : <code>root@qq.com</code></p>\n<p><code>ssh://root@hostname:port</code> : <code>ssh://root@qq.com:666</code></p>\n<h3 id=\"ssl\">SSL</h3>\n<p>基于 SSL 证书，可将站点由 HTTP（Hypertext Transfer Protocol）切换到 HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer），即基于安全套接字层（SSL）进行安全数据传输的加密版 HTTP 协议。</p>\n<h4 id=\"ssl优势\">SSL优势</h4>\n<ul>\n<li><p><strong>防流量劫持：</strong>全站 HTTPS 是根治运营商、中间人流量劫持的解决方案，不仅可以杜绝网页中显示的小广告，更可以保护用户隐私安全。</p></li>\n<li><p><strong>提升搜索排名：</strong>采用 HTTPS 可以帮忙搜索排名的提升，提高站点的可信度和品牌形象。</p></li>\n<li><p><strong>杜绝钓鱼网站：</strong>HTTPS 地址栏绿色图标可以帮助用户识别出钓鱼网站，保障用户和企业的利益不受损害，增强用户信任。</p></li>\n</ul>\n<h4 id=\"ssl证书签发\">SSL证书签发</h4>\n<p>域名型证书由以下品牌提供自动审核认证，快速签发。</p>\n<ul>\n<li><strong>SecureSite</strong>：全球最大的信息安全厂商和服务商，最权威的数字证书颁发机构，为企业、个人用户和服务供应商提供广泛的内容和网络安全解决方案，全球500强中有93%选择了 VeriSign SSL 数字证书，目前均由 SecureSite 提供服务。</li>\n<li><strong>TrustAsia®（亚洲诚信）</strong>：亚数信息科技（上海）有限公司应用于信息安全领域的品牌，是 SecureSite 的白金合作伙伴，专业为企业提供包含数字证书在内的所有网络安全服务。</li>\n<li><strong>GeoTrust</strong>：GeoTrust 是全球第二大数字证书颁发机构（CA），也是身份认证和信任认证领域的领导者，该公司各种先进的技术使得任何大小的机构和公司都能安全地低成本地部署 SSL 数字证书和实现各种身份认证。从2001年成立到2006年占领全球市场25%的市场份额，VeriSign 于2006年5月 - 2006年9月以1.25亿美元收购 GeoTrust，目前也同为 SecureSite 旗下 SSL 证书的<strong>性价比高</strong>的品牌。</li>\n<li><strong>GlobalSign</strong>： GlobalSign 成立于1996年，是一家声誉卓著，备受信赖的 CA 中s心和 SSL 数字证书提供商，在全球总计颁发超过2000万张数字证书。GlobalSign 的专业实力获得中国网络市场众多服务器、域名注册商、系统服务供应商的青睐，成为其数字证书服务的合作伙伴。</li>\n<li><strong>WoTrus（沃通）</strong>：沃通电子认证服务有限公司（WoTrus CA Limited）是同时获得国内电子认证服务许可证（由工信部颁发）和通过国际认证的证书颁发机构（CA）。专业为企业提供权威第三方数字身份认证服务，颁发全球信任的各种数字证书产品。</li>\n<li><strong>DNSPod 品牌国密标准（SM2）证书</strong>：DNSPod 为腾讯云自有品牌，采用国密标准，并且是纯国产数字证书，由国内知名 CA 机构提供基础设置支撑，敏捷高效，同时满足国家监管需求。</li>\n</ul>\n<h4 id=\"ssl证书品牌差异\">SSL证书品牌差异</h4>\n<p>不同品牌的证书在浏览器地址栏、加密强度、赔付保障上均存在差异，最重要的差异点在于根证书。</p>\n<p>例如，GeoTrust 通配符是 GeoTrust 根证书签发的，而 SecureSite 通配符是 SecureSite 根证书签发的。<mark>Digicert 根证书可以兼容市面上所有的浏览器，对移动端的支持也是最好的</mark>，而 Trustasia 通配符也是 Digicert 根证书签发的，GlobalSign 通配符是 GlobalSign 的根证书签发的，DNSPod 是由 Wotrus 的根证书签发的，Wotrus 通配符是 Sectigo 的根证书签发的。</p>\n<blockquote>\n<p><strong>通配符：</strong></p>\n<p><strong>根证书：</strong></p>\n</blockquote>\n<p>单纯从技术角度，SecureSite（原 Verisign）和 GeoTrust 的区别如下：</p>\n<ul>\n<li>算法支持上 SecureSite（支持 RSA、DSA、ECC 三种算法）优于 GeoTrust（支持 RSA、DSA 两种算法）。</li>\n<li>兼容性 SecureSite 优于 GeoTrust，SecureSite 可兼容市面上所有的浏览器，对移动端的支持也是极好的。</li>\n<li>OCSP 响应速度上 SecureSite 优于 GeoTrust。</li>\n<li>CA 安全性方面 SecureSite 优于 GeoTrust，SecureSite 是国际知名安全厂商，CA 的安全级别也是国际第一的安全系数。</li>\n<li>SecureSite 证书除实现加密传输以外，还另外有恶意软件扫描和漏洞评估的附加功能。</li>\n<li>SecureSite 对证书有商业保险赔付保障，金额最高为175万美金，GeoTrust 最高为150万美金。</li>\n</ul>\n<h4 id=\"ssl证书格式\">SSL证书格式</h4>\n<p>SSL证书分为 <code>pem</code> 和 <code>key</code> 这两种格式，分别存储的是 <strong>证书base64加密</strong> 和 <strong>私钥base64加密</strong> 还有 格式分割符，也就是说pem存的是证书，key 存的是私钥。</p>\n<p>如pem中的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-----BEGIN CERTIFICATE-----</span><br><span class=\"line\">略</span><br><span class=\"line\">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure>\n<p><code>-----BEGIN CERTIFICATE-----</code> 和 <code>-----END CERTIFICATE-----</code> 为分割分，表示在这两个中间存的是证书的base64编码</p>\n<p>备注：</p>\n<p>如key中的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-----BEGIN RSA PRIVATE KEY-----</span><br><span class=\"line\">略</span><br><span class=\"line\">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>\n<p><code>-----BEGIN RSA PRIVATE KEY-----</code> 和 <code>-----END RSA PRIVATE KEY-----</code> 为分割符号，表示在这两个中间存的是私钥的base64编码</p>\n<p>备注：CERTIFICATE 单词代表证书的意思；PRIVATE KEY 单词代表 私钥、秘钥的意思。</p>\n<h4 id=\"ssl证书配置\">SSL证书配置</h4>\n<p>以下以“阿里云OSS\"及“腾讯云COS”的对象存储（bucket）与域名（name）绑定过程中，对SSL证书的配置为例，进行解释和说明，不对详细步骤进行描述，仅解释原理。</p>\n<h5 id=\"域名及bucket绑定\">域名及Bucket绑定</h5>\n<p>阿里云及腾讯云都可以申请对象存储和域名，所申请的域名按正规流程均需要经过挂载至某个服务器进行备案（国内公安要求）后才可以与对象存储绑定，进而颁发证书给挂载至对象存储的域名。</p>\n<h5 id=\"ssl证书申请及配置\">SSL证书申请及配置</h5>\n<p>若域名互相绑定后未配置SSL则会导致https访问失败，配置SSL需要给自己的域名申请免费SSL证书，阿里云及腾讯云都可以免费申请为期一年的证书，按流程填写信息并等待审核下发即可；获得证书后需要选择“其他”类型的证书进行下载。证书中需要的 <strong>公钥</strong> 即 <code>.pem</code> 格式文件，而 <strong>私钥</strong> 即 <code>.key</code> 格式文件，分别填写到Bucket的域名管理页面内下的 <strong>证书上传</strong> 中。</p>\n<p>流程大致如下：</p>\n<pre class=\"mermaid\">graph LR\n    开始 --> Bucket申请--可选CDN加速开启--> 获得Bucket域名或CDN加速域名 --CNAME解析-->域名绑定-->结束\n    开始 --> 域名申请 --> 域名备案 --CNAME解析--> 域名绑定\n    域名申请 --> SSL证书申请 --> 下载证书 --复制粘贴至Bucket的域名管理页面--> 证书上传--> 结束</pre>\n<h3 id=\"ddos\">DDos</h3>\n<h4 id=\"常见流量攻击\">常见流量攻击</h4>\n<h5 id=\"syn-flood\">SYN Flood</h5>\n<p>Flood即洪水之意，SYN是指TCP通信中用于建立连接时标志位之一。</p>\n<p>此时需要用到 TCP Three-way Handshake的知识点，当需要建立连接时：</p>\n<ul>\n<li>Client向Server <mark>发去SYN标志</mark></li>\n<li>Server收到后向Client <mark>回复SYN和ACK标志</mark></li>\n<li>Client收到由Server发过来的SYN和ACK后 <mark>回复一个ACK标志</mark></li>\n</ul>\n<p>以上即为三次握手协议的主要流程，其实只有Server收到该ACK时，才标志着双方建立连接。以下介绍几种”意外“情况。</p>\n<p><strong>情况一：</strong>当Client第一次收到SYN和ACK时，Client就单方面“认为”自己已经和Server建立连接了。但网络通信时并不能百分百保证可靠，假如Client发了ACK，但Server并未收到，则Server就并不”认为“自己与Client建立了连接。Server和Client都有自己的定时器，在发送数据之后就开始计时，不管如何，此时Client都已经发了ACK了，“觉得”自己已经建立了连接，而Server不然，Server就会再次发送SYN和ACK以请求Client的确认。</p>\n<p><strong>情况二：</strong>多个Client向Server同时发送SYN请求，Server收到信息后立即回复SYN和ACK，并且需要为每一个Client设立一个计时器以等待他们的ACK信息。假如此刻Client的数量非常多且每一个都发送了一次SYN请求，则Server的计时器则会立刻被用光，导致任何正常请求都无法连接。（针对此种攻击方式，提出了二次SYN当成一次SYN的防攻击手段，即Client需要连续发两次SYN在标明自己是真的“有意”连接，不是恶意发送攻击的，但此类二次验证方式比较简单，仍然容易被模仿）</p>\n<h5 id=\"icmp-flood\">ICMP Flood</h5>\n<p>ICMP也算是网络层协议的一员，封装在IP协议中，是IP协议的附属协议，可以直接被用户进程直接使用。</p>\n<p>此处的ICMP Flood指的是利用集群设备在同一时间使用 ping 功能对目标主机发起请求，强制主机进行回复，致使目标主机瘫痪。</p>\n<p>以下为ping的英文解释</p>\n<blockquote>\n<p><em>PING - Send ICMP ECHO_REQUEST to network hosts</em></p>\n<p><em>Ping uses the ICMP protocol's mandatory ECHO_REQUEST datagram to elicit an ICMP ECHO_RESPONSE from a host or gateway.</em></p>\n<p>—— from 'manual of ping' in linux</p>\n</blockquote>\n<h3 id=\"选择数据库服务器的五个原则\">选择数据库服务器的五个原则</h3>\n<h4 id=\"高性能原则\">　　1)高性能原则</h4>\n<p>保证所选购的服务器，不仅能够满足运营系统的运行和业务处理的需要，而且能够满足一定时期业务量的增长。一般可以根据经验公式计算出所需的服务器TpmC值(Tpmc是衡量计算机系统的事务处理能力的程序)，然后比较各服务器厂商和TPC组织公布的TpmC值，选择相应的机型。同时，用服务器的市场价/报价除去计算出来的TpmC值得出单位TpmC值的价格，进而选择高性能价格比的服务器。</p>\n<p><strong>结论：</strong>服务器处理器性能很关键，CPU的主频要高，要有较大的缓存</p>\n<h4 id=\"可靠性原则\">　　2)可靠性原则</h4>\n<p>可靠性原则是所有选择设备和系统中首要考虑的，尤其是在大型的、有大量处理要求的、需要长期运行的系统上。考虑服务器系统的可靠性，不仅要考虑服务器单个节点的可靠性或稳定性，而且要考虑服务器与相关辅助系统之间连接的整体可靠性，如：网络系统、安全系统、远程打印系统等。在必要时，还应考虑对关键服务器采用集群技术，如：双机热备份或集群并行访问技术，甚至采用可能的完全容错机。</p>\n<p><strong>结论：</strong>服务器要具备冗余技术，同时像硬盘、网卡、内存、电源此类设备要以稳定耐用为主，性能其次。</p>\n<h4 id=\"可扩展性原则\">　　3)可扩展性原则</h4>\n<p>保证所选购的服务器具有优秀的可扩展性原则。因为服务器是所有系统处理的核心，要求具有大数据吞吐速率，包括：I/O速率和网络通讯速率，而且服务器需要能够处理一定时期的业务发展所带来的数据量，需要服务器能够在相应时间对其自身根据业务发展的需要进行相应的升级，如：CPU型号升级、内存扩大、硬盘扩大、更换网卡、增加终端数目、挂接磁盘阵列或与其他服务器组成对集中数据的并发访问的集群系统等。这都需要所选购的服务器在整体上具有一个良好的可扩充余地。一般数据库和计费应用服务器在大型计费系统的设计中就会采用集群方式来增加可靠性，其中挂接的磁盘存储系统，根据数据量和投资考虑，可以采用DAS、NAS或SAN等实现技术。</p>\n<p><strong>结论：</strong>服务器的IO要高，否则在CPU和内存都是高性能的情况下，会出现瓶颈。除此之外，服务器的扩展性要好，为的是满足企业在日后发展的需要。</p>\n<h4 id=\"安全性原则\">　　4)安全性原则</h4>\n<p>服务器处理的大都是相关系统的核心数据，其上存放和运行着关键的交易和重要的数据。这些交易和数据对于拥有者来说是一笔重要的资产，他们的安全性就非常敏感。服务器的安全性与系统的整体安全性密不可分，如：网络系统的安全、数据加密、密码体制等。服务器需要在其自身，包括软硬件，都应该从安全的角度上设计考虑，在借助于外界的安全设施保障下，更要保证本身的高安全性。</p>\n<p><strong>结论：</strong>首先从服务器的材料上来说要具备高硬度高防护性等条件，其次服务器的冷却系统和对环境的适应能力要强，这样才能够在硬件上满足服务器安全的要求。</p>\n<h4 id=\"可管理性原则\">　　5)可管理性原则</h4>\n<p>服务器既是核心又是系统整体中的一个节点部分，就像网络系统需要进行管理维护一样，也需要对服务器进行有效的管理。这需要服务器的软硬件对标准的管理系统支持，尤其是其上的操作系统，也包括一些重要的系统部件。</p>\n<p><strong>结论：</strong>尽量选择支持系统多的服务器，因为服务器兼容的系统越多，你就可以拥有更大选择空间。</p>\n<p><strong>总结：</strong>首先数据库服务器的性能要求很高，所以在CPU，内存，以及硬盘等方面都有很高的要求，其次是存储，存储要具备良好的稳定性，来满足长期运作的服务器随时读取写入等操作不会出现错误。最后希望通过总结的以上五点，帮助你挑选你所需要的数据库服务器。</p>\n<h3 id=\"服务器产品结构\">服务器产品结构</h3>\n<p>U是厚度要求，是一种表示服务器外部尺寸的单位，是unit的缩略语，详细的尺寸由作为业界团体的美国电子工业协会（EIA）所决定。 <code>1U=4.445cm</code> ， 1U至7U的产品结构是指外形满足EIA规格、厚度为4.445cm-31.115cm的服务器。</p>\n<p>多少U是指服务器的尺寸大小。在专业机房，托管的服务器一般是放在机柜里面的，机柜从上到下有很多单位格，我们叫一格为1U(U是unit的意思)。如果一个机柜是42U高，如果每2个服务器中间留1U空间，那么可以放21个1U的主机。同样情况放2U主机就只能放14台了。</p>\n<p>很多机房托管费用会按所占U的多少来收费的。</p>\n<h3 id=\"nat\">NAT</h3>\n<p>NAT（Network Address Translation，网络地址转换）是1994年提出的。</p>\n<p>当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。 这种方法需要在专用网（私网IP）连接到因特网（公网IP）的路由器上 <mark>安装NAT软件</mark> 。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址（公网IP地址）。</p>\n<p>这样，所有使用本地地址（私网IP地址）的主机在和外界通信时，都要在 <strong>NAT路由器</strong> 上将其本地地址转换成全球IP地址，才能和因特网连接。 另外，这种通过使用少量的全球IP地址（公网IP地址）代表较多的私有IP地址的方式，将有助于减缓可用的IP地址空间的枯竭。在RFC 2663中有对NAT的说明。</p>\n<p><strong>举例</strong>：</p>\n<blockquote>\n<p>在内网下 <code>192.168.0.100</code> 这台电脑上开了一个http网站服务，那么端口默认是 <code>80</code>，在内网下你直接通过浏览器输入 <code>http://192.168.0.100</code> 直接打开网站，这个内网链接地址在外是打不开的。 通过内网穿透后平台 <strong>分配</strong> 一个公网地址（给内网的设备）,比如 <code>http://test123k.nat.nsloop.com</code> 用户在外时就可以通过这个公网地址打开网站。</p>\n</blockquote>\n<p>要使用内网穿透服务，需要先确定好 <mark>内网要映射的IP和端口</mark> ，穿透成功后内网的IP+端口，映射成为公网的域名+端口（如需要IP，可以在CMD命令下PING 服务器的IP地址） 穿透前: 访问IP地址 <code>192.168.0.100</code> 端口 <code>3389</code> 穿透后：访问地址 <code>s0.nsloop.com</code> 端口 <code>12843</code> 。</p>\n<p>内网穿透是通过服务器中继转发数据来实现的将内网端口映射到公网，速度上没有P2P直连的快。</p>\n<h3 id=\"异地组网\">异地组网</h3>\n<h3 id=\"内网穿透\">内网穿透</h3>\n<p>内网穿透（Intranet penetration），也即 NAT 穿透，进行 NAT 穿透是为了使具有某一个特定源 IP 地址和源端口号的数据包 <mark>不被 NAT 设备屏蔽而正确路由到内网主机</mark> 。</p>\n<p>UDP 内网穿透的实质是利用路由器上的NAT 系统。NAT 是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型 Internet 接入方式和各种类型的网络中。<mark>NAT可以完成重用地址，并且对于内部的网络结构可以实现对外隐蔽</mark>。</p>\n","categories":["Networking"],"tags":["Web","CDN","Aliyun"]},{"title":"群晖、腾讯云和公网IP设置","url":"/2021/11/12/Networking/2021-11-12-%E7%BE%A4%E6%99%96%E3%80%81%E8%85%BE%E8%AE%AF%E4%BA%91%E5%92%8C%E5%85%AC%E7%BD%91IP%E8%AE%BE%E7%BD%AE/","content":"<p>双十一豪豪酱买了群晖DS220j家用NAS服务器，为了方便工作文件的备份传输，让电脑（PC、Mac）能用上远程网络驱动，就需要让服务器穿透内网，并申请一个独立域名，想着就用腾讯云和家里的小米路由器AX3600来干吧。下方是对硬件上需要的一些要求：</p>\n<p><strong>光猫</strong>：使用 <strong>桥接模式</strong>，具有 <strong>独立公网IP</strong></p>\n<p><strong>路由器</strong>：使用 <strong>PPPoE模式</strong> 进行拨号、支持 <strong>端口映射</strong>、 <strong>端口转发</strong> 和 <strong>DMZ</strong></p>\n<p><strong>群晖NAS</strong>：支持 <strong>DDNS</strong>、<strong>UPnP</strong> 协议、支持 <strong>证书使用范围管理</strong></p>\n<h1 id=\"前期准备工作\">前期准备工作</h1>\n<h2 id=\"更改工作模式\">更改工作模式</h2>\n<p><strong>光猫</strong> 和 <strong>路由器</strong> 都支持 <strong>路由模式</strong> 和 <strong>桥接模式</strong>，都支持多个无线接入和有线接入，但因为自己购买的路由器具有更多不一样的功能，例如支持UPnP等，而且光猫是连接物理光纤进行上网的，而自己购买的路由器不能直接连接光纤上网，还得依赖于光猫，所以可以认为是两种不一样的工作硬件。</p>\n<p>如果光猫已经工作在桥接模式（通过查看路由器后台的 <strong>上网方式</strong> 是否为PPPoE，如果是则说明自己购买的路由器工作在路由模式，电信光猫工作在桥接模式）。一般没有此类服务器需求的家庭网络，都是让光猫工作在路由拨号模式（即路由模式）的，而路由器则工作在桥接模式，此情况则需要将两个硬件设备的工作模式进行互换，参考以下步骤：</p>\n<ol type=\"1\">\n<li>打电话给电信营业厅 <code>(0000)10000</code> （前方的 <code>(0000)</code> 是自己的市区号），确认一下光猫是路由模式还是桥接模式，如果是路由模式，则将其改成桥接模式。</li>\n<li>确认改成桥接模式后，询问宽带的账户和密码，在路由器后台输入账户密码并连接测试，确保路由器工作在拨号模式，而光猫工作在桥接模式。</li>\n</ol>\n<blockquote>\n<p>目前国内家庭宽带都是默认内网IP，想要公网IP就只能向运营商申请了，这并不需要额外的收费。电信手上的IP资源最多，也最大方。我也是照着别人的说法，打电话给电信客服，说装监控需要公网IP，客服登记之后，过几个小时就打电话说已经换好了，干净利落，服务好。目前好像还没见到过电信要不到公网IP的情况。</p>\n<p>——《<a href=\"https://post.smzdm.com/p/awxqqwkg/\">BT下载教程 篇一：BT下载大提速！ 获取公网IP和端口映射转发简单教程</a> 》</p>\n</blockquote>\n<figure>\n<img src=\"https://pic.islet.space/2021/11/202111130020050.png\" alt=\"image-20211113000614809\" /><figcaption aria-hidden=\"true\">image-20211113000614809</figcaption>\n</figure>\n<h2 id=\"多重nat改成公网ip\">多重NAT改成公网IP</h2>\n<p>同样是打给电信，然后申请公网IP，电信客服专员一般会在一个小时内处理完毕，然后就可以得到公网IP了。</p>\n<p>“谁拨号，谁就有公网IP” ——即此时如果路由器已经成功设置了路由模式（使用PPPoE拨号上网），则可以在路由器后台查看到其公网IP地址，如：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/11/202111130020200.png\" alt=\"image-20211113001927548\" /><figcaption aria-hidden=\"true\">image-20211113001927548</figcaption>\n</figure>\n<h2 id=\"ddns域名绑定\">DDNS域名绑定</h2>\n<p>虽然已经获得公网IP，但是该IP还是会随机变动，还会需要使用DDNS服务将公网IP映射到对应域名上，而群辉服务器则提供此功能，此处需要自己申请一个域名（此步骤省略）。进入群辉服务器后台，开启DDNS功能，将域名和随机公网IP绑定和更新。</p>\n<p>另外，需要自己上所用的服务器上开启API Token，并提供给群辉DDNS服务（类似于授权，可以由DDNS服务自己检测家庭网络的公网IP，并自动绑定最新的公网IP）。</p>\n<h3 id=\"api-token申请\">API Token申请</h3>\n<p>下方以腾讯云的DNSPOD为例，点击DNSPOD中的 <strong>API密钥</strong>，进行 <strong>新建密钥</strong> 即可，将对应的 <strong>SecretId</strong> 和 <strong>SecretKey</strong> 复制下来。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/11/202111130022335.png\" alt=\"image-20211113002208036\" /><figcaption aria-hidden=\"true\">image-20211113002208036</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/11/202111130022186.png\" alt=\"image-20211113001142315\" /><figcaption aria-hidden=\"true\">image-20211113001142315</figcaption>\n</figure>\n<h3 id=\"ddns添加\">DDNS添加</h3>\n<p>将获取到的 <strong>SecretId</strong> 填写到 <strong>用户名/电子邮件</strong> 中， 将 <strong>SecretKey</strong> 填写到 <strong>密码/密钥</strong> 中。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/11/202111130022727.png\" alt=\"image-20211113001623814\" /><figcaption aria-hidden=\"true\">image-20211113001623814</figcaption>\n</figure>\n<p>经过前面的步骤，可以看到群晖NAS服务器自动测试的 <strong>DDNS状态</strong> 为 <strong>正常</strong> 即可。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/11/202111130022986.png\" alt=\"image-20211112175853513\" /><figcaption aria-hidden=\"true\">image-20211112175853513</figcaption>\n</figure>\n<h2 id=\"端口映射和转发\">端口映射和转发</h2>\n<p><strong>端口映射</strong>：Port Mapping， 即将内网中的主机的一个端口映射到外网主机的一个端口，以提供相应的服务。当用户访问外网IP的这个端口时，服务器自动将请求映射到对应局域网内部的机器上。</p>\n<p><strong>端口转发</strong>：Port Forwarding， 即将外网对应 EA 端口上收到的数据转发到内网某个主机对应的某个 IA 端口上，或者反过来将内网某个主机 IB 端口的数据转发到对应外网的 EB端口 上。</p>\n<p><strong>UPnP协议</strong>：Universal Plug and Play，即 即插即用。主要是微软在推行的一个标准，适用于家庭网络，用于设备间的发现和连接。UPnP 最大的愿景就是希望实现任何设备只要一接入网络就能被网络中的所有其它设备发现，做到完全的即插即用。UPnP是一个多层协议构成的框架体系，每一层都以相邻的下层为基础，同时又是相邻上层的基础。直至达到应用层为止。</p>\n<h3 id=\"手动端口转发或自动端口转发\">手动端口转发或自动端口转发</h3>\n<p>手动端口转发：</p>\n<p>自动端口转发：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/11/202111130022401.png\" alt=\"image-20211112180357037\" /><figcaption aria-hidden=\"true\">image-20211112180357037</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/11/202111211632483.png\" alt=\"image-20211112175632036\" /><figcaption aria-hidden=\"true\">image-20211112175632036</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/11/202111130022536.png\" alt=\"image-20211112180450097\" /><figcaption aria-hidden=\"true\">image-20211112180450097</figcaption>\n</figure>\n<h2 id=\"配置dmz\">配置DMZ</h2>\n<blockquote>\n<p>通过配置DMZ，我们可以将需要保护的Web应用程序服务器和数据库系统放在内网中，把没有包含敏感数据、担当代理数据访问职责的主机放置于DMZ中，这样就为应用系统安全提供了保障。</p>\n<p>DMZ使包含重要数据的内部系统免于直接暴露给外部网络而受到攻击，攻击者即使初步入侵成功，还要面临DMZ设置的新的障碍。</p>\n</blockquote>\n<figure>\n<img src=\"https://pic.islet.space/2021/11/202111130022178.png\" alt=\"image-20211112172411026\" /><figcaption aria-hidden=\"true\">image-20211112172411026</figcaption>\n</figure>\n<h3 id=\"dmz开启前\">DMZ开启前</h3>\n<figure>\n<img src=\"https://pic.islet.space/2021/11/202111130022255.png\" alt=\"image-20211112172343953\" /><figcaption aria-hidden=\"true\">image-20211112172343953</figcaption>\n</figure>\n<h3 id=\"dmz开启后\">DMZ开启后</h3>\n<p>虽然也是随机公网IP，但是可以使用DMZ将连接到路由器的设备映射到外网上。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/11/202111130022517.png\" alt=\"image-20211112175925384\" /><figcaption aria-hidden=\"true\">image-20211112175925384</figcaption>\n</figure>\n<h2 id=\"安全证书设置\">安全证书设置</h2>\n<p>设置安全证书及其使用范围，<mark style=\"font-weight: 900;\">不要使用自我签名的证书，所有浏览器都会识别和阻止你访问的</mark>。</p>\n<p>经过前面DDNS的 API token 配置之后，群晖NAS能够获取到对应域名的免费证书，并提供页面进行管理，将所有使用到的应用安全验证证书都设置为对应云服务提供商提供的证书即可。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/11/202111130022177.png\" alt=\"image-20211112180133874\" /><figcaption aria-hidden=\"true\">image-20211112180133874</figcaption>\n</figure>\n<h1 id=\"后台服务器访问\">后台服务器访问</h1>\n<p>经过上面复杂的折腾之后，就可以使用自定义的域名进行后台登录和管理了。</p>\n<p>输入 <code>https://nax.xxx.xxx:5000</code> 即可进行后台服务器的访问，也可以使用 ping 进行测试，如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/11/202111130029734.png\" alt=\"image-20211113002928045\" /><figcaption aria-hidden=\"true\">image-20211113002928045</figcaption>\n</figure>\n<h1 id=\"远程驱动器设置\">远程驱动器设置</h1>\n<ol type=\"1\">\n<li>在文件管理器中右键点击 <strong>此电脑</strong> 的属性</li>\n<li>然后点击 <strong>映射网络驱动器</strong></li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/11/202111130022518.png\" alt=\"image-20211112174837538\" /><figcaption aria-hidden=\"true\">image-20211112174837538</figcaption>\n</figure>\n<ol start=\"3\" type=\"1\">\n<li>选择本地的 <strong>虚拟驱动号</strong> 进行设置</li>\n<li>输入 <strong>网络地址</strong> 和 <strong>端口号</strong>，格式如 <code>https://nas.xxx.xxx:5006</code></li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/11/202111130022793.png\" alt=\"image-20211112175022321\" /><figcaption aria-hidden=\"true\">image-20211112175022321</figcaption>\n</figure>\n<ol start=\"5\" type=\"1\">\n<li>按照提示输入群晖提供的账户名和密码即可进行连接</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/11/202111130022607.png\" alt=\"image-20211112174513370\" /><figcaption aria-hidden=\"true\">image-20211112174513370</figcaption>\n</figure>\n<ol start=\"6\" type=\"1\">\n<li>连接完毕即可查看到对应的网络驱动器</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/11/202111130022504.png\" alt=\"image-20211112174559989\" /><figcaption aria-hidden=\"true\">image-20211112174559989</figcaption>\n</figure>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li><a href=\"https://zhuanlan.zhihu.com/p/75648110\">【干货】什么是端口转发？什么是端口映射？如何设置端口映射？</a></li>\n<li><a href=\"https://baike.baidu.com/item/DMZ/631225#6\">DMZ</a></li>\n<li><a href=\"https://blog.csdn.net/braddoris/article/details/41646789\">upnp协议简介（一）</a></li>\n</ol>\n","categories":["Networking"],"tags":["群晖"]},{"title":"TCP/IP专有名词","url":"/2019/01/07/Networking/%E7%BD%91%E7%BB%9C%20-%20TCP-IP%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D/","content":"<h1 id=\"dhcp\">DHCP</h1>\n<p>Dynamic Host Configuration Protocol, 动态主机设置协议, 是一个局域网的网络协议，使用UDP协议工作，主要有两个用途： 1. 用于内部网或网络服务供应商自动分配IP地址给用户 2. 用于内部网管理员作为对所有计算机作中央管理的手段</p>\n<h1 id=\"tcpip-stack-library-lwip\">TCP/IP Stack Library (LwIP)</h1>\n<p>LwIP是瑞典计算机科学院的一个开源的TCP/IP协议栈实现。</p>\n<p>LwIP协议栈主要关注的是怎么样减少内存的使用和代码的大小，这样就可以让lwIP适用于资源有限的小型平台例如嵌入式系统。为了简化处理过程和内存要求，lwIP对API进行了裁减，可以不需要复制一些数据。</p>\n<p>lwIP是TCP / IP协议套件的一个小型独立实现，最初由Adam Dunkels开发，现在继续在这里。</p>\n<p>lwIP TCP / IP实现的重点是减少资源使用，同时仍然具有全面的TCP。这使得lwIP适用于具有数十千字节空闲RAM的嵌入式系统，并且可以容纳大约40千字节的代码ROM。</p>\n<h2 id=\"lwip主要功能\">lwIP主要功能</h2>\n<h3 id=\"协议\">协议</h3>\n<p>IP，IPv6，ICMP，ND，MLD，UDP，TCP，IGMP，ARP，PPPoS，PPPoE</p>\n<h3 id=\"客户端\">客户端</h3>\n<p>DHCP客户端 DNS客户端（包括mDNS主机名解析器），AutoIP / APIPA（Zeroconf），SNMP agent（v1，v2c，v3，私有MIB支持和MIB编译器）</p>\n<h3 id=\"api\">API</h3>\n<p>用于增强性能的专用API，可选的Berkeley-socket套接字API</p>\n<h3 id=\"扩展功能\">扩展功能</h3>\n<p>通过多个网络接口进行IP转发，TCP拥塞控制，RTT估计和快速恢复/ fast retransmit</p>\n<h3 id=\"addon应用程序\">Addon应用程序</h3>\n<p>HTTP(S)服务器，SNTP客户端，SMTP(S)客户端，ping，NetBIOS名称服务器，mDNS响应器，MQTT客户端，TFTP服务器</p>\n<p>lwIP根据BSD风格许可证授权：<a href=\"http://lwip.wikia.com/wiki/License\" class=\"uri\">http://lwip.wikia.com/wiki/License</a></p>\n<h1 id=\"ttl\">TTL</h1>\n<p>TTL(Time- To-Live)，简单的说它表示一条域名解析记录在DNS服务器上缓存时间.当各地的DNS服务器接受到解析请求时，就会向域名指定的DNS服务器发出解析请求从而获得解析记录；在获得这个记录之后，记录会在DNS服务器中保存一段时间，这段时间内如果再接到这个域名的解析请求，DNS服务器将不再向DNS服务器发出请求，而是直接返回刚才获得的记录；而这个记录在DNS服务器上保留的时间，就是TTL值。</p>\n<h1 id=\"参考链接\">参考链接</h1>\n<p>1.《<a href=\"https://zh.wikipedia.org/wiki/LwIP\">lwIP</a>》 2.《<a href=\"https://savannah.nongnu.org/projects/lwip/\">lwIP - A Lightweight TCP/IP stack - Summary</a>》 3.《<a href=\"https://blog.csdn.net/ysdaniel/article/details/6922097\">TTL值的含义以及与域名DNS TTL值的区别</a>》</p>\n","categories":["Communication"],"tags":["Terminology","TCP/IP"]},{"title":"利用云服务器搭建MQTT服务","url":"/2019/01/06/Networking/%E7%BD%91%E7%BB%9C%20-%20%E5%88%A9%E7%94%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAMQTT%E6%9C%8D%E5%8A%A1/","content":"<p>MQTT全称Message Queue Telemetry Transport，是一个针对轻量级的发布/订阅式消息传输场景的协议，同时也是被推崇的物联网传输协议。 MQTT：<a href=\"http://mqtt.org\" class=\"uri\">http://mqtt.org</a></p>\n<p>在以Linux为内核的服务器上，可以有很多种方法来搭建MQTT服务，如Apache Apollo、Emqttd和Eclipse Mosquitto等等。 本文以将在阿里云Ubuntu云服务器上，创建专门用作MQTT服务器的账户，然后安装、开启并测试Mosquitto。</p>\n<h1 id=\"mqtt服务官网\">1. MQTT服务（官网）：</h1>\n<p>Apache Apollo：<a href=\"http://activemq.apache.org/apollo/\" class=\"uri\">http://activemq.apache.org/apollo/</a> EMQTTD：<a href=\"http://emqttd.com\" class=\"uri\">http://emqttd.com</a> Eclipse Mosquitto: <a href=\"http://mosquitto.org\" class=\"uri\">http://mosquitto.org</a></p>\n<h1 id=\"准备工作\">2. 准备工作</h1>\n<h2 id=\"创建新用户\">2.1 创建新用户</h2>\n<p>创建新用户是为了防止用户账户及密码泄露造成服务器root账号的信息安全及管理问题，因此很有必要单独创建一个用于MQTT服务的账户。 请在Terminal输入以下命令，XXXXX为你要新建的用户名称。 <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"安装mosquitto\">2.2 安装Mosquitto</h2>\n<h1 id=\"测试mqtt\">3. 测试MQTT</h1>\n<h2 id=\"电脑客户端安装\">3.1 电脑客户端安装</h2>\n<p><a href=\"https://mqttfx.jensd.de/index.php/download\">MQTT.fx</a> ## 3.2 测试 ### 3.2.1 登录 在两台连接到不同IP的设备上（这里要求这两台设备不会连接到同一个网段，包括同一个WiFi）分别填写MQTT服务器的信息，包括： * 服务器的IP（或绑定了IP的域名） * 端口号（物联网用的MQTT端口号默认为：1883） * 用户名 * 密码 * 作为订阅者/发布者的昵称（大致是这个意思）</p>\n<h3 id=\"主题订阅及收信\">3.2.2 主题订阅及收信</h3>\n<p>在其中一台设备上填写订阅信息的主题名称，填写好后点Subscribe按钮。 在另一台设备上，填写发布信息的主题名称，填写好后在文本发送框填写发布内容并点击Publish按钮。</p>\n<p>然后就可以欢快地在两台设备上发布和接收信息了，测试结束。</p>\n<h1 id=\"参考链接\">参考链接</h1>\n<ol type=\"1\">\n<li>《<a href=\"https://blog.csdn.net/yannanxiu/article/details/70504586\">【MQTT】在Ubuntu下搭建MQTT服务器</a>》</li>\n<li>《<a href=\"http://mc.dfrobot.com.cn/forum.php?mod=viewthread&amp;tid=27276\">micropython之动手搭建自己的MQTT服务器并实现通信（点亮led）</a>》</li>\n<li>《<a href=\"https://www.howtoing.com/how-to-install-and-secure-the-mosquitto-mqtt-messaging-broker-on-ubuntu-16-04\">如何在Ubuntu 16.04上安装和保护Mosquitto MQTT消息传递代理</a>》</li>\n<li>《<a href=\"https://blog.csdn.net/lele52141/article/details/6593840\">ubuntu用户添加adduser, useradd</a>》</li>\n</ol>\n","categories":["Communication"],"tags":["Hardwares","MQTT","Server"]},{"title":"专利撰写及经验","url":"/2019/04/19/Others/2019-04-19-%E4%B8%93%E5%88%A9%E6%92%B0%E5%86%99%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%BB%8F%E9%AA%8C/","content":"<h1 id=\"专利基础\">专利基础</h1>\n<h2 id=\"专利概述\">专利概述</h2>\n<ol type=\"1\">\n<li>专利的特点、作用</li>\n<li>我国专利制度概述</li>\n<li>专利基础知识点</li>\n</ol>\n<h3 id=\"知识产权分类\">知识产权分类</h3>\n<p>知识产权分为 <strong>工业产却</strong> 与 <strong>著作权</strong> 两大类，而工业产权又分为 <strong>专利</strong> 、<strong>商标</strong> 等。其中，专利分为 <strong>发明专利</strong> 、 <strong>实用新型专利</strong> 及 <strong>外观设计专利</strong> 三类。</p>\n<pre class=\"mermaid\">graph LR\n    知识产权 --> 工业产权 --> 专利\n    工业产权 --> 商标\n    工业产权 --> 集成电路布图设计\n    工业产权 --> 植物新品种\n    知识产权 --> 著作权\n    专利 --> 发明专利\n    专利 --> 实用新型专利\n    专利 --> 外观设计专利</pre>\n<h3 id=\"知识产权特点\">知识产权特点</h3>\n<ul>\n<li>无形性：客体无形、载体有形</li>\n<li>独占性：专属于权利人，经其同意或法律规定外，任何人不得享有或行使该权利。</li>\n<li>时间性：法律对各项知识产权保护都有一定有效期。</li>\n<li>地域性：只在所确认和保护的地域内有效。除了签订有国际公约或双边互惠协定外，经一国法律所保护的某项权利只在该国范围内发生法律效力。</li>\n</ul>\n<h3 id=\"专利权\">专利权</h3>\n<ul>\n<li>发明创造的合法所有人依法对其发明享有的独占权。</li>\n<li>国家主管机关依法授予申请人（或发明人）的，在一定期限内禁止他人未经允许实施其专利的权利。</li>\n</ul>\n<h3 id=\"专利制度作用\">专利制度作用</h3>\n<ul>\n<li>鼓励发明创造，促进创新</li>\n<li>传播技术信息，推动发明创造的应用和推广</li>\n<li>促进科学进步和经济发展</li>\n<li>构建良好的竞争秩序，激励创新</li>\n<li>创建良好的投资环境，吸引投资和先进技术</li>\n</ul>\n<h3 id=\"专利制度宗旨\">专利制度宗旨</h3>\n<ul>\n<li>为了保护专利权人的合法权益</li>\n<li>鼓励发明创造</li>\n<li>推动发明创造的应用</li>\n<li>提高创新能力，促进科学技术进步和经济社会发展</li>\n</ul>\n<h3 id=\"专利保护\">专利保护</h3>\n<h4 id=\"专利相关法律\">专利相关法律</h4>\n<p>1984年3月12日，全国人大常委会表决通过专利法</p>\n<p>1985年04月01日，《中华人民共和国专利法》实施</p>\n<p>现今适用法律、法规：</p>\n<p>《专利法》 、《专利法实施细则》、 《专利审查指南》</p>\n<p>《专利法》的篇章结构 共8章 76条</p>\n<blockquote>\n<p>第一章 总则 21条； 第二章 授予专利权的条件 4条； 第三章 专利的申请 8条； 第四章 专利申请的审查和批准 8条； 第五章 专利权的期限、终止和无效 6条； 第六章 专利实施的强制许可 11条； 第七章 专利权的保护 16条； 第八章 附则 2条</p>\n</blockquote>\n<p>《专利法实施细则》作为专利法的配套行政法规，经国务院批准于1985年1月19日公布，1985年4月1日与专利法一同实施。 目前细则条文总共11章，123条。</p>\n<h4 id=\"专利保护的对象和期限\">专利保护的对象和期限</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>类型</th>\n<th>定义</th>\n<th>保护年限</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>发明</td>\n<td>对 <strong>产品、方法</strong> 或其改进提出的 <strong>新的技术方案</strong></td>\n<td>20</td>\n</tr>\n<tr class=\"even\">\n<td>实用新型</td>\n<td>对 <strong>产品的形状、构造</strong> 或者其结合提出的适于实用<strong>新的技术方案</strong></td>\n<td>10</td>\n</tr>\n<tr class=\"odd\">\n<td>外观设计</td>\n<td>对 <strong>产品的形状、图案</strong> 或者其 <strong>形状与图案的结合</strong>以及<strong>色彩与形状、图案的结合</strong>所作出富有美感的并适于工业应用<strong>新设计</strong></td>\n<td>10</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"专利审查\">专利审查</h3>\n<h4 id=\"专利审查机关\">专利审查机关</h4>\n<p><strong>国家知识产权局</strong> 统一受理和审查专利申请，依法授予专利权。</p>\n<p>涉及国防利益需要保密的专利申请，由 <strong>国防专利机构</strong> 受理并进行审查。</p>\n<h4 id=\"专利审查制度\">专利审查制度</h4>\n<p><strong>发明</strong> 专利采用 <strong>实审制</strong>（发明初审公布后，需经实质审查，审查其是否符合专利法的相关规定，发现没有驳回理由的，应当公告授予专利权）。其 <strong>正常流程</strong> 为，自申请日（有优先权的指优先权日）起18个月公布，申请日（有优先权的指优先权日）起3年内提实审。其<strong>加快流程</strong> 为，初审、公布、实审、授权，大概2-3个月公布，最快1年内授权。</p>\n<p><strong>实用新型</strong> 采用 <strong>初审制</strong>（初审合格即公告授权，不进行实质审查），最快需要3-4个月授权公告。</p>\n<p>外观设计采用 <strong>初审制</strong>。</p>\n<blockquote>\n<p>技术淘汰快的最好申请实用新型；技术淘汰慢的最好申请发明</p>\n</blockquote>\n<h3 id=\"专利权授予条件\">专利权授予条件</h3>\n<p>对于发明与实用新型专利，应当具 <strong>新颖性</strong> 、 <strong>创造性</strong> 及 <strong>实用性</strong> 三大条件。</p>\n<p><strong>新颖性</strong> 是指不属于现有技术，也没有抵触申请的新技术，即是否处在一样的技术，是否有区别。<strong>创造性</strong> 是指非显而易见性，即区别是否足够大。<strong>实用性</strong> 是指能够在制造和使用上产生积极效果。</p>\n<p>对 <strong>现有技术</strong> 的定义是：自申请日以前在国内外为公众所知的技术。包括出版物公开、使用公开、其他方式公开。</p>\n<blockquote>\n<p><em>授予专利权的发明和实用新型，应当具备新颖性、创造性和实用性。新颖性，是指该发明或者实用新型不属于现有技术；也没有任何单位或者个人就同样的发明或者实用新型在申请日以前向国务院专利行政部门提出过申请，并记载在申请日以后公布的专利申请文件或者公告的专利文件中。创造性，是指与现有技术相比，该发明具有突出的实质性特点和显著的进步，该实用新型具有实质性特点和进步。实用性，是指该发明或者实用新型能够制造或者使用，并且能够产生积极效果。本法所称现有技术，是指申请日以前在国内外为公众所知的技术。</em></p>\n<p>——《专利法》第22条</p>\n</blockquote>\n<p>现行专利法——绝对新颖性原则</p>\n<p>且以上专利授予条件 <mark>必须满足</mark> “不属于《专利法》第法5、9及25条等其他不授予的情况”。</p>\n<h3 id=\"专利权保护范围\">专利权保护范围</h3>\n<p><strong>发明/实用新型</strong> 专利权的保护范围以其 <strong>权利要求的内容为准</strong>，说明书及附图可以用于解释权利要。</p>\n<p><strong>外观设计</strong> 专利权的保护范围以表示在<strong>图片或者照片中的该产品的外观设计为准</strong>，简单说明可以用于解释图片或者照片所表示的该产品的外观设计。</p>\n<h2 id=\"专利意识\">专利意识</h2>\n<p>统计显示，全世界90%以上的技术信息都将通过专利信息公开。充分利用专利信息，避免重复研发。</p>\n<p>专利布局工作能够使我们的研发成果得到全面的保护，避免竞争对手抄袭，通过专利手段提升我司产品的市场份额。</p>\n<p>侵权排查与无效规避是我们工作中不可逾越的红线，一旦越过红线，将导致我司产品无法上市，所有的研发心血付诸东流。</p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417091043022.png\" alt=\"image-20210417091043022\" style=\"zoom:50%;\" /></p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417091131935.png\" alt=\"image-20210417091131935\" style=\"zoom:50%;\" /></p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417091222349.png\" alt=\"image-20210417091222349\" style=\"zoom:50%;\" /></p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417091245709.png\" alt=\"image-20210417091245709\" style=\"zoom:50%;\" /></p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417091430726.png\" alt=\"image-20210417091430726\" style=\"zoom:50%;\" /></p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417091604437.png\" alt=\"image-20210417091604437\" style=\"zoom:50%;\" /></p>\n<h2 id=\"格力专利制度\">格力专利制度</h2>\n<ol type=\"1\">\n<li><p>我司专利团队架构</p></li>\n<li><p>我司知识产权管理办法</p></li>\n<li><p>我司知识产权相关活动</p></li>\n<li><p>我司知识产权荣誉</p></li>\n</ol>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417091758176.png\" alt=\"image-20210417091758176\" style=\"zoom:50%;\" /></p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417091832811.png\" alt=\"image-20210417091832811\" style=\"zoom:50%;\" /></p>\n<h3 id=\"专利管理办法\">专利管理办法</h3>\n<p>我司知识产权管理办法 QG0203.07-02</p>\n<p>我司专利管理办法 QG0203.06-03</p>\n<h4 id=\"职务发明\">职务发明</h4>\n<p>即 <strong>执行本单位的任务</strong> 或者主要是利用本单位的物质技术条件所完成的发明创造为职务发明创造。职务发明创造申请专利的权利属于该单位；申请被批准后，该单位为 <strong>专利权人</strong>。</p>\n<p>管理办法中对人员的定义如下：</p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417092038416.png\" alt=\"image-20210417092038416\" style=\"zoom: 33%;\" /></p>\n<p>“<strong>执行本公司的任务</strong>”完成的智力劳动成果定义：</p>\n<ul>\n<li><p>在本职工作中取得的智力劳动成果，即在执行科研计划（含补充计划和临时计划）课题和合同计划课题，完成计划创作任务和设计任务，实施技术改造工程或履行其他所在岗位职责的过程中所取得的智力劳动成果。包括但不限于公司所派的项目和各项目组自己提出的项目所产生的劳动成果。动</p></li>\n<li><p>履行本公司交付的本职工作之外的任务所取得的智力劳动成果。</p></li>\n<li><p>离休、退休、辞退或调离工作后一年内做出的与其在本公司承担的本职工作或本公司分配的任务有关的智力劳动成果。</p></li>\n</ul>\n<p>“<strong>利用公司物质技术条件</strong>”完成的智力劳动成果定义：</p>\n<p>利用本公司资金、设备、原材料、试验条件、场地或者不对外公开的技术资料、图纸及其说明、声像材料等等。</p>\n<p>“<strong>利用本公司的名义</strong>”定义：</p>\n<p>在经济技术合同中使用本公司名称。</p>\n<p>“<strong>享受本单位的待遇</strong>”定义：</p>\n<p>指自选课题、自筹资金、自立项目，但在工作时间内完成的智力劳动成果。</p>\n<h2 id=\"格力专利务实操作基础知识\">格力专利务实操作基础知识</h2>\n<ol type=\"1\">\n<li>我司专利申请流程</li>\n<li>我司知识产权管理系统操作方法</li>\n<li>我司一级专利评定及标准</li>\n<li>我司发明人及专利权人变更相关注意事项</li>\n</ol>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417092724954.png\" alt=\"image-20210417092724954\" style=\"zoom:50%;\" /></p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417092937790.png\" alt=\"image-20210417092937790\" style=\"zoom:50%;\" /></p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417093010187.png\" alt=\"image-20210417093010187\" style=\"zoom:50%;\" /></p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417093053523.png\" alt=\"image-20210417093053523\" style=\"zoom:50%;\" /></p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417094700862.png\" alt=\"image-20210417094700862\" style=\"zoom:67%;\" /></p>\n<h1 id=\"专利撰写准备\">专利撰写准备</h1>\n<h2 id=\"专利新创性\">专利新创性</h2>\n<p>据《专利法》二十二条第二款，<strong>新颖性：</strong></p>\n<p>是指该发明或者实用新型不属于<strong>现有技术</strong>；也没有任何单位或者个人就 <strong>同样的发明或者实用新型</strong>向国务院专利行政部门提出过申请，并且记载在<strong>申请日以后公布</strong>的专利申请文件中或者公告的专利文件中。</p>\n<p>据《专利法》二十二条第三款，<strong>创造性：</strong></p>\n<p>是指与现有技术相比，该发明具有<strong>突出的实质性特点</strong> 和 <strong>显著的进步</strong>，该实用新型有 <strong>实质性特点和进步</strong>。</p>\n<h3 id=\"抵触申请\">抵触申请</h3>\n<blockquote>\n<p><em>是指损害新颖性的专利申请。具体是指在申请日以前，任何单位或个人就同样的技术已向专利行政部门提出过申请，并且记载在申请日以后公布的专利申请文件或者公告的专利文件中，那么这一申请就被称之为 <mark>专利申请的抵触申请 </mark>。</em></p>\n<p>——百度百科</p>\n</blockquote>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417100345018.png\" alt=\"image-20210417100345018\" style=\"zoom:50%;\" /></p>\n<h3 id=\"审查原则\">审查原则</h3>\n<blockquote>\n<p>1、单独对比原则，即每项权利要求与单独一项现有技术（或抵触申</p>\n<p>请）进行对比。</p>\n<p>2、整体原则（四相同）：</p>\n<p>（1）技术方案（实质）相同；</p>\n<p>（2）能够适用相同的 <strong>技术领域</strong>、解决相同的 <strong>技术问题</strong>、并且具有相</p>\n<p>同的 <strong>预期效果</strong>。</p>\n<p>——《专利审查指南》</p>\n</blockquote>\n<p>从权利要求书上的每一条逐条与现有技术进行比对，此为 <strong>单独比对原则</strong>。</p>\n<p><strong>整体比对原则</strong> 是指从 <strong>技术方案（的实质）</strong>、 <strong>技术领域</strong> 、 <strong>技术问题</strong> 及 <strong>预期效果</strong> 上进行全方面比对。如果全都相同，则说明该专利方案不具有新颖性。</p>\n<h3 id=\"本领域技术人员要求\">本领域技术人员要求</h3>\n<ul>\n<li><strong>知晓</strong>申请日或者优先权日之前发明所属技术领域所有的普通技术知识；</li>\n<li>能够<strong>获知</strong>该领域中所有的现有技术；</li>\n<li>具有<strong>应用</strong>该日期之前常规实验手段的能力，但他<strong>不具有</strong>创造能力；</li>\n<li>如果所要解决的技术问题能够<strong>促使</strong>本领域的技术人员在其他技术领域寻找技术手段，他也应具有从该其他技术领域中获知该申请日或优先权日之前的相关现有技术、普通技术知识和常规实验手段的能力。</li>\n</ul>\n<h3 id=\"突出的实质性特点\">突出的实质性特点</h3>\n<p>突出的实质性特点，是指对所属技术领域的技术人员来说，发明相对于现有技术是 <mark>非显而易见</mark> 的。如果发明是所属技术领域的技术人员在现有技术的基础上仅仅通过合乎逻辑的分析、推理或者有限的试验可以得到的，则该发明是显而易见的，也就不具备突出的实质性特点</p>\n<p style=\"color: #CCC; font-weight: 100; font-style: italic;\">\n无论如何发明出来的专利一定是具有实用性的，也就是有用的，这种有用会体现在实际解决的技术问题上，对于某项发明解决的问题应该明确描述。\n</p>\n<p><strong>判断方法：</strong></p>\n<ol type=\"1\">\n<li>确定最接近的现有技术</li>\n<li>确定发明的区别技术特征和发明实际解决的技术问题</li>\n<li>判断要求保护的发明对本领域的技术人员来说是否显而易见</li>\n</ol>\n<h3 id=\"显著的进步\">显著的进步</h3>\n<p>发明有显著的进步，是指发明与现有技术相比能够产生有益的技术效果。</p>\n<ul>\n<li>发明与现有技术相比具有 <strong>更好的技术效果</strong>，例如，质量改善、产量提高、节约能源、防治环境污染等；</li>\n<li>发明提供了一种 <strong>技术构思不同的方案</strong>，其技术效果能够基本上达到现有技术的水平；</li>\n<li>发明代表某种 <strong>新技术发展趋势</strong>；</li>\n<li>尽管发明在某些方面有负面效果，但在其他方面具有 <strong>明显积极的技术效果</strong>。</li>\n</ul>\n<h3 id=\"发明的分类\">发明的分类</h3>\n<p><strong>开拓性发明</strong>，是指一种全新的技术方案，在技术史上未曾有过先例，它为人类科学技术在某个时期的发展开创了新纪元。开拓性发明同现有技术相比，具有突出的实质性特点和显著的进步，具备创造性。</p>\n<p><strong>组合发明</strong>，是指将某些技术方案进行组合，构成一项新的技术方案，以解决现有技术客观存在的技术问题。在进行组合发明创造性的判断时通常需要考虑：组合后的各技术特征在功能上是否彼此相互支持、组合的难易程度、现有技术中是否存在组合的启示以及组合后的技术效果等。</p>\n<p><strong>选择发明</strong>，是指从现有技术中公开的宽范围中，有目的地选出现有技术中未提到的窄范围或个体的发明。<u>在进行选择发明创造性的判断时，选择所带来的预料不到的技术效果是考虑的主要因素。</u></p>\n<blockquote>\n<ol type=\"1\">\n<li>如果发明仅是从一些已知的可能性中进行选择，或者发明仅仅是从一些具有相同可能性的技术方案中选出一种，而选出的方案未能取得预料不到的技术效果，则该发明不具备创造性。</li>\n<li>如果发明是在可能的、有限的范围内选择具体的尺寸、温度范围或者其他参数，而 这些选择可以由本领域的技术人员通过常规手段得到并且没有产生预料不到的技术效果， 则该发明不具备创造性。</li>\n<li>如果发明是可以从现有技术中直接推导出来的选择，则该发明不具备创造性。</li>\n<li>如果选择使得发明取得了预料不到的技术效果，则该发明具有突出的实质性特点和显著的进步，具备创造性。</li>\n</ol>\n</blockquote>\n<p><strong>转用发明</strong>，是指将某一技术领域的现有技术转用到其他技术领域中的发明。在进行转用发明的创造性判断时通常需要考虑：转用的技术领域的远近、是否存在相应的技术启示、转用的难易程度、是否需要克服技术上的困难、转用所带来的技术效果等</p>\n<blockquote>\n<ol type=\"1\">\n<li>如果转用是在类似的或者相近的技术领域之间进行的，并且未产生预料不到的技术效果，则这种转用发明不具备创造性。</li>\n<li>如果这种转用能够产生预料不到的技术效果，或者克服了原技术领域中未曾遇到的困难，则这种转用发明具有突出的实质性特点和显著的进步，具备创造性。</li>\n</ol>\n</blockquote>\n<p><strong>已知产品的新用途发明</strong>，是指将已知产品用于新的目的的发明。在进行已知产品新用途发明的创造性判断时通常需要考虑：新用途与现有用途技术领域的远近、新用途所带来的技术效果等。</p>\n<blockquote>\n<ol type=\"1\">\n<li>如果新的用途仅仅是使用了已知材料的已知的性质，则该用途发明不具备创造性。</li>\n<li>如果新的用途是利用了已知产品新发现的性质，并且产生了预料不到的技术效果，则这种用途发明具有突出的实质性特点和显著的进步，具备创造性。</li>\n</ol>\n</blockquote>\n<p><strong>要素变更的发明</strong>，包括 <strong>要素关系改变的发明</strong> 、 <strong>要素替代的发明</strong> 和 <strong>要素省略的发明</strong> 。在进行要素变更发明的创造性判断时通常需要考虑：要素关系的改变、要素替代和省略是否存在技术启示、其技术效果是否可以预料等。</p>\n<p><strong>要素关系改变的发明</strong>，是指发明与现有技术相比，其形状、尺寸、比例、位置及作用关系等发生了变化</p>\n<blockquote>\n<ol type=\"1\">\n<li>如果要素关系的改变没有导致发明效果、功能及用途的变化，或者发明效果、功能及用途的变化是可预料到的，则发明不具备创造性。</li>\n<li>如果要素关系的改变导致发明产生了预料不到的技术效果，则发明具有突出的实质性特点和显著的进步，具备创造性</li>\n</ol>\n</blockquote>\n<p><strong>要素替代的发明</strong>，是指已知产品或方法的某一要素由其他已知要素替代的发明。</p>\n<blockquote>\n<ol type=\"1\">\n<li>如果发明是相同功能的已知手段的等效替代，或者是为解决同一技术问题，用已知最新研制出的具有相同功能的材料替代公知产品中的相应材料，或者是用某一公知材料替代公知产品中的某材料，而这种公知材料的类似应用是已知的，且没有产生预料不到的技术效果，则该发明不具备创造性。</li>\n<li>如果要素的替代能使发明产生预料不到的技术效果，则该发明具有突出的实质性特点和显著的进步，具备创造性。</li>\n</ol>\n</blockquote>\n<p><strong>要素省略的发明</strong>，是指省去已知产品或者方法中的某一项或多项要素的发明。</p>\n<blockquote>\n<ol type=\"1\">\n<li>如果发明省去一项或多项要素后其功能也相应地消失，则该发明不具备创造性。</li>\n<li>如果发明与现有技术相比，发明省去一项或多项要素(例如，一项产品发明省去了一个或多个零、部件或者一项方法发明省去一步或多步工序) 后，依然保持原有的全部功能，或者带来预料不到的技术效果，则具有突出的实质性特点和显著的进步，该发明具备创造性。</li>\n</ol>\n</blockquote>\n<h2 id=\"专利文件\">专利文件</h2>\n<h3 id=\"专利文件结构\">专利文件结构</h3>\n<ol type=\"1\">\n<li><strong>著录项：</strong>包括：公开号、公告/公布日、申请号、申请日、专利权人/ 申请人、发明人、专利代理机构、代理人、分类号等。</li>\n<li><strong>摘要及摘要附图</strong></li>\n<li><strong>权利要求书</strong></li>\n<li><strong>说明书及说明书附图</strong></li>\n</ol>\n<ul>\n<li><strong>扉页</strong>：著录项、摘要、附图，快速获取信息</li>\n<li><strong>权利要求书</strong>：以说明书为依据，清楚限定专利保护范围</li>\n<li><strong>说明书</strong>：背景技术、发明内容、具体实施方式、附图</li>\n</ul>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417110814683.png\" alt=\"image-20210417110814683\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417110835219.png\" alt=\"image-20210417110835219\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417110846476.png\" alt=\"image-20210417110846476\" style=\"zoom:67%;\" /></p>\n<h3 id=\"专利文件阅读技巧\">专利文件阅读技巧</h3>\n<ul>\n<li>看技术方案，即 <strong>说明书</strong> 中的具体实施方式。</li>\n<li>看结构，即 <strong>说明书</strong> 附图。</li>\n<li>看保护范围，即 <strong>权利要求书</strong> 如何描述。</li>\n<li>看本发明有益效果，即 <strong>摘要</strong>。</li>\n<li>看本发明要解决的技术问题，即 <strong>说明书</strong> 背景技术部分及 <strong>发明内容</strong> 的第一段。</li>\n</ul>\n<h2 id=\"无效对比与分析\">无效对比与分析</h2>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417111224516.png\" alt=\"image-20210417111224516\" style=\"zoom:50%;\" /></p>\n<blockquote>\n<p><mark>无效宣告请求的理由，是指被授予专利的发明创造不符合专利法</mark>第二条、第二十条第一款、第二十二条、第二十三条、第二十六条第三款、第四款、第二十七条第二款、第三十三条或者本细则第二十条第二款、第四十三条第一款的规定，或者属于专利法第五条、第二十五条的规定，或者依照专利法第九条规定 <mark>(而)不能取得专利权</mark>。</p>\n</blockquote>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417111400147.png\" alt=\"image-20210417111400147\" style=\"zoom:50%;\" /></p>\n<h1 id=\"专利撰写实践\">专利撰写实践</h1>\n<h2 id=\"专利检索\">专利检索</h2>\n<ol type=\"1\">\n<li>基本知识</li>\n<li>检索方法</li>\n<li>检索技巧</li>\n<li>常用检索数据库</li>\n</ol>\n<h3 id=\"基本知识\">基本知识</h3>\n<p>指从用户特定的信息需求出发，对特定的信息集合采用一定的方法、 技术手段，根据一定的线索与规则从中找出相关信息。</p>\n<p><strong>专利检索</strong> 是根据一项或多项特征，从海量专利文献或专利数据库中挑选出符合某一特定要求的文献或信息的过程。</p>\n<h3 id=\"检索方法\">检索方法</h3>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419101550917.png\" alt=\"image-20210419101550917\" style=\"zoom:67%;\" /></p>\n<h3 id=\"检索技巧\">检索技巧</h3>\n<h3 id=\"常用检索数据库\">常用检索数据库</h3>\n<h2 id=\"专利提案书\">专利提案书</h2>\n<p>提案书是发明人将发明内容清晰、完整地传达给 <strong>专利管理员</strong>、<strong>代理人</strong> 的文书。而 <strong><em>清楚、完整</em></strong> 是指使用所属技术领域的技术术语，明确表达想做什么和如何 去做，使得所属技术领域的技术人员能够实现该方案。</p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417111740858.png\" alt=\"image-20210417111740858\" style=\"zoom: 50%;\" /></p>\n<h3 id=\"提案书架构\">提案书架构</h3>\n<ul>\n<li>发明创造名称</li>\n<li>背景技术</li>\n<li>解决的技术问题及有益效果</li>\n<li>发明点</li>\n<li>附图</li>\n<li>最优实施方式</li>\n</ul>\n<h4 id=\"发明创造名称\">发明创造名称</h4>\n<p>应清楚、简要、全面地反映要求保护的发明创造的主题和类型。一件专利申请 <mark><strong>可以同时包含产品和方法</strong></mark>，如《空调器除霜系统及除霜控制方法》</p>\n<p><em>其中，<strong>主题</strong> 是指专利所要求保护的技术内容，而 <strong>类型</strong> 是指要求保护的是产品还是方法</em></p>\n<p><strong>注意：</strong>避免使用“技术”、“设计”等笼统且抽象的术语。</p>\n<h5 id=\"错误示例\">错误示例</h5>\n<ul>\n<li>柜机新增缺氟保护功能</li>\n<li>空调主动降噪技术</li>\n<li>吸气管减振结构设计</li>\n<li>一种可以在导电材料面上实现的触摸检测技术</li>\n<li>智能功率模块的集成设计及结构实现</li>\n<li>一种提升PCB抗冲击的结构方案</li>\n</ul>\n<h5 id=\"正确示例\">正确示例</h5>\n<ul>\n<li>柜式空调器的缺氟保护方法</li>\n<li>空调器的主动降噪方法和降噪系统</li>\n<li>具有圆弧段减震结构的吸气管</li>\n<li>金属电容式触摸键盘</li>\n<li>集成PFC电路和逆变电路的智能功率模块</li>\n<li>一种具有缓冲部件的电器盒及电器盒组件</li>\n</ul>\n<h4 id=\"背景技术\">背景技术</h4>\n<h5 id=\"撰写原则\">撰写原则</h5>\n<ul>\n<li>应当系统、全面地介绍对本申请的理解和检索有用的现有技术。</li>\n<li>有相关专利文献(或科技文献)的，请 <strong>给出引证的专利号</strong>(或文献编号)。</li>\n<li>通过分析推理，说明现有技术中存在的问题和缺点（仅限于由本申请 的技术方案能解决的），其产生的原因和解决问题时曾遇到的困难</li>\n</ul>\n<h5 id=\"注意事项\">注意事项</h5>\n<ol type=\"1\">\n<li>（不能满足则被认为没有引证） 所引证的非专利文件和外国专利文件的公开日应当在本申 请的申请日之前；</li>\n<li>所引证的中国专利文件的公开日不能晚于本申请的公开日。</li>\n<li>现有技术中的技术问题分析不到位时，将导致审查员低估专利的新创性高度。<strong>建议介绍一下发现问题的过程，以及发现问题过程的难度，进而结合到具体的现有技术通过推理的方式阐述技术问题产生的原因。</strong></li>\n</ol>\n<h5 id=\"错误示例-1\">错误示例</h5>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417113935138.png\" alt=\"image-20210417113935138\" style=\"zoom: 67%;\" /></p>\n<h5 id=\"优秀示例\">优秀示例</h5>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417113847130.png\" alt=\"image-20210417113847130\" style=\"zoom:80%;\" /></p>\n<h4 id=\"解决的技术问题及有益效果\">解决的技术问题及有益效果</h4>\n<h5 id=\"技术问题\">技术问题</h5>\n<ul>\n<li>正面直接、清楚、客观地指出要解决的问题；</li>\n<li>技术问题应该是背景技术中存在的技术问题；</li>\n<li>可以同时解决多个技术问题，也可以解决一个技术问题，也可以多个方 案解决多个技术问题</li>\n</ul>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417133524015.png\" alt=\"image-20210417133524015\" style=\"zoom:67%;\" /></p>\n<h5 id=\"有益效果\">有益效果</h5>\n<p>有益效果是指与背景技术相比具有的有益效果。</p>\n<ul>\n<li>应当通过对本申请结构特点的分析和理论说明相结合，或者通过列出实 验数据（给出必要实验条件和方法）的方式，说明与背景技术的区别以 及由该区别所取得的有益效果，不得只断言具有有益效果。</li>\n<li>有益效果可以由产率、质量、精度和效率的提高，能耗、原材料、工序 的节省，加工、操作、控制、使用的简便，环境污染的治理以及有用性 能的出现等方面反映出来</li>\n</ul>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417133718557.png\" alt=\"image-20210417133718557\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417133700056.png\" alt=\"image-20210417133700056\" style=\"zoom:67%;\" /></p>\n<h6 id=\"有益效果的作用\">有益效果的作用</h6>\n<p>有益效果是确定 <strong>发明</strong> 是否具有 “<strong>显著进步</strong>” 的重要依据，是确定 <strong>实用新型</strong> 是否具有 “<strong>进步</strong>” 的重要依据！</p>\n<h5 id=\"举例\">举例</h5>\n<p><strong>设备、装置等结构类：</strong> 通过说明增加或者改进了哪些部件，给出机械运动过程，给出推理过 程，围绕需要解决的问题做技术上的说明。</p>\n<p><strong>控制方法、工艺等方法类：</strong> 重点介绍增加或者改进了哪个步骤，给出为什么可以实现预期效果， 给出推理过程，围绕需要解决的问题做技术上的说明。</p>\n<h4 id=\"发明点\">发明点</h4>\n<p>发明点，即本申请相对于背景技术改进的技术点，该技术点是 解决前述技术问题的关键；</p>\n<p>简明扼要，突出重点，根据重要程度一一列举改进的技术点。</p>\n<p><strong>举例</strong></p>\n<p>一项关于空调器清洁杀菌方法的发明，技术方案是通过控制空调按 凝露、结霜、化霜、高温杀菌步骤完成清洁杀菌。</p>\n<p><strong>发明点列举：</strong></p>\n<ol type=\"1\">\n<li><p>杀菌控制方法；</p></li>\n<li><p>高压保护；</p></li>\n<li><p>低压保护。</p></li>\n</ol>\n<h4 id=\"附图\">附图</h4>\n<p>附图部分，应当提供可编辑的附图（CAD、VISIO等），<mark>写明各附图的图名</mark> ；</p>\n<p><strong>结构类附图</strong> 最好能够 <mark>提供立体图及爆炸图，标号表明各部件</mark>；</p>\n<p><strong>模块框图</strong> 需要 <mark>描述清楚各个模块的名称及连接关系</mark>；</p>\n<p><strong><em>照片仅能起到帮助理解方案的作用，在专利申请文件中一般不能使用</em></strong></p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419092202673.png\" alt=\"image-20210419092202673\" style=\"zoom: 50%;\" /></p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419092228518.png\" alt=\"image-20210419092228518\" style=\"zoom:50%;\" /></p>\n<h3 id=\"具体实施方式\">具体实施方式</h3>\n<ul>\n<li>围绕发明点，结合附图详细地描述技术方案，所有附图都应详 细描述，以不看附图即可明白技术方案为准；</li>\n<li>对采用的技术手段逐一描述有益效果；</li>\n<li>用词规范，含义明确</li>\n</ul>\n<h4 id=\"针对各类提案书的书写建议\">针对各类提案书的书写建议</h4>\n<h5 id=\"产品装置类技术方案\">产品、装置类技术方案</h5>\n<ul>\n<li><p>首先，描述产品整体构造；</p></li>\n<li><p>其次，详细描述关键改进部分的具体构造；</p></li>\n<li><p>最后，说明动作过程和工作原理</p></li>\n</ul>\n<p><strong>注意：</strong>尽可能详细地描述各个部件之间的连接关系及位置关系。</p>\n<h5 id=\"方法类技术方案\">方法类技术方案</h5>\n<ul>\n<li><p>描述具体的实现流程；</p></li>\n<li><p>描述方式：通过XX设备执行了XX动作/操作，达到了XX条件/目的；</p></li>\n<li><p>详细介绍方法的步骤构成，各步骤间的关系，工艺参数等</p></li>\n</ul>\n<h5 id=\"电子类技术方案\">电子类技术方案</h5>\n<ul>\n<li>描述电子产品的元器件、部件，相互配置关系，以及各器件/部件在整个产品中的功能</li>\n</ul>\n<h4 id=\"举例-1\">举例</h4>\n<blockquote>\n<p><strong>例1：</strong>产品类 技术方案</p>\n<p>首先，描述产品整体构造。</p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419093156426.png\" alt=\"image-20210419093156426\" style=\"zoom:50%;\" /></p>\n<p>其次，详细描述关键改进部分的具体构造</p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419093239539.png\" alt=\"image-20210419093239539\" style=\"zoom:50%;\" /></p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419093255210.png\" alt=\"image-20210419093255210\" style=\"zoom:50%;\" /></p>\n<p>最后，说明动作过程和工作原理</p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419093337481.png\" alt=\"image-20210419093337481\" style=\"zoom:50%;\" /></p>\n</blockquote>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419093524237.png\" alt=\"image-20210419093524237\" style=\"zoom: 50%;\" /></p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419093534973.png\" alt=\"image-20210419093534973\" style=\"zoom: 50%;\" /></p>\n<h4 id=\"实施例撰写准则\">实施例撰写准则</h4>\n<ul>\n<li>实施例中，不仅要对技术方案所涉及的各技术特征进行具体描述，还要对有助于理解本发明创造的相关内容进行具体描述。例如：产品的制造过程及设备、原料来源、使用方法等；方法的实施设备、使用范围等。</li>\n<li>技术内容保证详实、实质性的描述，切忌只有功能性描述，而无实现该功能的具体技术方案。</li>\n<li>如果涉及公式，需要写出具体的公式形式，并给出公式中的每个参数的物理含义。</li>\n<li>如果涉及到实验，请尽量提供实验数据（以表格形式）或实验过程，通过实验数据支撑实验结果。</li>\n<li>如果涉及到算法，需以步骤形式写出具体的算法逻辑规则。如果是现有算法，请采用业内通用名称，并简单介绍算法原理；若非现有算法，请详细介绍算法原理。</li>\n</ul>\n<h4 id=\"实施例拓展\">实施例拓展</h4>\n<blockquote>\n<p>《专利审查指南》规定：</p>\n<ul>\n<li>当专利要求保护范围较宽时，应当给出至少两个不同的实施例，以支持要求保护的范围。</li>\n<li>专利的改进涉及数值范围时，通常应当给出两端值的实施例，范围较宽时，还应当给出至少一个中间值的实施例。</li>\n</ul>\n</blockquote>\n<h3 id=\"提案书内核标准\">提案书内核标准</h3>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419094300129.png\" alt=\"image-20210419094300129\" style=\"zoom:67%;\" /></p>\n","categories":["Others"],"tags":["patent"]},{"title":"Phrases in Development","url":"/2021/01/01/Others/2021-01-01-Phrases/","content":"<h1 id=\"a\">A</h1>\n<p><strong><em>accurate clock</em></strong> 精确的时钟</p>\n<blockquote>\n<p>results in an accurate clock 产生了（导致、致使）一个精确的时钟</p>\n</blockquote>\n<p><strong><em>adaptive layout</em></strong> 自适应布局</p>\n<p><strong><em>adequate</em></strong> <em>adj</em>. 充足的；适当的；胜任的</p>\n<blockquote>\n<p>For correct operation, the input signal to the ADC must be allowed <em>adequate</em> time to charge the sample and hold capacitor.</p>\n</blockquote>\n<p><strong><em>advance</em></strong> <em>vt</em>. 使……前进</p>\n<blockquote>\n<p>advancing the connected timer by one second 将连接的时钟向前推进1秒</p>\n<p>advance at different rates 以不同的速率前进</p>\n</blockquote>\n<p><strong><em>aligned</em></strong> <span style=\"color: #CCC; font-style: italic;\">/əˈlaɪnd/</span> v. 结盟；支持；使成一直线；校准；安放，排列；使一致（align 的过去式和过去分词）</p>\n<p>be <strong><em>aligned on</em></strong> B 对齐至B</p>\n<blockquote>\n<p>byte-aligned memory address 字节内存地址</p>\n</blockquote>\n<p><strong><em>alternate</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ɔːlˈtɜːnət/</span> <em>adj</em>. 交替的，轮流的；间隔的，每隔（……天等）的；（一或多个事物）另外的，可供选择的；（两者）互不相容的；另类的，非传统的；<em>v</em>. （使）交替，（使）轮流 <em>n</em>. 替换物，代理人</p>\n<p><strong><em>alternate mux selection</em></strong> 交替复用选择</p>\n<p><strong><em>transient pulse</em></strong> 瞬时脉冲</p>\n<blockquote>\n<p>alternate mux selections 交替复用选择</p>\n<p>The <code>GPyGMUXn</code> register should be configured before the <code>GPyMUXn</code> to avoid transient pulses on GPIOs from <em>alternate mux selections</em>. <code>GPyGMUXn</code> 寄存器应在 <code>GPyMUXn</code> 之前配置，以避免交替复用选择对GPIO产生瞬时脉冲。</p>\n</blockquote>\n<p><strong><em>alteration</em></strong> <em>n</em>. 改变；变更；服装修改</p>\n<blockquote>\n<p>The Embedded C++ library works in <em>conjunction</em> with 15 of the headers from the Standard C library, sometimes with small <em>alterations</em>.</p>\n</blockquote>\n<p>amplify <em>vt</em>. 放大，扩大；增强；详述 <em>vi</em>. 详述</p>\n<p><strong><em>amplifier</em></strong> <em>n</em>. 增益器；放大器；</p>\n<p><strong><em>power amplifier</em></strong> （也简写: power amp）功率放大器</p>\n<p>pre-amplifier 前置放大器（也写作：preamplifier 或 preamp）</p>\n<p>operational amplifier 运算放大器</p>\n<p><strong><em>analog to analog latency</em></strong> 模比延迟</p>\n<blockquote>\n<p>38 μs analog-to-analog latency</p>\n</blockquote>\n<p><strong><em>appends</em></strong> <em>sth</em>. <strong><em>as appropriate</em></strong> 适当地附加某物</p>\n<blockquote>\n<p>When sending out the address on the bus, the TWI controller appends the read/write bit as appropriate, based on the state of the TWIMDIR bit in the master mode control register.</p>\n</blockquote>\n<p><strong><em>approximate</em></strong> <span style=\"color: #CCC; font-style: italic;\">/əˈprɒksɪmət/</span> <em>adj</em>. 近似的，大概的 <em>v</em>. 接近，近似；粗略估计</p>\n<p><strong><em>approximately</em></strong> <span style=\"color: #CCC; font-style: italic;\">/əˈprɒksɪmətli/</span> <em>adv</em>. 大约，近似地；近于</p>\n<p><strong><em>approximation</em></strong> <em>n</em>. 近似值</p>\n<blockquote>\n<p>A typical motherboard, including an Am486DX2-80CPU, consumes around 13 W, meaning that the CPU accounts for <em>approximately</em> 16 percent of the total motherboard power consumption. 一个典型的主板，包括Am486DX2-80CPU，消耗约13W，这意味着CPU约占主板总功耗的16%。</p>\n</blockquote>\n<p><strong><em>arbitration</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˌɑːbɪˈtreɪʃn/</span> <em>n</em>. 公断，仲裁</p>\n<p><strong><em>arbitrarily</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˌɑːbɪˈtrerəli/</span> adv. 武断地；任意地；专横地；</p>\n<blockquote>\n<p><code>SOC5</code> is chosen arbitrarily. （此处就）任意选择SOC5。</p>\n</blockquote>\n<p><strong><em>arithmetic</em></strong> <span style=\"color: #CCC; font-style: italic;\">/əˈrɪθmətɪk/</span> n. 算术，算法；数字</p>\n<p>arithmetic operations 算术运算</p>\n<p><strong><em>assemble</em></strong> <em>vt</em>. 集合，聚集；装配；收集 <em>vi</em>. 集合，聚集</p>\n<p><strong><em>assembly</em></strong> <em>n</em>. 装配；集会，集合 <em>n</em>. 汇编，编译</p>\n<blockquote>\n<p>assembly source 汇编源代码</p>\n<p>assembly code 汇编码</p>\n</blockquote>\n<p><strong><em>assert</em></strong> <em>vt</em>. 维护，坚持；断言；主张；声称</p>\n<p><strong><em>assertion</em></strong> <span style=\"color: #CCC; font-style: italic;\">/əˈsɜːʃn/</span> n. 断言，声明；主张，要求；坚持；认定</p>\n<blockquote>\n<p>assertion check 断言检查</p>\n<p>internal asserts 内部断言</p>\n</blockquote>\n<p>A be <strong><em>assigned to</em></strong> B A被分配给了B</p>\n<blockquote>\n<p>Parameters are assigned to instructions in the order in which the instructions are instantiated in the code. 参数按照在代码中实例化指令的顺序被分配给了指令。</p>\n</blockquote>\n<p><strong>attribute</strong> <em>n</em>. 属性；特质 <em>vt</em>. 归属；把……归于</p>\n<blockquote>\n<p><strong>property</strong> <em>n</em>. 性质，性能；财产；所有权</p>\n</blockquote>\n<blockquote>\n<p>pin attributes 引脚分配</p>\n</blockquote>\n<p>the <strong><em>attached clock</em></strong> 附带的时钟</p>\n<p>attenuate <em>v</em>. （使）减弱；（使）纤细，稀薄 adj. 减弱的；稀薄的；细小的</p>\n<p>attenuated <em>adj</em>. （力量或效果）衰减的；（人）瘦长的 <em>v</em>. 使减弱；使变细；稀释</p>\n<p><strong><em>attenuation</em></strong> <em>n</em>. [物] 衰减；变薄；稀释</p>\n<p>digital attenuation step 数字衰减步长</p>\n<p>digital attenuation range 数字衰减范围</p>\n<blockquote>\n<p>The volume setting of each ADC can be <em>digitally attenuated</em> in the <code>ADCx_VOLUME</code> registers.</p>\n</blockquote>\n<p>auto increment 自增</p>\n<p><strong><em>auto-increment circuit</em></strong> 自增电路</p>\n<blockquote>\n<p>The ADAU1772 always decodes the subaddress and sets the <em>auto-increment circuit</em> so that the address increments after the appropriate number of bytes.</p>\n</blockquote>\n<p><strong><em>auxiliary</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ɔːɡˈzɪliəri/</span> adj. 辅助的；副的；附加的；（发动机、设备等）备用的</p>\n<blockquote>\n<p>auxiliary definitions 辅助定义</p>\n</blockquote>\n<h1 id=\"b\">B</h1>\n<p><strong><em>base address</em></strong> 基地址</p>\n<p><strong><em>batch session</em></strong> 批处理会话</p>\n<blockquote>\n<p>To launch a batch session using two command files \"input1\" and \"input2\".</p>\n</blockquote>\n<p><em>sth</em>. <strong><em>become scattered throughout</em></strong> <em>somewhere</em> 某物被分散到某处</p>\n<blockquote>\n<p>As memory blocks are \"freed\" back to the <code>HeapMem</code>, the available memory in the <code>HeapMem</code> becomes scattered throughout the heap.</p>\n</blockquote>\n<p><strong><em>benchmark</em></strong> <em>n</em>. 参考标准，基准 (a standard by which something can be measured or judged)</p>\n<p><strong><em>bias</em></strong> <em>n</em>. 偏移；偏差；偏见；<em>vt</em>. 使存偏见 <em>adj</em>. 偏斜的 <em>adv</em>. 偏斜地</p>\n<p><strong><em>bias generators</em></strong> 偏置发生器</p>\n<p><strong><em>bitfield reference</em></strong> 位域参考</p>\n<p><strong><em>bond</em></strong> <em>n</em>. 债券；结合；约定；粘合剂；纽带 <em>vi</em>. 结合，团结在一起 <em>vt</em>. 使结合；以…作保</p>\n<p><strong><em>unbond</em></strong> adj. 未绑定的</p>\n<blockquote>\n<p>floating unbonded inputs 未绑定的浮点输入</p>\n<p>To avoid any <em>floating unbonded inputs</em>, the Boot ROM will enable internal pullups on GPIO pins that are not bonded out in a particular package. 为了避免任何未绑定的浮点输入，Boot ROM将在特定封装中未绑定的GPIO引脚上启用内部上拉。</p>\n</blockquote>\n<p><strong><em>boost</em></strong> <em>vt</em>. 促进；增加；支援 <em>vi</em>. 宣扬；偷窃 <em>n</em>. 推动；帮助；宣扬</p>\n<p><strong><em>PGA boost</em></strong> 可编程增益放大器（功率）提升</p>\n<p><strong><em>booster</em></strong> <em>n</em>. 升压机；支持者；扩爆器</p>\n<p>booster-pack / <strong><em>boosterpack</em></strong> 增强包</p>\n<p><strong><em>bootloader</em></strong> 引导器</p>\n<p><strong><em>be broken down into</em></strong></p>\n<blockquote>\n<p>The process of converting an analog voltage to a digital value <em>is broken down into</em> an S+H phase and a conversion phase.</p>\n</blockquote>\n<p><strong><em>bypass</em></strong> n. 旁路，支流 v. 绕过，避开；忽视，不顾（规章制度）；设旁路，迂回</p>\n<p><strong><em>bypass capacitor</em></strong> 旁路电容</p>\n<p><img src=\"https://pic.islet.space/2021/04/Bypass-capacitor.png\" alt=\"旁路电容\" style=\"zoom:50%;\" /></p>\n<p><strong><em>be bypassed with a capacitor</em></strong> 用一个电容进行绕装</p>\n<blockquote>\n<p>Each supply signal on the board should also <em>be bypassed with</em> a single bulk capacitor (10 μF to 47 μF).</p>\n</blockquote>\n<h1 id=\"c\">C</h1>\n<p><strong><em>calibration</em></strong> n. 校准；刻度；标度</p>\n<p>self-calibration 自校准</p>\n<p>offset self-calibration 偏移自校准</p>\n<blockquote>\n<p>Internal connection to VREFLO on all ADCs for offset self-calibration. ADC上所有到VREFLO的内部连接，都用于偏移自校准。（这语法也很迷）</p>\n</blockquote>\n<p><em>A</em> <strong><em>calls into</em></strong> <em>B</em> A调用B</p>\n<blockquote>\n<p>Internally, the Memory module calls into the heap’s interface functions.</p>\n</blockquote>\n<p>A <strong><em>make calls to</em></strong> B A调用B</p>\n<blockquote>\n<p>it makes calls to the Heap module through the <code>IHeap_Handle</code>.</p>\n</blockquote>\n<p><strong><em>capacibility</em></strong></p>\n<p><strong><em>capacitance</em></strong> n. 电容（值）</p>\n<p><strong><em>capacitor</em></strong> n. 电容器</p>\n<p><strong><em>easy parallel switching capacibility</em></strong> 易于并联开断/切换的电容</p>\n<p><strong><em>care should be taken when</em></strong> 当/在……时需要小心</p>\n<blockquote>\n<p><em>Care should be taken</em> when choosing a Task stack size.</p>\n<p>在选择任务堆栈大小时要小心。</p>\n</blockquote>\n<p><strong><em>characteristic</em></strong> n. 特性</p>\n<blockquote>\n<p>thermal resistance characteristics 热阻特性</p>\n<p>static characteristic 静态特性</p>\n<p>dynamic characteristic 动态特性</p>\n<p>electrical characteristic 电气特性</p>\n<p>switching characteristic 开关特性</p>\n<p>diode characteristic 二极管特性</p>\n</blockquote>\n<p><strong><em>circuitry</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˈsɜːkɪtri/</span> <em>n</em>. 电路；电路系统；电路学；一环路</p>\n<blockquote>\n<p>The easiest way to achieve this is to use a regulator that has a power good (PGOOD) signal to power the ADAU1772 or generate a power good signal using additional <em>circuitry</em> external to the regulator itself.</p>\n</blockquote>\n<p><strong><em>clamp</em></strong> v. 固定，稳定</p>\n<blockquote>\n<p>The inputs are internally clamped to VDD and GND by diodes.</p>\n</blockquote>\n<p><strong><em>coefficient write</em></strong> 系数写入</p>\n<p><strong><em>collision</em></strong> <span style=\"color: #CCC; font-style: italic;\">/kəˈlɪʒn/</span> <em>n</em>. 碰撞；冲突；（意见，看法）的抵触；（政党等的）倾轧</p>\n<p><strong><em>collision detection</em></strong> 冲突检测</p>\n<p><strong><em>several-input-lines command</em></strong> 多行输入命令</p>\n<blockquote>\n<p>Commands may extend over several input lines by ending each line but the last with a backslash ().</p>\n<p>命令可以扩展到多个输入行，每一行以反斜杠()结束，最后一行以反斜杠()结束。</p>\n</blockquote>\n<p><strong><em>comment out</em></strong> sth. 注释掉</p>\n<blockquote>\n<p>Therefore, commenting out a continued line comments out the entire command.</p>\n<p>因此，注释掉一个连续的行就会注释掉整个命令.</p>\n<p>That is, no white space is implied, nor is a comment terminated.</p>\n<p>也就是说，没有空格，注释也不会终止。</p>\n</blockquote>\n<p><strong><em>commit</em></strong> <span style=\"color: #CCC; font-style: italic;\">/kəˈmɪt/</span> <em>vt</em>. 犯罪；把...交托给；指派…作战；使…承担义务；（公开地）表示意见 <em>vi</em>. 忠于（某个人、机构等）；承诺</p>\n<blockquote>\n<p>amend last commit 修改上一次提交（的数据）</p>\n<p>initial commit message 初始提交消息</p>\n</blockquote>\n<p><strong><em>configuration entry</em></strong> 配置条目</p>\n<p><strong><em>conjunction</em></strong> <em>n</em>. 结合；[语] 连接词；同时发生</p>\n<p><strong><em>connect</em></strong> <em>A</em> <strong><em>in series with</em></strong> <em>B</em> 让A与B以串联形式连接</p>\n<blockquote>\n<p>The headphone outputs can also be configured as ground centered outputs by connecting coupling capacitors in series with the output pins.</p>\n</blockquote>\n<p><strong><em>consistency</em></strong> n. 一致性</p>\n<p>data consistency 数据一致性</p>\n<p>data consistency in every node of the system 系统内部各节点的数据一致性</p>\n<p><strong><em>constrain</em></strong> <em>vt</em>. 驱使；强迫；束缚</p>\n<p><strong><em>be significantly constrained</em></strong> 非常有限 / 显著不足的</p>\n<blockquote>\n<p>This is particularly useful on targets where the code memory is significantly constrained.</p>\n</blockquote>\n<p><strong><em>constructor</em></strong> <em>n</em>. 构造函数；构造器；建造者</p>\n<p><strong><em>destructor</em></strong> <em>n</em>. 析构函数</p>\n<p><strong><em>context of a software interrupt</em></strong> 软件中断的上下文</p>\n<blockquote>\n<p>Memory allocation APIs such as <code>Memory_alloc()</code> and <code>Memory_calloc()</code> cannot be called from within the context of a software interrupt.内存分配接口如A和B不能够在软件中断的上下文中被调用。</p>\n</blockquote>\n<p><strong><em>convention</em></strong> <em>n</em>. 公约</p>\n<p><strong><em>software convention</em></strong> 软件公约、软件惯例</p>\n<blockquote>\n<p>Allocation of source bits to source processor and meaning is entirely based on software convention.源位分配到源处理器和意义完全基于软件惯例。</p>\n</blockquote>\n<p><strong><em>corner frequency</em></strong> 角频率</p>\n<p><strong><em>correspond</em></strong> <span style=\"color: #CCC; font-style: italic;\">/,kɒrə'spɒnd/</span> <em>vi</em>. 符合，一致；相应；通信</p>\n<p><strong><em>the corresponding modules</em></strong> 对应模块</p>\n<blockquote>\n<p>The ADAU1772 knows to <strong><em>increment</em></strong> its subaddress register every two bytes because the requested subaddress corresponds to a register or memory area with a 2-byte word length. [此处应该是语法有问题，个人感觉应该是increase而不是increment]</p>\n<p>For example, <code>Ipc_S_SUCCESS</code>, <code>MessageQ_E_FAIL</code>, and <code>SharedRegion_E_MEMORY</code> are status codes that may be returned by functions in the corresponding modules.</p>\n</blockquote>\n<p><strong><em>curly braces</em></strong> 花括号</p>\n<p>denote optional arguments 表示可选参数</p>\n<p>mutually exclusive choices 互相排斥的选择</p>\n<blockquote>\n<p>In this document, curly braces ({}) denote optional arguments and a vertical bar (|) separates mutually exclusive choices.</p>\n<p>在本文档中，花括号({})表示可选参数，竖线(|)分隔互斥的选项。</p>\n</blockquote>\n<p><strong><em>current</em></strong> <em>n</em>. 电流</p>\n<p>concurrent <em>adj</em>. 并发的；一致的；同时发生的；并存的 <em>n</em>. [数] 共点；同时发生的事件</p>\n<p><strong><em>concurrently</em></strong> <em>adv</em>. 同时地</p>\n<p><strong><em>nominal current</em></strong> 名义电流、额定电流</p>\n<p><strong><em>rated current</em></strong> 额定电流</p>\n<h1 id=\"d\">D</h1>\n<p><strong><em>declaration</em></strong> <span style=\"color: #CCC; font-style: italic;\">/,deklə'reiʃən/</span> n. （纳税品等的）申报；宣布；公告；申诉书；声明；</p>\n<blockquote>\n<p>function declaration 函数声明</p>\n</blockquote>\n<p><strong><em>derived</em></strong> <span style=\"color: #CCC; font-style: italic;\">/dɪˈraɪvd/</span> <strong><em>class</em></strong> 派生类</p>\n<blockquote>\n<p>In derived classes, <code>super()</code> must be called before you can use <code>this</code>. 在派生类中，使用<code>this</code> 前必先调用 <code>super()</code> 函数。</p>\n</blockquote>\n<p><strong><em>diagnostics</em></strong> n. 诊断学（用作单数）</p>\n<p><strong>discrete</strong> <span style=\"color: #CCC; font-style: italic;\">/dɪˈskriːt/</span> adj. 离散的，不连续的 n. 分立元件；独立部件</p>\n<p>discrete device 分离部件</p>\n<p><strong><em>dissipation</em></strong> <em>n</em>. 损耗，耗散</p>\n<p><strong><em>power dissipation</em></strong> 功率损耗</p>\n<p><strong><em>dynamic memory allocation and deallocation</em></strong> 动态内存分配和回收</p>\n<blockquote>\n<p>SYS/BIOS provides reentrant versions of malloc() and free() that internally use the xdc.runtime. SYS/BIOS为内部使用XDC.RUNTIME的 malloc() 和 free() 提供了可重入版本。</p>\n</blockquote>\n<h1 id=\"e\">E</h1>\n<p>electric</p>\n<p>electrical</p>\n<p>electron</p>\n<p>electronic</p>\n<p><strong><em>electret</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ɪˈlektrət/</span> <em>n</em>. 驻极体；电介体</p>\n<p><strong><em>electret microphone</em></strong> 驻极体麦克风</p>\n<p><strong><em>seamless interfacing</em></strong> 无缝连接（的接口）</p>\n<blockquote>\n<p>Two microphone bias pins provide <em>seamless interfacing</em> to <em>electret microphones</em>. 两个麦克风偏置针为驻极体麦克风提供了无缝连接。</p>\n</blockquote>\n<p><strong><em>electrical layer requirements</em></strong> 电气层要求</p>\n<p><strong><em>elicit</em></strong> <span style=\"color: #CCC; font-style: italic;\">/i'lisit/</span> <em>vt</em>. 引出</p>\n<p><strong><em>endian</em></strong> <em>n</em>. 字节存储次序，元组排列顺序</p>\n<p><strong><em>big-endian</em></strong> 高位对齐，大端</p>\n<p><strong><em>small-endian</em></strong> 低位对齐，小端</p>\n<p><strong><em>device endianness</em></strong> 设备字节顺序</p>\n<p><strong><em>equivalent</em></strong> <em>adj</em>. （在价值、数量等方面）相等的；等价的；等效的；等量的；同意义的 <em>n</em>. 对等的人（或事物）；当量</p>\n<p><strong><em>equidistant</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˌiːkwɪˈdɪstənt/</span> <em>adj</em>. 等距的；距离相等的</p>\n<blockquote>\n<p>For maximum effectiveness, <em>locate</em> the capacitor equidistant <em>from</em> the power and ground pins or slightly closer to the power pin if equidistant placement is not possible. 为了获取最大效率，应在电源及接地的等距接口处置放电容，若等距放置无法采用，则应在放置在电源一侧。</p>\n</blockquote>\n<p><strong><em>encoded internal representations</em></strong> 编码的内部表示</p>\n<p>an <strong><em>entire contiguous Ethernet packet</em></strong> 一个完整连续的以太网包</p>\n<p><strong><em>error</em></strong> <em>n</em>. 错误，误差</p>\n<p><strong><em>fatal error</em></strong> 致命错误</p>\n<p><strong><em>offset error</em></strong> 便宜误差</p>\n<p><strong><em>gain error</em></strong> 增益误差</p>\n<p><strong><em>explicitly</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ɪkˈsplɪsɪtli/</span> <em>adv</em>. 明确地；明白地</p>\n<p><strong><em>implicitly</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ɪmˈplɪsɪtli/</span> <em>adv</em>. 含蓄地；暗中地</p>\n<blockquote>\n<p>explicity and implicity 显性和隐性</p>\n</blockquote>\n<p><strong><em>exploring the ecosystem</em></strong> 探索生态系统</p>\n<p><strong><em>extent</em></strong> <em>n</em>. 程度；范围；长度</p>\n<p>extend <em>vt</em>. 延伸；扩大；推广；伸出；给予；使竭尽全力；对…估价 <em>vi</em>. 延伸；扩大；伸展；使疏开</p>\n<p>extensive <em>adj</em>. 广泛的；大量的；广阔的</p>\n<p>extension <em>n</em>. 拓展；延伸；接发；（医学）牵引；（计算机）拓展名；（逻辑）外延</p>\n<p>extended <em>adj</em>. 延伸的；扩大的；长期的；广大的 <em>v</em>. 延长；扩充（extend 的过去分词）</p>\n<blockquote>\n<p>The <em>extent</em> to which this is true depends on the floating-point processor’s architecture. 这一点在多大程度上取决于浮点处理器的架构。</p>\n</blockquote>\n<p><strong><em>event combiner</em></strong> 事件组合器</p>\n<p><strong><em>expand</em></strong> <em>vt</em>. 扩张；使膨胀；详述 <em>vi</em>. 发展；张开，展开</p>\n<p>expansion <em>n</em>. 膨胀；阐述；扩张物</p>\n<blockquote>\n<p>It also <em>expands</em> the vector table to allow each interrupt to have its own ISR.</p>\n</blockquote>\n<h1 id=\"f\">F</h1>\n<p><strong><em>facility</em></strong> <em>n</em>. 设备，设施</p>\n<p><strong><em>facilitate</em></strong> <em>v</em>. 促进，帮助，使容易</p>\n<blockquote>\n<p>These registers also provide a <em>Source ID facility</em> by which up to 28 different sources of interrupts can be identified. 这些寄存器还提供了一个 <em>源 ID设备</em> ，通过它可以识别多达28个不同的中断源。</p>\n<p>The IPCGRH register facilitates interrupts to external hosts. IPCGRH寄存器促进中断到外部主机。</p>\n</blockquote>\n<p><strong><em>farad</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˈfæræd/</span> n. 法拉</p>\n<p><strong><em>microfarad</em></strong> 微法</p>\n<p><strong><em>millifarad</em></strong> 毫法</p>\n<p><strong><em>nanofarad</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˈneɪnəˈfærəd/</span> 纳法</p>\n<p>fed vt. 喂养</p>\n<p>A <strong><em>be fed directly to</em></strong> <em>somewhere</em> / B A被直接带到某处 、A被直接喂给B（吃掉）</p>\n<blockquote>\n<p>The ADAU1772 can generate its clocks either from an externally provided clock or from a crystal oscillator. In both cases, the on board PLL can be used or the clock can be fed directly to the core.</p>\n</blockquote>\n<p><strong><em>filter</em></strong> n. 滤波器</p>\n<p>all-pole filters / gain 全通角过滤器/增益</p>\n<p>second order filter 二阶滤波器</p>\n<p>sinc filter</p>\n<p><strong><em>fixed</em></strong> <em>adj</em>. 固定的</p>\n<blockquote>\n<p>variable-sized buffers 可变大小缓冲</p>\n<p>fixed-size buffers 固定大小缓冲</p>\n</blockquote>\n<p><strong><em>formal parameter</em></strong> 形式参数</p>\n<blockquote>\n<p>C++ allows you to specify default values for formal parameters within the function declaration. C++允许你在函数声明中指定形参的默认值。</p>\n</blockquote>\n<p><strong><em>forward</em></strong> <em>adj</em>. 正向的</p>\n<p><strong><em>diode forward current</em></strong> 二极管正向电流</p>\n<p>on-board <strong><em>fractional PLL</em></strong> 板载小数分频PLL</p>\n<p><strong><em>frame sync edge detection</em></strong> 帧同步边缘检测</p>\n<blockquote>\n<p>These registers (where x signifies SPORT 0 through 7) allow programs to set frame sync edge detection for I2S compatibility. 这些寄存器（其中x表示SPORT 0到7）允许程序设置帧同步边缘检测以实现I2S的兼容性。****</p>\n</blockquote>\n<p><strong><em>full-scale</em></strong> 全尺寸的、全尺度的、满量程的</p>\n<p><strong><em>full-scale input voltage</em></strong> 满量程输入电压</p>\n<p><strong><em>function call sequence</em></strong> 函数调用顺序</p>\n<blockquote>\n<p>Standard IPC Function Call Sequence</p>\n</blockquote>\n<p><em>A</em> <strong><em>as a function of</em></strong> <em>B</em>. 把B带入函数求得A；把B当作自变量，A当作因变量。用于描述 A与B的关系。</p>\n<blockquote>\n<p>collector current <strong><em>as a function of</em></strong> case temperature 集电极电流与外壳温度的关系</p>\n</blockquote>\n<h1 id=\"g\">G</h1>\n<p><strong><em>ganged</em></strong> <em>adj</em>. 成组的，联动的；<em>v</em>. 用金属细丝加固</p>\n<blockquote>\n<p>ganged references</p>\n</blockquote>\n<p><strong>gate off</strong> 关闭</p>\n<blockquote>\n<p>turn on 打开</p>\n</blockquote>\n<p><strong><em>give more control over</em></strong> <em>sth</em>. 在某事上予以更多控制权</p>\n<p><strong><em>graphical programming software</em></strong> 图形化编程软件</p>\n<blockquote>\n<p>The program and parameter RAMs can be loaded with custom audio processing signal flow built using the SigmaStudio™ graphical programming software from Analog Devices, Inc. 在使用Analog Devices公司的SigmaStudio图形化编程软件建立自定义音频处理信号流时，程序和参数内存会被自动加载。</p>\n</blockquote>\n<p><strong><em>granularity</em></strong> n. 间隔尺寸，[岩] 粒度</p>\n<blockquote>\n<p>the quality of being composed of relatively large particles</p>\n</blockquote>\n<h1 id=\"h\">H</h1>\n<p>a <strong><em>handful of</em></strong> <em>sth</em>. 一些某物（可数）</p>\n<blockquote>\n<p>An adaptive layout will give you more control over the design because you only have a handful of states to consider.</p>\n</blockquote>\n<p><strong><em>harmonic</em></strong> n. 谐波</p>\n<p>total <strong><em>harmonic distortion</em></strong> + noise 总谐波失真和噪声</p>\n<p><strong><em>harness</em></strong> <em>n</em>. 马具；背带，吊带；甲胄；挽具状带子；降落伞背带；日常工作 <em>v</em>. 治理，利用；套；驾驭；披上甲胄；将（两只动物）拴在一起</p>\n<blockquote>\n<p>wiring harness 线束</p>\n<p>the complex wiring harness 复杂的线束</p>\n</blockquote>\n<p><strong><em>hierarchy board</em></strong> 层次结构板</p>\n<p><strong><em>hint</em></strong> <em>n</em>. 暗示；线索 <em>vt</em>. 暗示；示意 <em>vi</em>. 示意</p>\n<blockquote>\n<p>This chapter provides hints for improving the runtime performance and shared memory usage of applications that use IPC.</p>\n</blockquote>\n<h1 id=\"i\">I</h1>\n<p><strong><em>identical</em></strong> <em>adj</em>. 一致的，一样的</p>\n<blockquote>\n<p>Each ePWM instance is identical with one exception. 所有ePWM实例都是一致的，只有一个例外。</p>\n</blockquote>\n<p><strong><em>impedance</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ɪmˈpiːdns/</span> n. 阻抗</p>\n<p>input impedance 输入阻抗</p>\n<p>output impedance 输出阻抗</p>\n<p>load impedance 负载阻抗</p>\n<p>impedance matching 阻抗匹配</p>\n<p>impedance mismatch 阻抗失配</p>\n<p><strong><em>implement</em></strong> <em>v</em>. 实施，执行；实现，使生效 <em>n</em>. 工具，器具；手段 (apply in a manner consistent with its purpose or design)</p>\n<blockquote>\n<p>implementation of the interface 接口的实现</p>\n<p>instantiation of clock 时钟实例化</p>\n</blockquote>\n<p><strong><em>incorporate</em></strong> 包含</p>\n<blockquote>\n<p>The ADAU1772 is a codec with four inputs and two outputs that incorporates a digital processing engine to perform filtering, level control, signal level monitoring, and mixing.</p>\n</blockquote>\n<p>be <strong><em>independent of</em></strong> 独立于……；相对于……独立</p>\n<p><strong><em>indicate</em></strong> <em>vt</em>. 表明；指出；预示；象征</p>\n<p><strong><em>inherent</em></strong> adj. 固有的；内在的；与生俱来的，遗传的</p>\n<blockquote>\n<p>In Round-Robin priority method, no SOC has an inherent higher priority than another. 在RR优先级模式下，所有SOC的优先级都平等。</p>\n</blockquote>\n<p><strong><em>install</em></strong> <em>sth</em>. <strong><em>across</em></strong> <em>sth</em>. 在某物上安装某物</p>\n<blockquote>\n<p>To use MCLK on the J4 header, first install a resistor across the R2 pads. 要在J4引脚上使用MCLK，首先要在R2焊盘上安装一个电阻。</p>\n</blockquote>\n<p><strong><em>instantiation</em></strong> <em>n</em>. 实例化；[计] 例示</p>\n<p>interact <em>vt</em>./<em>vi</em>. 互相影响；互相作用</p>\n<p>interaction <em>n</em>. 相互作用，相互影响；交流；[数] 交互作用；互动</p>\n<p>interactive <em>adj</em>. 交互式的；相互作用的</p>\n<p><strong><em>interactive plot windows</em></strong> 互动式绘制窗口</p>\n<blockquote>\n<p><em>-p</em> tells the program not to close any remaining interactive plot windows when the program exits.</p>\n</blockquote>\n<p><strong><em>internal digital supply voltage</em></strong> 内部数字电源电压</p>\n<blockquote>\n<p>The operating voltage range is 1.8 V to 3.63 V, with an on-board regulator generating the internal digital supply voltage.</p>\n</blockquote>\n<p>interrupt <em>n</em>. 中断</p>\n<p><strong><em>peripheral interrupt</em></strong> 外设中断</p>\n<p><strong><em>hardware interrupt</em></strong> 硬件中断</p>\n<p>software interrupt 软件中断</p>\n<p>external interrupt 外部中断</p>\n<p>intuitive <span style=\"color: #CCC; font-style: italic;\">/ɪnˈtjuːɪtɪv/</span> <em>adj</em>. 直觉的；凭直觉获知的</p>\n<p>counterintuitive <em>adj</em>. 违反直觉的</p>\n<blockquote>\n<p>The naming convention for these endpoints is very consistent, but frequently counterintuitive.</p>\n</blockquote>\n<p><strong><em>invention</em></strong> n. 发明</p>\n<p><strong><em>inventory</em></strong> n. 存货，存货清单；详细目录；财产清册 vt. 给……开列清单</p>\n<p><strong><em>take inventory of</em></strong> 盘点一下</p>\n<blockquote>\n<p>take inventory of the unique signals 对独特的信号进行盘点</p>\n</blockquote>\n<p><strong><em>invoke the class member function</em></strong> 调用类成员函数</p>\n<blockquote>\n<p>By writing a wrapper function which accepts a class instance as a parameter, you can invoke the class member function from within the wrapper. 通过编写以类实例作为参数的包装函数，你可以在包装函数中调用其类成员函数。</p>\n</blockquote>\n<p><strong><em>insertion/withdrawal force</em></strong> 推拉力</p>\n<p>isolate <em>vt</em>. （使）隔离，孤立；将……剔出；（某物质、细胞等）分离；区别看待（观点、问题等）<em>n</em>. 被隔离的人（或物）；[生]（用于研究的）分离菌，隔离群</p>\n<p><strong><em>isolated</em></strong> <em>adj</em>. 偏远的；孤立的；孤独的；单独的； 绝缘的</p>\n<p><strong><em>inter-channel isolation</em></strong> 通道间隔</p>\n<p><strong><em>optimal isolation</em></strong> 隔离优化</p>\n<blockquote>\n<p>As previously stated, the stack has been designed for <em>optimal isolation</em>, and so that it may seamlessly plug in to varying run-time environments.</p>\n</blockquote>\n<h1 id=\"j\">J</h1>\n<p><strong><em>left/right justified</em></strong> 左/右对齐</p>\n<h1 id=\"l\">L</h1>\n<p><strong><em>legacy</em></strong> <em>n</em>. 遗产；遗赠财物；遗留问题；后遗症</p>\n<p><strong><em>latch</em></strong> <em>vi</em>. 占有，抓住；闭锁 <em>vt</em>. 闩上；纠缠住某人 <em>n</em>. 门闩，锁存器</p>\n<p><strong><em>latency</em></strong> <em>n</em>. 潜伏；潜在因素；延迟</p>\n<p><strong><em>leap year</em></strong> 闰年</p>\n<p><strong><em>locate</em></strong> <em>sth</em>. <strong><em>from</em></strong> <em>somewhere</em> 从某处定位某物</p>\n<p><strong><em>low latency</em></strong> 低延迟</p>\n<blockquote>\n<p>The path from the analog input to the DSP core to the analog output is optimized for <em>low latency</em> and is ideal for noise cancelling headsets.</p>\n</blockquote>\n<h1 id=\"m\">M</h1>\n<p><strong><em>mandatory</em></strong> <span style=\"color: #CCC; font-style: italic;\">/‘mændətəri/</span> <em>adj</em>. 强制的；命令的；托管的； <em>n</em>. 受托者</p>\n<blockquote>\n<p>Ping uses the ICMP protocol's mandatory <em>ECHO_REQUEST</em> datagram to elicit an ICMP <em>ECHO_RESPONSE</em> from a host or gateway.</p>\n<p>PING使用ICMP协议的强制性的“回声请求”数据报来引出主机或网关的“回声响应”。</p>\n</blockquote>\n<p><strong><em>mangle</em></strong> <span style=\"color: #CCC; font-style: italic;\">/mæŋgl/</span> <em>vt</em>. 乱砍、损坏</p>\n<p><strong><em>name mangling</em></strong> （函数）命名重整</p>\n<blockquote>\n<p>The process of encoding the signature into the link name is referred to as <strong>name mangling</strong>. 对链接名称解码签名的过程被称为命名重整。</p>\n<p>Since function overloading is accomplished through <strong>name mangling</strong>, function overloading has limitations for functions that are called from the configuration. 由于函数重载是通过命名重整完成的，因此函数重载对从配置中调用的函数有限制。</p>\n</blockquote>\n<p><strong><em>maximum outstanding connection request</em></strong> 最大未完成连接请求</p>\n<p><strong><em>meet the requirement</em></strong> 满足需求</p>\n<blockquote>\n<p>This feature assists designers in meeting the Energy Star requirements.</p>\n</blockquote>\n<p><strong><em>memory policy</em></strong> 存储策略</p>\n<p><strong><em>memory management traits</em></strong> 内存管理特征</p>\n<blockquote>\n<p>Different heap implementations optimize for different memory management traits.</p>\n</blockquote>\n<p><strong><em>memory region</em></strong> 内存区域</p>\n<blockquote>\n<p>This function enables caching for a specific memory region.</p>\n</blockquote>\n<p>metric <em>n</em>. 度量标准 <em>adj</em>. 公制的；米制的；公尺的</p>\n<p>metrics <em>n</em>. 度量；作诗法；韵律学</p>\n<p><strong><em>bad font metrics</em></strong> 糟糕的字体度量</p>\n<blockquote>\n<p><em>-s</em> tells the program to wait for slow font initialization on startup. Otherwise it prints an error and continues with bad font metrics.</p>\n</blockquote>\n<p><strong><em>modulate</em></strong> <em>vi</em>. 调制；转调 <em>vt</em>. 调节；调制；调整</p>\n<p><strong><em>modulation</em></strong> <em>n</em>. 调制；调整</p>\n<p><strong><em>modulator</em></strong> <em>n</em>. 调制器</p>\n<p>PCM (Pulse Code Modulation) 脉冲编码调至</p>\n<p>PDM (Pulse Density Modulation) 脉冲密度调制</p>\n<p>PDM modulator 脉冲密度调制器</p>\n<p><strong><em>module</em></strong> n. [计] 模块；组件；模数</p>\n<p><strong><em>monolithic</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˌmɒnəˈlɪθɪk/</span> <em>adj</em>. 整体的；巨石的，庞大的；完全统一的 <em>n</em>. 单块集成电路，单片电路</p>\n<blockquote>\n<p>monolithic diode 单片二极管</p>\n</blockquote>\n<p><strong><em>millennium</em></strong> <span style=\"color: #CCC; font-style: italic;\">/mɪˈleniəm/</span> <em>n</em>. 千年；千禧年</p>\n<p><strong><em>minimum addressable units</em></strong> 最小可寻址单元</p>\n<blockquote>\n<p>Memory allocation sizes are measured in \"Minimum Addressable Units\" (MAUs) of memory. An MAU is the smallest unit of data storage that can be read or written by the CPU.</p>\n</blockquote>\n<p><strong><em>miscellaneous</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˌmɪsəˈleɪniəs/</span> <em>adj</em>. 混杂的，各种各样的；多方面的，多才多艺的</p>\n<p>miscellaneous devices 杂项设备</p>\n<p>A be a <strong><em>multiple of</em></strong> B A应该是B的数倍</p>\n<blockquote>\n<p>To prevent unintended behavior \"blockPtr\" should be aligned on the cache line size and \"byteCnt\" should be a multiple of the cache line size.</p>\n</blockquote>\n<p><strong><em>multiplex</em></strong> <em>adj</em>. 多元的，多样的；多路传输的；<em>v</em>. 多路传输、多工</p>\n<blockquote>\n<p><strong><em>simplex</em></strong> 单工的</p>\n<p><strong><em>full-duplex</em></strong> 全双工</p>\n<p><strong><em>half-duplex</em></strong> 半双工</p>\n</blockquote>\n<blockquote>\n<p>transmission simplex 单工传输</p>\n<p>full-duplex communication 全双工通信</p>\n<p>full-duplex channel 全双工信道</p>\n<p>time division multiplex communication 时分多路通信</p>\n<p>time multiplexer communication channel 时分多路通信信道</p>\n<p>time-derived channel 时分通道、时分信道</p>\n</blockquote>\n<p><strong><em>multiplex up to</em></strong> 复用至xx</p>\n<blockquote>\n<p>The ePIE <em>multiplexes up to</em> sixteen peripheral interrupts into each CPU interrupt line.</p>\n</blockquote>\n<p><strong><em>mutual</em></strong> <span style=\"color: #CCC; font-style: italic;\">/'mju: tfuel/</span> exclusion 互斥</p>\n<blockquote>\n<p>Manages gates for mutual exclusion of shared resources by multiple processors and threads. 管理多个处理器和线程共享资源的互斥门。</p>\n</blockquote>\n<h1 id=\"n\">N</h1>\n<p><strong><em>noise cancelling headset</em></strong> 降噪耳机</p>\n<h1 id=\"o\">O</h1>\n<p><strong><em>octet</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ɔk'tet/</span> 八重、八位（计算机语境下，基本与byte同意）</p>\n<p><strong><em>on a</em></strong> + <em>adj</em>. + <strong><em>basis</em></strong> 在何种基础上</p>\n<blockquote>\n<p>You can reduce the amount of code space used by an application by setting the memory Policy on a global or per-module basis.</p>\n</blockquote>\n<p>register optimizations 寄存器优化</p>\n<p>local optimizations 本地优化</p>\n<p>global optimizations 全局优化</p>\n<p>interprocedure optimization 进程优化</p>\n<p><strong><em>other than</em></strong> .... 除了……</p>\n<blockquote>\n<p>Blue boxes identify modules for which your application will call C API functions <em>other than</em> those used to dynamically create objects.</p>\n</blockquote>\n<h1 id=\"p\">P</h1>\n<p>two <strong><em>parameter banks</em></strong> 参数集（参数组， two sets of parameters）</p>\n<blockquote>\n<p>There are two parameter banks available. Each bank can hold a full set of 160 parameters (32 filters × 5 coefficients).</p>\n</blockquote>\n<p>parasite <span style=\"color: #CCC; font-style: italic;\">/ˈpærəsaɪt/</span> <em>n</em>. 寄生虫</p>\n<p><strong><em>parasitic</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˌpærəˈsɪtɪk/</span> <em>adj</em>. 寄生的</p>\n<p>parasitical <em>adj</em>. 寄生的</p>\n<p><strong><em>channel parasitic input capacitance</em></strong> 通道寄生输入电容</p>\n<p><strong><em>parse</em></strong> <span style=\"color: #CCC; font-style: italic;\">/'pɑːz/</span> <em>v</em>.理解，从语法上分析，解析</p>\n<blockquote>\n<p>Parsing CGI Form Data 解析CGI结构的数据</p>\n</blockquote>\n<p>a <strong><em>particular heap implementation</em></strong> 特定堆生成</p>\n<blockquote>\n<p>Using Memory APIs makes applications and middleware portable and not tied to a particular heap implementation.</p>\n</blockquote>\n<p><strong><em>patched</em></strong> <span style=\"color: #CCC; font-style: italic;\">/pætʃt/</span> <em>adj</em>. 打补丁的 <em>v</em>. 打补丁；遮盖（视力好的眼）促进弱视眼看；（用补丁对程序）改错（patch 的过去式和过去分词）</p>\n<p><strong><em>be patched with</em></strong> <em>sth</em>. 用某物修补</p>\n<p><strong><em>period</em></strong> <em>n</em>. 周期</p>\n<p><strong><em>periodic</em></strong> <span style=\"color: #CCC; font-style: italic;\">/periɒdik/</span> <em>adj</em>. 周期的</p>\n<p><strong><em>perspective</em></strong> <em>n</em>. 观点；远景；透视图 <em>adj</em>. 透视的</p>\n<blockquote>\n<p>customize perspective 定制化的角度（来看）</p>\n</blockquote>\n<p><strong><em>phase</em></strong> n. 相位</p>\n<p>phase shifted 180 DEG 相位偏移180度</p>\n<p>phase relationship 相位关系</p>\n<p><em>sb./sth.</em> <strong><em>places certain restrictions on</em></strong> <em>sth. / sw.</em> 某物对某物产生影响</p>\n<blockquote>\n<p>Running the scheduler thread at a low priority places certain restrictions on how a Task can operate at the socket layer.</p>\n<p>以低优先级运行调度程序线程会对任务在套接字层上的操作方式产生某些限制。</p>\n</blockquote>\n<p>polar 北极</p>\n<p><strong><em>polarity</em></strong> <span style=\"color: #CCC; font-style: italic;\">/pəˈlærəti/</span> <em>n</em>. [物] 极性；两极；对立</p>\n<p><strong><em>signal polarity</em></strong> 信号极性</p>\n<p><strong><em>unipolar signal</em></strong> 单极信号（仅有零值和正值）</p>\n<p><strong><em>bipolar signal</em></strong> 双极信号（有正负值和零值）</p>\n<p><strong><em>populate</em></strong> v. 焊接</p>\n<p><strong><em>unpopulated header pads</em></strong> 未焊接点（盘）</p>\n<p>unpopulated PCB 无载印制电路板</p>\n<blockquote>\n<p><strong><em>solder</em></strong> <em>n</em>. 焊料；接合物 <em>v</em>. 焊接；使联接在一起</p>\n</blockquote>\n<blockquote>\n<p>To use an external speaker, wires can be <em>soldered</em> to the <em>unpopulated header pads</em>, J13 and J16.</p>\n<p>The R2 resistor is not populated from the factory. 在工厂时，R2电阻未安装。</p>\n</blockquote>\n<p><strong><em>port</em></strong> n. 接口，端口</p>\n<p><strong><em>portable</em></strong> adj. 便携的</p>\n<p><strong><em>portfolio</em></strong> <span style=\"color: #CCC; font-style: italic;\">/pɔːtˈfəʊliəʊ/</span> n. 公文包；文件夹；证券投资组合；部长职务；作品集；（公司或机构提供的）系列产品，系列服务；（职业类型）短期合同制的，兼职的</p>\n<p>broad portfolio 广泛的产品组合</p>\n<p><strong><em>potentiostat</em></strong> <span style=\"color: #CCC; font-style: italic;\">/pəu'tenʃiəstæt/</span> <em>n</em>. 恒电势器；[电] 稳压器</p>\n<p>potentiostatic <em>adj</em>. 电压稳定器的；恒电势的；电势恒定器的</p>\n<p><strong><em>potentiometer</em></strong> <span style=\"color: #CCC; font-style: italic;\">/pəˌtenʃiˈɒmɪtə(r)/</span> <em>n</em>. 电位计；分压计</p>\n<p>potentiometric <span style=\"color: #CCC; font-style: italic;\">/pəu,tenʃiə'metrik/</span> <em>adj</em>. 电势测定的，电位计的</p>\n<blockquote>\n<p>control interface: switches and <em>potentiometers</em> 控制接口：开关和电位器</p>\n</blockquote>\n<p><strong><em>precision</em></strong> 精度</p>\n<p><strong><em>single-precision</em></strong> 单精度</p>\n<p><strong><em>double-precision</em></strong> 双精度</p>\n<p>Single-precision biquad filter 单精度双四轴滤波器</p>\n<blockquote>\n<p>The double length memory enables the core to <em>double precision</em> arithmetic with double length data and single length coefficients.</p>\n</blockquote>\n<p><strong><em>precision sensing applications</em></strong> 精密传感应用</p>\n<blockquote>\n<p>They allow analog and digital sensing for interpreting capabilities with built-in ADCs, DACs, and temp sensors for precision sensing applications. 这些MCUs利用为紧密传感应用准备的内置模-数、数-模、温度传感器向模拟和数字传感提供解释能力。</p>\n<p>【这逻辑，我确实接受不来】</p>\n</blockquote>\n<p><strong><em>preempt</em></strong> 抢占</p>\n<blockquote>\n<p>All Clock functions run at the same SWI priority, so one Clock function cannot preempt another. 所有的时钟函数都运行在相同的SWI优先级，所以一个时钟函数不能抢占另一个时钟函数。</p>\n</blockquote>\n<p><strong><em>prefix</em></strong> n. 前缀 vt. 加前缀；将某事物加在前面</p>\n<p><strong><em>presume</em></strong> / <strong><em>assume</em></strong> 假定</p>\n<blockquote>\n<p>So this book <em>presumes</em> that you have already learned something about Python programming from the many excellent tutorials and books on the subject.</p>\n<p>On the other hand, this book does not start by <em>assuming</em> that you know any networking!</p>\n</blockquote>\n<p><strong><em>previous versions</em></strong> 以前的版本</p>\n<blockquote>\n<p>Note that the appropriate include file location has changed from previous versions of IPC. 注意，适当的头文件位置已经从以前的IPC版本中更改。</p>\n</blockquote>\n<p><strong><em>prologue</em></strong> <span style=\"color: #CCC; font-style: italic;\">/prəʊlɒg/</span> <em>n</em>. 开场白</p>\n<p><strong><em>prolong</em></strong> <span style=\"color: #CCC; font-style: italic;\">/prəˈlɒŋ/</span> <em>vt</em>. 延长，拖延</p>\n<blockquote>\n<p>they can then <em>prolong</em> the LOW period of the SCL signal to slow down the transfer. 可以延长SCL信号的低电平周期，以降低传输速度。</p>\n</blockquote>\n<p><strong><em>prior</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˈpraɪər/</span> adj. （时间、顺序等）先前的；优先的</p>\n<p><strong><em>priority</em></strong> n. 优先级</p>\n<p>prioritize <span style=\"color: #CCC; font-style: italic;\">/praɪˈɒrətaɪz/</span> v. 按优先顺序列出，确定 (任务) 优先顺序；优先处理，优先考虑</p>\n<p>prior to 在……之前； 居先</p>\n<blockquote>\n<p>It is important to enrich the soil prior to planting. 栽种之前给土壤施肥很重要。</p>\n</blockquote>\n<p><strong>probe</strong> <em>n</em>. 探针；调查 <em>vi</em>. 调查；探测 <em>vt</em>. 探查；用探针探测</p>\n<p><strong>simulation probe</strong> 模拟探针</p>\n<p>the <strong><em>proper adjustment</em></strong> 适当调整</p>\n<blockquote>\n<p>The scheduler thread can run at any priority with the proper adjustment.</p>\n<p>调度器线程经适当调整可以运行在任何优先级。</p>\n</blockquote>\n<h1 id=\"r\">R</h1>\n<p><strong><em>rate</em></strong> <em>n</em>. 速度；比率；价格；等级</p>\n<p><strong><em>rating</em></strong> <em>n</em>. 等级；等级评定；额定功率 <em>v</em>. 对…评价（rate的ing形式）</p>\n<p><strong><em>ratio</em></strong> <em>n</em>. 比率，比例</p>\n<p>rational <em>adj</em>. 合理的；理性的 <em>n</em>. 有理数</p>\n<blockquote>\n<p><strong>speed</strong> <em>n</em>. 速度，速率；进度；迅速；繁荣；感光度；排挡；<em>v</em>. 快速运动；加速；促进；</p>\n</blockquote>\n<blockquote>\n<p>The <em>rate</em> of the internal master clock must be set properly using the CC_MDIV bit in the clock control register (Address 0x0000). 内部主时钟的速率必须要在时钟控制寄存器下的CC_MDIV位上设置正确。</p>\n<p><em>rated</em> input voltage 额定输入电压</p>\n<p><em>rated</em> input current 额定输入电流</p>\n<p>flammability <em>rating</em> 可燃性等级</p>\n<p>absolute maximum <em>ratings</em> 最大功率</p>\n<p>ESD <em>ratings</em> 静电放电等级</p>\n<p>power supply rejection <em>ratio</em> 电源抑制比</p>\n<p>SNR（Signal-to-Noise Ratio） 信噪比</p>\n</blockquote>\n<p><strong><em>rectification</em></strong> <em>n</em>. 整流</p>\n<p><strong><em>recursive nature</em></strong> 递归性质</p>\n<blockquote>\n<p>Due to its recursive nature, a Task tends to consume a significant amount of stack.</p>\n<p>由于其递归性质，任务往往会消耗大量的堆栈。</p>\n</blockquote>\n<p><strong><em>re-entrance exclusion methodology</em></strong> 重连拒绝方法</p>\n<blockquote>\n<p>The NDK requires a re-entrance exclusion methodology to call into internal tack functions.</p>\n</blockquote>\n<p><strong><em>reentrant versions</em></strong> 可重入版本</p>\n<p>regular <em>adj</em>. 有规律的</p>\n<p>regulate <em>vt</em>. 调节；规定；控制；校准；有系统地管理</p>\n<p><strong><em>regulated voltage</em></strong> 稳定电压</p>\n<p><strong><em>regulator</em></strong> <em>n</em>. 监管机构，监管者；调整者；校准器；稳压器</p>\n<blockquote>\n<p>Typically, on such <em>regulators</em> the power good signal changes state when the regulated voltage drops below ~90% of its target value.</p>\n<p>通常只有在稳定电压低于规定目标的90%以下时，这些稳压器的良好信号才会改变状态。</p>\n</blockquote>\n<p><strong><em>on-board regulator</em></strong> 板载调节器</p>\n<blockquote>\n<p>The on-board regulator generates the 3.3 V dc or 1.8 V dc supply, determined by S1, for the on-board circuitry. 板载整流器为板载电流提供了由S1决定的1.8V或3.3V电压。</p>\n</blockquote>\n<p>LDO regulator （某种）线性稳压器？</p>\n<p><img src=\"https://pic.islet.space/2021/04/image-20210421160130520.png\" alt=\"image-20210421160130520\" style=\"zoom: 67%;\" /></p>\n<p>the <strong><em>remote processor</em></strong> 远程处理器</p>\n<blockquote>\n<p>The response from the remote processor triggers a hardware interrupt, which then posts a Semaphore to allow to Task to resume execution. 远程处理器的响应触发硬件中断，然后硬件中断发布一个信号量以允许任务继续执行。</p>\n</blockquote>\n<p><strong><em>power-on reset</em></strong> 开机复位</p>\n<p><strong><em>brownout reset</em></strong> 断电复位</p>\n<p>resistor n. 电阻器</p>\n<p><strong><em>resistance</em></strong> <em>n</em>. 电阻值；电阻</p>\n<p>constant resistance 恒定电阻</p>\n<p>insulation resistance 绝缘电阻</p>\n<p>damping resistor 阻尼电阻</p>\n<p>equivalent series resistance 等效串联电阻</p>\n<p><strong><em>ruggedness</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˈrʌɡɪdnəs/</span> <em>n</em>. 强度，坚固性；险峻，崎岖；粗野</p>\n<p><strong><em>high ruggedness</em></strong> 高坚固性</p>\n<p><strong><em>runtime support library</em></strong> 运行时支持库</p>\n<blockquote>\n<p>This module provides <code>xdc.runtime.ITimestampClient</code> APIs for the xdc Runtime Support Library.</p>\n</blockquote>\n<h1 id=\"s\">S</h1>\n<p><strong><em>sanity</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˈsænəti/</span> <em>n</em>. 明智；头脑清楚；精神健全；通情达理</p>\n<p><strong><em>saturate</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˈsætʃəreɪt/</span> vt. 使浸透；使饱和；使充满； adj. 浸透的；饱和的；</p>\n<p>saturation n. 饱和度</p>\n<blockquote>\n<p>Clear the X1CNT counter and then wait for it to saturate four times.</p>\n</blockquote>\n<p><strong><em>schematic</em></strong> <em>n</em>. 原理图</p>\n<p>second 秒</p>\n<p><strong><em>microsecond</em></strong> 微秒</p>\n<p><strong><em>millisecond</em></strong> 毫秒</p>\n<p><strong><em>nanosecond</em></strong> 纳秒</p>\n<p><strong><em>semaphore</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˈseməfɔːr/</span> <em>n</em>. 信号标，信标，旗语；臂板信号装置 <em>v</em>. 打旗语，发信号</p>\n<p><strong><em>sequence</em></strong> <em>n</em>. 顺序</p>\n<p>text sequences 文本序列</p>\n<p><strong><em>ship</em></strong>(<em>v.</em>) <strong><em>with</em></strong> 与某物一起（类似于打包在一起）</p>\n<blockquote>\n<p>The fact that you will often be using Python libraries of prepared code—whether from the built-in standard library that ships with Python.</p>\n</blockquote>\n<p><strong><em>shunt</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ʃʌnt/</span> <em>v</em>. <em>n</em>. 并励；并联；分流</p>\n<p><strong><em>signal path</em></strong> 信号通路，信号路径</p>\n<p>a <strong><em>significant amount of</em></strong> 大量的</p>\n<p><strong><em>single-address mode</em></strong> 单地址模式</p>\n<p><strong><em>single-word mode</em></strong> 单字模式</p>\n<p><strong><em>burst mode</em></strong> 突发模式/爆发模式</p>\n<blockquote>\n<p>All addresses can be accessed in either single-address mode or burst mode.</p>\n</blockquote>\n<p><strong><em>sophisticated services</em></strong> 复杂的服务</p>\n<blockquote>\n<p>The idea of a <em>protocol stack</em>, in which very simple network services are used as a foundation on which to build more sophisticated services.</p>\n</blockquote>\n<p><strong><em>specification</em></strong> <em>n</em>. 规范 (a detailed description of design criteria for a piece of work)</p>\n<blockquote>\n<p>specifications for benchmark tests 基准测试规范</p>\n</blockquote>\n<p><strong><em>target-specific functions</em></strong> 目标特定的功能</p>\n<blockquote>\n<p>device-specific functions 设备特定的功能</p>\n</blockquote>\n<p><strong><em>split</em></strong> <span style=\"color: #CCC; font-style: italic;\">/splɪt/</span> <em>vt</em>. 分离；使分离；劈开；离开；分解 <em>vi</em>. 离开；被劈开；断绝关系 <em>n</em>. 劈开；裂缝 adj. 劈开的</p>\n<p><strong><em>stage changed</em></strong> （确认）暂存（数据）已变化</p>\n<p><strong><em>standalone operation</em></strong> 独立操作</p>\n<blockquote>\n<p>For <em>standalone operation</em>, the clock can be generated using the on-board crystal oscillator.</p>\n</blockquote>\n<p><strong><em>static inline</em></strong> 静态内联</p>\n<p><strong><em>stimuli</em></strong> <em>n</em>. 刺激；刺激物；促进因素（stimulus的复数）</p>\n<p><strong><em>simulation stimuli</em></strong> 模拟刺激</p>\n<p>at a <strong><em>strategic point in time</em></strong> 在战略性的时间点上 / 在关键时间点上 / 在关键时刻</p>\n<p><strong><em>support a myriad of</em></strong> <em>sth</em>. 支持各种各样的....</p>\n<blockquote>\n<p>Our Processors and Microcontrollers support a myriad of general-purpose and application-specific needs. 我们的处理器和微控制器能够满足各种各样的通用或特定需求。</p>\n</blockquote>\n<p><strong><em>suppress</em></strong> vt. 抑制；镇压；废止</p>\n<p><strong><em>suppression</em></strong> n. 抑制；镇压；[植] 压抑</p>\n<blockquote>\n<p>Pop-and-Click Suppression 音频杂音（嘀嗒和爆破）抑制</p>\n<p>pop suppression 爆破（音）抑制</p>\n</blockquote>\n<h1 id=\"t\">T</h1>\n<p>temperature n. 温度</p>\n<p><strong><em>junction temperature</em></strong> （T<sub>j</sub>）结温；接点温度；接面温度</p>\n<p>operating junction temperature 运行时结温</p>\n<p>free-Air temperature 大气温度；</p>\n<p>storage temperature 存储温度</p>\n<p>ambient temperature （T<sub>A</sub>）环境温度</p>\n<p><strong><em>terminate</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˈtɜːmɪneɪt/</span> vi./vt. 使终止；使结束；解雇</p>\n<p><strong><em>timing</em></strong> <em>n</em>. 时序</p>\n<blockquote>\n<p>the timing of a burst mode write sequence 突发模式写入顺序时间（时序）</p>\n</blockquote>\n<p><strong><em>toggle</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˈtɒɡl/</span> <em>n</em>. 拴扣；切换键，开关；套索钉 <em>v</em>. 切换；拴牢，系紧</p>\n<blockquote>\n<p>toggle split editor 切换分屏编辑器</p>\n<p>toggle full screen 切换全屏幕</p>\n<p>toggle function 切换函数</p>\n</blockquote>\n<p><strong><em>tolerable</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˈtɒlərəbl/</span> <em>adj</em>. 可以的；可容忍的</p>\n<blockquote>\n<p>tolerable settling error 可容忍的沉降误差</p>\n</blockquote>\n<p><strong><em>torque</em></strong> <span style=\"color: #CCC; font-style: italic;\">/tɔːk/</span> n. 转矩，[力] 扭矩；项圈，金属领圈 v. (向轴、螺栓、圆轮等)施以扭动力；(使)沿轴转动；使(绕轴等)扭转；施加转矩</p>\n<p><strong><em>trench</em></strong> <em>n</em>. 沟渠、沟道</p>\n<p><strong>trim</strong> v. 修剪；切除 <em>n</em>. 点缀物；汽车装饰；修剪 <em>adj</em>. 整齐的；身材苗条的</p>\n<blockquote>\n<p>offset trim register 偏移修整寄存器</p>\n</blockquote>\n<p><strong><em>trip</em></strong> <em>n</em>. （短程）旅行；幻觉；绊倒；错误；令人兴奋的经历；自我放纵的态度（或行动）；（机器、电路的）开关；（安全装置的）脱扣；轻捷的脚步；让人开心的奇人，奇妙有趣的经历 <em>vi</em>. 绊倒，跌倒；轻快地走（或跑、跳舞）；（非正式）（服用毒品后）产生幻觉；（部分电路）自动断开；作短途旅行 <em>vt</em>. 绊倒；（使）跌倒；触发（开关）；起（锚）；竖起（帆桁）</p>\n<p><strong><em>tristate</em></strong> <em>n</em>. 三角洲的</p>\n<p>tristate buffer 三态缓冲器</p>\n<p>tristate control 三态控制</p>\n<p><strong><em>truncate</em></strong> <em>vt</em>. 截断</p>\n<blockquote>\n<p>Fractional values are truncated. 小数值已省略。/ 忽略小数部分</p>\n</blockquote>\n<h1 id=\"u\">U</h1>\n<p><strong><em>use</em></strong> <em>sth.</em> <strong><em>from</em></strong> <em>sb.</em>/<em>sth.</em></p>\n<blockquote>\n<p>In earlier versions of gnuplot, some terminal types used the values from 'set size' to control also the size of the output canvas.</p>\n<p>在gnuplot的早期版本中，一些终端类型使用set size中的值来控制输出画布的大小。</p>\n</blockquote>\n<p><strong><em>be used in a variety of combinations</em></strong> 被用于多种组合</p>\n<blockquote>\n<p>IPC modules can be used in variety of combinations.</p>\n</blockquote>\n<h1 id=\"v\">V</h1>\n<p><strong><em>versatility</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˌvɜːsəˈtɪləti/</span> n. 多功能性；多才多艺；用途广泛</p>\n<p><strong><em>volatile</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˈvɒlətaɪl/</span> <em>adj</em>. [化学] 挥发性的；不稳定的；爆炸性的；反复无常的 <em>n</em>. 挥发物；有翅的动物</p>\n<p>volatile unsigned int</p>\n<h1 id=\"w\">W</h1>\n<p><strong><em>welding</em></strong> <em>v</em>. 焊接；（使）紧密结合，成整体；焊接（物件）；（通过熔化或软化）连接（weld 的现在分词）<em>n</em>. 焊接，锻接</p>\n<p>withstand</p>\n<p>voltage withstand 耐电压</p>\n<p><strong><em>wrapper function</em></strong> 包装函数</p>\n<h1 id=\"z\">Z</h1>\n<p><strong><em>zero out</em></strong> 清零</p>\n<blockquote>\n<p>Zero out structure object. 清空结构体对象</p>\n</blockquote>\n<h1 id=\"近意之词\">近意之词</h1>\n<h2 id=\"level\">level</h2>\n<p>level 有 <code>层级</code>、 <code>等级</code> 、<code>电平</code>、<code>水平</code> 之意，较难区分。</p>\n<p><strong>等级</strong>：relative stack priority level 相对堆栈优先（等）级</p>\n<blockquote>\n<p>The below options allow you to set the scheduler's relative stack priority level and run mode.</p>\n<p>下列设置允许你调整调度器的相对堆栈优先级和运行模式。</p>\n</blockquote>\n<p><strong>电平</strong>：full-scale level 满量程电平</p>\n<p>logic-level 逻辑电平</p>\n<blockquote>\n<p>Therefore, the full-scale level of a signal in the processing core will be slightly different from a full-scale level external to the IC.</p>\n</blockquote>\n<h2 id=\"独立\">独立</h2>\n<p>以下的词汇都具有 “分别的，独立的“之意</p>\n<p>individual</p>\n<p>respective</p>\n<p>separated</p>\n<h2 id=\"术语\">术语</h2>\n<p><strong><em>nomenclature</em></strong> <span style=\"color: #CCC; font-style: italic;\">/nəˈmeŋklətʃə(r)/</span> <em>n</em>. 命名法；术语</p>\n<p><strong><em>glossary</em></strong> <em>n</em>. 术语</p>\n<p><strong><em>terminology</em></strong> <em>n</em>. 术语，术语学；用辞</p>\n<p><strong><em>term</em></strong> <em>n</em>. 术语；学期；期限；条款；(代数式等的)项 <em>vt</em>. 把…叫做</p>\n<h2 id=\"时钟\">时钟</h2>\n<p><strong><em>clock oscillator</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ˈɒsɪleɪtə(r)/</span> 时钟振荡器</p>\n<p><strong><em>internal oscillator</em></strong> 内部振荡器</p>\n<p><strong><em>external oscillator</em></strong> 外部振荡器</p>\n<p><strong><em>crystal oscillator</em></strong> 晶体振荡器</p>\n<p><strong><em>quartz crystal</em></strong> 石英晶振</p>\n<p><strong><em>external resonator</em></strong> 外部谐振器</p>\n<h2 id=\"程序\">程序</h2>\n<p>以下单词都具有程序/代码的意思</p>\n<p>program</p>\n<p>procedure</p>\n<p>routine</p>\n<p>code</p>\n<p>utilities <span style=\"color: #CCC; font-style: italic;\">/juː'tɪlɪtɪz/</span> <em>n</em>. 实用程序</p>\n<h2 id=\"器件\">器件</h2>\n<p>switching regulator 开关整流器</p>\n<p>voltage regulator 稳压器</p>\n<p>limiter 限幅器</p>\n<p>interpolator power 插值器功率</p>\n<p>decimator power 切割器功率</p>\n<p>capture 捕获器</p>\n<p>pulse width modulator 脉冲幅频调制器</p>\n<p>quadrature encoder 正交编码器</p>\n<p>quadrature encoder pulse 正交编码器脉冲</p>\n<p>sigma-delta filter module 西格玛-德尔塔滤波器模块</p>\n<p>oscilloscope n. 示波器</p>\n<p>co-processor 协处理器</p>\n<p>modulator ADC 调制器</p>\n<p>coupling capacitor 耦合电容器</p>\n<p>discrete devices 分立器件</p>\n<p>optoelectronic <span style=\"color: #CCC; font-style: italic;\">/ˌɒptəʊɪlekˈtrɒnɪks/</span> devices 光电子器件</p>\n<h2 id=\"线路\">线路</h2>\n<p>以下词汇均有 \"<strong>线路</strong>\" 之意：</p>\n<p>line</p>\n<p>wire</p>\n<p>trace</p>\n<p>cable</p>\n<p>connect the audio cables 连接音频电缆</p>\n<p>wider trace 更宽的线路、更宽的导线</p>\n<blockquote>\n<p>If the headphone amplifiers are enabled, the PCB trace to this pin should be wider than traces to other pins to increase the current carrying capacity. A wider trace should also be used for the headphone output lines.</p>\n</blockquote>\n<h2 id=\"半导体\">半导体</h2>\n<p><strong><em>thyristor</em></strong> <span style=\"color: #CCC; font-style: italic;\">/'θaɪrɪstə/</span> n. 半导体闸流管</p>\n<p><strong><em>diode</em></strong> <em>n</em>. 二极管</p>\n<p><strong><em>collector</em></strong> <em>n</em>. 集电极</p>\n<p><strong><em>emitter</em></strong> <span style=\"color: #CCC; font-style: italic;\">/ɪˈmɪtə(r)/</span> <em>n</em>. 发射器，发射体，发射极</p>\n<p><strong><em>gate</em></strong> <em>n</em>. 栅极</p>\n<p>collector-emitter voltage 集电极-发射极电压</p>\n<p>collector-emitter breakdown voltage 集电极和发射极的击穿电压</p>\n<p>collector-emitter saturation voltage 集电极和发射极的饱和电压</p>\n<p>gate-emitter voltage 栅极发射极电压</p>\n<p>gate-emitter threshold voltage 栅极和发射极的阈值电压</p>\n<p>gate-emitter leakage current</p>\n<p>pulsed collector current 脉冲（瞬时）集电极电流</p>\n<p>High voltage gate driver IC 高电压栅极驱动芯片</p>\n<p>600 V half bridge gate drive IC 600V半桥栅极驱动芯片</p>\n","categories":["Others"],"tags":["Phrases"]},{"title":"LaTex公式入门","url":"/2021/08/21/Others/2021-08-21-LaTex%E5%85%AC%E5%BC%8F%E5%85%A5%E9%97%A8/","content":"<p>[TOC]</p>\n<h1 id=\"公式书写\">公式书写</h1>\n<p>Typora虽然是支持Markdown出名，但是也支持LaTex公式，需要在Typora的设置中打开相关选项</p>\n<h2 id=\"typora设置\">Typora设置</h2>\n<ol type=\"1\">\n<li><p>在Typora的偏好设置 下，选择 Markdown 选项，勾选 <code>內联公式（例：$\\LaTeX$）</code> 选项和 <code>自动添加序号</code> 选项（此项可不选）</p></li>\n<li><p>在 “<strong>当复制或导出为无格式的HTML时</strong>” 选择 “<strong>使用LaTeX代码</strong>”</p></li>\n</ol>\n<p><img src=\"https://pic.islet.space/2021/09/image-20210904111919668.png\" alt=\"image-20210904111919668\" style=\"zoom:80%;\" /></p>\n<h2 id=\"书写方法\">书写方法</h2>\n<p>设置完毕后，即可进入公式书写。</p>\n<p>在使用Typora的Markdown语法来编辑LaTex公式，本身LaTex就与Markdown语法存在一定的冲突，但在Pandoc（Typora使用的效果渲染器）的加持下，显示效果较好，但公式写得多了或者书写过程中可能仍会存在一定的显示延迟（解决办法是：暂时没有）。</p>\n<p>以下全程默认使用Typora编辑器。</p>\n<p>使用LaTex支持两种书写方式，<strong>行模式</strong> 和 <strong>块模式</strong> ，对应的通用叫法是 <strong>内联公式</strong>（行内公式，inline） 和 <strong>块公式</strong>（block）。这里需要一点HTML5的知识，就是该公式是可以被存放在文字中间的，还是独占一行的，存放在文字中间的叫 <strong>内联</strong>，如 <span class=\"math inline\">\\(f(x)=x^2\\)</span> ，独占一行的叫 <strong>块</strong>，如： <span class=\"math display\">\\[\nf(x)= \\lambda e^{-\\lambda x} \\tag{样例公式}\n\\]</span></p>\n<h3 id=\"内联公式\">内联公式</h3>\n<p>书写内联公式时，只需要在同一行文字内书写两个美元符号 <code>$$</code> ，然后再两个美元符号中间书写内容即可。</p>\n<p>尝试复制粘贴右侧文字到typora吧： <code>$f(x)= x^2$</code>​</p>\n<h3 id=\"块公式\">块公式</h3>\n<p>块公式需要在独占一行时书写 <code>$$</code>，然后按回车键，即可进入块编辑模式，编辑框如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210904113516554.png\" alt=\"image-20210904113516554\" /><figcaption aria-hidden=\"true\">image-20210904113516554</figcaption>\n</figure>\n<p>不管是内联公式还是快公式都是支持实时编辑和实时显示的。</p>\n<h1 id=\"基础符号\">基础符号</h1>\n<table>\n<thead>\n<tr class=\"header\">\n<th>中文</th>\n<th>样式</th>\n<th>语法</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>上标</td>\n<td><span class=\"math inline\">\\(X^2\\)</span><br><span class=\"math inline\">\\(X^{log(10)}\\)</span></td>\n<td>X<sup>2<br>X</sup>{log(10)}</td>\n</tr>\n<tr class=\"even\">\n<td>下标</td>\n<td><span class=\"math inline\">\\(X_i\\)</span><br><span class=\"math inline\">\\(X_{a-b}\\)</span></td>\n<td><code>X_i</code> 和 <code>X_&#123;a-b&#125;</code></td>\n</tr>\n<tr class=\"odd\">\n<td>积分符号</td>\n<td><span class=\"math inline\">\\(\\int\\)</span></td>\n<td><code>\\int</code></td>\n</tr>\n<tr class=\"even\">\n<td>无限</td>\n<td><span class=\"math inline\">\\(\\infin\\)</span></td>\n<td><code>\\infin</code></td>\n</tr>\n<tr class=\"odd\">\n<td>平均值符号</td>\n<td><span class=\"math inline\">\\(\\overline x\\)</span></td>\n<td><code>\\overline x</code></td>\n</tr>\n<tr class=\"even\">\n<td>帽子符号</td>\n<td><span class=\"math inline\">\\(\\hat{a}\\)</span></td>\n<td><code>\\hat&#123;a&#125;</code></td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td><span class=\"math inline\">\\(\\widehat{a}\\)</span></td>\n<td><code>\\widehat&#123;a&#125;</code></td>\n</tr>\n<tr class=\"even\">\n<td></td>\n<td><span class=\"math inline\">\\(\\acute{a}\\)</span></td>\n<td><code>\\acute&#123;a&#125;</code></td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td><span class=\"math inline\">\\(\\grave{a}\\)</span></td>\n<td><code>\\grave&#123;a&#125;</code></td>\n</tr>\n<tr class=\"even\">\n<td></td>\n<td><span class=\"math inline\">\\(\\bar{a}\\)</span></td>\n<td><code>\\bar&#123;a&#125;</code></td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td><span class=\"math inline\">\\(\\dot{a}\\)</span></td>\n<td><code>\\dot&#123;a&#125;</code></td>\n</tr>\n<tr class=\"even\">\n<td></td>\n<td><span class=\"math inline\">\\(\\ddot{a}\\)</span></td>\n<td><code>\\ddot&#123;a&#125;</code></td>\n</tr>\n<tr class=\"odd\">\n<td>短波浪号</td>\n<td><span class=\"math inline\">\\(\\tilde{A_2}\\)</span></td>\n<td><code>\\tilde&#123;A_2&#125;</code></td>\n</tr>\n<tr class=\"even\">\n<td>长波浪号</td>\n<td><span class=\"math inline\">\\(\\widetilde{A_2}\\)</span></td>\n<td><code>\\widetilde&#123;A_2&#125;</code></td>\n</tr>\n<tr class=\"odd\">\n<td>上左箭头</td>\n<td><span class=\"math inline\">\\(\\overleftarrow{N}\\)</span></td>\n<td><code>\\overleftarrow&#123;N&#125;</code></td>\n</tr>\n<tr class=\"even\">\n<td>上右箭头</td>\n<td><span class=\"math inline\">\\(\\overrightarrow{N}\\)</span></td>\n<td><code>\\overrightarrow&#123;N&#125;</code></td>\n</tr>\n<tr class=\"odd\">\n<td>下左箭头</td>\n<td><span class=\"math inline\">\\(\\underleftarrow{N}\\)</span>​</td>\n<td><code>\\underleftarrow&#123;N&#125;</code></td>\n</tr>\n<tr class=\"even\">\n<td>下右箭头</td>\n<td><span class=\"math inline\">\\(\\underrightarrow{N}\\)</span>​</td>\n<td><code>\\underrightarrow&#123;N&#125;</code></td>\n</tr>\n<tr class=\"odd\">\n<td>限制下标</td>\n<td><span class=\"math inline\">\\(\\mathop{a}\\limits_{i=1}\\)</span></td>\n<td><code>\\mathop&#123;a&#125;\\limits_&#123;i=1&#125;</code></td>\n</tr>\n<tr class=\"even\">\n<td>分子式</td>\n<td><span class=\"math inline\">\\(\\frac{1}{2}\\)</span></td>\n<td><code>\\frac&#123;1&#125;&#123;2&#125;</code></td>\n</tr>\n<tr class=\"odd\">\n<td>根号</td>\n<td><span class=\"math inline\">\\(\\sqrt{2\\pi}\\)</span></td>\n<td><code>\\sqrt&#123;2\\pi&#125;</code></td>\n</tr>\n<tr class=\"even\">\n<td>求和符号</td>\n<td><span class=\"math inline\">\\(\\sum\\)</span></td>\n<td><code>\\sum</code></td>\n</tr>\n<tr class=\"odd\">\n<td>三角符号</td>\n<td><span class=\"math inline\">\\(\\triangle\\)</span></td>\n<td><code>\\triangle</code></td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"块公式样例\">块公式样例</h1>\n<p>直接复制代码框中的内容到typora即可。</p>\n<h2 id=\"样例1\">样例1</h2>\n<p><span class=\"math display\">\\[\nf(x) = \\left\\{ \n\\displaylines{\\lambda e^{-\\lambda x}, x ≥ 0\\\\ 0,x &lt; 0} \n\\right. \\tag{指数分布密度函数}\n\\]</span></p>\n<figure class=\"highlight latex\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">$</span><span class=\"built_in\">$</span></span><br><span class=\"line\">f(x) = <span class=\"keyword\">\\left</span><span class=\"keyword\">\\&#123;</span> </span><br><span class=\"line\"><span class=\"keyword\">\\displaylines</span>&#123;<span class=\"keyword\">\\lambda</span> e<span class=\"built_in\">^</span>&#123;-<span class=\"keyword\">\\lambda</span> x&#125;, x ≥ 0<span class=\"keyword\">\\\\</span> 0,x &lt; 0&#125; </span><br><span class=\"line\"><span class=\"keyword\">\\right</span>. <span class=\"keyword\">\\tag</span>&#123;指数分布密度函数&#125;</span><br><span class=\"line\"><span class=\"built_in\">$</span><span class=\"built_in\">$</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"样例2\">样例2</h2>\n<p><span class=\"math display\">\\[\nF(x) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\int^x_0 \\frac{1}{t} e^{-{(lnt-\\mu)^2}/{2\\sigma^2}} \\ dt \\tag{对数正态累积分布函数}\n\\]</span></p>\n<figure class=\"highlight latex\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">$</span><span class=\"built_in\">$</span></span><br><span class=\"line\">F(x) = <span class=\"keyword\">\\frac</span>&#123;1&#125;&#123;<span class=\"keyword\">\\sigma</span> <span class=\"keyword\">\\sqrt</span>&#123;2<span class=\"keyword\">\\pi</span>&#125;&#125; <span class=\"keyword\">\\int</span><span class=\"built_in\">^</span>x<span class=\"built_in\">_</span>0 <span class=\"keyword\">\\frac</span>&#123;1&#125;&#123;t&#125; e<span class=\"built_in\">^</span>&#123;-&#123;(lnt-<span class=\"keyword\">\\mu</span>)<span class=\"built_in\">^</span>2&#125;/&#123;2<span class=\"keyword\">\\sigma</span><span class=\"built_in\">^</span>2&#125;&#125; <span class=\"keyword\">\\ </span>dt <span class=\"keyword\">\\tag</span>&#123;对数正态累积分布函数&#125;</span><br><span class=\"line\"><span class=\"built_in\">$</span><span class=\"built_in\">$</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"样例3\">样例3</h2>\n<p><span class=\"math display\">\\[\n\\varphi(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-{(x-\\mu)^2}/{2\\sigma^2}} \\tag{正态密度函数}\n\\]</span></p>\n<figure class=\"highlight latex\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">$</span><span class=\"built_in\">$</span></span><br><span class=\"line\"><span class=\"keyword\">\\varphi</span>(x) = <span class=\"keyword\">\\frac</span>&#123;1&#125;&#123;<span class=\"keyword\">\\sigma</span><span class=\"keyword\">\\sqrt</span>&#123;2<span class=\"keyword\">\\pi</span>&#125;&#125;e<span class=\"built_in\">^</span>&#123;-&#123;(x-<span class=\"keyword\">\\mu</span>)<span class=\"built_in\">^</span>2&#125;/&#123;2<span class=\"keyword\">\\sigma</span><span class=\"built_in\">^</span>2&#125;&#125; <span class=\"keyword\">\\tag</span>&#123;正态密度函数&#125;</span><br><span class=\"line\"><span class=\"built_in\">$</span><span class=\"built_in\">$</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"希腊字母\">希腊字母</h1>\n<p>整理了常用的希腊字母及其Latex书写方式。</p>\n<p>LaTex书写希腊字母时都是使用 <strong>转义字符</strong> 进行的，即 <code>\\</code> + <code>对应的英文</code> 。</p>\n<p>如果需要表现大写希腊字母，则对应英文的首字母大写，否则就用小写。</p>\n<p>需要注意的是，<em>epsilon</em> 和 <em>phi</em> 有额外的符号，所以会有额外的写法，如下方表格所示。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>序号</th>\n<th>大写</th>\n<th>LATEX</th>\n<th>小写</th>\n<th>LATEX</th>\n<th>英文</th>\n<th>国际音标[推荐]</th>\n<th>汉字注音</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>1</td>\n<td>Α</td>\n<td><code>$Alpha$</code></td>\n<td>α</td>\n<td><code>$alpha$</code></td>\n<td>alpha</td>\n<td>/'ælfə/</td>\n<td>阿尔法</td>\n</tr>\n<tr class=\"even\">\n<td>2</td>\n<td>Β</td>\n<td><code>$Beta$</code></td>\n<td>β</td>\n<td><code>$beta$</code></td>\n<td>beta</td>\n<td>/'bi:tə/或/'beɪtə/</td>\n<td>贝塔/毕塔</td>\n</tr>\n<tr class=\"odd\">\n<td>3</td>\n<td>Γ</td>\n<td><code>$Gamma$</code></td>\n<td>γ</td>\n<td><code>$gamma$</code></td>\n<td>gamma</td>\n<td>/'gæmə/</td>\n<td>伽玛/甘玛</td>\n</tr>\n<tr class=\"even\">\n<td>4</td>\n<td>Δ</td>\n<td><code>$Delta$</code></td>\n<td>δ</td>\n<td><code>$delta$</code></td>\n<td>delta</td>\n<td>/'deltə/</td>\n<td>德尔塔/岱欧塔</td>\n</tr>\n<tr class=\"odd\">\n<td>5</td>\n<td>Ε</td>\n<td><code>$Epsilon$</code></td>\n<td>ε</td>\n<td><code>$epsilon$</code></td>\n<td>epsilon</td>\n<td>/'epsɪlɒn/</td>\n<td>艾普西龙</td>\n</tr>\n<tr class=\"even\">\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td><code>$varepsilon$</code></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>6</td>\n<td>Ζ</td>\n<td><code>$Zeta$</code></td>\n<td>ζ</td>\n<td><code>$zeta$</code></td>\n<td>zeta</td>\n<td>/'zi:tə/</td>\n<td>泽塔</td>\n</tr>\n<tr class=\"even\">\n<td>7</td>\n<td>Η</td>\n<td><code>$Eta$</code></td>\n<td>η</td>\n<td><code>$eta$</code></td>\n<td>eta</td>\n<td>/'i:tə/</td>\n<td>伊塔/诶塔</td>\n</tr>\n<tr class=\"odd\">\n<td>8</td>\n<td>Θ</td>\n<td><code>$Theta$</code></td>\n<td>θ</td>\n<td><code>$theta$</code></td>\n<td>theta</td>\n<td>/'θi:tə/</td>\n<td>西塔</td>\n</tr>\n<tr class=\"even\">\n<td>9</td>\n<td>Ι</td>\n<td><code>$Iota$</code></td>\n<td>ι</td>\n<td><code>$iota$</code></td>\n<td>iota</td>\n<td>/aɪ'əʊtə/</td>\n<td>埃欧塔</td>\n</tr>\n<tr class=\"odd\">\n<td>10</td>\n<td>Κ</td>\n<td><code>$Kappa$</code></td>\n<td>κ</td>\n<td><code>$kappa$</code></td>\n<td>kappa</td>\n<td>/'kæpə/</td>\n<td>堪帕</td>\n</tr>\n<tr class=\"even\">\n<td>11</td>\n<td>∧</td>\n<td><code>$Lambda$</code></td>\n<td>λ</td>\n<td><code>$lambda$</code></td>\n<td>lambda</td>\n<td>/'læmdə/</td>\n<td>兰姆达</td>\n</tr>\n<tr class=\"odd\">\n<td>12</td>\n<td>Μ</td>\n<td><code>$Mu$</code></td>\n<td>μ</td>\n<td><code>$mu$</code></td>\n<td>mu</td>\n<td>/mju:/</td>\n<td>谬/穆</td>\n</tr>\n<tr class=\"even\">\n<td>13</td>\n<td>Ν</td>\n<td><code>$Nu$</code></td>\n<td>ν</td>\n<td><code>$nu$</code></td>\n<td>nu</td>\n<td>/nju:/</td>\n<td>拗/奴</td>\n</tr>\n<tr class=\"odd\">\n<td>14</td>\n<td>Ξ</td>\n<td><code>$Xi$</code></td>\n<td>ξ</td>\n<td><code>$xi$</code></td>\n<td>xi</td>\n<td>希腊:/ksi/英美:/ˈzaɪ/或/ˈksaɪ/</td>\n<td>可西/赛</td>\n</tr>\n<tr class=\"even\">\n<td>15</td>\n<td>Ο</td>\n<td><code>$Omicron$</code></td>\n<td>ο</td>\n<td><code>$omicron$</code></td>\n<td>omicron</td>\n<td>/əuˈmaikrən/或/ˈɑmɪˌkrɑn/</td>\n<td>欧(阿~)米可荣</td>\n</tr>\n<tr class=\"odd\">\n<td>16</td>\n<td>∏</td>\n<td><code>$Pi$</code></td>\n<td>π</td>\n<td><code>$pi$</code></td>\n<td>pi</td>\n<td>/paɪ/</td>\n<td>派</td>\n</tr>\n<tr class=\"even\">\n<td>17</td>\n<td>Ρ</td>\n<td><code>$Rho$</code></td>\n<td>ρ</td>\n<td><code>$rho$</code></td>\n<td>rho</td>\n<td>/rəʊ/</td>\n<td>柔/若</td>\n</tr>\n<tr class=\"odd\">\n<td>18</td>\n<td>∑</td>\n<td><code>$Sigma$</code></td>\n<td>σ</td>\n<td><code>$sigma$</code></td>\n<td>sigma</td>\n<td>/'sɪɡmə/</td>\n<td>西格玛</td>\n</tr>\n<tr class=\"even\">\n<td>19</td>\n<td>Τ</td>\n<td><code>$Tau$</code></td>\n<td>τ</td>\n<td><code>$tau$</code></td>\n<td>tau</td>\n<td>/tɔ:/或/taʊ/</td>\n<td>套/驼</td>\n</tr>\n<tr class=\"odd\">\n<td>20</td>\n<td>Υ</td>\n<td><code>$Upsilon$</code></td>\n<td>υ</td>\n<td><code>$upsilon$</code></td>\n<td>upsilon</td>\n<td>/ˈipsilon/或/ˈʌpsɨlɒn/</td>\n<td>宇(阿~)普西龙</td>\n</tr>\n<tr class=\"even\">\n<td>21</td>\n<td>Φ</td>\n<td><code>$Phi$</code></td>\n<td>φ</td>\n<td><code>$varphi$</code></td>\n<td>phi</td>\n<td>/faɪ/</td>\n<td>弗爱/弗忆</td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td><code>$phi$</code></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>22</td>\n<td>Χ</td>\n<td><code>$chi$</code></td>\n<td>χ</td>\n<td><code>$chi$</code></td>\n<td>chi</td>\n<td>/kaɪ/</td>\n<td>凯/柯义</td>\n</tr>\n<tr class=\"odd\">\n<td>23</td>\n<td>Ψ</td>\n<td><code>$Psi$</code></td>\n<td>ψ</td>\n<td><code>$psi$</code></td>\n<td>psi</td>\n<td>/psaɪ/</td>\n<td>赛/普赛/普西</td>\n</tr>\n<tr class=\"even\">\n<td>24</td>\n<td>Ω</td>\n<td><code>$Omega$</code></td>\n<td>ω</td>\n<td><code>$omega$</code></td>\n<td>omega</td>\n<td>/'əʊmɪɡə/或/oʊ'meɡə/</td>\n<td>欧米伽/欧枚嘎</td>\n</tr>\n</tbody>\n</table>\n","categories":["Others"],"tags":["LaTex"]},{"title":"可靠性工程师笔记","url":"/2021/08/31/Others/2021-08-31-%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AE%B0/","content":"<h1 id=\"可靠性概论\">可靠性概论</h1>\n<p>只有在图纸设计阶段就考虑到使用场景时遇到的问题，再按图生产，才能制造出合格的产品。</p>\n<blockquote>\n<ul>\n<li>1950年12月7日，美国电子设备可靠性专门委员会成立。</li>\n<li>1952年8月21日，电子设备可靠性咨询组（AGREE）成立。</li>\n<li>1953年，美国兰德公司给出衡量武器系统优劣的七项参数：性能、可靠性、精度、易损性、可操作性、维修性和可用性。</li>\n<li>1957年6月，AGREE发表《军用电子设备可靠性》研究报告。</li>\n</ul>\n</blockquote>\n<p>可靠性工程这门学科被认为是自1957年问世的。</p>\n<p>1957年6月，AGREE发表的《军用电子设备可靠性》研究报告中，提出一套可靠性设计、试验及管理方法，形成了一套完善的可靠性设计、试验和管理标准。并在新一代产品的研制中，逐渐制定了较为完善的可靠性大纲，规定了定量的可靠性要求，进行了可靠性分配及预计、故障模式及影响分析（FMEA）和故障树分析（FTA），采用了冗余设计，开展了可靠性鉴定试验、验收试验和老炼试验，进行了可靠性评审等。</p>\n<blockquote>\n<ul>\n<li>1970年代，可靠性发展步入成熟阶段。</li>\n<li>1980年，美国国防部颁布《（D0DD 5000.40）可靠性及维修性》。</li>\n<li>1985年，美国空军推行“可靠性及维修性2000年行动计划”（R&amp;M2000），提出了“可靠性翻一番，维修性减半”的目标。</li>\n</ul>\n</blockquote>\n<h2 id=\"可靠性定义\">可靠性定义</h2>\n<p><strong>可靠性</strong> 是指产品在 <strong>规定条件下</strong> 和 <strong>规定时间内</strong>，<mark>完成规定功能</mark> 的能力。</p>\n<p><strong>维修性</strong> 是指产品在 <strong>规定条件下</strong> 和 <strong>规定时间内</strong>，按规定的程序和方法维修时，<mark>保持或恢复到规定功能</mark> 的能力。</p>\n<h3 id=\"三个时间点\">三个时间点</h3>\n<p>如果将产品比作人，那么产品从被研发、生产、出厂、使用到寿命终结的阶段，就好比人受精、怀胎、分娩、成长到死亡的阶段。将整个过程看做一个时间轴 $ t $ ， 那么其中的产品出厂（人的分娩）的时间就为 $ t=0 $，产品被研发和生产（人的受精、怀胎）的阶段，其时间被视为 <span class=\"math inline\">\\(t&lt;0\\)</span>​， 产品被使用到寿命终结（人的成长到死亡）的阶段，其时间被视为 <span class=\"math inline\">\\(t&gt;0\\)</span>​ 。这种方法是将产品简单划为三个时间点，例如在 <span class=\"math inline\">\\(t&lt;0\\)</span>​ 时，研发和预制是两个不同的工作内容或阶段。</p>\n<h3 id=\"三个阶段\">三个阶段</h3>\n<p>实际上，<span class=\"math inline\">\\(t=0\\)</span>​ 仅仅是个时间点，在可靠性研究过程中，产品寿命周期通常是按以下三个阶段进行研究：<strong>研发阶段</strong>（<span class=\"math inline\">\\(t&lt;0\\)</span>​）、<strong>生产制造阶段</strong>（<span class=\"math inline\">\\(t&lt;0\\)</span>​）和 <strong>使用至报废阶段</strong> （<span class=\"math inline\">\\(t&gt;0\\)</span>​）。</p>\n<div style=\"font-size: 0.8rem; color: #222222; font-weight: 900; text-align: center;\">\n图1-1 质量与可靠性关系示意图\n</div>\n<div style=\"font-size: 0.8rem; color: #222222; font-weight: 900; text-align: center;\">\n表 质量、可靠性与时间三者的关系\n</div>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>质量的度量</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>t = 0<br>出厂时间</td>\n<td>使用产品合格率进行度量</td>\n</tr>\n<tr class=\"even\">\n<td>t &lt; 0<br>研制阶段</td>\n<td>提高 <strong>制造过程</strong> 中的一致性和稳定性，以降低不合格率</td>\n</tr>\n<tr class=\"odd\">\n<td>t &gt; 0<br>使用阶段</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"可靠性数学基础\">可靠性数学基础</h1>\n<p>所有可观测的现象包括 <strong>自然现象</strong> 和 <strong>社会现象</strong>，按照结果的确定性对此类现象进行分类可以分为：<strong>确定现象</strong> 和 <strong>不确定现象</strong>。</p>\n<pre class=\"mermaid\">graph LR\n现象 --结果确定--> 确定现象\n现象 --结果不确定--> 不确定现象 --具有统计规律--> 随机现象\n不确定现象 --不具有统计规律--> 未知</pre>\n<h2 id=\"随机\">随机</h2>\n<table>\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 38%\" />\n<col style=\"width: 51%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>概念</th>\n<th>定义</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong>随机现象</strong></td>\n<td>具有统计规律性的 <strong>不确定现象</strong>。</td>\n<td>- 描述 <strong>过程/现象可能性</strong></td>\n</tr>\n<tr class=\"even\">\n<td><strong>随机事件</strong></td>\n<td>随机现象的某种 <strong>可能结果</strong>。</td>\n<td>- 描述 <strong>结果可能性</strong><br>- 具有不可确定性，即事件真正发生之前不能确定其是否出现。</td>\n</tr>\n<tr class=\"odd\">\n<td><strong>随机试验</strong></td>\n<td>研究随机现象中各种 <strong>可能发生的结果的过程</strong>。</td>\n<td>- 描述 <strong>研究结果可能性的过程</strong><br>- 试验全部可能结果的集合可确定<br>- 试验条件不变的情况下，试验可以无限重复<br>- 试验的结果以随机的形式发生（实验条件相同，结果可能不同）</td>\n</tr>\n</tbody>\n</table>\n<p>随机现象之所以称之为随机现象，是因为现象发生后具有1个以上的可能结果，如果仅有1种结果，则可以称之现象和事件为 <strong>确定现象</strong> 和 <strong>确定事件</strong>。</p>\n<p>例如：</p>\n<blockquote>\n<p>小球会落入某个洞口，小球的总数为2，小球落入洞口的现象是可观察可统计的，但小球确实地落在哪个洞口中具有不确定性，称之为现象。</p>\n<p>但小球落入到洞口A或者洞口B，是可以预测到的结果，落入洞口A则称之为事件A，落入洞口B则称之为事件B，总称之为事件。</p>\n</blockquote>\n<h2 id=\"频率概率\">频率/概率</h2>\n<p>每一种随机现象的试验结果用 <strong>事件</strong> 一词来描述，则随机事件有可能在一次试验中可能发生，也可能不发生，其事件的发生可能性使用 <strong>频率</strong> 或 <strong>概率</strong> 来度量。</p>\n<p>在相同试验条件下，进行 <span class=\"math inline\">\\(n\\)</span> 次试验，事件A的出现次数 <span class=\"math inline\">\\(m\\)</span> 称之为 <strong>频数</strong> ，使用 <strong>试验总次数</strong> <span class=\"math inline\">\\(n\\)</span> 和 <strong>事件A的频数</strong> <span class=\"math inline\">\\(m\\)</span>​ 来表示 事件A在所有试验下的 <strong>频率</strong> <span class=\"math inline\">\\(P^*(A)\\)</span> ： <span class=\"math display\">\\[\nP^*(A)={m\\over n} \\tag{频率公式}\n\\]</span></p>\n<p><strong>频率</strong>、<strong>频数</strong>、<strong>频次</strong> 等术语在描述或者度量事件发生的可能性大小时，会因试验总次数太低 或 某个随机事件出现的次数具有波动性而导致不合理，就连以上三个词汇本身在描述时含有一定的随机性。</p>\n<p>但在 <strong>大量重复</strong> 某一试验时，频率趋于稳定，此时该稳定值可以称之为随机事件的 <strong>概率</strong> 或 <strong>统计概率</strong>，使用 <span class=\"math inline\">\\(P(A)\\)</span> 表示。</p>\n<p>即，<strong>概率</strong> 和 <strong>频率</strong> 两个词汇在描述随机试验中的事件时，<mark>最大的区别在于该事件频率值是否趋于 <strong>稳定</strong>，或者试验本身的总次数是否已经 <strong>足够大</strong></mark>。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>频率</th>\n<th>概率</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong>数学符号</strong></td>\n<td><span class=\"math inline\">\\(P^*(A)\\)</span></td>\n<td><span class=\"math inline\">\\(P(A)\\)</span></td>\n</tr>\n<tr class=\"even\">\n<td><strong>特点</strong></td>\n<td>- <strong>试验值</strong>，具有波动性<br>- <strong>近似反映</strong> 事件发生的可能性大小</td>\n<td>- <strong>理论值</strong>，由事件的本质属性决定<br>- <strong>精确反映</strong> 事件的可能性大小</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"概率分布\">概率分布</h2>\n<p>常用的分布函数由：两点分布、<strong>二项分布</strong>、<strong>泊松分布</strong>、均匀分布、<strong>正态分布</strong>、<strong>对数正态分布</strong>、<strong>指数分布</strong> 和 <strong>威布尔分布</strong> 等。</p>\n<p>随机变量按照试验结果的值是否有限或连续可以分为：<strong>离散型随机变量</strong> 和 <strong>连续型随机变量</strong>，其中离散型随机变量在可靠性工程中常见的统计分布类型有 <strong>二项分布</strong> 和 <strong>泊松分布</strong>；连续型随机变量在可靠性工程中常见的统计分布类型有： <strong>指数分布</strong>、<strong>正态分布</strong>、<strong>对数正态分布</strong> 和 <strong>威布尔分布</strong>。</p>\n<pre class=\"mermaid\">graph LR\nid1[随机变量] --试验结果的值有限--> id2[离散型随机变量]\nid1 --试验结果的值连续--> id3[连续型随机变量]\nid2 --> 二项分布\nid2 --> 泊松分布\nid3 --> 正态分布\nid3 --> 对数正态分布\nid3 --> 指数分布\nid3 --> 威布尔分布γ=0</pre>\n<table>\n<colgroup>\n<col style=\"width: 35%\" />\n<col style=\"width: 39%\" />\n<col style=\"width: 24%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: left;\"></th>\n<th style=\"text-align: left;\">离散型随机变量</th>\n<th style=\"text-align: left;\">连续型随机变量</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><strong>可能取值范围</strong></td>\n<td style=\"text-align: left;\">可能取值有限</td>\n<td style=\"text-align: left;\">给定区间（或无限区间）内可取得任意数值</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><strong>可能取值符号</strong></td>\n<td style=\"text-align: left;\"><span class=\"math inline\">\\(x_1, x_2,x_3...x_n\\)</span></td>\n<td style=\"text-align: left;\">[0,∞)</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><strong>概率函数</strong>/<strong>分布律</strong><br><em>某点的概率</em></td>\n<td style=\"text-align: left;\"><span class=\"math inline\">\\(P(X=x_i)=p_i,(i=1,2,3 ... n)\\)</span>​</td>\n<td style=\"text-align: left;\">/</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><strong>概率密度函数</strong><br><em>概率在点的变化率</em></td>\n<td style=\"text-align: left;\">/</td>\n<td style=\"text-align: left;\"><span class=\"math inline\">\\(f(x)=F&#39;(x)={dF(x)\\over dx}\\)</span></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><strong>概率分布函数</strong>/<strong>累积概率函数</strong><br><em>区间内的概率之和</em></td>\n<td style=\"text-align: left;\"><span class=\"math inline\">\\(F(x)=P(X≤x)=\\sum_{x_k≤x}p_k\\)</span>​​​</td>\n<td style=\"text-align: left;\"><span class=\"math inline\">\\(F(x)=P(X≤x)\\)</span></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><strong>性质</strong></td>\n<td style=\"text-align: left;\">- 任意取值变量的概率都在 <code>[0,1)</code> 之间：<span class=\"math inline\">\\(0≤P(X=x_i)=p_i＜1\\)</span>​​<br>- 所有事件概率总和为 <code>1</code> ：<span class=\"math inline\">\\(\\sum^n_{i=1}p_i=1\\)</span>​</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n</tbody>\n</table>\n<p><strong>概率密度函数</strong> 或 <strong>概率分布</strong> <mark>反映了随机变量的统计规律</mark>。概率密度函数值反映了概率在该点的变化率，而非该点的概率。</p>\n<p>以下需要区分几个概念，什么是 <strong>故障概率函数</strong>、<strong>故障率函数</strong>、<strong>故障概率密度函数</strong>、<strong>故障密度函数</strong>、<strong>可靠度函数</strong>？</p>\n<p><strong>故障概率函数</strong>，也称为 <strong>故障率函数</strong>，即 <strong>失败概率函数</strong>，用事件的失败概率进行求解。</p>\n<p><strong>故障概率密度函数</strong>，即适用于 连续型随机变量的故障概率函数。</p>\n<p>在连续型统计分布中，<code>故障密度函数 = 可靠度函数 * 故障率函数</code>。</p>\n<h3 id=\"离散型随机变量分布\">离散型随机变量分布</h3>\n<table>\n<colgroup>\n<col style=\"width: 7%\" />\n<col style=\"width: 31%\" />\n<col style=\"width: 35%\" />\n<col style=\"width: 16%\" />\n<col style=\"width: 8%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>（故障）概率函数</th>\n<th>（故障）（累积）概率分布函数</th>\n<th>均值 <span class=\"math inline\">\\(\\mu\\)</span></th>\n<th>方差 <span class=\"math inline\">\\(\\sigma^2\\)</span></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong>二项分布</strong></td>\n<td><span class=\"math inline\">\\(P(x)=C^x_np^xq^{n-x}\\)</span>​​<br><span class=\"math inline\">\\(C^x_n = {n!\\over x!(n-x)!}\\)</span>​</td>\n<td><span class=\"math inline\">\\(F(x)=\\sum ^r_{x=0} C^x_n p^x q^{n-x}\\)</span>​<br><span class=\"math inline\">\\(C^x_n = {n!\\over x!(n-x)!}\\)</span></td>\n<td><span class=\"math inline\">\\(np\\)</span></td>\n<td><span class=\"math inline\">\\(npq\\)</span></td>\n</tr>\n<tr class=\"even\">\n<td><strong>泊松分布</strong></td>\n<td><span class=\"math inline\">\\(P(x)={(np)^x \\over x!}e^{-np}\\)</span></td>\n<td><span class=\"math inline\">\\(F(x) = \\sum ^r_{x=0} {(np)^x \\over x!}e^{-np}\\)</span></td>\n<td><span class=\"math inline\">\\(\\lambda\\)</span> <br><span class=\"math inline\">\\(\\lambda = np\\)</span></td>\n<td><span class=\"math inline\">\\(\\lambda\\)</span></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<ul>\n<li><span class=\"math inline\">\\(n\\)</span>​ 为 样本量，即抽取样本总数</li>\n<li><span class=\"math inline\">\\(x\\)</span> 或 <span class=\"math inline\">\\(r\\)</span> ​均为失败数，即抽取样本总数下失败的数量</li>\n<li><span class=\"math inline\">\\(p\\)</span> 为 失败概率</li>\n<li><span class=\"math inline\">\\(q\\)</span> 为 成功概率</li>\n</ul>\n</blockquote>\n<p><strong>需要注意</strong>： <span class=\"math inline\">\\(C^x_n = {n!\\over x!(n-x)!}\\)</span>​​​ ，是为 <strong>总试验次数的累乘</strong>（阶乘）与 （<strong>成功次数的累乘</strong> 和 <strong>失败次数的累乘</strong> 之积） 的商。</p>\n<h4 id=\"二项分布\">二项分布</h4>\n<p><strong>贝努力试验</strong>：随机变量的基本结果只有两种（成功/失败）的试验。</p>\n<p><strong>N重贝努力试验</strong>：随机现象是由N次相同的贝努力试验组成，每次试验结果 <strong>只有两种</strong> 且 <strong>互不影响</strong>。</p>\n<p><strong>例题 2-1</strong></p>\n<blockquote>\n<p>某新产品在规定的生产条件下废品率为 <code>0.2</code> ，从批量较大的产品中随机抽取出 <code>20</code> 个，有 <span class=\"math inline\">\\(r\\)</span>（<span class=\"math inline\">\\(r=0,1,2...,10\\)</span>）个废品的概率是多少？</p>\n</blockquote>\n<p><strong>解</strong>：已知某新产品的的废品与否，可以分为两种独立事件：<strong>成功</strong> 或 <strong>失败</strong>（废品）。且单个产品是否成功或失败不影响下一个产品，即符合N重贝努力试验的要求。使用二项分布概率公式 <span class=\"math inline\">\\(P(x)=C^x_np^xq^{n-x}\\)</span>​ 代入，随机抽取的20个产品即为 <span class=\"math inline\">\\(n\\)</span> ，<span class=\"math inline\">\\(p\\)</span> 为失败的概率，即题目中的 <code>0.2</code> 或 <code>20%</code>，<span class=\"math inline\">\\(x\\)</span> 则为抽取总数 <code>20</code> 下的失败产品数量，代入可得： <span class=\"math display\">\\[\nP(X=r)=C^r_{20}0.2^r(1-0.2)^{20-r},r=0,1,2,3...10 \\tag{例2-1}\n\\]</span></p>\n<h4 id=\"泊松分布\">泊松分布</h4>\n<p>二项分布和泊松分布是不一样的。虽然都是离散型随机变量的分布类型，但是 <mark>二项分布适用于抽样总数小于 <code>20</code> 且 失败概率大于 <code>0.05</code> 的情况</mark>，当抽样数无限大时，使用二项分布公式进行求解计算不了，代码中会出现 <code>-nan</code> 关键字，此时泊松分布可以轻松计算，因此，<mark style=\"font-weight: 900;\">泊松分布被认为是二项分布在大抽样数下的扩展</mark>。</p>\n<p>反之，如果将适用于二项分布的数据代入泊松分布公式，虽然能够计算，但是可能会获得异常数据。</p>\n<p>即，虽然人为泊松分布是二项分布的在大抽样数下的扩展，但是毕竟公式和理念都不一样，不能够用来互相验证。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210902105513439.png\" alt=\"image-20210902105513439\" /><figcaption aria-hidden=\"true\">image-20210902105513439</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210902105540683.png\" alt=\"image-20210902105540683\" /><figcaption aria-hidden=\"true\">image-20210902105540683</figcaption>\n</figure>\n<p><strong>例题 2-2</strong></p>\n<blockquote>\n<p>控制台指示灯平均失效率为每小时 <code>0.001</code> 次。如果指示灯的失效数不能超过 <code>2</code> 个，该控制台指示灯工作 <code>500</code> 小时的可靠度是多少？</p>\n</blockquote>\n<p><strong>解</strong>：结合上方题目和泊松分布的概率公式 <span class=\"math inline\">\\(P(x)={(np)^x \\over x!}e^{-np}\\)</span> 可知，每小时平均失效率即为 失败概率 <span class=\"math inline\">\\(p\\)</span> ，工作时长500个小时即为抽样总数 <span class=\"math inline\">\\(n\\)</span> ，而失效灯数不能超过 <code>2</code> 个即为失败数 <code>x</code> ，代入公式可得： <span class=\"math display\">\\[\nP(x) = {(500·0.001)^x \\over x!} ·e^{-500*0.001} = {0.5^x \\over x!} ·e^{-0.5} \\tag{例2-2 概率函数}\n\\]</span> 然后求的其 <span class=\"math inline\">\\(P(0) + P(1) +P(2)\\)</span> 之和： <span class=\"math display\">\\[\nF(2) = \\sum^2_{0}P(x) = {0.5^0 \\over 0!} ·e^{-0.5} + {0.5^1 \\over 1!} ·e^{-0.5} +{0.5^2 \\over 2!} ·e^{-0.5} = 1.625*0.606530 = 0.9856 \\tag{例2-2 累积概率分布函数}\n\\]</span></p>\n<h3 id=\"连续型随机变量分布\">连续型随机变量分布</h3>\n<table>\n<colgroup>\n<col style=\"width: 6%\" />\n<col style=\"width: 30%\" />\n<col style=\"width: 31%\" />\n<col style=\"width: 31%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>分布形式</th>\n<th>故障密度函数 <span class=\"math inline\">\\(f(x)\\)</span>​</th>\n<th>可靠度函数 <span class=\"math inline\">\\(R(x)\\)</span>​</th>\n<th>故障率函数 <span class=\"math inline\">\\(\\lambda(x)\\)</span>​​</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>正态分布</td>\n<td><span class=\"math inline\">\\(\\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-{(x-\\mu)^2}/{2\\sigma^2}}\\)</span>​​</td>\n<td><span class=\"math inline\">\\(\\frac{1}{\\sigma\\sqrt{2\\pi}}\\int_x^\\infin e^{-{(x-\\mu)^2}/{2\\sigma^2}} dt\\)</span>​</td>\n<td><span class=\"math inline\">\\(e^{-(x-\\mu)^2/(2\\sigma)^2} / \\int ^\\infin _x e^{-(x-\\mu)^2/(2\\sigma)^2} dt\\)</span>​</td>\n</tr>\n<tr class=\"even\">\n<td>对数正态分布</td>\n<td><span class=\"math inline\">\\(\\frac{1}{x\\sigma\\sqrt{2\\pi}}e^{-(lnx-\\mu)^2/2\\sigma^2}\\)</span></td>\n<td><span class=\"math inline\">\\(\\frac{1}{\\sigma\\sqrt{2\\pi}}\\int_x^\\infin \\frac{1}{t}e^{-(lnt-\\mu)^2/2\\sigma^2} dt\\)</span>​​</td>\n<td><span class=\"math inline\">\\(\\frac{1}{x}e^{-(lnt-\\mu)^2/(2\\sigma)^2}/ \\int_x^\\infin \\frac{1}{t}e^{-(lnt-\\mu)^2/(2\\sigma)^2} dt\\)</span>​​</td>\n</tr>\n<tr class=\"odd\">\n<td>指数分布</td>\n<td><span class=\"math inline\">\\(λe^{-λx}\\)</span></td>\n<td><span class=\"math inline\">\\(e^{-λx}\\)</span></td>\n<td><span class=\"math inline\">\\(λ\\)</span></td>\n</tr>\n<tr class=\"even\">\n<td>威布尔分布</td>\n<td>$()<sup>{m-1}e</sup>{-(x/)^m} $​​</td>\n<td><span class=\"math inline\">\\(e^{-(x/\\eta)^m}\\)</span></td>\n<td><span class=\"math inline\">\\(\\frac{m}{\\eta}(\\frac{x}{\\eta})^{m-1}\\)</span></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"正态分布\">正态分布</h4>\n<p>在数学上，<strong>正态分布</strong>（Normal Distribution）利用 <strong>均值</strong> <span class=\"math inline\">\\(\\mu\\)</span>​ 和 <strong>方差</strong> <span class=\"math inline\">\\(\\sigma^2\\)</span>​ 记为 <span class=\"math inline\">\\(\\Nu(\\mu, \\sigma^2)\\)</span>​​ 。</p>\n<p><strong>标准正态分布</strong>：正态分布曲线的 <strong>均值</strong> 为0，<strong>标准差</strong> 为1的正态分布，即 <span class=\"math inline\">\\(\\mu = 0, \\sigma = 1\\)</span>​。</p>\n<p><strong>一般正态分布</strong>：除标准正态分布以外的正态分布。任何正态分布都可以使用标准正态分布来计算。</p>\n<h5 id=\"一般正态分布\">一般正态分布</h5>\n<p>正态分布的密度函数 <span class=\"math inline\">\\(f(x)\\)</span> 为： <span class=\"math display\">\\[\n\\varphi(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-{(x-\\mu)^2}/{2\\sigma^2}} \\tag{正态密度函数}\n\\]</span> 正态分布的可靠度函数 <span class=\"math inline\">\\(R(x)\\)</span> 为： <span class=\"math display\">\\[\nR(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\int_x^\\infin e^{-{(x-\\mu)^2}/{2\\sigma^2}} dt \\tag{正态可靠度函数}\n\\]</span></p>\n<h5 id=\"标准正态分布\">标准正态分布</h5>\n<p>标准正态分布以下简称标正，由于标正的均值为0，标准差为1，即 <span class=\"math inline\">\\(\\mu = 0, \\sigma = 1\\)</span> ，代入对应公式可得 <strong>标正密度函数</strong> 记为 <span class=\"math inline\">\\(\\varphi(z)\\)</span> ，<strong>标正累积分布函数</strong> 记为 <span class=\"math inline\">\\(\\Phi(z)\\)</span>​ ，分别如下： <span class=\"math display\">\\[\n\\varphi(z) = \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} \\tag{标正密度函数}\n\\]</span></p>\n<p><span class=\"math display\">\\[\n\\Phi(z) = \\int^z_{-\\infin} \\varphi(z) \\ dz = \\frac{1}{\\sqrt{2\\pi}} \\int^z_{-\\infin} e^{-z^2/2} \\ dz \\tag{标正累积分布函数}\n\\]</span></p>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/09/image-20210903143312170.png\" alt=\"image-20210903143312170\" style=\"zoom:80%;\" /><img src=\"https://pic.islet.space/2021/09/image-20210903144047691.png\" alt=\"image-20210903144047691\" style=\"zoom:80%;\" />\n</div>\n<div style=\"font-size: 0.8rem; color: #222222; font-weight: 900; text-align: center;\">\n图 标准正态分布密度函数曲线 及 累积曲线\n</div>\n<p>正态分布的 <strong>可靠度函数</strong> 为： <span class=\"math display\">\\[\nR(t) = 1-\\Phi(\\frac{t-\\mu}{\\sigma}) \\tag{正态可靠度函数}\n\\]</span></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210903145950111.png\" alt=\"image-20210903145950111\" /><figcaption aria-hidden=\"true\">image-20210903145950111</figcaption>\n</figure>\n<div style=\"font-size: 0.8rem; color: #222222; font-weight: 900; text-align: center;\">\n图 标准正态分布可靠度函数曲线\n</div>\n<p>总结成下表：</p>\n<table>\n<colgroup>\n<col style=\"width: 6%\" />\n<col style=\"width: 31%\" />\n<col style=\"width: 31%\" />\n<col style=\"width: 31%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>密度函数</th>\n<th>累积分布函数</th>\n<th>可靠度函数</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong>一般正态</strong></td>\n<td><span class=\"math inline\">\\(\\varphi(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-{(x-\\mu)^2}/{2\\sigma^2}}\\)</span></td>\n<td><span class=\"math inline\">\\(\\Phi(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} \\int^x_{-\\infin} e^{-{(x-\\mu)^2}/{2\\sigma^2}} \\ dx\\)</span>​​</td>\n<td><span class=\"math inline\">\\(R(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\int_x^\\infin e^{-{(x-\\mu)^2}/{2\\sigma^2}}\\)</span></td>\n</tr>\n<tr class=\"even\">\n<td><strong>标准正态</strong></td>\n<td><span class=\"math inline\">\\(\\varphi(z) = \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2}\\)</span></td>\n<td><span class=\"math inline\">\\(\\Phi(z) = \\int^z_{-\\infin} \\varphi(z) \\ dz = \\frac{1}{\\sqrt{2\\pi}} \\int^z_{-\\infin} e^{-z^2/2} \\  dz\\)</span>​</td>\n<td><span class=\"math inline\">\\(R(t) = 1-\\Phi(\\frac{t-\\mu}{\\sigma})\\)</span></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>正态分布的重要参数有以下几个：</p>\n<ol type=\"1\">\n<li>工作时长 <span class=\"math inline\">\\(x\\)</span></li>\n<li>均值 <span class=\"math inline\">\\(\\mu\\)</span></li>\n<li>标准差 <span class=\"math inline\">\\(\\sigma\\)</span></li>\n</ol>\n</blockquote>\n<p><strong>需要注意的是</strong>：</p>\n<ul>\n<li><strong>一般正态密度函数</strong> 的符号记为 <span class=\"math inline\">\\(f(x)\\)</span>​ ，<strong>标准正态密度函数</strong> 的符号记为小写的希腊字母 <span class=\"math inline\">\\(\\varphi(z)\\)</span>​。</li>\n<li>一般其他分布的 <strong>累积分布函数</strong> 为 大写的 <span class=\"math inline\">\\(F(x)\\)</span> 。</li>\n<li><strong>标正累积分布函数</strong> 的符号记为大写的希腊字母 <span class=\"math inline\">\\(\\Phi(z)\\)</span>​​​​ ，与 <strong>标正密度函数</strong> 的符号发音一致，<mark style=\"font-weight: 900;\">标正累积分布函数的值计算较为麻烦，可以通过查表获得</mark>。</li>\n<li><mark>就标正比较特殊，需要全部用希腊字母</mark>。</li>\n<li>因为 <strong>标正累积分布函数</strong> 和 <strong>标正可靠度函数</strong> 的曲线互为水平翻转。</li>\n</ul>\n<p><strong>例题 2-3</strong></p>\n<blockquote>\n<p>假设发电机的寿命服从正态分布，其均值为300小时，标准差为40小时。试求当工作时间为250小时时，发电机的可靠度是多少？</p>\n</blockquote>\n<p><strong>解</strong>：已知均值 <span class=\"math inline\">\\(u = 300\\)</span> ，标准差 <span class=\"math inline\">\\(\\sigma = 40\\)</span> 且 工作时长为 <code>250</code> 小时，可代入正态可靠度函数进行求解，如下： <span class=\"math display\">\\[\nR(t) = 1- \\Phi(\\frac{t-\\mu}{\\sigma}) = 1-\\Phi(\\frac{250-300}{40}) = 1 - \\Phi(-1.25) \\tag{例2-3 正态分布可靠度函数}\n\\]</span> 其中，<span class=\"math inline\">\\(\\Phi(-1.25)\\)</span>​​ 和 <span class=\"math inline\">\\(\\Phi(1.25)\\)</span>​​ 互补（和为 <code>1</code>），可以通过查询标准正态累积分布表 或使用 自行编写的函数进行计算，可得 <span class=\"math inline\">\\(\\Phi(1.25) = 0.89\\)</span>​​ ，则发电机的可靠度为: <span class=\"math display\">\\[\nR(250) = 1-(1-\\Phi(1.25)) = 1 - (1-0.89) = 0.89 \\tag{例2-3 可靠度计算}\n\\]</span></p>\n<h5 id=\"正态分布的特性\">正态分布的特性</h5>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(\\Phi(x)\\)</span> 和 <span class=\"math inline\">\\(\\Phi(-x)\\)</span> 为 <strong>互补关系</strong>，即 <span class=\"math inline\">\\(\\Phi(x) + \\Phi(-x) =1\\)</span>​</li>\n<li>在 <strong>标准正态分布</strong> 下，<strong>可靠度</strong> 和 <strong>累积分布值</strong> 互补为1， <span class=\"math inline\">\\(R(t) = 1-\\Phi(t)\\)</span>​，在 <strong>一般正态分布</strong> 下，需要注意加入 <strong>均值</strong> <span class=\"math inline\">\\(\\mu\\)</span> 和 <strong>标准差</strong>​ <span class=\"math inline\">\\(\\sigma\\)</span>​​ 。</li>\n</ol>\n<h5 id=\"正态分布的用途\">正态分布的用途</h5>\n<p>在可靠性工程中，正态分布具有以下三种用途：</p>\n<ol type=\"1\">\n<li>分析由于磨损发生故障的产品，如机械装置。</li>\n<li>对制造的产品及其性能是否符合规范进行分析。</li>\n<li>用于机械可靠性概率设计。</li>\n</ol>\n<h4 id=\"对数正态分布\">对数正态分布</h4>\n<p><strong>对数正态分布</strong>（Logarithmic Normal Distribution） 是 正态分布随机变量的 <strong>自然对数</strong> <span class=\"math inline\">\\(y = ln(x)\\)</span>​​​​ ，记为 <span class=\"math inline\">\\(LN(\\mu, \\sigma^2)\\)</span>​​​​​​。</p>\n<p><strong>特点</strong>：使用 对数正态分布 的对数变换 可以使得较大的数缩小为较小的数，且越大的数缩小的越明显。好处是使得较为分散的数据通过对数变换后，可以相对地集中起来，所以常把 <mark style=\"font-weight: 900;\">跨几个数量级的数据用对数正态分布区拟合</mark>（如下方例题2-4）。</p>\n<p><strong>适用产品/场景</strong>：<strong>半导体器件</strong> 的可靠性分析、<strong>机械零件</strong> 的疲劳寿命分析 或 在 <strong>维修性分析</strong> 中对维修时间数据的分析。</p>\n<p>对数正态分布的密度函数如下，需要注意，该函数的取值范围为 <span class=\"math inline\">\\([0,\\infin)\\)</span>​ <span class=\"math display\">\\[\nf(x)=\\frac{1}{x\\sigma\\sqrt{2\\pi}}e^{-(lnx-\\mu)^2/2\\sigma^2}\\tag{对数正态分布密度函数}\n\\]</span></p>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/09/image-20210903171208666.png\" alt=\"image-20210903171208666\" style=\"zoom: 80%;\" /><img src=\"https://pic.islet.space/2021/09/image-20210903170823326.png\" alt=\"image-20210903170823326\" style=\"zoom:80%;\" />\n</div>\n<div style=\"font-size: 0.8rem; color: #222222; font-weight: 900; text-align: center;\">\n图 标准对数正态分布密度函数曲线 及 累积曲线\n</div>\n<blockquote>\n<p><strong>注意</strong>：应该是没有标准对数正态分布的吧，就代入 <span class=\"math inline\">\\(\\mu = 0, \\sigma = 1\\)</span>​ 进行计算求得图像</p>\n</blockquote>\n<p>对数正态累积分布函数如下： <span class=\"math display\">\\[\nF(x) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\int^x_0 \\frac{1}{t} e^{-{(lnt-\\mu)^2}/{2\\sigma^2}} \\ dt \\tag{对数正态累积分布函数}\n\\]</span> 其可靠度函数如下： <span class=\"math display\">\\[\nR(x) = 1 - \\Phi(\\frac{ln(x)-\\mu}{\\sigma}) \\tag{对数正态分布可靠度函数}\n\\]</span> 其中，<span class=\"math inline\">\\(ln(x)\\)</span>​​ 和 <span class=\"math inline\">\\(x\\)</span>​​ 的均值和方差如下：</p>\n<table>\n<colgroup>\n<col style=\"width: 7%\" />\n<col style=\"width: 39%\" />\n<col style=\"width: 53%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>均值</th>\n<th>方差</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><span class=\"math inline\">\\(ln(x)\\)</span></td>\n<td><span class=\"math inline\">\\(\\mu\\)</span></td>\n<td><span class=\"math inline\">\\(\\sigma^2\\)</span></td>\n</tr>\n<tr class=\"even\">\n<td><span class=\"math inline\">\\(x\\)</span></td>\n<td><span class=\"math inline\">\\(E(x)=exp(\\mu + \\frac{\\sigma^2}{2})\\)</span>​</td>\n<td><span class=\"math inline\">\\(Var(x)=exp(2\\mu + \\sigma^2) · [exp(\\sigma^2)-1]\\)</span></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>对数正态分布的重要参数有以下几个：</p>\n<ol type=\"1\">\n<li>工作时长 <span class=\"math inline\">\\(x\\)</span></li>\n<li>均值 <span class=\"math inline\">\\(\\mu\\)</span></li>\n<li>标准差 <span class=\"math inline\">\\(\\sigma\\)</span></li>\n</ol>\n</blockquote>\n<p><strong>例题 2-4</strong></p>\n<blockquote>\n<p>假设人们观察到炮管寿命服从对数正态分布，<span class=\"math inline\">\\(\\mu = 9,\\sigma = 2\\)</span>。（注意，<span class=\"math inline\">\\(\\mu\\)</span> 和 <span class=\"math inline\">\\(\\sigma\\)</span> 是 <span class=\"math inline\">\\(ln(x)\\)</span> 的均值和标准差）求发射1000发炮弹时的可靠度。</p>\n</blockquote>\n<p><strong>解</strong>：</p>\n<p><strong>情况一</strong>：已知对数正态分布可靠度表格</p>\n<p>在已知表格时，直接代入公式，然后查表计算即可。 <span class=\"math display\">\\[\nR(1000)=1-\\Phi(\\frac{ln1000-9}{2}) = 1-\\Phi(-1.046) = 1-0.15 = 0.85 \\tag{例2-4 可靠度计算}\n\\]</span> <strong>情况二</strong>：未知对数正态分布可靠度表格</p>\n<p>在没有对数正态分布可靠度值表格可查询的情况下，是没有办法直接得出答案的。正常的思路如下：</p>\n<ol type=\"1\">\n<li>将 <span class=\"math inline\">\\(\\mu=9, \\sigma=2\\)</span> 代入密度公式 <span class=\"math inline\">\\(f(x)\\)</span></li>\n<li>然后在区间 <span class=\"math inline\">\\((0,1000]\\)</span>​ 内进行积分，通过累计分布函数 <span class=\"math inline\">\\(\\Phi(1000)\\)</span> ，可以得到其特定区间内的累积分布值。</li>\n<li>然后使用 <code>1</code> 减去该累积分布值即可获得该可靠度值 <span class=\"math inline\">\\(R(1000)\\)</span>。</li>\n</ol>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/09/image-20210903165737856.png\" alt=\"image-20210903165737856\" style=\"zoom:80%;\" /><img src=\"https://pic.islet.space/2021/09/image-20210903165632407.png\" alt=\"image-20210903165632407\" style=\"zoom:80%;\" />\n</div>\n<div style=\"font-size: 0.8rem; color: #222222; font-weight: 900; text-align: center;\">\n图 例题的对数正态累积分布曲线和可靠度曲线\n</div>\n<p>上面两个图片是经由C++函数计算并使用gnuplot进行绘制的，实际计算得到本例题的 <span class=\"math inline\">\\(\\Phi(1000) = 0.14781, R(1000)= 0.85219\\)</span>​</p>\n<p>无聊着又稍微拟合了该产品在工作到 <code>100,000</code> 小时时的 <strong>可靠度曲线</strong> 和 工作到 <code>10,000</code> 小时时的 <strong>密度曲线</strong>。</p>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/09/image-20210903172937541.png\" alt=\"image-20210903172937541\" style=\"zoom:80%;\" /><img src=\"https://pic.islet.space/2021/09/image-20210903195121209.png\" alt=\"image-20210903195121209\" style=\"zoom:80%;\" />\n</div>\n<div style=\"font-size: 0.8rem; color: #222222; font-weight: 900; text-align: center;\">\n图 工作到10万小时的炮管的可靠度曲线 和 工作到1万小时的炮管的密度曲线\n</div>\n<h4 id=\"指数分布\">指数分布</h4>\n<p><strong>指数分布</strong>（Exponential Distribution） 是可靠性工程中最重要的一种分布。</p>\n<p>当产品工作进入浴盆曲线的偶然故障期后，产品的故障率基本接近常数，其对应的故障分布函数就是指数分布。</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>参数估计简单容易，只有一个变量；</li>\n<li>在数学上非常容易处理；</li>\n<li>适用范围非常广；</li>\n<li>大量指数分布的独立变量之和还是指数分布，具有可加性。</li>\n</ul>\n<p><strong>性质</strong>：</p>\n<ul>\n<li>指数分布的失效率 <span class=\"math inline\">\\(\\lambda\\)</span> 等于 <strong>常数</strong>；</li>\n<li>指数分布的 <strong>平均寿命</strong> <span class=\"math inline\">\\(\\theta\\)</span> 和 <strong>失效率</strong> <span class=\"math inline\">\\(\\lambda\\)</span> 互为倒数，即 <span class=\"math inline\">\\(\\theta = 1/\\lambda\\)</span> ；</li>\n<li>指数分布“无记忆性”。（<strong>无记忆性</strong> 是指故障分布为指数分布的系统的失效率，在任何时刻都与系统已工作过的时间长短没有关系。）</li>\n</ul>\n<p>指数分布的密度函数如下： <span class=\"math display\">\\[\nf(x) = \\left\\{ \n\\displaylines{\\lambda e^{-\\lambda x}, x ≥ 0\\\\ 0,x &lt; 0} \n\\right. \\tag{指数分布密度函数}\n\\]</span> 其累积失效分布函数为： <span class=\"math display\">\\[\nF(x) = 1 - e^{-\\lambda x} \\tag{指数累积分布函数}\n\\]</span> 其可靠度函数为： <span class=\"math display\">\\[\nR(x)=e^{-\\lambda x} \\tag{指数分布可靠度函数}\n\\]</span></p>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/09/image-20210903190717009.png\" alt=\"image-20210903190717009\" style=\"zoom:80%;\" /><img src=\"https://pic.islet.space/2021/09/image-20210903191446082.png\" alt=\"image-20210903191446082\" style=\"zoom:80%;\" />\n</div>\n<div style=\"font-size: 0.8rem; color: #222222; font-weight: 900; text-align: center;\">\n图 故障率为100 和 故障率为0.01的指数分布密度函数曲线\n</div>\n<blockquote>\n<p>上图为错误例子啊，因为故障率 <span class=\"math inline\">\\(\\lambda = 100\\)</span>​​​ 时已经高得离谱，且故障率和平均工作时长是呈反比的，故障率为 <code>100</code> 的话，就是说大概只能工作 <code>0.01</code> 小时（大概 <code>36</code> s），所以会看到该 <strong>密度曲线</strong> 在x轴没到0.1就飞降。把故障率修改为 <code>0.01</code>，即大概能工作100个小时，就可以看到较为 <strong><em>正常</em></strong> 的密度曲线了。</p>\n</blockquote>\n<p>如果要求其可靠度曲线，则用 <strong>密度值</strong> <span class=\"math inline\">\\(F(x)\\)</span> 除以 <strong>故障率</strong> <span class=\"math inline\">\\(\\lambda\\)</span>​ 即可，曲线如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210903193144464.png\" alt=\"image-20210903193144464\" /><figcaption aria-hidden=\"true\">image-20210903193144464</figcaption>\n</figure>\n<div style=\"font-size: 0.8rem; color: #222222; font-weight: 900; text-align: center;\">\n图 故障率为0.01的指数分布可靠度函数曲线\n</div>\n<p><strong>例题 2-5</strong></p>\n<blockquote>\n<p>机载火控系统的平均故障间隔时间是 <code>100</code> 小时，即 <span class=\"math inline\">\\(\\theta = 100\\)</span>​ 小时，工作5小时不发生故障的概率是多少？</p>\n</blockquote>\n<p><strong>解</strong>：由题目已知 <span class=\"math inline\">\\(\\theta = 100\\)</span> ， 即 <span class=\"math inline\">\\(\\lambda = 0.01\\)</span> ，要求的是工作5小时不发生故障的概率，即求可靠度。</p>\n<p>代入指数分布可靠度公式 <span class=\"math inline\">\\(R(x)=e^{-\\lambda x}\\)</span> 即可求得 <code>0.951229</code>，即 <code>95.12%</code> 。</p>\n<h4 id=\"威布尔分布\">威布尔分布</h4>\n<p><strong>威布尔分布</strong>（Weibull Distribution）是由 <strong>最弱环节模型</strong> 导出的，如链条的寿命就服从威布尔分布。</p>\n<p>威布尔分布 是 <strong>通用分布</strong> ，通过调整分布参数可以构成各种不同的分布，可以为各种不同类型的产品的寿命特性建立模型。</p>\n<p>威布尔分布既包括 故障率 为常数的模型，也包括故障率随时间变化的 <strong>递减</strong>（早期故障）和 <strong>递增</strong>（损耗故障）模型，因而可以描述更为复杂的失效过程。许多产品的故障率是单调递增的，威布尔分布可以很好地描述产品疲劳、磨损等损耗故障。</p>\n<table>\n<colgroup>\n<col style=\"width: 9%\" />\n<col style=\"width: 45%\" />\n<col style=\"width: 45%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>两参数公式</th>\n<th>三参数公式</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>概率密度函数</td>\n<td><span class=\"math inline\">\\(f(t)=\\frac{m}{\\eta}(\\frac{t}{\\eta})^{m-1}exp[-(\\frac{t}{\\eta})^m]\\)</span></td>\n<td><span class=\"math inline\">\\(f(t)=\\frac{m}{\\eta}(\\frac{t-\\gamma}{\\eta})^{m-1}exp[-(\\frac{t-\\gamma}{\\eta})^m]\\)</span></td>\n</tr>\n<tr class=\"even\">\n<td>累积分布函数</td>\n<td><span class=\"math inline\">\\(F(t)=1-exp[-(\\frac{t}{\\eta})^m]\\)</span>​</td>\n<td><span class=\"math inline\">\\(F(t)=1-exp[-(\\frac{t-\\gamma}{\\eta})^m]\\)</span></td>\n</tr>\n<tr class=\"odd\">\n<td>可靠度函数</td>\n<td><span class=\"math inline\">\\(R(t)=exp[-(\\frac{t}{\\eta})^m]\\)</span></td>\n<td><span class=\"math inline\">\\(R(t)=exp[-(\\frac{t-\\gamma}{\\eta})^m]\\)</span></td>\n</tr>\n<tr class=\"even\">\n<td>故障率函数</td>\n<td><span class=\"math inline\">\\(\\lambda(t)=\\frac{m}{\\eta}(\\frac{t}{\\eta})^{m-1}\\)</span></td>\n<td><span class=\"math inline\">\\(\\lambda(t)=\\frac{m}{\\eta}(\\frac{t-\\gamma}{\\eta})^{m-1}\\)</span></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>威布尔分布的重要参数有以下几个：</p>\n<ol type=\"1\">\n<li>随机变量 <span class=\"math inline\">\\(t\\)</span> ，<span class=\"math inline\">\\(t≥0\\)</span>（两参数），<span class=\"math inline\">\\(t≥\\gamma\\)</span>​（三参数）</li>\n<li>无量纲 形状参数 <span class=\"math inline\">\\(m,\\ m&gt;0\\)</span>​​</li>\n<li>尺度参数 <span class=\"math inline\">\\(\\eta,\\ \\eta&gt;0\\)</span>​​</li>\n<li>位置参数 <span class=\"math inline\">\\(\\gamma, \\ \\gamma&gt;0\\)</span></li>\n</ol>\n<p>除形状参数 <span class=\"math inline\">\\(m\\)</span> 以外，其他参数单位相同。</p>\n</blockquote>\n<p><strong>例题 2-6</strong></p>\n<blockquote>\n<p>人们发现某种特定的发射管的失效时间服从威布尔分布，其中 <span class=\"math inline\">\\(m=2, \\eta = 1000\\)</span> 小时，试确定当任务时间为100小时时这种发射管的可靠度。</p>\n</blockquote>\n<p><strong>解</strong>：</p>\n<p>威布尔分布除了时间 <span class=\"math inline\">\\(t\\)</span> 以外，就只剩下三个参数，而题目中并无使用位置参数 <span class=\"math inline\">\\(\\gamma\\)</span> ，因此直接代入可靠度公式进行求解即可： <span class=\"math display\">\\[\nR(x) =exp[-(\\frac{t-\\gamma}{\\eta})^m] = e^{-(t/\\eta)^m}  \\tag{例2-6 可靠度求解}\n\\]</span> 得到该产品在工作时长为100小时时的可靠度为： <span class=\"math display\">\\[\nR(100) = e^{-(100/1000)^2} = e^{-0.01} = 0.990049 ≈ 99\\%\n\\]</span></p>\n<p>使用C++驱动GNUPLOT拟合该曲线至 <span class=\"math inline\">\\(t=3000\\)</span>​​ 时的 <strong>可靠度曲线</strong> 和 <strong>累积曲线</strong> 如下：</p>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/09/image-20210903201848206.png\" alt=\"image-20210903201848206\" style=\"zoom:80%;\" /><img src=\"https://pic.islet.space/2021/09/image-20210903203111178.png\" alt=\"image-20210903203111178\" style=\"zoom:80%;\" />\n</div>\n<div style=\"font-size: 0.8rem; color: #222222; font-weight: 900; text-align: center;\">\n图 例题2-6 威布尔分布的 可靠度曲线 和 累积曲线\n</div>\n<h2 id=\"参数估计\">参数估计</h2>\n<p>可靠性工程中，<strong>数理统计</strong> 是进行数据整理和分析的基础，<mark>其基本内容是统计推断</mark>。</p>\n<p><mark>随机变量的概率分布虽然能很好地描述随机分布，但是通常不能对研究对象的总体都进行观测和试验</mark>，只能从中随机地抽取一部分子样进行观察和试验，获得必要的数据，对齐进行分析处理，然后对总体的 <strong>分布类型</strong> 和 <strong>参数</strong> 进行推断。</p>\n<h3 id=\"抽样相关概念\">抽样相关概念</h3>\n<p><strong>总体</strong>：也称为 <strong>母体</strong>，研究对象的全体。</p>\n<p><strong>个体</strong>：组成总体的每个基本单元。</p>\n<p><strong>样本</strong>：也称为 <strong>子样</strong>，在总体中随机抽取的部分个体。</p>\n<p><strong>样本值</strong>：在每次抽样后测得的具体数值（记为 <span class=\"math inline\">\\(x_1, x_2, x_3 ... x_n\\)</span>）。</p>\n<p><strong>样本容量</strong>：样本所包含的个体数目（记为 <span class=\"math inline\">\\(n\\)</span>）。</p>\n<p><strong>随机抽样</strong>：不掺入人为主观因素而具有随机性的抽样，即具有 <strong>代表性</strong> 和 <strong>独立性</strong> 的抽样。</p>\n<p><strong>样本统计量</strong>：是指子样 <span class=\"math inline\">\\(x_1, x_2, ..., x_n\\)</span> 是从母体 <span class=\"math inline\">\\(X\\)</span> 中随机抽取出来后，进一步提炼和加工后的统计量，如 <strong>均值</strong> <span class=\"math inline\">\\(\\overline x\\)</span> 、<strong>方差</strong> <span class=\"math inline\">\\(S^2\\)</span>、<strong>极差</strong> <span class=\"math inline\">\\(R\\)</span>​​</p>\n<p>子样之所以很宝贵，是因为包含了母体的各种信息，尚未对子样进一步提炼和加工处理前，母体的各种信息仍分散在子样中，子样经过加工成一些统计量之后可以反映出一些信息，如：<strong>均值</strong> 反映了母体数学期望信息，<strong>方差</strong> 反映了母体方差信息，<strong>极差</strong> 粗略地反映了母体分散程度，但不能直接用于估计母体的方差。下方为统计量的一些概念。</p>\n<h3 id=\"统计量相关概念\">统计量相关概念</h3>\n<p><strong>均值</strong>：反映了母体数学期望的信息，表示为 <span class=\"math inline\">\\(\\overline x =\\frac{1}{n} \\sum^n_{i=1}x_i\\)</span>​​</p>\n<p><strong>平均差</strong>：平均差是表示各个变量值之间差异程度的数值之一。指各个变量值同平均数的离差绝对值的算术平均数。</p>\n<p><strong>方差</strong>：方差是在概率论和统计方差衡量随机变量或一组数据时离散程度的度量。概率论中方差用来度量随机变量和其数学期望（即均值）之间的偏离程度。统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，表示为 <span class=\"math inline\">\\(S^2=\\frac{1}{n-1}\\sum ^n_{i=1}(x_i-\\overline x)^2\\)</span>​ 。</p>\n<p><strong>标准差</strong>：是离均差平方的算术平均数的平方根，是方差的算术平方根，表示为 <span class=\"math inline\">\\(\\sigma=\\sqrt{S^2}\\)</span> 。</p>\n<p><strong>极差</strong>：极差又称范围误差或全距(Range)，以 <span class=\"math inline\">\\(R\\)</span>​ 表示，是用来表示统计资料中的变异量数(measures of variation)，其最大值与最小值之间的差距，即最大值减最小值后所得之数据。是指一组数据内的最大值和最小值之间的差异，表示为 <span class=\"math inline\">\\(R=max(x_1,x_2, ..., x_n)-min(x1, x2, ..., xn)\\)</span> 。</p>\n<h4 id=\"分布参数的点估计\">分布参数的点估计</h4>\n<p>如果 <span class=\"math inline\">\\(X\\)</span> 是一个具有概率分布 <span class=\"math inline\">\\(f(x)\\)</span> 的随机变量，样本容量为 <span class=\"math inline\">\\(n\\)</span>，样本值为 <span class=\"math inline\">\\(x_1, x_2, ..., x_n\\)</span> ，则与其位置参数 <span class=\"math inline\">\\(\\theta\\)</span> 相应的统计量 <span class=\"math inline\">\\(\\hat{\\theta }\\)</span> 的估计值。</p>\n<p>此处，<span class=\"math inline\">\\(\\hat{\\theta}\\)</span> 是一个随机变量，因为它是样本数据的函数。在样本已经选好之后，就能得到一个确定的 <span class=\"math inline\">\\(\\hat{\\theta}\\)</span> 值，就是 <span class=\"math inline\">\\(\\theta\\)</span> 的点估计。</p>\n<h5 id=\"点估计的解析法\">点估计的解析法</h5>\n<p>在点估计的解析法中，有很多方法可以选择，如 矩法、最小二乘法、极大似然法、最好线性无偏估计、最好线性不变估计、简单线性无偏估计 和 不变估计。以上方法的特点如下：</p>\n<ul>\n<li>矩法只适用于完全样本；</li>\n<li>最好线性无偏估计 和 不变估计 已有国家标准《GB 2689.4-1981 寿命试验和加速寿命试验的最好线性无偏估计法（用于威布尔分布）》，但只适用于定数截尾情况，在一定样本量下有专用表格；</li>\n<li>极大似然法和最小二乘法适用于所有情况，极大似然法是精度最好的方法。</li>\n</ul>\n<h5 id=\"极大似然法\">极大似然法</h5>\n<p>极大似然估计（Maximum Likelihood Estimate, MLE）是一种重要的估计方法，利用总体分布函数表达式及样本数据两种信息来建立似然函数。</p>\n<p><strong>特点</strong>：具有一致性、有效性 和 渐近无偏性 等优良性质。</p>\n<p><strong>缺点</strong>：求解方法最为复杂，需要用迭代法并借助计算机求解。</p>\n<h4 id=\"分布参数的区间估计\">分布参数的区间估计</h4>\n<p><strong>区间估计</strong>：在实际问题中，对于未知参数 <span class=\"math inline\">\\(\\theta\\)</span> ，并不一定求出其点估计值 <span class=\"math inline\">\\(\\hat{\\theta}\\)</span> 为满足，仍希望求出其范围，并希望知道该范围包含未制参数 <span class=\"math inline\">\\(\\theta\\)</span> 真值的置信概率的估计。</p>\n<p><strong>置信区间</strong>：表示计算估计的精确程度</p>\n<p><strong>置信度</strong>：是样品的试验结果在母体的概率分布参数（如均值或标准差）的某个区间内出现的概率，表示结果的可信性。</p>\n<p>与置信度不同，可靠度 是指 样品在规定条件下和规定时间内正常工作的概率，反映的是产品本身的质量状况。</p>\n<h1 id=\"可靠性设计与分析\">可靠性设计与分析</h1>\n<h1 id=\"gitee项目分享\">Gitee项目分享</h1>\n<p>适用于《可靠性工程师手册》的数学函数已经开源共享至Gitee，依托于 GNUPLOT 的图形绘制能力，可以轻松查看各种函数的曲线形状，十分方便。</p>\n<h1 id=\"math-for-reliability\">Math-For-Reliability</h1>\n<p>在Gitee上的开源项目，开放给所有学习可靠性的人使用。</p>\n<p>Gitee项目地址：https://gitee.com/tonyliew/math-for-reliability</p>\n<h1 id=\"debug_records\">DEBUG_RECORDS</h1>\n<h2 id=\"section\">20210902-01</h2>\n<p>在Linux上运行标准正态累积分布计算函数，其计算结果与标准正态分布表方向相反了。<span class=\"math inline\">\\(x = 0\\)</span>​​ 时的 <span class=\"math inline\">\\(\\Phi(x)\\)</span>​​ 值本应为0.5，结果和 <span class=\"math inline\">\\(x = 5\\)</span>​​ 时的 <span class=\"math inline\">\\(\\Phi(x)\\)</span>​​​​ 值相反。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210902193634846.png\" alt=\"image-20210902193634846\" /><figcaption aria-hidden=\"true\">image-20210902193634846</figcaption>\n</figure>\n<p>一番检查发现积分函数可能不适用</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210902194119411.png\" alt=\"image-20210902194119411\" /><figcaption aria-hidden=\"true\">image-20210902194119411</figcaption>\n</figure>\n<p>经过“校准”一番，终于修改好了，不知道还会不会卡Bug。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210902194157770.png\" alt=\"image-20210902194157770\" /><figcaption aria-hidden=\"true\">image-20210902194157770</figcaption>\n</figure>\n<p>目前可以计算x值为正时的累积分布值，结果与标准正态分布表一致。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210902194241093.png\" alt=\"image-20210902194241093\" /><figcaption aria-hidden=\"true\">image-20210902194241093</figcaption>\n</figure>\n<p>重新解答完 2-3例题，发现知道了修改bug的方法，也只是补上了而已，哈哈哈哈。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210902200537224.png\" alt=\"image-20210902200537224\" /><figcaption aria-hidden=\"true\">image-20210902200537224</figcaption>\n</figure>\n<p>经过验证，结果正确。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210902200910935.png\" alt=\"image-20210902200910935\" /><figcaption aria-hidden=\"true\">image-20210902200910935</figcaption>\n</figure>\n<p>9月3日订正，为了生成标准正态累积分布的图形，发现带负号的 <code>integral()</code> 函数生成曲线时是 <strong>水平翻转</strong> 的。</p>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/09/image-20210903144047691.png\" alt=\"image-20210903144047691\" style=\"zoom:80%;\" /><img src=\"https://pic.islet.space/2021/09/image-20210903145950111.png\" alt=\"image-20210903145950111\" style=\"zoom:80%;\" />\n</div>\n<div style=\"font-size: 0.8rem; color: #222222; font-weight: 900; text-align: center;\">\n图 标准正态分布的 累积（故障）函数曲线 和 可靠度函数曲线 互为水平翻转\n</div>\n<p>仔细思考后发现，标准正态函数下，<strong>可靠度曲线值</strong> 是和 <strong>累积分布函数曲线</strong> 值各点互补为 <code>1</code> 的，很容易将累积分布函数和可靠度函数互相搞混，因此其图像才会互为 <strong>水平翻转</strong>，修改后的标正累积分布函数代码如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210903144813581.png\" alt=\"image-20210903144813581\" /><figcaption aria-hidden=\"true\">image-20210903144813581</figcaption>\n</figure>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li>《可靠性工程师手册（第二版）》中国人名大学出版社 李良巧主编</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/266435689\">概率分布函数、概率密度函数</a></li>\n</ol>\n","categories":["Others"],"tags":["可靠性工程师"]},{"title":"面试经验","url":"/2021/12/10/Others/2021-12-10-%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/","content":"<p>因为也是人力资源管理专业出身，所以基于面试者（员工）角度来写这篇文章的时候，其实是左右手互博的感觉。</p>\n<p>特殊性说明，本文所描述的岗位背景其实是 <strong>嵌入式DSP裸机软件（驱动）开发</strong> 。</p>\n<p><strong>注意</strong>：下面标灰色的部分都是跟HR工作相关的概念，如果看不太懂可以跳过。</p>\n<h1 id=\"面试流程\">面试流程</h1>\n<p>技术类岗位招聘通常会遇到 <strong>2~3轮面试</strong> 和一次 <strong>HR提供Offer</strong> 的环节，最经典的流程如下：</p>\n<pre class=\"mermaid\">graph LR\n简历投送 --> ID1((HR面)) --> ID2((项目面)) --> ID3((技术面)) --> 拿Offer</pre>\n<h2 id=\"面试原则\">面试原则</h2>\n<p>面试者需要在面试过程中适当包装和美化一下自己的工作经历，但是还是需要秉承着相对诚实的原则。</p>\n<h3 id=\"为什么说是相对诚实的原则\">为什么说是相对诚实的原则</h3>\n<p>你可以说“自己的工作很难但按时完成”，“自己独立完成”，“自主编写代码” 等等他人较难去鉴别的工作，这些都是一个人工作能力不错的表现。但假如把自己没做过的项目放进去，一旦被问技术面的时候问到细节就会露馅。即使面试时没有露馅，工作时露馅了，大概率也会被面试官知道的。</p>\n<blockquote>\n<p>一个HR有可能是在一家公司专门从事招聘的专员，也有可能是为多家公司做招聘的猎头（专门从事招聘工作的人员，通常是成立一个猎头公司，专门帮其他公司找人才）。一旦技术面的时候夸大自己的工作经验，技术面也会跟HR反馈你的夸大情况，然后你就再也不能通过该猎头或者专员找到其他的工作了，相当于自己白白损失了一个资源口。</p>\n</blockquote>\n<p>而，嵌入式开发之类的技术岗位（目前）是绝对的版本答案之一，企业通过猎头找人才已经是常态，因此绝对不能有这种作死行为。</p>\n<h1 id=\"hr面\">HR面</h1>\n<p>由专门/兼职做人力资源的工作人员负责，主要有以下流程：</p>\n<ol type=\"1\">\n<li><strong>说明招聘信息</strong>（包括所招聘的岗位的基本要求和职责、企业背景、团队情况和项目情况）</li>\n<li><strong>在职情况</strong>（千万不能说自己已经离职，否则你就会很掉价，因为HR会觉得你急于找到新工作而压低你的价格——对，就是你的薪酬，你的卖身一个月的价格，当然也有其他方法可以来试着压低你的薪酬，后面再谈）</li>\n<li><strong>询问面试者的离职原因</strong>（以判断该员工是否足够稳定，因为薪酬给的更高的员工其离职后给企业造成的离职成本会更高，因此需要该员工足够稳定，后面详谈如何回答离职原因）</li>\n<li><strong>询问面试者当前的工作内容</strong>（以确定该员工与所招聘岗位的匹配度，就是说，面试者目前的工作内容如果和他招聘的岗位的工作内容差异太大，他就不会想要再继续去问了，这点应该比较容易懂吧。当然，面试者也不能明明不匹配就瞎说自己会该工作技能，不然就是坑自己也坑别人，这里尽量坦白一些比较好）</li>\n<li><strong>询问面试者的求职意向及工作意愿</strong>（就是会问面试者是否愿意从事本岗，一般到这里如果没有回答“愿意”，都没得聊了）</li>\n<li><strong>询问面试者期待的薪资及目前薪资</strong>（这一点在招聘网站看可以看到该企业所招聘的岗位能提供的薪资范围，通常也就是个薪酬区间，后面详谈如何回答这部分内容。询问目前薪资就是来确定你的人力成本，进而探寻能够压缩你人力成本空间的可能性的。）</li>\n<li><strong>约定下一步面试时间</strong>（这一点应该没什么好说，通常都是电话技术面或视频技术面，确认好双方有空闲的时间）</li>\n<li><strong>其他</strong>（会问是不是符合一些硬性条件，比如统招本科（就是学信网能够查到本科学历信息），毕业时间等等）</li>\n</ol>\n<h2 id=\"如何回答离职原因\">如何回答离职原因</h2>\n<p>这一部分看似回答很简单，其实会藏着很多坑。</p>\n<blockquote>\n<p>首先，要明白为什么需要HR面，为什么面试第一个打来的都是HR，而不是技术员工直接打过来。</p>\n<p>从企业运行的角度考虑，每一时刻的企业运作都是需要运行成本的，包括场地成本、设备成本（采购、折旧、损耗等等）、物料成本、人力成本（招聘成本、培训成本、薪酬成本等）等等，就特别多，专人专事这个大家都能理解。</p>\n<p>如果一个员工匆忙从一家企业离职，该员工入职前的招聘成本、入职时的培训成本和所需要支付的薪酬成本就会拜拜支出，不能给企业带来盈利，但企业在招聘一个员工前后所支出的成本又是实实在在支出了的，就会造成巨大损失（绿厂就不是，就完全不担心这一点，因为给的太少了（通俗点就是成本不高），打着500强名号，韭菜一茬一茬就随便割，又不会特地挽留员工离职，而且全公司现状都是培训工作做得差，成本就不高）。</p>\n<p>（个人觉得）企业当然不能实现所有人终身雇佣，没有新鲜血液是不行的，一定比例的人员流动可以给企业带来活力（这个原因我就不必讲了吧）。HR是学过这些东西的，需要站在企业角度去帮企业考虑招聘什么样子的人会让企业更加稳定，人员稳定（流失减少，并控制在一定范围内）就能帮助企业降低运行成本。</p>\n</blockquote>\n<p>因此，<mark style=\"font-weight: 900;\">面试者需要体现出自己的稳定性，证明自己是一个不太会轻易离职的人，并说明是一些客观的因素（并不是自己的原因）造成了面试者的离职</mark>。当然，面试者自己在一家企业就业时，也不应该轻易离职，如果是高校毕业者，最好在第一家企业从事1年及以上再离职（建议！）。以下列举了几个较为客观（不能说绝对客观）的原因：</p>\n<ul>\n<li>办公室氛围太过压抑，缺少团队活动</li>\n<li>团队协作性太差</li>\n<li>领导风格太过压迫和强势</li>\n</ul>\n<p>一些员工的主观原因（或者说是令HR反感的原因），这些话是绝对不能说的，绝对禁区！</p>\n<ul>\n<li>自己不喜欢目前的工作</li>\n<li>工作太难了</li>\n</ul>\n<p>一些员工可以说的话：</p>\n<ul>\n<li>自己不太挑工作，比较看重团队氛围和工作环境（一般有自信点的HR都会觉得这点没问题，“不太挑工作”的前提是，也得是自己觉得对口的才行，别不对口你不挑个啥。比如，做MCU/ARM/SOC/DSP的相通性较高，说自己不挑可以，但是跨行业太大也敢说自己不挑那就是找事儿）（另，不太挑工作其实对HR来说是个好品质，但自己也得好好掂量掂量自己）</li>\n</ul>\n<h2 id=\"如何回答目前薪资及期望薪资\">如何回答目前薪资及期望薪资</h2>\n<blockquote>\n<p>HR之所以需要问你的目前薪资，不仅是了解本行业或者某个岗位在某个地区的大致薪酬情况（以对比公司招聘员工的薪酬竞争优势），也是在探寻面试者的薪酬上涨或可以压缩的空间。</p>\n</blockquote>\n<p>面试者首先需要了解（或者说准备好）几点信息：</p>\n<ol type=\"1\">\n<li>该行业该岗位在某个地区的 <strong>普遍薪资范围</strong> 是如何（当然不能拿最高薪资来当做普遍薪资，得看自己的能力和对应岗位的工作难度）</li>\n<li>所面试的公司提供的薪酬范围</li>\n<li>自己所期待的薪资底线</li>\n<li>自己目前薪资</li>\n</ol>\n<p>首先是，如果HR问目前薪资。面试者可以适当夸大自己目前的薪资，税后薪资可能都很低，可以说税前，多说几千没关系，不要与对方公司提供的薪酬底线相差太大即可。如果HR说自己公司有30%或者40%的涨薪幅度限制，那么可以放心，该HR觉得你岗位匹配度较高，只是想通过这个来压一压你的成本而已。</p>\n<p>此时，你可以说自己期待在某个地区某个岗位的薪酬底线，低于这个就不行。HR态度一般都会更为委婉些。</p>\n<p>如果你通过面试，到了拿offer的环节，HR还是会再跟你谈一遍。豪气的公司（一种薪酬策略，用高于行业平均水平的薪资招聘员工，但也要求更高）一般开价都会比你要求的更高，但这是后面的事情了。</p>\n<h2 id=\"hr面结束之后\">HR面结束之后</h2>\n<p>（如果你对HR提供的岗位较为满意，接收了技术面/项目面的预约）需要记住一些最基础、关键、有用的信息。这些HR面时都已经说明了，最好是拿个小本本记好，这是对面试企业的一个尊重，也是为了防止后面出现的一些莫名其妙的（跟你面试岗位无关的）问题把你问倒。</p>\n<ol type=\"1\">\n<li><strong>岗位工作地点</strong>（很多大企业全国都有研究中心和技术中心，可以选择的，看对方给你提供的是哪个城市的就业岗位）</li>\n<li><strong>对方面试官的名字</strong>（至少记住姓啥）</li>\n<li><strong>对方的公司名称及背景</strong>（比如是帮别人做外包的还是做自研的，有没有上市或者有没有股权激励，成立多久了之类的）</li>\n<li><strong>岗位基本信息</strong> （任职要求和工作职责等）</li>\n</ol>\n<h1 id=\"项目面和技术面\">项目面和技术面</h1>\n<p>普遍情况下，二轮/三轮面试都会问你一些技术和项目上的东西，根据所闻内容的不同，将其分别称呼为 <strong>技术面</strong> 和 <strong>项目面</strong>。</p>\n<p>有些公司会将这两轮分开，面试的先后顺序不一，总得占比是项目经历会问得更多一些，技术面的占比较少。</p>\n<p>有些公司也会将项目面和技术面合在一起（就是同一次面试里就有技术面和项目面），夹杂交替着问。</p>\n<h2 id=\"项目面\">项目面</h2>\n<p>主要是问你从事（主要负责或者协助负责）过的一些项目/经历，了解你对研发的产品、芯片、硬件、软件、工具、设备的认知。项目面会有三种类型的提问：</p>\n<ol type=\"1\">\n<li>工具认知提问。了解面试者对工具使用的经验。</li>\n<li>问题解决提问。了解面试者对一些解决问题的方法和经历。</li>\n<li>情景假设提问。考验面试者解决问题的思路。</li>\n</ol>\n<p><strong>项目面的面试形式：</strong>一般都是电话提问和视频提问。</p>\n<p><strong>面试时长</strong>：单轮面试时间都是在15分钟以上，最长30分钟左右。</p>\n<h3 id=\"工具认知提问\">工具认知提问</h3>\n<p>就是会问你开发过程中遇到的一些工具模块是如何使用的，一些算法或者逻辑的原理。这部分比较简单，都是经验而已。</p>\n<p>例如，面试官问我ADC的使用，我就如实回答我是如何用ADC的，以及我对ADC模块的认知。</p>\n<h3 id=\"问题解决提问\">问题解决提问</h3>\n<blockquote>\n<p>有很大概率（不一定是所有公司都会问的），会问你一些“发现问题解决问题”的经验。这里面试官主要是想知道以下几点情况：</p>\n<ol type=\"1\">\n<li><strong>面试者对工作问题的解决思路</strong>。是否足够清晰，有什么角度可以去考虑，需要面试者自己去总结，然后可以清晰地向他人阐述。</li>\n<li><strong>面试者在解决问题时的耐心</strong>。面试者需要介绍一个以上的案例，向面试官说明问题现象，自己的思考方式、检查方法、解决方法、过程 和 结果 等等。</li>\n<li><strong>面试者的经验</strong>。你能说出自己在遇到一些问题（比如调试问题）时的解决思路，或者看待问题（较为全面）的角度时，就说明了你已经具有足够经验了。</li>\n</ol>\n</blockquote>\n<p>如果面试官问你“发现问题解决问题”的经验，你回答自己不知道，不太记得，忘记了这些话，就妥妥失败了。</p>\n<p>因为这些工作问题的发现、解决和记录工作，在日常工作过程中其实都是可以稍微花点时间去完成的（这并不难，只是你有没有耐心而已），如果面试者自己没有做这部分 <strong>经验积累工作</strong>，那就很吃亏，大部分人都有相关的工作经验，自己不会去 <strong>总结</strong> 而已。</p>\n<h3 id=\"情景假设提问\">情景假设提问</h3>\n<p>面试官可能会抛出情景题，例如问你给你一个芯片，2周之内完成开发，你需要怎么准备，有什么计划。其实就是一个经验问题，或者思路问题。回答方法我就不详细说了。</p>\n<h2 id=\"技术面\">技术面</h2>\n<p>技术面，就是会问一些项目之下的一些底层技术问题，一般来说都不会太难，也偶尔会有一些面试官问的问题比较偏门（开发过程中较难出现的问题）。例如，我经历过的偏门提问，会问C语言的野指针出现和排查，C++的继承概念等等（这些是我项目上比较难涉及到的）。</p>\n<p>但大部分情况下，这些技术提问，都是提问一些你做过的东西，比如你做过某种通信协议的开发，请你表述以下该协议的相关内容（例如，时序、通信格式（通信起始和结束的变化）、电气特性（电平、电压范围）等）。这些其实也是经验的一部分，真的做过的话就应该自己做做笔记，一定会有点印象的，不应该去抱佛脚。</p>\n<p><strong>面试原则</strong>：问到你会的，你就自信回答。问到偏门的，开发过程中较少出现/遇到和使用的，你就如实回答就好了，不要不懂装懂。</p>\n<p><strong>技术面的面试形式：</strong>可能是让你线上答卷，现场答卷，也可以是电话提问、视频提问。</p>\n<p><strong>面试时长</strong>：同项目面，也可能夹杂着在项目面中间进行提问。</p>\n<h1 id=\"拿offer\">拿Offer</h1>\n<p>拿到Offer后，你可能需要向HR详细确认的信息：</p>\n<ol type=\"1\">\n<li>每天上班时间，从几点到几点</li>\n<li>每个月的薪资计算时间是从几号到几号</li>\n<li>每个月的薪资发放日期、时间</li>\n<li>是否双休、年假情况</li>\n<li>每天的加班强度、每个月的加班强度、加班薪资等</li>\n<li>每年发放多少个月的薪资（就是年终奖发放情况，好一点的是15薪以上，最基本的13薪）</li>\n<li><strong>每个（税前）月薪资是多少</strong>（可能需要关心一下社保和公积金的缴纳情况等）</li>\n</ol>\n<p>基本信息了解完毕之后，需要自己有意识地去提问的一些问题：</p>\n<ol type=\"1\">\n<li>近期可以签订合同的最晚时间（合同期限一般都是3年，这个就比较不用担心）</li>\n<li>期望入职时间（自己期望什么时候入职，对方期望最晚什么时候入职，可否协调程度）</li>\n<li>涨薪计划（入职后会有哪些涨薪激励计划，或之前其他股权发放啊、年终奖增长等等）</li>\n<li>绩效计划（可能这时候不太愿意说，但是入职后可以去了解）</li>\n</ol>\n","categories":["Others"],"tags":["Exp"]},{"title":"POSIX","url":"/2021/05/23/Programming/2021-05-23-POSIX/","content":"<blockquote>\n<p><em>可移植操作系统接口（英语：Portable Operating System Interface，缩写为POSIX）是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，而国际标准名称为ISO/IEC 9945。此标准源于一个大约开始于1985年的项目。POSIX这个名称是由理查德·斯托曼（RMS）应IEEE的要求而提议的一个易于记忆的名称。它基本上是Portable Operating System Interface（可移植操作系统接口）的缩写，而X则表明其对Unix API的传承。</em></p>\n<p><em>Linux基本上逐步实现了POSIX兼容，但并没有参加正式的POSIX认证。[1]</em></p>\n<p><em>微软的Windows NT声称部分实现了POSIX标准。</em></p>\n<p><em>当前的POSIX主要分为四个部分[2]：Base Definitions、System Interfaces、Shell and Utilities和Rationale。</em></p>\n<p>——Wikipedia.org的 <a href=\"https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3\">可移植操作系统接口</a></p>\n</blockquote>\n<blockquote>\n<p><em>一般情况下，应用程序通过应用编程接口(API)而不是直接通过系统调用来编程。这点很重要，因为应用程序使用的这种编程接口实际上并不需要和内核 提供的系统调用对应。一个API定义了一组应用程序使用的编程接口。它们可以实现成一个系统调用，也可以通过调用多个系统调用来实现，而完全不使用任何系 统调用也不存在问题。实际上，API可以在各种不同的操作系统上实现，给应用程序提供完全相同的接口，而它们本身在这些系统上的实现却可能迥异。</em></p>\n<p><em>在Unix世界中，最流行的应用编程接口是基于POSIX标准的。从纯技术的角度看，POSIX是由IEEE的一组标准组成，其目标是提供一套大体上基于Unix的可移植操作系统标准。Linux是与POSIX兼容的。</em></p>\n<p><em>POSIX是说明API和系统调用之间关系的一个极好例子。在大多数Unix系统上，根据POSIX而定义的API函数和系统调用之间有着直接关 系。实际上，POSIX标准就是仿照早期Unix系统的界面建立的。另一方面，许多操作系统，像Windows NT，尽管和Unix没有什么关系，也提供了与POSIX兼容的库。</em></p>\n<p><em>Linux的系统调用像大多数Unix系统一样，作为C库的一部分提供如图5-1所示。如图5-1所示C库实现了Unix系统的主要API，包括标 准C库函数和系统调用。所有的C程序都可以使用C库，而由于C语言本身的特点，其他语言也可以很方便地把它们封装起来使用。此外，C库提供了POSIX的 绝大部分API。</em></p>\n<p><em>从程序员的角度看，系统调用无关紧要；他们只需要跟API打交道就可以了。相反，内核只跟系统调用打交道；库函数及应用程序是怎么使用系统调用不是内核所关心的。</em></p>\n<p>——《Linux内核设计与实现（第2版）》第5章</p>\n</blockquote>\n<p><strong>简单总结</strong></p>\n<p>完成同一功能，不同内核提供的系统调用（也就是一个函数）是不同的，例如创建进程，linux下是fork函数，windows下是creatprocess函数。好，我现在在linux下写一个程序，用到fork函数，那么这个程序该怎么往windows上移植？我需要把源代码里的fork通通改成creatprocess，然后重新编译...</p>\n<p>posix标准的出现就是为了解决这个问题。linux和windows都要实现基本的posix标准，linux把fork函数封装成posix_fork（随便说的），windows把creatprocess函数也封装成posix_fork，都声明在unistd.h里。这样，程序员编写普通应用时候，只用包含unistd.h，调用posix_fork函数，程序就在源代码级别可移植了</p>\n","categories":["Programming"],"tags":["C","C++","POSIX"]},{"title":"Debug问题排查思路","url":"/2021/08/03/Programming/2021-08-03-Debug%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/","content":"<p>以下内容适用于嵌入式开发工程师。</p>\n<h1 id=\"裸机debug\">裸机Debug</h1>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/20210915214751.png\" alt=\"image-20210804172539069\" /><figcaption aria-hidden=\"true\">image-20210804172539069</figcaption>\n</figure>\n<p>裸机调试过程中出现问题时，可以从以下几个角度进行考虑，分别是 <strong>电气特性</strong>、<strong>软件设置</strong> 、 <strong>代码设置</strong> 和 <strong>项目设置</strong>。</p>\n<h2 id=\"电气特性\">电气特性</h2>\n<p>排查电气特性的方法，主要是使用 <strong>万用表</strong>、<strong>逻辑分析仪</strong>、<strong>示波器</strong> 等可以捕捉电信号的设备进行直接的观察。</p>\n<p>例如使用万用表、示波器来检查电信号的电压、电流是否在正常工作范围。</p>\n<h2 id=\"软件设置\">软件设置</h2>\n<p>虽然软件设置和代码设置的命名方式相近，但是这里的软件设置更多强调的是系统级、寄存器级、驱动级的基础设置，而非算法级、代码级、逻辑级的更高一级设置。</p>\n<p>软件设置中，直观可见的是所有可能需要检查的问题点，都是可以通过查阅技术参考手册中的相关寄存器设置来检查是否设置正确的，包括中断、内存、时钟、外设等各项涉及到寄存器级别的内容。</p>\n<h2 id=\"代码设置\">代码设置</h2>\n<p>代码设置，强调的是算法级、代码级 或 逻辑级 的软件编写或设置。</p>\n<p>需要检查的更多是对应 芯片 及其 板载环境 、工作系统 之间的关系，例如代码里面有没有导致死循环、或者多线程之间的资源锁死、内存溢出等情况。</p>\n<h2 id=\"项目设置\">项目设置</h2>\n<h3 id=\"调试文件\">调试文件</h3>\n<h4 id=\"调试协议\">调试协议</h4>\n<h4 id=\"寻址文件\">寻址文件</h4>\n<p>但看调试文件，同样是f28004x系列芯片，通用的寻址文件就多达十几种。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210804172803808.png\" alt=\"image-20210804172803808\" /><figcaption aria-hidden=\"true\">image-20210804172803808</figcaption>\n</figure>\n<p>一般最高型号的芯片还有额外的 <code>.cmd</code> 文件，如：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210804172915025.png\" alt=\"image-20210804172915025\" /><figcaption aria-hidden=\"true\">image-20210804172915025</figcaption>\n</figure>\n<p>此时就需要仔细挑选对应的寻址文件，避免多个寻址文件载入导致寻址空间重名冲突。</p>\n<h2 id=\"案例\">案例</h2>\n<h3 id=\"adc中断未进入bug\">ADC中断未进入BUG</h3>\n<h4 id=\"情况1组中断未打开\">情况1——组中断未打开</h4>\n<p>ADC模块有检测到信号（下图<code>ADCRESULT0</code>） ，转换电容将电压转换成数值，但是没有触发中断，进而中断函数没有被执行。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210810093022182.png\" alt=\"image-20210810093022182\" /><figcaption aria-hidden=\"true\">image-20210810093022182</figcaption>\n</figure>\n<p>仔细检查对应的ADC中断标志寄存器，整理思路：SOC可以正常收到EPWM6的触发源进而正常地对电压进行转换，然后将数值存到对应寄存器中。也就是说，EOC也有正常工作，能够生成脉冲中断。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210818100405137.png\" alt=\"image-20210818100405137\" /><figcaption aria-hidden=\"true\">image-20210818100405137</figcaption>\n</figure>\n<p>对照着《TRM》中的说明文档再阅读一遍：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210818100624266.png\" alt=\"image-20210818100624266\" /><figcaption aria-hidden=\"true\">image-20210818100624266</figcaption>\n</figure>\n<p>接着再对应检查一下与中断相关的溢出标志寄存器，发现的确有中断溢出了。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210818100710508.png\" alt=\"image-20210818100710508\" /><figcaption aria-hidden=\"true\">image-20210818100710508</figcaption>\n</figure>\n<p>在ISR中断服务程序中写入一个全局调试变量，用于观察是否进入中断服务程序，可以知道其并未进入中断服务程序。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210818101346665.png\" alt=\"image-20210818101346665\" /><figcaption aria-hidden=\"true\">image-20210818101346665</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210818101314520.png\" alt=\"image-20210818101314520\" /><figcaption aria-hidden=\"true\">image-20210818101314520</figcaption>\n</figure>\n<p>最后对比检查样例代码中的main函数对ePIE寄存器的控制，发现少了一行对PIE控制寄存器的操作，补上~</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210818101749256.png\" alt=\"image-20210818101749256\" /><figcaption aria-hidden=\"true\">image-20210818101749256</figcaption>\n</figure>\n<p>成功进入中断：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210818101822146.png\" alt=\"image-20210818101822146\" /><figcaption aria-hidden=\"true\">image-20210818101822146</figcaption>\n</figure>\n<p><strong>总结</strong></p>\n<ul>\n<li>此处很重要的是要仔细研读《TRM》文件，将文档内的中断流程进行一一对照校验检查</li>\n<li>理解玩系统框图后，按照信号进入的顺序对涉及到的寄存器依次进行检查，逐个排查之后，再对其他可能会出现问题的地方进行DEBUG代码编写。</li>\n<li>如果没有参照手册，就得参照样例文件逐行检查代码</li>\n</ul>\n<h3 id=\"开启adc-c模块之后idle函数就不再执行\">开启ADC C模块之后IDLE函数就不再执行</h3>\n<h4 id=\"情况1中断函数不要处理大量数据计算\">情况1——中断函数不要处理大量数据计算</h4>\n<p>IDLE函数是写在 <code>main()</code> 函数中，最后面的位置的，以 <code>while(1)</code> 语句进行包裹着的永远循环的语句。</p>\n<p>在 <code>main()</code> 函数中，一般会对整个系统、外设、内存、中断等进行初始化和配置，一旦所有工作部件跑起来之后，需要CPU进行数据处理时，就会暂停进入IDLE函数，转而去处理更为紧急的事情，例如进行浮点数计算（如果没有开启对应的FPU的话），此时IDLE函数就会过很长一段时间（时间不定，依据实时处理情况而定）才执行一次。</p>\n<p>例如下方所示，一旦开启了对应的中断处理函数中的电压、温度、阻值计算，需要处理器实时且大量的计算的话，就会造成CPU短时/长时荷载较高，无法进入IDLE函数，原本在IDLE函数中设置为1秒闪烁一次的LED灯，过了十几二十秒才关闭/打开。</p>\n<p>一旦将其注释，LED灯的闪烁速度又得到了恢复。</p>\n<p>也可以在中断向量表和处理程序处进行注释以关闭中断处理，也可以看到LED等闪烁正常。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210824190557672.png\" alt=\"image-20210824190557672\" /><figcaption aria-hidden=\"true\">image-20210824190557672</figcaption>\n</figure>\n<h3 id=\"adc读值转换失败\">ADC读值/转换失败</h3>\n<h4 id=\"情况1adc触发源更改\">情况1——ADC触发源更改</h4>\n<p><strong>新增了功能</strong>：由主循环检测GPIO3上的引脚是否导通，导通则开启ePWM的时钟，否则不开启，开关检测代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sw1WrapFunc</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(GpioDataRegs.GPADAT.bit.GPIO3 == HIGH_LEVEL)&#123;  <span class=\"comment\">//是否为高电平</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(CpuSysRegs.PCLKCR2.bit.EPWM1 == ON) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            EALLOW;</span><br><span class=\"line\">            CpuSysRegs.PCLKCR2.bit.EPWM1 = ON;  <span class=\"comment\">//高电平且未开启则开启</span></span><br><span class=\"line\">            EDIS;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(GpioDataRegs.GPADAT.bit.GPIO3 == LOW_LEVEL)&#123;  <span class=\"comment\">//是否为低电平</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(CpuSysRegs.PCLKCR2.bit.EPWM1 == OFF) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            EALLOW;</span><br><span class=\"line\">            CpuSysRegs.PCLKCR2.bit.EPWM1 = OFF;  <span class=\"comment\">//低电平且已开启则关闭</span></span><br><span class=\"line\">            EDIS;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在增加了新功能之后，发现ADC突然不工作了，每次ePWM一关闭，ADC也跟着不工作，一打开ePWM，ADC又开始工作了。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210907134639238.png\" alt=\"image-20210907134639238\" /><figcaption aria-hidden=\"true\">image-20210907134639238</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210907134734391.png\" alt=\"image-20210907134734391\" /><figcaption aria-hidden=\"true\">image-20210907134734391</figcaption>\n</figure>\n<p>重新整理思路，想起来ADC工作的配置中，唯一一项跟PWM相关的就是其触发源。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210907135154333.png\" alt=\"image-20210907135154333\" /><figcaption aria-hidden=\"true\">image-20210907135154333</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210907135359661.png\" alt=\"image-20210907135359661\" /><figcaption aria-hidden=\"true\">image-20210907135359661</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210907135436244.png\" alt=\"image-20210907135436244\" /><figcaption aria-hidden=\"true\">image-20210907135436244</figcaption>\n</figure>\n<p>修改其触发源为CPU1 Timer0，正常工作：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210907135823329.png\" alt=\"image-20210907135823329\" /><figcaption aria-hidden=\"true\">image-20210907135823329</figcaption>\n</figure>\n<h4 id=\"情况2主函数被测试用的死循环卡住\">情况2——主函数被测试用的死循环卡住</h4>\n<p>主循环中一定不能再套一个等待状态（或死循环）的语句，否则整个主循环将有可能永远被卡死。</p>\n<p>写完SCI部分函数后，发现ADC温度转换的不工作了，但ADC的中断程序（中断程序对全局变量的写入成功）和中断溢出标志是可以正常处理的，同时写了一个Debug变量放在主循环下的ADC包装函数中，发现数据并未被处理，因此可以判断主程序被卡死。</p>\n<p>解决方法是，将SCI通信发送和接收的功能写到中断程序中，让中断程序来处理。</p>\n<h3 id=\"ecap外设没有正常工作\">ECAP外设没有正常工作</h3>\n<p>首先是注意到该外设对应的GPIO没有正常工作，查看 <code>GpioDataRegs</code> 下的 <code>GPADAT</code> 寄存器，发现GPIO10在其他外设都能正常工作的情况下，该引脚无法动弹（表现为：使用3.3V电源连接GPIO10，没有反映）。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210906172346311.png\" alt=\"image-20210906172346311\" /><figcaption aria-hidden=\"true\">image-20210906172346311</figcaption>\n</figure>\n<p>然后查看eCAP引脚源代码，初步推断可能是引脚方向设置出错，更改以下源代码中的最后一句以更改引脚信号导通方向。</p>\n<p>源代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Init_eCAP_GPIO</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//配置输入XBAR10</span></span><br><span class=\"line\">    InputXbarRegs.INPUT10SELECT = <span class=\"number\">0xA</span>; <span class=\"comment\">// 将GPIO10(0xA)与输入XBAR 10进行连接</span></span><br><span class=\"line\"></span><br><span class=\"line\">    GpioCtrlRegs.GPAGMUX1.bit.GPIO10 = <span class=\"number\">0</span>;  <span class=\"comment\">//外设组多路配置</span></span><br><span class=\"line\">    GpioCtrlRegs.GPAMUX1.bit.GPIO10 = <span class=\"number\">3</span>;  <span class=\"comment\">//外设多路配置</span></span><br><span class=\"line\">    GpioCtrlRegs.GPADIR.bit.GPIO10 = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再次测试发现结果正常。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210907094432301.png\" alt=\"image-20210907094432301\" /><figcaption aria-hidden=\"true\">image-20210907094432301</figcaption>\n</figure>\n<p>修改后代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Init_eCAP_GPIO</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//配置输入XBAR10</span></span><br><span class=\"line\">    EALLOW;</span><br><span class=\"line\">    InputXbarRegs.INPUT10SELECT = <span class=\"number\">0xA</span>; <span class=\"comment\">// 将GPIO10(0xA)与输入XBAR 10进行连接</span></span><br><span class=\"line\"></span><br><span class=\"line\">    GpioCtrlRegs.GPAGMUX1.bit.GPIO10 = <span class=\"number\">0</span>;  <span class=\"comment\">//外设组多路配置</span></span><br><span class=\"line\">    GpioCtrlRegs.GPAMUX1.bit.GPIO10 = <span class=\"number\">3</span>;  <span class=\"comment\">//外设多路配置</span></span><br><span class=\"line\">    GpioCtrlRegs.GPADIR.bit.GPIO10 = GPIO_SIGNAL_INPUT;  <span class=\"comment\">// INPUT 输入</span></span><br><span class=\"line\">    GpioCtrlRegs.GPAPUD.bit.GPIO10 = GPIO_PULLUP_DISABLE;</span><br><span class=\"line\">    GpioCtrlRegs.GPAQSEL1.bit.GPIO10 = GPIO_SYNCHRONIZE;</span><br><span class=\"line\">    EDIS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：因为GPIO9和GPIO10临近，默认情况下GPIO10还是会受到附近（结构上）其他GPIO电平的影响而拉高，此时即使设置了 <code>GPIO_PULLUP_DISABLE</code> 都没办法置低。同时，GPIO9也会因为GPIO10的电平拉低而拉低。</p>\n<h3 id=\"ecap引脚配置\">ECAP引脚配置</h3>\n<p>从GPIO部分的图8-1、 引脚部分的 表4-6 、X-BAR部分的 图9-1 和 eCAP部分的表19-1 四份内容可以看出，GPIO10 没办法被通过INPUT X-BAR 复用到ECAP上。</p>\n<p>因为表4-6决定了，GPIO10不能复用到INPUT X-BAR 或 OUT-BAR，但可以复用为自己（GPIO10），只需要设置 <code>GPAGMUX.bit.GPIO10 = 0x0; GPAMUX.bit.GPIO10 = 0x0;</code> 即可。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210913105909558.png\" alt=\"image-20210913105909558\" /><figcaption aria-hidden=\"true\">image-20210913105909558</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210913110038846.png\" alt=\"image-20210913110038846\" /><figcaption aria-hidden=\"true\">image-20210913110038846</figcaption>\n</figure>\n<p><img src=\"https://pic.islet.space/2021/09/image-20210913110545272.png\" alt=\"image-20210913110545272\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/09/image-20210913110506997.png\" alt=\"image-20210913110506997\" style=\"zoom: 67%;\" /></p>\n<h3 id=\"sci引脚导致复位\">SCI引脚导致复位</h3>\n<p>SCI配置完毕后，与对应的GPIO引脚无法通信（即无高低电平变化），将逻辑分析仪插入对应的引脚，会导致芯片复位重启。</p>\n<p>原GPIO引脚配置为：一个GPIO为拉高和异步，另一个为拉高和同步。</p>\n<p>将两个GPIO修改为异步配置之后，并未出现复位情况。</p>\n<h3 id=\"sci-rx数据错误\">SCI RX数据错误</h3>\n<p>使用RS485进行发送时，不仅接收会存在错误，发送也会存在错误。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210914155055154.png\" alt=\"image-20210914155055154\" /><figcaption aria-hidden=\"true\">image-20210914155055154</figcaption>\n</figure>\n<div style=\"font-weight: 900; font-size: 0.8rem; text-align: center;\">\n图 使用XCOM串口助手和GREE DATACONVERTER进行发送和CCS中数组值有异\n</div>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210914155215669.png\" alt=\"image-20210914155215669\" /><figcaption aria-hidden=\"true\">image-20210914155215669</figcaption>\n</figure>\n<div style=\"font-weight: 900; font-size: 0.8rem; text-align: center;\">\n图 使用GREE DATACONVERTER接收数据时也存在错误-1\n</div>\n<p>在数据量较低且手动点击鼠标进行发送时，仍然会有数据处理错误：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210914170117568.png\" alt=\"image-20210914170117568\" /><figcaption aria-hidden=\"true\">image-20210914170117568</figcaption>\n</figure>\n<div style=\"font-weight: 900; font-size: 0.8rem; text-align: center;\">\n图 使用GREE DATACONVERTER接收数据时也存在错误-2\n</div>\n<p>同样的代码（中途未复位重启芯片）对比使用CH340芯片进行发送和接收：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210914155521881.png\" alt=\"image-20210914155521881\" /><figcaption aria-hidden=\"true\">image-20210914155521881</figcaption>\n</figure>\n<div style=\"font-weight: 900; font-size: 0.8rem; text-align: center;\">\n图 使用CH340进行发送和接收时数据无误\n</div>\n<p>SCI未触发中断</p>\n<h1 id=\"系统debug\">系统Debug</h1>\n<h1 id=\"windowslinuxmac\">Windows/Linux/Mac</h1>\n<h2 id=\"分离式代码的联合编译\">分离式代码的联合编译</h2>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211009172229.png\" alt=\"image-20211009172014699\" /><figcaption aria-hidden=\"true\">image-20211009172014699</figcaption>\n</figure>\n<p>上图为使用VS Code进行项目编译时报错的情况，在使用 MinGW 的g++ 作为编译器时，一开始使用 <code>main.cpp</code> 作为被编译的文件进行编译运行，成功可用。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211011173023.png\" alt=\"image-20211011150027217\" /><figcaption aria-hidden=\"true\">image-20211011150027217</figcaption>\n</figure>\n<p>后期新增了 <code>SerialPort.h</code> 和 <code>SerialPort.cpp</code> ，再次点击编译发现失败。说是查找不到 <code>SerialPort</code> 类下的函数定义相关的报错，并不是因为没有给 <code>SerialPort::SerialPort()</code> 等这些类里的函数进行定义，只是因为定义和声明并不在同一个 <code>.h</code> 文件里面。因为将类定义写在了 <code>.h</code> 文件中，而定义写在了另一个 <code>.cpp</code> 文件中，因此该编程方式称为 <strong>分离式代码</strong>。如果将其书写到同一个 <code>.hpp</code> 文件里，就称为 <strong>非分离式代码</strong>。</p>\n<p>采用的 <strong>分离式</strong> 的代码书写方法，造成了 <code>g++</code> 编译器在只编译 <code>main.cpp</code> 的情况下会报错 <strong>函数未定义</strong> 。</p>\n<h3 id=\"解决办法\">解决办法</h3>\n<p>对分离式的 C++ 代码，需要联合多个 <code>.cpp</code> 文件进行编译，在Linux系统上使用命令行进行编译即可提现 如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">g++ main.cpp SerialPort.cpp -o main --std=c++17</span><br></pre></td></tr></table></figure>\n<p>上面就把 <code>main.cpp</code> 和 <code>SerialPort.cpp</code> 两个代码文件联合在一起进行编译，只生成一个 <code>main</code> 二进制可运行文件。</p>\n<p>类似，只要在Windows上能用同一句编译命令实现多个 <code>.cpp</code> 文件的编译即可，但自己没有找到如何在 VS Code中进行该操作方法。另辟蹊径找到了用Terminal进行搞定，方法如下：</p>\n<ol type=\"1\">\n<li>将 <code>D:\\mingw64\\bin</code> 加入到 <strong>系统环境变量</strong> 的 <code>Path</code> 变量下：</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211011173019.png\" alt=\"image-20211011150836483\" /><figcaption aria-hidden=\"true\">image-20211011150836483</figcaption>\n</figure>\n<ol start=\"2\" type=\"1\">\n<li>打开 Terminal 进行跳转到工作目录，或者在工作目录按 <code>shift</code> 同时点击右键菜单里的 <code>在Windows终端中打开</code> 即可。</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211011173017.png\" alt=\"image-20211011150800473\" /><figcaption aria-hidden=\"true\">image-20211011150800473</figcaption>\n</figure>\n<ol start=\"3\" type=\"1\">\n<li>尝试进行编译，发现就不报这个 <code>undefined reference</code> 的错了。</li>\n</ol>\n<h3 id=\"总结\">总结</h3>\n<p>分离式代码就需要联合多个 <code>.cpp</code> 文件进行编译，不能只编译一个 <code>main.cpp</code>，Windows Terminal 也可以直接操作 <code>g++</code> （只要加了系统变量）进行多文件编译。</p>\n<h2 id=\"cannot-convert\">CANNOT CONVERT</h2>\n<p>以下为 VS Code中的报错：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211009172849.png\" alt=\"image-20211009172830768\" /><figcaption aria-hidden=\"true\">image-20211009172830768</figcaption>\n</figure>\n<p>以下为 Terminal g++ 中的报错：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211011173012.png\" alt=\"image-20211011151525322\" /><figcaption aria-hidden=\"true\">image-20211011151525322</figcaption>\n</figure>\n<p>cannot convert <code>const wchar_t*</code> to <code>LPCSTR</code> ，即是说，无法将<code>const wchar_t*</code> 类型转换为 <code>LPCSTR</code> 类型。</p>\n<p>LPCSTR，即 <em>long pointer const string</em> , 是Win32和VC++所使用的一种字符串数据类型。定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> _Null_terminated_ CONST CHAR *LPCSTR, *PCSTR; </span><br></pre></td></tr></table></figure>\n<p><code>LPCSTR</code> 代表了 <code>const char *</code> 类型，它是一个指向以 <code>\\0</code> 结尾的 8 bit（单字节）<strong>ANSI字符数组</strong> 的常量指针。</p>\n<p>而 <code>const wchar_t *</code> 类型是一个指向 <code>\\0</code> 结尾的 16 bit（双字节）<strong>Unicode字符数组</strong> 的常量指针。</p>\n<p>在VS2013编译器中直接输入的字符串常量（如 <code>“abc”</code> ）默认是以 <code>const char *</code> 的格式（即ANSI编码）储存的，因此会导致类型不匹配的编译错误。</p>\n<h3 id=\"解决办法-1\">解决办法</h3>\n<p>以下办法查询自网络，未实践：</p>\n<ol type=\"1\">\n<li>Visual Studio: 右击“解决方案资源管理器”中的项目，“属性→配置属性→常规→项目默认值→字符集”，默认的选项是“使用多字节字符集”，将它改为“使用Unicode字符集”即可。这样，输入的字符串会默认以 <code>const wchar_t *</code> 格式储存。</li>\n<li>使用 <code>_T</code> 宏，它在 &lt;tchar.h&gt; 中定义，它能够自动识别当前编译器字符串的储存格式并做出相应转换，避免这种类型的编译错误。具体使用方法为：将 <code>“abc”</code> 改为 <code>_T(\"abc\")</code> 。</li>\n</ol>\n<p>以下办法亲自实验可用：</p>\n<ol type=\"1\">\n<li>删除该实参 <code>L\"xxxxxx\"</code> 前的 <code>L</code> 字符即可，在使用 MinGW 编译器的情况下，如果有该 <code>L</code> 字符，就会一直报错，就算将文本字符集改成 <code>UTF-16 LE/BE</code> ，虽然不会报该 <code>L</code> 字符的错了，但仍会出现其他问题，也是因为字符集搞的鬼。在Linux或Mac下就不会报该错误。</li>\n</ol>\n","categories":["Programming"],"tags":["Debug"]},{"title":"使用VS Code同步Gitee项目","url":"/2021/09/02/Programming/2021-09-02-%E4%BD%BF%E7%94%A8VS-Code%E5%90%8C%E6%AD%A5Gitee%E9%A1%B9%E7%9B%AE/","content":"<p>自从Github被微软收购，除了Copilot这个AI代码写作助手，大家开源贡献的代码都被拿来用了之后，就不想在Github上贡献代码了。</p>\n<p>转而使用Gitee，感觉也挺好。</p>\n<h1 id=\"生成并绑定公钥\">生成并绑定公钥</h1>\n<p>使用terminal生成公钥：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-keygen</span><br></pre></td></tr></table></figure>\n<p>遇到选择就按回车，不用管就好。然后使用以下命令进行查看：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n<p>公钥样例（千万不要复制下面的模板）如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-rsa BBBBA3NzaC1yc2EBBBBDAQBABBBABQCoLmvwKsFETfy0Lj8VN0QwDj/fu2J1msoM+kWCLTj64zXXXXXXXXXSKQxj30zjVO4tZ9PsO/jaItdev1uV7a9lk9MiemLLAxc1LSYsBdki81tx+7941rl9y/XXXXXXXXXXDjNpPCMq6xH8ZSRoRLcgCz+gRaDfnQALWBcavEO0uVqYGn4I4KRFPup7gm+3j5gRpdm1uKtkrqHxqykErCwXXXXXXXXXX6+okRt/TN5jjq6zV44D6tRYAK6oCOFpwO/RTqTIUU//w/XXXXXXXXXXXXXXXXXXXXdPCqs8Zax9cH/31FJqltQzsRbGDLTFFXqyICK7QKVgFXGhrzM3AVvD xxxx@xxxx.local</span><br></pre></td></tr></table></figure>\n<h1 id=\"绑定到gitee配置\">绑定到Gitee配置</h1>\n<p>这里就不延时注册Gitee账户了。</p>\n<p>在Gitee头像下点击 <strong>设置</strong> ，然后在左侧选择 <strong>SSH公钥</strong>，将生成的公钥粘贴进去，标题会自动识别和生成，使用默认标题即可，最后点击 <strong>确定</strong> 进行保存。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210902220637986.png\" alt=\"image-20210902220637986\" /><figcaption aria-hidden=\"true\">image-20210902220637986</figcaption>\n</figure>\n<h1 id=\"在gitee上生成项目\">在Gitee上生成项目</h1>\n<p>在gitee页面右上角选择那个 <code>+</code> 号，选择里面的 <strong>新建仓库</strong>。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210902222312335.png\" alt=\"image-20210902222312335\" /><figcaption aria-hidden=\"true\">image-20210902222312335</figcaption>\n</figure>\n<p>跳转到 <strong>新建仓库</strong> 仓库页面，填写相关信息即可。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210902222413221.png\" alt=\"image-20210902222413221\" /><figcaption aria-hidden=\"true\">image-20210902222413221</figcaption>\n</figure>\n<p>然后在仓库页面的 <strong>克隆/下载</strong> 处选择 <strong>HTTPS</strong> 源 并 <strong>复制</strong>。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210902222531450.png\" alt=\"image-20210902222531450\" /><figcaption aria-hidden=\"true\">image-20210902222531450</figcaption>\n</figure>\n<h1 id=\"绑定vscode\">绑定VSCode</h1>\n<p>在本地新建文件夹，命名和存储路径随意。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210902222116108.png\" alt=\"image-20210902222116108\" /><figcaption aria-hidden=\"true\">image-20210902222116108</figcaption>\n</figure>\n<p>然后使用VSCode打开该文件夹，如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210902222631177.png\" alt=\"image-20210902222631177\" /><figcaption aria-hidden=\"true\">image-20210902222631177</figcaption>\n</figure>\n<p>点选左侧树杈型图标，选择 <strong>初始化存储库</strong>。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210902222655162.png\" alt=\"image-20210902222655162\" /><figcaption aria-hidden=\"true\">image-20210902222655162</figcaption>\n</figure>\n<p>在上方 <code>...</code> 处选择 <strong>远程</strong>，<strong>添加远程仓库</strong>。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210902223026835.png\" alt=\"image-20210902223026835\" /><figcaption aria-hidden=\"true\">image-20210902223026835</figcaption>\n</figure>\n<p>粘贴刚刚复制过来的仓库地址。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210902223107646.png\" alt=\"image-20210902223107646\" /><figcaption aria-hidden=\"true\">image-20210902223107646</figcaption>\n</figure>\n<p>填写远程存储库名称，就是仓库名称。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210902223222009.png\" alt=\"image-20210902223222009\" /><figcaption aria-hidden=\"true\">image-20210902223222009</figcaption>\n</figure>\n<p>VSCode右下角会出现如下提示，选择 <strong>是</strong>。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210902223253826.png\" alt=\"image-20210902223253826\" /><figcaption aria-hidden=\"true\">image-20210902223253826</figcaption>\n</figure>\n<p>正常来说点选 <strong>拉取</strong> 也是直接可以拉取到远程数据的，但是也可能因为配置错误导致拉取失败，出现如下提示。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210902223319460.png\" alt=\"image-20210902223319460\" /><figcaption aria-hidden=\"true\">image-20210902223319460</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210902224720818.png\" alt=\"image-20210902224720818\" /><figcaption aria-hidden=\"true\">image-20210902224720818</figcaption>\n</figure>\n<h1 id=\"配置本地git参数\">配置本地git参数</h1>\n<p>如果拉取不成功，仍需要配置以下信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">&quot;xxxx&quot;</span></span><br><span class=\"line\">git config --global user.email xxxx@xxx.com</span><br></pre></td></tr></table></figure>\n<p>其中xxxx需要替换成个人在gitee网站的用户名和对应的邮箱，如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210902224904264.png\" alt=\"image-20210902224904264\" /><figcaption aria-hidden=\"true\">image-20210902224904264</figcaption>\n</figure>\n<h1 id=\"拉取仓库文件\">拉取仓库文件</h1>\n<p>如果仍然无法拉取仓库文件，可以在VSCode下按 <code>CTRL</code> + <code>J</code> 或 <code>COMMAND</code> + <code>J</code> 来打开，然后输入如下命令进行 拉取，命令中对应的源需要替换。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git pull https://gitee.com/xxxx/xxxx.git master</span><br></pre></td></tr></table></figure>\n<p>拉取完后如下所示：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210902225228260.png\" alt=\"image-20210902225228260\" /><figcaption aria-hidden=\"true\">image-20210902225228260</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210902225338842.png\" alt=\"image-20210902225338842\" /><figcaption aria-hidden=\"true\">image-20210902225338842</figcaption>\n</figure>\n","categories":["Programming"],"tags":["Git","VSCode","Gitee"]},{"title":"网页前端开发笔记","url":"/2020/11/05/Web/2020-11-05-%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"<h1 id=\"part-1-html\">PART 1: HTML</h1>\n<div style=\"font-style: italic; color: #999; text-align: right;\">\n——佳佳\n</div>\n<p>Hyper Text Markup Language超文本标记语言</p>\n<h2 id=\"html框架\">HTML框架</h2>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span>\t</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">long</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>TAG<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"常用标签\">常用标签</h2>\n<h3 id=\"基础标签\">基础标签</h3>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span>\t</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">long</span>=<span class=\"string\">&quot;zh&quot;</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>网页标题<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>内容标题<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">hr</span>&gt;</span><span class=\"comment\">&lt;!--此处添加水平线--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">                此处为<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>段落内容</span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: center;\">标签</th>\n<th style=\"text-align: center;\">功能</th>\n<th style=\"text-align: center;\">应用</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">&lt;DOCTYPE&gt;</td>\n<td style=\"text-align: center;\">定义文档类型</td>\n<td style=\"text-align: center;\">&lt;!DOCTYPE html&gt;</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">&lt;html&gt;</td>\n<td style=\"text-align: center;\">定义一个HTML文档</td>\n<td style=\"text-align: center;\">&lt;html long=\"zh\"&gt;内容&lt;/html&gt;</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">&lt;title&gt;</td>\n<td style=\"text-align: center;\">为文档定义一个标题</td>\n<td style=\"text-align: center;\">&lt;title&gt;标题&lt;/title&gt;</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">&lt;body&gt;</td>\n<td style=\"text-align: center;\">文档的主体</td>\n<td style=\"text-align: center;\">&lt;body&gt;主体&lt;/body&gt;</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">&lt;h1&gt;to&lt;h6&gt;</td>\n<td style=\"text-align: center;\">HTML标题</td>\n<td style=\"text-align: center;\">&lt;h1&gt;标题&lt;/h1&gt;</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">&lt;p&gt;</td>\n<td style=\"text-align: center;\">一个段落</td>\n<td style=\"text-align: center;\">&lt;p&gt;内容&lt;/p&gt;</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">&lt;br&gt;</td>\n<td style=\"text-align: center;\">换行</td>\n<td style=\"text-align: center;\">&lt;br/&gt;</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">&lt;hr&gt;</td>\n<td style=\"text-align: center;\">水平线</td>\n<td style=\"text-align: center;\">&lt;hr&gt;</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">&lt;!----&gt;</td>\n<td style=\"text-align: center;\">注释</td>\n<td style=\"text-align: center;\">&lt;!--需要注释的内容--&gt;</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"格式标签\">格式标签</h3>\n<table>\n<colgroup>\n<col style=\"width: 16%\" />\n<col style=\"width: 41%\" />\n<col style=\"width: 41%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: center;\">标签</th>\n<th style=\"text-align: left;\">功能</th>\n<th style=\"text-align: left;\">应用</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">&lt;abbr&gt;</td>\n<td style=\"text-align: left;\">定义一个缩写</td>\n<td style=\"text-align: left;\">&lt;abbr title=\"蹲坑\"&gt;dk&lt;/abbr&gt;</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">&lt;address&gt;</td>\n<td style=\"text-align: left;\">定义文档作者/所有者的联系信息</td>\n<td style=\"text-align: left;\">&lt;address&gt;地址联系信息&lt;/address&gt;</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">&lt;b&gt;</td>\n<td style=\"text-align: left;\">加粗(无语义)</td>\n<td style=\"text-align: left;\">&lt;b&gt;文本&lt;/b&gt;</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">&lt;bdi&gt;</td>\n<td style=\"text-align: left;\">设置一段文本，使其脱离其父元素的文本方向设置</td>\n<td style=\"text-align: left;\">&lt;bdi&gt;文本&lt;/bdi&gt;</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">&lt;bdo&gt;</td>\n<td style=\"text-align: left;\">定义文本方向（rtl&amp;ltr）</td>\n<td style=\"text-align: left;\">&lt;bdo dir=\"rtl\"&gt;文本&lt;/bdo&gt;</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">&lt;blockquote&gt;</td>\n<td style=\"text-align: left;\">块引用(cite)</td>\n<td style=\"text-align: left;\">&lt;blockquote cite=\"url\"&gt;引用内容&lt;/blockquote&gt;</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">&lt;cite&gt;</td>\n<td style=\"text-align: left;\">定义作品的标题（书籍、歌曲、电影等）</td>\n<td style=\"text-align: left;\">&lt;cite&gt;作品标题&lt;/cite&gt;</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">&lt;code&gt;</td>\n<td style=\"text-align: left;\">定义计算机代码文本</td>\n<td style=\"text-align: left;\">&lt;code&gt;代码&lt;/code&gt;</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">&lt;del&gt;</td>\n<td style=\"text-align: left;\">删除线</td>\n<td style=\"text-align: left;\">&lt;del&gt;要删除的文本&lt;/del&gt;</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">&lt;dfn&gt;</td>\n<td style=\"text-align: left;\">定义项目</td>\n<td style=\"text-align: left;\">&lt;dfn&gt;项目名&lt;/dfn&gt;</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">&lt;em&gt;</td>\n<td style=\"text-align: left;\">倾斜字体（语义较强）</td>\n<td style=\"text-align: left;\">&lt;em&gt;字体&lt;/em&gt;</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">&lt;i&gt;</td>\n<td style=\"text-align: left;\">倾斜字体（无语义）</td>\n<td style=\"text-align: left;\">&lt;i&gt;需倾斜文本&lt;/i&gt;</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">&lt;ins&gt;</td>\n<td style=\"text-align: left;\">定义删除后新插入的文本</td>\n<td style=\"text-align: left;\">&lt;del&gt;red&lt;/del&gt;&lt;ins&gt;blue&lt;/ins&gt;</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\"><mark>&lt;mark&gt;</mark></td>\n<td style=\"text-align: left;\">高亮文本</td>\n<td style=\"text-align: left;\">&lt;mark&gt;文本&lt;/mark&gt;</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\"><mark>&lt;meter&gt;</mark></td>\n<td style=\"text-align: left;\">已知最大最小值的度量<br>value(必须)：规定当前值<br>max:规定最大值；min:规定最小值<br>high:规定最高值；low:规定最低值<br>optimum:规定最优值</td>\n<td style=\"text-align: left;\">&lt;meter value=\"2\" min=\"0\" max=\"10\"&gt;2 out of 10&lt;/meter&gt;<br>&lt;meter value=\"0.6\"&gt;60%&lt;/meter&gt;</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\"><mark>&lt;progress&gt;</mark></td>\n<td style=\"text-align: left;\">定义运行任务进度</td>\n<td style=\"text-align: left;\">&lt;progress value=\"22\" max=\"100\"&gt;&lt;/progress&gt;</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">&lt;q&gt;</td>\n<td style=\"text-align: left;\">定义短的引用</td>\n<td style=\"text-align: left;\">&lt;q&gt;引用内容&lt;/q&gt;</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\"><mark>&lt;rp&gt;</mark></td>\n<td style=\"text-align: left;\">定义不支持 ruby 元素的浏览器所显示的内容</td>\n<td style=\"text-align: left;\">&lt;ruby&gt;&lt;br/&gt;汉 &lt;rt&gt;&lt;rp&gt;(&lt;/rp&gt;ㄏㄢˋ&lt;rp&gt;)&lt;/rp&gt;&lt;/rt&gt;&lt;br/&gt;&lt;/ruby&gt;</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\"><mark>&lt;rt&gt;</mark></td>\n<td style=\"text-align: left;\">定义字符（中文注音或字符）的解释或发音</td>\n<td style=\"text-align: left;\">&lt;ruby&gt;&lt;br/&gt;汉 &lt;rt&gt; ㄏㄢˋ &lt;/rt&gt;&lt;br/&gt;&lt;/ruby&gt;</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\"><mark>&lt;ruby&gt;</mark></td>\n<td style=\"text-align: left;\">定义ruby注释（中文注音或字符）</td>\n<td style=\"text-align: left;\">&lt;ruby&gt;&lt;br/&gt;汉 &lt;rt&gt; ㄏㄢˋ &lt;/rt&gt;&lt;br/&gt;&lt;/ruby&gt;</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">&lt;s&gt;</td>\n<td style=\"text-align: left;\">删除线</td>\n<td style=\"text-align: left;\">&lt;s&gt;文本&lt;/s&gt;</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">&lt;strong&gt;</td>\n<td style=\"text-align: left;\">加粗（语义较强）</td>\n<td style=\"text-align: left;\">&lt;strong&gt;文本&lt;/strong&gt;</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">&lt;sub&gt;</td>\n<td style=\"text-align: left;\">下标文本</td>\n<td style=\"text-align: left;\">&lt;sub&gt;文本&lt;/sub&gt;</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">&lt;sup&gt;</td>\n<td style=\"text-align: left;\">上标文本</td>\n<td style=\"text-align: left;\">&lt;sup&gt;文本&lt;/sup&gt;</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\"><mark>&lt;time&gt;</mark></td>\n<td style=\"text-align: left;\">定义公历时间（24）或日期</td>\n<td style=\"text-align: left;\">The concert starts at &lt;time&gt;20:00&lt;/time&gt;<br>The concert took place on <time datetime=\"2001-05-15 19:00\">May 15</time></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">&lt;u&gt;</td>\n<td style=\"text-align: left;\">下划线</td>\n<td style=\"text-align: left;\">&lt;u&gt;文本&lt;/u&gt;</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"表单标签\">表单标签</h3>\n<table>\n<colgroup>\n<col style=\"width: 15%\" />\n<col style=\"width: 84%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>标签</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>&lt;form&gt;</td>\n<td>定义一个表单域</td>\n</tr>\n<tr class=\"even\">\n<td>&lt;input&gt;</td>\n<td>定义一个输入控件<br>type: <br>button:定义一个按钮。<br>file:选择文件<br>submit:提交按钮(点击后会向后台提交所选表单域中的信息)<br>search:搜索框<br>password:密码框<br>date:选择时间框(年-月-日)<br>text:单行文本<br>datetime-local:选择年月日时分<br>tel:电话号码 <br>radio:单选按钮(需要给<mark>相同的name</mark>)<br>checkbox:复选按钮<br>color:选择颜色<br>email:邮箱<br>number:输入数字<br>reset:重新输入<br>week:多少年的第几周</td>\n</tr>\n<tr class=\"odd\">\n<td>&lt;textarea&gt;</td>\n<td>多行文本输入框&lt;textarea&gt;自定义内容&lt;/textarea&gt;</td>\n</tr>\n<tr class=\"even\">\n<td>&lt;select&gt;</td>\n<td>下拉选择列表&lt;select&gt;option*N&lt;/select&gt;<br>size:规定下拉菜单中可见的选项数目<br>required=\"required\":必须要选一个<br>multiple=\"true\":可选多个选项</td>\n</tr>\n<tr class=\"odd\">\n<td>&lt;optgroup&gt;</td>\n<td>选择列表中相关选项的组合{<optgroup label=\"组合名\">option*N</optgroup>}N</td>\n</tr>\n<tr class=\"even\">\n<td>&lt;option&gt;</td>\n<td>选择列表中的选项</td>\n</tr>\n<tr class=\"odd\">\n<td>&lt;label&gt;</td>\n<td>input元素的标注(不点击控件，点链接到的文字也可以定位到控件)<br>&lt;label <mark>for=\"male\"</mark>&gt;Male&lt;/label&gt;<br/>&lt;input type=\"radio\" name=\"sex\" <mark>id=\"male\"</mark> value=\"male\"&gt;</td>\n</tr>\n<tr class=\"even\">\n<td>&lt;fieldset&gt;</td>\n<td>围绕表单中元素的边框</td>\n</tr>\n<tr class=\"odd\">\n<td>&lt;legend&gt;</td>\n<td>定义fieldset元素的标题</td>\n</tr>\n<tr class=\"even\">\n<td>&lt;datalist&gt;</td>\n<td>规定input元素可能的选项列表</td>\n</tr>\n<tr class=\"odd\">\n<td>&lt;keygen&gt;</td>\n<td>用于表单的秘钥对生成器字段</td>\n</tr>\n<tr class=\"even\">\n<td>&lt;output&gt;</td>\n<td>定义计算的结果</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"多媒体标签\">多媒体标签</h3>\n<h4 id=\"图像标签\">图像标签</h4>\n<p><mark>&lt;img&gt;</mark></p>\n<p><strong>作用：</strong>向网页中嵌入一张图片</p>\n<p><strong>应用：</strong><code>&lt;img src=\"url\" alt=\"图片加载不出来时的代替文本\" title=\"鼠标放到图片上的介绍文本\"&gt;</code></p>\n<p><strong>Note:</strong>绝对路径用“”;相对路径用“/”</p>\n<h4 id=\"视频标签\">视频标签</h4>\n<h4 id=\"音频标签\">音频标签</h4>\n<h3 id=\"超链接标签\">超链接标签</h3>\n<p><mark>&lt;a&gt;</mark></p>\n<p><strong>作用</strong>：超链接</p>\n<p><strong>应用</strong>：&lt;a href=\"链接地址\" target=\"_blank\"&gt;连接描述&lt;/a&gt;<strong><code>（内部、外部链接）</code></strong></p>\n<p>​ &lt;a href=\"#\"&gt;链接描述&lt;/a&gt;<strong><code>（空链接）</code></strong></p>\n<p>​ &lt;a href=\"文件地址、压缩包地址\"&gt;<strong><code>下载文件</code></strong>&lt;/a&gt;<strong><code>（文本、图片、视频、音频等均可以为超链接）</code></strong></p>\n<p>​ &lt;a href=\"#age\"&gt;年龄&lt;/a&gt;</p>\n<p>​ &lt;h3 id=\"age\"&gt;年龄详情&lt;/h3&gt;<strong><code>(锚点链接)</code></strong></p>\n<p>Note:</p>\n<ul>\n<li>默认为_self(当前窗口打开)</li>\n<li>_blank(新窗口中打开)</li>\n<li>​ _top(整个窗口中打开)</li>\n</ul>\n<h3 id=\"列表标签\">列表标签</h3>\n<table>\n<thead>\n<tr class=\"header\">\n<th>标签</th>\n<th>功能</th>\n<th>应用</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>&lt;ul&gt;</td>\n<td>定义一个无序列表</td>\n<td>&lt;ul&gt;&lt;li&gt;&lt;li&gt;&lt;/li&gt;&lt;/li&gt;&lt;&lt;/ul&gt;</td>\n</tr>\n<tr class=\"even\">\n<td>&lt;ol&gt;</td>\n<td>定义一个有序列表</td>\n<td>&lt;ol&gt;&lt;li&gt;&lt;li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/ol&gt;</td>\n</tr>\n<tr class=\"odd\">\n<td>&lt;li&gt;</td>\n<td>定义列表项</td>\n<td>&lt;ol&gt;&lt;li&gt;&lt;li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/ol&gt;</td>\n</tr>\n<tr class=\"even\">\n<td>&lt;dl&gt;</td>\n<td>定义一个定义列表</td>\n<td>&lt;dl&gt;&lt;dt&gt;电脑&lt;/dt&gt;&lt;dd&gt;电脑的解释&lt;/dd&gt;&lt;/dl&gt;</td>\n</tr>\n<tr class=\"odd\">\n<td>&lt;dt&gt;</td>\n<td>定义列表中的项目</td>\n<td>&lt;dl&gt;&lt;dt&gt;电脑&lt;/dt&gt;&lt;dd&gt;电脑的解释&lt;/dd&gt;&lt;/dl&gt;</td>\n</tr>\n<tr class=\"even\">\n<td>&lt;dd&gt;</td>\n<td>定义列表中的项目描述</td>\n<td>&lt;dl&gt;&lt;dt&gt;电脑&lt;/dt&gt;&lt;dd&gt;电脑的解释&lt;/dd&gt;&lt;/dl&gt;</td>\n</tr>\n</tbody>\n</table>\n<p>Note:</p>\n<ul>\n<li><p>&lt;ul&gt;&lt;ol&gt;里面只能放&lt;li&gt;标签，&lt;li&gt;标签里面可以放弃他标签</p></li>\n<li><p>&lt;dd&gt;中的内容是&lt;dt&gt;中内容的说明或是包含于&lt;dd&gt;内容</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">long</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>列表<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>洗衣机<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>冰箱<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>空调<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>太阳<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>地球<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>西安<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">dl</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">dt</span>&gt;</span>跨栏<span class=\"tag\">&lt;/<span class=\"name\">dt</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">dd</span>&gt;</span>是一项运动<span class=\"tag\">&lt;/<span class=\"name\">dd</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">dd</span>&gt;</span>奥运会项目<span class=\"tag\">&lt;/<span class=\"name\">dd</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">dd</span>&gt;</span>刘翔是冠军<span class=\"tag\">&lt;/<span class=\"name\">dd</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">dl</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"表格标签\">表格标签</h3>\n<table>\n<thead>\n<tr class=\"header\">\n<th>标签</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>&lt;table&gt;</td>\n<td>定义一个表格<br>border=\"num\"定义边框宽度</td>\n</tr>\n<tr class=\"even\">\n<td>&lt;tr&gt;</td>\n<td>定义行</td>\n</tr>\n<tr class=\"odd\">\n<td>&lt;td&gt;</td>\n<td>定义单元格<br>colspan:规定单元格可横跨的列数<br>rowspan:规定单元格可横跨的行数</td>\n</tr>\n<tr class=\"even\">\n<td>&lt;th&gt;</td>\n<td>定义表头<mark>单元格</mark>(使内容居中加粗)</td>\n</tr>\n<tr class=\"odd\">\n<td>&lt;thead&gt;</td>\n<td>定义表头<mark>整行</mark></td>\n</tr>\n<tr class=\"even\">\n<td>&lt;tbody&gt;</td>\n<td>定义表格主题内容</td>\n</tr>\n<tr class=\"odd\">\n<td>&lt;tfoor&gt;</td>\n<td>定义表注（脚注）</td>\n</tr>\n</tbody>\n</table>\n<p>Note:</p>\n<ul>\n<li><p><mark>合并单元格时，选定操作目标单元格后，需要删掉被合并单元格的代码。</mark></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>表格<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">border</span>=<span class=\"string\">&quot;1&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">                 <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>序号<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">                 <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>姓名<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>年龄<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>张佳佳<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>24<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>张亮亮<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>33<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">rowspan</span>=<span class=\"string\">&quot;2&quot;</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>张盼盼<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>22<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>张志荣<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>63<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">colspan</span>=<span class=\"string\">&quot;2&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"高级html知识\">高级HTML知识</h2>\n<h3 id=\"网站图标设置\">网站图标设置</h3>\n<h5 id=\"favicon\">favicon</h5>\n<p><code>&lt;link rel=\"shortcut icon\" href=\"favicon.ico\"&gt;</code></p>\n<h3 id=\"头部标签设置\">头部标签设置</h3>\n<h4 id=\"tdk三大标签及seo优化\">TDK三大标签及SEO优化</h4>\n<p>TDK三大标签即title、description、keyword；SEO即Search Engine Optimization，即搜索引擎优化。</p>\n<h5 id=\"title\">Title</h5>\n<p><code>&lt;title&gt;blablabla...&lt;/title&gt;</code></p>\n<h5 id=\"description\">Description</h5>\n<p><code>&lt;meta name=\"description\" content=\"blablablabla...\" /&gt;</code></p>\n<h5 id=\"keyword\">Keyword</h5>\n<p><code>&lt;meta name=\"keyword\" content=\"blablabla...\"&gt;</code></p>\n<h1 id=\"part-2-css\">PART 2: CSS</h1>\n<div style=\"font-style: italic; color: #999; text-align: right;\">\n——佳佳、铭锐、吉财\n</div>\n<p><strong>WebKit浏览器：</strong></p>\n<blockquote>\n<p>基于WebKit Core的浏览器。</p>\n<p>WebKit是一种用来让网页浏览器绘制网页的排版引擎。它被用于Apple Safari。其分支Blink被用于基于Chromium的网页浏览器，如Opera与Google Chrome。</p>\n<p>Webkit亦使用于Apple iOS、BlackBerry Tablet OS、Tizen及Amazon Kindle的默认浏览器。WebKit的C++应用程序接口提供了一系列的Class以在视窗上显示网页内容，并且实现了一些浏览器的特色，如用户链接点击、管理前后页面列表及近期历史页面等等。</p>\n<p>WebKit的HTML及JavaScript代码源自KDE的KHTML及KJS库的一个分支[3]，现已由KDE、Apple、Google、Nokia、Bitstream、BlackBerry及Igalia等独立开发[4]。OS X、Windows、GNU/Linux以及其他类Unix系统操作系统，皆支持这个项目[5]。2013年4月3日，Google宣布它创建了WebKit中WebCore组件的分支——Blink，Blink用于新版Google Chrome与Opera[6][7]。</p>\n<p>WebKit的WebCore及JavaScriptCore组件使用GNU宽通用公共许可证，其他组件则采用BSD许可证[8]。</p>\n<p>截至2013年3月7日，Webkit商标已被苹果公司在美国专利及商标局注册为其商标。[9]</p>\n<p>——Wikipedia</p>\n</blockquote>\n<p>CSS是层叠样式表（Cascading Style Sheets）标记语言，主要用来设置文本的内容（大小、字体、对齐方式等）、图片的外形等等。</p>\n<p><strong>CSS语法规范：</strong>由 <u>选择器</u> 以及 <u>一条或多条声明</u> 两个主要的部分构成。</p>\n<p><strong>书写方式：</strong> <code>选择器:</code> { <code>属性值;</code> }</p>\n<h2 id=\"css基础知识\">CSS基础知识</h2>\n<h3 id=\"css-类命名规则\">1. CSS 类命名规则</h3>\n<h4 id=\"公共命名规则\">公共命名规则</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: left;\">CSS样式命名</th>\n<th style=\"text-align: left;\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">wrapper</td>\n<td style=\"text-align: left;\">页面外围控制整体布局宽度</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">container或content</td>\n<td style=\"text-align: left;\">容器,用于最外层</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">layout</td>\n<td style=\"text-align: left;\">布局</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">head, header</td>\n<td style=\"text-align: left;\">页头部分</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">foot, footer</td>\n<td style=\"text-align: left;\">页脚部分</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">nav</td>\n<td style=\"text-align: left;\">主导航</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">subnav</td>\n<td style=\"text-align: left;\">二级导航</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">menu</td>\n<td style=\"text-align: left;\">菜单</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">submenu</td>\n<td style=\"text-align: left;\">子菜单</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">sideBar</td>\n<td style=\"text-align: left;\">侧栏</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">sidebar_a, sidebar_b</td>\n<td style=\"text-align: left;\">左边栏或右边栏</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">main</td>\n<td style=\"text-align: left;\">页面主体</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">tag</td>\n<td style=\"text-align: left;\">标签</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">msg message</td>\n<td style=\"text-align: left;\">提示信息</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">tips</td>\n<td style=\"text-align: left;\">小技巧</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">vote</td>\n<td style=\"text-align: left;\">投票</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">friendlink</td>\n<td style=\"text-align: left;\">友情连接</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">title</td>\n<td style=\"text-align: left;\">标题</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">summary</td>\n<td style=\"text-align: left;\">摘要</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">loginbar</td>\n<td style=\"text-align: left;\">登录条</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">searchInput</td>\n<td style=\"text-align: left;\">搜索输入框</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">hot</td>\n<td style=\"text-align: left;\">热门热点</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">search</td>\n<td style=\"text-align: left;\">搜索</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">search_output</td>\n<td style=\"text-align: left;\">搜索输出和搜索结果相似</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">searchBar</td>\n<td style=\"text-align: left;\">搜索条</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">search_results</td>\n<td style=\"text-align: left;\">搜索结果</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">copyright</td>\n<td style=\"text-align: left;\">版权信息</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">branding</td>\n<td style=\"text-align: left;\">商标</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">logo</td>\n<td style=\"text-align: left;\">网站LOGO标志</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">siteinfo</td>\n<td style=\"text-align: left;\">网站信息</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">siteinfoLegal</td>\n<td style=\"text-align: left;\">法律声明</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">siteinfoCredits</td>\n<td style=\"text-align: left;\">信誉</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">joinus</td>\n<td style=\"text-align: left;\">加入我们</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">partner</td>\n<td style=\"text-align: left;\">合作伙伴</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">service</td>\n<td style=\"text-align: left;\">服务</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">regsiter</td>\n<td style=\"text-align: left;\">注册</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">arr/arrow</td>\n<td style=\"text-align: left;\">箭头</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">guild</td>\n<td style=\"text-align: left;\">指南</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">sitemap</td>\n<td style=\"text-align: left;\">网站地图</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">list</td>\n<td style=\"text-align: left;\">列表</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">homepage</td>\n<td style=\"text-align: left;\">首页</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">subpage</td>\n<td style=\"text-align: left;\">二级页面子页面</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">tool, toolbar</td>\n<td style=\"text-align: left;\">工具条</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">drop</td>\n<td style=\"text-align: left;\">下拉</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">dorpmenu</td>\n<td style=\"text-align: left;\">下拉菜单</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">status</td>\n<td style=\"text-align: left;\">状态</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">scroll</td>\n<td style=\"text-align: left;\">滚动</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">.tab</td>\n<td style=\"text-align: left;\">标签页</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">.left .right .center</td>\n<td style=\"text-align: left;\">居左、中、右</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">.news</td>\n<td style=\"text-align: left;\">新闻</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">.download</td>\n<td style=\"text-align: left;\">下载</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">.banner</td>\n<td style=\"text-align: left;\">广告条(顶部广告条)</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"其他div命名规则\">其他DIV命名规则</h4>\n<p>　　登录条:loginBar</p>\n<p>　　标志:logo</p>\n<p>　　侧栏:sideBar</p>\n<p>　　广告:banner</p>\n<p>　　导航:nav</p>\n<p>　　子导航:subNav</p>\n<p>　　菜单:menu</p>\n<p>　　子菜单:subMenu</p>\n<p>　　搜索:search</p>\n<p>　　滚动:scroll</p>\n<p>　　页面主体:main</p>\n<p>　　内容:content</p>\n<p>　　标签页:tab</p>\n<p>　　文章列表:list</p>\n<p>　　提示信息:msg</p>\n<p>　　小技巧:tips</p>\n<p>　　栏目标题:title</p>\n<p>　　友情链接:friendLink</p>\n<p>　　页脚:footer</p>\n<p>　　加入:joinus</p>\n<p>　　指南:guild</p>\n<p>　　服务:service</p>\n<p>　　热点:hot</p>\n<p>　　新闻:news</p>\n<p>　　下载:download</p>\n<p>　　注册:regsiter</p>\n<p>　　状态:status</p>\n<p>　　按钮:btn</p>\n<p>　　投票:vote</p>\n<p>　　合作伙伴:partner</p>\n<p>　　版权:copyRight</p>\n<h3 id=\"选择器\">2. 选择器</h3>\n<h4 id=\"基础选择器\">基础选择器</h4>\n<p>选择器按作用大小（从小到大）分为 <code>ID选择器(使用井字符做特殊标注：#)</code> 、<code>类选择器（使用英文点号做特殊标注：.）</code> 、 <code>标签选择器</code> 及 <code>通配符选择器（使用英文星号做特殊标注：*）</code>。</p>\n<p>CCS 选择器的作用：选择器是为了选定标签，声明对象设置具体样式</p>\n<table>\n<colgroup>\n<col style=\"width: 9%\" />\n<col style=\"width: 48%\" />\n<col style=\"width: 22%\" />\n<col style=\"width: 19%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>选择器类型</th>\n<th>选择器特性</th>\n<th>style书写方式</th>\n<th>style应用方式</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>ID选择器</td>\n<td>1. 与其他选择器类型一致，特殊之处是大部分情况作JavaScript调用<br/>2. 需要编写唯一id不可重复使用</td>\n<td>#DivStyle { color: red; }</td>\n<td>id=\"DivStyle\"</td>\n</tr>\n<tr class=\"even\">\n<td>类选择器</td>\n<td>1. 作用于使用class属性的一类标签，同面向对象的其他语言特性一致<br/>2. 单个标签可以使用多个类，中间以空格隔开</td>\n<td>.ClassStyle { color: black;}</td>\n<td>Class=\"ClassStyle .....\"</td>\n</tr>\n<tr class=\"odd\">\n<td>标签选择器</td>\n<td>作用于所有使用本标签的标签</td>\n<td>div { color: blue; }</td>\n<td>/</td>\n</tr>\n<tr class=\"even\">\n<td>通配符选择器</td>\n<td>作用于所有标签</td>\n<td>* { clolor: pink; }</td>\n<td>/</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"复合选择器\">复合选择器</h4>\n<table>\n<colgroup>\n<col style=\"width: 15%\" />\n<col style=\"width: 42%\" />\n<col style=\"width: 42%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>复合选择器类型</th>\n<th>选择器特性</th>\n<th>style书写方式</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>后代选择器</td>\n<td>1. 可以选择<strong>某个</strong>父标签下的<strong>某个</strong>全部子标签，不管其是否在同一个层级<br/>2. 当标签发生嵌套时，内层标签就称为外层标签的后代<br/>3. 浏览器按照标签层级的关系进行查找，并<u>对最内层标签进行修改</u>，因此可以定义多重标签选择，如可以使用基础选择器（类选择器及ID选择器）进行组合使用<br/>4. 内外层选择器之间 <mark>以空格隔开</mark></td>\n<td>外层标签 内层标签 {属性}<br/>ol li { color: #000; }<br/>ol li a { color: #777; }<br/>.nav li a { color: pruple;}</td>\n</tr>\n<tr class=\"even\">\n<td>子代选择器</td>\n<td>1. 即与后代选择器不同，仅对父级标签下的某一类选择器进行操作，不会作用于其他子代的同类标签<br/>2. 使用符号 <code>&gt;</code> 进行操作</td>\n<td>.nav&gt;a {color: pink;}</td>\n</tr>\n<tr class=\"odd\">\n<td>集选择器（相邻选择器）</td>\n<td>1. 在两个没有从属关系（子代或后代）和相同特点（如同类标签）的同级不同类标签中，定义一个相同的样式<br/>2. 多个标签进行选择时使用英文逗号 <code>,</code> 进行并列选择<br/>3. 并集选择器内可使用 <strong>简单选择器</strong> 和 <strong>复合选择器</strong>（如 后代选择器 和 子代选择器），竖向书写选择器</td>\n<td>div, p {color: pink; }</td>\n</tr>\n<tr class=\"even\">\n<td>伪类选择器</td>\n<td>1. 用于给某些选择器添加特殊效果（如给链接添加特殊效果），或者选择某个元素<br/>2. 结构伪类、链接伪类、表单伪类<br/>3. 伪类选择器其实更像是一个行为选择器（或状态选择器），它定义了一个/类标签在不同状态下的样式，书写形式如：<code>标签</code>: <code>状态/行为</code> <code>&#123;属性&#125;</code></td>\n<td>.OnlineTitle:link {<br/> color: #222222;<br/> text-decoration: none;<br/>}</td>\n</tr>\n<tr class=\"odd\">\n<td>属性选择器（高级）</td>\n<td>元素名[属性（及关键搜索项）]<br />E[att] 选择具有att属性的E元素<br />E[att=\"val\"] 选择ett=val的E元素<br />E[att^=\"val\"] 选择att属性开头为val的E元素<br />E[att$=\"val\"] 选择att属性结尾为val的E元素<br />E[att*=\"val\"] 选择att属性中包含\"val\"字符的E元素</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>结构伪类选择器（高级）</td>\n<td>根据文档结构来选择元素，常用于父级元素里的子元素<br />E:first-child 匹配父元素中的第一个子元素E<br />E:last-child 匹父元素中的最后一个元素E<br />E:nth-child(n) 匹配父级元素中的第n个子元素E<br />E:first-of-type 指定类型E的第一个<br />E:last-of-type 指定类型E的最后一个<br />E:nth-of-type(n)指定类型E的第n个</td>\n<td>n可以是<strong>正数</strong>、<strong>关键字</strong>（even偶数、odd奇数）和<strong>公式</strong><br />可以配合其他复合选择器进行选择，如子代选择器、后代选择器等。<br />在使用<code>nth-child(n)</code>后，未指定特殊数字时，将从0开始计数，直到所有子代结束，即等同于全选所有该类子代。</td>\n</tr>\n<tr class=\"odd\">\n<td>伪元素选择器（高级）</td>\n<td>::before 在元素内部的前面插入东西<br />::after 在元素内部的后面插入东西<br /></td>\n<td>所创建的元素为行内元素；<br />必须有content属性；<br /></td>\n</tr>\n</tbody>\n</table>\n<p>并集选择器</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">HTML</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">如要求将下方熊大、熊二及佩奇一家都改为粉色，则按照&lt;style&gt;中的方式进行书写</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">            //在两个没有从属关系（子代或后代）和相同特点（如同类标签）的同级不同类标签中，定义一个相同的样式</span><br><span class=\"line\"><span class=\"css\">            <span class=\"selector-tag\">div</span>,</span></span><br><span class=\"line\"><span class=\"css\">            <span class=\"selector-tag\">p</span>,</span></span><br><span class=\"line\"><span class=\"css\">            <span class=\"selector-class\">.pig</span> <span class=\"selector-tag\">li</span> &#123;                //类选择器</span></span><br><span class=\"line\"><span class=\"css\">                <span class=\"attribute\">color</span>: pink;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>熊大<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>熊二<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>关头强<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;pig&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>PIG 1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>PIG 2<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>PIG 3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>链接伪类选择器</strong></p>\n<p>四个使用方式: link / visited / hover / active</p>\n<ol type=\"1\">\n<li>为了确保生效，应按照LVHA的顺序进行声明。</li>\n<li><code>&lt;a&gt;</code> 链接在浏览器中具有默认样式，不会因为在<code>&lt;body&gt;</code>中而随之改变，实际工作中需要给链接单独指定样式。</li>\n<li>使用时，加上冒号 <code>:</code> 与 四种<code>状态</code>之一 即可</li>\n</ol>\n<p>举例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\t<span class=\"attribute\">background-color</span>:yellow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当鼠标经过父级元素时，显示子元素的遮罩层：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.tudou</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.mask</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">display</span>: block;      <span class=\"comment\">/* 显示遮罩层 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>最小盒子：</strong>即只能存放文字了，不能再存放其他标签/元素，如 <code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code>等文字块级标签；</p>\n<p><strong>结构伪类选择器</strong></p>\n<p><code>nth-child()</code>在执行时会先把所有子元素都进行排序，先看<code>nth-child()</code>括号中的数字，再匹配前方的标签是否与实际标签一致，如果不一致则不执行。</p>\n<p><code>nth-of-type()</code>在执行时会先把指定类型的子元素都进行排序，先看<code>nth-of-type()</code>括号中的数字，再匹配查找到具体的标签。</p>\n<p>CSS中使用伪类选择器，根据结构顺序精确选择标签：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first</span>-child &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: white;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:last-child</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span>:<span class=\"built_in\">nth-chile</span>(<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">  color: yellow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HTML结构如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>5<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>6<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>自增长序列，n是从0开始的，按照公式从0开始计算，所得结果为选择器选择的行数。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>公式</th>\n<th>取值</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>2n</td>\n<td>偶数</td>\n</tr>\n<tr class=\"even\">\n<td>2n+1</td>\n<td>奇数</td>\n</tr>\n<tr class=\"odd\">\n<td>5n</td>\n<td>5、10、15...</td>\n</tr>\n<tr class=\"even\">\n<td>n+5</td>\n<td>从第5个开始（包含第5个）直到最后</td>\n</tr>\n<tr class=\"odd\">\n<td>-n+5</td>\n<td>前5个（包含第5个）</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"元素显示模式\">元素显示模式</h4>\n<p>是指在页面上的元素以 <strong>块状模式</strong> 、 <strong>行内模式</strong> 或 <strong>行内块模式</strong> 进行显示。元素按显示模式可以分为 <strong>块状（级）元素</strong> 及 <strong>行内元素（内联元素）</strong> 及 <strong>行内块元素</strong> 三种类型。</p>\n<table>\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 30%\" />\n<col style=\"width: 30%\" />\n<col style=\"width: 30%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>元素类型</th>\n<th>典型标签</th>\n<th>特点</th>\n<th>注意点</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>块状元素</td>\n<td><code>&lt;h1&gt;</code>~<code>&lt;h6&gt;</code> 、 <code>&lt;p&gt;</code>、 <code>&lt;div&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>......</td>\n<td>1. 即使设置标签宽度，也是独占一行<br/>2. 高、宽、外边距及内边距可调节<br/>3. 默认宽度是父级宽度的100%<br/>4. 是一个容器及盒子，可以放任何标签</td>\n<td>文字类的标签内不可以存放块元素</td>\n</tr>\n<tr class=\"even\">\n<td>行内元素（内联元素）</td>\n<td><code>&lt;a&gt;</code>、 <code>&lt;strong&gt;</code>、<code>&lt;b&gt;</code>、 <code>&lt;em&gt;</code>、<code>&lt;i&gt;</code> ......</td>\n<td>1. 相邻行内元素在一行上，一行可以显示多个<br/>2. 直接设置宽高无效，可以间接设置<br/>3. 默认宽度就是其内容宽度<br/>4. 行内元素只能容纳文本及其他行内元素</td>\n<td>1. 链接中不允许再放其他链接<br/>2. <code>&lt;a&gt;</code>中可以放置块元素，但是转换成块级元素最安全</td>\n</tr>\n<tr class=\"odd\">\n<td>行内块元素</td>\n<td><code>&lt;input&gt;</code>、 <code>&lt;image&gt;</code>、<code>&lt;td&gt;</code>......</td>\n<td>1. 同时具有块元素及行内元素的特定<br/>2. 和相邻行内元素（行内块）在一行上，但是有空白缝隙，可以一行显示多个<br/>3. 默认宽度即内容宽度<br/>4. 高度、行高、外边距及内边距可控制</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><strong>元素显示模式的转换</strong></p>\n<p>即一个模式的元素需要另一个模式的特性，可以通过在CSS的标签样式属性中添加display语句进行转换。</p>\n<p>转换为块级元素： <em><code>display: block;</code></em></p>\n<p>转换为行内元素： <em><code>display: inline;</code></em></p>\n<p>转换为行内块元素： <em><code>display: inline-block;</code></em></p>\n<h4 id=\"选择器特性\">选择器特性</h4>\n<p>层叠性、继承性、优先性</p>\n<p><strong>层叠性</strong></p>\n<blockquote>\n<p>样式冲突，就近原则</p>\n</blockquote>\n<p><strong>继承性</strong></p>\n<blockquote>\n<p>子标签会继承父标签的某些样式</p>\n<p>子元素可以继承父元素的样式（text-，font-，line-这些元素开头的可以继承，以及color属性</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\">    <span class=\"selector-tag\">body</span>&#123;</span></span><br><span class=\"line\"><span class=\"css\">        <span class=\"attribute\">color</span>:pink;</span></span><br><span class=\"line\"><span class=\"css\">        <span class=\"attribute\">font</span>:<span class=\"number\">25px</span>/<span class=\"number\">1.5</span> <span class=\"string\">&#x27;Microsoft YaHei&#x27;</span>;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"css\">    <span class=\"selector-tag\">div</span>&#123;</span></span><br><span class=\"line\"><span class=\"css\">        <span class=\"attribute\">font</span>:<span class=\"number\">14px</span>;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"css\"><span class=\"comment\">/*此时div会继承body中1.5倍的行高，此时div中的行高就是14*1.5=21px*/</span></span></span><br><span class=\"line\">    行高可以跟单位也可以不跟单位</span><br><span class=\"line\">    如果子元素没有设置行高，则会继承父元素行高为1.5</span><br><span class=\"line\">    此时子元素的行高是：当前子元素的文字大小*1.5</span><br><span class=\"line\"><span class=\"css\">    <span class=\"selector-tag\">body</span>行高<span class=\"number\">1.5</span>这样写法最大的优势就是里面子元素可以根据自己文字大小自动调整行高</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>优先性（权重）</strong></p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>选择器类型</th>\n<th>权重</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>继承</td>\n<td>无</td>\n</tr>\n<tr class=\"even\">\n<td>通配符选择器、子代选择器、相邻选择器（并集选择器）</td>\n<td>0,0,0,0</td>\n</tr>\n<tr class=\"odd\">\n<td>元素选择器（标签选择器）、伪元素选择器</td>\n<td>0,0,0,1</td>\n</tr>\n<tr class=\"even\">\n<td>类选择器、伪类选择器、属性选择器</td>\n<td>0,0,1,0</td>\n</tr>\n<tr class=\"odd\">\n<td>ID选择器</td>\n<td>0,1,0,0</td>\n</tr>\n<tr class=\"even\">\n<td>内联选择器</td>\n<td>1,0,0,0</td>\n</tr>\n<tr class=\"odd\">\n<td>!IMPORTANT</td>\n<td>无限</td>\n</tr>\n</tbody>\n</table>\n<p>选择器的加权结果并非二进制，而是在各个数位上进行单独相加，例如元素选择器与类选择器的加权结果为 <code>0,0,1,1</code>，左侧数位的数值越大，权重越高。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"selector-tag\">div</span> &#123;</span></span><br><span class=\"line\"><span class=\"css\">\t\t\t<span class=\"attribute\">color</span>: red;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t.colour &#123;</span><br><span class=\"line\"><span class=\"css\">\t\t\t<span class=\"attribute\">color</span>: green;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t#demo &#123;</span><br><span class=\"line\"><span class=\"css\">\t\t\t<span class=\"attribute\">color</span>: burlywood;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"css\">\t\t<span class=\"selector-tag\">p</span> &#123;</span></span><br><span class=\"line\"><span class=\"css\">\t\t\t<span class=\"attribute\">color</span>: <span class=\"number\">#008000</span>;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;colour&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;demo&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;color: #4682B4;&quot;</span>&gt;</span></span><br><span class=\"line\">\t\t不爱绿色爱蓝色</span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">\t\t\t继承的权重为0</span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">/*此时p是继承不到父级的设定* 所以看标签到底执行哪个样式，就先看这个标签有没有直接被选出来/</span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<div style=\"color: red; font-weight: 800;\">\n继承的权重是0，如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是0。\n</div>\n<h3 id=\"list\">3. List</h3>\n<p><code>list-style</code> CSS 属性是一个简写对属性集合，包括<code>list-style-type</code>, <code>list-style-image,</code> 和 <code>list-style-position</code>。</p>\n<p><code>list-style: none | circle | square inside ;</code>表示<code>&lt;ul&gt;</code> 下 <code>&lt;li&gt;</code> 前的小点样式，如“无、圆圈、实心方形”。</p>\n<p>例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;one&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>List Item1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>List Item2<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>List Item3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">List 2</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;two&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>List Item A<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>List Item B<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>List Item C<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>及</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.one</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">list-style</span>: circle;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.two</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">list-style</span>: square inside;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"background\">4. Background</h3>\n<p><code>background-color</code> 可以设置为 <code>transparent</code>，即透明的，不可视的。</p>\n<p><code>background-image</code> 可以设置为 <code>none</code>，也可以跟上一个 <code>url()</code> 链接。如：<code>background-image: url(http://xxxxxx.com/123.jpg)</code></p>\n<p><code>background-repeat: repeat | no-repea | repeat-x | repeat-y</code> ，分别是指 重复（平铺）、不平铺、在x轴上平铺 及 在y轴上平铺 。</p>\n<p><code>background-position: top | bottom | left | right | center;</code> 除了可以使用类似于左侧的方位词定位，还可以使用坐标轴数值定位。</p>\n<p><code>background: [image] [repeat] [position];</code> 是复合写法，<code>repeat</code> 和 <code>position</code> 可省略，<code>image</code> 不可省略。</p>\n<h3 id=\"font\">5. Font</h3>\n<p><strong>FONT-FAMILY 字体族</strong></p>\n<p>通用属性之一，用于设置网页显示字体，font-family的使用方式为 <code>font-family=\" \"</code> ，双引号内可以书写多个字体，引擎会按顺序搜索本地字体并使用，如果都没有则使用本地字体。</p>\n<p><strong>注意：</strong>建议使用字体的全英文进行书写，如 <strong>微软雅黑</strong> 全英文为 <strong>Microsoft YaHei</strong>，英文书写时有空格的应用单引号<code>‘’</code> 进行包裹。</p>\n<p><strong>FONT-SIZE 字体大小</strong></p>\n<p>通常用于对body标签内所有正文字体大小的设置，对标题（如<code>h3</code>）大小的设置仍需另起样式。</p>\n<p><strong>复合写法</strong></p>\n<p><code>font: font-style font-weight font-size/line-height font-family;</code></p>\n<p><code>font-size</code> 和 <code>font-family</code> 不可缺省</p>\n<h3 id=\"text\">6. Text</h3>\n<p><strong>文本属性</strong></p>\n<table>\n<colgroup>\n<col style=\"width: 22%\" />\n<col style=\"width: 47%\" />\n<col style=\"width: 30%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>属性</th>\n<th>书写方式</th>\n<th>注意</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>color<br/>颜色</td>\n<td>1. 常见英文表示法，直接书写该颜色英文即可，如 pink  red  blue  purple<br/>2. 16进制表示法，用#号进行书写，如#FF00FF<br/>3. RGB表示法，如rgb(0,0,255)</td>\n<td>16进制简写为#fff<br/>实际开发中用16进制</td>\n</tr>\n<tr class=\"even\">\n<td>text-align<br/>文本对齐</td>\n<td>仅有左、中、右三种表示方式，用英文 left  center  right 进行书写</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>text-indent<br/>文本缩进</td>\n<td>缩进可以用2种方式表示：<br/>1. 精准缩进：即直接使用 <code>px</code> 单位进行书写，表示缩进多少像素点，缺点是容易出现问题<br/>2. 字符单位缩进：即按照字符大小，自适应缩进字符距离，单位是em，如 <code>2em</code>，可以缩进2个字符</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>text-decoration<br/>文本修饰</td>\n<td>常见的修饰类型有四种：无（none）、上划线（overline）、下划线（underline）、删除线（line-through）</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>line-height</td>\n<td>行高=上行距+下行距+字高，且上行距=下行距</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"box-module\">7. Box Module</h3>\n<p>盒子模型主要分三部分：<strong>border</strong>（边框）、<strong>padding</strong>（内边距）及 <strong>margin</strong>（外边距）。</p>\n<h4 id=\"border\">Border</h4>\n<p>边框主要有一下三种参数：粗细、颜色及样式</p>\n<ul>\n<li>粗细(<code>border-width: 5px;</code>)</li>\n<li>颜色(<code>boder-color: #555</code>) （<em>注意：如果这个值没有设置，它的默认值是元素的 color属性值（是文字颜色而非背景色）</em>），可以定义为<code>transparent</code>（透明的）</li>\n<li>样式(<code>boder-style: none | hidden | dotted | dashed | solid | double(双层线) | groove(内雕刻) | ridge(外浮雕) | inset(内凹陷) | outset(外凹陷) ;</code>)</li>\n</ul>\n<p>border属性之可以在中间添加上、下、左、右四个方位词和三参数之一，如 <code>border-top-color</code> | <code>border-bottom-style</code> ....</p>\n<p>边框使用时会影响盒子大小，需要注意调整。</p>\n<p><strong>复合写法</strong></p>\n<p><code>border: [border-width ||border-style ||border-color |inherit] ;</code></p>\n<p>如：<code>border: 10px solid transparent;</code></p>\n<h4 id=\"padding\">Padding</h4>\n<p>内边距涉及到的参数包括 上下左右四边的边距。</p>\n<p>在未设置内盒子的width时，设置padding对内盒子实际显示大小不起影响，一旦设置width，则会让盒子的width在显示时超过设置参数的大小。</p>\n<h4 id=\"margin\">Margin</h4>\n<p>外边距同内边距。</p>\n<p>在标准流下，设置块级盒子width参数后，设置margin左右为auto，可以让盒子实现居中效果。（以下三种写法，推荐第一个，第一个参数表示上下，第二个参数表示左右）</p>\n<p><code>margin: 0 auto;</code></p>\n<p><code>margin: auto;</code></p>\n<p><code>margin-left: auto; margin-right: auto;</code></p>\n<h4 id=\"qa\">Q/A</h4>\n<p><strong>盒子塌陷的解决方案</strong></p>\n<p>以下为两个盒子嵌套，同时设置上边距导致塌陷问题的解决方案：</p>\n<ul>\n<li>可以为父元素定义上边框/上内边距</li>\n<li>可以为父元素添加 <code>overflow: hidden;</code></li>\n<li>利用浮动、固定、绝对定位解决</li>\n</ul>\n<h3 id=\"float\">8. Float</h3>\n<p>浮动最初的开发目的是让图片和文字产生环绕效果的，浮动可以让多个块级元素在一行内显示。</p>\n<p><code>float: none | left | right;</code></p>\n<p><strong>注意：</strong>两个行内块元素中间会有空白间隙存在，如果父级元素设定了宽度，会让元素存放不下。需要给此类行内块元素设定浮动</p>\n<p><strong>浮动特性：</strong></p>\n<ul>\n<li><p>脱标</p></li>\n<li><p>顶端对齐</p></li>\n<li><p>具有行内块元素特性</p></li>\n</ul>\n<p><strong>外边距合并</strong></p>\n<blockquote>\n<p>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p>\n</blockquote>\n<p><strong>注释：</strong>只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。</p>\n<p>在标准流中嵌套一个带有外边距的浮动框，不会让他们产生外边距合并。</p>\n<h3 id=\"clean-float\">9. Clean Float</h3>\n<p>清除浮动也叫闭合浮动，是指在未指定父级元素高度而子级元素为浮动时，会对父级元素同级的标准流造成影响，因而需要清除该类浮动造成的弊端的情况。</p>\n<p>清除浮动的四种方式：</p>\n<table>\n<colgroup>\n<col style=\"width: 9%\" />\n<col style=\"width: 35%\" />\n<col style=\"width: 20%\" />\n<col style=\"width: 35%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>方法</th>\n<th>说明</th>\n<th>写法</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>额外标签</td>\n<td>[w3c推荐]也称隔墙法，指在浮动的块（行内块）级元素后面新增一个带有<code>clear: both;</code>属性的额外标签（要求是块级元素）来屏蔽浮动的影响。</td>\n<td><code>clear: both;</code></td>\n<td>弊端是增加了额外标签，对H5结构造成负担；<br/>要求新增的标签不能是行内元素</td>\n</tr>\n<tr class=\"even\">\n<td>父级添加overflow</td>\n<td>仅给父级元素添加overflow，添加hidden、auto、scroll皆可。</td>\n<td><code>overflow: hidden | auto | scroll</code></td>\n<td>优点是代码简洁，缺点是无法显示溢出的部分</td>\n</tr>\n<tr class=\"odd\">\n<td>:after伪元素</td>\n<td>额外标签法的升级版，利用CSS样式添加额外标签<br/>仅给父级元素添加</td>\n<td>见下方</td>\n<td>没有增加额外标签，样式写法较为复杂；</td>\n</tr>\n<tr class=\"even\">\n<td>双伪元素</td>\n<td>在子级前后各添加一个伪元素</td>\n<td>见下方</td>\n<td>代码简洁，照顾低版本。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>:after伪元素代码示例：</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.clearfix</span>:after &#123;</span><br><span class=\"line\">\tcontent: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">\t<span class=\"attribute\">visibility</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.clearfix</span> &#123;       <span class=\"comment\">/* IE6、7专有 */</span></span><br><span class=\"line\">\t*zoom: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>双伪元素代码示例：</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.clearfix</span>:before, .clearfix:after&#123;</span><br><span class=\"line\">\tcontent: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">display</span>: table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.clearfix</span>:after&#123;</span><br><span class=\"line\">\tclear: both;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.clearfix</span>&#123;</span><br><span class=\"line\">\t*zoom: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"position\">10. Position</h3>\n<h4 id=\"定位的意义\">定位的意义</h4>\n<p>让盒子自由地在某个盒子中移动或固定在屏幕中的某个位置，并且可以压住其他盒子。</p>\n<p><strong>注意：</strong>对于标准流和浮动，不可以使用定位。</p>\n<h4 id=\"定位模式\">定位模式</h4>\n<p><code>position: static | relative | absolute | fixed ;</code></p>\n<table>\n<colgroup>\n<col style=\"width: 12%\" />\n<col style=\"width: 14%\" />\n<col style=\"width: 5%\" />\n<col style=\"width: 27%\" />\n<col style=\"width: 39%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>定位分类</th>\n<th>脱标</th>\n<th>使用情况</th>\n<th>参考系</th>\n<th>其他特点</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>静态定位 <code>static</code></td>\n<td>否，不能使用边偏移</td>\n<td>很少</td>\n<td>无，不设置边偏移</td>\n<td>按照标准流特性摆放位置</td>\n</tr>\n<tr class=\"even\">\n<td>相对定位 <code>relative</code></td>\n<td>否，占用标准流的位置</td>\n<td>常用</td>\n<td>自身原来的位置</td>\n<td>相对于自身原来的位置来移动<br/>设置相对定位后，后面的标准流<strong>不会脱标</strong>，不会让身后的标准流往前挤或往后挤；<br/>通常是给绝对定位当父级元素的属性</td>\n</tr>\n<tr class=\"odd\">\n<td>绝对定位 <code>absolute</code></td>\n<td>是，不占用标准流的位置</td>\n<td>常用</td>\n<td>最近一级父级以上带有定位的盒子（子绝父相）</td>\n<td>如果没有已定位的父级元素，则以浏览器进行绝对定位</td>\n</tr>\n<tr class=\"even\">\n<td>固定定位 <code>fixed</code></td>\n<td>是，不占用标准流的位置</td>\n<td>常用</td>\n<td>浏览器的可视窗口</td>\n<td>与父级元素无关，不随窗口滚动条滚动<br/></td>\n</tr>\n<tr class=\"odd\">\n<td>粘性定位 <code>sticky</code></td>\n<td>否，占用标准流的位置</td>\n<td>很少</td>\n<td>浏览器的可视窗口</td>\n<td>相对定位和固定定位的混合体，具有两者的某些特点<br/>必须添加至少一个边偏移参数<br/>需与滚动搭配使用，对IE兼容性差，类似粘性定位的做法通常用JavaScript来做</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"边偏移\">边偏移</h4>\n<p>相对于父级盒子（或者有定位的祖辈盒子）的边线偏移量（偏移量可以为负值）。</p>\n<p>需要在设置好定位模式后边偏移才能生效。</p>\n<p><strong>四种偏移：</strong>top、bottom、right、left；</p>\n<p><strong>例：</strong><code>top: 10px; right: 20px;</code></p>\n<p><strong>如何将内容固定到版心右侧？</strong></p>\n<p>使用固定定位至左侧的50%，在调整<code>margin-left</code>值至版心宽度的一般（直接书写数值px）。</p>\n<p><strong>如何让内容固定到屏幕正中心？</strong></p>\n<p>使用固定定位至左侧和顶部的50%，再使用<code>margin-left</code>和<code>margin-right</code>的负值来抵消自身宽高的一半。</p>\n<h4 id=\"定位显示优先级\">定位显示优先级</h4>\n<p>定位显示优先级，即定位叠放顺序，是指 <strong>具有定位属性的盒子</strong>（类似于PS图层）在Z轴上的显示优先级，数值越大则优先级越高。</p>\n<p>如果设置为<code>auto</code>，则按照H5结构书写顺序以“后来居上”的原则显示。</p>\n<p>如果设置为数值，则比auto优先级更高，但是不能写单位。</p>\n<p><code>z-index: (number) | auto;</code></p>\n<h4 id=\"定位的特殊性质\">定位的特殊性质</h4>\n<ul>\n<li>给行内元素添加绝对或者固定定位后，可以设置宽度和高度（不等同于与块级元素互换特性？）</li>\n<li>给块级元素添加绝对或者固定宽度后，不设置宽高也可以则应用内容的大小</li>\n</ul>\n<h3 id=\"显示与隐藏\">11. 显示与隐藏</h3>\n<p>显示与隐藏的三种方式：display（显示隐藏）、visibility（显示隐藏）、overflow （溢出显示隐藏）</p>\n<table>\n<colgroup>\n<col style=\"width: 17%\" />\n<col style=\"width: 41%\" />\n<col style=\"width: 41%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>方式</th>\n<th>用法</th>\n<th>特性</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>display（显示隐藏）</td>\n<td>该属性本来是设置元素如何显示的；<br /><code>display: none;</code> 用于隐藏对象；<br /><code>display: block;</code> 除了用于转换成块级元素，还可以用于显示元素；</td>\n<td>隐藏元素后，不再占有其原位置；<br />应用广泛，搭配js做网页特效用；</td>\n</tr>\n<tr class=\"even\">\n<td>visibility（显示隐藏）</td>\n<td>用于设置元素的可见性；<br /><code>visibility: visible | hidden | inherit | collapse ;</code></td>\n<td>隐藏元素后，仍占有其原位置；<br /></td>\n</tr>\n<tr class=\"odd\">\n<td>overflow （溢出显示隐藏）</td>\n<td>仅针对溢出元素框的部分进行显示或隐藏；<br /><code>overflow: visible;</code> 设置时<code>clip</code>属性设置将失效；<br /><code>overflow: hidden;</code> 不显示超过对象尺寸的内容；<br /><code>overflow: scroll;</code> 以滚动条形式显示，不管是否内容是否溢出；<br /><code>overflow: auto;</code> 自动判断内容长度，按需添加滚动条；</td>\n<td>如果带有定位属性，应慎用 <code>overflow: hidden;</code> ，会隐藏多余的部分</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"布局\">12. 布局</h3>\n<h4 id=\"常见的布局形式\">常见的布局形式</h4>\n<p><strong>传统布局方式：</strong>普通流（文档流、标准流）、浮动、定位。</p>\n<p><strong>通栏：</strong>是指和浏览器一样宽。</p>\n<p><strong>布局设计准则：</strong></p>\n<ul>\n<li><p>纵向块级元素用标准流，横向块级元素用浮动。</p></li>\n<li><p>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置，复合网页布局第一准则。</p></li>\n<li><p>浮动的盒子只会影响浮动盒子后方的标准流，不影响前方的标准流。</p></li>\n<li><p>应首先采用“一浮全浮”设计原则。</p></li>\n<li><p>在产品列表数量众多、文字数量众多等不能明确盒子高度的情况下不应指定父级盒子的高度， 否则会出现父级盒子因高度限制而出现子元素无法显示的情况，应让子元素撑开父元素。</p></li>\n<li><p>当给父元素设置标准流却未设置高度，而子元素为浮动时，父元素会高度塌陷。因浮动的子元素不占有高度，因此子元素浮动会会导致无高度的标准流父级元素高度塌陷，影响后续布局。</p></li>\n</ul>\n<h4 id=\"css属性书写建议\">CSS属性书写建议</h4>\n<ol type=\"1\">\n<li>布局定位属性：display / position / float / clear / visibility / overflow (建议display第一个写)</li>\n<li>自身属性：width / height / margin / padding / border / background</li>\n<li>文本属性：color / font / text-decoration / text-align / vertical-align / white-space / break-word</li>\n<li>其他属性：content / cursor / border-radius / box-shadow / text-shadow / background:liner-gradient ....</li>\n</ol>\n<h4 id=\"页面布局的整体思路\">页面布局的整体思路</h4>\n<ol type=\"1\">\n<li>确定版心，即可视区</li>\n<li>分析行、块 以及 块中的列模块</li>\n<li>列模块经常浮动布局，确定列大小后确定列的位置</li>\n<li>先结构，后样式</li>\n</ol>\n<h4 id=\"关于导航栏\">关于导航栏</h4>\n<p>实际开发中，不会直接只用<code>&lt;a&gt;</code>来制作导航栏，而是用<code>&lt;li&gt;</code>包含链接的<code>&lt;li&gt;</code>+<code>&lt;a&gt;</code>来制作。</p>\n<p><code>&lt;li&gt;</code>+<code>&lt;a&gt;</code>语义更加清晰，更为有条理的列表型内容。如果直接用<code>&lt;a&gt;</code>，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字存在被搜索引擎降权的风险），从而影响网站排名。</p>\n<h3 id=\"特殊符号\">13. 特殊符号</h3>\n<p>小于号 &lt; <code>&amp;lt;</code></p>\n<p>大于号 &gt; <code>&amp;gt;</code></p>\n<h2 id=\"css高级知识\">CSS高级知识</h2>\n<p>目标：</p>\n<ul>\n<li><p>能够使用精灵图</p></li>\n<li><p>能够使用字体图标</p></li>\n<li><p>能够写出CSS三角</p></li>\n<li><p>能够写出常见的CSS用户界面样式</p></li>\n<li><p>能够说出常见的布局技巧</p></li>\n</ul>\n<h3 id=\"css-sprites\">CSS Sprites</h3>\n<p>CSS精灵技术的目的：减少客户端向服务器的请求次数，减小服务器的压力，提高网页的加载速度。</p>\n<p>使用专用的位置测量工具，如Firework、photoshop或者其他专业工具，可以精确测量精灵图中的小图坐标，设定好盒子大小，使用专业工具测量的图片位置取负值进行平移定位。</p>\n<p>建议使用position复合写法进行书写，如 <code>position: url(images/abc.jpg) no-repeat -150px 120px;</code> 。</p>\n<p><strong>缺点：</strong></p>\n<ol type=\"1\">\n<li>图片文件较大</li>\n<li>放大或缩小导致失真</li>\n<li>制作完毕后更换图片复杂</li>\n</ol>\n<h3 id=\"icon-font\">Icon Font</h3>\n<p><strong>优点：</strong></p>\n<ol type=\"1\">\n<li>轻量级：字体加载时，字体图标就会马上渲染出来，减少了服务器的请求。</li>\n<li>灵活性：本质是文字，具有font相关的所有特性。</li>\n<li>兼容性：几乎支持所有浏览器。</li>\n</ol>\n<p><strong>适用场景：</strong>结构和样式较为简单的图标。</p>\n<p><strong>缺点：</strong>不能胜任复杂的结构和样式。</p>\n<p><strong>字体图标下载网站：</strong></p>\n<ol type=\"1\">\n<li><a href=\"http://icomoon.io\">icomoon字库</a></li>\n<li><a href=\"http://www.iconfont.cn\">阿里iconfont</a></li>\n</ol>\n<p><strong>四种字体文件格式：</strong></p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>字体格式</th>\n<th>兼容性</th>\n<th>特性</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>.ttf</td>\n<td>最高</td>\n<td>win及mac最常见字体格式</td>\n</tr>\n<tr class=\"even\">\n<td>.woff</td>\n<td>一般</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>.eot</td>\n<td>低</td>\n<td>IE专用字体，支持IE4+</td>\n</tr>\n<tr class=\"even\">\n<td>.svg</td>\n<td>较低</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><strong>使用教程：</strong></p>\n<ol type=\"1\">\n<li>字体文件下载完毕之后，会有四种格式的字体文件（请勿删除任一文件）。</li>\n<li>所有的图标字体复制粘贴到资源管理器下即可。</li>\n<li>在效果预览中复制该图标字体，并粘贴至H5文件中。</li>\n<li>在 <code>&lt;style&gt;</code>中添加 <code>font-face</code> 相关的属性（下载的文件包中会有相关代码可供复制粘贴）。</li>\n</ol>\n<p><strong>示例</strong></p>\n<hr />\n<p>字体声明：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Logo 字体 */</span></span><br><span class=\"line\"><span class=\"keyword\">@font-face</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-family</span>: <span class=\"string\">&quot;iconfont logo&quot;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">src</span>: <span class=\"built_in\">url</span>(<span class=\"string\">&#x27;fonts/demofont.eot?t=1545807318834&#x27;</span>);</span><br><span class=\"line\">  <span class=\"attribute\">src</span>: <span class=\"built_in\">url</span>(<span class=\"string\">&#x27;fonts/demofonteot?t=1545807318834#iefix&#x27;</span>) <span class=\"built_in\">format</span>(<span class=\"string\">&#x27;embedded-opentype&#x27;</span>),</span><br><span class=\"line\">    <span class=\"built_in\">url</span>(<span class=\"string\">&#x27;fonts/demofont.woff?t=1545807318834&#x27;</span>) <span class=\"built_in\">format</span>(<span class=\"string\">&#x27;woff&#x27;</span>),</span><br><span class=\"line\">    <span class=\"built_in\">url</span>(<span class=\"string\">&#x27;fonts/demofont.ttf?t=1545807318834&#x27;</span>) <span class=\"built_in\">format</span>(<span class=\"string\">&#x27;truetype&#x27;</span>),</span><br><span class=\"line\">    <span class=\"built_in\">url</span>(<span class=\"string\">&#x27;fonts/demofont.svg?t=1545807318834#iconfont&#x27;</span>) <span class=\"built_in\">format</span>(<span class=\"string\">&#x27;svg&#x27;</span>);</span><br><span class=\"line\">  <span class=\"attribute\">font-weight</span>: normal;</span><br><span class=\"line\">  <span class=\"attribute\">font-style</span>: normal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用时需要在标签中引用<code>font-family</code>属性：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">span</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">font-family</span>: <span class=\"string\">&#x27;iconfont logo&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>字体追加：</strong></p>\n<p>从网站上下载文件时，自带<code>.json</code>文件，里面记录了所有已选择的字体的信息，只要在网站中导入该文件，即可包含过往所选择的所有图标信息，避免选择新图标后旧图标消失。</p>\n<h3 id=\"triangle\">Triangle</h3>\n<p>三角形，其实是在一个长宽皆为0的盒子中，利用一条border显示，其余三条boders皆透明来制作的。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.triangle</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  inline-<span class=\"attribute\">height</span>: <span class=\"number\">0</span>;     <span class=\"comment\">/*兼容性*/</span></span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">0</span>;         <span class=\"comment\">/*兼容性*/</span></span><br><span class=\"line\">\t<span class=\"attribute\">border</span>: <span class=\"number\">10px</span> solid transparent;</span><br><span class=\"line\">\t<span class=\"attribute\">border-right-color</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在实际应用中，常与另一个盒子共同包裹在一个大盒子中，使用 <code>position: absolute;</code> 和 <code>位移属性</code> 来制作气泡窗口。</p>\n<h3 id=\"user-interface-style\">User Interface Style</h3>\n<h4 id=\"cursor\">Cursor</h4>\n<p><code>cursor: default | pointer | move | text | not-allowed ;</code></p>\n<p>分别是 <strong>箭头</strong>、<strong>手指</strong>、<strong>十字架</strong>、<strong>文本</strong>、<strong>禁止</strong> 样式。</p>\n<h4 id=\"outline\">Outline</h4>\n<p><code>outline: 0;</code> 或者 <code>outline: none;</code>可取消表单轮廓线。</p>\n<h4 id=\"resize\">Resize</h4>\n<p><code>resize: none;</code> 可以设置让 <code>&lt;textarea&gt;</code> 不能随意拖动。</p>\n<h4 id=\"vertical-align\">Vertical-align</h4>\n<p><code>vertical-align: baseline | top | middle | bottom;</code></p>\n<p>分别可以实现 <strong>父元素基线对齐</strong>、<strong>（与最高元素的）顶端对齐</strong>、<strong>父元素中部对齐</strong>、<strong>（与最低元素的）的顶端对齐</strong>。</p>\n<p><strong>注意：</strong>本属性针对行内元素或行内块元素，可以使其水平对齐，<em>对块级元素无效</em>。</p>\n<p>四种线类型从高往底分别是：top line / middle line / base line / bottom line，默认情况下图片与文字是 <em>baseline align</em> 样式。</p>\n<p><strong>行内块元素与（父级）块元素的底部缝隙消除？</strong></p>\n<p>当在<code>&lt;div&gt;</code>中装入<code>&lt;img&gt;</code>时，<code>&lt;img&gt;</code>标签会与<code>&lt;div&gt;</code>标签的基线对齐，留下小缝隙，此时需要添加除了<em>baseline</em>以外的属性来消除缝隙。</p>\n<p>也可以将行内块元素或行内元素转换为块级元素来实现，但是会有导致其他问题。</p>\n<h4 id=\"text-overflow\">Text-overflow</h4>\n<p>单行文本省略显示</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">background-color</span>: white;</span><br><span class=\"line\">\t<span class=\"attribute\">margin</span>: <span class=\"number\">100px</span> auto;</span><br><span class=\"line\">\t<span class=\"attribute\">white-space</span>: nowrap;       <span class=\"comment\">/* 1. 强制一行显示 */</span></span><br><span class=\"line\">\t<span class=\"attribute\">overflow</span>: hidden;          <span class=\"comment\">/* 2. 隐藏溢出内容 */</span></span><br><span class=\"line\">\t<span class=\"attribute\">text-overflow</span>: ellipsis;   <span class=\"comment\">/* 3. 省略号代替溢出部分 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>多行文本显示省略号</p>\n<p>需要WebKit内核的支持，在最新的浏览器及移动端浏览器上较为兼容，IE不支持。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">40px</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">background-color</span>: white;</span><br><span class=\"line\">\t<span class=\"attribute\">margin</span>: <span class=\"number\">100px</span> auto;</span><br><span class=\"line\">\t<span class=\"attribute\">overflow</span>: hidden;               <span class=\"comment\">/* 1. 隐藏溢出内容 */</span></span><br><span class=\"line\">\t<span class=\"attribute\">text-overflow</span>: ellipsis;        <span class=\"comment\">/* 2. 省略号代替溢出部分 */</span></span><br><span class=\"line\">  <span class=\"attribute\">display</span>: -webkit-box;           <span class=\"comment\">/* 3. 转换为弹性伸缩的盒子 */</span>      </span><br><span class=\"line\">  -webkit-line-clamp: <span class=\"number\">2</span>;          <span class=\"comment\">/* 4. 设置需要显示的行数 */</span></span><br><span class=\"line\">  -webkit-box-orient: vertical;   <span class=\"comment\">/* 5. 设置排列方式 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"highlight\">Highlight</h4>\n<p>鼠标滑过<code>&lt;div&gt;</code>时高亮显示，可以使用 <code>position: relative;</code> 或者 <code>z-index: 1;</code> 搭配其他特效 来让盒子图层置顶高亮显示。</p>\n<h4 id=\"单个盒子内文字围绕图片效果\">单个盒子内文字围绕图片效果</h4>\n<ul>\n<li>可以在一个父级只装了文字的盒子内，放置一个浮动模块，产生文字围绕图片的效果。</li>\n<li>此时文字和盒子的间距为0，显得不美观，可以为图片添加一个 <code>padding</code>属性。</li>\n</ul>\n<h4 id=\"页面导航制作\">页面导航制作</h4>\n<p>使用行内块可以制作不需要添加 <code>margin</code> 属性，却有 <code>margin</code> 效果的页码导航部分。 所有行内块元素可以在同一列显示，且使用 <code>text-align: center;</code> 即可让所有元素居中对齐。</p>\n<h4 id=\"梯形制作\">梯形制作</h4>\n<p>梯形是由矩形+直角三角形获得，直角三角形获得方式如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">100px</span> solid transparent;     <span class=\"comment\">/* 其中一边设置为长边，且设置为透明色 */</span></span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">50px</span> solid skyblue;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">0</span> solid blue;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">0</span> solid green;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: transparent red transparent transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-style</span>: solid;</span><br><span class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">22px</span> <span class=\"number\">8px</span> <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"css初始化样式\">CSS初始化样式</h3>\n<p><code>&lt;link rel=\"stylesheet\" href=\"css/base.css\"&gt;</code></p>\n<p>最简单的初始化方法就是： <code>* &#123;padding: 0; margin: 0;&#125;</code>。虽然通配符<code>*</code> 在编写代码的时候非常方便快捷，但如果网站和CSS样式表文件都很大，书写通配符<code>*</code>会把所有的标签都初始化一遍，加大了网站渲染的负担，延后网页加载时间。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* CSS 初始化 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 标签选择器 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">html</span>, <span class=\"selector-tag\">body</span>, <span class=\"selector-tag\">ul</span>, <span class=\"selector-tag\">li</span>, <span class=\"selector-tag\">ol</span>, <span class=\"selector-tag\">dl</span>, <span class=\"selector-tag\">dd</span>, <span class=\"selector-tag\">dt</span>, <span class=\"selector-tag\">p</span>, <span class=\"selector-tag\">h1</span>, <span class=\"selector-tag\">h2</span>, <span class=\"selector-tag\">h3</span>, <span class=\"selector-tag\">h4</span>, <span class=\"selector-tag\">h5</span>, <span class=\"selector-tag\">h6</span>, </span><br><span class=\"line\"><span class=\"selector-tag\">form</span>, <span class=\"selector-tag\">fieldset</span>, <span class=\"selector-tag\">legend</span>, <span class=\"selector-tag\">img</span> &#123; <span class=\"attribute\">margin</span>:<span class=\"number\">0</span>; <span class=\"attribute\">padding</span>:<span class=\"number\">0</span>; &#125; </span><br><span class=\"line\"><span class=\"selector-tag\">fieldset</span>, <span class=\"selector-tag\">img</span>,<span class=\"selector-tag\">input</span>,<span class=\"selector-tag\">button</span> &#123; <span class=\"attribute\">border</span>:none; <span class=\"attribute\">padding</span>:<span class=\"number\">0</span>;<span class=\"attribute\">margin</span>:<span class=\"number\">0</span>;<span class=\"attribute\">outline-style</span>:none; &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">ul</span>, <span class=\"selector-tag\">ol</span> &#123; <span class=\"attribute\">list-style</span>:none; &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">input</span> &#123; <span class=\"attribute\">padding-top</span>:<span class=\"number\">0</span>; <span class=\"attribute\">padding-bottom</span>:<span class=\"number\">0</span>; <span class=\"attribute\">font-family</span>: <span class=\"string\">&quot;SimSun&quot;</span>,<span class=\"string\">&quot;宋体&quot;</span>;&#125;</span><br><span class=\"line\">select, <span class=\"selector-tag\">input</span> &#123; <span class=\"attribute\">vertical-align</span>:middle; &#125;</span><br><span class=\"line\">select, <span class=\"selector-tag\">input</span>, <span class=\"selector-tag\">textarea</span> &#123; <span class=\"attribute\">font-size</span>:<span class=\"number\">12px</span>; <span class=\"attribute\">margin</span>:<span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">textarea</span> &#123; <span class=\"attribute\">resize</span>:none; &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">img</span> &#123;<span class=\"attribute\">border</span>:<span class=\"number\">0</span>;    <span class=\"attribute\">vertical-align</span>:middle;&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">table</span> &#123; <span class=\"attribute\">border-collapse</span>:collapse; &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font</span>:<span class=\"number\">12px</span>/<span class=\"number\">150%</span> Arial,Verdana,<span class=\"string\">&quot;\\5b8b\\4f53&quot;</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#666</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:<span class=\"number\">#fff</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.clearfix</span>:before,.clearfix:after&#123; </span><br><span class=\"line\">    content:<span class=\"string\">&quot;&quot;</span>; </span><br><span class=\"line\">    <span class=\"attribute\">display</span>:table; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"selector-class\">.clearfix</span>:after&#123;clear:both;&#125; </span><br><span class=\"line\"><span class=\"selector-class\">.clearfix</span>&#123; </span><br><span class=\"line\">    *zoom:<span class=\"number\">1</span>;<span class=\"comment\">/*IE/7/6*/</span> </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"selector-tag\">a</span>&#123;<span class=\"attribute\">color</span>:<span class=\"number\">#666</span>; <span class=\"attribute\">text-decoration</span>:none; &#125;</span><br><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span>&#123;<span class=\"attribute\">color</span>:<span class=\"number\">#C81623</span>;&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h1</span>,<span class=\"selector-tag\">h2</span>,<span class=\"selector-tag\">h3</span>,<span class=\"selector-tag\">h4</span>,<span class=\"selector-tag\">h5</span>,<span class=\"selector-tag\">h6</span>&#123;<span class=\"attribute\">text-decoration</span>:none;<span class=\"attribute\">font-weight</span>:normal;&#125;</span><br><span class=\"line\">s,<span class=\"selector-tag\">i</span>,<span class=\"selector-tag\">em</span>&#123;<span class=\"attribute\">font-style</span>:normal;<span class=\"attribute\">text-decoration</span>:none;&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-red</span>&#123;<span class=\"attribute\">color</span>: <span class=\"number\">#C81623</span><span class=\"meta\">!important</span>;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 公共类选择器 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.w</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">1210px</span>;<span class=\"attribute\">margin</span>:<span class=\"number\">0</span> auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.fl</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span><span class=\"selector-pseudo\">:left</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.fr</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span><span class=\"selector-pseudo\">:right</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.al</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span><span class=\"selector-pseudo\">:left</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.ac</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>:center</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.ar</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span><span class=\"selector-pseudo\">:right</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.hide</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>:none</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"css公共样式\">CSS公共样式</h3>\n<p><code>&lt;link rel=\"stylesheet\" href=\"css/common.css\"&gt;</code></p>\n<h3 id=\"css3函数支持\">CSS3函数支持</h3>\n<h4 id=\"滤镜函数\">滤镜函数</h4>\n<p><strong><code>filter</code></strong>属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。</p>\n<p>CSS标准里包含了一些已实现预定义效果的函数。</p>\n<p>设置一种函数，方法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">filter</span>: &lt;filter-function&gt; [&lt;filter-function&gt;]* | none</span><br></pre></td></tr></table></figure>\n<p>filter中所有的滤镜函数：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* URL to SVG filter */</span></span><br><span class=\"line\"><span class=\"attribute\">filter</span>: <span class=\"built_in\">url</span>(<span class=\"string\">&quot;filters.svg#filter-id&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* &lt;filter-function&gt; values */</span></span><br><span class=\"line\"><span class=\"attribute\">filter</span>: <span class=\"built_in\">blur</span>(<span class=\"number\">5px</span>);                           <span class=\"comment\">/*设置高斯模糊*/</span></span><br><span class=\"line\"><span class=\"attribute\">filter</span>: <span class=\"built_in\">brightness</span>(<span class=\"number\">0.4</span>);                     <span class=\"comment\">/*设置明亮度*/</span></span><br><span class=\"line\"><span class=\"attribute\">filter</span>: <span class=\"built_in\">contrast</span>(<span class=\"number\">200%</span>);</span><br><span class=\"line\"><span class=\"attribute\">filter</span>: <span class=\"built_in\">drop-shadow</span>(<span class=\"number\">16px</span> <span class=\"number\">16px</span> <span class=\"number\">20px</span> blue);    <span class=\"comment\">/**/</span></span><br><span class=\"line\"><span class=\"attribute\">filter</span>: <span class=\"built_in\">grayscale</span>(<span class=\"number\">50%</span>);</span><br><span class=\"line\"><span class=\"attribute\">filter</span>: <span class=\"built_in\">hue-rotate</span>(<span class=\"number\">90deg</span>);</span><br><span class=\"line\"><span class=\"attribute\">filter</span>: <span class=\"built_in\">invert</span>(<span class=\"number\">75%</span>);</span><br><span class=\"line\"><span class=\"attribute\">filter</span>: <span class=\"built_in\">opacity</span>(<span class=\"number\">25%</span>);</span><br><span class=\"line\"><span class=\"attribute\">filter</span>: <span class=\"built_in\">saturate</span>(<span class=\"number\">30%</span>);</span><br><span class=\"line\"><span class=\"attribute\">filter</span>: <span class=\"built_in\">sepia</span>(<span class=\"number\">60%</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 多种滤镜复合使用 */</span></span><br><span class=\"line\"><span class=\"attribute\">filter</span>: <span class=\"built_in\">contrast</span>(<span class=\"number\">175%</span>) <span class=\"built_in\">brightness</span>(<span class=\"number\">3%</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 全局变量 */</span></span><br><span class=\"line\"><span class=\"attribute\">filter</span>: inherit;</span><br><span class=\"line\"><span class=\"attribute\">filter</span>: initial;</span><br><span class=\"line\"><span class=\"attribute\">filter</span>: unset;</span><br></pre></td></tr></table></figure>\n<h4 id=\"计算函数\">计算函数</h4>\n<p><strong><em><code>calc()</code></em></strong> 函数可以在任何定义数值大小的地方进行使用，不同于代码的严格输入要求，CSS支持混合类型输入，即百分比和精确数值混合使用，如 <code>width: calc(100% - 3px)</code>; 运算符号支持 + | - | * | / 四则。</p>\n<h3 id=\"css3动画效果\">CSS3动画效果</h3>\n<h4 id=\"过渡\">过渡</h4>\n<p>过渡可以为一个元素在不同状态之间切换的时候定义不同的过渡效果。比如在不同的伪元素之间切换，像是 <code>:hover</code>，<code>:active</code> 或者通过 JavaScript 实现的状态变化。</p>\n<p><strong><em><code>transition CSS</code></em></strong>属性是 <code>transition-property</code>，<code>transition-duration</code>，<code>transition-timing-function</code> 和 <code>transition-delay</code> 的一个简写属性。</p>\n<p><code>transition-property</code> 可设置的参数如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 关键值 */</span></span><br><span class=\"line\"><span class=\"attribute\">transition-property</span>: none;</span><br><span class=\"line\"><span class=\"attribute\">transition-property</span>: all;</span><br><span class=\"line\"><span class=\"attribute\">transition-property</span>: test_05;</span><br><span class=\"line\"><span class=\"attribute\">transition-property</span>: -specific;</span><br><span class=\"line\"><span class=\"attribute\">transition-property</span>: sliding-vertically;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">transition-property</span>: test1;</span><br><span class=\"line\"><span class=\"attribute\">transition-property</span>: test1, animation4;</span><br><span class=\"line\"><span class=\"attribute\">transition-property</span>: all, height, all;</span><br><span class=\"line\"><span class=\"attribute\">transition-property</span>: all, -moz-specific, sliding;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 全局变量 */</span></span><br><span class=\"line\"><span class=\"attribute\">transition-property</span>: inherit;</span><br><span class=\"line\"><span class=\"attribute\">transition-property</span>: initial;</span><br><span class=\"line\"><span class=\"attribute\">transition-property</span>: unset;</span><br></pre></td></tr></table></figure>\n<h1 id=\"part-3-javascript\">PART 3: JavaScript</h1>\n<div style=\"font-style: italic; color: #999; text-align: right;\">\n——吉财\n</div>\n<h2 id=\"基础知识\">基础知识</h2>\n<h3 id=\"简介\">简介</h3>\n<h4 id=\"优缺点\">优缺点</h4>\n<table>\n<colgroup>\n<col style=\"width: 50%\" />\n<col style=\"width: 50%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>1. 减少服务器交互-数据发送到服务器前验证输入，减少流量及计算量<br />2. 立即反馈给服务者-不必等待页面重载而立即判断输入是否遗漏<br />3. 交互性增强-各种悬停交互或键盘交互<br />4. 更丰富的界面-拖放组件或滑块组件使界面更丰富</td>\n<td>1. 客户端的JavaScript不允许读取或写入文件，出于安全考虑<br />2. 不能用于网络应用，不支持此功能<br />3. 没有任何多线程或多处理器能力</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"语法\">语法</h3>\n<h4 id=\"注释\">注释</h4>\n<ul>\n<li><code>//</code> 及随后的文本</li>\n<li><code>/*</code> 及 <code>*/</code>之间的文本</li>\n<li><code>&lt;!--</code> （HTML注释开始序列）被视为与 <code>//</code> 一致的单行注释</li>\n<li>HTML注释结束序列 <code>--&gt;</code> 无法被识别为注释</li>\n</ul>\n<h4 id=\"非javascript浏览器警告\">非JavaScript浏览器警告</h4>\n<p>可以使用<code>&lt;noscript&gt;</code>标记向用户显示缺少JavaScript功能警告。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">language</span>=<span class=\"string\">&quot;javascript&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class=\"line\">\t&lt;!--</span><br><span class=\"line\">\tJavaScript</span><br><span class=\"line\">\t--&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">noscript</span>&gt;</span></span><br><span class=\"line\">\tSorry... JavaScript is needed to go ahead.</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">noscript</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"变量\">变量</h3>\n<p>JavaScript支持三种原始数据类型：Numbers | Strings | Boolean ; 及两种简单数据类型：Null | Undefined</p>\n<h3 id=\"循环\">循环</h3>\n<p>for...in循环</p>\n<p>类似于C# / Java中的用法</p>\n<h3 id=\"事件\">事件</h3>\n<h4 id=\"onclick事件\">onclick事件</h4>\n<p>可以通过在HTML的标签中设置<code>onclick</code>属性，结合JavaScript定义函数来构成 <strong>鼠标单击事件</strong>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">    \t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHello</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        alert(<span class=\"string\">&quot;Hello, World!&quot;</span>);</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;sayHello()&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;say Hello&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"进阶知识\">进阶知识</h2>\n<h1 id=\"part-4-网站及框架\">PART 4: 网站及框架</h1>\n<div style=\"font-style: italic; color: #999; text-align: right;\">\n——吉财\n</div>\n<p>框架是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法。另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。</p>\n<p>可以说，一个框架是一个可复用的设计构件，它规定了应用的体系结构，阐明了整个设计、协作构件之间的依赖关系、责任分配和控制流程，表现为一组抽象类以及其实例之间协作的方法，它为构件复用提供了上下文(Context)关系。因此构件库的大规模重用也需要框架。</p>\n<p>构件领域框架方法在很大程度上借鉴了硬件技术发展的成就，它是 <strong>构件技术</strong> 、 <strong>软件体系结构研究</strong> 和 <strong>应用软件开发</strong> 三者发展结合的产物。在很多情况下，框架通常以 <strong>构件库</strong> 的形式出现，但构件库只是框架的一个重要部分。框架的关键还在于框架内对象间的 <strong>交互模式</strong> 和 <strong>控制流模式</strong> 。</p>\n<p>框架比构件可定制性强。在某种程度上，将构件和框架看成两个不同但彼此协作的技术或许更好。框架为构件提供重用的环境，为构件处理错误、交换数据及激活操作提供了标准的方法。</p>\n<p><strong>应用框架</strong></p>\n<blockquote>\n<p>应用框架并不是包含构件应用程序的小片程序，而是实现了某应用领域通用完备功能（除去特殊应用的部分）的底层服务。使用这种框架的编程人员可以在一个通用功能已经实现的基础上开始具体的系统开发。框架提供了所有应用期望的默认行为的类集合。具体的应用通过重写子类(该子类属于框架的默认行为)或组装对象来支持应用专用的行为。应用框架强调的是软件的设计重用性和系统的可扩充性,以缩短大型应用软件系统的开发周期，提高开发质量。与传统的基于类库的面向对象重用技术比较，应用框架更注重于面向专业领域的软件重用。应用框架具有领域相关性，构件根据框架进行复合而生成可运行的系统。框架的粒度越大，其中包含的领域知识就更加完整。</p>\n</blockquote>\n<blockquote>\n<p><strong><em>“框架其实是某种应用的半成品，就是一组组件，供你选用完成你自己的系统。简单说就是使用别人搭好的舞台，你来做表演。而且，框架一般是成熟的，不断升级的软件。 ”</em></strong></p>\n</blockquote>\n<p>框架的概念最早起源于Smalltalk环境，其中最著名的框架是Smalltalk 80的用户界面框架MVC(Model-View-Controller)。随着用户界面框架Interviews 【Linton 89】和ET++ 【Weinand 89】 的开发和发布，框架研究越来越受到研究人员的重视。虽然框架研究最初起源于用户界面领域，但它还被成功地应用到其他领域中，如操作系统、火警系统 等。Taligent公司于1992年成立后，框架研究受到了广泛的重视。该公司计划基于框架来开发一个完整的面向对象操作系统。另外，该公司还发布了一套支持快速应用开发的工具集CommonPoint，其中包括了上百个面向对象框架 【Andert 94,Cotter 95】。框架还没有统一的定义，其中Ralph Johnson所给出的定义基本上为大多数研究人员所接受：</p>\n<blockquote>\n<p><strong><em>一个框架是一个可复用设计，它是由一组抽象类及其实例间协作关系来表达的。</em></strong></p>\n</blockquote>\n<p>这个定义是从框架内涵的角度来定义框架的，当然也可以从框架用途的角度来给出框架的定义：</p>\n<blockquote>\n<p><strong><em>一个框架是在一个给定的问题领域内，一个应用程序的一部分设计与实现。</em></strong></p>\n</blockquote>\n<p>从以上两个定义可以看出，框架是对特定应用领域中的应用系统的部分设计和实现的整体结构。框架将应用系统划分为类和对象，定义类和对象的责任，类和对象如何互相协作，以及对象之间的控制线程。这些共有的设计因素由框架预先定义，应用开发人员只须关注于特定的应用系统特有部分。框架刻画了其应用领域所共有的设计决策，所以说框架着重于设计复用，尽管框架中可能包含用某种程序设计语言实现的具体类。</p>\n<p>一个基于框架开发的应用系统包含一个或多个框架，与框架相关的构件类，以及与应用系统相关的功能扩展。与应用系统相关的扩展包括与应用系统相关的类和对象。应用系统可能仅仅复用了面向对象框架的一部分，或者说，它可能需要对框架进行一些适应性修改，以满足系统需求。</p>\n<p>面向对象的框架作为一种可复用的软件，在基于框架的软件开发过程中会涉及到框架的开发和利用两个方面的工作。框架的开发阶段在于产生领域中可复用的设计。该阶段的主要结果是框架以及与框架相关的构件类。该阶段的一个重要活动是框架的演变和维护。象所有软件一样，框架也易于变化。产生变化的原因很多，如应用出错，业务领域变化，等等。</p>\n<p>不论是哪一种技术，最终都是为业务发展而服务的。从业务的角度来讲。首先，框架的是为了企业的业务发展和战略规划而服务的，他服从于企业的愿景；其次，框架最重要的目标是提高企业的竞争能力，包括降低成本、提高质量、改善客户满意程度，控制进度等方面。最后，框架实现这一目标的方式是进行有效的知识积累。软件开发是一种知识活动，因此知识的聚集和积累是至关重要的。框架能够采用一种结构化的方式对某个特定的业务领域进行描述，也就是将这个领域相关的技术以代码、文档、模型等方式固化下来。</p>\n<h2 id=\"mvc-框架\">MVC 框架</h2>\n<p>即 Model-View-Control 三层框架。</p>\n<h2 id=\"mvvm-框架\">MVVM 框架</h2>\n<p>即 Model-View-ViewModel，一个软件架构设计模式。由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表。</p>\n<p>MVVM 源自于经典的 Model–View–Controller（MVC）模式（期间还演化出了 Model-View-Presenter（MVP）模式，可忽略不计）。</p>\n<p>MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。</p>\n<p>当然这些事 ViewModel 已经帮我们做了，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示：</p>\n<p><img src=\"http://pic.liewzheng.cn/2021/02/2021-02-19-20210219-02.png\" alt=\"20210219-02\" style=\"zoom: 80%;\" /></p>\n<h3 id=\"mvvm框架详解\">MVVM框架详解</h3>\n<p><img src=\"http://pic.liewzheng.cn/2021/02/2021-02-19-20210219-01.png\" alt=\"20210219-01\" style=\"zoom: 80%;\" /></p>\n<h4 id=\"view-level\">View Level</h4>\n<p>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建，为了更方便地展现 ViewModel 或者 Model 层的数据，已经产生了各种各样的前后端模板语言，比如 FreeMarker、Marko、Pug、Jinja2等等，各大 MVVM 框架如 KnockoutJS，Vue，Angular 等也都有自己用来构建用户界面的内置模板语言。</p>\n<h4 id=\"model-level\">Model Level</h4>\n<p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。</p>\n<h4 id=\"viewmodel-level\">ViewModel Level</h4>\n<p>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li><p><strong><em>ViewModel 所封装出来的数据模型包括视图的状态和行为两部分</em></strong>，而 <u>Model 层的数据模型是只包含状态的</u>（比如页面的这一块展示什么，那一块展示什么这些都属于视图状态（展示），而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互）），<u>视图状态和行为都封装在了 ViewModel 里。</u></p></li>\n<li><p>这样的封装使得 ViewModel 可以完整地去描述 View 层。由于实现了双向绑定，ViewModel 的内容会实时展现在 View 层，这是激动人心的，因为前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新，真正实现数据驱动开发。</p></li>\n<li><p>View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</p></li>\n</ul>\n<p><strong>意义：</strong></p>\n<p>MVVM用接口实现了前后端数据的通信，这样可以使前后端之间的业务逻辑没有什么关系，促进了 <strong><em>GUI 前端开发与后端业务逻辑的分离</em></strong>， 极大地提高了前端开发效率</p>\n<h3 id=\"mvvm框架编程实例\">MVVM框架编程实例</h3>\n<p>Vue 的 View 模板：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">&quot;showMessage()&quot;</span>&gt;</span>Click me<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n<p>Vue 的 ViewModel 层（下面是伪代码）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">    data: &#123;     <span class=\"comment\">// 用于描述视图状态（有基于 Model 层数据定义的，也有纯前端定义）</span></span><br><span class=\"line\">        message: <span class=\"string\">&#x27;Hello Vue!&#x27;</span>,  <span class=\"comment\">// 纯前端定义</span></span><br><span class=\"line\">        server: &#123;&#125;, <span class=\"comment\">// 存放基于 Model 层数据的二次封装数据</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods: &#123;  <span class=\"comment\">// 用于描述视图行为（完全前端定义）</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">showMessage</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> vm = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">            alert(vm.message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">created</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> vm = <span class=\"built_in\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Ajax 获取 Model 层的数据</span></span><br><span class=\"line\">        ajax(&#123;</span><br><span class=\"line\">            url: <span class=\"string\">&#x27;/your/server/data/api&#x27;</span>,</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">success</span>(<span class=\"params\">res</span>)</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// TODO 对获取到的 Model 数据进行转换处理，做二次封装</span></span><br><span class=\"line\">                vm.server = res;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n<p>服务端的 Model 层（省略业务逻辑处理，只描述对外接口）：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;url&quot;</span>: <span class=\"string\">&quot;/your/server/data/api&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;res&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">&quot;success&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;IoveC&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;domain&quot;</span>: <span class=\"string\">&quot;www.cnblogs.com&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"名词解释\">名词解释</h2>\n<p><strong>渐进式</strong></p>\n<hr />\n<p>指VUE.JS并未强制开发者一定要使用哪种方式进行开发，更不必严格按照规矩来开发（较Angular、React），适用于开发水平不尽相同的团队，其只是提供了视图层（View Level），对于底层的开发方式还是提供了很多选择。</p>\n<blockquote>\n<p><em>“资料非常多，规则非常多，你要用它开发，你就必须使用它的开发规则，像模块机制、依赖注入及组件的定义，你都得按它的来，不然开发过程中就会有很多坑等着你。”</em></p>\n<p>——对Angular的评价</p>\n</blockquote>\n<blockquote>\n<p><em>“你必须要有优秀的函数式编程思想，能把业务很好的映射到函数式编程的理念，……，对于刚接触这个框架的新人来说，如果在没有人或者架构师去详细跟他们讲解公司里react项目框架细节情况的前提下，直接拿着公司项目框架来进行业务模型、逻辑组件开发或者是快速开发，结果可能是非常糟糕的。”</em></p>\n<p>——对React的评价</p>\n</blockquote>\n<p><strong>响应式</strong></p>\n<hr />\n<p>此概念于2010年5月由国外著名网页设计师Ethan Marcotte所提出。</p>\n<p>响应式网站设计(Responsive Web design)的理念是：</p>\n<p><strong>页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整。</strong>具体的实践方式由多方面组成，包括弹性网格和布局、图片、CSS media query的使用等。无论用户正在使用笔记本还是iPad，我们的页面都应该能够自动切换分辨率、图片尺寸及相关脚本功能等，以适应不同设备；换句话说，页面应该有能力去自动响应用户的设备环境。</p>\n<p><strong>响应式网页设计就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。</strong>这样，我们就可以不必为不断到来的新设备做专门的版本设计和开发了。 [1]</p>\n<p>响应式网站设计是一种网络页面设计布局，其理念是：集中创建页面的图片排版大小，可以智能地根据用户行为以及使用的设备环境进行相对应的布局。</p>\n<h2 id=\"目前流行的9大前端框架\"><a href=\"https://zhuanlan.zhihu.com/p/76463271\">目前流行的9大前端框架</a></h2>\n<hr />\n<p>1.<a href=\"https://cn.vuejs.org\">Vue</a></p>\n<p>Vue (读音 <em>/vjuː/</em>，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>\n<p>2.<a href=\"https://react.docschina.org/\">React</a></p>\n<p>React 是一个用于构建用户界面的 JAVASCRIPT 库。React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。</p>\n<p>3.<a href=\"https://angular.io\">Angular</a></p>\n<p>AngularJS诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。</p>\n<p>4.<a href=\"http://www.uileader.com/product_quickui\">QucikUI</a></p>\n<p>QucikUI 4.0是一套完整的企业级web前端开发解决方案，由基础框架、UI组件库、皮肤包、示例工程和文档等组成。底层基于jquery构建。使用QucikUI 开发者可以极大地减少工作量，提高开发效率，快速构建功能强大、美观、兼容的web应用系统。</p>\n<p>5.<a href=\"https://www.layui.com/\">Layui</a></p>\n<p>layui（谐音：类UI) 是一款采用自身模块规范编写的前端 UI 框架，遵循原生 HTML/CSS/JS 的书写与组织形式，门槛极低，拿来即用。其外在极简，却又不失饱满的内在，体积轻盈，组件丰盈，从核心代码到 API 的每一处细节都经过精心雕琢，非常适合界面的快速开发。layui 首个版本发布于2016年金秋，她区别于那些基于 MVVM 底层的 UI 框架，却并非逆道而行，而是信奉返璞归真之道。准确地说，她更多是为服务端程序员量身定做，你无需涉足各种前端工具的复杂配置，只需面对浏览器本身，让一切你所需要的元素与交互，从这里信手拈来。</p>\n<p>6.<a href=\"http://avalonjs.coding.me/\">Avalon</a></p>\n<p>avalon2是一款基于虚拟DOM与属性劫持的 迷你、 易用、 高性能 的 前端MVVM框架， 拥有超优秀的兼容性, 支持移动开发, 后端渲染, WEB Component式组件开发, 无需编译, 开箱即用。</p>\n<p>7.<a href=\"https://dojo.io/\">Dojo</a></p>\n<p>Dojo致力于实现最大的互操作性。Web组件提供了一种机制，可以在Dojo应用程序中利用非Dojo组件，并在非Dojo应用程序中轻松使用基于Dojo的小部件。Dojo为Web组件提供一流的支持。您今天做出的决定不应该将您锁定在未来的决策中。</p>\n<p>8.<a href=\"https://emberjs.com/\">Ember</a></p>\n<p>Ember.js可能是最固执己见的主流框架，这也是其最大的优势。它有创建Ember.js应用程序的正确方法，通常只有一种方法来创建应用程序。Ember.js更类似于一个产品或平台，在那里你会到一个供应商的长期支持和维护。Ember.js提供了对其平台的全面版本管理，升级工具以及对API升级的强大指导和工具。成熟，是对Ember.js的一个很好的总结。</p>\n<p>9.<a href=\"https://aurelia.io/\">Aurelia</a> Aurelia是一个令人惊叹的框架，它在不牺牲功能的情况下采用简单而干净的代码。在本教程中，我们将通过构建“Todo”应用程序向您介绍Aurelia的简单性。您将看到应用程序代码的简洁程度，您将学习Aurelia的几个基本概念和功能。</p>\n<h2 id=\"web前端js框架有哪些\"><a href=\"https://zhuanlan.zhihu.com/p/145228252%3Ffrom%5Fvoters%5Fpage%3Dtrue\">Web前端js框架有哪些</a></h2>\n<hr />\n<p><strong>MobX</strong></p>\n<blockquote>\n<p>MobX 支持单向数据流，也就是动作改变状态，而状态的改变会更新所有受影响的视图。</p>\n<p>当状态改变时，所有衍生都会进行原子级的自动更新。因此永远不可能观察到中间值。</p>\n</blockquote>\n<p><strong>Ractive.js</strong></p>\n<blockquote>\n<p>active最初是在The Guardian <a href=\"https://link.zhihu.com/?target=http%3A//theguardian.com\">http://theguardian.com</a>上创建的，用于制作新闻应用程序。典型的新闻应用是高度互动的，结合了HTML和SVG，并且是在极端的最后期限压力下开发的。它必须跨浏览器可靠地工作，即使在移动设备上也能很好地运行。</p>\n</blockquote>\n<p><strong>WebRx</strong></p>\n<blockquote>\n<p>WebRx是一个基于浏览器的MVVM-Framework，它将功能反应编程与声明性数据绑定，模板和客户端路由相结合。</p>\n<p>该框架构建于ReactiveX for Javascript（RxJs）之上，它是一组功能强大的库，用于处理和查询异步数据流，这些数据流可以来自不同的来源，如Http-Requests，Input-Events，Timers等等。</p>\n</blockquote>\n<p><strong>Deku</strong></p>\n<blockquote>\n<p>Deku是一个使用纯函数和虚拟DOM渲染接口的库。</p>\n<p>Deku只使用函数并将所有状态管理和副作用的责任推送到像Redux这样的工具，而不是使用类和本地状态。它还旨在仅支持现代浏览器以保持简单。</p>\n</blockquote>\n<p><strong>Roit.js</strong></p>\n<blockquote>\n<p>Riot为所有现代浏览器带来了自定义组件。它旨在为您提供Web组件API所需的所有本机<strong>。</strong></p>\n</blockquote>\n<p><strong>Mithril</strong></p>\n<blockquote>\n<p>用于构建单页应用程序的现代客户端Javascript框架。它很小（9.55 KB gzip），速度快，提供开箱即用的路由和XHR实用程序。</p>\n</blockquote>\n<p><strong>jQuery</strong></p>\n<blockquote>\n<p>Query是一个快速，小巧，功能丰富的JavaScript库。它通过易于使用的API在大量浏览器中运行，使得HTML文档遍历和操作，事件处理，动画和Ajax变得更加简单。通过多功能性和可扩展性的结合，jQuery改变了数百万人编写JavaScript的方式。</p>\n</blockquote>\n<p><strong>React</strong></p>\n<blockquote>\n<p>React 组件使用一个名为 render() 的方法，接收输入的数据并返回需要展示的内容。在示例中这种类似 XML 的写法被称为 JSX。被传入的数据可在组件中通过 this.props 在 render() 访问。</p>\n</blockquote>\n<p><strong>Polymer</strong></p>\n<blockquote>\n<p>Polymer 库提供用于创建自定义元素的一组功能。这些功能的设计，使其更容易、更快地创建像标准的 DOM 元素一样工作的自定义元素。</p>\n</blockquote>\n<p><strong>Node.js</strong></p>\n<blockquote>\n<p>Node.js®是基于Chrome的V8 JavaScript引擎构建的JavaScript运行时。</p>\n</blockquote>\n<p><strong>Meteor</strong></p>\n<blockquote>\n<p>Meteor是一个用于构建现代Web应用程序的超简单环境。</p>\n</blockquote>\n<p><strong>D3.js</strong></p>\n<blockquote>\n<p>D3.js是一个用于根据数据操作文档的JavaScript库。D3可帮助您使用HTML，SVG和CSS将数据变为现实。D3对Web标准的强调为您提供了现代浏览器的全部功能，而无需将自己与专有框架联系起来，将强大的可视化组件和数据驱动方法结合到DOM操作中。</p>\n</blockquote>\n<p><strong>Ember</strong></p>\n<blockquote>\n<p>Ember.js是一个JavaScript框架，可以大大减少构建任何Web应用程序所需的时间，精力和资源。它致力于通过执行大多数Web开发项目中涉及的所有常见，重复但必不可少的任务，使您（开发人员）尽可能高效地工作。</p>\n</blockquote>\n<p><strong>Aurelia</strong></p>\n<blockquote>\n<p>Aurelia是一个现代的前端JavaScript框架，用于构建浏览器，移动和桌面应用程序。它侧重于与Web平台规范紧密结合，使用约定优于配置，并具有最小的框架入侵。</p>\n</blockquote>\n<p><strong>Knockout</strong></p>\n<blockquote>\n<p>Knockout是一个JavaScript MVVM（MVC的现代变体）库，可以更轻松地使用JavaScript和HTML创建丰富的，类似桌面的用户界面。它使用观察器使您的UI自动与底层数据模型保持同步，以及一组功能强大且可扩展的声明性绑定，以实现高效的开发。</p>\n</blockquote>\n<p><strong>Keystore</strong></p>\n<blockquote>\n<p>KeystoneJS是一个功能强大的Node.js内容管理系统和基于Express Web框架和Mongoose ODM构建的Web应用程序框架。Keystone可以轻松创建复杂的网站和应用程序，并附带一个漂亮的自动生成的管理UI。</p>\n</blockquote>\n<p><strong>Backbone</strong></p>\n<blockquote>\n<p>Backbone.js的提供给结构的Web应用程序的模型与键值绑定和自定义事件， 收集与枚举功能丰富的API， 观点与陈述事件处理，而这一切在一个RESTful JSON接口连接到现有的API。</p>\n</blockquote>\n<p><strong>Zepto</strong></p>\n<blockquote>\n<p>Zepto是一个用于现代浏览器的极简主义JavaScript库，具有与jQuery兼容的API。</p>\n</blockquote>\n<h2 id=\"网站相关知识\">网站相关知识</h2>\n<h3 id=\"静态网站与动态网站\">静态网站与动态网站</h3>\n<h4 id=\"静态网站\">静态网站</h4>\n<h5 id=\"特性\">特性</h5>\n<ol type=\"1\">\n<li>静态网站是最初的建站方式，浏览者所看到的每个页面是建站者上传到服务器上的一个 html （ htm ）文件，这种网站每增加、删除、修改一个页面，都必须重新对服务器的文件进行一次下载上传。网页内容一经发布到网站服务器上，无论是否有用户访问，每个静态网页的内容都是保存在网站服务器上的，也就是说，静态网页是实实在在保存在服务器上的文件，每个网页都是一个独立的文件；</li>\n<li>静态网页的内容相对稳定，因此容易被搜索引擎检索；</li>\n<li>静态网页没有数据库的支持，在网站制作和维护方面工作量较大，因此当网站信息量很大时完全依靠静态网页制作方式比较困难；</li>\n<li>静态网页的交互性较差，在功能方面有较大的限制。</li>\n</ol>\n<h4 id=\"动态网站\">动态网站</h4>\n<ol type=\"1\">\n<li><p>交互性：网页会根据用户的要求和选择而动态地改变和响应，浏览器作为客户端，成为一个动态交流的桥梁，动态网页的交互性也是今后 Web 发展的潮流。</p></li>\n<li><p>自动更新：即无须手动更新 HTML 文档，便会自动生成新页面，可以大大节省工作量。</p></li>\n<li><p>因时因人而变：即当不同时间、不同用户访问同一网址时会出现不同页面。</p></li>\n</ol>\n<p>动态网站在页面里嵌套了程序，这种网站对一些框架相同，更新较快的信息页面进行内容与形式的分离，将信息内容以记录的形式存入了网站的数据库中，以便于网 站各处的调用。这样，我们看到的一个页面，可能在服务器上不一一对应某个 html 的文件了，网页框架里套了很多数据库里的记录中的内容。此外动态网页是与静态网页相对应的，也就是说，网页 URL 的后缀不是 <code>.htm</code> 、 <code>.html</code> 、 <code>.shtml</code> 、 <code>.xml</code> 等静态网页的常见形式，而是以 <code>.asp</code> 、 <code>.jsp</code> 、 <code>.php</code> 、<code>.perl</code> 、 <code>.cgi</code> 等形式为后缀。</p>\n<p>这里说的动态网页，与网页上的各种动画、滚动字幕等视觉上的 “ 动态效果 ” 没有直接关系，动态网页也可以是纯文字内容的，也可以是包含各种动画的内容，这些只是网页具体内容的表现形式，无论网页是否具有动态效果，采用动态网站技术生成的网页都称为动态网页。</p>\n<h4 id=\"静态或动态的选择\">静态或动态的选择</h4>\n<p>对于一个业务稳定，页面变化频率不大的公司来说，静态网站是一个很好的选择。因为不用开发后台程序，报 价会便宜很多。对于一个公司规模比较大的公司来说，可能经常会有动态信息要发布给浏览者，可以考虑用动态网站的后台来管理网站信息。</p>\n<h4 id=\"服务器端运行状态区别\">服务器端运行状态区别</h4>\n<p>静态服务器</p>\n<p><img src=\"http://pic.liewzheng.cn/2021/02/2021-03-01-20210301-01.png\" style=\"zoom:100%;\" /></p>\n<p>动态服务器-没有数据库</p>\n<p><img src=\"http://pic.liewzheng.cn/2021/02/2021-03-01-20210301-02.png\" style=\"zoom:100%;\" /></p>\n<p>动态服务器-有数据库</p>\n<p><img src=\"http://pic.liewzheng.cn/2021/02/2021-03-01-20210301-03.png\" style=\"zoom:100%;\" /></p>\n<p>动态服务器-多个数据库</p>\n<p><img src=\"http://pic.liewzheng.cn/2021/02/2021-03-01-20210301-04.png\" style=\"zoom:100%;\" /></p>\n<p>动态服务器-负载均衡</p>\n<p><img src=\"http://pic.liewzheng.cn/2021/02/2021-03-01-20210301-05.png\" style=\"zoom:100%;\" /></p>\n<h3 id=\"网站制作流程\">网站制作流程</h3>\n<ol type=\"1\">\n<li>网站功能书编写</li>\n<li>网站原型图设计</li>\n<li>网站效果图制作</li>\n<li>网站搭建（前后端同步）</li>\n</ol>\n<h1 id=\"vue.js\">Vue.js</h1>\n<p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>\n<h1 id=\"reference\">Reference</h1>\n<ol type=\"1\">\n<li><p>官方网站：http://cn.vuejs.org/</p></li>\n<li><p>视频教程：https://learning.dcloud.io/#/</p></li>\n</ol>\n","categories":["Networking"],"tags":["Web"]},{"title":"Javascript","url":"/2021/04/11/Web/2021-04-11-JavaScript/","content":"<h1 id=\"面向对象编程\">面向对象编程</h1>\n<h2 id=\"对象的抽象\">对象的抽象</h2>\n<p><strong>抽象</strong> 是指一种归纳或总结，<strong>对象</strong> 是现实世界物体特征的实体。万事万物不论大小皆可看做对象， <strong>类</strong> 则是对各种不同对象的 <em>归纳总结</em>，类是对象的 <em>抽象表示形式</em>。</p>\n<blockquote>\n<p>例如，男演员Jack可以看做是一个对象，女演员Rose也可以看过是一个对象，而两者会被统一归纳为Person或者Human的类（或抽象）。每一个对象都有其独特的属性（Property）或功能（Function），而归纳总结出来的类则具有不同对象的相同属性或功能。</p>\n</blockquote>\n<p>基于类的面向对象语言是面向对象世界里的主流。虽然大多数面向对象开发语言都使用类来完成面向对象编程，但类不是面向对象编程的实质内涵。面向对象的实质内涵是将所有业务逻辑单元都视为一个对象（即，对象是目的或结果），且类不是唯一用来完成面向对象编程的方法。</p>\n<p>面向对象不能被当做面向类，否则会进入误区。对象和类的关系相当于一般程序设计语言中的 <strong>变量</strong> 和 <strong>变量类型</strong> 的关系。所以，有时类也被称为是一种数据类型，可以看做抽象数据类型的具体实现。此时的数据类型则是 <strong>数据 </strong>和 <strong>操作</strong> 的集合。</p>\n<h2 id=\"面向对象与面向过程的区别\">面向对象与面向过程的区别</h2>\n<p>面向过程程序设计，即结构化程序设计，诸如Pascal、C。</p>\n<p>面向对象程序设计解决了结构化程序设计代码复用的难题，如C++、C#、Java、JavaScript、Python等都是。</p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210413144641711.png\" alt=\"image-20210413144641711\" style=\"zoom: 67%;\" /></p>\n<p>面向过程也是把程序定义为“数据+作用于数据的操作算法”，但最重要的区别是：面向过程编程 <mark>使用过程操作数据结构</mark>， 而面向对象编程将过程和数据结构捆绑，使对象 <mark>操作自己的数据结构</mark>。</p>\n<h1 id=\"javascript的类\">JavaScript的类</h1>\n<h2 id=\"类的创建\">类的创建</h2>\n<p>JavaScript可以用关键字 <code>class</code> 进行赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">height, width</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.height = height;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.width = width;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法一：参数赋值法，间接调用构造器赋值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oRectangle = <span class=\"keyword\">new</span> Rectangle(<span class=\"number\">10</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二：生成对象后单独调用赋值</span></span><br><span class=\"line\"><span class=\"comment\">// var oRectangle = new Rectangle();</span></span><br><span class=\"line\"><span class=\"comment\">// oRectangle.height = 10;</span></span><br><span class=\"line\"><span class=\"comment\">// oRectangle.width = 30;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(oRectangle.height, oRectangle.width)</span><br></pre></td></tr></table></figure>\n<p>在MDN Web Docs中，对JavaScript类的定义如下：</p>\n<blockquote>\n<p>实际上，类是“特殊的函数”，就像你能够定义的函数表达式和函数声明一样，类语法有两个组成部分：<strong>类表达式 </strong>和 <strong>类声明</strong>。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HelloWrold</span>(<span class=\"params\"></span>)</span>&#123;    <span class=\"comment\">//To use keyword `function` instead of `class` to define a class</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.printInfo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hi! JavaScript!\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> oHelloWorld = <span class=\"keyword\">new</span> HelloWorld();    <span class=\"comment\">// Make a new object of the class named `HelloWorld`</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = oHelloWorld.printInfo();    <span class=\"comment\">//Call the method of the object to assign</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(result);</span><br></pre></td></tr></table></figure>\n<h2 id=\"构造器\">构造器</h2>\n<p><strong>构造器（Constructor）</strong>，或称 <strong>构造方法</strong>，一种用于创建和初始化<code>class</code>创建的对象的特殊 <strong>方法（Methods）</strong>。<code>constructor([arguments]) &#123; ... &#125;</code>， 其中 <code>arguments</code> 看情况而定，可以省略。</p>\n<p><strong>注意</strong>：</p>\n<ol type=\"1\">\n<li>在一个类中只能有一个名为 <code>constructor</code> 的特殊方法。 一个类中出现多次构造函数 (constructor)方法将会抛出一个 <code>SyntaxError</code> 错误。</li>\n<li>在一个构造方法中可以使用 <code>super</code> 关键字来 <mark>调用一个父类的构造方法</mark>。</li>\n<li>如果没有显式指定构造方法，则会添加默认的 constructor 方法。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Polygon</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">arg0, arg1</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = <span class=\"string\">&#x27;Polygon&#x27;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.body = arg0 + arg1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> poly1 = <span class=\"keyword\">new</span> Polygon(<span class=\"number\">10</span>,<span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(poly1.name, poly1.body);</span><br><span class=\"line\"><span class=\"comment\">// expected output: &quot;Polygon&quot; 30</span></span><br></pre></td></tr></table></figure>\n","categories":["Networking"],"tags":["Web","Javascript"]},{"title":"What is the meaning of '-save' for NPM install ?","url":"/2021/05/19/Web/2021-05-19-What-is-the-meaning-of--savefor-NPM-install-/","content":"<p><a href=\"https://www.geeksforgeeks.org/what-is-the-meaning-of-save-for-npm-install/\">geeksforgeeks.org</a></p>\n<p><strong><a href=\"https://www.geeksforgeeks.org/node-js-npm-node-package-manager/\">NPM (Node Package Manager)</a></strong> is the default package manager employed in JavaScript runtime environment in Node.js. It has a very frequently used command <strong>npm install [Package Name] –save</strong>. But the fact is there is no difference between <strong>npm install [Package Name]</strong> and <strong>npm install [Package Name] –save</strong> in the later version after npm 5.0.0 onwards.</p>\n<p>Before npm 5.0.0, it was necessary to add <code>--save</code> after package name because it will save the installed package to package.json file in the dependency section. If you are using a recent version of npm save yourself from unnecessary typing and use <strong>npm install [Package Name]</strong> instead of <strong>npm install [Package Name] <code>--save</code></strong> by default it will add the installed package to the dependency list in the package.json file.</p>\n<p><strong>NPM has several commands which are listed below:</strong></p>\n<ol type=\"1\">\n<li><p>–save or -S:</p>\n<p>When the following command is used with npm install this will save all your installed core packages into the dependency section in the package.json file. Core dependencies are those packages without which your application will not give desired results. But as mentioned earlier, it is an unnecessary feature in the npm 5.0.0 version onwards.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save</span><br></pre></td></tr></table></figure></li>\n<li><p>–save-prod or -P:</p>\n<p>The following command is introduced in the later version of npm it will perform the same task as the</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--save</span><br></pre></td></tr></table></figure>\n<p>command unless any other command such as</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-D</span><br></pre></td></tr></table></figure>\n<p>or</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-O</span><br></pre></td></tr></table></figure>\n<p>is present.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-prod</span><br></pre></td></tr></table></figure></li>\n<li><p>–save-dev or -D:</p>\n<p>With</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--save-dev</span><br></pre></td></tr></table></figure>\n<p>or</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-D</span><br></pre></td></tr></table></figure>\n<p>command your installed packages will be added to devDependency section of the package.json file. Development dependencies are those packages which only meant for development purpose it will not affect the application’s result.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-dev</span><br></pre></td></tr></table></figure></li>\n<li><p>–save-optional or -O:</p>\n<p>When this command is used the install the that packages will be listed under the optional Dependency section of the package.json file. Optional dependencies are those packages which are only used when a particular feature of the application is used and will not be required if that functionality isn’t used.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-optional</span><br></pre></td></tr></table></figure></li>\n<li><p>–no-save:</p>\n<p>When this command is used with npm install it will not allow the installed packages from being saved into the dependency section.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --no-save</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><strong>Note:</strong> NPM provides two additional options to save dependencies into package.json file.</p>\n<ol type=\"1\">\n<li><p>–save-exact or -E:</p>\n<p>This is an additional or optional command provided by the npm that will save the exact version of the installed packages which are configured at the time of development. It will not download the dependencies from npm’s default server range operator.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-exact</span><br></pre></td></tr></table></figure></li>\n<li><p>–save-bundle or -B:</p>\n<p>The following command is also an optional command when</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">--save-bundle</span><br></pre></td></tr></table></figure>\n<p>or</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-B</span><br></pre></td></tr></table></figure>\n<p>is used. This will also add the saved dependencies under the bundleDependency list.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-bundle</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>​</p>\n","categories":["Networking"],"tags":["node","Nodejs","npm","save"]},{"title":"What is a Bypass Capacitor?","url":"/2021/04/21/Signal/2021-04-21-What%20is%20a%20Bypass%20Capacitor/","content":"<p><a href=\"http://www.learningaboutelectronics.com/Articles/What-is-a-bypass-capacitor.html\">learningaboutelectronics.com</a></p>\n<h1 id=\"what-is-a-bypass-capacitor\">What is a Bypass Capacitor?</h1>\n<figure>\n<img src=\"http://www.learningaboutelectronics.com/images/Bypass-capacitor.png\" alt=\"Bypass capacitor\" /><figcaption aria-hidden=\"true\">Bypass capacitor</figcaption>\n</figure>\n<p>A bypass capacitor is a capacitor that shorts AC signals to ground, so that any AC noise that may be present on a DC signal is removed, producing a much cleaner and pure DC signal.</p>\n<p>A bypass capacitor essentially bypasses AC noise that may be on a DC signal, filtering out the AC, so that a clean, pure DC signal goes through without any AC ripple.</p>\n<p>For example, you may want a pure DC signal from a power source.</p>\n<p>Below is a transistor circuit. A transistor is an active device, so in order to work, it needs DC power. This power source is VCC. In this case, VCC equals 15 volts.</p>\n<figure>\n<img src=\"http://www.learningaboutelectronics.com/images/DC-power-source-transistor.png\" alt=\"DC Power Source for Transistor\" /><figcaption aria-hidden=\"true\">DC Power Source for Transistor</figcaption>\n</figure>\n<p>This 15 volts provides power to the transistor so that the transistor can amplify signals. We want this signal to be as purely DC as possible. Although we obtain our DC voltage, VCC, from a DC power source such as a power supply, the voltage isn't always purely DC. In fact, many times the voltage is very noisy and contains a lot of AC ripple on it, especially at the 60Hz frequency because this is the frequency at which AC signals run in many countries.</p>\n<p>So although we want a pure DC signal, such as below:</p>\n<figure>\n<img src=\"http://www.learningaboutelectronics.com/images/Pure-DC-voltage.png\" alt=\"Pure DC Voltage\" /><figcaption aria-hidden=\"true\">Pure DC Voltage</figcaption>\n</figure>\n<p>Many times, we get a noisy signal that looks like:</p>\n<figure>\n<img src=\"http://www.learningaboutelectronics.com/images/Noisy-dc-signal.png\" alt=\"Noisy DC Voltage Signal\" /><figcaption aria-hidden=\"true\">Noisy DC Voltage Signal</figcaption>\n</figure>\n<p>A DC signal such as this is actually very common. This is undesired because it adds noise to the transistor circuit. Therefore, this noisy DC signal will be imposed on the AC signal. So the AC signal which may have music or some type of recording will now have much more noise.</p>\n<p>This noise which is on the signal is AC ripple. Many times when using a DC power supply connected to an AC power outlet, it will have some of the AC noise transfer to the DC power voltage. AC ripple can also appear from other sources, so even batteries can produce noise.</p>\n<p>To eliminate this AC ripple, we use a bypass capacitor. So our transistor circuit above will have a bypass capacitor added to it:</p>\n<figure>\n<img src=\"http://www.learningaboutelectronics.com/images/Bypass-capacitor-transistor-circuit.png\" alt=\"Bypass Capacitor for a Transistor Circuit\" /><figcaption aria-hidden=\"true\">Bypass Capacitor for a Transistor Circuit</figcaption>\n</figure>\n<p>A capacitor is a device that offers a tremendously high resistance for signals of low frequencies. Therefore, signals at low frequencies will not go through them. This is because signals (current) always takes the path of least resistance. Therefore, they will instead go through the resistor, RE. Remember, again, this is for low frequency signals, which is basically DC signals.</p>\n<p>However, capacitors offer much less resistance at higher frequencies (AC signals). So AC signals will go through the capacitor and then to gorund. Therefore, DC signals will go through the resistor, RE, while AC signals will go through the capacitor, getting shunted to ground. So AC signals get shunted to ground. This is how we have a clean DC signal across our circuit, while AC noise imposed on it is bypassed to ground.</p>\n<figure>\n<img src=\"http://www.learningaboutelectronics.com/images/How-a-bypass-capacitor-works.png\" alt=\"How a Bypass Capacitor Works\" /><figcaption aria-hidden=\"true\">How a Bypass Capacitor Works</figcaption>\n</figure>\n<p>So a bypass capacitor blocks the DC from entering it by the great resistance it offers to the signal but accepts the AC noise that may be on the DC line and shunts or bypasses it to ground. This is how bypass capacitors work.</p>\n<h1 id=\"how-to-choose-the-value-of-the-bypass-capacitor\">How to Choose the Value of the Bypass Capacitor</h1>\n<p>Now that you know conceptually what a bypass capacitor is, the next step is to know how to select the value of the bypass capacitor.</p>\n<p>And selecting the value is pretty straightforward.</p>\n<p>The value of the bypass capacitor should be at least 1/10th of the resistance across the emitter resistance, RE at the lowest frequency intended to be bypassed.</p>\n<p>Because capacitors are reactive devices, they have different resistances to signals based on the signal's frequency. This is referred to as the capacitor's reactance, which can be seen as the resistance it offers. We want the capacitor to have 1/10th of the resistance to the flow of current than what the resistor offers for the frequency signal that we want to bypass.</p>\n<p>If you visualize the current moving through the transistor, it can take one of 2 paths once it passes the collector and moves through the emitter. Current can either go the resistor, RE or current can flow through the bypass capacitor. Current always takes the path of least resistance. Therefore, current will take the path of the lower resistance. This is why you want the value of the resistance of the bypass capacitor to be at least 1/10th the value of the emitter resistor or, even better, less than one-tenth. We want the AC current to flow through the least resistance path, which is the bypass capacitor if the correct value is chosen.</p>\n<p>However, DC signals do not see it as AC. To DC, the capacitor has infinite resistance. So DC will automatically go through the RE resistor, which offers lower resistance by far to the infinite resistance of the capacitor.</p>\n<p>AC, however, does not see infinite resistance for the capacitor. If we choose the value correctly for the capacitor, we can make the capacitor a much lower-resistance path to ground, thus shorting out the AC signal to ground.</p>\n<p>So let's go over a practical example of how we would select the bypass capacitor value.</p>\n<p>Let's say we want to bypass the lowest possible frequency of 50Hz, because the frequency of AC voltages worldwide are 50-60Hz. Therefore, this frequency can be a very problematic because often there is AC ripple at this frequency.</p>\n<p>Remember, when we said we bias the value of the bypass capacitor based on the lowest frequency that we want to bypass. So by selecting the frequency of 50Hz, this blocks frequencies from 50Hz and higher; so it covers 60Hz. As frequency of an AC signal increases, the resistance of the capacitor decreases and decreases with each increase. Therefore, all the frequencies above the frequency value that we choose get bypassed easier and easier. We'll demonstrate this all mathematically.</p>\n<p>So we decided we want to bypass AC signals 50Hz or higher to ground.</p>\n<p>The typical value of an emitter resistor is 400-500‎Ω. The resistance is kept low so that gain on the transistor isn't lowered too much.</p>\n<p>So let's say we choose an emitter resistor of 470‎Ω.</p>\n<p>This means that we want the reactance of the capacitor to be one-tenth of 470‎Ω or less, which is 47‎Ω or lower. So this is our target.</p>\n<p>The formula for the reactance of a capacitor is, XC= 1/2πfc= 1/2(3.14)(50Hz)(C)=47Ω. Solving for the capacitance, C, we get the value of approximately 67μF. So we need a capacitor of at least 67μF to get a resistance of one-tenth the value of 470Ω resistor.</p>\n<p>Since a 67μF capacitor isn't readily available, we can round up to 100μF, which is readily available and easy to obtain. This is even better, because with a larger capacitance, the capacitor offers even less resistance to the AC signal. If we plug a 100μF capacitor into the same capacitor reactance formula, we get XC= 1/2πfc= 1/2(3.14)(50Hz)(100μF)=31.8Ω. This is much lower than 1/10 of the 470Ω resistor that we have in parallel. So it will act effectively to short all AC signals 50Hz or higher to ground to clean up the DC signal.</p>\n<p>Even if you wanted, you could increase the capacitance even more to allow for less AC noise on the signal. But a lot of times, this will not be done for cost and size constraints reasons. The larger the size a capacitor is, the more it costs per unit. Also the larger the size of a capacitor, the larger physically is. Therefore, if a company is designing a product, the size of the capacitor could be a problem if there are size constraint issues. The way things are going in electronics, companies want products to be as small and concise as possible. So due to reasons such as these, larger value capacitors won't always be chosen, but theoretically, they would increase the purity of the DC signal, by allowing more AC to ground.</p>\n<p>So again, this is a summary of what a bypass capacitor is and how to select the value of them based on the lowest AC signal desired to be filtered out and the value of the resistance in parallel with the capacitor.</p>\n<p>You can check out our <a href=\"http://www.learningaboutelectronics.com/Articles/Bypass-capacitor-calculator.php\">bypass capacitor calculator</a> to calculate the value of a bypass capacitor based on the input AC signal frequency and the value of the resistor in parallel.</p>\n<p>Related Resources</p>\n<p>​</p>\n","categories":["Signal"],"tags":["bypass","capacitor"]},{"title":"音频设备连接基础知识","url":"/2021/05/03/Signal/2021-05-03-%E9%9F%B3%E9%A2%91%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"<p>​</p>\n<p><a href=\"https://www.sohu.com/a/418986148_142772\">sohu.com</a></p>\n<h1 id=\"阻抗介绍\">阻抗介绍</h1>\n<p>仅针对音频系统中的电路进行说明</p>\n<ul>\n<li>在对电路施加电压时，电阻抗是 <strong>对电路中交流电的抵抗力的度量</strong>。</li>\n<li>阻抗以欧姆为单位（类似于电阻）测量，并且 <strong>可以认为是交流电路中的一种“交流电阻”</strong>。</li>\n<li>音频信号是交流电压，因为它们同时具有负电压和正电压（信号的正振幅和负振幅）。<strong>因此，音频信号是交流电</strong>（具有负电流和正电流）。</li>\n<li>仅当<strong>上级设备</strong>输出连接到前置放大器（或串联的下一个音频设备）时，音频信号才会通过。（上级设备的输出必须创建一个带有负载的电路，以使音频信号流动。）</li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/05/a0fcf0d70d88400289cafcd70441614e.png\" alt=\"img\" style=\"zoom:33%;\" /></p>\n<p>在音频系统的连接中，有各式各样的设备进行设备串联，首先说两个概念：</p>\n<blockquote>\n<p><strong>输出阻抗</strong>： 音频设备输出端上的固有阻抗。</p>\n<p><strong>负载阻抗</strong>： 音频设备下一级（通常是前置放大器）的输入阻抗，该阻抗与上级的输出共同构成电路。</p>\n</blockquote>\n<p>在音频行业内，行业规定 <mark>输入接口的阻抗应为输出阻抗的10倍以上，这样才能保证音频信号的传输质量</mark>。</p>\n<p><mark>这样的 “<strong>阻抗匹配</strong>” 其实是为了 “<strong>电压匹配</strong>” ，而不是传统电学概念中的输入输出等阻抗的“阻抗匹配”。</mark></p>\n<p>源输出阻抗和输入阻抗之间的电压传递公式：</p>\n<p><strong>V<sub>L</sub>= Z<sub>L</sub>·V<sub>S</sub> / (Z<sub>S</sub>+ Z<sub>L</sub>)</strong></p>\n<blockquote>\n<p>V<sub>L</sub>输入端 =前置放大器输入端的电压。</p>\n<p>V<sub>S</sub>输出端 =麦克风输出端的电压。</p>\n<p>Z<sub>L</sub>输入端 =前置放大器的输入阻抗（麦克风负载阻抗）。</p>\n<p>Z<sub>S</sub>输出端 =麦克风输出阻抗。</p>\n</blockquote>\n<p>可以将其可视化为简单的分压器：</p>\n<p><img src=\"https://pic.islet.space/2021/05/db9e3783f23c47a4b3529b34e2d8710a.png\" alt=\"img\" style=\"zoom: 33%;\" /></p>\n<div style=\"text-align: center; font-size: 10px; color: #aaa;\">\n图 简化电路\n</div>\n<p>不难推算，如果其他所有条件保持不变，增加负载阻抗“ Z输入端”可使上级设备的输出电压与前置放大器的输入电压之间的匹配度更高。</p>\n<p>Z输入端起码要达到Z输出端的10倍以上，电压才可达到源输出端电压的90%，但是我们也不希望输入端的阻抗过大，因为阻抗过高会增加线路出现噪音的可能。</p>\n<p>这种最大化的电压传输称为“阻抗桥接”，或者称为“电压匹配”。</p>\n<h1 id=\"音频信号\">音频信号</h1>\n<p>HOLA，在了解完阻抗的秘密之后，在这里我们简单说一下各个种类的信号等级和阻抗的差异。我们在这说下经常遇到的三类信号：<strong>麦克风信号</strong>、<strong>线路信号</strong>、<strong>乐器信号</strong>。</p>\n<div style=\"text-align: center; font-size: 10px; color: #aaa;\">\n表 各类信号参数表\n</div>\n<p><img src=\"https://pic.islet.space/2021/05/0a2b0b9619794c908f565d648a72eec6.png\" alt=\"img\" style=\"zoom:50%;\" /></p>\n<p><strong>麦克风信号</strong>，就是麦克风输出的信号，其电平大概在 <strong>-60dBV和-40dBV（0.001V - 0.010V)之间</strong>，通常需要前级放大器的放大才能正常使用，麦克风的<strong>输出阻抗通常在150Ω至200Ω之间</strong>。</p>\n<p>所以呢，你的声卡或者话放的Mic Input（麦克风输入）接口的阻值应至少该有1500Ω。</p>\n<p><img src=\"https://pic.islet.space/2021/05/d969f365edb84996b66525d18320fe3c.jpeg\" alt=\"img\" style=\"zoom:50%;\" /></p>\n<div style=\"text-align: center; font-size: 10px; color: #aaa;\">\n图 麦克风信号输入接口\n</div>\n<p><strong>线路信号</strong>也就是Line Level Signal，一般由TRS（大三芯）平衡线缆传递，比如一些播放器、效果器的输出信号都为线路信号，<strong>其电平约为0dBV（1V）</strong>，<strong>是麦克风信号电平的100倍-1000倍</strong>；<strong>其输出阻抗通常在100Ω至600Ω之间</strong>，Line Input（线路信号输入）接口的阻抗通常大于10,000Ω。有些音频接口有独立的Line Input，有的则是复合型。比如M-Audio Air192 | 4</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210503171654739.png\" alt=\"M-Audio  Air192|4\" style=\"zoom: 50%;\" /></p>\n<div style=\"text-align: center; font-size: 10px; color: #aaa;\">\n图 M-Audio Air192 | 4\n</div>\n<p><strong>乐器信号</strong> - Instrument Level Signal，乐器信号的电平位于麦克风信号和线路信号之间，通常以TS（大两芯）线缆传递，通常需要<strong>前级放大器</strong>将其提升到合适的<strong>线路电平等级</strong>；电吉他、电贝斯、带有拾音器的原声乐器输出的信号均为乐器信号，通常这些乐器的输出阻抗非常高，约在7,000Ω至15,000Ω甚至更高。因此你经常能看到话放、声卡的线路输入通道上有“Hi-Z(高阻抗）”或者“Line/Instrument”切换开关，能使线路输入接口的阻值增加，以适配乐器信号输入，有些音频接口则直接独立出来高阻乐器输入接口。乐器输入接口阻值通常在1MΩ（100万欧姆）左右。</p>\n<p>在前文说过，如果<strong>乐器输入接口阻值过低时，信号会失真、高频丢失，声音听起来会很沉闷</strong>；而<strong>阻值过高时，会增加线路出现噪音</strong>的可能。而有一类设备能完美的解决这一问题，让你随心所欲的调节满意的音色。比如：</p>\n<p>IK Multimedia的Z‑Tone系列产品可对这些变量进行控制，通过使用高质量的前置放大器，并配备可调的输入阻抗，以使各种拾音器都能发出其完美的声音。Z-Tone系列有两款相关产品，有体积较大的Z‑Tone DI和更紧凑的Z‑Tone Buffer Boost。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210503172016745.png\" alt=\"Z‑Tone Buffer Boost\" /><figcaption aria-hidden=\"true\">Z‑Tone Buffer Boost</figcaption>\n</figure>\n<div style=\"text-align: center; font-size: 10px; color: #aaa;\">\n图 Z‑Tone Buffer Boost\n</div>\n<h1 id=\"实际应用\">实际应用</h1>\n<p>如果<strong>将高阻抗输出输入到低阻抗麦克风电平输入中，它通常会使前置放大器过载</strong>。这将导致<strong>失真</strong>，甚至可能<strong>损坏前置放大器的电路</strong>！</p>\n<p>例如，如果你想将合成器、吉他等高阻信号插入调音台、音频接口的麦克风（XLR）输入，建议你使用<strong>DI盒转换</strong>，将高阻抗信号转换为低阻抗信号。</p>\n<p><img src=\"https://pic.islet.space/2021/05/c9178428f8ad4ecf8272344c07e24c02.jpeg\" alt=\"img\" style=\"zoom:50%;\" /></p>\n<div style=\"text-align: center; font-size: 10px; color: #aaa;\">\n图 使用Z-Tone DI录制箱琴\n</div>\n<p><strong>注意</strong>：最好将DI盒尽可能靠近高阻抗输出源，较长的走线应将转换后的低阻抗信号传送到调音台或声卡。通俗点说就是，连接时，两芯线短，卡农线长。这将有助于节省更多的音频信号高端频率。</p>\n<p>那么有的好奇的同学会问，低阻抗的输出接入高阻抗会怎样呢？按理论来说，低阻出，高阻入，很完美呀！但是…</p>\n<p>举个栗子🌰，我们的麦克风是低阻输出，你的吉他单块效果器是高阻输入，串联在一起是理想的选择，也有一些朋友想实现这样的操作，让声音变得更有意思。但是你直接拿XLR卡农转TS大两芯，从麦克风插到效果器上，这样是有问题的。</p>\n<p>问题在于，线路或乐器输入需要线路或乐器信号等级。线路和乐器信号的电压比麦克风信号高得多。</p>\n<p><strong>将低阻抗麦克风插入高阻抗乐器或线路输入会产生很低的电平信号。音频信号将接近接收端设备本底噪声，因此当你提升放大器的增益时也会产生更大噪声，这种不良的信噪比是很令人绝望的。</strong></p>\n<p>这时候你就需要Re-amp盒或者类似AXE I/O这种带有Re-amp功能的音频接口来实现你的这一想法。</p>\n<p><img src=\"https://pic.islet.space/2021/05/cb59d2afa93b469b91fe410bbc38df23.jpeg\" alt=\"img\" style=\"zoom:50%;\" /></p>\n<div style=\"text-align: center; font-size: 10px; color: #aaa;\">\n图 IK Multimedia AXE I/O\n</div>\n<p>​</p>\n","categories":["Signal"],"tags":["resistance","match","voltage"]},{"title":"使用ADAU1761 PGA、ALC 的DSP控制模式","url":"/2021/05/05/Signal/2021-05-05-%E4%BD%BF%E7%94%A8ADAU1761-PGA%E3%80%81ALC-%E7%9A%84DSP%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F/","content":"<h1 id=\"使用adau1761-pga-alc的dsp控制模式\">使用ADAU1761 PGA / ALC的DSP控制模式</h1>\n<p>ADAU1761模拟前端具有ALC（自动电平控制）功能，可根据输入信号的电平动态设置差分输入路径的增益。但是，可以绕过ALC，DSP程序可以直接控制应用于 <strong>差分输入</strong> 的增益量。</p>\n<p>为此，一个或两个通道的差分路径需要<strong>启用和取消静音</strong>。为了启用 <strong>差分路径</strong>，还应根据需要将<strong>LDBOOST</strong>（和/或<strong>RDBOOST</strong>）设置为0 dB或20 dB。</p>\n<p><a href=\"https://ez.analog.com/cfs-file/__key/communityserver-wikis-components-files/00-00-00-01-75/1e169c85b74a88a01485d3c18fecd396.jpg\"><img src=\"https://ez.analog.com/cfs-filesystemfile/__key/communityserver-components-secureimagefileviewer/communityserver-wikis-components-files-00-00-00-01-75/1e169c85b74a88a01485d3c18fecd396.jpg_2D00_373x238.jpg?_=636716033579270573\" alt=\"img\" /></a></p>\n<p>然后，<strong>应将ALCSEL</strong>位设置为<strong>DSP控制</strong>模式。</p>\n<p><a href=\"https://ez.analog.com/cfs-file/__key/communityserver-wikis-components-files/00-00-00-01-75/be2493be5fd62ceb941ade31bb1c2ea2.jpg\"><img src=\"https://ez.analog.com/cfs-filesystemfile/__key/communityserver-components-secureimagefileviewer/communityserver-wikis-components-files-00-00-00-01-75/be2493be5fd62ceb941ade31bb1c2ea2.jpg_2D00_136x228.jpg?_=636716033581410640\" alt=\"img\" /></a></p>\n<p>现在，在DSP程序原理图中，用户可以将<strong>AIGC输出</strong>单元添加到项目中：</p>\n<p><a href=\"https://ez.analog.com/cfs-file/__key/communityserver-wikis-components-files/00-00-00-01-75/a6abc0254ac0020e47fd1b347f706504.jpg\"><img src=\"https://ez.analog.com/cfs-filesystemfile/__key/communityserver-components-secureimagefileviewer/communityserver-wikis-components-files-00-00-00-01-75/a6abc0254ac0020e47fd1b347f706504.jpg_2D00_215x49.jpg?_=636716033575290474\" alt=\"img\" /></a></p>\n<p>通道0映射到左侧的PGA。</p>\n<p><a href=\"https://ez.analog.com/cfs-file/__key/communityserver-wikis-components-files/00-00-00-01-75/524d0fbf699c770a6e85e142dd636b3b.png\"><img src=\"https://ez.analog.com/cfs-filesystemfile/__key/communityserver-components-secureimagefileviewer/communityserver-wikis-components-files-00-00-00-01-75/524d0fbf699c770a6e85e142dd636b3b.png_2D00_91x54.png?_=636716033578360546\" alt=\"img\" /></a></p>\n<p>通道1映射到右侧的PGA。</p>\n<p><a href=\"https://ez.analog.com/cfs-file/__key/communityserver-wikis-components-files/00-00-00-01-75/3a9410be5a75f96f99e4087743e69d2f.jpg\"><img src=\"https://ez.analog.com/cfs-filesystemfile/__key/communityserver-components-secureimagefileviewer/communityserver-wikis-components-files-00-00-00-01-75/3a9410be5a75f96f99e4087743e69d2f.jpg_2D00_94x57.jpg?_=636716033575450467\" alt=\"img\" /></a></p>\n<p>现在，馈送到这些单元中每个单元的5.23信号确定了相应PGA的增益。</p>\n<p>作为一个简单的示例，要将每个PGA的增益设置为0.5（或-6 dB），请从<strong>Sources</strong>库创建一个<strong>DC Input Entry</strong>单元并将其设置为0.5，然后将其连接到<strong>AIGC输出</strong>。</p>\n<p><a href=\"https://ez.analog.com/cfs-file/__key/communityserver-wikis-components-files/00-00-00-01-75/462b7691a9c4c01ab55c2f09825bd18e.jpg\"><img src=\"https://ez.analog.com/cfs-filesystemfile/__key/communityserver-components-secureimagefileviewer/communityserver-wikis-components-files-00-00-00-01-75/462b7691a9c4c01ab55c2f09825bd18e.jpg_2D00_208x103.jpg?_=636716033578360546\" alt=\"img\" /></a></p>\n<p>在下一个示例中，使用“<strong>乘”</strong>和“<strong>加”</strong>单元缩放并移动10 Hz的<strong>正弦音调</strong>，使其范围在0到1之间，然后将其发送到<strong>AIGC输出</strong>单元。这会导致PGA增益在0 dB和静音之间快速来回移动，从而产生颤音效果。</p>\n<p><a href=\"https://ez.analog.com/cfs-file/__key/communityserver-wikis-components-files/00-00-00-01-75/8f391a0c6d528ce961e9f54617503cd9.jpg\"><img src=\"https://ez.analog.com/cfs-filesystemfile/__key/communityserver-components-secureimagefileviewer/communityserver-wikis-components-files-00-00-00-01-75/8f391a0c6d528ce961e9f54617503cd9.jpg_2D00_349x178.jpg?_=636716033575530468\" alt=\"img\" /></a></p>\n<p>在下面的示例中，每个输入的峰值电平由“<strong>峰值包络”</strong>单元检测，并且使用“<strong>除法”</strong>单元和“ <strong>DC输入条目”</strong>单元创建该信号的反相。结果发送到<strong>AIGC输出</strong>单元。这意味着输入峰值电平的倒数用于缩放PGA增益。结果是，当输入信号为低电平时，增益较高；但是，当输入电平增加时，增益将降低以避免削波。</p>\n<p><a href=\"https://ez.analog.com/cfs-file/__key/communityserver-wikis-components-files/00-00-00-01-75/d24015ce9b3e9d247f8a8fb1e43943a3.jpg\"><img src=\"https://ez.analog.com/cfs-filesystemfile/__key/communityserver-components-secureimagefileviewer/communityserver-wikis-components-files-00-00-00-01-75/d24015ce9b3e9d247f8a8fb1e43943a3.jpg_2D00_400x379.jpg?_=636716033578810577\" alt=\"img\" /></a></p>\n<p>这些只是在ADAU1761的PGA上使用DSP控制模式可以完成的操作的几个示例。</p>\n","categories":["Signal"],"tags":["ADI","PGA","ALC","ADAU","1761"]},{"title":"分贝","url":"/2021/05/05/Signal/2021-05-05-%E5%88%86%E8%B4%9D/","content":"<p><a href=\"https://zh.wikipedia.org/wiki/%E5%88%86%E8%B2%9D\">Wikipedia</a></p>\n<h1 id=\"分貝\">分貝</h1>\n<p><strong>分贝</strong>（decibel）是量度两个相同单位之数量<a href=\"https://zh.wikipedia.org/wiki/比例\">比例</a>的单位，常用<strong>dB</strong>表示。“<a href=\"https://zh.wikipedia.org/wiki/分\">分</a>”（deci-）指十分之一，个位是“贝”或“贝尔”（bel，纪念发明家<a href=\"https://zh.wikipedia.org/wiki/亚历山大·格拉汉姆·贝尔\">亚历山大·格拉汉姆·贝尔</a>），但一般只用分贝。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>dB</th>\n<th>声能比</th>\n<th>声压比</th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>100</td>\n<td>10 000 000 000</td>\n<td></td>\n<td>100 000</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>90</td>\n<td>1 000 000 000</td>\n<td></td>\n<td>31 623</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>80</td>\n<td>100 000 000</td>\n<td></td>\n<td>10 000</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>70</td>\n<td>10 000 000</td>\n<td></td>\n<td>3 162</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>60</td>\n<td>1 000 000</td>\n<td></td>\n<td>1 000</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>50</td>\n<td>100 000</td>\n<td></td>\n<td>316</td>\n<td>.2</td>\n</tr>\n<tr class=\"odd\">\n<td>40</td>\n<td>10 000</td>\n<td></td>\n<td>100</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>30</td>\n<td>1 000</td>\n<td></td>\n<td>31</td>\n<td>.62</td>\n</tr>\n<tr class=\"odd\">\n<td>20</td>\n<td>100</td>\n<td></td>\n<td>10</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>10</td>\n<td>10</td>\n<td></td>\n<td>3</td>\n<td>.162</td>\n</tr>\n<tr class=\"odd\">\n<td>6</td>\n<td>3</td>\n<td>.981（≈4）</td>\n<td>1</td>\n<td>.995（≈2）</td>\n</tr>\n<tr class=\"even\">\n<td>3</td>\n<td>1</td>\n<td>.995（≈2）</td>\n<td>1</td>\n<td>.413（≈√2）</td>\n</tr>\n<tr class=\"odd\">\n<td>1</td>\n<td>1</td>\n<td>.259</td>\n<td>1</td>\n<td>.122</td>\n</tr>\n<tr class=\"even\">\n<td>0</td>\n<td>1</td>\n<td></td>\n<td>1</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>-3</td>\n<td>0</td>\n<td>.501（≈½）</td>\n<td>0</td>\n<td>.708（≈√½）</td>\n</tr>\n<tr class=\"even\">\n<td>-6</td>\n<td>0</td>\n<td>.251（≈¼）</td>\n<td>0</td>\n<td>.501（≈½）</td>\n</tr>\n<tr class=\"odd\">\n<td>-10</td>\n<td>0</td>\n<td>.1</td>\n<td>0</td>\n<td>.316 2</td>\n</tr>\n<tr class=\"even\">\n<td>-20</td>\n<td>0</td>\n<td>.01</td>\n<td>0</td>\n<td>.1</td>\n</tr>\n<tr class=\"odd\">\n<td>-30</td>\n<td>0</td>\n<td>.001</td>\n<td>0</td>\n<td>.031 62</td>\n</tr>\n<tr class=\"even\">\n<td>-40</td>\n<td>0</td>\n<td>.000 1</td>\n<td>0</td>\n<td>.01</td>\n</tr>\n<tr class=\"odd\">\n<td>-50</td>\n<td>0</td>\n<td>.000 01</td>\n<td>0</td>\n<td>.003 162</td>\n</tr>\n<tr class=\"even\">\n<td>-60</td>\n<td>0</td>\n<td>.000 001</td>\n<td>0</td>\n<td>.001</td>\n</tr>\n<tr class=\"odd\">\n<td>-70</td>\n<td>0</td>\n<td>.000 000 1</td>\n<td>0</td>\n<td>.000 316 2</td>\n</tr>\n<tr class=\"even\">\n<td>-80</td>\n<td>0</td>\n<td>.000 000 01</td>\n<td>0</td>\n<td>.000 1</td>\n</tr>\n<tr class=\"odd\">\n<td>-90</td>\n<td>0</td>\n<td>.000 000 001</td>\n<td>0</td>\n<td>.000 031 62</td>\n</tr>\n<tr class=\"even\">\n<td>-100</td>\n<td>0</td>\n<td>.000 000 000 1</td>\n<td>0</td>\n<td>.000 01</td>\n</tr>\n</tbody>\n</table>\n<p>这是一个说明声源能量 (<img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4\" alt=\"x\" />), 声压 (<img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/d62b24be305beff66cba9bfbcc01a362ba390f44\" alt=\"{}\" />)，与声音分贝数 dB (![{_{10}{x}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/be2b0b75f65fbc06b19e6e8548ce8ec33b0c0c4f)) 正比关系的对照表 从声音分贝数 dB 只有 2~3 个数字的差异，相比声源或声压 9~10 个数字的差异，dB可<strong>帮助人们更快的理解数字代表的意义</strong>。</p>\n<h2 id=\"计算方法\">计算方法</h2>\n<p>分贝（dB）是十分之一贝尔（B）：<code>1B = 10dB</code>。1贝尔的两个功率量的比值是10:1，1贝尔的两个场量的比值是<img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/2f35055a56f97ce282bf4797deddb716cfa8a924\" alt=\"{}:1\" />[<a href=\"about:reader?url=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E5%88%86%E8%B2%9D#cite_note-1\">1]</a>。'</p>\n<p>场量（field quantity）是诸如<a href=\"https://zh.wikipedia.org/wiki/电压\">电压</a>、<a href=\"https://zh.wikipedia.org/wiki/电流\">电流</a>、<a href=\"https://zh.wikipedia.org/wiki/声压\">声压</a>、<a href=\"https://zh.wikipedia.org/wiki/电场强度\">电场强度</a>、<a href=\"https://zh.wikipedia.org/wiki/速度\">速度</a>、<a href=\"https://zh.wikipedia.org/wiki/電荷密度\">电荷密度</a>等量值，其平方值在一个线性系统中与功率成比例。功率量（power quantity）是功率值或者直接与功率值成比例的其它量，如<a href=\"https://zh.wikipedia.org/wiki/能量密度\">能量密度</a>、<a href=\"https://zh.wikipedia.org/wiki/音强\">音强</a>、<a href=\"https://zh.wikipedia.org/wiki/发光强度\">发光强度</a>等。</p>\n<p>分贝的计算，依赖于是 <strong>功率量</strong> 还是 <strong>场量</strong> 而不同。</p>\n<p>两个信号具有1分贝的差异，那么其功率比值是1.25892（即<img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/99d92002d56747705f253a7c0aac2c7e4c310f20\" alt=\"10^{},\" />）而幅值之比是1.12202（即<img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/a515a9617441696adc7fb0f3a2cd1f74210cee64\" alt=\"{}^{},\" />）[<a href=\"about:reader?url=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E5%88%86%E8%B2%9D#cite_note-2\">2]</a>。</p>\n<h2 id=\"好处\">好处</h2>\n<p>使用分贝有很多便利之处：</p>\n<ul>\n<li>分贝实际上是对数值，因此可以用常用的数量来表示非常大的比值，可以清楚地表示非常大的数量变化。</li>\n<li>多部件系统的整体增益（如级联的<a href=\"https://zh.wikipedia.org/wiki/放大器\">放大器</a>）可以直接用各部件的增益分贝相加而求得。不必把这些增益值相乘（例如log(A × B × C) = log(A) + log(B) + log(C)）。</li>\n<li>人对强度的感知，如声音或者光照，更接近与强度的对数成正比而不是强度值本身，依据<a href=\"https://zh.wikipedia.org/wiki/韋伯定理\">韦伯定理</a>，因此分贝值可用于描述感知级别或级差。</li>\n</ul>\n<h2 id=\"使用\">使用</h2>\n<h3 id=\"声学\">声学</h3>\n<p>声学中，<a href=\"https://zh.wikipedia.org/wiki/声强\">声音的强度</a>定义为声压。计算分贝值时采用20微帕斯卡为参考值[<a href=\"about:reader?url=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E5%88%86%E8%B2%9D#cite_note-ElectronicEngineersHandbook-5\">5]</a>。这一参考值是人类对声音能够感知的阈值下限。声压是场量，因此使用声压计算分贝时使用下述版本的公式：</p>\n<figure>\n<img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/3994b439a75418d133c3c75063bdea671f5f16ae\" alt=\"声音强度公式\" /><figcaption aria-hidden=\"true\">声音强度公式</figcaption>\n</figure>\n<p>在空气中 <strong>1帕斯卡等于94分贝声压级</strong>。在其他介质，如水下，1微帕斯卡更为普遍[<a href=\"about:reader?url=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E5%88%86%E8%B2%9D#cite_note-Morfey-6\">6]</a>。这些标准被<a href=\"https://zh.wikipedia.org/wiki/ANSI\">ANSI</a>S1.1-1994.所收录[<a href=\"about:reader?url=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E5%88%86%E8%B2%9D#cite_note-7\">7]</a>。</p>\n<p>人耳对声音感知具有很大的<a href=\"https://zh.wikipedia.org/wiki/动态范围\">动态范围</a>。从短期暴露即会永久损害听力的声强到最静的人耳能听到的声强，其比值是1万亿（10<sup>12</sup>）。[<a href=\"about:reader?url=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E5%88%86%E8%B2%9D#cite_note-8\">8]</a>这么大的比值范围表示为对数度量：1万亿（10<sup>12</sup>）基于10的对数为12，用分贝表示是240。人的听力并不是对所有频率都是相同敏感，最敏感的频率范围是20<a href=\"https://zh.wikipedia.org/wiki/赫兹\">Hz</a>~20<a href=\"https://zh.wikipedia.org/wiki/千赫兹\">kHz</a>.</p>\n<p>当一个空间受外来声音干扰，而影响预期的正常作息时，需要建置一个六面结构的宁静空间，而当宁静空间建置完成后，能否达到预期的效果，则于施工前制定一个规范，此规范即为声学规范。</p>\n<h3 id=\"电子学\">电子学</h3>\n<p>电子学中，通常用分贝表示功率或幅值之比（<a href=\"https://zh.wikipedia.org/wiki/增益\">增益</a>），而不常用算术比或者百分比。一项好处是一些列部件组成的系统的总增益是各部件增益之和。类似的，电信领域中，从一个发射器到一个接收器通过一些媒介（<a href=\"https://zh.wikipedia.org/w/index.php?title=光无线通信&amp;action=edit&amp;redlink=1\">光无线通信</a>、<a href=\"https://zh.wikipedia.org/wiki/波导\">波导</a>、<a href=\"https://zh.wikipedia.org/wiki/同轴电缆\">同轴电缆</a>、<a href=\"https://zh.wikipedia.org/wiki/光纤\">光纤</a>等等）的信号增益用分贝表示，用于<a href=\"https://zh.wikipedia.org/wiki/链路预算\">链路预算</a>。</p>\n<p>分贝也可以组合一些后缀，表示电功率的绝对单位。例如，后缀\"m\"表示\"毫瓦\"组合出\"dBm\"，0 dBm等于1毫瓦，1 dBm约为1.259 毫瓦。</p>\n<p>在专业声学领域，常用单位是dBu。\"u\"代表\"unloaded\"。dBu是电压的<a href=\"https://zh.wikipedia.org/wiki/平方平均数\">平方平均数</a>（RMS）度量的单位，其参考电压约为 0.775 VRMS。由于历史原因，此参考电压是在600欧姆电阻上耗散1 mW功率的电压，用于电话音频电路的标准阻抗。</p>\n<h2 id=\"后缀与参考值\">后缀与参考值</h2>\n<p>dB与后缀的组合，指出计算比值时的参考值。例如dBm指示功率值与1毫瓦的比值的分贝数。</p>\n<p>如果计算分贝时的参考值明确、确切地给出，那么分贝数值可以作为绝对量，如同被测量的功率量或者场量。例如，20dBm即为100毫瓦。</p>\n<p>SI国际单位制不允许使用分贝与后缀的组合形式如dBm, dBu, dBA，等等[<a href=\"about:reader?url=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E5%88%86%E8%B2%9D#cite_note-13\">13]</a>。但这种不遵从SI单位制的表示却广泛应用于很多场合。</p>\n","categories":["Signal"],"tags":["decibel","bel","sound","noise"]},{"title":"模数接口中的可编程增益放大器（PGA）","url":"/2021/05/05/Signal/2021-05-05-%E6%A8%A1%E6%95%B0%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%8F%AF%E7%BC%96%E7%A8%8B%E5%A2%9E%E7%9B%8A%E6%94%BE%E5%A4%A7%E5%99%A8%EF%BC%88PGA%EF%BC%89/","content":"<p>原文出处：https://www.21ic.com/app/analog/201207/134812.htm</p>\n<p>用可编程增益放大器(PGA)处理数据采集系统中传感器/变送器模拟输出和信号处理数字之间的接口。单片和高集成度PGA现在被可编程、更高精度、更高吞吐量和更小封装尺寸的模块和混合方案替代。</p>\n<p>由于来自传感器/变送器的模拟信号的本性，使其工作必须具备相当大的动态范围。这要求采用连续增益级在进行任何实际的数字处理之前增大这些信号，PGA能满足这种要求。</p>\n<p>PGA是可变增益放大器(VGA)的一种。VGA提供可变和连续增益控制，而PGA <mark>必须在软件控制下以固定步(通常6dB步)做到可变增益控制</mark>。达到更精细的分辨步0.5dB是可能的。 一般多通道数据采集系统用很多不同类型的传感器/变送器，这包括 <strong>热电偶</strong>、<strong>惠斯登电桥</strong>，<strong>热敏电阻</strong>、<strong>应变计</strong> 和 <strong>超声系统</strong>。虽然，传感器/变送器是基于不同的物理原理，但大多数产品是 <strong>以电压做为输出</strong>。甚至这会产生中间值(如电容或电阻)，但最终变换为电压，以便在数据采集系统中进行</p>\n<p><img src=\"http://pic.islet.space/2021/04/fb222bc5a544088d5a7fc0c708476621.jpg\" /></p>\n<p>传感器/变送器的输出可覆盖非常大的范围，需要PGA来处理传感器/变送器输出到ADC的接口。</p>\n<blockquote>\n<p>例如，在工业过程控制系统中，低频信号可以几毫伏到几伏变化。需要PGA来匹配这种宽传感器/变送器输出范围到特定的ADC输入范围。通常，在输入数据采集通道最低信号电平与最高信号电平之比是2个量级或更大。 12位ADC接收小于ADC满标输入十分之一的信号仅可提供8位分辨率，除非在信号到达ADC之前用PGA放大。PGA允许在软件控制下使接收信号的增益达到宽范围增益一带宽乘积。这可避免钳位并允许采用较便宜的ADC，如用12位ADC替代16位ADC。</p>\n</blockquote>\n<p>PGA可做更多事情。PGA缓冲来自前级(通常是多路转换器)ADC的输入，防止多路转换器导通电阻所引起的加载。PGA也提供差分别单端的变换，大多数跟踪和保持型ADC需要单输入。把PGA连接到差分多路转换器输出时，PGA提供共模抑制。</p>\n<p>在市场上可以得到很多种PGA和支持元件。这包括可独立应用的运放被专门设计成PGA、ASIC、集成有可编程滤波器的PGA、仪表放大器PGA、用于运放的数字电位器前端、PGA用数字可编程分压器、ADC驱动器。有时把PGA和DAC集成在同一芯片上。</p>\n<p>对于不需要信号宽动态范围的应用，PGA不是必须的。放大器可以直接接口传感器/变送器到ADC。</p>\n<blockquote>\n<p>例如，Maxim的MAX1494仪表放大器适合于250V/V或更小增益范围的应用。</p>\n</blockquote>\n<h1 id=\"各种性能的pga\">各种性能的PGA</h1>\n<p>对于特殊性能参量(如高增益稳定性和高精度，低漂移，低失真，高输出驱动电流，高转换率，快速建立时间，高共模抑制比，低功率和小尺寸)有很多PGA是最佳的。</p>\n<blockquote>\n<ul>\n<li>Microchip公司的MCP6S2X家族PGA具有2、6和8通道输入，包含多路转换器并可通过串行外设接口(SPI)总线进行增益控制和通道选择。</li>\n<li>NS公司的LMH6718IC是双PGA，具有高输出(200mA)驱动信号。<br />\n</li>\n<li>高性能小封装的PAG有ADI公司的AD8555，这是封装在微型8引线SOIC中的数字可编程信号调理自动零放大器，它包含放大器，比较器，用Digit Trim技术的电阻调节分压器和缓冲器。其500V/℃总输入失调漂移是其他竞争产品的1/20。</li>\n<li>Linear公司的LTC6915A也是小封装高性能PGA。此仪表放大器封装为16引线SSOP或12引线DFN，可把它放置在最靠近传感器/变送器的地方。它所占电路板面积是等效分立方案的1/6。零漂移特性具有高达4096的宽可编程动态范围(增益精度0.1%)。它也有50mV/℃漂移和与增益无关的125dB CMRR。<br />\n</li>\n<li>对于低失真是主要考虑因素的应用，可以选择Intersil公司PGA缓冲器HFA11XX，其低失真电平低到-73dBc、噪声电平低到7\"9nV/√Hz。</li>\n<li>TI公司的THS7001/7002单/双PGA采用Power PAD封装，包含分离的低噪声前置放大器和增益放大级。此器件可达到非常低的噪声电平(低到1.7nV/√Hz)。</li>\n<li>其他可注意的PGA包括ADI公司的AD628首款具有可编程增益的共模差分放大器和Linear公司的LTC1564 PGA(除放大器外，它还具有8阶软件可编程抗混淆滤波器)。</li>\n</ul>\n</blockquote>\n<p>PGA也集成有其他前端电路。</p>\n<blockquote>\n<p>如Maxim公司的MAX14XX家族，这是包含PGA的信号调理ASIC。这种器件直接用于传感器/变送器和ADC之间。</p>\n<p>Maxim公司的ADC驱动器MAX2055具有低失真(-76dBc 2次谐波和-69dBc 3次谐波)特性，其差分输出是为驱动高速ADC专门设计的。</p>\n</blockquote>\n<p>一些PGA供应商也提供驱动PGA前端的数字电位计和分压器IC。</p>\n<blockquote>\n<p>例如，Maxim公司的MAX5420/21数字可编程电压分压器；</p>\n<p>ADI公司的AD5321数字电位计(常用于可编程增益和衰减的非易失性存储器)。</p>\n<p>另外，Xicor也提供不少PGA器件，这些PGA器件对于执行数字控制的电位计(DCP)是最佳的。</p>\n</blockquote>\n<h1 id=\"集成方案\">集成方案</h1>\n<p>现在，很多公司把PGA和其他信号调理电路直接集成在ADC芯片上。这种方法有利于所占空间更小，比分离PGA和ADC方案具有更好的性能。然而，其成本比较高，集成PGA在ADC上除灵活性较低外，还有 <mark>较高的时钟噪声电平</mark>。</p>\n<blockquote>\n<p>带线化前端的Maxim公司的MAX1457(图2)传统器线性化IC就是其中一种，它包含12位ADC。</p>\n<p>ADI公司的ADC7707高精度信号调理16位S-D ADC包含多路转换器、缓冲器、PGA、电荷平衡电路、串行接口和时钟产生器。</p>\n<p>ADI公司的ADC7708/18S-D6位/24位ADC具有与AD7707相同的电路，但它们的目标是低电压和低功率应用。</p>\n</blockquote>\n<figure>\n<img src=\"http://pic.islet.space/2021/04/8b55f596bcfdf9a408bd3c959504fb21.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>一个感兴趣的高集成度ADC是ADC7731 24位S-D器件，它具有ADC77017的所有电路。另外，还加上定标微控制器(图3)。此IC的目标是低噪声高吞吐量应用。</p>\n<p>Maxim公司也有带集成PGA的双6位ADC，它具有90Sample/s吞吐率、功耗仅550mW。</p>\n<p><img src=\"http://pic.islet.space/2021/04/8CzZ7BjS2OMEYQJ.jpg\" /></p>\n<p>我们将会看到更多包含PGA和其他信号处理电路的ADC吗？</p>\n<p>不可回避的事实是高集成度是IC业的准则，而PGA和其他信号调理支持电路也不例外。所以希望看到PGA与ADC集成在同一芯片，并能解决片上性能参量(如时钟引起的噪声)和降低高分辨率器件的单个ADC价格。</p>\n<p>事实上，设计人员主要的目标是把传感器/变送器电路放在高集成度ADC上。</p>\n<p>这将是最终解决问题：现实世界模拟信号与计算机的数字世界结合起来的途经。</p>\n<p>这也将聚焦在模拟和数字电路设计的两种不同方法。</p>\n","categories":["Signal"],"tags":["PGA","forwarding"]},{"title":"晶振、滤波器、运放、增益与音量","url":"/2021/05/06/Signal/2021-05-06-%E6%BB%A4%E6%B3%A2%E5%99%A8%E3%80%81%E5%A2%9E%E7%9B%8A%E5%92%8C%E9%9F%B3%E9%87%8F/","content":"<h1 id=\"晶振\">晶振</h1>\n<iframe src=\"//player.bilibili.com/player.html?aid=375201195&amp;bvid=BV1Do4y1f7zZ&amp;cid=326338193&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\">\n</iframe>\n<iframe src=\"//player.bilibili.com/player.html?aid=541620530&amp;bvid=BV1qi4y1u7Ha&amp;cid=218806392&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\">\n</iframe>\n<h1 id=\"滤波器\">滤波器</h1>\n<p><strong>自百度百科</strong>：</p>\n<p>滤波器是由 <strong>电容</strong>、<strong>电感</strong>和<strong>电阻</strong> 组成的滤波电路。滤波器可以 <strong>对 </strong>电源线中<strong>特定频率的频点</strong> <strong>或</strong> 该频点 <strong>以外的频率</strong> 进行有效滤除，得到一个特定频率的电源信号，或消除一个特定频率后的电源信号。</p>\n<p><strong>自Bilibili视频</strong>：</p>\n<p>滤波器是具有频率选择作用的 <strong>电路</strong> 或 <strong>运算处理系统</strong>， 具有 <strong>滤除噪声</strong> 和 <strong>分离各种不同信号</strong> 的功能。</p>\n<p>即滤波器有模拟滤波器和数字滤波器两类，模拟滤波器主要依靠电路实现滤波，数字滤波器依靠运算处理系统进行滤波。滤波主要是为了滤除噪声或者分离不同信号。</p>\n<iframe src=\"//player.bilibili.com/player.html?aid=925644966&amp;bvid=BV1nT4y1u7LL&amp;cid=192193457&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\">\n</iframe>\n<p><strong>自Wikipedia</strong>：</p>\n<p>电子滤波器（英语：electronic filters）可执行信号处理功能的电子线路组件或设备，它专门用于去除信号中不想要的成分或者增强所需成分。</p>\n<p>电子滤波器有音频滤波器（wave filter）与噪声滤波器（noise filter）等应用设备，可以是： - 无源的或者有源的 - 模拟的或者数字的 - 离散时间（采样）的或者连续时间的 - 线性的或者非线性的 - 无限脉冲响应（IIR）或者有限脉冲响应（FIR）</p>\n<h2 id=\"简介\">简介</h2>\n<p><strong>自百度百科</strong>：</p>\n<p>滤波器是一种选频装置，可以使信号中特定的频率成分通过，而极大地衰减其他频率成分。利用滤波器的这种选频作用，可以滤除干扰噪声或进行频谱分析。换句话说，凡是可以使信号中特定的频率成分通过，而极大地衰减或抑制其他频率成分的装置或系统都称之为滤波器。滤波器，是对波进行过滤的器件。“波”是一个非常广泛的物理概念，在电子技术领域，“波”被狭义地局限于特指描述各种物理量的取值随时间起伏变化的过程。该过程通过各类传感器的作用，被转换为电压或电流的时间函数，称之为各种物理量的时间波形，或者称之为信号。因为自变量时间是连续取值的，所以称之为<strong>连续时间信号</strong>，又习惯地称之为模拟信号(Analog Signal)。</p>\n<p>滤波是信号处理中的一个重要概念，在<a href=\"https://baike.baidu.com/item/直流稳压电源/327901\">直流稳压电源</a>中滤波电路的作用是尽可能减小脉动的直流电压中的<a href=\"https://baike.baidu.com/item/交流/2700357\">交流</a>成分，保留其直流成分，使输出电压纹波系数降低，波形变得比较平滑。</p>\n<p><img src=\"https://pic.islet.space/2021/05/fc1f4134970a304e3fbc1b7edfc8a786c8175c93\" alt=\"滤波\" style=\"zoom:50%;\" /></p>\n<h2 id=\"主要参数\">主要参数</h2>\n<p><strong>品质因数</strong></p>\n<p>仅针对2阶滤波器有效，对1阶和3阶滤波器无效。</p>\n<iframe src=\"//player.bilibili.com/player.html?aid=19074169&amp;bvid=BV1rW411H7qv&amp;cid=31115293&amp;page=3\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\">\n</iframe>\n<p><strong>中心频率</strong>（Center Frequency）</p>\n<blockquote>\n<p>滤波器通带的频率f0，一般取 f0=（f<sub>1</sub>+f<sub>2</sub>）/2，f<sub>1</sub>、f<sub>2</sub>为带通或带阻滤波器左、右相对下降1dB或3dB边频点。窄带滤波器常以插损最小点为中心频率计算通带带宽。</p>\n</blockquote>\n<p><strong>截止频率</strong>（Cutoff Frequency）</p>\n<blockquote>\n<p>指低通滤波器的通带右边频点及高通滤波器的通带左边频点。通常以1dB或3dB <strong>相对损耗点</strong> 来标准定义。</p>\n<p><strong>相对损耗的参考基准为：</strong>低通以DC处插损为基准，高通则以未出现 <strong>寄生阻带</strong> 的足够高通带频率处插损为基准。</p>\n</blockquote>\n<p><strong>通带带宽</strong></p>\n<blockquote>\n<p>指需要通过的频谱宽度，BW=（f2-f1）。f<sub>1</sub>、f<sub>2</sub>为以中心频率f<sub>0</sub>处插入损耗为基准。</p>\n</blockquote>\n<p><strong>插入损耗</strong>（Insertion Loss）</p>\n<blockquote>\n<p>由于滤波器的引入对电路中原有信号带来的衰耗，以中心或截止频率处损耗表征，如要求 <mark>全带内插损需强调</mark>。</p>\n</blockquote>\n<p><strong>纹波</strong>（Ripple）</p>\n<blockquote>\n<p>指1dB或3dB带宽（截止频率）范围内，插损随频率在损耗均值曲线基础上波动的峰值。</p>\n</blockquote>\n<p><strong>带内波动</strong>（Passband Ripple）</p>\n<blockquote>\n<p>通带内插入损耗随频率的变化量。1dB带宽内的带内波动是1dB。</p>\n</blockquote>\n<p><strong>带内驻波比</strong>（VSWR）</p>\n<blockquote>\n<p>衡量滤波器通带内信号是否良好匹配传输的一项重要指标。理想匹配VSWR=1：1，失配时VSWR 大于1。对于一个实际的滤波器而言，满足VSWR小于1.5：1的带宽一般小于BW3dB，其占BW3dB的比例与滤波器阶数和插损相关。</p>\n</blockquote>\n<p><strong>回波损耗</strong>（Return Loss）</p>\n<blockquote>\n<p>端口信号输入功率与反射功率之比的分贝（dB）数，也等于20Log10ρ，ρ为电压反射系数。输入功率被端口全部吸收时回波损耗为无穷大。</p>\n</blockquote>\n<p><strong>阻带抑制度</strong></p>\n<blockquote>\n<p>衡量滤波器选择性能好坏的重要指标。该指标越高说明对带外干扰信号抑制的越好。通常有两种提法：一种为要求对某一给定带外频率fs抑制多少dB，计算方法为fs处衰减量；另一种为提出表征滤波器幅频响应与理想矩形接近程度的指标——矩形系数（KxdB大于1），KxdB=BWxdB/BW3dB，（X可为40dB、30dB、20dB等）。滤波器阶数越多矩形度越高——即K越接近理想值1，制作难度当然也就越大。</p>\n</blockquote>\n<p><strong>延迟</strong>（Td）</p>\n<blockquote>\n<p>指信号通过滤波器所需要的时间，数值上为传输相位函数对角频率的导数，即Td=df/dv。</p>\n</blockquote>\n<p><strong>带内相位线性度</strong></p>\n<blockquote>\n<p>该指标表征滤波器对通带内传输信号引入的相位失真大小。按线性相位响应函数设计的滤波器具有良好的相位线性度。</p>\n</blockquote>\n<h2 id=\"主要分类\">主要分类</h2>\n<ul>\n<li><p>按所处理的信号分为 <strong>模拟滤波器</strong> 和 <strong>数字滤波器</strong> 两种。</p>\n<ul>\n<li>模拟滤波器在实时性方面较有优势，且发展较早，更为成熟。</li>\n<li>数字滤波器依赖于计算速度。</li>\n</ul></li>\n<li><p>按所通过信号的频段分为 <strong>低通</strong>、<strong>高通</strong>、<strong>带通</strong>、<strong>带阻</strong> 和 <strong>全通</strong> 滤波器五种。</p>\n<p><strong>低通滤波器</strong>：它允许信号中的低频或直流分量通过，抑制高频分量或干扰和噪声；</p>\n<p><strong>高通滤波器</strong>：它允许信号中的高频分量通过，抑制低频或直流分量；</p>\n<p><strong>带通滤波器</strong>：它允许一定频段的信号通过，抑制低于或高于该频段的信号、干扰和噪声；</p>\n<p><strong>带阻滤波器</strong>：它抑制一定频段内的信号，允许该频段以外的信号通过，又称为陷波滤波器。 [1]</p>\n<p><strong>全通滤波器</strong>：全通滤波器是指在全频带范围内，信号的幅值不会改变，也就是全频带内幅值增益恒等于1，<strong>即全通滤波器并不滤波</strong>。一般全通滤波器 <strong>用于移相</strong>，也就是说，对输入信号的相位进行改变，理想情况是相移与频率成正比，相当于一个时间延时系统。</p></li>\n<li><p>按所采用的元器件分为 <strong>无源</strong> 和 <strong>有源</strong> 滤波器两种。</p>\n<ul>\n<li>无源滤波 常见有 <strong>LC无源滤波</strong>，<strong>RC无源滤波</strong>，<strong>特殊元件无源滤波（应用较少）</strong> 等。\n<ul>\n<li>LC滤波器中的 L电杆 和 C电容 都是理想元件，本身不耗能，但电杆体积较大，现一般不使用。</li>\n<li>RC滤波器中的 R电阻 是会消耗能量的。</li>\n</ul></li>\n<li>有源滤波 常见有 <strong>RC有源滤波</strong>。</li>\n</ul></li>\n<li><p>按照传递函数微分方程的介数分为 <strong>一阶滤波器</strong>、<strong>二阶滤波器</strong> 及 <strong>高阶滤波器</strong>。</p></li>\n<li><p>根据滤波器的安放位置不同，一般分为 <strong>板上滤波器</strong> 和 <strong>面板滤波器</strong>。</p>\n<p><strong>板上滤波器</strong>安装在线路板上，如PLB、JLB系列滤波器。这种滤波器的优点是经济，缺点是高频滤波效果欠佳。其主要原因是：</p>\n<blockquote>\n<p>1、滤波器的输入与输出之间没有隔离，容易发生耦合；</p>\n<p>2、滤波器的接地阻抗不是很低，削弱了高频旁路效果；</p>\n<p>3、滤波器与机箱之间的一段连线会产生两种不良作用： 一个是机箱内部空间的电磁干扰会直接感应到这段线上，沿着电缆传出机箱，借助电缆辐射，使滤波器失效；另一个是外界干扰在被板上滤波器滤波之前，借助这段线产生辐射，或直接与线路板上的电路发生耦合，造成敏感度问题；</p>\n</blockquote>\n<p>滤波阵列板、滤波连接器等<strong>面板滤波器</strong>一般都直接安装在屏蔽机箱的金属面板上。由于直接安装在金属面板上，滤波器的输入与输出之间完全隔离，接地良好，电缆上的干扰在机箱端口上被滤除，因此滤波效果相当理想。</p></li>\n</ul>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210509151758365.png\" alt=\"image-20210509151758365\" /><figcaption aria-hidden=\"true\">image-20210509151758365</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210509152214883.png\" alt=\"image-20210509152214883\" /><figcaption aria-hidden=\"true\">image-20210509152214883</figcaption>\n</figure>\n<h2 id=\"常用滤波器\">常用滤波器</h2>\n<h3 id=\"有源滤波及无源滤波比较\">有源滤波及无源滤波比较</h3>\n<table>\n<colgroup>\n<col style=\"width: 6%\" />\n<col style=\"width: 46%\" />\n<col style=\"width: 46%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>无源滤波（Passive Filter）</th>\n<th>有源滤波（Active Filter）</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>组成</td>\n<td>仅由无源元件(R、L 和C)组成<br>即不使用任何需要电源的器件</td>\n<td>由无源滤波 + 有源器件（如运放）组成</td>\n</tr>\n<tr class=\"even\">\n<td>优点</td>\n<td>- 电路比较简单<br>- 不需要直流电源供电<br>- 可靠性高</td>\n<td>- 输出阻抗可以很低<br>- 可以使用放大器进行增益<br>- 不使用电感，因为电感是高容差型元件，频率较低时，体积会很大<br>- 通带内的信号不仅没有能量损耗，而且还可以放大<br>- 负载效应不明显<br>- 多级相联时相互影响很小<br>- 利用级联的简单方法很容易构成高阶滤波器<br>- 并且滤波器的体积小、重量轻、不需要磁屏蔽(由于不使用电感元件）；</td>\n</tr>\n<tr class=\"odd\">\n<td>缺点</td>\n<td>- 通带内的信号有能量损耗<br>- 负载效应比较明显<br>- 使用电感元件时容易引起电磁感应<br>- 当电感L较大时滤波器的体积和重量都比较大，在低频域不适用。</td>\n<td>- 通带范围受有源器件(如集成运算放大器）的带宽限制，需要直流电源供电<br>- 可靠性不如无源滤波器高，在高压、高频、大功率的场合不适用。</td>\n</tr>\n<tr class=\"even\">\n<td>应用场景</td>\n<td>电源滤波器<br>廉价且噪声较高的电源<br>处理10MHz以上的高频信号</td>\n<td>不能应用于电源滤波，因为有源滤波也需要其他电源进行供电</td>\n</tr>\n</tbody>\n</table>\n<p>注意：有源滤波器的设计所用运算放大器的频率通常要比设计截止频率高100倍左右，具体数值取决于峰化和其他多种因素。即（目前）无法使用有源滤波器处理10MHz以上的高频信号，这需要GHz规格的有源滤波器。</p>\n<h3 id=\"数字滤波器和模拟滤波器比较\">数字滤波器和模拟滤波器比较</h3>\n<table>\n<colgroup>\n<col style=\"width: 3%\" />\n<col style=\"width: 48%\" />\n<col style=\"width: 48%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>数字滤波器</th>\n<th>模拟滤波器</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>优点</td>\n<td>- 可编程（有一组系数和一个时钟频率，容易更改）<br>- 可重复性（即可复用性，数字滤波器的特性受环境影响较小）<br>- 采用FIR滤波器，会产生（框架中固有的）恒定时间的延迟（应该是受计算性能影响）</td>\n<td>- 无混叠（No aliasing）<br>- 降低对数字滤波的要求<br>- 降低对ADC的要求</td>\n</tr>\n</tbody>\n</table>\n<p>注意：在数字滤波器中，一个超过奈奎斯特频率的频率通过ADC时，滤波器将无法区分该频率和较低的频率。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210509162541363.png\" alt=\"image-20210509162541363\" /><figcaption aria-hidden=\"true\">image-20210509162541363</figcaption>\n</figure>\n<h3 id=\"数字滤波器\">数字滤波器</h3>\n<p><strong>定义</strong></p>\n<p>数字滤波器是与模拟滤波器相对应的，我们在常用的<a href=\"https://baike.baidu.com/item/离散系统/9719813\">离散系统</a>中， 使用数字滤波器。它的主要作用是利用离散时间系统的特性，在这里 时间就是一个变量，然后在对外部输入的信号，进行处理，这里的输 入信号一般都是广义上的波形型号，信号可以是电压、电流、功率等。 当然也有类似于频率等这种。在实际的操作中，我们也可以把输入的信号波形变成输出，也就是将输入和输出倒置。从而实现我们将信号的频谱修改的目的。</p>\n<p><strong>实现技术手段</strong></p>\n<p>数字滤波器有多种方式可以实现信号的处理，我们介绍在实际中使用最多的两种，一种是我们集成电路的方式将集成电路的各种元器件组成一个专用的设备，这种设备称之为<strong>数字信号处理机</strong>，类似于arm架构或者单片机架构的数字处理机就是我们常用的一种，这种方式对于成套批量的需求商用价值比较高，因为造价成本比较低，受到了市场的欢迎；另一种就是使用我们平常使用的<a href=\"https://baike.baidu.com/item/x86/6150538\">x86</a>/<a href=\"https://baike.baidu.com/item/x64/8161446\">x64</a>的商用或者工控计算机进行模拟仿真，这个完全是使用应用软件进行仿真的，这种方式也在实验室或者大型的数字滤波项目中使用，这种方式成本较高，不适宜与大批量的生产与配套。但是在实验室是最好的一种模拟方式，在高阶模拟和运算中有非常大的优势。</p>\n<p><strong>数字滤波器的对比</strong></p>\n<p>数字滤波器主要有两种，一种是<a href=\"https://baike.baidu.com/item/IIR/875808\">IIR</a>，我们称之为<strong>无限的冲激响应滤波器</strong>，另外一种是<a href=\"https://baike.baidu.com/item/FIR/345936\">FIR</a>，这种滤波器是与IIR相对应的，这个是<strong>有限的冲激响应滤波器</strong>。</p>\n<p>两个系统都是有各自的特点的，FIR的滤波器是没有闭环的反馈的环路信号，它的结构比较简单，可以实现比较严格的线性方程的相位的计算，一般情况下<mark>相位的要求不严格一般不会使用FIR滤波器</mark>，相反的话，会采用这种滤波器。</p>\n<p>当然在很多的场景下面，我们要对信号进行一些实时的处理，当现场的信号数据越来越多的情况下，我们对硬件的性能要求就越来越高，市面上很多的<a href=\"https://baike.baidu.com/item/单片机/102396\">单片机</a>已经无法满足我们实际的功能需求，一般的8位的16位的乃至32位的单片机以及<a href=\"https://baike.baidu.com/item/ARM/7518299\">ARM</a>芯片已经不能在对算法进行支撑，由于专门为数字处理设计的<a href=\"https://baike.baidu.com/item/DSP/74514\">DSP</a>控制器的出现，提高了我们滤波器的效率，DSP很多情况下可以使用多组总线的方式，并行处理多组实时的数据，独立的一些算法器充分的使用大大提高了我们滤波器的效率。</p>\n<p>对于硬件上的短板完全可以由DSP的芯片进行弥补，做到对数字信号的实时处理与计算。DSP与普通的微处理器相比有很大的数字信号的处理优势，他是单片机以及ARM的继承，为信号处理做了一些局部的开发和改进，大大的增强了数字处理的能力，它有特定的数据流程格式、有特定的算法器，有特殊的系统结构为解决复杂的数字信号的处理提供了很多优越的条件和基础，通过对DSP的编程可以实现IIR滤波器。 FIR滤波器实际上有一定的缺陷，这类系统只有零点，它不会跟IIR系统的那样容易获取比较好衰减的特性，但是也有更加明显的优势。他是通过非硬件电路实现的，相比硬件电路实现滤波器主要优点有很多，例如，效率很高、有极点、有反馈等。</p>\n<h3 id=\"程控滤波系统\">程控滤波系统</h3>\n<p>程控滤波系统是在传统滤波器的不足中提出的，传统滤波器在工作时产生误差，会影响整个系统的精确度。低精度的滤波器在使用时会造成很多不良后果，而且传统滤波器对波形要求越高就意味着需要跟多的<a href=\"https://baike.baidu.com/item/运放/1527937\">运放</a>，这是非常麻烦的。所以程控滤波器的数字化能够减少生产过程中的不确定因素和人为参与的环节数，可以有效地解决电源模块中诸如可靠性、智能化和产品一致性等工程问题，极大地提高生产 效率和产品的可维护性。</p>\n<h3 id=\"无源滤波器\">无源滤波器</h3>\n<p>无源滤波器是利用<a href=\"https://baike.baidu.com/item/电阻/3315365\">电阻</a>、<a href=\"https://baike.baidu.com/item/电抗器/7397303\">电抗器</a>和<a href=\"https://baike.baidu.com/item/电容器/1087619\">电容器</a>元器件构成的滤波电路。谐振频率时，电路阻抗值最小，非谐振频率时，电路阻抗比很大，将电路元器件数值调整到某一特征谐波频率，则能滤除该次谐波电流；当若干谐波频率的调谐电路组成在一起，则能滤除对应的特征谐波频率，通过低阻抗旁路实现对主要次数谐波（3、5、7）的过滤。主要原理就是针对不同次数谐波，设计该谐波频率的阻抗为很小，实现谐波电流的分流效应，即为预滤除的高次谐波提供旁路通道，实现净化波形。</p>\n<p>无源滤波器按接线形式可分为电容滤波器、电厂滤波电路、L型RC滤波电路、π形RC滤波电路、多节π形RC 滤波电路、π形LC滤波电路。按功能可分为<a href=\"https://baike.baidu.com/item/单调谐滤波器/10801261\">单调谐滤波器</a>、<a href=\"https://baike.baidu.com/item/双调谐滤波器/10801292\">双调谐滤波器</a>、高通滤波器。无源滤波器具有如下优势：结构 形式简单、投资费用低，能够补偿系统中的无功分量、改善电网功率因数；工作稳定性较高、维护简单、技术成熟等，在有源滤波器出现以前被广泛采用。无源滤波器的缺点也有很多方面：受电网参数的影响较大，系统阻抗值和主要次数谐振频率往往随着工况发生变化；谐波滤除的频带也较窄，只能滤除主要次数的谐波，或因发生<a href=\"https://baike.baidu.com/item/并联谐振/9876961\">并联谐振</a>，放大一些次数的谐波；滤波和无功补偿及调压之间的协调较困难 ；随着流经滤波器的电流升高，可能造成设备过负荷运行；耗材多，重量和体积都较大；运行稳定性较差等缺点。因此，整体性能更优的有源滤波器得到越来越多的应用。 [4]</p>\n<h3 id=\"有源滤波器\">有源滤波器</h3>\n<p>有源滤波器主要作用不仅能动态追踪并抑制谐波，而且可以补偿电网中较低的无功分量。它能够对幅值和频率都波动的高次谐波分量进行补偿，以及对变化的系统无功分量进行动态补偿，克服了传统型式谐波治理方案和无功补偿的缺点，达到了动态跟踪补偿的效果。<a href=\"https://baike.baidu.com/item/APF/15286545\">APF</a>的基本原理是检测当前系统的电压和电流信号，通过指令电流运算电路的运算，产生补偿电流信号，并将其指令由补偿电流发生电路按谐波信号放大，从而得到补偿电流，再与系统中的高次谐波分量及无功等电流抵消，实现系统波形的正弦化，滤除电网谐波，提高电能质量。有源滤波器和无源滤波器的区别，在于需要电源供电，且既补谐波又补无功。指令电流运算电路和补偿电流发生电路是有源滤波器的两个重要组成部分。指令电流运算电路的作用是检测出系统所需补偿的谐波分量和无功分量等。补偿电流发生电路的作用是按照上述检测到的谐波分量和无功分量，发出补偿电流指令，产生能够抵消的补偿电流，它主要由三部分构成 ：电流跟踪控制电路、驱动电路和主电路。</p>\n<p>根据储能元件的不同，有源滤波器可以分为电压型有源滤波器和电流型有源滤波器。电压型有源滤波器，因其损耗少、效率高，被广泛使用。电流型有源滤波器，因损耗大、效率低，而较少采用。按照交直流电源可分为直流 APF 和交流 APF。按照电路拓朴结构分类，可分为串联型 APF、并联型 APF 和串并联型，以及APF和<a href=\"https://baike.baidu.com/item/PPF/2374493\">PPF</a>的混合型使用方式。与无源滤波器相比，有源滤波器有许多优点：响应速度快，可控性能非常强；具有自适应功能，能够动态跟踪和补偿系统高次谐波；稳定性高，不受系统阻抗影响，避免谐振的发生；能够抑制闪变；补偿系统不足的无功分量等。机柜式系统采用模块化结构，联络设计细密，可随时根据现场实际需求扩容，可拓展性强，模块化的配置方式和小巧的体积让设计者有更多的选择，并可最大程度节省用户空间，可实现弹性的容量配置，支持后续现场容量扩展。现场安装和维修维护更是简单拔插即可。 抽屉式结构，能够满足用户单独对模块设计，选用优良的架构形式，具备DSP处理能力，运用大型可编程控制器操作，选用大功率电力电子组件，具有可外传的通信端口，还可附于其他盘柜中独立工作。 [4]</p>\n<h2 id=\"注意事项\">注意事项</h2>\n<p>板上滤波器虽然对高频的滤波效果不理想，但是如果应用得当，可以满足大部分民用产品<a href=\"https://baike.baidu.com/item/电磁兼容\">电磁兼容</a>的要求。在使用时要注意以下事项：</p>\n<p>如果决定使用板上滤波器，在布线时就要注意在电缆端口处留出一块“干净地”，滤波器和连接器都安装在“干净地”上。通过前面的讨论，可知信号地线上的干扰是十分严重的。如果直接将电缆的<a href=\"https://baike.baidu.com/item/滤波电容\">滤波电容</a>连接到这种地线上，会造成严重的 <strong>共模辐射</strong> 问题。为了取得较好的滤波效果，必须准备一块干净地。并与信号地只能在一点连接起来，这个流通点称为“桥”，所有<a href=\"https://baike.baidu.com/item/信号线\">信号线</a>都从桥上通过，以减小信号环路面积。</p>\n<p><strong>并排设置</strong>：同一组电缆内的所有<a href=\"https://baike.baidu.com/item/导线\">导线</a>的未滤波部分在—起，已滤波部分在一起。否则，一根导线的耒滤波部分会将另一根导线的已滤波部分重新污染使电缆整体滤波失效。</p>\n<p><strong>靠近电缆</strong>：滤波器与面板之间的导线的距离应尽量短。必要时，使用金属板遮挡一下，隔离近场干扰。</p>\n<p><strong>与机箱接</strong>：安装滤波器的干净地要与金属机箱可靠地搭接起来，如果机箱不是金属的，就在线路板下方设置一块较大的金属板来作为滤波地。干净地与金属机箱之间的搭接要保证很低的射频阻抗。如有必要，可以使用<a href=\"https://baike.baidu.com/item/电磁\">电磁</a>密封衬垫搭接，增加搭接面积，减小射频阻抗。</p>\n<p><strong>接地线短</strong>：考虑到<a href=\"https://baike.baidu.com/item/引脚\">引脚</a>的电感效应，其重要性前面已讨论，滤波器的局部布线和设计线路板与机箱（金属板）的连接结构时要特别注意。</p>\n<h1 id=\"滤波电容\">滤波电容</h1>\n<iframe src=\"//player.bilibili.com/player.html?aid=497834686&amp;bvid=BV1yK411V74V&amp;cid=181383906&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\">\n</iframe>\n<p><strong>旁路</strong>：一般出现在电路的输入端，为交流信号提供一个分支，滤除不需要的交流成分。</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210509154852357.png\" alt=\"image-20210509154852357\" /> <img src=\"https://pic.islet.space/2021/05/image-20210509155438601.png\" alt=\"image-20210509155438601\" /></p>\n<p>下图是带有低频扰动和高频尖刺的直流信号，使用所示电路对该信号进行过滤，可获得稳定直流信号。</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210509155705572.png\" alt=\"image-20210509155705572\" /> <img src=\"https://pic.islet.space/2021/05/image-20210509155806309.png\" alt=\"image-20210509155806309\" /></p>\n<p>其中，0.1uF 用于滤除高频成分；1000uF 用于滤除/抵抗 <strong>低频扰动</strong> 信号。</p>\n<p><strong>去耦</strong>：既有 <strong>滤波</strong> 的作用也有 <strong>储能</strong> 的作用。</p>\n<p>当芯片电路需要拉去较大的电压时，VCC可能会突然供电不足，此时用于VCC的去耦电容发挥了储能的作用，为芯片电路提供较稳定的电源。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210509155156432.png\" alt=\"image-20210509155156432\" /><figcaption aria-hidden=\"true\">image-20210509155156432</figcaption>\n</figure>\n<iframe src=\"//player.bilibili.com/player.html?aid=752864529&amp;bvid=BV1kk4y1R7TZ&amp;cid=178561019&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\">\n</iframe>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210509154226811.png\" alt=\"image-20210509154226811\" style=\"zoom:50%;\" /></p>\n<h1 id=\"运算放大器\">运算放大器</h1>\n<h2 id=\"运放定义\">运放定义</h2>\n<p>同相输入端，V<sub>p</sub>和V<sub>n</sub> 。</p>\n<p>虚短：</p>\n<p>虚断：</p>\n<h2 id=\"运放分类\">运放分类</h2>\n<p>按照电源电压分类：单端运放、双端运放。</p>\n<p>单端运放是指运算放大器的供给电源为正向电源和地；双端运放是指运算放大器的供给电源为正向电源和负向电源。</p>\n<h1 id=\"增益与音量\">增益与音量</h1>\n<h2 id=\"增益\">增益</h2>\n<blockquote>\n<p><strong>增益(Gain)的一般含义简而言之就是放大倍数</strong>。</p>\n<p>在电子学上，通常为一个系统的讯号输出与讯号输入的比率，如天线增益表示定向天线辐射集中程度的参数，为定向天线和无方向天线在预定方向产生的电场强度平方之比。<strong>放大器增益</strong>，表示放大器功率放大倍数，以输出功率同输入功率比值的常用对数表示等。</p>\n</blockquote>\n<p>增益一般指对元器件、电路、设备或系统，其电流、电压或功率增加的程度，以分贝(dB)数来规定，即增益的单位一般是分贝（dB），是一个<strong>相对值</strong>。电子学上常使用对数单位量度增益，并以贝（bel）作为单位：</p>\n<ul>\n<li>Gain = log<sub>10</sub>( <em>P<sub>2</sub></em> / <em>P<sub>1</sub></em> ) bel</li>\n</ul>\n<p>其中P1与P2分别为输入及输出的功率。</p>\n<p>由于增益的数值通常都很大，因此一般都使用分贝来表示：</p>\n<ul>\n<li>Gain = 10×log<sub>10</sub>( <em>P<sub>2</sub></em> / <em>P<sub>1</sub></em> ) dB</li>\n</ul>\n<p>这就是增益的绝对值与相对值分贝之间的关系。</p>\n<h3 id=\"常见增益\">常见增益</h3>\n<h4 id=\"天线增益\">天线增益</h4>\n<p>天线增益是指：在输入功率相等的条件下，实际天线与理想的辐射单元在空间同一点处所产生的信号的功率密度之比。天线增益是入网测试时极其重要的标准，它表示了天线的方向性和信号能量的集中程度。增益的大小影响天线发射信号覆盖范围和强度。主瓣越窄，旁瓣越小，能量就会越集中，那么天线增益越高。</p>\n<p>一般来说，增益的提高主要依靠减小垂直面向辐射的波瓣宽度，而在水平面上保持全向的辐射性能。天线增益对移动通信系统的运行质量极为重要，因为它决定蜂窝边缘的信号电平。增加增益就可以在一确定方向上增大网络的覆盖范围，或者在确定范围内增大增益余量。任何蜂窝系统都是一个双向过程，增加天线的增益能同时减少双向系统增益预算余量。</p>\n<p>天线增益的单位一般有两种：<strong>dBi</strong>与<strong>dBd</strong>，其中dBi是以理想点源天线为参考的基准，在各方向的辐射是均匀的；dBd是以半波阵子（偶极子）的天线为参考基准，相对于对称阵子天线的增益dBi=dBd+2.15。相同的条件下，增益越高，电波传播的距离越远。一般地，GSM定向基站的天线增益为18dBi，全向的为11dBi。同一个天线增益，dBi比dBd在数值上大2.15 dB。</p>\n<h4 id=\"放大器增益\">放大器增益</h4>\n<p>放大器增益是放大器输出功率与输入功率比值的对数，用以表示功率放大的程度。亦指电压或电流的放大倍数。同样，分贝就是放大器增益的单位。</p>\n<p>放大器输出与输入的比值为放大倍数，单位是“倍”，如10倍放大器，100倍放大器。</p>\n<p>当改用“分贝”做单位时，放大倍数就称之为增益，这是一个概念的两种称呼。电学中分贝与放大倍数的转换关系为：</p>\n<p>AV(I)(dB)=20lg[V<sub>o</sub>/V<sub>i</sub>(I<sub>o</sub>/I<sub>i</sub>)]；Ap(dB)=10lg(P<sub>o</sub>/P<sub>i</sub>)</p>\n<p>分贝定义时 <strong>电压(电流)增益</strong> 和 <strong>功率增益</strong> 的公式不同，但我们都知道功率与电压、电流的关系是P=V<sup>2/R=I</sup>2R。采用这套公式后，两者的增益数值就一样了：</p>\n<p>10lg[P<sub>o</sub>/P<sub>i</sub>]=10lg(V<sub>2o</sub>/R)/(V<sub>2i</sub>/R)=20lg(V<sub>o</sub>/V<sub>i</sub>)。</p>\n<p>使用分贝做单位有很大好处。 电子系统的总放大倍数常常是几千、几万甚至几十万，一架收音机从天线收到的信号至送入喇叭放音输出，一共要放大2万倍左右。用分贝表示先取个对数，数值就小得多。放大器级联时，总的放大倍数是各级相乘。用分贝做单位时，总增益就是相加。若某功放前级是100倍(20dB)，后级是20倍(13dB)，那么总功率放大倍数是100×20=2000倍，总增益为<code>20dB+13dB=33dB</code>。</p>\n<h4 id=\"功率增益\">功率增益</h4>\n<p>功率增益（Power gain）是指一个电路里输出功率和输入功率的比例。不像其他的信号增益，例如电压增益和电流增益，功率增益由于“输入功率”和“输出功率”本身有着相对模糊的定义，因此有时显得有点混淆。</p>\n<p>三种重要的功率增益包括：<strong>运算功率增益</strong>（operating power gain）、<strong>转换功率增益</strong>（transducer power gain）和 <strong>有效功率增益</strong>（available power gain）。</p>\n<p style=\"color: #aaa; font-style: italic;\">\n值得注意的是，上述三种增益的定义均基于功率的平均效果，而非瞬时功率，不过“平均”二字经常被省略，在有的情况会引起混淆。\n</p>\n<h4 id=\"环路增益\">环路增益</h4>\n<p>环路增益（loop gain）为电子学及控制工程的名词，是指一反馈回路中的总增益，一般会以比例或是分贝表示。</p>\n<p>环路增益常用在放大器及电子振荡器的线路中，后来更扩展到控制工厂及设备的工业控制系统中。环路增益的概念也用在生物学中。在反馈回路中，为了控制输出，会量测设备、程序的输出，取样后，再以此影响输入信号，使输出控制的更理想。环路增益和环路相位移决定了设备的特性，也决定输出是否稳定，或是不稳定（振荡）。</p>\n<p>海因里希·巴克豪森在1921年最早发现环路增益在电子反馈放大器特性分析中的重要性，后来在1930年代由贝尔实验室的亨德里克·韦德·波德及哈里·奈奎斯特继续发展。 在通讯上，环路增益可以指载波终端或是二线中继器上的可用功率增益。最大的可用增益是由闭回路的总损失决定，可用增益不能大于总损失。</p>\n<h2 id=\"volume音量\">Volume/音量</h2>\n<p>音量(Volume)又称音强、响度，是指人耳对所听到的声音大小强弱的主观感受，其客观评价尺度是声音的振幅大小。这种感受源自物体振动时所产生的压力，即声压。物体振动通过不同的介质，将其振动能量传导开去。人们为了对声音的感受量化成可以监测的指标，就把声压分成“级”——声压级，以便能客观的表示声音的强弱，其单位称为“分贝”（dB）。</p>\n<p>音量影响的是后级最终输出的响度。</p>\n<h2 id=\"增益和音量的关系\">增益和音量的关系</h2>\n<p>增益多与“敏感度”相关，比方说：你的麦克风需要更“灵敏”吗？那么就把增益开大些。但是增益开得过大，信噪比会降低，底噪声就会更加明显。还会因电流输出限制产生削波失真。 这就是我们所说的“过载”效果的真正来源。也是很多朋友想要通过开大clean通道的volume去制造过载却不明显的原因。</p>\n<p>如果把增益开大，把音量关小的话，可以得到过载的效果。很多60,70年代的音乐作品中可以听到这种音色；关小增益开大音量的话，音符会很清晰，颗粒性也很好。</p>\n","categories":["Signal"],"tags":["filter","gain"]},{"title":"TRS端子及其他音频接口","url":"/2021/05/11/Signal/2021-05-11-TRS%E7%AB%AF%E5%AD%90%E5%8F%8A%E5%85%B6%E4%BB%96%E9%9F%B3%E9%A2%91%E6%8E%A5%E5%8F%A3/","content":"<p>接口其实包括对 “<strong>接口</strong>” （interface）和 “<strong>连接器</strong>” （connector）这两个方面的讨论，“连接器”我们通常也称之为“接头”或“插头”。 “接口”定义了电子设备之间连接的物理特性，包括传输的<strong>信号频率</strong>、<strong>强度</strong>，以及相应<strong>连线的类型</strong>、<strong>数量</strong>，还包括<strong>插头</strong>、<strong>插座</strong>的结构设计；而“连接器”则是在物理上实现设备之间连接的装置。</p>\n<h1 id=\"trs\">TRS</h1>\n<p>TRS端子（TRS connector）是一种常用于连接音响设备，用以传递音频信号的连接器。该词是其三个组成部件的首字母缩写：<strong>Tip</strong>（尖）、<strong>Ring</strong>（环）、<strong>Sleeve</strong>（套）。</p>\n<p>由于该种接头一般用于接插耳机和麦克风，因此也称 Phone Jack。虽然统称TRS，但也可依据具体的插头/插座的<strong>环（R）数</strong> 不同而分别称为<strong>TS</strong>（无环，即尖和套各提供一个接触点）、<strong>TRS</strong>（一环，三个接触点）、<strong>TRRS</strong>（两环，四个接触点）等等。</p>\n<p>日常生活中我们见得最多的就是<strong>TRS</strong>接口，它的接头外观是圆柱体形状，通常有三种尺寸<strong>1/4\"</strong>（6.3mm）、<strong>1/8\"</strong>（3.5mm）、<strong>3/32\"</strong>（2.5mm），最常见的是3.5mm尺寸的接头。</p>\n<p><img src=\"https://pic.islet.space/2021/05/72f082025aafa40fc0dca129a764034f78f0192f\" alt=\"img\" style=\"zoom:50%;\" /></p>\n<p><strong>TRS</strong> 的含义是Tip（signal）、Ring（signal）、Sleeve（ground），分别代表了这种接头的3个触点，我们看到的就是被两段绝缘材料隔离开的三段金属柱。因此，3.5mm接头和6.3mm接头也被人称为“小三芯”和“大三芯”。</p>\n<p><img src=\"https://pic.islet.space/2021/05/Cg-4WlUQA2qIVD1QAAEWTBx9jskAAAGGAKz658AARZk513.jpg\" alt=\" \" style=\"zoom: 150%;\" /></p>\n<p>TRS接口就是一个圆孔，其内部与接头对应，也有三个触点，彼此之间也被绝缘材料隔开。</p>\n<h2 id=\"常见设备\">常见设备</h2>\n<p>通常，手机上的耳机插口都是TRRS，而电脑上通常是两个TRS，一个传声音的左右声道，一个传话筒的左右声道。</p>\n<p>而为了使得双TRS的耳麦可以插到手机上，产生了转接头，也就是图中的第二个设备。不过我们考虑一下会发现，两个TRS都是3个信号，合并到一个TRRS接口上，信号变成了4个，减少了两个。除去一个共地的GND，还少了一个信号，去哪了呢？其实这是因为它会把LMIC和RMIC合并成一个MIC，而且TRRS本身就是只能传输一个MIC信号的，不存在左右声道。</p>\n<p>当然了，也有反过来将TRRS转接成两个TRS接口的转接头。</p>\n<p>此外，还有TS麦克风，如图中的第四个设备。如果话筒采用的这种接口，就默认了MIC只有一个声道，这种一般是用在小蜜蜂扩音器上。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/41_2.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>当然，既然能加芯，那也可以减芯。二芯的TRS接头可以用来传送非平衡的单声道音频信号，比如电吉他用的线就是二芯的TRS线。所以，单从TRS接口外观来看，我们不会知道它是否支持平衡传输；单从芯数来看，我们也不能确定四芯及以上的TRS接头是否支持平衡传输，具体情况需要看设备。</p>\n<p>尖和套是一定要有的，但环可以根据需要加，常见的有0-2个环的，也就是TS、TRS和TRRS。环越多，可以传输的信号数量越多。</p>\n<p>因此，普通双声道耳机需要3个信号，即TRS；而如果是带麦克风的耳机，就需要4个信号了，即TRRS。注意，这里除了左声道(L)、右声道(R)以及带麦耳机所需的麦克风(MIC)信号，必须还要有地线(GND)，因为没有绝对电压而只有相对电压。</p>\n<p>在3.5mm接口上传输的是模拟信号，使用电压模拟声波。</p>\n<p>此外，还有一种用于耳机的四芯3.5mm插头则是用来传输平衡信号的。6.3mm的“大三芯”插头可用来传输平衡信号或非平衡立体声信号，也就是说它可以和XLR平衡接口一样，能够传输平衡信号，但因制作这样的平衡线成本比较高，所以一般只用在高档专业音频设备上。</p>\n<p><img src=\"https://article-fd.zol-img.com.cn/t_s640x2000/g2/M00/01/08/Cg-4WlUQBM2IO7yBAAPH1zKABagAAAGHwBFP9AAA8fv952.jpg\" alt=\"拒绝做小白 你应该知道的常见音频接口 \" style=\"zoom:67%;\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n二芯6.3mm TRS电吉他线\n</div>\n<h2 id=\"trs母头\">TRS母头</h2>\n<p>ADI公司旗下的 ADAU1772 评估板采用的就是CUI公司旗下型号为 SJ-3523-SMT-TR 的TRS母头</p>\n<p><img src=\"https://pic.islet.space/2021/05/2021-05-11_16-39.png\" /></p>\n<p>说明书如：<a href=\"https://www.cuidevices.com/product/resource/digikeypdf/sj-352x-smt.pdf\">sj-352x-smt.pdf</a> ，其规格如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210511164353982.png\" alt=\"image-20210511164353982\" /><figcaption aria-hidden=\"true\">image-20210511164353982</figcaption>\n</figure>\n<h1 id=\"rca\">RCA</h1>\n<p>RCA接口在我们日常生活中也非常常见，音箱、电视、功放、DVD机等设备上基本都有。它得名于美国无线电公司的英文缩写（Radio Corporation of America），上世纪40年代的时候，该公司将这种接口引入市场，用它来连接留声机和扬声器，也因此，它在欧州又称为PHONO接口。我们对它更熟悉的接头称呼则是“莲花头”。</p>\n<p><img src=\"https://article-fd.zol-img.com.cn/t_s640x2000/g2/M00/01/08/Cg-4WlUQCFeITgCFAAaVRivfdawAAAGKwBI8wMABpVe851.jpg\" alt=\"拒绝做小白 你应该知道的常见音频接口 \" style=\"zoom:67%;\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\nRCA接口在我们日常生活中非常常见\n</div>\n<p><img src=\"https://article-fd.zol-img.com.cn/t_s640x2000/g2/M00/01/08/Cg-4WVUQCFyIRm-6AAMW5z_mkQ8AAAGKwB5ZmQAAxb_659.jpg\" alt=\"拒绝做小白 你应该知道的常见音频接口 \" style=\"zoom:67%;\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n被称为“莲花头”的RCA接头\n</div>\n<p>RCA接口采用同轴传输信号的方式，中轴用来传输信号，外沿一圈的接触层用来接地。每一根RCA线缆负责传输一个声道的音频信号，因此，可以根据对声道的实际需要，使用与之数量相匹配的RCA线缆。比如要组双声道立体声就需要两根RCA线缆。</p>\n<h1 id=\"xlr\">XLR</h1>\n<p>XLR接口又被称为“卡农口”，这是因为James H. Cannon创立的Cannon Electric公司是它最初的生产商。它们最早的产品是“cannon X”系列，后来改进产品增加了一个锁定装置（Latch），于是在“X”后面增加了一个“L”；再后来又围绕着接头的金属触点增加了橡胶封口（Rubber compound），于是又在“L”后面增加了一个“R”。人们就把三个大写字母组合在一起，称这种接头为“XLR connector”。</p>\n<p><img src=\"https://article-fd.zol-img.com.cn/t_s640x2000/g2/M00/01/08/Cg-4WVUQChyIbKeoAALaNHpTfMUAAAGMAMweHgAAtpM096.jpg\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n比较常见的三芯XLR接口\n</div>\n<p><img src=\"https://article-fd.zol-img.com.cn/t_s640x2000/g2/M00/01/08/Cg-4WlUQDLCIUqT0AAHcPS_ygasAAAGOQEvIJQAAdxV227.jpg\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n有的耳放上面会提供四芯平衡XLR接口\n</div>\n<p>我们通常见到的XLR插头是3脚的，当然也有2脚、4脚、5脚、6脚的，比如在一些高档耳机线上，我们也会看到四芯XLR平衡接头。XLR接口与“大三芯”TRS接口一样，可以用来传输音频平衡信号。这里我们简单说一下平衡信号与非平衡信号。声波转换成电信号后，如果直接传送就是非平衡信号，如果把原始信号反相180度，然后同时传送原始信号和反相信号，这就是平衡信号。平衡传输就是利用相位抵消原理，将音频信号传输过程中受到的其他干扰降至最低。 当然，XLR接口也跟“大三芯”TRS接口一样，可以传输非平衡信号，因此光从接口看，我们是看不出来它到底传输的是哪种信号。</p>\n","categories":["Signal"],"tags":["TRS","stereo"]},{"title":"PCM/WAV格式","url":"/2021/07/02/Signal/2021-07-02-PCMWAV%E6%A0%BC%E5%BC%8F/","content":"<p><a href=\"https://www.cnblogs.com/renhui/p/12148330.html\">cnblogs.com</a></p>\n<h1 id=\"名词解析\">名词解析</h1>\n<p>PCM(Pulse Code Modulation)也被称为脉码编码调制，PCM中的声音数据没有被压缩，它是由模拟信号经过采样、量化、编码转换成的标准的数字音频数据。采样转换方式参考下图进行了解：</p>\n<figure>\n<img src=\"https://img2018.cnblogs.com/blog/682616/202001/682616-20200104125147149-1090015063.png\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>音频采样包含以下几大要素：</p>\n<h2 id=\"采样率\">采样率</h2>\n<p>采样率表示音频信号每秒的数字快照数。该速率决定了音频文件的频率范围。采样率越高，数字波形的形状越接近原始模拟波形。低采样率会限制可录制的频率范围，这可导致录音表现原始声音的效果不佳。根据奈奎斯特采样定理，为了重现给定频率，采样率必须至少是该频率的两倍。例如，一般CD唱片的采样率为每秒 44,100 个采样，因此可重现最高为 22,050 Hz 的频率，此频率刚好超过人类的听力极限 20,000 Hz。</p>\n<figure>\n<img src=\"https://img2018.cnblogs.com/blog/682616/202001/682616-20200104124551841-1606892798.png\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>图中A是低采样率的音频信号，其效果已经将原始声波进行了扭曲，B则是完全重现原始声波的高采样率的音频信号。</p>\n<p>数字音频常用的采样率如下：</p>\n<figure>\n<img src=\"https://img2018.cnblogs.com/blog/682616/202001/682616-20200104124756569-1015603325.png\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<h2 id=\"位深度\">位深度</h2>\n<p>位深度决定动态范围。采样声波时，为每个采样指定最接近原始声波振幅的振幅值。较高的位深度可提供更多可能的振幅值，产生更大的动态范围、更低的噪声基准和更高的保真度。</p>\n<figure>\n<img src=\"https://img2018.cnblogs.com/blog/682616/202001/682616-20200104124916045-1853047547.png\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>位深度越高，提供的动态范围越大。</p>\n<h1 id=\"pcm\">PCM</h1>\n<p>在上面的名词解析中我们应该对PCM有了一定的理解和认识，下面我们将对PCM做更多的讲解。</p>\n<h2 id=\"pcm音频数据存储方式\">PCM音频数据存储方式</h2>\n<p>如果是单声道的文件，采样数据按时间的先后顺序依次存入。如果是单声道的音频文件，采样数据按时间的先后顺序依次存入（也可能采用 LRLRLR 方式存储，只是另一个声道的数据为 0）。</p>\n<p>如果是双声道的话通常按照 LRLRLR 的方式存储，存储的时候还和机器的大小端有关。（关于字节序大小端的相关内容可参考《<a href=\"https://www.cnblogs.com/renhui/p/13600572.html\">字节序问题之大小端模式讲解</a>》进行了解）</p>\n<p>PCM的存储方式为小端模式，存储Data数据排列如下图所示：</p>\n<figure>\n<img src=\"https://img2018.cnblogs.com/blog/682616/202001/682616-20200104112313716-290297915.png\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<h2 id=\"pcm-音频数据的参数\">PCM 音频数据的参数</h2>\n<p>描述 PCM 音频数据的参数的时候有如下描述方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">44100HZ 16bit stereo: 每秒钟有 44100 次采样, 采样数据用 16 位（2 字节）记录, 双声道（立体声）</span><br><span class=\"line\">22050HZ 8bit  mono: 每秒钟有 22050 次采样, 采样数据用 8 位（1 字节）记录, 单声道</span><br><span class=\"line\">48000HZ 32bit 51ch: 每秒钟有 48000 次采样, 采样数据用 32 位（4 字节浮点型）记录, 5.1 声道</span><br></pre></td></tr></table></figure>\n<p>44100Hz 指的是采样率，它的意思是每秒取样 44100 次。采样率越大，存储数字音频所占的空间就越大。</p>\n<p>16bit 指的是采样精度，意思是原始模拟信号被采样后，每一个采样点在计算机中用 16 位（两个字节）来表示。采样精度越高越能精细地表示模拟信号的差异。</p>\n<p>Stereo 指的是声道数，也即采样时用到的麦克风的数量，麦克风越多就越能还原真实的采样环境（当然麦克风的放置位置也是有规定的）。</p>\n<h1 id=\"wav\">WAV</h1>\n<p>WAV 是 Microsoft 和 IBM 为 PC 开发的一种声音文件格式，它符合 RIFF（Resource Interchange File Format）文件规范，用于保存 Windows 平台的音频信息资源，被 Windows 平台及其应用程序所广泛支持。WAVE 文件通常只是一个具有单个 “WAVE” 块的 RIFF 文件，该块由两个子块（”fmt” 子数据块和 ”data” 子数据块），它的格式如下图所示：</p>\n<figure>\n<img src=\"https://img2018.cnblogs.com/blog/682616/202001/682616-20200104131622902-1855086338.png\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p><strong>WAV 格式定义</strong></p>\n<p>该格式的实质就是在 PCM 文件的前面加了一个文件头，每个字段的的含义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef struct &#123;</span><br><span class=\"line\">    char          ChunkID[4]; &#x2F;&#x2F;内容为&quot;RIFF&quot;</span><br><span class=\"line\">    unsigned long ChunkSize;  &#x2F;&#x2F;存储文件的字节数（不包含ChunkID和ChunkSize这8个字节）</span><br><span class=\"line\">    char          Format[4];  &#x2F;&#x2F;内容为&quot;WAVE“</span><br><span class=\"line\">&#125; WAVE_HEADER;</span><br><span class=\"line\"> </span><br><span class=\"line\">typedef struct &#123;</span><br><span class=\"line\">   char           Subchunk1ID[4]; &#x2F;&#x2F;内容为&quot;fmt&quot;</span><br><span class=\"line\">   unsigned long  Subchunk1Size;  &#x2F;&#x2F;存储该子块的字节数（不含前面的Subchunk1ID和Subchunk1Size这8个字节）</span><br><span class=\"line\">   unsigned short AudioFormat;    &#x2F;&#x2F;存储音频文件的编码格式，例如若为PCM则其存储值为1。</span><br><span class=\"line\">   unsigned short NumChannels;    &#x2F;&#x2F;声道数，单声道(Mono)值为1，双声道(Stereo)值为2，等等</span><br><span class=\"line\">   unsigned long  SampleRate;     &#x2F;&#x2F;采样率，如8k，44.1k等</span><br><span class=\"line\">   unsigned long  ByteRate;       &#x2F;&#x2F;每秒存储的bit数，其值 &#x3D; SampleRate * NumChannels * BitsPerSample &#x2F; 8</span><br><span class=\"line\">   unsigned short BlockAlign;     &#x2F;&#x2F;块对齐大小，其值 &#x3D; NumChannels * BitsPerSample &#x2F; 8</span><br><span class=\"line\">   unsigned short BitsPerSample;  &#x2F;&#x2F;每个采样点的bit数，一般为8,16,32等。</span><br><span class=\"line\">&#125; WAVE_FMT;</span><br><span class=\"line\"> </span><br><span class=\"line\">typedef struct &#123;</span><br><span class=\"line\">   char          Subchunk2ID[4]; &#x2F;&#x2F;内容为“data”</span><br><span class=\"line\">   unsigned long Subchunk2Size;  &#x2F;&#x2F;接下来的正式的数据部分的字节数，其值 &#x3D; NumSamples * NumChannels * BitsPerSample &#x2F; 8</span><br><span class=\"line\">&#125; WAVE_DATA;</span><br></pre></td></tr></table></figure>\n<p><strong>WAV 文件头解析</strong></p>\n<p>这里是一个 WAVE 文件的开头 72 字节，字节显示为十六进制数字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">52 49 46 46 | 24 08 00 00 | 57 41 56 45</span><br><span class=\"line\">66 6d 74 20 | 10 00 00 00 | 01 00 02 00 </span><br><span class=\"line\">22 56 00 00 | 88 58 01 00 | 04 00 10 00</span><br><span class=\"line\">64 61 74 61 | 00 08 00 00 | 00 00 00 00 </span><br><span class=\"line\">24 17 1E F3 | 3C 13 3C 14 | 16 F9 18 F9</span><br><span class=\"line\">34 E7 23 A6 | 3C F2 24 F2 | 11 CE 1A 0D</span><br></pre></td></tr></table></figure>\n<p>字段解析如下图：</p>\n<figure>\n<img src=\"https://img2018.cnblogs.com/blog/682616/202001/682616-20200104131832991-1533022058.png\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<h1 id=\"pcm-wav-开发实践\">PCM &amp; WAV 开发实践</h1>\n<h2 id=\"pcm格式转为wav格式基于c语言\">PCM格式转为WAV格式（基于C语言）</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int simplest_pcm16le_to_wave(const char *pcmpath,int channels,int sample_rate,const char *wavepath)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    typedef struct WAVE_HEADER&#123;  </span><br><span class=\"line\">        char         fccID[4];        </span><br><span class=\"line\">        unsigned   long    dwSize;            </span><br><span class=\"line\">        char         fccType[4];    </span><br><span class=\"line\">    &#125;WAVE_HEADER;  </span><br><span class=\"line\">    typedef struct WAVE_FMT&#123;  </span><br><span class=\"line\">        char         fccID[4];        </span><br><span class=\"line\">        unsigned   long       dwSize;            </span><br><span class=\"line\">        unsigned   short     wFormatTag;    </span><br><span class=\"line\">        unsigned   short     wChannels;  </span><br><span class=\"line\">        unsigned   long       dwSamplesPerSec;  </span><br><span class=\"line\">        unsigned   long       dwAvgBytesPerSec;  </span><br><span class=\"line\">        unsigned   short     wBlockAlign;  </span><br><span class=\"line\">        unsigned   short     uiBitsPerSample;  </span><br><span class=\"line\">    &#125;WAVE_FMT;  </span><br><span class=\"line\">    typedef struct WAVE_DATA&#123;  </span><br><span class=\"line\">        char       fccID[4];          </span><br><span class=\"line\">        unsigned long dwSize;              </span><br><span class=\"line\">    &#125;WAVE_DATA;  </span><br><span class=\"line\">    if(channels&#x3D;&#x3D;0||sample_rate&#x3D;&#x3D;0)&#123;</span><br><span class=\"line\">    channels &#x3D; 2;</span><br><span class=\"line\">    sample_rate &#x3D; 44100;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int bits &#x3D; 16;</span><br><span class=\"line\">    WAVE_HEADER   pcmHEADER;  </span><br><span class=\"line\">    WAVE_FMT   pcmFMT;  </span><br><span class=\"line\">    WAVE_DATA   pcmDATA;  </span><br><span class=\"line\"> </span><br><span class=\"line\">    unsigned   short   m_pcmData;</span><br><span class=\"line\">    FILE   *fp,*fpout;  </span><br><span class=\"line\">    fp&#x3D;fopen(pcmpath, &quot;rb&quot;);</span><br><span class=\"line\">    if(fp &#x3D;&#x3D; NULL) &#123;  </span><br><span class=\"line\">        printf(&quot;open pcm file error\\n&quot;);</span><br><span class=\"line\">        return -1;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fpout&#x3D;fopen(wavepath,   &quot;wb+&quot;);</span><br><span class=\"line\">    if(fpout &#x3D;&#x3D; NULL) &#123;    </span><br><span class=\"line\">        printf(&quot;create wav file error\\n&quot;);  </span><br><span class=\"line\">        return -1; </span><br><span class=\"line\">    &#125;        </span><br><span class=\"line\">    &#x2F;&#x2F;WAVE_HEADER</span><br><span class=\"line\">    memcpy(pcmHEADER.fccID,&quot;RIFF&quot;,strlen(&quot;RIFF&quot;));                    </span><br><span class=\"line\">    memcpy(pcmHEADER.fccType,&quot;WAVE&quot;,strlen(&quot;WAVE&quot;));  </span><br><span class=\"line\">    fseek(fpout,sizeof(WAVE_HEADER),1); </span><br><span class=\"line\">    &#x2F;&#x2F;WAVE_FMT</span><br><span class=\"line\">    pcmFMT.dwSamplesPerSec&#x3D;sample_rate;  </span><br><span class=\"line\">    pcmFMT.dwAvgBytesPerSec&#x3D;pcmFMT.dwSamplesPerSec*sizeof(m_pcmData);  </span><br><span class=\"line\">    pcmFMT.uiBitsPerSample&#x3D;bits;</span><br><span class=\"line\">    memcpy(pcmFMT.fccID,&quot;fmt &quot;,strlen(&quot;fmt &quot;));  </span><br><span class=\"line\">    pcmFMT.dwSize&#x3D;16;  </span><br><span class=\"line\">    pcmFMT.wBlockAlign&#x3D;2;  </span><br><span class=\"line\">    pcmFMT.wChannels&#x3D;channels;  </span><br><span class=\"line\">    pcmFMT.wFormatTag&#x3D;1;  </span><br><span class=\"line\"> </span><br><span class=\"line\">    fwrite(&amp;pcmFMT,sizeof(WAVE_FMT),1,fpout); </span><br><span class=\"line\">    &#x2F;&#x2F;WAVE_DATA;</span><br><span class=\"line\">    memcpy(pcmDATA.fccID,&quot;data&quot;,strlen(&quot;data&quot;));  </span><br><span class=\"line\">    pcmDATA.dwSize&#x3D;0;</span><br><span class=\"line\">    fseek(fpout,sizeof(WAVE_DATA),SEEK_CUR);</span><br><span class=\"line\">    fread(&amp;m_pcmData,sizeof(unsigned short),1,fp);</span><br><span class=\"line\">    while(!feof(fp))&#123;  </span><br><span class=\"line\">        pcmDATA.dwSize+&#x3D;2;</span><br><span class=\"line\">        fwrite(&amp;m_pcmData,sizeof(unsigned short),1,fpout);</span><br><span class=\"line\">        fread(&amp;m_pcmData,sizeof(unsigned short),1,fp);</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    pcmHEADER.dwSize&#x3D;44+pcmDATA.dwSize;</span><br><span class=\"line\">    rewind(fpout);</span><br><span class=\"line\">    fwrite(&amp;pcmHEADER,sizeof(WAVE_HEADER),1,fpout);</span><br><span class=\"line\">    fseek(fpout,sizeof(WAVE_FMT),SEEK_CUR);</span><br><span class=\"line\">    fwrite(&amp;pcmDATA,sizeof(WAVE_DATA),1,fpout);</span><br><span class=\"line\">    </span><br><span class=\"line\">    fclose(fp);</span><br><span class=\"line\">    fclose(fpout);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：函数里声明的数据类型unsigned long在有些C编译器上是64位的，这时候要改成unsigned int才可以，否则wav头有88bytes，标准的是44bytes，改完就正常了，对C还不熟悉的人小小的心得，另外，声道数和采样率也要注意，一般采样率有44100/16000/8000，要确认是哪个，声道是1还是2，这两个参数要设置好才会有正确的转换结果。</p>\n<h2 id=\"pcm降低某个声道的音量基于c语言\">PCM降低某个声道的音量（基于C语言）</h2>\n<p>一般来说 PCM 数据中的波形幅值越大，代表音量越大，对于 PCM 音频数据而言，它的幅值（即该采样点采样值的大小）代表音量的大小。</p>\n<p>如果我们需要降低某个声道的音量，可以通过减小某个声道的数据的值来实现降低某个声道的音量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int pcm16le_half_volume_left( char *url ) &#123;</span><br><span class=\"line\">    FILE *fp_in &#x3D; fopen( url, &quot;rb+&quot; );</span><br><span class=\"line\">    FILE *fp_out &#x3D; fopen( &quot;output_half_left.pcm&quot;, &quot;wb+&quot; );</span><br><span class=\"line\">    unsigned char *sample &#x3D; ( unsigned char * )malloc(4); &#x2F;&#x2F; 一次读取一个sample，因为是2声道，所以是4字节 </span><br><span class=\"line\">    while ( !feof( fp_in ) )&#123;</span><br><span class=\"line\">        fread( sample, 1, 4, fp_in );</span><br><span class=\"line\">        short* sample_num &#x3D; ( short* )sample; &#x2F;&#x2F; 转成左右声道两个short数据</span><br><span class=\"line\">        *sample_num &#x3D; *sample_num &#x2F; 2; &#x2F;&#x2F; 左声道数据减半</span><br><span class=\"line\">        fwrite( sample, 1, 2, fp_out ); &#x2F;&#x2F; L</span><br><span class=\"line\">        fwrite( sample + 2, 1, 2, fp_out ); &#x2F;&#x2F; R</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    free( sample );</span><br><span class=\"line\">    fclose( fp_in );</span><br><span class=\"line\">    fclose( fp_out );</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码做的事情是：在读出左声道的 2 Byte 的取样值之后，将其转成了 C 语言中的一个 short 类型的变量。将该数值除以 2 之后写回到了 PCM 文件中。</p>\n<h2 id=\"分离pcm音频数据左右声道的数据\">分离PCM音频数据左右声道的数据</h2>\n<p>因为PCM音频数据是按照LRLRLR的方式来存储左右声道的音频数据的，所以我们可以通过将它们交叉的读出来的方式来分离左右声道的数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int simplest_pcm16le_split(char *url) &#123;</span><br><span class=\"line\">    FILE *fp&#x3D;fopen(url,&quot;rb+&quot;);</span><br><span class=\"line\">    FILE *fp1&#x3D;fopen(&quot;output_l.pcm&quot;,&quot;wb+&quot;);</span><br><span class=\"line\">    FILE *fp2&#x3D;fopen(&quot;output_r.pcm&quot;,&quot;wb+&quot;);</span><br><span class=\"line\">    unsigned char *sample&#x3D;(unsigned char *)malloc(4);</span><br><span class=\"line\">    while(!feof(fp))&#123;</span><br><span class=\"line\">        fread(sample,1,4,fp);</span><br><span class=\"line\">        &#x2F;&#x2F;L</span><br><span class=\"line\">        fwrite(sample,1,2,fp1);</span><br><span class=\"line\">        &#x2F;&#x2F;R</span><br><span class=\"line\">        fwrite(sample+2,1,2,fp2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    free(sample);</span><br><span class=\"line\">    fclose(fp);</span><br><span class=\"line\">    fclose(fp1);</span><br><span class=\"line\">    fclose(fp2);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<h2 id=\"从pcm16le单声道音频采样数据中截取一部分数据\">从PCM16LE单声道音频采样数据中截取一部分数据</h2>\n<p>本程序中的函数可以从PCM16LE单声道数据中截取一段数据，并输出截取数据的样值。函数的代码如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Cut a 16LE PCM single channel file.</span><br><span class=\"line\"> * @param url        Location of PCM file.</span><br><span class=\"line\"> * @param start_num  start point</span><br><span class=\"line\"> * @param dur_num    how much point to cut</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">int simplest_pcm16le_cut_singlechannel(char *url,int start_num,int dur_num)&#123;</span><br><span class=\"line\">    FILE *fp&#x3D;fopen(url,&quot;rb+&quot;);</span><br><span class=\"line\">    FILE *fp1&#x3D;fopen(&quot;output_cut.pcm&quot;,&quot;wb+&quot;);</span><br><span class=\"line\">    FILE *fp_stat&#x3D;fopen(&quot;output_cut.txt&quot;,&quot;wb+&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">    unsigned char *sample&#x3D;(unsigned char *)malloc(2);</span><br><span class=\"line\"> </span><br><span class=\"line\">    int cnt&#x3D;0;</span><br><span class=\"line\">    while(!feof(fp))&#123;</span><br><span class=\"line\">        fread(sample,1,2,fp);</span><br><span class=\"line\">        if(cnt&gt;start_num&amp;&amp;cnt&lt;&#x3D;(start_num+dur_num))&#123;</span><br><span class=\"line\">            fwrite(sample,1,2,fp1);</span><br><span class=\"line\"> </span><br><span class=\"line\">            short samplenum&#x3D;sample[1];</span><br><span class=\"line\">            samplenum&#x3D;samplenum*256;</span><br><span class=\"line\">            samplenum&#x3D;samplenum+sample[0];</span><br><span class=\"line\"> </span><br><span class=\"line\">            fprintf(fp_stat,&quot;%6d,&quot;,samplenum);</span><br><span class=\"line\">            if(cnt%10&#x3D;&#x3D;0)</span><br><span class=\"line\">                fprintf(fp_stat,&quot;\\n&quot;,samplenum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    free(sample);</span><br><span class=\"line\">    fclose(fp);</span><br><span class=\"line\">    fclose(fp1);</span><br><span class=\"line\">    fclose(fp_stat);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"将pcm16le双声道音频采样数据转换为pcm8音频采样数据\">将PCM16LE双声道音频采样数据转换为PCM8音频采样数据</h2>\n<p>本程序中的函数可以通过计算的方式将PCM16LE双声道数据16bit的采样位数转换为8bit。函数的代码如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Convert PCM-16 data to PCM-8 data.</span><br><span class=\"line\"> * @param url  Location of PCM file.</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">int simplest_pcm16le_to_pcm8(char *url)&#123;</span><br><span class=\"line\">    FILE *fp&#x3D;fopen(url,&quot;rb+&quot;);</span><br><span class=\"line\">    FILE *fp1&#x3D;fopen(&quot;output_8.pcm&quot;,&quot;wb+&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">    int cnt&#x3D;0;</span><br><span class=\"line\"> </span><br><span class=\"line\">    unsigned char *sample&#x3D;(unsigned char *)malloc(4);</span><br><span class=\"line\"> </span><br><span class=\"line\">    while(!feof(fp))&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">        short *samplenum16&#x3D;NULL;</span><br><span class=\"line\">        char samplenum8&#x3D;0;</span><br><span class=\"line\">        unsigned char samplenum8_u&#x3D;0;</span><br><span class=\"line\">        fread(sample,1,4,fp);</span><br><span class=\"line\">        &#x2F;&#x2F;(-32768-32767)</span><br><span class=\"line\">        samplenum16&#x3D;(short *)sample;</span><br><span class=\"line\">        samplenum8&#x3D;(*samplenum16)&gt;&gt;8;</span><br><span class=\"line\">        &#x2F;&#x2F;(0-255)</span><br><span class=\"line\">        samplenum8_u&#x3D;samplenum8+128;</span><br><span class=\"line\">        &#x2F;&#x2F;L</span><br><span class=\"line\">        fwrite(&amp;samplenum8_u,1,1,fp1);</span><br><span class=\"line\"> </span><br><span class=\"line\">        samplenum16&#x3D;(short *)(sample+2);</span><br><span class=\"line\">        samplenum8&#x3D;(*samplenum16)&gt;&gt;8;</span><br><span class=\"line\">        samplenum8_u&#x3D;samplenum8+128;</span><br><span class=\"line\">        &#x2F;&#x2F;R</span><br><span class=\"line\">        fwrite(&amp;samplenum8_u,1,1,fp1);</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printf(&quot;Sample Cnt:%d\\n&quot;,cnt);</span><br><span class=\"line\"> </span><br><span class=\"line\">    free(sample);</span><br><span class=\"line\">    fclose(fp);</span><br><span class=\"line\">    fclose(fp1);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>PCM16LE格式的采样数据的取值范围是-32768到32767，而PCM8格式的采样数据的取值范围是0到255。所以PCM16LE转换到PCM8需要经过两个步骤：第一步是将-32768到32767的16bit有符号数值转换为-128到127的8bit有符号数值，第二步是将-128到127的8bit有符号数值转换为0到255的8bit无符号数值。在本程序中，16bit采样数据是通过short类型变量存储的，而8bit采样数据是通过unsigned char类型存储的。</p>\n<h2 id=\"将pcm16le双声道音频采样数据的声音速度提高一倍\">将PCM16LE双声道音频采样数据的声音速度提高一倍</h2>\n<p>本程序中的函数可以通过抽象的方式将PCM16LE双声道数据的速度提高一倍，采用采样每个声道奇(偶)数点的样值的方式，函数的代码如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Re-sample to double the speed of 16LE PCM file</span><br><span class=\"line\"> * @param url  Location of PCM file.</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">int simplest_pcm16le_doublespeed(char *url)&#123;</span><br><span class=\"line\">    FILE *fp&#x3D;fopen(url,&quot;rb+&quot;);</span><br><span class=\"line\">    FILE *fp1&#x3D;fopen(&quot;output_doublespeed.pcm&quot;,&quot;wb+&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">    int cnt&#x3D;0;</span><br><span class=\"line\"> </span><br><span class=\"line\">    unsigned char *sample&#x3D;(unsigned char *)malloc(4);</span><br><span class=\"line\"> </span><br><span class=\"line\">    while(!feof(fp))&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">        fread(sample,1,4,fp);</span><br><span class=\"line\"> </span><br><span class=\"line\">        if(cnt%2!&#x3D;0)&#123;</span><br><span class=\"line\">            &#x2F;&#x2F;L</span><br><span class=\"line\">            fwrite(sample,1,2,fp1);</span><br><span class=\"line\">            &#x2F;&#x2F;R</span><br><span class=\"line\">            fwrite(sample+2,1,2,fp1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printf(&quot;Sample Cnt:%d\\n&quot;,cnt);</span><br><span class=\"line\"> </span><br><span class=\"line\">    free(sample);</span><br><span class=\"line\">    fclose(fp);</span><br><span class=\"line\">    fclose(fp1);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"参考\">参考</h1>\n<p><a href=\"https://blog.csdn.net/leixiaohua1020/article/details/50534316\">视音频数据处理入门：PCM音频采样数据处理</a> --&gt; 致敬雷神！</p>\n<p>​</p>\n","categories":["Signal"],"tags":["PCM","WAV"]},{"title":"MIC LEVEL vs LINE LEVEL--Audio Levels Explained","url":"/2021/04/19/Signal/MIC%20LEVEL%20vs%20LINE%20LEVEL%20Audio%20Levels%20Explained/","content":"<p><a href=\"https://audiouniversityonline.com/mic-level-vs-line-level-audio-levels-explained/\">audiouniversityonline.com</a></p>\n<p>In this post, you’ll learn the difference between microphone level and line level, as well as other levels commonly used in professional audio such as instrument level and speaker level.</p>\n<p>What is the difference between microphone level and line level?</p>\n<p><strong>Microphones and instruments output very low signal voltages, while +4dBu is the line level is the standard voltage level for professional audio equipment.</strong></p>\n<p><strong>In pro audio, you’ll generally be dealing with four types of audio signals: Mic Level, Instrument Level, Line Level, and Speaker Level</strong></p>\n<h1 id=\"microphone-level\">Microphone Level</h1>\n<p>A microphone captures sound by converting pressure changes in the air into electrical currents in a wire. The electrical currents created by these pressure changes are very subtle. That’s why we use a microphone preamp – to amplify the signal to a more usable level.</p>\n<p>A microphone preamp takes in a mic level signal, amplifies it, and outputs a line level signal. This is controlled by the gain knob on your mixing console, audio interface, or outboard mic pre.</p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Mic-Level-Chart-900.jpg\" alt=\"img\" style=\"zoom:50%;\" /></p>\n<h1 id=\"instrument-level\">Instrument Level</h1>\n<p>The pickups of an electric guitar convert the vibrations of the strings into electrical currents. Similar to those from a microphone, the electrical currents from a guitar pickup are very weak.</p>\n<p>A preamp can also be used to boost instrument level signals to line level.</p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Instrument-Level-Chart-900.jpg\" alt=\"img\" style=\"zoom: 50%;\" /></p>\n<p>Once an input signal is brought up to line level, it is optimized for use with professional audio equipment, such as mixing consoles, outboard effects, and amplifiers.</p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Line-Level-Chart-900.jpg\" alt=\"img\" style=\"zoom:50%;\" /></p>\n<h1 id=\"professional-vs-consumer-line-level\">Professional vs Consumer Line Level</h1>\n<p>There are two standards for line level: +4 dBu (professional) and -10 dBV (consumer).</p>\n<p>Watch this video to learn the difference between professional and consumer line level. I also wrote a post on <a href=\"https://audiouniversityonline.com/consumer-vs-professional-audio-levels-what-is-the-difference/\">professional vs consumer audio levels</a> that will help you understand the difference.</p>\n<h1 id=\"speaker-level\">Speaker Level</h1>\n<p>Line level is adequate for sending signals between devices, but not strong enough to power a speaker.In order to power a speaker, the line level signal needs to be amplified again.</p>\n<p>This can be done with a power amplifier. A power amp takes in a line level signal, amplifies it, and outputs a speaker level signal that is strong enough to power a speaker.</p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Speaker-Level-Chart-900.jpg\" alt=\"img\" style=\"zoom:50%;\" /></p>\n<h1 id=\"a-complete-audio-system\">A Complete Audio System</h1>\n<p>In a complete system, you might run a microphone through a preamp and an electric guitar through another preamp.</p>\n<p>Once those signals are at line level, you can send them through outboard effects and eventually to an amplifier, which will add enough gain to the signal to power a speaker.</p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Complete-Chart-900.jpg\" alt=\"img\" style=\"zoom:50%;\" /></p>\n","categories":["Signal"],"tags":["mic","level","audio","line"]},{"title":"VCC、VDD、VEE、VSS的区别","url":"/2021/07/10/Hardware/Circuit/2021-07-10-VCC%E3%80%81VDD%E3%80%81VEE%E3%80%81VSS%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"<h2 id=\"对于晶体管\">对于晶体管</h2>\n<p><strong><em>Vcc</em></strong>：来源于集电极电源电压， <em>Collector Voltage</em>， 一般用于双极型晶体管， PNP 管时为负电源电压， 有时也标成 -Vcc， NPN 管时为正电压</p>\n<p><strong><em>Vdd</em></strong>：来源于漏极电源电压， <em>Drain Voltage</em>， 用于 MOS 晶体管电路， 一般指正电源。 因为很少单独用 PMOS 晶体管， 所以在 CMOS 电路中 Vdd 经常接在 PMOS 管的源极上。</p>\n<p><strong><em>Vss</em></strong>：源极电源电压， 在 CMOS 电路中指负电源， 在单电源时指零伏或接地。</p>\n<p><strong><em>Vee</em></strong>：发射极电源电压， <em>Emitter Voltage</em>， 一般用于 ECL 电路的负电源电压。</p>\n<p><strong><em>Vbb</em></strong>：基极电源电压， 用于双极晶体管的共基电路。</p>\n<h2 id=\"对于电路及芯片\">对于电路及芯片</h2>\n<p><strong><em>VDD</em></strong>：电源电压(单极器件)；芯片电源电压。（Device）</p>\n<p><strong><em>VCC</em></strong>：电源电压(双极器件)；电路电源电压。（Circuit）</p>\n<p><strong><em>VSS</em></strong>：接地端、负极。（Series）</p>\n<p><strong><em>VEE</em></strong>：负电压供电；</p>\n<p><strong><em>VPP</em></strong>：编程/擦除电压。</p>\n","categories":["Hardware"],"tags":["voltage"]},{"title":"IGBT及其驱动芯片规格学习","url":"/2021/07/15/Hardware/Circuit/2021-07-15-IGBT%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8%E8%8A%AF%E7%89%87%E8%A7%84%E6%A0%BC%E5%AD%A6%E4%B9%A0/","content":"<p>[TOC]</p>\n<p>IGBT和其驱动芯片的电气特性、引脚等参数的开发记录。</p>\n<h1 id=\"igbt\">IGBT</h1>\n<p>IGBT芯片选型为 IKW50N65WR5。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210715090401339.png\" alt=\"image-20210715090401339\" /><figcaption aria-hidden=\"true\">image-20210715090401339</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210715093221500.png\" alt=\"image-20210715093221500\" /><figcaption aria-hidden=\"true\">image-20210715093221500</figcaption>\n</figure>\n<p>IGBT有三个极，发射极、集电极 和 栅极。</p>\n<p>从其电气性能表格中，可以看出：</p>\n<ul>\n<li>集电极到发射极的击穿电压 <em>最小</em> 为650V</li>\n<li>在 V<span style=\"font-size: 0.8rem; font-weight: 500;\">GE</span> 完全导通（最高15V）时，集电极到发射极的饱和电压为1.8V以下，此时 IGBT 处于截止状态</li>\n<li>在 V<span style=\"font-size: 0.8rem; font-weight: 500;\">GE</span> 完全截止（0V）时，二极管的正向电压为1.9V以下。<mark> 此时，V<span style=\"font-size: 0.8rem; font-weight: 500;\">CE</span> 处于导通状态。</mark></li>\n</ul>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210715094151439.png\" alt=\"image-20210715094151439\" /><figcaption aria-hidden=\"true\">image-20210715094151439</figcaption>\n</figure>\n<p>从上方表中可以看出，在官方的《开关特性测试情况》下，V<span style=\"font-size: 0.8rem; font-weight: 500;\">GE</span> 的通电情况是 0V 或者 15V，故此推断给此IGBT的栅极电源输入信号应该是0V ~ 15V的方波。</p>\n<p>因此，下图中IGBT器件的电路连接方式为：G 接0/15V方波信号，C 接最高650V电源，E 接地。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210715095656309.png\" alt=\"image-20210715095656309\" /><figcaption aria-hidden=\"true\">image-20210715095656309</figcaption>\n</figure>\n<h1 id=\"driver-ic\">DRIVER IC</h1>\n<p>选用芯片型号为 2EDL05I06PF。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210715102359830.png\" alt=\"image-20210715102359830\" /><figcaption aria-hidden=\"true\">image-20210715102359830</figcaption>\n</figure>\n<p>根据表1索引可得，芯片封装类型为DSO-8，目标驱动芯片是 IGBT，而非 MOSFET。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210715102251417.png\" alt=\"image-20210715102251417\" /><figcaption aria-hidden=\"true\">image-20210715102251417</figcaption>\n</figure>\n<p>再根据图3可得芯片引脚分布，根据表2可得所有引脚描述。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210715095931941.png\" alt=\"image-20210715095931941\" /><figcaption aria-hidden=\"true\">image-20210715095931941</figcaption>\n</figure>\n<p>结合表2和图3，再根据图1的典型应用电路，可以大致知道芯片的连接方法。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>针脚</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>VDD</td>\n<td>芯片供电接口</td>\n</tr>\n<tr class=\"even\">\n<td>GND</td>\n<td>芯片接地接口</td>\n</tr>\n<tr class=\"odd\">\n<td>HIN</td>\n<td>调制波形输入接口——高位</td>\n</tr>\n<tr class=\"even\">\n<td>LIN</td>\n<td>调制波形输入接口——低位</td>\n</tr>\n<tr class=\"odd\">\n<td>VB</td>\n<td>高位正电</td>\n</tr>\n<tr class=\"even\">\n<td>HO</td>\n<td>控制高位IGBT栅极的信号输出接口</td>\n</tr>\n<tr class=\"odd\">\n<td>VS</td>\n<td>高位负电</td>\n</tr>\n<tr class=\"even\">\n<td>LO</td>\n<td>控制低位IGBT栅极的信号输出接口</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>还是不太明白VB和VS的作用</p>\n</blockquote>\n<p>表4给出了 V<span style=\"font-size: 0.8rem; font-weight: 500;\">DD</span> 和 V<span style=\"font-size: 0.8rem; font-weight: 500;\">B</span> 的供电范围：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210715105358524.png\" alt=\"image-20210715105358524\" /><figcaption aria-hidden=\"true\">image-20210715105358524</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210715105816397.png\" alt=\"image-20210715105816397\" /><figcaption aria-hidden=\"true\">image-20210715105816397</figcaption>\n</figure>\n<p>表6 给出了输入 V<span style=\"font-size: 0.8rem; font-weight: 500;\">IN</span> 的逻辑电平高低的电压范围，高电平为1.7 ~ 2.4 V， 低电平为0.7 ~ 1.1V。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210715103507327.png\" alt=\"image-20210715103507327\" /><figcaption aria-hidden=\"true\">image-20210715103507327</figcaption>\n</figure>\n<p>图2 提供了驱动芯片内部结构示意图</p>\n<p>概括地说，IGBT栅极驱动器是一个放大器，其通过提高电压和电流来放大控制信号。</p>\n<p>栅极驱动器的主要作用是对 <mark>IGBT的输入和反向输出电容放电</mark>。因此栅极驱动器（初其他影响因素外）与IGBT的开关性能密切相关，也与通态损耗与开关损耗有关。</p>\n<p>绝大多数IGBT驱动器都是基于电压源的，与电流源驱动器相比，电压源的优势是其功率损耗在栅极电阻上，而非驱动中的电流源内。通过栅极电阻，可以调整最大的栅极电流。另一优势是，电压源相对简单的电路和控制方法。</p>\n<h2 id=\"驱动功能\">驱动功能</h2>\n<p>IGBT驱动电路为系统提供的功能：</p>\n<ol type=\"1\">\n<li>在IGBT开通过程中，栅极处的电容充电直到IGBT的开通阈值电压，反向传输电容（密勒电容）也如此。</li>\n<li>在IGBT关断过程中，输入电容放电直到栅极电压达到关断阈值电压以下，反向传输电容（密勒电容）也如此。</li>\n<li>IGBT驱动可以具有保护IGBT免受损坏的功能，如 <strong>避免IGBT短路</strong> 和 <strong>过电压保护</strong>。</li>\n</ol>\n<h2 id=\"驱动供电\">驱动供电</h2>\n<p>大部分情况下，IGBT驱动需要用隔离的供电电源。隔离电源可以看做是IGBT驱动的一部分。这些电源一般由 <strong>DC-DC变换器</strong> 或 <strong>自举电路</strong> 构成。</p>\n<p>同时，驱动会影响IGBT和续流二极管的动态特性，此外仍须确保IGBT输入电路电压（低压侧）和输出电路（高压侧）的电压隔离。<mark>低压侧与控制电路连接，高压侧与IGBT电路连接。</mark></p>\n<h2 id=\"信号传输\">信号传输</h2>\n<p>阿博说的电路PCB布局要点：强弱隔离，数模隔离，信号沿地。</p>\n<p>IGBT需要隔离的控制信号 包括： <strong>开通信号</strong>、<strong>关断信号</strong>、<strong>反馈信号</strong>。</p>\n<p>这些控制信号的传输路径的隔离是通过 <strong>电隔离</strong> 或 <strong>非电隔离</strong> 的方式形成的，这种电隔离被进一步划分为基于磁感应的、光学的隔离，极少情况下是电容性的隔离。需要通过 <strong><em>IGBT阻断电压</em></strong> 或 <strong><em>应用电压的高低</em></strong> 来判断组个方式，在 高压应用 或 IGBT阻隔电压 U<span style=\"font-size: 0.6rem;\">CES</span> 高至 <code>1.2kV</code> 时，采用磁感应式 或 光学式信号传送器；在 低压 或 中压 应用中 或 低于 <code>1.2kV</code> 时，采用光电耦合驱动芯片。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210717130119184.png\" alt=\"image-20210717130119184\" style=\"zoom:50%;\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n图 Infineon对电气隔离的定义\n</div>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210717115141036.png\" alt=\"image-20210717115141036\" /><figcaption aria-hidden=\"true\">image-20210717115141036</figcaption>\n</figure>\n<h3 id=\"光电耦合器\">光电耦合器</h3>\n<p>光电耦合器就是一种可以实现IGBT驱动的同时实现强弱电隔离的器件。由于光电耦合器的结构设计，集成光电耦合器的IGBT只能实现信息传递，不能为任何设备提供充足的能量支撑，需要一个隔离电源为驱动核心和光电耦合器的二次侧（高压侧）提供电能。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210717113118307.png\" alt=\"image-20210717113118307\" style=\"zoom:80%;\" /></p>\n<p>另外有个相当重要的参数需要考虑——<strong><em>传输延迟时间</em></strong>，即 信号从光电耦合器IGBT输入到控制电流输出的时间。常规而言，传播延迟时间 <em>t</em><span style=\"font-size: 0.6rem;\">PLH</span> 和 <em>t</em><span style=\"font-size: 0.6rem;\">PHL</span> 在几百个纳秒时间，但通常大于200ns。这种延时本身不会构成真正的问题，因为微控制器的控制算法可以考虑这一点，最大的问题在于 延时的公差（传输延迟时间不匹配），即最小和最大延时的不一致性。一旦该公差越大，上下桥臂的IGBT死区时间 <em>t</em><span style=\"font-size: 0.6rem;\">DT</span> 就越大，加重了逆变器输出电流的失真影响。光电耦合器里信号延迟的误差因为操作使用会发生巨大变化，最终可导致高达1us的偏差。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210717114405335.png\" alt=\"image-20210717114405335\" /><figcaption aria-hidden=\"true\">image-20210717114405335</figcaption>\n</figure>\n<h3 id=\"脉冲变压器\">脉冲变压器</h3>\n<p>利用脉冲变压器为信号传输的IGBT，可以达到较低的延时水平，但与光电耦合器一样，只能传输信号，提供所需能量仍需由隔离电源提供。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210717115333071.png\" alt=\"image-20210717115333071\" /><figcaption aria-hidden=\"true\">image-20210717115333071</figcaption>\n</figure>\n<h3 id=\"单片电平转换器\">单片电平转换器</h3>\n<p><strong>单片电平转换器</strong>，即 仅通过一个集成电路来实现 输入信号 和 输出信号 之间的隔离。需要注意的是，并不想光耦、变压器、脉冲等技术的完全绝缘的电气隔离，如果出现差错（如输出侧寄生电感产生的负电压瞬变），电路高压侧和地压侧将会直接连在一起（导致内部集成芯片的损坏）。将 <strong><em>SOI（绝缘硅）技术</em></strong> 应用于电平转换器可以解决这一缺陷，Infineon的产品大多都应用这项技术。这样的SOI装置不是由PN结反向偏置来提供内部电路隔离的，而是通过一层绝缘层（通常是二氧化硅 SiO2）来为不同的内部电路提供隔离，其反向电压耐压高达较高（因产品而不同）。</p>\n<p>单片电平转换器主要应用于 U<span style=\"font-size: 0.6rem;\">CES</span> 低于 600V 的IGBT，通常一个驱动器有六路输出。但是在驱动 1.2kV 以上时，其驱动芯片和其他驱动方式相比成本劣势较少采用。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210717122123709.png\" alt=\"image-20210717122123709\" /><figcaption aria-hidden=\"true\">image-20210717122123709</figcaption>\n</figure>\n<div style=\"text-align: center; font-weight: 900;\">\n图 带电平转换器的IGBT工作原理\n</div>\n<h1 id=\"产品概念\">产品概念</h1>\n<p>栅极驱动芯片 又可以称作 门极驱动芯片。按照门极驱动结构类型可以分为 <strong>单通道</strong>、<strong>双通道</strong>、<strong>四通道</strong> 和 <strong>六通道</strong>，又进一步划分 <strong>高边</strong>、<strong>地边</strong>、<strong>高低边</strong>、<strong>半桥</strong>、<strong>全桥</strong>、<strong>三相</strong>。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210717125203004.png\" alt=\"image-20210717125203004\" /><figcaption aria-hidden=\"true\">image-20210717125203004</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210717125219691.png\" alt=\"image-20210717125219691\" /><figcaption aria-hidden=\"true\">image-20210717125219691</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210717125337142.png\" alt=\"image-20210717125337142\" /><figcaption aria-hidden=\"true\">image-20210717125337142</figcaption>\n</figure>\n<h2 id=\"eicedriver\">EiceDriver</h2>\n<p>下图为Infineon提供的栅极驱动芯片品类示意：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210717120650887.png\" alt=\"image-20210717120650887\" /><figcaption aria-hidden=\"true\">image-20210717120650887</figcaption>\n</figure>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li><a href=\"https://storage.islet.space/01_Learning/12_Hardwares/03_Semiconductor/IGBT%E6%A8%A1%E5%9D%97%EF%BC%9A%E6%8A%80%E6%9C%AF%E9%A9%B1%E5%8A%A8%E5%92%8C%E5%BA%94%E7%94%A8.pdf\">《IGBT模块：技术驱动和应用》</a></li>\n<li><a href=\"https://toshiba.semicon-storage.com/content/dam/toshiba-ss/shared/docs/design-support/document/Reference-design/application-note/MOSFET-Gate-Drive-Circuit-Application-Notes_EN_36267-CN.pdf\">《MOSFET 栅极驱动电路》</a></li>\n<li><a href=\"https://www.infineon.com/dgdl/Infineon-Power_and_Sensing-ProductSelectionGuide-v00_01-EN.pdf?fileId=5546d4625607bd13015621522aa012cb&amp;da=t\">《Infineon-Power_and_Sensing-ProductSelectionGuide-v00_01-EN》</a></li>\n<li><a href=\"https://www.infineon.com/dgdl/Infineon-EiceDRIVER_Gate_Driver_ICs-ProductSelectionGuide-v01_01-CN.pdf?fileId=5546d46269e1c019016ab0ec653015cc\">《Infineon-EiceDRIVER_Gate_Driver_ICs-ProductSelectionGuide-v01_01-CN》</a></li>\n</ol>\n","categories":["Hardware"],"tags":["IGBT","MOSFET"]},{"title":"电隔离和非电隔离","url":"/2021/07/17/Hardware/Circuit/2021-07-17-%E7%94%B5%E9%9A%94%E7%A6%BB%E5%92%8C%E9%9D%9E%E7%94%B5%E9%9A%94%E7%A6%BB/","content":"<p>在产品设计时，倘若没有考虑应用环境对电源隔离的要求，产品到了应用时就会出现因设计方案的不当导致的系统不稳定，甚至出现高压损坏后级负载的情况，以及出现危害人身财产安全的情况。因此产品设计是否需要隔离至关重要。</p>\n<h1 id=\"定义\">定义</h1>\n<p><strong>隔离电源</strong>：电源的输入回路和输出回路之间没有直接的电气连接，输入和输出之间是绝缘的高阻态，没有电流回路。</p>\n<p><img src=\"https://pic.islet.space/2021/07/60935d50373e5-thumb.png\" alt=\"img\" style=\"zoom:67%;\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n图1 采用变压器的隔离电源\n</div>\n<p><strong>非隔离电源</strong>：输入和输出之间有直接的电流回路，例如，输入和输出之间是共地的。以隔离的反激电路和非隔离的BUCK电路为例。</p>\n<p><img src=\"https://pic.islet.space/2021/07/60935d4fef66f-thumb.png\" alt=\"img\" style=\"zoom:67%;\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n图2 非隔离电源\n</div>\n<p><img src=\"https://pic.islet.space/2021/07/60935d5048313-thumb.png\" alt=\"img\" style=\"zoom:50%;\" /></p>\n<h1 id=\"优缺点对比\">优缺点对比</h1>\n<p>由上述概念可知，对于常用的电源拓扑而言，非隔离电源主要有：<strong><em>Buck</em></strong>、<strong><em>Boost</em></strong>、<strong><em>Buck-Boost</em></strong>等。而隔离电源主要有各种带隔离变压器的 <strong><em>反激</em></strong>、<strong><em>正激</em></strong>、<strong><em>半桥</em></strong>、<strong><em>LLC</em></strong> 等拓扑。</p>\n<p>结合常用的隔离与非隔离电源，我们从直观上就可得出它们的一些优缺点，两者的优缺点几乎是相反的。使用隔离或非隔离的电源，需了解实际项目对电源的需求是怎样的。</p>\n<p>隔离和非隔离电源的主要差别在于 隔离模块的可靠性高，但成本高，效率差点。非隔离模块的结构很简单，成本低，效率高，安全性能差。因此，在如下几个场合，建议用隔离电源：</p>\n<ol type=\"1\">\n<li></li>\n</ol>\n<p>总结的表如表1所示，两者的优缺点几乎是相反的。</p>\n<div style=\"text-align: center; font-weight: 900;\">\n表1 隔离电源和非隔离电源的优缺点\n</div>\n<p><img src=\"https://pic.islet.space/2021/07/60935d504e874-thumb.png\" alt=\"img\" style=\"zoom:80%;\" /></p>\n<h1 id=\"适用场景\">适用场景</h1>\n<p>一般场合使用对模块电源隔离电压要求不是很高，但是 <mark> 更高的隔离电压可以保证模块电源具有更小的漏电流，更高的安全性和可靠性，并且 <strong><em>EMC特性</em></strong> 也更好一些</mark>，因此目前业界普遍的隔离电压水平为1500VDC以上。</p>\n<p>了解了隔离与非隔离电源的优缺点，对于一些常用的嵌入式供电，其对应的场景及推荐隔离方案如下：</p>\n<ol type=\"1\">\n<li>系统前级的电源，为提高抗干扰性能，保证可靠性，一般用隔离电源。</li>\n<li>对安全有要求的场合，如需接市电的AC-DC，或医疗用的电源和白色家电，为保证人身的安全，必须用隔离电源，有些场合还必须用加强隔离的电源。</li>\n<li>对于远程工业通信的供电，为有效降低地电势差和导线耦合干扰的影响，为每个通信节点单独供电一般都用隔离电源。</li>\n<li>内部IC或部分电路供电，从性价比和体积出发，优先选用非隔离电源。</li>\n<li>对于采用电池供电，<mark>对续航力要求严苛的场合，采用非隔离供电</mark>。</li>\n</ol>\n<h3 id=\"隔离电源\">隔离电源</h3>\n<ol type=\"1\">\n<li><p>涉及可能触电的场合，如从电网取电，转成低压直流的场合，需用隔离的AC-DC电源；</p></li>\n<li><p>串行通信总线通过RS-232、RS-485和控制器局域网(CAN)等物理网络传送数据，这些相互连接的系统每个都配备有自己的电源，而且各系统之间往往间隔较远，因此，我们通常需要隔离电源进行电气隔离来确保系统的物理安全，且通过隔离 <mark style=\"font-style: Italic; font-weight: 900;\">切断接地回路</mark>，来保护系统免受瞬态高电压冲击，同时减少信号失真；</p></li>\n<li><p>对外的I/O端口，为保证系统的可靠运行，也建议对I/O端口做电源隔离。</p></li>\n</ol>\n<h3 id=\"非隔离电源\">非隔离电源</h3>\n<p>电路板内的IC或部分电路供电，从性价比和体积出发，优先选用非隔离的方案；如MPS的MP150/157/MP174系列buck型非隔离AC-DC，适合于1~5W应用；</p>\n<p>对于工作电压低于36V，采用电池供电，对续航力要求严苛的场合，优先采用非隔离供电，如MPS的MP2451/MPQ2451。</p>\n<h1 id=\"隔离电源模块选型的注意事项\">隔离电源模块选型的注意事项</h1>\n<p>电源的隔离耐压在GB-4943国标中又叫抗电强度，这个GB-4943标准就是我们常说的信息类设备的安全标准，就是为了防止人员受到物理和电气伤害的国家标准，其中包括避免人受到电击伤害、物理伤害、爆炸等伤害。如下图为隔离电源结构图。</p>\n<p><img src=\"https://pic.islet.space/2021/07/60935d4fe8f0d-thumb.png\" alt=\"img\" style=\"zoom:120%;\" /></p>\n<div style=\"text-align: center; font-weight: 900;\">\n图 隔离电源结构\n</div>\n<p>作为模块电源的重要指标，标准中也规定了隔离耐压相关测试方法，简单的测试时一般采用等电位连接测试，连接示意图如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/60935d4fc9c96-thumb.png\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<div style=\"text-align: center; font-weight: 900;\">\n图 隔离耐压测试示意\n</div>\n<h2 id=\"测试方法\">测试方法</h2>\n<ol type=\"1\">\n<li><p>将耐压计的电压设为规定的耐压值，电流设为规定的漏电流值，时间设为规定的测试时间值；</p></li>\n<li><p>操作耐压计开始测试，开始加压，在规定的测试时间内，模块应无击穿，无飞弧现象。</p></li>\n<li><p>注意在测试时焊接电源模块要选取合适的温度，避免反复焊接，损坏电源模块。</p></li>\n<li><p>除此之外还要注意：</p>\n<ol type=\"1\">\n<li>要注意是AC-DC还是DC-DC。</li>\n<li>隔离电源模块的隔离耐压。例如隔离1000V DC 是否满足绝缘要求。</li>\n<li>隔离电源模块是否有进行全面的可靠性测试。电源模块要经过性能测试、容差测试、瞬态条件测试、可靠性测试、EMC电磁兼容测试、高低温测试、极限测试、寿命测试、安规测试等。</li>\n<li>隔离电源模块的生产工厂产线是否规范。电源模块生产线需要通过ISO9001, ISO14001，OHSAS18001等多项国际认证，如下图3所示。</li>\n<li>隔离电源模块是否有应用在工业、汽车等恶劣环境。电源模块不仅仅大量应用与恶劣的工业环境，同时在新能源汽车的BMS管理系统中也游刃有余。</li>\n</ol></li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/60935d503580c-thumb.png\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<div style=\"text-align: center; font-weight: 900;\">\n图 ISO认证\n</div>\n<h1 id=\"总结\">总结</h1>\n<p>很多人认为非隔离电源不如隔离电源好，因为隔离电源贵，所以肯定贵的就好。前几年非隔离的稳定性确实没有隔离稳定，但随着研发技术的更新，现如今非隔离已经非常成熟，日渐稳定。说到安全性，其实现在非隔离电源也是很安全的，只要在结构稍微做下改动，对人体还是很安全的，同样的道理，非隔离电源也是可以过很多安规标准，例如:ULTUVSAACE等。</p>\n<p>实际上非隔离电源损坏的根源就是电源AC线两端的浪涌电压所致，也可以这么说，雷击浪涌吧，这种电压是加在电压AC线两端的瞬间高压，有时高达三千伏，但时间很短，能量却极强，在打雷时会发生，或是在同一条AC线上，当一个大的负载断开瞬间，因为电流惯性的原因也会发生，这个电压进入电源，对于非隔离BUCK电路，会瞬间传达到输出，击坏恒流检测环，或是进一步击坏芯片，造成300v直通，而烧掉整条灯管。对于隔离反激电源，会击坏MOS,现象就是保管，芯片，MOS管全烧坏。现在LED驱动电源，在使用过程中坏的，80%以上都是这两种类似现象。而且，小型开关电源，就算是电源适配器，也经常损坏的是这个现象，均是浪涌电压所致，而在LED电源里，表现的更加普遍，这是因为LED的负载特性是特别的怕浪涌电压的。</p>\n<p>如果按照一般的理论来讲，电子电路里，元器件越少，可靠性越高，相应越多的元件的电路板可靠性则越低。实际上非隔离电路的元件是比隔离电路要少的，为什么隔离电路可靠性高。其实说白了，不是什么可靠性，而是 <mark>非隔离电路对于浪涌太敏感，抑制能力差</mark>，隔离电路，因为能量是先进入变压器，然后从变压器再输送到LED负载的。BUCK电路是输入电源一部分直接加在了LED负载上，故前者对浪涌抑制和衰减能力强，所以浪涌来时损坏的机率小而已。实际上，非隔离电源的问题主要是在于浪涌问题，目前这个问题，因为只有LED灯具在大批量应用时，从概率上才能看出其解决的程度，所以很多人没有提出好的防治办法，更多的人则是不知道浪涌电压为何物。LED灯具坏了，很多人也找不到原因，最后只能一句，什么此电源不稳定就了结了，具体哪里不稳定，他不知道。</p>\n<p>非隔离电源的优势一是效率，二是成本。</p>\n<p>非隔离电源适合的场合：首先，是室内的灯具，这种室内用电环境较好，浪涌影响小。第二，使用的场合是高压小电流，低压大电流用非隔离没有意义，因为低压大电流非隔离的效率并不比隔离的高，成本也低不到多少去。第三，电压相对较稳定的环境中使用非隔离电源。当然，如果有办法解决掉抑制浪涌的问题，那么非隔离电源的应用范围将大大拓宽！</p>\n<p>隔离电源因为浪涌的问题，损坏率也不可小觑，一般那种返修回来，击坏保险，芯片，MOS的第一个应该想到是浪涌问题。为了减少损坏率，在设计时就行要考虑到浪涌的因素进去，或是在使用时要告戒用户，尽量避免浪涌发生。（如室内灯具，打雷时暂时先关掉）</p>\n<p>综合所述，使用隔离与非隔离很多时候都是因为浪涌这个问题，而浪涌问题和用电环境是息息相关的，所以很多时候使用隔离电源和非隔离电源不能一刀切，非隔离电源在节能，成本上都是很有优势的，所以要科学的选用非隔离还是隔离作为LED驱动电源。</p>\n","categories":["Hardware"],"tags":["circuit","隔离"]},{"title":"NTC热敏电阻","url":"/2021/08/21/Hardware/Circuit/2021-08-21-NTC%E7%83%AD%E6%95%8F%E7%94%B5%E9%98%BB/","content":"<h1 id=\"ntc及热敏电阻\">NTC及热敏电阻</h1>\n<p><strong>NTC</strong>（<em>Negative Temperature Coefficient</em>）是指 <mark>随温度上升电阻呈指数关系减小、具有负温度系数的热敏电阻现象和材料</mark>。</p>\n<p>该类材料是利用锰、铜、硅、钴、铁、镍、锌等两种或两种以上的金属氧化物进行充分混合、成型、烧结等工艺而成的半导体陶瓷，可制成具有负温度系数（NTC）的热敏电阻。其 <strong>电阻率</strong> 和 <strong>材料常数</strong> 随材料成分比例、烧结气氛、烧结温度和结构状态不同而变化。现在还出现了以碳化硅、硒化锡、氮化钽等为代表的非氧化物系NTC热敏电阻材料。</p>\n<blockquote>\n<p>1834年，科学家首次发现了硫化银有 <strong>负温度系数</strong> 的特性。</p>\n<p>1930年，科学家发现氧化亚铜-氧化铜也具有负温度系数的性能，并将之成功地运用在航空仪器的温度补偿电路中。随后，由于晶体管技术的不断发展，热敏电阻器的研究取得重大进展。</p>\n<p>1960年研制出了NTC热敏电阻器。NTC热敏电阻器广泛用于测温、控温、温度补偿等方面。</p>\n</blockquote>\n<p><strong>热敏电阻</strong> （<em>Thermistor</em>）也可作为电子线路元件用于仪表线路温度补偿和温差电偶冷端温度补偿等。利用NTC热敏电阻的自热特性可实现自动增益控制，构成RC振荡器稳幅电路，延迟电路和保护电路。在自热温度远大于环境温度时阻值还与环境的散热条件有关，因此在流速计、流量计、气体分析仪、热导分析中常利用热敏电阻这一特性，制成专用的检测元件。</p>\n<p><strong>功率型NTC热敏电阻</strong> 多用于电源抑制浪涌。抑制浪涌用NTC热敏电阻器，是一种大功率的圆片式热敏电阻器，常用于有电容器、加热器和马达启动的电子电路中。 在电路电源接通瞬间，电路中会产生比正常工作时高出许多倍的浪涌电流，而NTC热敏电阻器的初始阻值较大，可以抑制电路中过大的电流，从而保护其电源电路及负载。当电路进入正常工作状态时，热敏电阻器由于通过电流而引起阻体温度上升，电阻值下降至很小，不会影响电路的正常工作。</p>\n<h1 id=\"b值特性\">B值特性</h1>\n<p>热敏电阻的 <strong>B值</strong>（B-value） 是NTC的属性之一，B值简单的说就是 <strong>材料系数</strong>（<em>Material Coefficient</em>）。</p>\n<p><strong>相同温度区间不同的B值</strong>，说明材料可能不一样，因为NTC热敏电阻是负温度系数温度升高阻值成规律下降，B值代表曲线的弯曲程度或者说温度的敏感指数，单位温度变化的时候阻值增幅程度就代表B值。</p>\n<p>通俗的说，即当温度降低，阻值曲线发生变化时会陡一点还是平一点。一般来说B值越大曲线越陡，当曲线越陡说明电阻值的变化就越大，相对来说就灵敏些；B值越小曲线越平，当曲线越平说明电阻值的变化就没那么大，相对来说阻值温度系数也就越小。</p>\n<p><strong>注意</strong>：B值是 <u>经由人为计算出来的</u> 逼近某款热敏电阻 <u>在某个温度区间内的</u> 温度阻值特性曲线的 常数/系数。</p>\n<p>因为B值反映的是 <strong>两个温度点之间</strong> 的阻值变化规律，可以用以下公式来计算，以每摄氏度的百分比 <code>％/°C​​</code> 为单位。 <span class=\"math display\">\\[\nB = {ln(R_{T1}) - ln(R_{T2})\\over {1 \\over {T_1}} -{ 1 \\over T_2}}\n\\]</span></p>\n<blockquote>\n<p>$ R1 $ 或 $ RT1 $：温度T1的时候零功率电阻值</p>\n<p>$ R2 $​ 或 $ RT2 $​​：温度T2的时候零功率电阻值</p>\n<p>T1 = 273.15 k + (T1℃)</p>\n<p>T2 = 273.15 k + (T2℃)</p>\n</blockquote>\n<p>除非特别指出，B值通常是在[25, 50]这个温度范围中进行测量，由 <code>T1 = 25℃（298.15K）</code> 和 <code>T2 = 50℃（323.15K）</code> 时的零功率电阻值计算而得。</p>\n<p>根据式1，若已知B值的情况下，可以得出目标温度对应的阻值，如下式2： <span class=\"math display\">\\[\nR_{T2} = R_{T1} * e^{B * ({1 \\over T_2} - {1 \\over T_1})}\n\\]</span></p>\n<blockquote>\n<p>e = 2.718281828459045</p>\n</blockquote>\n<h1 id=\"温度系数\">温度系数</h1>\n<p>NTC热敏电阻的 <strong>温度系数</strong> 定义为 <mark>相对于温度变化的阻值的相对变化</mark>。计算NTC <strong>热敏电阻温度系数</strong> 的最简单转换公式如下： <span class=\"math display\">\\[\nα = {-β \\over T^2}\n\\]</span></p>\n<blockquote>\n<p><strong>β</strong>：B常数</p>\n<p><strong>T</strong>：25摄氏度时的电阻值</p>\n</blockquote>\n<p>最终结果之所以带上负号，因为是“负温度系数”啊，不带的话就是“正温度系数”。</p>\n<h1 id=\"阻值特性表\">阻值特性表</h1>\n<p>厂家在提供热敏电阻电气特性时都会给出B值，但并不是是就不需要阻值特性表了。</p>\n<p>使用B值并能够推算出全部想要的温度阻值，因为B值所描述的是某个温度区间内的温度和阻值关系，而热敏电阻所呈现的是温度与阻值的非线性关系，也就是说这种关系没法通过B值和公式准确描述全部温度区间的阻值关系。否则一旦不同厂家的热敏电阻其B值相同，用公式来推导那岂不是阻值全是一样。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210821102248552.png\" alt=\"image-20210821102248552\" /><figcaption aria-hidden=\"true\">image-20210821102248552</figcaption>\n</figure>\n<div style=\"font-size: 0.8rem; font-weight: 900; text-align: center;\">\n某温度-阻值特性表示例\n</div>\n<p>例如，[-25℃ ~ 50℃]内的B值已给出，意思就是说在25~50度这个区间用公式是完全没有问题的，超出这个范围，那么B值是不同的，所以不在这个范围用公式得出的阻值也是不对的。</p>\n<p>如下图所示，为三款B值相同的热敏电阻，然而其阻值却不同。由此可知，B值只是一个针对每款热敏电阻的某区间参数，它只反应此热敏电阻的部分特性，并不是一个严谨的参数，在实际应用中，需要提供检测温度范围内的阻值表才是正确的做法。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/pIYBAF4On2WAc2XpAAC6ucLpfUY488.png\" alt=\"热敏电阻应用详解\" /><figcaption aria-hidden=\"true\">热敏电阻应用详解</figcaption>\n</figure>\n<p>B值的范围一般在1800K ~ 5800k，其测温点范围通常为 [25, 50]、[25, 85]、 [0, 100] 或 [0, 50]，部分厂家可以提供特殊NTC热敏电阻 <u>B值的定制</u>。</p>\n<h1 id=\"案例\">案例</h1>\n<p>假设客户订购10,000 W热敏电阻，其热敏电阻的精度为±0.5°C。部件号为MF52A-103，B值为3950 K.25°C（298.15 K）。</p>\n<p>根据 式3 求其 <strong>热敏电阻温度系数</strong> α ： <span class=\"math display\">\\[\nα = -{3950K \\over (298.15K)^2} \n = - 4.44 \\%/℃\n\\]</span> 根据热敏电阻温度系数 α 和 其器件精度求得 25℃时的温度容差为： <span class=\"math display\">\\[\nResistance \\ Tolerance\\ @25℃ = α *（±0.5℃） = -4.44\\%/℃ * （±0.5℃） = ± 2.22\\% \\ @25℃\n\\]</span></p>\n<h2 id=\"电气特性\">电气特性</h2>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210821095249164.png\" alt=\"image-20210821095249164\" /><figcaption aria-hidden=\"true\">image-20210821095249164</figcaption>\n</figure>\n<ul>\n<li><strong>电阻值</strong>：R25 = 50kΩ ± 2% 。即在25摄氏度下，其阻值为50k欧姆，阻值允差为百分之二。</li>\n<li><strong>B常数</strong>： B25/50 = 3950K ± 2% 。即该NTC热敏电阻的材料系数B值，在25摄氏度至50摄氏度之间的B常数为3950K，允差为百分之二。</li>\n</ul>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li><a href=\"http://www.elecfans.com/yuanqijian/ptc/202001031148953.htm\">热敏电阻应用与参数详解</a></li>\n<li><a href=\"https://baike.baidu.com/item/NTC/16035\">NTC</a></li>\n</ol>\n","categories":["Hardware"],"tags":["NTC","热敏电阻"]},{"title":"TI开发笔记","url":"/2021/01/01/Hardware/DSP/2021-01-01-TI%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","content":"<p>[TOC]</p>\n<h1 id=\"sysbios\">SYS/BIOS</h1>\n<ul>\n<li><p>The Ethernet Media Access Controller (EMAC) module provides an efficient interface between the device core processor and the networked community.</p></li>\n<li><p>The EMAC controls the flow of packet data from the processor to the PHY. The MDIO module controls PHY configuration and status monitoring.</p></li>\n<li><p>Both the EMAC and the MDIO modules interface to the DSP through a custom interface that allows efficient data transmission and reception.</p></li>\n<li><p>This custom interface is referred to as the EMAC control module, and is considered integral to the EMAC/MDIO peripheral.</p></li>\n<li><p>The EMAC control, EMAC, and MDIO modules all have control registers. These registers are memory <strong>mapped into device memory space</strong> via the device configuration bus.【EMAC控制器、EMAC、MDIO模块都有控制寄存器，寄存器地址通过设备控制总线写入设备内存空间。】</p></li>\n<li><p>【Descriptor 不存储任何缓冲数据，仅仅作为数据描述包而存在。主要结构为pNext、pBuffer、Buffer Offset、Buffer Length、Flags和Packet Length。其中，pBuffer是指向数据包Packet的指针存储块。】</p></li>\n</ul>\n<h2 id=\"preparation\">Preparation</h2>\n<h3 id=\"ide-installation\">IDE Installation</h3>\n<h4 id=\"setup\">SETUP</h4>\n<h4 id=\"configurations\">CONFIGURATIONS</h4>\n<h3 id=\"project\">Project</h3>\n<h4 id=\"开发及编译环境\">开发及编译环境</h4>\n<ol type=\"1\">\n<li>CSS安装</li>\n<li>TI编译工具安装</li>\n<li>SYS/BIOS安装</li>\n<li>BIOS-MCSDK软件包安装</li>\n<li>BIOS-MCSDK软件包<em>补丁</em>安装</li>\n<li>XDC-Tools安装</li>\n<li>pdk_C6657软件包</li>\n</ol>\n<table>\n<thead>\n<tr class=\"header\">\n<th>安装流程</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong>CCS安装</strong></td>\n<td>CCS工程操作本体软件</td>\n</tr>\n<tr class=\"even\">\n<td><strong>TI编译工具安装</strong></td>\n<td>TI某型号设备编译软件，一定要确保是否安装，没有的话无法生成工程文件</td>\n</tr>\n<tr class=\"odd\">\n<td><strong>SYS/BIOS安装</strong></td>\n<td>SYS/BIOS RTOS系统（可能安装BIOS_MCSDK时自带）</td>\n</tr>\n<tr class=\"even\">\n<td><strong>BIOS-MCSDK软件包安装</strong></td>\n<td>安装时会生成 <code>ndk_2_21_01_38</code>，需要删除，不删除会导致后面无法安装其他软件包</td>\n</tr>\n<tr class=\"odd\">\n<td><strong>BIOS-MCSDK软件包<em>补丁</em>安装</strong></td>\n<td>必须安装，否则会出错</td>\n</tr>\n<tr class=\"even\">\n<td><strong>XDC-Tools安装</strong></td>\n<td>装CSS的时候就已经能自带XDC-Tools了，也可以单独更新版本</td>\n</tr>\n<tr class=\"odd\">\n<td><strong>pdk_C6657软件包</strong></td>\n<td>安装BIOS_MCSDK时自带</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意：</strong></p>\n<ul>\n<li>部分SDK、组件包可能会线下兼容，但是版本包带不带特殊标识，如XDCTOOLS个别版本带 <code>_core</code> 的，可能会导致不兼容<code>gr</code> platform。</li>\n<li>组件包安装完毕之后需要在 CCS 的 <code>Products and Repositories</code> 中进行挂载和选择。</li>\n</ul>\n<h4 id=\"工程生成导入与重编\">工程生成、导入与重编</h4>\n<p>工程的生成、导入与重编主要是针对他人写的代码，未针对我的硬件生成对应的工程文件，因而需要按照我的编译环境和硬件生成对应的工程文件，进而应用到我的硬件上。</p>\n<h5 id=\"工程生成\">工程生成</h5>\n<p>通过执行命令行工具 <code>pdksetupenv.bat</code> 和 <code>pdkProjectCreate.bat</code> 在对应的工程文件包生成工程文件夹 <code>project</code> 。</p>\n<p><strong>注意事项：</strong></p>\n<blockquote>\n<p><em>命令行工具中设置了一些关于路径的变量，如果安装了更新版本的软件包则因进入命令行文件对相应的文件路径进行修改。</em> 如下，XDC-TOOLS 可能因为版本问题而导致 <code>XDC_INSTALL_PATH</code> 变量出错，各变量也应一一对照安装路径的文件夹名称进行审核。</p>\n<p><code>pdksetupenv.bat</code> 文件下的变量设置：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> MCSDK_INSTALL_PATH=D:\\TexasInstruments\\</span><br><span class=\"line\"><span class=\"built_in\">set</span> XDC_INSTALL_PATH=<span class=\"variable\">%MCSDK_INSTALL_PATH%</span>\\xdctools_3_25_06_96</span><br></pre></td></tr></table></figure>\n<p><code>pdkProjectCreate.bat</code> 文件下的变量设置如下：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">@REM 需修改成实际安装路径</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> CCS_INSTALL_PATH=&quot;D:\\ti\\ccsv7&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">@REM 以下各文件版本需要根据当前最新使用的软件包版本来调整</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> CGT_VERSION=<span class=\"number\">8</span>.<span class=\"number\">3</span>.<span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> XDC_VERSION=<span class=\"number\">3</span>.<span class=\"number\">32</span>.<span class=\"number\">2</span>.<span class=\"number\">25</span>_core</span><br><span class=\"line\"><span class=\"built_in\">set</span> BIOS_VERSION=<span class=\"number\">6</span>.<span class=\"number\">33</span>.<span class=\"number\">06</span>.<span class=\"number\">50</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> IPC_VERSION=<span class=\"number\">1</span>.<span class=\"number\">24</span>.<span class=\"number\">03</span>.<span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> EDMA_VERSION=<span class=\"number\">02</span>.<span class=\"number\">11</span>.<span class=\"number\">05</span>.<span class=\"number\">02</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> NDK_VERSION=<span class=\"number\">2</span>.<span class=\"number\">21</span>.<span class=\"number\">02</span>.<span class=\"number\">43</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> PDK_VERSION=<span class=\"number\">1</span>.<span class=\"number\">1</span>.<span class=\"number\">2</span>.<span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<p>在以上文件都设置好以后，还需要进入CCS，点击 <code>WINDOWS</code> -&gt; <code>PREFERENCES</code> -&gt; <code>CODE COMPOSER STUDIO</code> -&gt; <code>PRODUCTS</code> , 在 <code>INSTALLED PRODUCTS</code> 面板下找到已安装的软件包，如果未找到，点击 <code>INSTALL</code> , 选择 <code>/ti</code> 路径进行软件包安装。</p>\n<p>如未挂载软件包，可能会出现错误提示如：<code>!ERROR: Unknown product-type ID 'com.ti.sdo.edma3'!</code></p>\n</blockquote>\n<p>找到示例文件，在示例文件的 <code>/src/</code> 文件夹下，按住 <code>shift键</code> 并 点击鼠标右键，选择 <code>在此处打开Powershell窗口</code> ，输入绝对路径和文件名称并按回车运行，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">D:\\ti\\pdk_C6657_1_1_2_6\\packages\\ti\\drv\\pdksetupenv.bat</span><br><span class=\"line\">D:\\ti\\pdk_C6657_1_1_2_6\\packages\\ti\\drv\\pdkProjectCreate.bat</span><br></pre></td></tr></table></figure>\n<p>成功时结果如下示：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">PDK_SHORT_NAME: <span class=\"title\">I</span>:\\03.<span class=\"title\">TexasInstruments_Workspace</span>\\<span class=\"title\">tl</span>-<span class=\"title\">led</span>-<span class=\"title\">flash</span>\\<span class=\"title\">src</span></span></span><br><span class=\"line\"><span class=\"function\">*****************************************************************************</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Detecting</span> <span class=\"title\">UnitTest</span> <span class=\"title\">Projects</span> <span class=\"title\">in</span> <span class=\"title\">PDK</span> <span class=\"title\">and</span> <span class=\"title\">importing</span> <span class=\"title\">them</span> <span class=\"title\">in</span> <span class=\"title\">the</span> <span class=\"title\">workspace</span> &quot;<span class=\"title\">I</span>:\\03.<span class=\"title\">TexasInstruments_Workspace</span>\\<span class=\"title\">tl</span>-<span class=\"title\">led</span>-<span class=\"title\">flash</span>\\<span class=\"title\">src</span>\\<span class=\"title\">project</span>&quot;</span></span><br><span class=\"line\"><span class=\"function\">找不到文件</span></span><br><span class=\"line\"><span class=\"function\">*****************************************************************************</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Detecting</span> <span class=\"title\">Example</span> <span class=\"title\">Projects</span> <span class=\"title\">in</span> <span class=\"title\">PDK</span> <span class=\"title\">and</span> <span class=\"title\">importing</span> <span class=\"title\">them</span> <span class=\"title\">in</span> <span class=\"title\">the</span> <span class=\"title\">workspace</span> &quot;<span class=\"title\">I</span>:\\03.<span class=\"title\">TexasInstruments_Workspace</span>\\<span class=\"title\">tl</span>-<span class=\"title\">led</span>-<span class=\"title\">flash</span>\\<span class=\"title\">src</span>\\<span class=\"title\">project</span>&quot;</span></span><br><span class=\"line\"><span class=\"function\">找不到文件</span></span><br><span class=\"line\"><span class=\"function\">*****************************************************************************</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Detecting</span> <span class=\"title\">TL</span> <span class=\"title\">Projects</span> <span class=\"title\">and</span> <span class=\"title\">importing</span> <span class=\"title\">them</span> <span class=\"title\">in</span> <span class=\"title\">the</span> <span class=\"title\">workspace</span> &quot;<span class=\"title\">I</span>:\\03.<span class=\"title\">TexasInstruments_Workspace</span>\\<span class=\"title\">tl</span>-<span class=\"title\">led</span>-<span class=\"title\">flash</span>\\<span class=\"title\">src</span>\\<span class=\"title\">project</span>&quot;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Detected</span> <span class=\"title\">Example</span> <span class=\"title\">Project</span>: <span class=\"title\">tl</span>-<span class=\"title\">led</span>-<span class=\"title\">flash</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Creating</span> <span class=\"title\">project</span> &#x27;<span class=\"title\">tl</span>-<span class=\"title\">led</span>-<span class=\"title\">flash</span>&#x27;...</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Done</span>!</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Copying</span> <span class=\"title\">macros.ini</span></span></span><br><span class=\"line\"><span class=\"function\">已复制         1 个文件。</span></span><br></pre></td></tr></table></figure>\n<p>遇到关于 的问题</p>\n<p><code>D:\\ti\\ccsv7\\tools\\compiler\\ti-cgt-c6000_8.2.2\\lib</code></p>\n<h2 id=\"xdcstd\">XDC/STD</h2>\n<h3 id=\"details\">DETAILS</h3>\n<p>In addition to the interfaces specified below, this package also supplies a C/C++ header, <code>std.h</code> that facilitates the creation of portable sources. This header defines a set of \"base\" types that enable the creation of C-code that is portable between any two targets. C source code that relies exclusively on these types is portable to all targets and platforms. Where appropriate, the types defined below are related to the types defined in the library headers prescribed by the C99 standard (ISO/IEC 9899:1999).</p>\n<p>Why not simply use the C99 types? Having a unique set of names provides <strong>a layer of insulation between a portable code base and a particular compiler</strong>; e.g., even if a compiler does not support the C99 types or defines them inappropriately for a particular device, it is possible to use the compiler without changing the code base. Thus, the developer is not forced to choose the lesser of two evils: waiting for a change to the compiler or forking the code base for a particular compiler device combination.</p>\n<p>There are several situations where a small separate set of <strong>portable types</strong> can help the maintainability of a code base.</p>\n<ul>\n<li>not all of the types described in the C99 standard are required to be defined by conformant implementations nor is it possible for all devices to implement some of the types specified (e.g., <code>int8_t</code> is not implemented on C54 devices); so it is difficult to identify non-portable source code.</li>\n<li>not all compilers provide C99 type support; if XDC supplies the type definition and the compiler is updated to include C99 types, a compilation error will occur if the source includes the C99 headers.</li>\n<li>not all compiler and device combinations are conformant; even high quality compilers may not properly define the types for each device supported by compiler.</li>\n</ul>\n<h3 id=\"usage\">USAGE</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;xdc/std.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>To compile sources that include <code>xdc/std.h</code>, <strong>two symbols must be defined</strong> before including this header:</p>\n<ul>\n<li><p><code>xdc_target_types__</code></p>\n<p>the package qualified path of the target's standard types header; e.g., <code>ti/targets/std.h</code>. This value is specified in the target's <code>stdInclude</code> config parameter; see <code>xdc.bld.ITarget.stdInclude</code></p></li>\n<li><p><code>xdc_target_name__</code></p>\n<p>the target's module name without the package prefix; e.g., <code>C64</code> rather than <code>ti.targets.C64</code>.</p></li>\n</ul>\n<p>For example, to compile sources for the <code>ti.targets.C64</code> target using TI's <code>cl6x</code> compiler, the following command line is sufficient:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cl6x -Dxdc_target_types__&#x3D;ti&#x2F;targets&#x2F;std.h -Dxdc_target_name__&#x3D;C64</span><br></pre></td></tr></table></figure>\n<p>Each of the type names below has an equivalent \"long name\"; i.e., a name that has an \"<code>xdc_</code>\" prefix. For example, the type <code>Bool</code> can also be written as \"<code>xdc_Bool</code>\". <strong>Long names exist to avoid conflicts with names defined or used by existing code bases.</strong></p>\n<p>In the event that one of the short type names below conflicts with another type name (that can not be changed), it is possble to disable the short names by defining the symbol <code>xdc__nolocalnames</code> before including <code>xdc/std.h</code>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#define xdc__nolocalnames</span><br><span class=\"line\">#include &lt;xdc&#x2F;std.h&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"standard-types\">STANDARD TYPES</h3>\n<p>This header may be included multiple times and defines the following target-dependent types:</p>\n<ul>\n<li><p><code>Bool</code></p>\n<blockquote>\n<p>this type is large enough to hold the values <code>0</code> or <code>1</code>. The constants TRUE and FALSE are of this type; see below.</p>\n</blockquote></li>\n<li><p><code>String</code></p>\n<blockquote>\n<p>this type is defined to be a <code>char *</code> and exists to allow code to distinguish between pointers to buffers of raw data and '\\0' terminated strings.</p>\n</blockquote></li>\n<li><p><code>CString</code></p>\n<blockquote>\n<p>this type is defined to be a <code>const char *</code> and exists to allow code to distinguish between pointers to a modifiable '\\0' terminated sequence of characters (i.e., a <code>String</code>) and one that is not modifiable (e.g., a literal string such as <code>\"hello world\\n\"</code>).</p>\n</blockquote></li>\n<li><p><code>Int</code>n, where n = 8, 16, or 32</p>\n<blockquote>\n<p>signed integer type that is large enough to hold n bits; the actual target type may by be larger than n. This type is equivalent to one of the C99 types <code>int_least</code>n<code>_t</code> or <code>int_fast</code>n<code>_t</code>; see Section 7.18.</p>\n</blockquote></li>\n<li><p><code>UInt</code>n, where n = 8, 16, or 32</p>\n<blockquote>\n<p>unsigned integer type that is large enough to hold n bits; the actual target type may by be larger than n. This type is equivalent to one of the C99 types <code>uint_least</code>n<code>_t</code> or <code>uint_fast</code>n<code>_t</code>; see ISO/IEC 9899:1999 Section 7.18.</p>\n</blockquote></li>\n<li><p><code>Bits</code>n, where n = 8, 16, or 32</p>\n<blockquote>\n<p>unsigned integer type that is precisely n bits. Not all targets support all values of n; if the target does not support an exact size the corresponding type is not defined. This type is equivalent to the corresponding C99 type <code>uint</code>n<code>_t</code>; see ISO/IEC 9899:1999 Section 7.18.</p>\n</blockquote></li>\n<li><p><code>Fxn</code></p>\n<blockquote>\n<p>this type is a pointer to code; it can hold a pointer to any function.</p>\n</blockquote></li>\n<li><p><code>Ptr</code></p>\n<blockquote>\n<p>this type is a pointer to data; it can hold a pointer to any data structure.</p>\n</blockquote></li>\n<li><p><code>IArg</code></p>\n<blockquote>\n<p>this integer type is large enough to hold a <code>Fxn</code>, <code>Ptr</code>, or <code>Int</code>.</p>\n</blockquote></li>\n<li><p><code>UArg</code></p>\n<blockquote>\n<p>this unsigned integer type is large enough to hold a <code>Fxn</code>, <code>Ptr</code>, or <code>Int</code>.</p>\n</blockquote></li>\n<li><p><code>LLong</code></p>\n<blockquote>\n<p>this long integer type is large enough to hold a <code>Long</code> and is defined as a 'long long' type on targets that support this type; otherwise, it is simply a <code>Long</code>. Note that C99 requires the <code>long long</code> type to be at least 64-bits wide (See ISO/IEC 9899:1999 Section 5.2.4.2.1). But some compilers do not support 64-bit integral types and some don't support the <code>long long</code> even though they do support 64-bit integral types. Since these variations limit the portability of valid C sources, the LLong type is always defined, is always at least as wide as the <code>Long</code> type, and is at least 64-bits wide for targets that support 64-bit integral types.</p>\n</blockquote></li>\n<li><p><code>ULLong</code></p>\n<blockquote>\n<p>this unsigned long integer type is large enough to hold a <code>ULong</code> and is defined as a 'unsigned long long' type on targets that support this type; otherwise, it is simply a <code>ULong</code>.</p>\n</blockquote></li>\n</ul>\n<p>The <code>xdc/std.h</code> header also defines the following aliases for the base C types. These aliases exist so that C sources can consistently follow a naming convention in which all type names are written in camel-case.</p>\n<ul>\n<li><p><code>Char</code> and <code>UChar</code></p>\n<blockquote>\n<p>aliases for <code>char</code> and <code>unsigned char</code>, respectively</p>\n</blockquote></li>\n<li><p><code>Short</code> and <code>UShort</code></p>\n<blockquote>\n<p>aliases for <code>short</code> and <code>unsigned short</code>, respectively</p>\n</blockquote></li>\n<li><p><code>Int</code> and <code>UInt</code></p>\n<blockquote>\n<p>aliases for <code>int</code> and <code>unsigned int</code>, respectively</p>\n</blockquote></li>\n<li><p><code>Long</code> and <code>ULong</code></p>\n<blockquote>\n<p>aliases for <code>long</code> and <code>unsigned long</code>, respectively</p>\n</blockquote></li>\n<li><p><code>Double</code> and <code>LDouble</code></p>\n<blockquote>\n<p>aliases for <code>double</code> and <code>long double</code>, respectively</p>\n</blockquote></li>\n<li><p><code>SizeT</code></p>\n<blockquote>\n<p>alias for <code>size_t</code></p>\n</blockquote></li>\n<li><p><code>VaList</code></p>\n<blockquote>\n<p>alias for <code>va_list</code></p>\n</blockquote></li>\n</ul>\n<p>The types above are defined for all targets. Some targets can support the following additional types. Since these types are not always supported by a target, these types should only be used when no other type sufficies.</p>\n<ul>\n<li><p><code>Bits</code>n, where n = 8, 16, or 32</p>\n<blockquote>\n<p>this unsigned integer type is precisely n-bits wide. This type is equivalent to the optional C99 type <code>uint</code>n<code>_t</code>; see ISO/IEC 9899:1999 Section 7.18.1.1. This type is defined if and only if the preprocessor macro <code>xdc__BITS</code>n<code>__</code> is defined.</p>\n</blockquote></li>\n</ul>\n<h3 id=\"bit-types\">64 BIT TYPES</h3>\n<p>Although the C99 standard requires support for 64-bit types, not all compiler/device combinations can usefully support them. As a result, the 64-bit types described here may not be defined for all targets. For each type there is a corresponding pre-processor macro which is defined if and only if the type is supported.</p>\n<ul>\n<li><p><code>Int64</code></p>\n<blockquote>\n<p>signed integer type that is large enough to hold 64 bits; the actual target type may by be wider than 64 bits. This type is equivalent to one of the C99 types <code>int_least64_t</code> or <code>int_fast64_t</code>; see Section 7.18. This type is defined if and only if the preprocessor macro <code>xdc__INT64__</code> is defined.</p>\n</blockquote></li>\n<li><p><code>UInt64</code></p>\n<blockquote>\n<p>unsigned integer type that is large enough to hold n bits; the actual target type may by be wider than 64 bits. This type is equivalent to one of the C99 types <code>uint_least64_t</code> or <code>uint_fast64_t</code>; see ISO/IEC 9899:1999 Section 7.18. This type is defined if and only if the preprocessor macro <code>xdc__INT64__</code> is defined.</p>\n</blockquote></li>\n<li><p><code>Bits64</code></p>\n<blockquote>\n<p>unsigned integer type that is precisely 64 bits wide. If the target does not support an exact 64-bit size, this type is not defined. This type is equivalent to the corresponding C99 type <code>uint64_t</code>; see ISO/IEC 9899:1999 Section 7.18. This type is defined if and only if the preprocessor macro <code>xdc__BITS64__</code> is defined.</p>\n</blockquote></li>\n</ul>\n<p><em>The table below is from <strong>Log_print6()</strong> in the <strong>XDC/RUNTIME/LOG.H</strong>.</em></p>\n<p>However, because the declared type of the arguments is <code>IArg</code>, all pointer arguments must be cast to an <code>IArg</code> type.<code>IArg</code> is an integral type large enough to hold any pointer or an <code>int</code>. So, casting a pointer to an <code>IArg</code> does not cause any loss of information and C's normal integer conversions make the cast unnecessary for integral arguments.</p>\n<p>The format string can use the following conversion characters. However, it is important to recall that all arguments referenced by these conversion characters have been converted to an <code>IArg</code> prior to conversion; so, the use of \"length modifiers\" should be avoided.</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>Conversion Character</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>%c</td>\n<td>Character</td>\n</tr>\n<tr class=\"even\">\n<td>%d</td>\n<td>Signed integer</td>\n</tr>\n<tr class=\"odd\">\n<td>%u</td>\n<td>Unsigned integer</td>\n</tr>\n<tr class=\"even\">\n<td>%x</td>\n<td>Unsigned hexadecimal integer</td>\n</tr>\n<tr class=\"odd\">\n<td>%o</td>\n<td>Unsigned octal integer</td>\n</tr>\n<tr class=\"even\">\n<td>%s</td>\n<td>Character string</td>\n</tr>\n<tr class=\"odd\">\n<td>%p</td>\n<td>Pointer</td>\n</tr>\n<tr class=\"even\">\n<td>%f</td>\n<td>Single precision floating point (float)</td>\n</tr>\n</tbody>\n</table>\n<p><code>usertype.h</code> 中的定义:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span>           INT8;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">short</span>          INT16;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span>            INT32;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>  UINT8;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> UINT16;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>   UINT32;</span><br></pre></td></tr></table></figure>\n<h2 id=\"sysbios-rtos\">SYS/BIOS RTOS</h2>\n<p>我们依赖操作系统来提供底层和中间件的服务，如让设备启动，处理基本IO口，允许多个程序并行运行，为多个正在运行的程序分配内存和磁盘空间，以及通过USB和以太网口等通讯堆栈来实现更多复杂的IO口通讯。</p>\n<h3 id=\"rtos的优点\">RTOS的优点</h3>\n<ul>\n<li>模块化设计，线程的使用使各任务得到最大化独立；</li>\n<li>提供模块及接口以方便地驱动外设；</li>\n<li>代码可移植性/脱离于内核处理器；</li>\n</ul>\n<h3 id=\"线程\">线程</h3>\n<ul>\n<li>线程是一组存储在存储器的代码，一旦寄存器被正确初始化，CPU就会执行这些代码。</li>\n<li>定义和管理任何需要被操作的内容\n<ul>\n<li>包括程序指针、堆栈和寄存器等值</li>\n<li>这些被统称“上下文”【每个线程都会被定义上下文，包括<code>程序计数器</code>、<code>堆栈</code>和<code>关键寄存器</code>的信息】</li>\n<li>会有一系列的线程需要在指定时间被执行，RTOS会按一定标准在指定时间选择线程执行。</li>\n</ul></li>\n<li>线程可以使任何类型的，SYS/BIOS定义了四种线程类型（优先级降序排列）：\n<ul>\n<li>硬件中断</li>\n<li>软件中断</li>\n<li>任务</li>\n<li>空闲</li>\n</ul></li>\n<li>各线程有 隐式的(implicity) 和 显示的(explicity)（可能有）优先级\n<ul>\n<li>隐式的优先级由线程类型决定</li>\n<li>显式的优先级由软件编程者决定</li>\n</ul></li>\n<li>允许抢占（或者上下文切换）\n<ul>\n<li>基于优先级的调度管理机制保证了最高优先级的线程能够在第一时间被执行</li>\n</ul></li>\n<li>线程之间的交互\n<ul>\n<li>阻断</li>\n<li>通信</li>\n<li>同步</li>\n</ul></li>\n</ul>\n<h3 id=\"timer-and-clock\">TIMER and CLOCK</h3>\n<ul>\n<li><p><strong>定时器模块 TIMER</strong></p></li>\n<li><p>管理定时器外设</p></li>\n<li><p>提供虚拟的目标/设备概念</p>\n<ul>\n<li>【通过操作定时器模块而不是硬件外设，开发人员能够更轻松更直观地管理定时器，且在多个不同TI芯片中移植式，代码更具可移植性】</li>\n<li>【对于SYS/BIOS而言，可以产生无限数量的定时器】</li>\n</ul></li>\n<li><p><strong>时钟模块 CLOCK</strong></p>\n<ul>\n<li>管理BIOS的“心脏节拍“</li>\n<li>在指定时间触发功能（单次或周期性）</li>\n<li>使用定时器模块或者应用层模块的“节拍”来处理输入事件</li>\n<li>【时钟模块所在的层位于定时器之上】</li>\n<li>【时钟模块可以通过定时器模块将系统中的外部事件引入作为输入事件，或者使用定时器模块产生的周期性节拍，基于这些输入事件，时钟模块可以产生软件中断，或者时钟模块还能提供一种服务，以便一次性或者周期性地触发任意数量的不同函数】</li>\n<li>【时钟实例中包含了对两个时间段的定义，第一个时间段的定义称为<code>超时时间量</code>，它定义了时钟实例的启动和首次触发相关函数的时间量，通常会在应用程序中，通过显示的调用时钟来启动一个时钟实例，如果创建时钟实例时，标志为TRUE，则实例会在创建后立即启动；第二个时间段的定义标志了相关函数首次调用和后续调用之间<code>持续时间量</code>；对于一次性的时钟实例，只需定义超时时间量，持续时间量将为0；相关函数都是由时钟实例的中断来调用的，这意味着必须在同一线程中启动或停止时钟，而不能在其他线程中任意启动或停止时钟】</li>\n</ul></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 启动/停止时钟实例，仅能通过时钟SWI调用</span></span><br><span class=\"line\">Clock_start()</span><br><span class=\"line\">Clock_stop()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动/停止定时器底层产生时间节拍</span></span><br><span class=\"line\"><span class=\"comment\">// 【`时钟停止启动` 和 `时钟节拍停止`，用来为驱动时钟模块提供底层定时器】</span></span><br><span class=\"line\">Clock_tickStart()</span><br><span class=\"line\">Clock_tickStop()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修改停止的时钟实例</span></span><br><span class=\"line\"><span class=\"comment\">// 【设置 `时钟周期`、`超时`、`功能` 函数，用于修改时钟实例的参数】</span></span><br><span class=\"line\">Clock_setPeriod()</span><br><span class=\"line\">Clock_setTimeout()</span><br><span class=\"line\">Clock_setfunc()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 允许修改时钟实例的参数，基于新的定时器频率</span></span><br><span class=\"line\"><span class=\"comment\">// 当CPU的频率发生变化时，可以通过此函数对时钟进行重新配置</span></span><br><span class=\"line\">Clock_tickReconfig()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间戳模块\n<ul>\n<li>为代码的基准测试提供便捷的时间戳服务</li>\n<li>允许时间戳记录RTA日志</li>\n</ul></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*前两个变量的类型由时钟模块定义*/</span></span><br><span class=\"line\">Clock_Params clockParams;               <span class=\"comment\">//用于容纳所有的时钟实例参数</span></span><br><span class=\"line\">Task_Handle myClock;                    <span class=\"comment\">//用于存储将要创建的时钟实例的句柄</span></span><br><span class=\"line\">Error_block eb;                         <span class=\"comment\">//错误块变量，若创建失败可以获取失败原因的信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">Clock_Params_init(&amp;clockParams);        <span class=\"comment\">//时钟实例初始化参数，已默认值填充参数结构</span></span><br><span class=\"line\"><span class=\"comment\">/*下两句分别更新与默认值不同的参数*/</span></span><br><span class=\"line\">clockParams.period = <span class=\"number\">4</span>;                 <span class=\"comment\">//Every 4 Clock ticks</span></span><br><span class=\"line\">ClockParams.startFlag = TRUE;           <span class=\"comment\">//Start immediately</span></span><br><span class=\"line\">Error_init(&amp;eb);                        <span class=\"comment\">//错误块变量，若创建失败可以获取失败原因的信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">myClock = Clock_create((Clock_FuncPtr)clockHandler,<span class=\"number\">4</span>,&amp;clockParams,&amp;eb); <span class=\"comment\">//三参数，时钟实例创建，并返回句柄给myClock</span></span><br></pre></td></tr></table></figure>\n<p><strong>在XGCONF中配置时钟参数：</strong></p>\n<table>\n<colgroup>\n<col style=\"width: 14%\" />\n<col style=\"width: 85%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>NAME</th>\n<th>VALUE</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>tickSource</td>\n<td><code>tickSource_TIMER</code> ：选择定时器（周期性调用Clock_tick)； <code>tickSource_User</code>：选择外部中断触发调用Clock_tick；<code>tickSource_NULL</code>：没有时钟API，没有超时【由信号量写入的调用不能具有超时值】</td>\n</tr>\n<tr class=\"even\">\n<td>timerId</td>\n<td>【用于指定芯片实际使用的定时器外设】<code>-1</code>：默认定时器</td>\n</tr>\n<tr class=\"odd\">\n<td>swiPiority</td>\n<td>【时钟模块是由底层定时器模块触发软件中断来调用的，因此其SWI的优先级可以设置】默认值 <code>15</code></td>\n</tr>\n<tr class=\"even\">\n<td>tickPeriod</td>\n<td>【系统节拍的周期】默认值 <code>1000</code> usec</td>\n</tr>\n</tbody>\n</table>\n<p><strong>时钟实例化参数：</strong></p>\n<table>\n<colgroup>\n<col style=\"width: 13%\" />\n<col style=\"width: 86%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>NAME</th>\n<th>VALUE</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>clockFxn</td>\n<td>[Creat Args]【需要被调用的实例函数在clockfxn字段中】</td>\n</tr>\n<tr class=\"even\">\n<td>timeout</td>\n<td>[Creat Args]【从时钟开始运行到相关函数被首次调用的初始时间值】</td>\n</tr>\n<tr class=\"odd\">\n<td>startFlag</td>\n<td>[Params]【将指定时钟是在BIOS的调度程序开始运行时立即启动，还是由应用程序调用时钟的启动API】<code>true</code>：立即启动；<code>false</code>：调用；<code>Clock_start()</code> ：后启动</td>\n</tr>\n<tr class=\"even\">\n<td>period</td>\n<td>[Params]【在首次调用函数后，需要确定后续函数调用的间隔】<code>0</code>：单次调用；</td>\n</tr>\n<tr class=\"odd\">\n<td>arg</td>\n<td>[Params] argument to clockFxn【用户可以将静态变量传递给相关函数，这样做可以将多个时钟实例共同使用单一函数，由于每个实例都可以向被调用的函数传递一个不同的值，因此在实现函数时可以根据调用到的时钟采取不同的操作】</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"hwi-and-idle\">HWI and Idle</h3>\n<p>嵌入式硬件中断的原理：前台/后台调度（主要由低优先级任务、无线循环任务和ISR构成，复杂性较低，存在不足）</p>\n<ul>\n<li>应用程序循环处理由硬件中断服务程序职位的标志位</li>\n<li>ISR抢断主循环，执行中断服务【ISR 被称为前台进程】</li>\n</ul>\n<p>SYS/BIOS在BIOS之上实行 <code>Idle loop</code> + <code>Hwi</code> + <code>main()</code> 的方式：</p>\n<ul>\n<li>空闲循环是优先级最低的无限循环（并不代表优先级不重要），所执行的是一系列静态配置的后台程序</li>\n<li>典型应用：用户界面，内置的系统测试，测量，以及低功耗模式</li>\n<li>被最高优先级线程抢断/从被抢断的地方恢复运行</li>\n<li><strong>ISR以HWI线程的方式运行，任意HWI都能抢断空闲循环</strong></li>\n</ul>\n<p><strong>后台空闲循环（线程）</strong></p>\n<blockquote>\n<p>The <strong>background Idle Loop</strong> is the thread with the lowest priority of all. It runs in a loop when the CPU is not busy running another thread.</p>\n</blockquote>\n<ul>\n<li><p>When tasks are enabled, the Idle Loop is implemented as the only task running at priority 0.</p></li>\n<li><p>When tasks are disabled, the Idle Loop is fallen into after the application's \"main()\" function is called.（空闲循环会在应用程序main()函数被调用后陷入？）</p></li>\n</ul>\n<p><strong>HWI的中断及恢复流程（中断调度流程）：</strong></p>\n<ol type=\"1\">\n<li>屏蔽任务调度【HWI是被视为隐式的较高优先级线程，因此不希望所有目前最高优先级的线程抢断HWI线程，如果应用程序没有启用任务模块，该段启动任务调度的程序将被优化出中断调度程序，以便确保中断调度程序能够高效执行】</li>\n<li>转向ISR堆栈（如果没有指向该堆栈）【如果当前指针指向任务堆栈，则此时会切换到中断堆栈】</li>\n<li>保存中断返回地址【中断调度程序将存储该指针，以防用户使用IRP的API来检索该返回地址，如果不需要使用该API则被优化】</li>\n<li>屏蔽SWI调度【如任务模块一样未被开启，则自动优化出中断调度程序】</li>\n<li>调用HWI挂钩启动函数【<strong>附加</strong>挂钩函数】</li>\n<li>如果允许自动嵌套：允许全局中断【有更高优先级的硬件中断来临时，打开中断屏蔽，使能全局中断】</li>\n<li>调用ISR服务程序【真正的硬件中断程序开始执行】</li>\n<li>屏蔽全局中断</li>\n<li>调用HWI挂钩结束函数</li>\n<li>运行SWI调度</li>\n<li>切换回任务堆栈</li>\n<li>运行任务调度</li>\n</ol>\n<p><strong>SYS/BIOS中断管理的优势：</strong></p>\n<ol type=\"1\">\n<li>降低代码量</li>\n<li>提供中断堆栈，降低任务堆栈大小</li>\n<li>管理中断嵌套</li>\n<li>在ISR任务中禁止调度中断</li>\n<li>运行由ISR程序递交的SWI程序</li>\n<li>管理任务抢断</li>\n<li>提供监测</li>\n<li>灵活性：仍然允许不执行中断调度</li>\n</ol>\n<p><strong>注意：</strong> <em>HWI不需要使用编译器认可的中断关键字！SYS/BIOS的中断调度会自动保存堆栈相关数据，如果使用会导致灾难性的运行故障发生！</em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hwi_Params hwiParams;              <span class=\"comment\">//硬件中断参数结构体实例</span></span><br><span class=\"line\">Hwi_Handle hwi0;                   <span class=\"comment\">//硬件中断句柄</span></span><br><span class=\"line\">Error_block eb;</span><br><span class=\"line\"></span><br><span class=\"line\">Hwi_Params_init(&amp;hwiParams);       <span class=\"comment\">//参数初始化</span></span><br><span class=\"line\">hwiParams.arg = <span class=\"number\">5</span>;                 <span class=\"comment\">//更新参数</span></span><br><span class=\"line\">hwi0 = Hwi_create(id,hwiFunc,&amp;hwiParams,&amp;eb);  <span class=\"comment\">//四参数，前两个未知</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"swi\">SWI</h3>\n<ul>\n<li><p>一般伴随着硬件中断的发生而发生，以便最灵活地处理中断事务</p></li>\n<li><p>优先级共16级：0-15</p></li>\n<li><p>寄存器的保护/恢复由SYS/BIOS系统自动处理</p></li>\n<li><p>单堆栈模式：增加优先级将增加堆栈的开销</p></li>\n<li><p>【与任务的处理方式不同，SWI在单个堆栈上运行，同时兼具优点与局限性，能使SWI以非常低的内存消耗来运行，但也不允许他们被挂起（即SWI必须运行到结束）】</p></li>\n<li><p>【SWI通常由HWI调用，系统产生了一个外设的中断，从而触发了HWI线程，而HWI处理的都是需要紧急实时响应的事务，HWI线程需要尽可能快速处理完毕，并且处理HWI时会屏蔽其他中断，因此为了让HWI处理尽可能少的操作，一些不太需要紧急实时处理的任务会放到SWI中处理。】</p></li>\n<li><p>【因此当HWI将中断发布到SWI时，SWI会立即处理】</p></li>\n<li><p>【HWI通常是突发而紧急的，SWI通常较为灵活、常态而平稳】</p></li>\n<li><p>【HWI通常以微秒计时，SWI通常以毫秒计时】</p></li>\n<li><p>【HWI和SWI都只会运行一次，不管该线程在运行前被发布了多少次】</p></li>\n<li><p>【具有相同优先级的两个SWI线程不会抢占对方，会以FIFO的方式先后运行两个线程，即使第二个线程已经被发布，但直到第一个线程运行完毕，第二个线程都在持续等待】</p></li>\n<li><p>【如果使用ISR来发布更高优先级的SWI，或者说在使用ISR时发布SWI，则可能使得SWI立即抢占ISR的线程，造成数据丢失，BIOS更推荐使用HWI来发布SWI】</p></li>\n<li><p>【同一个SWI线程不论在运行前被发布了多少次，都只会运行一次】</p></li>\n</ul>\n<table>\n<thead>\n<tr class=\"header\">\n<th>API</th>\n<th>Allows you to :</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>Swi_inc()</td>\n<td>知道SWI在运行前被发布了多少次——N：自加计数</td>\n</tr>\n<tr class=\"even\">\n<td>Swi_dec()</td>\n<td>需要发布N次SWI，才能运行SWI——N：自减计数</td>\n</tr>\n<tr class=\"odd\">\n<td>Swi_or()</td>\n<td>在发布发出一个有用的信号——签名</td>\n</tr>\n<tr class=\"even\">\n<td>Swi_andn()</td>\n<td>只有在所需要的发布都已经发布后才会发布</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>Bitmask</th>\n<th>Counter</th>\n<th>Not Used</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>无条件发布</td>\n<td>Swi_or()</td>\n<td>Swi_inc()</td>\n<td>Swi_post()</td>\n</tr>\n<tr class=\"even\">\n<td>仅在触发值为0时发布</td>\n<td>Swi_andn()</td>\n<td>Swi_dec()</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>If trigger value is needed by the Swi, use <code>Swi_getTrigger()</code> which returns the value of the trigger when the Swi function starts running.</li>\n<li>After each posting, the trigger is reset to the initial condition specified in the Swi object.</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">Swi_Params swiParams;</span><br><span class=\"line\">Swi_Handle mySwi;</span><br><span class=\"line\">Error_Block eb;    <span class=\"comment\">//创建错误块结构体实例</span></span><br><span class=\"line\"></span><br><span class=\"line\">Swi_Params_init(&amp;swiParams);</span><br><span class=\"line\">swiParams.priority = <span class=\"number\">15</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Error_init(&amp;eb);   <span class=\"comment\">//初始化错误块结构体</span></span><br><span class=\"line\"></span><br><span class=\"line\">mySwi = Swi_create(swiFunc, &amp;swiParams, &amp;eb);    <span class=\"comment\">//三参数</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"task\">Task</h3>\n<h4 id=\"sysbios-task\">SYS/BIOS-TASK</h4>\n<p><strong>任务创建函数原型Task_create(Task_FuncPtr, Const*, Error_Block*)</strong></p>\n<p><strong>注意：</strong>要与 <code>TaskCreate(void*(), char*, int, uint, UINT32, UINT32, UINT32)</code>; 做区分。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">Task_create(Task_FuncPtr fxn,</span><br><span class=\"line\">            <span class=\"keyword\">const</span> Task_Params *params, </span><br><span class=\"line\">            Error_Block *eb);</span><br></pre></td></tr></table></figure>\n<p><strong>示例</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">Task_Params taskParams;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Create task with priority 15 </span></span><br><span class=\"line\">Task_Params_init(&amp;taskParams);</span><br><span class=\"line\">taskParams.stackSize = <span class=\"number\">512</span>;</span><br><span class=\"line\">taskParams.priority = <span class=\"number\">15</span>;</span><br><span class=\"line\">Task_create((Task_FuncPtr)myFxn, &amp;taskParams, &amp;eb);</span><br></pre></td></tr></table></figure>\n<p><strong>任务特性</strong></p>\n<ul>\n<li>任务调度使用更先进的调度技术\n<ul>\n<li>每个任务在创建时都会设立独立堆栈，任务访问共享资源时可能会因为等待而被挂起</li>\n<li>任务会被其他更高优先级的线程打断（SWI、HWI），HWI 及 SWI不可挂起（SWI是需要退出和返回）；</li>\n</ul></li>\n<li>任务的数量、状态及优先级都可以在程序执行时动态改变</li>\n<li>【两个任务可以调用同一函数（主要该函数是可以重入？的函数），即该函数在执行完毕之前可被安全地二次调用，任务在调用函数时可携带参数，使函数知晓是被哪个实例调用】</li>\n</ul>\n<p><strong>任务间时间切片。</strong></p>\n<blockquote>\n<p>任务在正常情况下是个看似 “无限循环” 的进程，只有在整个系统停止后才会结束；但在未被挂起的情况下，任务在被CPU分时间调度的过程中，任务会重新从头开始运行，即不会停留在上一次的位置。任务看似一次被执行就一直被无限调度，实际上是在时间分片中快速切换。</p>\n</blockquote>\n<p><strong>任务与Semaphore。</strong></p>\n<blockquote>\n<p>在使用Semaphore作为同步方式的任务调度中，如果一个任务等级较高，且 <code>Semaphore_pend()</code> 时，设置了第二个参数为 <code>BIOS_NO_WAIT</code> ，即该任务会被立即循环执行。如果参数设置为 <code>BIOS_WAIT_FOREVER</code> ，则该程序将会一直等待，直到它的信号量被post出来。</p>\n<p style=\"font-style: italic; color: #ccc;\">\n原文：A timeout value of BIOS_WAIT_FOREVER causes the task to wait indefinitely for its semaphore to be posted. A timeout value of BIOS_NO_WAIT causes Semaphore_pend to return immediately.\n</p>\n<p><strong>注意</strong>：互相形成依赖的任务（如嵌套）不要用同一个信号量，会发生冲突、堆栈溢出或死锁等现象。尽量一个任务关联一个信号量。</p>\n</blockquote>\n<p><strong>注意：</strong>如果有堆栈溢出，应优先检查task和semaphore的初始化情况。</p>\n<table>\n<colgroup>\n<col style=\"width: 50%\" />\n<col style=\"width: 50%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Functions</th>\n<th>explaination</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>Task_construct (Task_Struct *structP, Task_FuncPtr fxn, const Task_Params *params, Error_Block *eb);</code></td>\n<td>// <strong><em>Initialize</em></strong> a new instance object inside the provided structure <br />在提供的结构中<strong>创建</strong>一个新的实体对象</td>\n</tr>\n<tr class=\"even\">\n<td><code>Task_create(Task_FuncPtr fxn, const Task_Params *params, Error_Block *eb);</code></td>\n<td>// <strong><em>Allocate and initialize</em></strong> a new instance object and return its handle<br />开辟内存并初始化一个新的实体对象并返回其句柄</td>\n</tr>\n<tr class=\"odd\">\n<td><code>Task_delete(Task_Handle *handleP);</code></td>\n<td>// <strong><em>Finalize and free</em></strong> this previously allocated instance object, setting the referenced handle to NULL<br />终结一个已存在的实体对象，并释放内存，设置其句柄为空</td>\n</tr>\n<tr class=\"even\">\n<td><code>Task_destruct(Task_Struct *structP);</code></td>\n<td>// Finalize the instance object inside the provided structure<br />在提供的结构中<strong>创建</strong>一个新的实体对象</td>\n</tr>\n<tr class=\"odd\">\n<td><code>Task_disable();</code></td>\n<td>// Disable the task scheduler<br />使任务（列表）功能关闭</td>\n</tr>\n<tr class=\"even\">\n<td><code>Task_exit();</code></td>\n<td>// 5Terminate execution of the current task<br />终结现在正在运行的任务</td>\n</tr>\n<tr class=\"odd\">\n<td><code>Task_getEnv(Task_Handle handle);</code></td>\n<td>// Get task environment pointer<br />获取任务环境指针</td>\n</tr>\n<tr class=\"even\">\n<td><code>Task_getIdleTask();</code></td>\n<td>// returns a handle to idle task object<br />返回一个句柄给空闲任务对象</td>\n</tr>\n<tr class=\"odd\">\n<td><code>Task_getMode(Task_Handle handle);</code></td>\n<td>// Retrieve the Mode of a task<br />获取任务的句柄</td>\n</tr>\n<tr class=\"even\">\n<td><code>Task_getPri(Task_Handle handle);</code></td>\n<td>// Get task priority<br />获取任务的优先级</td>\n</tr>\n<tr class=\"odd\">\n<td><code>Task_Params_init(Task_Params *params);</code></td>\n<td>// Initialize this config-params structure with supplier-specified defaults before instance creation<br />在实例创建前使用指定默认值初始化配置参数结构</td>\n</tr>\n<tr class=\"even\">\n<td><code>Task_restore(UInt key);</code></td>\n<td>// Restore Task scheduling state储存任务调度状态</td>\n</tr>\n<tr class=\"odd\">\n<td><code>Task_self();</code></td>\n<td>// Returns a handle to the currently executing Task object<br />返回一个句柄给当前执行中的任务对象</td>\n</tr>\n<tr class=\"even\">\n<td><code>Task_selfMacro();</code></td>\n<td>// Returns a handle to the currently executing Task object<br />返回一个句柄给当前执行中的任务对象</td>\n</tr>\n<tr class=\"odd\">\n<td><code>Task_setEnv(Task_Handle handle, Ptr env);</code></td>\n<td>// Set task environment<br />设置任务环境</td>\n</tr>\n<tr class=\"even\">\n<td><code>Task_setHookContext(Task_Handle handle, Int id, Ptr hookContext);</code></td>\n<td>// Set hook instance's context for a task<br />为任务设置hook实例的</td>\n</tr>\n<tr class=\"odd\">\n<td><code>Task_setPri(Task_Handle handle, Int newpri);</code></td>\n<td>// Set a task's priority<br />设置任务优先级</td>\n</tr>\n<tr class=\"even\">\n<td><code>Task_sleep(UInt nticks);</code></td>\n<td>// Delay execution of the current task<br />延迟当前任务的执行时间</td>\n</tr>\n<tr class=\"odd\">\n<td><code>Task_stat(Task_Handle handle, Task_Stat *statbuf);</code></td>\n<td>// Retrieve the status of a task<br />获取任务状态</td>\n</tr>\n<tr class=\"even\">\n<td><code>Task_yield();</code></td>\n<td>// Yield processor to equal priority task<br />在两个相同等级的任务间切换处理器使用权<br />同等级任务切换函数</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"任务测试\">任务测试</h5>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>priority</th>\n<th>task_yield()</th>\n<th>ISR Post Sem</th>\n<th>任务内任务</th>\n<th>是否执行</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td></td>\n<td>更高</td>\n<td>存在</td>\n<td>存在</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr class=\"even\">\n<td></td>\n<td>相同</td>\n<td>存在</td>\n<td>存在</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><strong>Table 3-1. Comparison of Thread Characteristics</strong></p>\n<table>\n<colgroup>\n<col style=\"width: 16%\" />\n<col style=\"width: 16%\" />\n<col style=\"width: 22%\" />\n<col style=\"width: 22%\" />\n<col style=\"width: 22%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th><strong>Characteristic</strong></th>\n<th><strong>Hwi</strong></th>\n<th><strong>Swi</strong></th>\n<th><strong>Task</strong></th>\n<th><strong>Idle</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong>Priority</strong></td>\n<td>Highest</td>\n<td>2nd Highest</td>\n<td>2nd lowest</td>\n<td>Lowest</td>\n</tr>\n<tr class=\"even\">\n<td><strong>Number of priority levels</strong></td>\n<td>family/device-specific</td>\n<td>Up to 32; Periodic functions run at the priority of the Clock Swi.</td>\n<td>Up to 32; This includes 1 for the Idle Loop.</td>\n<td>1</td>\n</tr>\n<tr class=\"odd\">\n<td><strong>Can yield and pend</strong></td>\n<td>No, runs to completion except for preemption</td>\n<td>No, runs to completion except for preemption</td>\n<td>Yes</td>\n<td>Should not pend. <strong><em>Pending would disable all registered Idle threads.</em></strong></td>\n</tr>\n<tr class=\"even\">\n<td><strong>Execution states</strong></td>\n<td>Inactive, ready, running</td>\n<td>Inactive, ready, running</td>\n<td>Ready, running, blocked, terminated</td>\n<td>Ready, running</td>\n</tr>\n<tr class=\"odd\">\n<td><strong>Thread scheduler disabled by</strong></td>\n<td><code>Hwi_disable()</code></td>\n<td><code>Swi_disable()</code></td>\n<td><code>Task_disable()</code></td>\n<td>Program exit</td>\n</tr>\n<tr class=\"even\">\n<td><strong>Posted or made ready to run by</strong></td>\n<td>Interrupt occurs</td>\n<td><code>Swi_post()</code> , <code>Swi_andn()</code> , <code>Swi_dec()</code> , <code>Swi_inc()</code> , <code>Swi_or()</code></td>\n<td><code>Task_create()</code> and various task synchronization mechanisms <em>(Event, Semaphore, Mailbox)</em></td>\n<td><code>main()</code> exits and no other thread is currently running</td>\n</tr>\n<tr class=\"odd\">\n<td><strong>Stack used</strong></td>\n<td>System stack (1 per program)</td>\n<td>System stack (1 per program)</td>\n<td>Task stack (1 per program)</td>\n<td><strong>Task stack used by default</strong></td>\n</tr>\n<tr class=\"even\">\n<td><strong>Context saved when preempts other thread</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td><strong>Context saved when blocked</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td><strong>share data with thread via</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td><strong>Synchronize with thread via</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td><strong>Function hooks</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td><strong>Static creation</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td><strong>Dynamic creation</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td><strong>Dynamically change priority</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td><strong>Implicit logging</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td><strong>Implicit statistics</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"osif-task\">OSIF-TASK</h4>\n<p><code>&lt;osif.h&gt;</code> 文件提供系统级接口函数，与SYS/BIOS提供的相似任务函数具有不一样的函数定义。所有任务相关函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以下功能可能需要被链接或移植</span></span><br><span class=\"line\"><span class=\"function\">_extern <span class=\"keyword\">void</span>   <span class=\"title\">TaskBlock</span><span class=\"params\">(HANDLE h)</span></span>;</span><br><span class=\"line\"><span class=\"function\">_extern HANDLE <span class=\"title\">TaskCreate</span><span class=\"params\">( <span class=\"keyword\">void</span>(*pFun)(), <span class=\"keyword\">char</span> *Name, <span class=\"keyword\">int</span> Priority, uint StackSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          UINT32 Arg1, UINT32 Arg2, UINT32 Arg3 )</span></span>;</span><br><span class=\"line\"><span class=\"function\">_extern <span class=\"keyword\">void</span>   <span class=\"title\">TaskDestroy</span><span class=\"params\">( HANDLE h )</span></span>;</span><br><span class=\"line\"><span class=\"function\">_extern <span class=\"keyword\">void</span>   <span class=\"title\">TaskExit</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\">_extern HANDLE <span class=\"title\">TaskGetEnv</span><span class=\"params\">( HANDLE h, <span class=\"keyword\">int</span> Slot )</span></span>;</span><br><span class=\"line\"><span class=\"function\">_extern <span class=\"keyword\">int</span>    <span class=\"title\">TaskGetPri</span><span class=\"params\">(HANDLE h)</span></span>;</span><br><span class=\"line\"><span class=\"function\">_extern HANDLE <span class=\"title\">TaskSelf</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\">_extern <span class=\"keyword\">void</span>   <span class=\"title\">TaskSetEnv</span><span class=\"params\">( HANDLE h, <span class=\"keyword\">int</span> Slot, HANDLE hEnv )</span></span>;</span><br><span class=\"line\"><span class=\"function\">_extern <span class=\"keyword\">int</span>    <span class=\"title\">TaskSetPri</span><span class=\"params\">(HANDLE h, <span class=\"keyword\">int</span> priority)</span></span>;</span><br><span class=\"line\"><span class=\"function\">_extern <span class=\"keyword\">void</span>   <span class=\"title\">TaskSleep</span><span class=\"params\">(UINT32 delay)</span></span>;</span><br><span class=\"line\"><span class=\"function\">_extern <span class=\"keyword\">void</span>   <span class=\"title\">TaskYield</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<p><strong>任务创建函数 TaskCreate(void*(), char*, int, uint, UINT32, UINT32, UINT32); </strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">_extern HANDLE <span class=\"title\">TaskCreate</span><span class=\"params\">( <span class=\"keyword\">void</span>(*pFun)(), <span class=\"keyword\">char</span> *Name, <span class=\"keyword\">int</span> Priority, uint StackSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          UINT32 Arg1, UINT32 Arg2, UINT32 Arg3 )</span></span>;</span><br></pre></td></tr></table></figure>\n<p><code>TaskCreate();</code> 的使用方式如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">( <span class=\"keyword\">void</span> ) TaskCreate ( TCP_Perform_Server , <span class=\"string\">&quot;TCPBenchmarkRX&quot;</span> , OS_TASKPRIHIGH , <span class=\"number\">0x1400</span> , <span class=\"number\">0</span> , <span class=\"number\">0</span> , <span class=\"number\">0</span> );</span><br></pre></td></tr></table></figure>\n<p>关于任务优先级Priority的定义存在同一头文件中，具体如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Equates used in code</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DBG_PRINT_LEVEL         (_oscfg.DbgPrintLevel)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DBG_ABORT_LEVEL         (_oscfg.DbgAbortLevel)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> OS_TASKPRILOW           (_oscfg.TaskPriLow)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> OS_TASKPRINORM          (_oscfg.TaskPriNorm)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> OS_TASKPRIHIGH          (_oscfg.TaskPriHigh)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> OS_TASKPRIKERN          (_oscfg.TaskPriKern)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> OS_TASKSTKLOW           (_oscfg.TaskStkLow)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> OS_TASKSTKNORM          (_oscfg.TaskStkNorm)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> OS_TASKSTKHIGH          (_oscfg.TaskStkHigh)</span></span><br></pre></td></tr></table></figure>\n<p>以下出自 <strong><em>&lt;spru523h.pdf&gt;</em></strong> <em>Chapter 3.3 Creating a Task</em></p>\n<blockquote>\n<p>The process of creating a sockets application begins with the creation of a SYS/BIOS Task thread. You can use XGCONF to statically configure Tasks or use the standard SYS/BIOS API or the provided Task abstraction to dynamically create Tasks. For example, the following C code creates a basic Task:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">Task_Params taskParams;</span><br><span class=\"line\">Task_Handle hMyTask;</span><br><span class=\"line\">Error_Block eb;</span><br><span class=\"line\">Error_init(&amp;eb);</span><br><span class=\"line\"></span><br><span class=\"line\">Task_Params_init(&amp;taskParams);</span><br><span class=\"line\">taskParams.stackSize = <span class=\"number\">4096</span>;</span><br><span class=\"line\">taskParams.priority = <span class=\"number\">5</span>;             <span class=\"comment\">/* Create a Task with priority 5 */</span></span><br><span class=\"line\">hMyTask = Task_create((Task_FuncPtr)entrypoint, &amp;taskParams, &amp;eb);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (hMyTask == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">System_abort(<span class=\"string\">&quot;Task create failed&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>The same Task can be created via the <code>TaskCreate()</code> function in the Task abstraction API. The abstracted function is a little more restrictive. It creates a Task thread with exactly 3 parameters (they do not all have to be used). For example, the following call would create a Task similar to that shown above:</p>\n<p><code>hMyTask = TaskCreate( entrypoint, \"TaskName\", OS_TASKPRINORM, stacksize, arg1, arg2, arg3 );</code></p>\n<p>In both cases, <code>hMyTask</code> is a handle to a SYS/BIOS Task thread.</p>\n</blockquote>\n<h3 id=\"synchronization\">Synchronization</h3>\n<p>SYS/BIOS内的同步类型分为 <strong>进程同步</strong> 和 <strong>核同步</strong> ；同步方式共5种：<strong>Semaphore</strong>(信号量) / <strong>Event</strong>(事件) / <strong>Gate</strong>(门) / <strong>Mailbox</strong>(邮箱) / <strong>Queue</strong>(队列)</p>\n<h4 id=\"semaphore\">Semaphore</h4>\n<p>信号量可分为 <strong>互斥型</strong> 和 <strong>计数型</strong> 两种。</p>\n<p><strong>互斥型信号量</strong></p>\n<blockquote>\n<p>也称为为互斥量、二进制型信号量。可以理解为只能维护资源数量为1的二值计数信号量（值为0或1），但是互斥信号量又不同于计数信号量，因为它还具有 <strong>优先级继承</strong> 的机制。</p>\n<p>优先级继承机制是RTOS中为了避免出现 <strong>优先级翻转</strong> 问题而做的处理方式。简单来说就是如果低优先级持有互斥信号量那么高优先级任务想访问互斥量就会失败而挂起等待互斥量被释放，此时反而是低优先级任务在运行，这就出现了优先级翻转。为了避免该情况RTOS处理方式是把正在持有互斥量运行的低优先级任务的优先级提高到与等待访问互斥资源的高优先级任务同等优先级，这就是优先级继承。等互斥量被释放后RTOS会将该任务恢复到之前的低优先级。</p>\n</blockquote>\n<p><strong>特性：</strong></p>\n<ul>\n<li><p>信号量是指系统当前可用资源的数值，当资源超过1时，为 <code>计数型信号量</code> ；当资源仅为1和0时，为 <code>二进制型信号量</code>；因为资源总为1及以上，因此不论是计数型还是二进制型，可用的信号量始终≥0。</p></li>\n<li><p>信号量用于标识和实现任务的 <code>挂起</code> 和 <code>发布</code></p>\n<ul>\n<li><strong>发布</strong> 指任务正在处于结束状态，<code>Semaphore_post()</code> 将使信号量递增</li>\n<li><strong>挂起</strong> 指任务正在处于运行状态，<code>Semaphore_pend()</code> 将使信号量递减</li>\n<li>使用 <code>Semaphore_pend()</code> 以使用资源，使用 <code>Semaphore_post()</code> 以离开资源</li>\n</ul></li>\n<li><p>计数型信号量用来进行多任务管理</p>\n<ul>\n<li><code>多任务信号量</code>的初始值将为可同时进行任务的最大值</li>\n<li>当达到最大可运行任务量时，信号量值为0，即信号阻塞</li>\n</ul></li>\n<li><p>当信号量为0时，即系统资源被占满，如果此时出现最高优先级任务，系统将抢断低优先级任务从而使高优先级任务进行工作</p></li>\n</ul>\n<p><strong>任务与调用任务</strong></p>\n<blockquote>\n<p>在调用任务时，不需要特意调高被调用任务的等级。</p>\n<p>在被调用任务的等级等于本任务时，使用<code>Semaphore_post();</code> 并使用 <code>task_yeild();</code> ，即可顺利将任务切换到被调用任务。(如下 <strong>SEM-1</strong> 示)</p>\n<p>在被调用任务的等级低于本任务时，使用 <code>Semaphore_post();</code> 并使用 <code>task_sleep();</code> ，即可让低等级任务在本任务休眠期间执行。(如下 <strong>SEM-2</strong> 示)</p>\n</blockquote>\n<p><strong>SEM-1</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">task_core0TCPService</span><span class=\"params\">(UArg a0, UArg a1)</span> </span>&#123;                                      <span class=\"comment\">//Core0执行TCP信息接收任务</span></span><br><span class=\"line\">    <span class=\"keyword\">short</span> rx_length = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        Semaphore_pend( sem0_TcpReceive, BIOS_WAIT_FOREVER );</span><br><span class=\"line\">        TcpReceive(ReceiveBuffer, RECEIVEBUFFER_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rx_length &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ReceiveBufferTemp[<span class=\"number\">0</span>]==<span class=\"number\">0xf5</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">switch</span>(ReceiveBufferTemp[<span class=\"number\">2</span>])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">0x01</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(ReceiveBufferTemp[<span class=\"number\">3</span>] == <span class=\"number\">0x01</span>)&#123;                                                     </span><br><span class=\"line\">                        Semaphore_post(sem0_ad);                    <span class=\"comment\">//post同等级任务的信号量</span></span><br><span class=\"line\">                        Task_yield();                               <span class=\"comment\">//调用任务切换函数</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//...</span></span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    <span class=\"comment\">//...</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">task_core0AdcRead</span><span class=\"params\">(UArg a0, UArg a1)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;                                                                                               </span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        Semaphore_pend(sem0_ad,BIOS_WAIT_FOREVER);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ADC_Cnt &lt;= ADC_MICROSECOND)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Int <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">    Task_Handle task;                                              <span class=\"comment\">//创建空任务句柄</span></span><br><span class=\"line\">    Task_Params param;                                             <span class=\"comment\">//创建空任务参数</span></span><br><span class=\"line\">    Error_Block eb;                                                <span class=\"comment\">//创建空错误块</span></span><br><span class=\"line\">\tError_init(&amp;eb);                                               <span class=\"comment\">//初始化错误块参数</span></span><br><span class=\"line\">    Task_Params_init(&amp;param);                                      <span class=\"comment\">//初始化任务参数</span></span><br><span class=\"line\">    uart_init();                                                   <span class=\"comment\">//串口初始化</span></span><br><span class=\"line\">    uart_set_baudrate(<span class=\"number\">115200</span>);                                     <span class=\"comment\">//设置波特率</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(CSL_chipReadDNUM() == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    \tSemInit_Core0();                                            <span class=\"comment\">//配置semaphore，sem0_ad,sem0_da</span></span><br><span class=\"line\">    \tFanLed_Init();                                              <span class=\"comment\">//点亮LED3，开启FAN</span></span><br><span class=\"line\">    \tSgmii_Init();                                               <span class=\"comment\">//外设初始化</span></span><br><span class=\"line\">        ADS8568_Init();                   <span class=\"comment\">//INT6</span></span><br><span class=\"line\">        DAC8565_Init();                   <span class=\"comment\">//INT7</span></span><br><span class=\"line\">    \tTimer3_Init();                    <span class=\"comment\">//INT4</span></span><br><span class=\"line\"></span><br><span class=\"line\">        task = Task_create(task_core0Init, &amp;param, &amp;eb);</span><br><span class=\"line\">        TaskSuccess(&amp;task,<span class=\"string\">&quot;任务创建失败：task_core0Init\\n&quot;</span>); </span><br><span class=\"line\"></span><br><span class=\"line\">        param.priority=<span class=\"number\">10</span>;</span><br><span class=\"line\">        task = Task_create(task_core0TCPService, &amp;param, &amp;eb); </span><br><span class=\"line\">        TaskSuccess(&amp;task,<span class=\"string\">&quot;任务创建失败：task_core0TCPListenAndReceive!\\n&quot;</span>); </span><br><span class=\"line\"></span><br><span class=\"line\">        param.priority = <span class=\"number\">10</span>;</span><br><span class=\"line\">        task = Task_create(task_core0AdcRead, &amp;param, &amp;eb);           <span class=\"comment\">//读取AD任务</span></span><br><span class=\"line\">        TaskSuccess(&amp;task,<span class=\"string\">&quot;任务创建失败：task_core0AdcRead\\n&quot;</span>);                 </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    BIOS_start();</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>SEM-2</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Void <span class=\"title\">lowPriTask</span><span class=\"params\">(UArg arg0, UArg arg1)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;;)&#123;</span><br><span class=\"line\">\t\tSemaphore_pend(mySem, BIOS_WAIT_FOREVER); <span class=\"comment\">//挂起任务</span></span><br><span class=\"line\">\t\tresource += <span class=\"number\">1</span>;                  <span class=\"comment\">//do work on locked resource</span></span><br><span class=\"line\">\t\tSemaphore_post(mySem);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Void <span class=\"title\">hiPriTask</span><span class=\"params\">(UArg arg0, UArg arg1)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;;)&#123;</span><br><span class=\"line\">\t\tSemaphore_pend(mySem, BIOS_WAIT_FOREVER);</span><br><span class=\"line\">\t\tresource += <span class=\"number\">1</span>;                  <span class=\"comment\">//do work on locked resource</span></span><br><span class=\"line\">\t\tSemaphore_post(mySem);</span><br><span class=\"line\">\t\tTask_sleep(<span class=\"number\">5</span>);                 <span class=\"comment\">//allow low pri taks to work</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>任务与信号量之间的关系？</strong></p>\n<ul>\n<li><p>任务的顺利执行，需要经过 <strong>任务新建</strong>、<strong>信号量新建</strong>、<strong>信号量阻塞</strong> 和 <strong>信号量发布</strong> 四个流程。任务不是在被发布后就立即执行的，他需要等待信号量的到来。</p></li>\n<li><p>先pend后post，即任务执行必须由对应的信号量进行排队（阻塞）和准备（发布），如果其中任何一个步骤缺省都无法执行任务。</p></li>\n<li><p>pend要在该任务被执行时使用，放置在任务最开始的一句话中；post可以放置在别的任务或 <strong>IRS</strong> 中断里，由别的任务或函数来启动本任务。</p></li>\n<li><p>信号量使用须统一为计数型或二进制型？</p></li>\n</ul>\n<h4 id=\"event\">Event</h4>\n<h2 id=\"ndk\">NDK</h2>\n<h3 id=\"emac\">EMAC</h3>\n<p>EMAC驱动程序提供了一个定义良好的API层，允许应用程序使用EMAC外设来控制从处理器到PHY的数据包数据流，并使用MDIO模块来控制PHY配置和状态监控。</p>\n<p>EMAC驱动程序的设计要求如下:</p>\n<ul>\n<li>每个核支持多个EMAC端口(如果设备上可用)。</li>\n<li>每个核支持多个通道/MAC地址。</li>\n<li>支持多个内核在同一个EMAC端口上使用不同的通道。</li>\n<li>驱动程序是独立于操作系统的，通过OSAL操作系统层暴露所有的操作系统callout。</li>\n<li>EMAC示例测试应用程序提供了标准配置，并演示了可度量的基准测试。</li>\n</ul>\n<p>EMAC驱动程序的架构图如下:</p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/wps1.png\" alt=\"img\" style=\"zoom:67%;\" /></p>\n<p><strong>1.EMAC设备驱动程序</strong></p>\n<p>设备驱动程序公开了一组定义良好的API，应用层使用它通过EMAC外围设备发送和接收数据包，并通过MDIO外围设备配置和监视PHY。驱动程序还公开了一组定义良好的操作系统抽象API，用于确保驱动程序是操作系统独立的和可移植的。EMAC驱动程序对所有EMAC MMR访问使用CSL EMAC功能层。</p>\n<p><strong>2.应用程序代码</strong></p>\n<p>这是EMAC驱动程序的用户，它与驱动程序的接口是通过定义良好的API集实现的。应用程序用户使用EMAC驱动程序API通过EMAC外围设备发送和接收数据包。</p>\n<p><strong>3.操作系统抽象层</strong></p>\n<p>EMAC LLD是独立于操作系统的，并通过这个层公开所有的操作系统调出。</p>\n<p><strong>4.CSL功能层</strong></p>\n<p>EMAC驱动程序使用CSL EMAC功能层通过访问MMR来对设备IP进行编程。</p>\n<p><strong>5.注册层</strong></p>\n<p>寄存器层是由IP所有者生成的IP块内存映射寄存器。EMAC驱动程序不直接访问MMR寄存器，而是使用EMAC CSL功能层实现这个目的。</p>\n<h3 id=\"socket\">SOCKET</h3>\n<p>在C++/MFC中有Window Socket，作为TCP/UDP数据传输的接口工具。</p>\n<p>在C#/WPF中也有Socket，作用同上。</p>\n<p>在C++/TI.SYSBIOS的NDK套件中也有Socket作为沟通套接的工具。</p>\n<p>TI.SYSBIOS的NDK套件中，常用的函数如下：</p>\n<p><strong>NDK_accept()</strong></p>\n<blockquote>\n<p>Accept a connection on a socket</p>\n<p><code>SOCKET NDK_accept(SOCKET s, struct sockaddr *pName, int *plen);</code></p>\n</blockquote>\n<p><strong>NDK_bind</strong>()</p>\n<blockquote>\n<p>Bind a name to a socket</p>\n<p><code>int NDK_bind(SOCKET s, struct sockaddr *pName, int len);</code></p>\n</blockquote>\n<p><strong>NDK_connect</strong>()</p>\n<blockquote>\n<p>Initiate a connection on a socket</p>\n<p><code>int NDK_connect(SOCKET s, struct sockaddr *pName, int len);</code></p>\n</blockquote>\n<p><strong>NDK_getpeername()</strong></p>\n<blockquote>\n<p>Return name (address) of connected peer</p>\n<p><code>int NDK_getpeername(SOCKET s, struct sockaddr *pName, int *plen);</code></p>\n</blockquote>\n<p><strong>NDK_getsockname()</strong></p>\n<blockquote>\n<p>Return the local name (address) of the socket</p>\n<p><code>int NDK_getsockname(SOCKET s, struct sockaddr *pName, int *plen);</code></p>\n</blockquote>\n<p><strong><em>NDK_getsockopt()</em></strong></p>\n<blockquote>\n<p>Get the value of a socket option</p>\n<p><code>int NDK_getsockopt(SOCKET s, int level, int op, void *pbuf, int *pbufsize);</code></p>\n</blockquote>\n<p><strong>NDK_listen</strong>()</p>\n<blockquote>\n<p>Listen for connection requests on a socket</p>\n<p><code>int NDK_listen(SOCKET s, int maxcon);</code></p>\n</blockquote>\n<p><strong>NDK_recv()</strong></p>\n<blockquote>\n<p>Receive data from a socket</p>\n<p><code>int NDK_recv(SOCKET s, void *pbuf, int size, int flags);</code></p>\n</blockquote>\n<p><strong>NDK_recvfrom()</strong></p>\n<blockquote>\n<p>Receive data from a socket with the senders name (address)</p>\n<p><code>int NDK_recvfrom(SOCKET s, void *pbuf, int size, int flags, struct sockaddr *pName, int *plen);</code></p>\n</blockquote>\n<p><strong>NDK_send()</strong></p>\n<blockquote>\n<p>Send data to a connected socket</p>\n<p><code>int NDK_send(SOCKET s, void *pbuf, int size, int flags);</code></p>\n</blockquote>\n<p><strong>NDK_sendto()</strong></p>\n<blockquote>\n<p>Send data to a specified destination on an unconnected socket</p>\n<p><code>int NDK_sendto(SOCKET s, void *pbuf, int size, int flags, struct sockaddr *pName, int len);</code></p>\n</blockquote>\n<p><strong>NDK_setsockopt()</strong></p>\n<blockquote>\n<p>Set the value of a socket option</p>\n<p><code>int NDK_setsockopt(SOCKET s, int level, int op, void *pbuf, int bufsize);</code></p>\n</blockquote>\n<p><strong>NDK_shutdown</strong>()</p>\n<blockquote>\n<p>Close one half of a socket connection</p>\n<p><code>int NDK_shutdown(SOCKET s, int how)</code></p>\n</blockquote>\n<p><strong>NDK_socket</strong>()</p>\n<blockquote>\n<p>Create a socket</p>\n<p><code>SOCKET NDK_socket(int domain, int type, int protocol);</code></p>\n</blockquote>\n<p><strong>NDK_socketpair()</strong></p>\n<blockquote>\n<p>Create socket pair. Redundant; see Section 3.5, <em>Full Duplex Pipes</em> <em>Programming Interface</em>.</p>\n</blockquote>\n<blockquote>\n<p>The domain parameter specifies a communications domain within which communication will take place; 域参数指定通信将在其中发生的通信域;</p>\n</blockquote>\n<h1 id=\"terminology\">Terminology</h1>\n<p><strong>EMAC</strong></p>\n<blockquote>\n<p>Ethernet Media Access Controller</p>\n</blockquote>\n<p><strong>MDIO</strong></p>\n<blockquote>\n<p>Management Data Input/Output</p>\n</blockquote>\n<p><strong>PHY</strong></p>\n<blockquote>\n<p>Physical Layer</p>\n</blockquote>\n<p><strong>Purpose of the Peripheral</strong></p>\n<blockquote>\n<p>The EMAC module is used on the device to move data between the device and another host connected to the same network, in compliance with the Ethernet protocol.</p>\n</blockquote>\n<p><strong>PLL</strong></p>\n<blockquote>\n<p><strong>Phase-Locked Loop 锁相环</strong></p>\n<p><strong>锁相环路 </strong>是一种反馈控制电路，简称锁相环。</p>\n<p><strong>锁相环</strong> 的特点是：利用外部输入的参考信号控制环路内部振荡信号的频率和相位。因锁相环可以实现输出信号频率对输入信号频率的自动跟踪，所以锁相环通常用于闭环跟踪电路。</p>\n<p>锁相环在工作的过程中，当输出信号的频率与输入信号的频率相等时，输出电压与输入电压保持固定的相位差值，即输出电压与输入电压的相位被锁住，这就是锁相环名称的由来。</p>\n<p>锁相环通常由<strong>鉴相器</strong>（PD,Phase Detector）、<strong>环路滤波器</strong>（LF,Loop Filter）和 <strong>压控振荡器</strong>（VCO,Voltage Controlled Oscillator）三部分组成。</p>\n</blockquote>\n<p><strong>MII</strong></p>\n<blockquote>\n<p>以太网媒体接口有：MII、RMII、SMII、GMII</p>\n<p><strong>Media Independent Interface</strong></p>\n<p>称为 <strong>介质无关接口</strong> 或 <strong>媒体独立接口</strong>，它是 <strong>IEEE-802.3</strong> 定义的以太网行业标准。</p>\n<ul>\n<li>它包括一个 <strong>数据接口</strong> 和一个 <strong>MAC</strong> 和 <strong>PHY</strong> 之间的管理接口。<strong>数据接口</strong> 包括分别用于 <strong>发送器</strong> 和 <strong>接收器</strong> 的两条独立信道，每条信道都有自己的 数据、时钟 和 控制信号 。MII数据接口总共需要16个信号。</li>\n<li>管理接口是个双信号接口：一个是时钟信号，另一个是数据信号。通过管理接口，上层能监视和控制PHY。</li>\n<li>MII标准接口用于连接 <strong>Fast Ethernet MAC-block</strong> 与 <strong>PHY</strong>。表明在不对MAC硬件重新设计或替换的情况下，任何类型的PHY设备都可以正常工作。</li>\n<li>在其他速率下工作的与MII等效的接口有：<strong>AUI</strong>（10M　以太网）、<strong>GMII</strong>（Gigabyte　以太网）和<strong>XAUI</strong>（10-Gigabit　以太网）。</li>\n<li>MII支持10兆和100兆的操作，一个接口由14根线组成，它的支持还是比较灵活的，但是有一个<strong>缺点是因为它一个端口用的信号线太多</strong>，如果一个8端口的交换机要用到112根线，16端口就要用到224根线，到32端口的话就要用到448根线，一般按照这个接口做交换机，是不太现实的，所以现代的交换机的制作都会用到由MII简化而来的标准，如 <strong>RMII</strong>、<strong>SMII</strong>、<strong>GMII</strong> 等。\n<ul>\n<li>RMII（Reduced MII）是简化的MII接口，在数据的收发上它比MII接口少了一倍的信号线，所以它一般要求是50兆的总线时钟。RMII一般用在多端口的交换机，它不是每个端口安排收、发两个时钟，而是所有的数据端口公用一个时钟用于所有端口的收发，这里就节省了不少的端口数目。RMII的一个端口要求7个数据线，比MII少了一倍，所以交换机能够接入多一倍数据的端口。和MII一样，RMII支持10兆和100兆的总线接口速度。</li>\n<li>SMII（Serial MII）是由思科提出的一种媒体接口，它有比RMII更少的信号线数目，S表示串行的意思。因为它只用一根信号线传送发送数据，一根信号线传输接受数据，所以在时钟上为了满足100的需求，它的时钟频率很高，达到了125兆，为什么用125兆，是因为数据线里面会传送一些控制信息。SMII一个端口仅用4根信号线完成100信号的传输，比起RMII差不多又少了一倍的信号线。SMII在工业界的支持力度是很高的。同理，所有端口的数据收发都公用同一个外部的125M时钟。</li>\n<li>GMII（Gigabyte MII）是千兆网的MII接口，这个也有相应的RGMII接口，表示简化了的GMII接口。</li>\n</ul></li>\n</ul>\n<p><em>MII （Management interface）只有两条信号线。</em></p>\n</blockquote>\n<p><strong>SGMII</strong></p>\n<blockquote>\n<p>Serial Gigabit Media Independent Interface</p>\n</blockquote>\n<p><strong>SerDes</strong></p>\n<blockquote>\n\n</blockquote>\n<p><strong>ESD</strong></p>\n<blockquote>\n<p>Electrostatic discharge</p>\n</blockquote>\n<p><strong>STATS</strong></p>\n<blockquote>\n\n</blockquote>\n<p><strong>SOP</strong></p>\n<blockquote>\n<p>Start of Packet, the first fragment of packet</p>\n</blockquote>\n<p><strong>EOP</strong></p>\n<blockquote>\n<p>End of Packet, the last fragment of packet</p>\n</blockquote>\n<p><strong>EOQ</strong></p>\n<blockquote>\n<p>end-of-queue</p>\n</blockquote>\n<p><strong>LSB</strong></p>\n<blockquote>\n<p>least-significant bit</p>\n</blockquote>\n<p><strong>HDP</strong></p>\n<blockquote>\n<p>head descriptor pointer</p>\n</blockquote>\n<p><strong>DMA</strong></p>\n<blockquote>\n\n</blockquote>\n<p><strong>TXnHDP</strong></p>\n<blockquote>\n<p>Transmit Channel <em>n</em> DMA Head Descriptor Pointer Register</p>\n</blockquote>\n<p><strong>RXnHDP</strong></p>\n<blockquote>\n<p>Receive Channel <em>n</em> DMA Head Descriptor Pointer Register</p>\n</blockquote>\n<p><strong>Swi</strong></p>\n<blockquote>\n<p>Software Interrupt</p>\n</blockquote>\n<p><strong>Hwi</strong></p>\n<blockquote>\n<p>Hardware Interrupt</p>\n</blockquote>\n<p><strong>ISR</strong></p>\n<blockquote>\n<p>中断服务程序</p>\n</blockquote>\n<p><strong>C99</strong></p>\n<blockquote>\n<p><strong>C99</strong> （以前称为<strong>C9X</strong> ）是<strong>ISO / IEC 9899：1999</strong>的非正式名称，在1999年推出，被ANSI于2000年3月采用。它是C编程语言标准的过去版本。 它扩展了以前的版本（ C90 ），增加了语言和标准库的新功能，并帮助实现更好地利用可用的计算机硬件，如IEEE 754-1985浮点运算和编译器技术，最主要的增强在数值处理上。 2011年发布的C编程语言标准的C11版本取代了C99。</p>\n<p>C99是在C89/90的基础上发展起来的，增加了基本数据类型、关键字和一些系统函数等。</p>\n<p>C99有一部分是对于增加了宽字符集，还加入了一些库函数，是继C89标准之后的第二个C语言官方标准。第一个<a href=\"https://baike.baidu.com/item/C%2B%2B\">C++</a>语言官方标准C++98标准，就是基于C89编写的，因此C99标准新增的语法特性在C++的编译器中就或多或少地支持了，而完全或几乎完全支持C99标准的主流编译器有：GCC 、Clang 、Intel C++ Compiler 等。另外，Visual Studio 2013也部分支持了C99语法特征 。</p>\n<p>C99标准的<strong>草案</strong>是免费的 [6]</p>\n</blockquote>\n<p><strong>初始化列表</strong></p>\n<blockquote>\n<p>初始化列表是用于初始化一组（结构体）内存位置的值列表。</p>\n<p>例如，假设已经声明了以下 Date 结构体：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Date</span>&#123;</span><span class=\"keyword\">int</span> day, month, year;&#125;;</span><br></pre></td></tr></table></figure>\n<p>定义和初始化 Date 变量的方式是：先指定变量名，后接赋值运算符和初始化列表，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">Date birthday = &#123;<span class=\"number\">23</span>, <span class=\"number\">8</span>, <span class=\"number\">1983</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p>该声明定义 birthday 是一个 Date 结构体的变量，大括号内的值按顺序分配给其成员。</p>\n<p>也可以仅初始化结构体变量的部分成员。例如，如果仅知道要存储的生日是8月23日， 但不知道年份，则可以按以下方式定义和初始化变量：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">Date birthday = &#123;<span class=\"number\">23</span>,<span class=\"number\">8</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里只有 day 和 month 成员被初始化，year 成员未初始化。但是，如果某个结构成员未被初始化，则所有跟在它后面的成员都需要保留为未初始化。使用初始化列表时，<a href=\"http://c.biancheng.net/cplus/\">C++</a> 不提供跳过成员的方法。以下语句试图跳过 month 成员的初始化。这是不合法的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Date birthday &#x3D; &#123;23,1983&#125;; &#x2F;&#x2F;非法</span><br></pre></td></tr></table></figure>\n<p>还有一点很重要，不能在结构体声明中初始化结构体成员，因为结构体声明只是创建一个新的数据类型，还不存在这种类型的变量。因为<strong>结构体声明只声明一个结构体“看起来是什么样子的”，所以不会在内存中创建成员变量。</strong>只有通过定义该结构体类型的变量来实例化结构体，才有地方存储初始值。</p>\n</blockquote>\n<p><strong>构造函数</strong></p>\n<blockquote>\n<p>虽然初始化列表易于使用，但它有两个缺点：</p>\n<ol type=\"1\">\n<li>如果有某个成员未被初始化，那么在这种情况下，跟随在该成员后面的成员都不能初始化。</li>\n<li>如果结构体包括任何诸如字符串之类的对象，那么在许多编译器上它都将无法运行。</li>\n</ol>\n<p>在这些情况下，可以使用构造函数来初始化结构体成员变量，这和初始化类成员变量是相同的。与类构造函数一样，结构体的构造函数必须是与结构体名称相同的公共成员函数，并且没有返回类型。因为默认情况下，所有结构体成员都是公开的，所以不需要使用关键字 public。</p>\n<p>以下是一个名为 Employee 的结构体的声明语句，它包含一个具有两参数的构造函数，以便在创建一个 Employee 变量而不向其传递任何参数时，提供默认值：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Employee</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> name;    <span class=\"comment\">// 员工姓名</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vacationDays,    <span class=\"comment\">// 允许的年假</span></span><br><span class=\"line\">    daysUsed;    <span class=\"comment\">//已使用的年假天数</span></span><br><span class=\"line\">    Employee (<span class=\"built_in\">string</span> n =<span class=\"string\">&quot;&quot;</span>,<span class=\"keyword\">int</span> d = <span class=\"number\">0</span>)    <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        name = n;</span><br><span class=\"line\">        vacationDays = <span class=\"number\">10</span>;</span><br><span class=\"line\">        daysUsed = d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>Const in C++</strong></p>\n<blockquote>\n<ol type=\"1\">\n<li><p><strong>const与#define</strong></p>\n<p>两者都可以用来定义常量，但是const定义时，定义了常量的类型，所以更精确一些。</p>\n<p>#define只是简单的文本替换，除了可以定义常量外，还可以用来定义一些简单的函数，有点类似内联函数(Inline)。</p>\n<p>const和define定义的常量可以放在头文件里面。（小注：可以多次声明，但只能定义一次）</p></li>\n<li><p><strong>const与指针和引用</strong></p>\n<ul>\n<li><p>const与指针</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> me;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* p1 = &amp;me;<span class=\"comment\">//p1可变，*p1不可变，此时不能用*p1来修改，但是p1可以转向</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>* <span class=\"keyword\">const</span> p2 = &amp;me;<span class=\"comment\">//p2不可变，*p2可变，此时允许*p2来修改其值，但是p2不能转向。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* <span class=\"keyword\">const</span> p3 = &amp;me;<span class=\"comment\">//p3不可变，*p3也不可变，此时既不能用*p3来修改其值，也不能转向</span></span><br></pre></td></tr></table></figure></li>\n<li><p>指针和引用的区别很简单，就是引用更简洁，更安全。因为引用声明时必须初始化。 引用更接近const指针，一旦与某个变量关联，就将一直效忠于他。</p></li>\n<li><p><strong>const指针可以接受const和非const地址，但是非const指针只能接受非const地址</strong>。所以const指针的能力更强一些，所以尽量多用const指针，这是一种习惯。</p></li>\n</ul></li>\n<li><p>const与函数</p></li>\n</ol>\n<ul>\n<li><p>由于2.3，所以经常把函数的形参类型设为const，而且多为<strong>const 引用</strong>。但是这里有一个限制，<strong>不能把不是左值的地址传递给引用</strong>。（左值包括变量，数组元素，结构成员，引用，被解除引用的指针等）。 形参是const类型的，说明该函数将不会修改其值，该函数便为const函数。</p></li>\n<li><p>const与类成员函数。先看看下面这段代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Stock land = Stock(<span class=\"string\">&quot;hyd&quot;</span>);</span><br><span class=\"line\">land.show();</span><br></pre></td></tr></table></figure>\n<p>land 是常量，但是类成员函数show()无法保证不修改land，所以编译器将拒绝执行该段代码。除非你能保证show像const函数一样，但这需要另外一种语法，即：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>; <span class=\"comment\">//声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Stock::show</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;&#125; <span class=\"comment\">//定义</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</blockquote>\n<p><strong>内联函数</strong></p>\n<blockquote>\n<p>Inline Functions</p>\n</blockquote>\n<p><strong>超级循环</strong></p>\n<blockquote>\n\n</blockquote>\n<p><strong>ANC</strong></p>\n<blockquote>\n\n</blockquote>\n<p><strong>IPC</strong></p>\n<blockquote>\n<p>Inter-Processor Communication</p>\n<p>内部处理器通信</p>\n</blockquote>\n<p><strong>NDK</strong></p>\n<blockquote>\n<p>Network Development Kit</p>\n<p>网络开发套件</p>\n</blockquote>\n<p><strong>GPIO</strong></p>\n<blockquote>\n<p>General Purpose Input/Output</p>\n<p>通用型之输入输出的简称，功能类似8051的P0—P3，其接脚可以供使用者由程控自由使用，PIN脚依现实考量可作为通用输入（GPI）或通用输出（GPO）或通用输入与输出（GPIO），如当clk generator, chip select等。</p>\n<p>既然一个引脚可以用于输入、输出或其他特殊功能，那么一定有寄存器用来选择这些功能。对于输入，一定可以通过读取某个寄存器来确定引脚电位的高低；对于输出，一定可以通过写入某个寄存器来让这个引脚输出高电位或者低电位；对于其他特殊功能，则有另外的寄存器来控制它们。</p>\n</blockquote>\n<p><strong>EMIFA</strong></p>\n<blockquote>\n\n</blockquote>\n<p><strong>SRIO</strong></p>\n<blockquote>\n<p>高速串行IO口</p>\n</blockquote>\n<p><strong>Hyperlink</strong></p>\n<blockquote>\n<p>超链接</p>\n</blockquote>\n<p><strong>JTAG</strong></p>\n<blockquote>\n\n</blockquote>\n<p><strong>Warm reset</strong></p>\n<blockquote>\n<p>软复位</p>\n</blockquote>\n<p><strong>LLD</strong></p>\n<blockquote>\n<p>Low Level Driver</p>\n</blockquote>\n<p><strong>HAL</strong></p>\n<blockquote>\n<p>Hardware Adaption Layer硬件适应层</p>\n</blockquote>\n<p><strong>IGMP</strong></p>\n<blockquote>\n<p>Internet Group Management Protocol</p>\n<p>Internet Group Management Protocol (IGMP) is designed to help routers in routing IP multicast traffic. Each router can have multiple ports, and it is inefficient for the router to replicate every IP multicast packet out of each active port. Using the IGMP protocol, the multicast router is able to keep track of which IP multicast addresses need to be routed to each individual port. This allows the router to limit IP multicast transmission to only those ports that require the multicast traffic. IGMP 是用来帮助路由器路由IP组播流量的。每个路由器可以有多个端口，并且路由器从每个活动端口复制每个IP组播包是低效的。使用IGMP协议，组播路由器能够跟踪哪些IP组播地址需要被路由到每个单独的端口。这允许路由器将IP组播传输限制为仅需要组播流量的端口。</p>\n<p>The IGMP protocol assumes a client/server relationship between endpoints. The IGMP server is run by the multicast router to get IP multicast information about all the client on each of its individual ports. The IGMP client is only concerned with communicating its own multicast requirements to the local IGMP server, so that it will get the IP multicast packets that it requires. IGMP协议假定端点之间存在客户端/服务器关系。IGMP服务器由组播路由器运行，以获得关于每个单独端口上的所有客户端的IP组播信息。IGMP客户端只关心把它自己的组播要求传达给本地IGMP服务器，这样它就会得到它所需要的IP组播包。</p>\n</blockquote>\n<h1 id=\"vocabulary\">Vocabulary</h1>\n<ol type=\"1\">\n<li><p>granularity n. 间隔尺寸，[岩] 粒度</p>\n<blockquote>\n<p>the quality of being composed of relatively large particles</p>\n</blockquote></li>\n<li><p>be patched with 用**修补</p>\n<blockquote>\n<p><strong>patched</strong> <em>/pætʃt/</em></p>\n<p>adj. 打补丁的 v. 打补丁；遮盖（视力好的眼）促进弱视眼看；（用补丁对程序）改错（patch 的过去式和过去分词）</p>\n</blockquote></li>\n<li><p>an entire contiguous Ethernet packet 一个完整连续的以太网包</p></li>\n<li><p>byte-aligned memory address 字节内存地址</p>\n<blockquote>\n<p><strong>aligned</strong> [əˈlaɪnd]</p>\n<ol start=\"22\" type=\"a\">\n<li>结盟；支持；使成一直线；校准；安放，排列；使一致（align 的过去式和过去分词）</li>\n</ol>\n</blockquote></li>\n<li><p>prior <em>[ˈpraɪər]</em> adj. （时间、顺序等）先前的；优先的</p></li>\n<li><p>indicate vt. 表明；指出；预示；象征</p></li>\n<li><p>prologue <em>/prəʊlɒg/</em> n. 开场白</p></li>\n<li><p>auxiliary definitions 辅助定义</p>\n<blockquote>\n<p><strong>auxiliary</strong> [ɔːɡˈzɪliəri]</p>\n<p>adj. 辅助的；副的；附加的；（发动机、设备等）备用的</p>\n</blockquote></li>\n<li><p>static inline 静态内联</p></li>\n<li><p>volatile unsigned int</p>\n<blockquote>\n<p><strong>volatile</strong> [ˈvɒlətaɪl]</p>\n<p>adj. [化学] 挥发性的；不稳定的；爆炸性的；反复无常的</p>\n<ol start=\"14\" type=\"a\">\n<li>挥发物；有翅的动物</li>\n</ol>\n</blockquote></li>\n<li><p>heap n. 信号量</p></li>\n<li><p>explicity and implicity 显性和隐性</p>\n<blockquote>\n<p><strong>explicitly</strong> [ɪkˈsplɪsɪtli]</p>\n<p>adv. 明确地；明白地</p>\n<p><strong>implicitly</strong> [ɪmˈplɪsɪtli]</p>\n<p>adv. 含蓄地；暗中地</p>\n</blockquote></li>\n<li><p>assertion check 断言检查</p>\n<blockquote>\n<p><strong>assertion</strong> [əˈsɜːʃn]</p>\n<ol start=\"14\" type=\"a\">\n<li>断言，声明；主张，要求；坚持；认定</li>\n</ol>\n<p>assert</p>\n<p>internal asserts</p>\n</blockquote></li>\n<li><p>wrapper function 包装函数</p></li>\n<li><p>name mangling （函数）命名重整</p>\n<blockquote>\n<p><strong>mangle</strong> <em>/mæŋgl/</em></p>\n<p>vt. 乱砍、损坏</p>\n<p>The process of encoding the signature into the link name is referred to as <strong>name mangling</strong>. 对链接名称解码签名的过程被称为命名重整。</p>\n<p>Since function overloading is accomplished through <strong>name mangling</strong>, function overloading has limitations for functions that are called from the configuration. 由于函数重载是通过命名重整完成的，因此函数重载对从配置中调用的函数有限制。</p>\n</blockquote></li>\n<li><p>periodic <em>/periɒdik/</em> adj. 周期的</p>\n<blockquote>\n<p><strong>period</strong> n. 周期</p>\n</blockquote></li>\n<li><p>instantiation of clock 时钟实例化</p></li>\n<li><p>advancing the connected timer by one second 将连接的时钟向前推进1秒</p>\n<blockquote>\n<p>advance at different rates 以不同的速率前进</p>\n</blockquote></li>\n<li><p>the attached clock 附带的时钟</p></li>\n<li><p>results in an accurate clock 产生了（导致、致使）一个精确的时钟</p></li>\n<li><p>constructor n. 构造函数；构造器；建造者</p></li>\n<li><p>destructor n. 析构函数</p></li>\n<li><p>millenium n. 千年；千禧年</p></li>\n<li><p>leap year 闰年</p></li>\n<li><p>millisecond [ˈmɪlisekənd] n. 毫秒；千分之一秒</p>\n<blockquote>\n<p>microsecond 微秒</p>\n</blockquote></li>\n<li><p>semaphore [ˈseməfɔːr] n. 信号标，旗语；臂板信号装置 v. 打旗语，发信号</p></li>\n<li><p>diagnostics n. 诊断学（用作单数）</p></li>\n<li><p>declaration <em>/,deklə'reiʃən/</em> n. （纳税品等的）申报；宣布；公告；申诉书；声明；</p></li>\n<li><p>prefix n. 前缀 vt. 加前缀；将某事物加在前面</p></li>\n<li><p>assembly source 汇编源代码</p>\n<blockquote>\n<p>assembly code 汇编码</p>\n</blockquote></li>\n<li><p>toggle split editor 切换分屏编辑器</p>\n<blockquote>\n<p><strong>toggle</strong> [ˈtɒɡl]</p>\n<ol start=\"14\" type=\"a\">\n<li><p>拴扣；切换键，开关；套索钉</p></li>\n<li><p>切换；拴牢，系紧</p></li>\n</ol>\n<p><strong>split</strong> [splɪt]</p>\nvt. 分离；使分离；劈开；离开；分解\n<ol start=\"6\" type=\"i\">\n<li>离开；被劈开；断绝关系</li>\n</ol>\n<ol start=\"14\" type=\"a\">\n<li>劈开；裂缝 adj. 劈开的</li>\n</ol>\n<p>toggle full screen 切换全屏幕</p>\n<p>toggle funciton</p>\n</blockquote></li>\n<li><p>perspective n. 观点；远景；透视图 adj. 透视的</p>\n<blockquote>\n<p>customize perspective</p>\n</blockquote></li>\n<li><p>energia [e'nə:dʒiə] n. (Energia) 能源（火箭名）</p>\n<blockquote>\n<p>energia sketch 能源草图？</p>\n</blockquote></li>\n<li><p>specifications for benchmark tests 基准测试规范</p>\n<blockquote>\n<p><strong>specification</strong></p>\n<p>​ a detailed description of design criteria for a piece of work</p>\n<p>​ n. 规范</p>\n<p><strong>benchmark</strong></p>\n<p>​ a standard by which something can be measured or judged</p>\n<p>​ n. 参考标准，基准</p>\n</blockquote></li>\n<li><p>target-specific functions 目标特定的功能</p>\n<blockquote>\n<p>device-specific functions 设备特定的功能</p>\n</blockquote></li>\n<li><p>implementation of the IGateProvider interface IGateProvider 接口的实现</p>\n<blockquote>\n<p><strong>implement</strong></p>\n<p>​ apply in a manner consistent with its purpose or design</p>\n<p>​ v. 实现</p>\n</blockquote></li>\n<li><p>fixed-size buffers 固定大小缓冲</p>\n<blockquote>\n<p><strong>fixed</strong></p>\n<p>​ adj. 固定的</p>\n<p>variable-sized buffers 可变大小缓冲</p>\n</blockquote></li>\n<li><p>dynamic memory allocation and deallocation 动态内存分配和回收</p></li>\n<li><p>reentrant versions 可重入版本</p>\n<blockquote>\n<p>SYS/BIOS provides reentrant versions of malloc() and free() that internally use the xdc.runtime.</p>\n<p>SYS/BIOS为内部使用XDC.RUNTIME的 malloc() 和 free() 提供了可重入版本。</p>\n</blockquote></li>\n<li><p>formal parameter 形式参数</p>\n<blockquote>\n<p>C++ allows you to specify default values for formal parameters within the function declaration.</p>\n<p>C++允许你在函数声明中指定形参的默认值。</p>\n</blockquote></li>\n<li><p>invoke the class member function 调用类成员函数</p>\n<blockquote>\n<p>By writing a wrapper function which accepts a class instance as a parameter, you can invoke the class member function from within the wrapper. 通过编写以类实例作为参数的包装函数，你可以在包装函数中调用其类成员函数。</p>\n</blockquote></li>\n<li><p>context of a software interrupt 软件中断的上下文</p>\n<blockquote>\n<p>Memory allocation APIs such as <code>Memory_alloc()</code> and <code>Memory_calloc()</code> cannot be called from within the context of a software interrupt.内存分配接口如A和B不能够在软件中断的上下文中被调用。</p>\n</blockquote></li>\n<li><p>initial commit message 初始提交消息</p>\n<blockquote>\n<p><strong>commit</strong> [kəˈmɪt]</p>\n<p>​ vt. 犯罪；把...交托给；指派…作战；使…承担义务；（公开地）表示意见</p>\n<p>​ vi. 忠于（某个人、机构等）；承诺</p>\n<p>amend last commit 修改上一次提交（的数据）</p>\n</blockquote></li>\n<li><p>stage changed （确认）暂存（数据）已变化</p></li>\n<li><p>device endianness 设备字节顺序</p></li>\n<li><p>preempt 抢占</p>\n<blockquote>\n<p>All Clock functions run at the same Swi priority, so one Clock function cannot preempt another. 所有的时钟函数都运行在相同的SWI优先级，所以一个时钟函数不能抢占另一个时钟函数。</p>\n</blockquote></li>\n<li><p>terminate <em>/ˈtɜːmɪneɪt/</em> vi./vt. 使终止；使结束；解雇</p></li>\n<li><p>Event Combiner 事件组合器</p></li>\n<li><p>optimal isolation 最佳隔离？？？</p>\n<blockquote>\n<p>As previously stated, the stack has been designed for optimal isolation, and so that it may seamlessly plug in to varying run-time environments.</p>\n</blockquote></li>\n<li><p>octet /ɔk'tet/ 八重、八位（计算机语境下，基本与byte同意）</p></li>\n<li><p>configuration entry 配置条目</p></li>\n<li><p>is independent of 独立于……；相对于……独立</p></li>\n<li><p>Parsing CGI Form Data 解析CGI结构的数据</p>\n<blockquote>\n<p>parse <em>/'pɑːz/</em> v.理解，从语法上分析</p>\n</blockquote></li>\n<li></li>\n</ol>\n<h1 id=\"reference\">Reference</h1>\n<p>www.digoboy.com</p>\n","categories":["Hardware"],"tags":["C","TI"]},{"title":"TI多核开发","url":"/2021/04/02/Hardware/DSP/2021-04-02-TI%E5%A4%9A%E6%A0%B8%E5%BC%80%E5%8F%91/","content":"<p>多核开发涉及多核通信及任务分配管理的问题，任何多核通信都需要针对具体芯片的型号及系统特性去设计。多核通信包括资源共享、竞争、同步、异步等问题；多核任务分配则关系着各核心任务均衡和RTOS系统能否及时响应的问题。</p>\n<h1 id=\"基础知识\">1. 基础知识</h1>\n<h2 id=\"并发并行异步同步共享互斥进程线程\">并发、并行、异步、同步、共享、互斥、进程、线程</h2>\n<h3 id=\"concurrency-并发\">Concurrency 并发</h3>\n<p>仅表示计算机可以同时执行多项任务，以至于如何实现“同时”执行，则有许多不同形式。</p>\n<p>如，单核处理器可以通过分配时间片，轮询任务来达到多任务并发。系统让一个任务运行一段时间，在切换到另一个任务运行，如此循环往复，此过程也被称为 线程的<strong>上下文切换（Context Switching）</strong>。</p>\n<h3 id=\"parallelism-并行\">Parallelism 并行</h3>\n<p>多个任务于同一时刻在不同的和核心上进行处理，称为并行</p>\n<h3 id=\"synchronization-同步\">Synchronization 同步</h3>\n<p>指程序任务间的先后关系，后面一个程序必须等前一个任务执行完毕方可启动。因此，在同步中，并无并发或并行概念</p>\n<h3 id=\"asynchronization-异步\">Asynchronization 异步</h3>\n<p>指不同的任务之间不会相互等待</p>\n<p>对于I/O资源访问频繁的系统，宜使用异步编程，</p>\n<h3 id=\"mutual-exclusion-互斥\">Mutual Exclusion 互斥</h3>\n<p>程序内存开销 及 线程切换开销</p>\n<h2 id=\"堆栈\">堆、栈</h2>\n<p>题目所指的 heap 和 stack 在 C++ 标准中相对的术语分别是<strong>自由存储</strong>（free store，即用<code>new</code>创建对象时所分配的空间）和<strong>自动变量</strong>（automatic variable，或称为局部变量，不要与 C++11 的<code>auto</code>混淆）。</p>\n<p>编程角度，要分开两者，是因为两者的生命周期不一样。</p>\n<p>如果只需要在作用域内维持变量的生命周期，最好就用自动变量，这样是最简单方便高效的。其他情况可考虑用自由存储、静态局部／全局变量，或类的（静态）成员变量。它们各有不同特点，不在此答案详述。另外，由于 C++ 不支持可变长数组（VLA），不可以定义动态长度的自动变量（成员变量也不行），这个情况下也需要用 new[] 来创建动态长度的数组。</p>\n<p>自动变量会在作用域（如函数作用域、块作用域等）结束后析构、释放内存。因为分配和释放的次序是刚好完全相反的，所以可用到堆栈先进后出（first-in-last-out, FILO）的特性，而 C++ 语言的实现一般也会使用到调用堆栈（call stack）来分配自动变量（但非标准的要求）。 自由存储可以在函数结束后继续生存，所以也需要配合 delete 来手动析构、释放内存（也可使用智能指针避免手动 delete）。由于分配和释放次序没有限制，不能使用堆栈这种数据结构做分配，实现上可能采用自由链表（free list）或其他动态内存分配机制。</p>\n<p><strong>堆</strong>，英文是 heap，在内存管理的语境下，指的是动态分配内存的区域。这个堆跟数据结构里的堆不是一回事。这里的内存，被分配之后需要手工释放，否则，就会造成内存泄漏。</p>\n<p>C++ 标准里一个相关概念是自由存储区(free store)，特指使用 <code>new</code> 和 <code>delete</code> 来分配和释放内存的区域。一般而言，free store是堆(heap)的一个子集，原因如下：</p>\n<ul>\n<li><code>new</code> 和 <code>delete</code> 操作的区域是 free store；<code>malloc</code> 和 <code>free</code> 操作的区域是 heap</li>\n<li><code>new</code> 和 <code>delete</code> 通常底层使用 <code>malloc</code> 和 <code>free</code> 来实现</li>\n</ul>\n<p><strong>栈</strong>，英文是 stack，在内存管理的语境下，指的是函数调用过程中产生的本地变量和调用数据的区域。这个栈和数据结构里的栈高度相似，都满足“后进先出”（last-in-first-out 或 LIFO）。</p>\n<p><strong>RAII</strong>，完整的英文是 Resource Acquisition Is Initialization，是 C++ 所特有的资源管理方式。有少量其他语言，如 D、Ada 和 Rust 也采纳了 RAII，但主流的编程语言中， C++ 是唯一一个依赖 RAII 来做资源管理的。</p>\n<p>RAII 依托栈和析构函数，来对所有的资源——包括堆内存在内——进行管理。对 RAII 的使用，使得 C++ 不需要类似于 Java 那样的垃圾收集方法，也能有效地对内存进行管理。RAII 的存在，也是垃圾收集虽然理论上可以在 C++ 使用，但从来没有真正流行过的主要原因。</p>\n<p>嵌入式的设备如DSP上的栈空间是Kb级别，在函数内定义数组或申请空间都不能像linux下那样直接定义和申请，要么定义成全局的，要么指向一块划分好的空间，否则就会造成覆盖代码段等的问题。</p>\n<p>DSP的所有变量，函数，以及程序员定义的地址都保存在这三片空间上，程序员在定义变量时，若没有特殊规定，则编译器自动把变量分配到可读写空间上的任意位置，所以当程序员使用 <code>int *p = 0x00810000</code> ；这种语法的时候，很有可能会覆盖掉程序保存变量和函数的空间，导致程序运行异常，因此需要一个 <code>.cmd</code> 文件来约束，哪些地方用来给程序员自己定义变量地址用，哪些地方用来给程序为变量和函数申请内存来用。</p>\n<h1 id=\"多核通信模块\">2. 多核通信模块</h1>\n<blockquote>\n<p><em>IPC Modules can be used in a variety of combinations.</em></p>\n</blockquote>\n<p>以上即是说，各类IPC模块可以根据需要进行组合混用。</p>\n<p>IPC以独立插件的形式进行安装与使用，使用时可能需要手动挂载至项目属性中。</p>\n<p>Here are some introductions about heap in the &lt;SPRUEX3K.pdf&gt; as follows:</p>\n<blockquote>\n<p>SYS/BIOS provides the following Heap implementations: - <strong>HeapMem.</strong> Allocate variable-size blocks. Section 6.8.1 - <strong>HeapBuf.</strong> Allocate fixed-size blocks. Section 6.8.2 - <strong>HeapMultiBuf.</strong> Specify variable-size allocation, but internally allocate from a variety of fixed-size blocks. Section 6.8.3</p>\n</blockquote>\n<table>\n<colgroup>\n<col style=\"width: 22%\" />\n<col style=\"width: 32%\" />\n<col style=\"width: 45%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Module</th>\n<th>Module Path</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>GateMP（门）</td>\n<td><code>GateMP</code></td>\n<td>Manages gates for mutual exclusion of shared resources by multiple processors and threads. <br/><em>See Section 2.6.</em></td>\n</tr>\n<tr class=\"even\">\n<td>HeapBufMP（堆缓存）</td>\n<td><code>ti.sdo.ipc.heaps.HeapBufMP</code></td>\n<td>Fixed-sized shared memory Heaps. Similar to SYS/BIOS’s <code>ti.sysbios.heaps.HeapBuf</code> module, but with some configuration differences. <br/><em>See Section 2.5.</em></td>\n</tr>\n<tr class=\"odd\">\n<td>HeapMemMP（堆储存）</td>\n<td><code>ti.sdo.ipc.heaps.HeapMemMP</code></td>\n<td>Variable-sized shared memory Heaps. <br/><em>See Section 2.5.</em></td>\n</tr>\n<tr class=\"even\">\n<td>HeapMultiBufMP（堆混合缓存）</td>\n<td><code>ti.sdo.ipc.heaps.HeapMultiBufMP</code></td>\n<td>Multiple fixed-sized shared memory Heaps. <br/><em>See Section 2.5.</em></td>\n</tr>\n<tr class=\"odd\">\n<td>Ipc（核间通信）</td>\n<td><code>ti.sdo.ipc.Ipc</code></td>\n<td>Provides <code>Ipc_start()</code> function and allows startup sequence configuration. <br/><em>See Section 2.2.</em></td>\n</tr>\n<tr class=\"even\">\n<td>ListMP（列表）</td>\n<td><code>ti.sdo.ipc.ListMP</code></td>\n<td>Doubly-linked list for shared-memory, multi-processor applications. Very similar to the ti.sdo.utils.List module. <br/><em>See Section 2.4.</em></td>\n</tr>\n<tr class=\"odd\">\n<td>MessageQ （Q报文）</td>\n<td><code>ti.sdo.ipc.MessageQ</code></td>\n<td>Variable size messaging module. 可拥有不同大小的信息模块。<br/><em>See Section 2.3.</em></td>\n</tr>\n<tr class=\"even\">\n<td>TransportShm（运输表）</td>\n<td><code>ti.sdo.ipc.transports.TransportShm</code></td>\n<td>Transport used by MessageQ for remote communication with other processors via shared memory. <br/><em>See Section 2.3.11.</em></td>\n</tr>\n<tr class=\"odd\">\n<td>Notify （通知）</td>\n<td><code>ti.sdo.ipc.Notify</code></td>\n<td>Low-level interrupt mux/demuxer module. <br/><em>See Section 2.7.</em></td>\n</tr>\n<tr class=\"even\">\n<td>NotifyDriverShm（通知驱动表）</td>\n<td><code>ti.sdo.ipc.notifyDrivers.NotifyDriverShm</code></td>\n<td>Shared memory notification driver used by the Notify module to communicate between a pair of processors. <br/><em>See Section 2.7.</em></td>\n</tr>\n<tr class=\"odd\">\n<td>SharedRegion （共享区域）</td>\n<td><code>ti.sdo.ipc.SharedRegion</code></td>\n<td>Maintains shared memory for multiple shared regions. <br/><em>See Section 2.8.</em></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"header-files-included\">Header Files included</h2>\n<p>除了<code>&lt;ipc_install_dir&gt;/packages/ti/ipc/</code> 路径下可以找到IPC必须的头文件外， <code>&lt;ipc_install_dir&gt;/packages/ti/sdo/ipc/</code> 路径下同样有IPC的头文件，但是请勿直接引用至 <code>.c</code>文件中。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;xdc/std.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">/* ---- XDC.RUNTIME module Headers */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;xdc/runtime/Memory.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;xdc/runtime/System.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;xdc/runtime/IHeap.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;xdc/runtime/Timestamp.h&gt;</span>    <span class=\"comment\">//not officially included</span></span></span><br><span class=\"line\"><span class=\"comment\">/* ----- IPC module Headers */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ti/ipc/GateMP.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ti/ipc/Ipc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ti/ipc/MessageQ.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ti/ipc/HeapBufMP.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ti/ipc/MultiProc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">/* ---- BIOS6 module Headers */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ti/sysbios/BIOS.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ti/sysbios/knl/Task.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">/* ---- Get globals from .cfg Header */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;xdc/cfg/global.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"standard-ipc-function-call-sequence\">Standard IPC Function Call Sequence</h2>\n<p>Standard IPC Function Call Sequence，即标准IPC函数的调用顺序。</p>\n<blockquote>\n<p><strong><em>MODULE</em></strong> 在本处指任一类型的IPC调用（如，GateMP、IPC、MessageQ等），如 <code>MODULE_Open()</code> 即可替换成 <code>MessageQ_Open()</code> ，具体实参见对应的头文件。</p>\n</blockquote>\n<p>An application that uses IPC APIs—such as <code>MessageQ</code>, <code>GateMP</code>, and <code>ListMP</code>—<strong>must include the Ipc module header file and call <code>Ipc_start()</code> in the <code>main()</code> function. </strong> <code>Ipc_start()</code> does the following:</p>\n<ul>\n<li>初始化：Initializes a number of objects and modules used by IPC.</li>\n<li>同步：Synchronizes multiple processors so they can boot in any order.</li>\n</ul>\n<p><strong>NOTES:</strong> If the <code>main()</code> function calls any IPC APIs, the call to <code>Ipc_start()</code> must be placed before any calls to IPC modules.</p>\n<h3 id=\"调用顺序\">调用顺序</h3>\n<ul>\n<li>Firstly, initialize a <code>MODULE_Params</code> structure to its default values via a <code>MODULE_Params_init()</code> function. The creator thread can then set individual parameter fields in this structure as needed.</li>\n<li>Secondly, calls the <code>MODULE_create()</code> function to creates the instance and initializes any shared memory used by the instance. <em>If the instance is to be opened remotely, a unique name must be supplied in the parameters.</em></li>\n<li>Other threads can access this instance via the <code>MODULE_open()</code> function, which <strong>returns a handle with access to the instance.</strong> The name that was used for instance creation must be used in the <code>MODULE_open()</code> function.</li>\n<li>Finally, the thread that called <code>MODULE_create()</code> can call <code>MODULE_delete()</code> to free the memory used by the instance.</li>\n</ul>\n<blockquote>\n<ul>\n<li>首先，使用 <code>MODULE_Params_init()</code> 来初始化 <code>MODULE_Params</code> 结构。（创建它的线程）可以根据需要单独调整结构体内的个别参数。</li>\n<li>然后，调用 <code>MODULE_create()</code> 函数来创建对象实例，并初始化其内存。如果该对象在别处被打开，需要给被调用的参数取好名字防止重复。</li>\n<li>接着， 其他线程可以通过 <code>MODULE_open()</code> 函数接入该对象，并返回一个对应的句柄。该对象的创建名称必须与打开名称保持一致。</li>\n<li>最后，调用 <code>MODULE_create()</code> 来创建对象实例的线程就可以调用 <code>MODULE_delete()</code> 来释放被对象占用的内存。</li>\n</ul>\n</blockquote>\n<p><strong>注意：</strong></p>\n<blockquote>\n<p><em>All threads that opened an instance must close that instance before the thread that created it can delete it.</em> <em>Also, a thread that calls <code>MODULE_create()</code> cannot call <code>MODULE_close()</code>.</em> <em>Likewise, a thread that calls <code>MODULE_open()</code> cannot call <code>MODULE_delete()</code>.</em></p>\n<p>在由创建者删除（delete）某IPC对象时，由谁使用（open）就由谁关闭（close）。且决不能由创建者来调用关闭函数，否则创建者无法删除该对象。（顺序如下图所示）</p>\n</blockquote>\n<pre class=\"mermaid\">stateDiagram-v2\n    [*] --> Core0\n    [*] --> Core1\n    Core0 --> IPC_Start()\n    IPC_Start() --> Module_Create()\n    IPC_Start() --> Core1 : Wait for Sychronization\n    Core1 --> UsersProgram()\n    UsersProgram() --> Module_Open()\n    Module_Open() --> Module_Close()\n    Module_Create() --> Module_Delete()\n    Module_Close() --> Module_Delete() : Closed by who opens</pre>\n<h3 id=\"代码示例\">代码示例</h3>\n<h4 id=\"ipc_start-使用示例\">Ipc_Start() 使用示例</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ti/ipc/Ipc.h&gt;</span></span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"function\">Int <span class=\"title\">main</span><span class=\"params\">(Int argc, Char* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">     Int status;</span><br><span class=\"line\">     <span class=\"comment\">/* Call Ipc_start() */</span></span><br><span class=\"line\">     status = Ipc_start();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (status &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">         System_abort(<span class=\"string\">&quot;Ipc_start failed\\n&quot;</span>);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     BIOS_start();</span><br><span class=\"line\">     <span class=\"keyword\">return</span> (<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"messageq_create-使用示例\">MessageQ_Create() 使用示例</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">messageQ = MessageQ_create(DSP_MESSAGEQNAME, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (messageQ == <span class=\"literal\">NULL</span>) &#123;   <span class=\"comment\">//an error occurred when creating the object</span></span><br><span class=\"line\">\tSystem_abort(<span class=\"string\">&quot;MessageQ_create failed\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"error-handling-in-ipc\">Error Handling in IPC</h2>\n<p>Success codes always have values greater or equal to zero. The Failure codes are always negative.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">MessageQ_Msg msg; </span><br><span class=\"line\">MessageQ_Handle messageQ;</span><br><span class=\"line\">Int status;</span><br><span class=\"line\">...</span><br><span class=\"line\">status = MessageQ_get(messageQ, &amp;msg, MessageQ_FOREVER);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (status &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\tSystem_abort(<span class=\"string\">&quot;Should not happen\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ipc-module-configuration\">IPC Module Configuration</h2>\n<p>Configure how the IPC module synchronizes processors by configuring the <code>Ipc.procSync</code> property. For example:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* CONFIGURATION ABOUT INTER-PROCESS COMMUNICATION */</span></span><br><span class=\"line\">var Ipc = xdc.useModule(&#x27;ti.sdo.ipc.Ipc&#x27;);</span><br><span class=\"line\">Ipc.procSync = Ipc.ProcSync_ALL;</span><br></pre></td></tr></table></figure>\n<p>Here are three options: <code>Ipc.ProcSync_ALL</code> | <code>Ipc.ProcSync_PAIR</code> | <code>Ipc.ProcSync_NONE</code></p>\n<table>\n<colgroup>\n<col style=\"width: 24%\" />\n<col style=\"width: 37%\" />\n<col style=\"width: 37%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Options</th>\n<th>Conditions</th>\n<th>Specialties</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong>Ipc.ProcSync_ALL</strong></td>\n<td>- IPC processors on a device start up at the same time<br/>- Connections should be established between every possible pair of processors</td>\n<td>- <code>Ipc_start() API</code> automatically attaches to and synchronizes all remote processors. <br/>- Application <strong><em>should never call</em></strong> <code>Ipc_attach()</code>.</td>\n</tr>\n<tr class=\"even\">\n<td><strong>Ipc.ProcSync_PAIR</strong> <em>(Default Mode)</em></td>\n<td><em>One of the following is true:</em><br>- You need to control when synchronization with each remote processor occurs.<br/>- Useful work can be done while trying to synchronize with a remote processor by yielding a thread after each attempt to Ipc_attach() to the processor. <br/> - Connections to some remote processors are unnecessary and should be made selectively to save memory.</td>\n<td>- Must explicitly call <code>Ipc_attach()</code> to attach to a specific remote processor. <br/>- <code>Ipc_start()</code> performs system-wide IPC initialization, but does not <strong>make connections to remote processors</strong>.</td>\n</tr>\n<tr class=\"odd\">\n<td><strong>Ipc.ProcSync_NONE</strong></td>\n<td><em>Use this option with caution.</em> <br/>It is intended for use in cases where the application performs its own synchronization and you want to avoid a potential deadlock situation with the IPC synchronization.</td>\n<td><code>Ipc_start()</code> doesn’t synchronize any processors before setting up the objects needed by other modules.</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"attach-and-detach-依附与分离\">Attach and Detach （依附与分离）</h4>\n<p>In addition to the default actions performed when attaching to or detaching from a remote processor, You can configure a function to perform custom actions.</p>\n<p>Attach and Detach are provided for the processor synchronization:</p>\n<ul>\n<li><p><code>Ipc_attach()</code> Creates a connection to the specified remote processor.</p></li>\n<li><p><code>Ipc_detach()</code> Deletes the connection to the specified remote processor.</p></li>\n</ul>\n<p>在 <code>.cfg</code> 文件中以下为两个互相依赖和两个互相分离的函数配置，每一组函数都会传递一个不同的参数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">var Ipc = xdc.useModule(&#x27;ti.sdo.ipc.Ipc&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">var fxn = <span class=\"keyword\">new</span> Ipc.UserFxn;</span><br><span class=\"line\">fxn.attach = &#x27;&amp;userAttachFxn1&#x27;;</span><br><span class=\"line\">fxn.detach = &#x27;&amp;userDetachFxn1&#x27;;</span><br><span class=\"line\">Ipc.addUserFxn(fxn, <span class=\"number\">0x1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">fxn.attach = &#x27;&amp;userAttachFxn2&#x27;;</span><br><span class=\"line\">fxn.detach = &#x27;&amp;userDetachFxn2&#x27;;</span><br><span class=\"line\">Ipc.addUserFxn(fxn, <span class=\"number\">0x2</span>);</span><br></pre></td></tr></table></figure>\n<p><strong><em>These functions run near the end of <code>Ipc_attach()</code> and near the beginning of <code>Ipc_detach()</code> , respectively.</em></strong></p>\n<p><strong><em>Such functions must be non-blocking and must run to completion. 这些被定义的函数必须为非阻塞且（一旦开始就）运行到底。</em></strong></p>\n<p><strong>注意：</strong> Call <code>Ipc_attach()</code> to the processor that owns shared memory region 0 (usually the processor with id = 0) before making a connection to any other remote processor. For example, if there are three processors configured with <strong><em>MultiProc</em></strong>, #1 should attach to #0 before it can attach to #2.</p>\n<h1 id=\"多核任务分配\">3. 多核任务分配</h1>\n<blockquote>\n<p>如果多个核共享一个工程及相同的bios 配置文件，是不能指定某一个任务到特定的core上，如果某个任务只有某个core才会运行，可以在任务中区分core运行。如果多个core分别有不同的工程，则没有“多核任务分配”的问题，每个工程可以根据各自core的应用创建各自的任务，不需要软件区分core。</p>\n</blockquote>\n<blockquote>\n<p>单核可以是一个out生成最终的bin文件烧写在flash，多核如果存在多个out文件，可以把out文件合并成一个bin烧写，或者多个bin分开烧写均可。bin文件中都有程序的地址及长度信息，在多个bin时，也是一样可以由core0负责对flash的程序文件解析，将程序搬移到相应的地址上，最后core0再向其他core magic address写入入口地址，并发送ipc触发即可。</p>\n</blockquote>\n<blockquote>\n<p>这个并非由SYS/BIOS分配，需要开发者指定。</p>\n<p>可以根据core number来做判断，然后确认该任务是否运行在该核上。</p>\n</blockquote>\n<h1 id=\"chip-support-library\">4. Chip Support Library</h1>\n<p>CSL，即芯片支持库( Chip Support Library)。在程序设计过程中利用CSL库函数可以方便地访问 <strong>DSP的寄存器和硬件资源</strong>，提高DSP软件的开发效率和速度。</p>\n<p>CSL库包含了对INTC、Boot Configuration、BWMNGMT、CACHE、CHIP、CPINTC、EDMA3、EMAC、EMIF4F、GPIO、IDMA、IPC、MDIO、MEMPROT、MPU、MSMC、PLLC、PSC、Semaphore、SGMII、SRIO、TIMER、TSC、VCP2、XMC、CGEM、CPPI、QMSS、CPPI_LLD_SYMBOL 及 CPPI_LLD_ENUM共30种模块的支持。</p>\n<h2 id=\"cache-module\">Cache Module</h2>\n<p>位于 <code>ti\\pdk_C6657_1_1_2_6\\packages\\ti\\csl\\</code> 下的头文件 <code>&lt;csl_cacheAux.h&gt;</code> 提供了缓存（Cache）配置相关的CSL功能层API。</p>\n<blockquote>\n<p>This is the CACHE Auxilary Header File which exposes the <strong><em>various CSL Functional Layer API</em></strong>'s to <strong><em>configure the CACHE Module</em></strong>.</p>\n</blockquote>\n<blockquote>\n<p>Cache API包含了对L1D（L1 Data Cache）、L1P 及 L2的各种操作。关于L1D、L1P及L2 的详细文件参考《SPRS814D》第193页。</p>\n</blockquote>\n<p>该头文件中对三种缓存的可操作方式如下示：</p>\n<table>\n<colgroup>\n<col style=\"width: 83%\" />\n<col style=\"width: 5%\" />\n<col style=\"width: 5%\" />\n<col style=\"width: 5%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>OPERATION</th>\n<th>L1D</th>\n<th>L1P</th>\n<th>L2</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>setSize</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"even\">\n<td>getSize</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"odd\">\n<td>freeze</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"even\">\n<td>unfreeze</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"odd\">\n<td>getPrevMode<br/><em>-- get the previous operating state</em></td>\n<td>√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>invAllWait<br/><em>-- wait for the cache global invalidate operation to complete</em></td>\n<td>√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>invAll<br/><em>-- globally invalidate cache</em></td>\n<td>√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>wbAllWait<br/><em>-- wait for the cache writeback operation to complete</em></td>\n<td>√</td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>wbAll<br/><em>-- writeback the dirty lines of the cache</em></td>\n<td>√</td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>wbInvAllWait<br/><em>-- wait for the cache writeback invalidate operation to complete</em></td>\n<td>√</td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>wbInvAll<br/><em>-- invalidate and writeback the dirty lines of the cache</em></td>\n<td>√</td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>invWait<br/><em>-- wait for the cache invalidate block operation to complete</em></td>\n<td>√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>inv<br/><em>-- to invalidate a block in cache</em></td>\n<td>√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>wbWait<br/><em>-- wait for the cache writeback block operation to complete</em></td>\n<td>√</td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>wb<br/><em>-- writeback the dirty lines of the block address</em></td>\n<td>√</td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>wbInvWait<br/><em>-- wait for the cache invalidate/writeback block operation to complete</em></td>\n<td>√</td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>wbInv<br/><em>-- invalidate and writeback the dirty lines of the block address</em></td>\n<td>√</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"ipc-module\">IPC Module</h2>\n<p>IPC，即进程间通信（Inter-process communication）。</p>\n<p>位于 <code>ti\\pdk_C6657_1_1_2_6\\packages\\ti\\csl\\</code> 下的头文件 <code>&lt;csl_ipcAux.h&gt;</code> 提供了<strong>查询定义</strong> 和 <strong>控制函数</strong>。IPC API包含了对 NMI、GEM、Host的各种操作。其中 <strong>GEM</strong> 对 IPCGRx 及 IPCARx 进行操作；而 <strong>Host</strong> 对 IPCGRH 及 IPCARH 进行操作。</p>\n<p><strong>注意：</strong> 下文中， <code>index</code> 和 <code>srcId</code> 均是函数形参，如在<code>CSL_IPC_isGEMInterruptAckSet（uint32 index, uint32 srcId)</code>中：<code>index</code> 指需要检查IPCARx寄存器的GEM编号。<code>srcId</code> 指示在指定的索引对应的IPCARx寄存器中需要读取0-27 SRCCx位中的哪一个。</p>\n<blockquote>\n<p><strong>NMI</strong>，即 <strong>不可屏蔽中断</strong>（Non Maskable Interrupt）。<strong>NMIG</strong>，即 <strong>不可屏蔽中断产生寄存器</strong>（NMI Generation Register <em>(NMIGRx)</em>）。NMIGRx registers are used for generating NMI events to the corresponding CorePac. The C6657 has two NMIGRx registers (NMIGR0 and NMIGR1). The NMIGR0 register generates an NMI event to CorePac0, and the NMIGR1 register generates an NMI event to CorePac1.Writing 1 to the NMIG field generates an NMI pulse. Writing 0 has no effect and reads return 0 and have no other effect.</p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_09-00-03.png\" style=\"zoom:50%;\" /></p>\n<p><strong>IPCGRx</strong>，即 <strong>进程间通信产生寄存器</strong>（IPC interrupt generation register）。IPCGRx are to facilitate inter CorePac interrupts. The C6657 has two IPCGRx registers (IPCGR0 and IPCGR1). These registers can be used by external hosts or CorePacs to generate interrupts to other CorePacs. A write of 1to the IPCG field of the IPCGRx register will generate an interrupt pulse to CorePacx (0 &lt;= x &lt;= 1).</p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_08-54-09.png\" style=\"zoom:50%;\" /></p>\n<p><strong>IPCARx</strong>，即 <strong>IPC中断确认寄存器</strong>（IPC interrupt-acknowledgement registers）。IPCARx are to facilitate inter-CorePac core interrupts. The C6657 has two IPCARx registers (IPCAR0 and IPCAR1). These registers also provide a <em>Source ID facility</em> by which up to 28 different sources of interrupts can be identified. Allocation of source bits to source processor and meaning is entirely based on software convention. The register field descriptions are shown in the following tables. Virtually anything can be a source for these registers as this is completely controlled by software. Any master that has access to BOOTCFG module space can write to these registers.</p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_08-57-22.png\" style=\"zoom:50%;\" /></p>\n<p><strong>IPCGRH</strong>，即 <strong>主机IPC产生寄存器</strong>（IPC Generation Host）。The IPCGRH register facilitates interrupts to external hosts. Operation and use of the IPCGRH register is the same as for other IPCGR registers. The interrupt output pulse created by the IPCGRH register appears on device pin HOUT. <mark><i>The host interrupt output pulse should be stretched. It should be asserted for 4 bootcfg clock cycles (CPU/6) followed by a deassertion of 4 bootcfg clock cycles. Generating the pulse will result in 8 CPU/6 cycle pulse blocking window. </i></mark>Write to IPCGRH with IPCG bit (bit 0) set will only generate a pulse if they are beyond 8 CPU/6 cycle period.</p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_09-33-14.png\" style=\"zoom:50%;\" /></p>\n<p><strong>IPCARH</strong>，即 <strong>主机IPC确认寄存器</strong>（Host IPC Acknowledgment Register）。</p>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_14-57-07.png\" style=\"zoom: 67%;\" /></p>\n</blockquote>\n<p>该头文件中的可操作方式如下示：</p>\n<table>\n<colgroup>\n<col style=\"width: 27%\" />\n<col style=\"width: 2%\" />\n<col style=\"width: 34%\" />\n<col style=\"width: 34%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>NMI</th>\n<th>GEM</th>\n<th>Host</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>genEvent</td>\n<td>√</td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>genInterrupt<br><em>-- generate an interrupt pulse</em></td>\n<td></td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"odd\">\n<td>isInterruptSourceSet</td>\n<td></td>\n<td>√<br><em>-- checks if the SRCSx bit of the <strong>IPCGRx</strong> register is set</em></td>\n<td>√<br><em>-- checks if the SRCSx bit of the <strong>IPCGRH</strong> register is set</em></td>\n</tr>\n<tr class=\"even\">\n<td>isInterruptAckSet</td>\n<td></td>\n<td>√<br><em>-- checks if the SRCCx bit of the <strong>IPCARx</strong> register is set.</em></td>\n<td>√<br><em>-- checks if the SRCCx bit of the <strong>IPCARH</strong> register is set.</em></td>\n</tr>\n<tr class=\"odd\">\n<td>clearInterruptSource</td>\n<td></td>\n<td>√</td>\n<td>√</td>\n</tr>\n</tbody>\n</table>\n<p><code>isGEMInterruptSourceSet()</code> returns 1 if the <u>SRCCx bit corresponding to the <strong>srcId</strong> is set</u> in the IPCARx register corresponding to the index specified. 如果与srcId对应的SRCCx位在与指定索引对应的IPCARx寄存器中被设置，则返回1。</p>\n<blockquote>\n<p><code>CSL_IPC_clearGEMInterruptSource()</code> clears the interrupt source IDs by setting the <strong>SRCCx bit of IPCARx</strong> and <strong>SRCSx bit of IPCGRx</strong> corresponding to the GEM index and Source ID specified.</p>\n<p><code>CSL_IPC_clearGEMInterruptSource()</code> 通过设置 <strong><em>GEM 索引</em></strong> 和 <strong><em>指定源 ID</em></strong> 对应的 <strong>IPCARx寄存器上的SRCCx位</strong> 和 <strong>IPCGRx寄存器上的SRCSx位</strong> 来清除 中断源ID 。</p>\n</blockquote>\n<blockquote>\n<p><code>CSL_IPC_clearHostInterruptSource()</code> function clears the interrupt source IDs by setting the <strong>SRCCx bit of IPCARH</strong> and <strong>SRCSx bit of IPCGRH</strong> corresponding to the Source ID specified.</p>\n<p><code>CSL_IPC_clearHostInterruptSource()</code> 通过设置 <strong><em>指定源ID</em></strong> 对应的 <strong>IPCARH上的SRCCx位</strong> 和 <strong>IPCGRH上的SRCSx位</strong> 来清楚中断源ID。</p>\n</blockquote>\n<h3 id=\"cache_wbinvl1d\">CACHE_wbInvL1d()</h3>\n<p>This function is used to <mark><strong>invalidate and writeback</strong> the <em>dirty lines</em> of the block address</mark>.</p>\n<p>Although the block size can be specified in the number of bytes, the cache controller operates on whole cache lines.</p>\n<p>To prevent unintended behavior \"blockPtr\" should be aligned on the cache line size and \"byteCnt\" should be a multiple of the cache line size.</p>\n<h3 id=\"cache_invl1d\">CACHE_invL1d ()</h3>\n<p>This function is used to <mark><strong>invalidate</strong> a <em>block</em> in the L1D Cache</mark>.</p>\n<p>Although the block size can be specified in the number of bytes, the cache controller operates on whole cache lines.</p>\n<p>To prevent unintended behavior \"blockPtr\" should be aligned on the cache line size and \"byteCnt\" should be a multiple of the cache line size.</p>\n<h2 id=\"chip-module\">Chip Module</h2>\n<p><code>#include &lt;csl_chipAux.h&gt;</code></p>\n<p>本头文件是以C( <code>extern \"C\"</code> )的方式来书写的，包含芯片读取与写入相关操作的API，名称以 <code>CSL_chipRead</code> 或 <code>CSL_chipWrite</code> 开头，所有函数均以静态内联（static inline，重定义成 <code>CSL_IDEF_INLINE</code> ）32位非负整数（Uint32）的方式定义，如 <code>CSL_IDEF_INLINE Uint32 CSL_chipRead***();</code> 。</p>\n<p><code>&lt;csl_chipAux.h&gt;</code> 提供了26个读取寄存器相关的函数，函数定义均是对寄存器的读取并返回数值，某些读取函数需要注意 <em>前置条件</em>（Pre-condition）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">CSL_chipReadAMR();    <span class=\"comment\">//Addressing Mode control register 寻址模式控制寄存器</span></span><br><span class=\"line\">CSL_chipReadCSR();    <span class=\"comment\">//Control Status register 控制状态寄存器</span></span><br><span class=\"line\">CSL_chipReadIFR();    <span class=\"comment\">//Interrupt Flag register 中断标志寄存器</span></span><br><span class=\"line\">CSL_chipReadIER();    <span class=\"comment\">//Interrupt Enable register 中断使能寄存器</span></span><br><span class=\"line\">CSL_chipReadISTP();    <span class=\"comment\">//Interrupt Service Table Pointer register 中断服务表指针寄存器</span></span><br><span class=\"line\">CSL_chipReadIRP();    <span class=\"comment\">//Interrupt Return Pointer register 中断返回指针寄存器</span></span><br><span class=\"line\">CSL_chipReadNRP();    <span class=\"comment\">//Nonmaskable Interrupt Return Pointer register </span></span><br><span class=\"line\">CSL_chipReadERP();    <span class=\"comment\">//Exception Return Pointer register 异常返回指针寄存器</span></span><br><span class=\"line\">CSL_chipReadTSCL();    <span class=\"comment\">//Time Stamp Counter Lower Order 32-bits register 时间戳计数器低32位</span></span><br><span class=\"line\">CSL_chipReadTSCH();    <span class=\"comment\">//Time Stamp Counter Higer Order 32-bits register 时间戳计数器高32位</span></span><br><span class=\"line\">CSL_chipReadARP();    <span class=\"comment\">//Analysis Return Pointer register </span></span><br><span class=\"line\">CSL_chipReadILC();    <span class=\"comment\">//Inner Loop SPL buffer Counter(ILC) register</span></span><br><span class=\"line\">CSL_chipReadRILC();    <span class=\"comment\">//Reload Inner Loop SPL buffer Counter(RILC) register</span></span><br><span class=\"line\">CSL_chipReadREP();    <span class=\"comment\">//Restricted Entry Point Address register</span></span><br><span class=\"line\">CSL_chipReadPCE1();    <span class=\"comment\">//Program Counter, E1 Phase register E1字段程序计数器</span></span><br><span class=\"line\">CSL_chipReadDNUM();    <span class=\"comment\">//DSP Core Number register 核心数寄存器</span></span><br><span class=\"line\">CSL_chipReadSSR();    <span class=\"comment\">//Saturation Status Register 饱和状态寄存器</span></span><br><span class=\"line\">CSL_chipReadGPLYA();    <span class=\"comment\">//GMPY A-side polynomial register </span></span><br><span class=\"line\">CSL_chipReadGPLYB();    <span class=\"comment\">//GMPY B-side polynomial register</span></span><br><span class=\"line\">CSL_chipReadGFPGFR();    <span class=\"comment\">//Golios Field Multiply Control Register</span></span><br><span class=\"line\">CSL_chipReadDIER();    <span class=\"comment\">//Debug Interrupt Enable Register 调试中断使能寄存器</span></span><br><span class=\"line\">CSL_chipReadTSR();    <span class=\"comment\">//Task State Register 任务状态寄存器</span></span><br><span class=\"line\">CSL_chipReadITSR();    <span class=\"comment\">//Interrupt Task State Register 中断任务状态寄存器</span></span><br><span class=\"line\">CSL_chipReadNTSR();    <span class=\"comment\">//NMI/Exception Task State Register 异常任务状态寄存器</span></span><br><span class=\"line\">CSL_chipReadEFR();    <span class=\"comment\">//Exception Flag Register 异常标志寄存器</span></span><br><span class=\"line\">CSL_chipReadIERR();    <span class=\"comment\">//Internal Exception Report Register 内部异常报告寄存器</span></span><br></pre></td></tr></table></figure>\n<p><code>&lt;csl_chipAux.h&gt;</code> 提供了24个写入寄存器相关的函数，且与读取寄存器相关函数并不呈现一一对应关系。函数定义均是将一个Uint32类型（重定义为 <code>CSL_Reg32</code> ）的新值赋值给寄存器，并将旧值返回，写入寄存器均不需要注意 前置条件，部分需要注意后置条件（Post-condition）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">CSL_chipWriteAMR(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteCSR(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteISR(CSL_Reg32  val);    <span class=\"comment\">//Interrupt Set Register 中断设置寄存器</span></span><br><span class=\"line\">CSL_chipWriteICR(CSL_Reg32  val);    <span class=\"comment\">//Interrupt Clear Register 中断清除寄存器</span></span><br><span class=\"line\">CSL_chipWriteIER(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteISTP(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteIRP(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteNRP(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteERP(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteTSCL(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteARP(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteILC(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteRILC(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteREP(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteSSR(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteGPLYA(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteGPLYB(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteGFPGFR(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteDIER(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteTSR(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteITSR(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteNTSR(CSL_Reg32  val);</span><br><span class=\"line\">CSL_chipWriteECR(CSL_Reg32  val);    <span class=\"comment\">//Exception Clear Register 异常清除寄存器</span></span><br><span class=\"line\">CSL_chipWriteIERR(CSL_Reg32  val);</span><br></pre></td></tr></table></figure>\n<p>共30个寄存器涉及是否可读写：</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>Register</th>\n<th>Read</th>\n<th>Write</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>AMR</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"even\">\n<td>CSR</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"odd\">\n<td>IFR</td>\n<td>√</td>\n<td>×</td>\n</tr>\n<tr class=\"even\">\n<td>ISR</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr class=\"odd\">\n<td>ICR</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr class=\"even\">\n<td>IER</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"odd\">\n<td>ISTP</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"even\">\n<td>IRP</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"odd\">\n<td>NRP</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"even\">\n<td>ERP</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"odd\">\n<td>TSCL</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"even\">\n<td>TSCH</td>\n<td>√</td>\n<td>×</td>\n</tr>\n<tr class=\"odd\">\n<td>ARP</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"even\">\n<td>ILC</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"odd\">\n<td>RILC</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"even\">\n<td>REP</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"odd\">\n<td>PCE1</td>\n<td>√</td>\n<td>×</td>\n</tr>\n<tr class=\"even\">\n<td>DNUM</td>\n<td>√</td>\n<td>×</td>\n</tr>\n<tr class=\"odd\">\n<td>SSR</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"even\">\n<td>GPLYA</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"odd\">\n<td>GPLYB</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"even\">\n<td>GFPGFR</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"odd\">\n<td>DIER</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"even\">\n<td>TSR</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"odd\">\n<td>ITSR</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"even\">\n<td>NTSR</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"odd\">\n<td>ECR</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr class=\"even\">\n<td>EFR</td>\n<td>√</td>\n<td>×</td>\n</tr>\n<tr class=\"odd\">\n<td>IERR</td>\n<td>√</td>\n<td>√</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"ipc_hw-example-in-anc\">IPC_HW Example in ANC</h2>\n<p><strong>硬件（中断）层核间通信</strong>（不需要修改）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Ipc_Init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tHwi_Params params;    <span class=\"comment\">//创建HWI对象</span></span><br><span class=\"line\">\tError_Block eb;    <span class=\"comment\">//创建错误块处理对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tError_init(&amp;eb);    <span class=\"comment\">//初始化错误块</span></span><br><span class=\"line\">\tHwi_Params_init(&amp;params);    <span class=\"comment\">//初始化HWI对象</span></span><br><span class=\"line\">\tparams.eventId = <span class=\"number\">90</span>;    <span class=\"comment\">//IPC INT\t/* Set the event ID of the associated host interrupt */</span></span><br><span class=\"line\">\tparams.enableInt = TRUE;    <span class=\"comment\">//打开中断</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tHwi_create(<span class=\"number\">5</span>, &amp;IpcIsr, &amp;params, &amp;eb);    <span class=\"comment\">//INT5\t/* Create Hwi thread Hwi function is CpIntc_dispatch */</span></span><br><span class=\"line\">\tHwi_enable();    <span class=\"comment\">//打开中断</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(CSL_chipReadDNUM() == <span class=\"number\">0</span>)&#123;     <span class=\"comment\">//core0\t//检测运行前触发的ipc，因为运行前写入的ipc无法触发中断</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(CSL_IPC_isGEMInterruptAckSet(<span class=\"number\">0</span>,<span class=\"number\">2</span>))&#123;    <span class=\"comment\">//判断索引为0对应的IPCARx中的第2位是否为中断确认位</span></span><br><span class=\"line\">\t\t\tCSL_IPC_clearGEMInterruptSource(<span class=\"number\">0</span>,<span class=\"number\">2</span>);    <span class=\"comment\">//是则清除</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;    <span class=\"comment\">//core1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(CSL_IPC_isGEMInterruptAckSet(<span class=\"number\">1</span>,<span class=\"number\">2</span>))&#123;    <span class=\"comment\">//判断索引为1对应的IPCARx中的第2位是否为中断确认位</span></span><br><span class=\"line\">\t\t\tCSL_IPC_clearGEMInterruptSource(<span class=\"number\">1</span>,<span class=\"number\">2</span>);   <span class=\"comment\">//是则清除</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>核心同步</strong>（不需要修改）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Ipc_CoreSync</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(CSL_chipReadDNUM() == <span class=\"number\">0</span>)&#123;    <span class=\"comment\">//core0</span></span><br><span class=\"line\">                CSL_IPC_genGEMInterrupt(<span class=\"number\">1</span>,<span class=\"number\">1</span>);    <span class=\"comment\">//IPC_IPCGR_SRCS1 = 1;</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span>(!CSL_IPC_isGEMInterruptAckSet(<span class=\"number\">0</span>,<span class=\"number\">1</span>));    <span class=\"comment\">//等待core1启动</span></span><br><span class=\"line\">                CSL_IPC_clearGEMInterruptSource(<span class=\"number\">0</span>,<span class=\"number\">1</span>);    <span class=\"comment\">//core1启动成功，清除标志</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;    <span class=\"comment\">//core1</span></span><br><span class=\"line\">\t\tCSL_IPC_genGEMInterrupt(<span class=\"number\">0</span>,<span class=\"number\">1</span>);    <span class=\"comment\">//IPC_IPCGR_SRCS1 = 1;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(!CSL_IPC_isGEMInterruptAckSet(<span class=\"number\">1</span>,<span class=\"number\">1</span>));    <span class=\"comment\">//等待core0启动</span></span><br><span class=\"line\">\t\tCSL_IPC_clearGEMInterruptSource(<span class=\"number\">1</span>,<span class=\"number\">1</span>);    <span class=\"comment\">//core0启动成功，清除标志</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>核间IPC信号发送</strong>（可根据需要进行修改）</p>\n<p>可定义多个IPC核间通信函数，但是要区分得清各函数在何时何处被调用到，否则将会引起混乱。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Ipc_Core0ToCore1</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">/* 可自定义区域 */</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">16</span>;i++)&#123;</span><br><span class=\"line\">\t\tptr0[i] = adData[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 可自定义区域 */</span></span><br><span class=\"line\">\tCACHE_wbInvL1d(ptr0,<span class=\"number\">64</span>,CACHE_WAIT);<span class=\"comment\">//L1D line size 64bytes</span></span><br><span class=\"line\">\tCSL_IPC_genGEMInterrupt(<span class=\"number\">1</span>,<span class=\"number\">2</span>);<span class=\"comment\">////ipcgr1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Ipc_Core1ToCore0</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">/* 可自定义区域 */</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)&#123;</span><br><span class=\"line\">\t\tptr1[i] = daData[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 可自定义区域 */</span></span><br><span class=\"line\">\tCACHE_wbInvL1d(ptr1,<span class=\"number\">64</span>,CACHE_WAIT);                 <span class=\"comment\">//L1D line size 64bytes</span></span><br><span class=\"line\">\tCSL_IPC_genGEMInterrupt(<span class=\"number\">0</span>,<span class=\"number\">2</span>);                               <span class=\"comment\">//ipcgr0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>核间通信中断函数</strong>（可根据需要进行修改）</p>\n<p><strong>注意：</strong>实际使用时，并不需要在某处调用 <code>IpcIsr()</code> 函数，即实际上是被硬件中断进行控制的，在 <code>HWI_Create()</code> 函数中被使用到。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">IpcIsr</span><span class=\"params\">(UArg arg)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(CSL_chipReadDNUM() == <span class=\"number\">0</span>) &#123;                      <span class=\"comment\">// core0</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(CSL_IPC_isGEMInterruptAckSet(<span class=\"number\">0</span>,<span class=\"number\">2</span>))&#123;                      <span class=\"comment\">//ipcgr0</span></span><br><span class=\"line\">\t\t\tCSL_IPC_clearGEMInterruptSource(<span class=\"number\">0</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\tCACHE_invL1d(ptr1,<span class=\"number\">64</span>,CACHE_WAIT);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t\tdaData[i] = ptr1[i];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tSemaphore_post(sem0_da);    <span class=\"comment\">//执行发送程序，将数据通过SPI发送到DA：通过semaphore切换task</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;\t<span class=\"comment\">// core1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(CSL_IPC_isGEMInterruptAckSet(<span class=\"number\">1</span>,<span class=\"number\">2</span>))&#123;                          <span class=\"comment\">//ipcgr1</span></span><br><span class=\"line\">\t\t\tCSL_IPC_clearGEMInterruptSource(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\tCACHE_invL1d(ptr0,<span class=\"number\">64</span>,CACHE_WAIT);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">16</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t\tadData[i] = ptr0[i];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tSemaphore_post(sem1_anc);    <span class=\"comment\">//执行core1的计算步骤，计算完后应该通知core0的ipc启动结果发送程序：通过semaphore切换task</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"c6657特性\">5. C6657特性</h1>\n<h2 id=\"l2缓存\">L2缓存</h2>\n<p>Debug模式下，程序文件都写在L2缓存中。而C6657总共有 <code>2048KB</code> 大小的L2 缓存，其中每个核心分配到 <code>1024KB</code> ，缓存起始地址为 <code>0x00800000</code> 。</p>\n<p>在仿真器中分配内存大小一致，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">MEMORY</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    L2SRAM (RWX) : org = <span class=\"number\">0x800000</span>, len = <span class=\"number\">0x100000</span></span><br><span class=\"line\">    MSMCSRAM (RWX) : org = <span class=\"number\">0xc000000</span>, len = <span class=\"number\">0x100000</span></span><br><span class=\"line\">    DDR3 (RWX) : org = <span class=\"number\">0x80000000</span>, len = <span class=\"number\">0x20000000</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Written in &lt;<em>TMS320C6655/57 DataManual</em>&gt;:</p>\n","categories":["Communication"],"tags":["TI","multicore"]},{"title":"ADI开发笔记","url":"/2021/04/23/Hardware/DSP/2021-04-23-ADI%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","content":"<p>[TOC]</p>\n<h1 id=\"terminology\">TERMINOLOGY</h1>\n<h2 id=\"processors-microcontrollers-dsp\">Processors / Microcontrollers / DSP</h2>\n<p>以下是ADI官方对Processors、Microcontrollers、DSP 等词的解释：</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210501094933998.png\" alt=\"image-20210501094933998\" style=\"zoom: 80%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210501094947031.png\" alt=\"image-20210501094947031\" style=\"zoom: 80%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210501094923111.png\" alt=\"image-20210501094923111\" style=\"zoom: 80%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210501095225573.png\" alt=\"image-20210501095225573\" style=\"zoom: 80%;\" /></p>\n<p><strong>Harvard Architecture</strong>，即哈佛结构，是一种将程序指令存储和数据存储分开的存储器结构。哈佛结构是一种并行体系结构，它的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问。</p>\n<p><strong>Super Harvard Architecture</strong>（超级哈佛架构，SHARC），由ADI开发，具体解释见下方 BLACKFIN / SHARC。</p>\n<h3 id=\"why-floating-point-dsp\">Why Floating-Point DSP?</h3>\n<blockquote>\n<p>A digital signal processor’s data format determines its ability to handle signals of <em>differing precision</em>, <em>dynamic range</em>, and <em>signal-to-noise ratios</em>. Because floating-point DSP math reduces the need for scaling and probability of overflow, <mark>using a floating-point DSP can ease algorithm and software development</mark>. The extent to which this is true depends on the floating-point processor’s architecture.</p>\n<p><u>Consistency with IEEE workstation simulations and the elimination of scaling are two clear ease-of-use advantages.</u> High-level language programmability, large address spaces, and wide dynamic range allow system development time to be spent on algorithms and signal processing concerns, rather than assembly language coding, code paging, and error handling.</p>\n<p><em>--&lt;ADSP-21160 SHARC® DSP Hardware Reference&gt;</em></p>\n</blockquote>\n<p>总结一下就是：</p>\n<ul>\n<li>(The data format is) <strong>Suitable to handle various kind of task</strong> (like <em>differing precision</em>, <em>dynamic range</em>, and <em>signal-to-noise ratios</em>).</li>\n<li>(F-P DSP math) <strong>Reduces the need of scaling and probability of overflow.</strong></li>\n<li><strong>High-level language programmability, large address spaces, wide dynamic range</strong>.</li>\n</ul>\n<h2 id=\"blackfin-sharc\">BLACKFIN / SHARC</h2>\n<p>以下是ADI官网对BLACKFIN 和 SHARC的描述</p>\n<p><strong>BLACKFIN</strong></p>\n<blockquote>\n<p>Blackfin® 16/32位嵌入式处理器提供软件灵活性和扩展能力，适合融合应用：多格式音频、视频、语音和图像处理、多模式基带和分组处理、控制处理以及实时安全。</p>\n</blockquote>\n<p><strong>SHARC</strong></p>\n<blockquote>\n<p>SHARC音频处理器产品系列采用ADI公司的SHARC®和SHARC+®数字信号处理(DSP)内核技术，提供确定性和极低处理延迟以及出色的MIPS/mW性能。SHARC处理器系列在浮点DSP市场占据主导地位，拥有出色的内核和存储器性能以及优异的I/O吞吐能力。SHARC具有多个产品版本和价位，能够为动态范围至关重要的许多应用提供实时浮点处理性能。</p>\n<p>许多处理器集成了FIR/IIR硬件加速器，可分流内核的通用数字信号处理算法任务，从而使内核能够并行执行后处理算法，因而非常适合实时音频应用。广泛的SHARC+ SoC产品组合提供高达1GHz的性能可扩展性以及各种片内存储器配置和混合外设。对于以太网和USB等复杂的外设，一些SoC集成了ARM内核以便处理运行堆栈软件和其他微控制器任务。</p>\n</blockquote>\n<p>以下文字是《ADSP-21479 EZ-Board Evaluation System Manual》全篇唯一出现blackfin关键字（Page28）的地方，但是21479不属于Blackfin系列，应该是错误来的。</p>\n<p><img src=\"https://pic.islet.space/2021/05/20210520135658.png\" alt=\"image-20210520135616863\" style=\"zoom:50%;\" /></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210520135659.png\" alt=\"image-20210520135407091\" /><figcaption aria-hidden=\"true\">image-20210520135407091</figcaption>\n</figure>\n<h1 id=\"basic-knowledge\">BASIC KNOWLEDGE</h1>\n<p>原理图模块 是指用于构建SigmaStudio设计的模块。每个处理器可用的块显示在“工具箱”和“树形工具箱”窗口中，可以将其拖放到原理图中。</p>\n<h2 id=\"usbi\">USBi</h2>\n<ul>\n<li><p>USBi features a standard Aardvark-compatible programming header.</p></li>\n<li><p>USBi can be used for real-time tuning of Sigma-DSP with SigmaStudio</p></li>\n</ul>\n<p>下图为USBi的功能框架：</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210518114358905.png\" alt=\"image-20210518114358905\" style=\"zoom:80%;\" /></p>\n<blockquote>\n<p>USBi在I2C总线上有一个EEPROM，地址为0x50。它用来向PC显示其供应商ID和产品ID，以及启动其内部程序。应该避免在你的系统设计中在这个地址上有任何其他的EEPROMs。</p>\n<p>这个EEPROM没有写保护；因此，如果你试图写到地址0x50，你将覆盖USBi的板载EEPROM，USBi将停止工作。如果不把板子还给Analog Devices，就不能对USBi进行重新编程。大多数EEPROM被设置为地址0x50的方法是将其引脚A0 = 1 和A1 = A2 = 0。</p>\n</blockquote>\n<h2 id=\"algorithms-addremove-growreduce\">Algorithms: Add/Remove, Grow/Reduce</h2>\n<p>每个原理图块代表一种或多种信号处理算法。算法的范围从非常简单的<a href=\"https://wiki.analog.com/resources/tools-software/sigmastudio/toolbox/basicdsp/signaladd\">信号添加</a>（如<a href=\"https://wiki.analog.com/resources/tools-software/sigmastudio/toolbox/basicdsp/signaladd\">Signal Add</a>）到高级系统组件（如<a href=\"https://wiki.analog.com/resources/tools-software/sigmastudio/toolbox/adialgorithms/dynamicbassboost\">Dynamic Bass Boost）</a>。您可以从块中添加或删除算法以满足您的特定要求。如下所述，算法也可以增长。</p>\n<hr />\n<p><strong>添加算法：</strong></p>\n<p>您必须添加一种算法-通常与一组I / O引脚关联-才能使块起作用。要将算法添加到块，请<strong>右键单击</strong>该块，然后选择<strong>添加算法&gt; IC＃</strong>，然后选择<strong>算法</strong>的DSP IC。请注意，如果您的项目中有多个处理器（IC / DSP），则可以选择哪个DSP将运行算法，有关更多信息，请参见下文。</p>\n<p><a href=\"https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic1.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Aalgorithms\"><img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic1.png\" alt=\"img\" /></a></p>\n<p>此时，如果需要，右键单击块的边界或标签以添加其他算法。（重要的是右键单击边框或标签；如果右键单击中心，则可能会显示用于输入参数值的弹出窗口。）</p>\n<p><a href=\"https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic2.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Aalgorithms\"><img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic2.png\" alt=\"img\" /></a></p>\n<p>不包含算法的块将没有控件或引脚，并且您只会看到该块的名称（如下图所示）。必须在空块中添加算法，然后才能在原理图设计中使用它们。</p>\n<p><a href=\"https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic3.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Aalgorithms\"><img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic3.png\" alt=\"img\" /></a></p>\n<p><strong>注意</strong>：使用“<a href=\"https://wiki.analog.com/resources/tools-software/sigmastudio/developmentenvironment/toolbox\">树形工具箱”窗口时</a>，总是为每个插入的块创建一个算法。但是，如果使用传统的“<a href=\"https://wiki.analog.com/resources/tools-software/sigmastudio/developmentenvironment/toolbox\">工具箱”</a>窗口插入块，则可能还必须添加算法。</p>\n<p>添加算法时，不仅要为模块选择计算方法，还要为算法选择特定的DSP关联。如果要连接多个DSP处理器，这一点很重要：通过将算法添加到模块中，可以共享模块和控件，并同时与多个DSP进行通信。</p>\n<p><strong>例如</strong>：<a href=\"https://wiki.analog.com/resources/tools-software/sigmastudio/volumecontrols/singlevolumecontrol\">单个音量控制</a>块具有用于所有算法的单个滑块控件。如果使用2个DSP处理器（IC 1（AD1940）和IC 2（ADAU1701））创建一个项目，然后选择“添加算法”，则系统将提示您要将该算法添加到哪个芯片。</p>\n<p><a href=\"https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic4.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Aalgorithms\"><img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic4.png\" alt=\"img\" /></a></p>\n<p>可以将第一种算法分配给IC 1，将第二种算法分配给IC 2，但是它们共享音量块和单个滑块控件。请注意，您不能在不同的处理器之间建立连线，有关更多信息，请参见<a href=\"https://wiki.analog.com/resources/tools-software/sigmastudio/usingsigmastudio/wiresandaliases\">连线</a>主题。</p>\n<hr />\n<p><strong>删除算法：</strong></p>\n<p>也可以从块中删除算法。要删除算法，请<strong>右键单击</strong>该块，然后选择“<strong>删除算法”</strong>。这将删除最后添加的算法（底部引脚）。如果该块仅包含一种算法，则删除该算法将导致一个空块</p>\n<hr />\n<p><strong>增长算法：</strong></p>\n<p>不断增长的算法意味着在该块的现有算法的基础上，保持相同的算法（在其上进行扩展）和相同的DSP关联（添加算法均不执行）。要增长算法，请<strong>右键单击</strong>该块，然后选择“<strong>增长算法”&gt;“（算法名称）”&gt;“（增长量）”</strong>。请注意，并非所有算法都可以使用增长。</p>\n<p>理解添加和增长之间区别的最简单方法是使用混合器块。将交叉混合器（2个输入）拖到工作区中。右键单击并选择“增长算法”，请参见下面的示例。</p>\n<ul>\n<li>增加混音器会创建更多的混音器输出引脚，实际上，您正在创建共享公共输入的额外混音器输出通道。块中仍然只有一个算法。</li>\n<li>添加算法将创建单独的算法，这些算法共享控制窗口，但不共享输入/输出引脚或资源。在混频器示例中，一个附加的输入引脚，输出引脚和一个交叉混频器控件被添加到了该模块中。</li>\n</ul>\n<hr />\n<p><strong>减少算法：</strong></p>\n<p>减少与增加相反，减少了由“增加算法”操作创建的多余控件和引脚。像删除算法一样，reduce将删除从底部或最近增长的项目开始的控件/大头针。</p>\n<figure>\n<img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic5.png\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<h3 id=\"wires-and-aliases\">Wires and Aliases</h3>\n<p>SigmaStudio原理图设计由与“导线”连接在一起的模块构建。导线定义了系统的信号流。</p>\n<p><strong>要创建原理图导线：</strong> 将鼠标光标移到块的<a href=\"https://wiki.analog.com/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/schematicblocks\">引脚上，</a>以便显示导线图标<a href=\"https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/icon.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Awiresandaliases\"><img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/icon.png\" alt=\"img\" /></a>。接下来，左键单击一个块引脚，然后在按住鼠标按钮的同时，将光标拖到另一个块的相应引脚上。输入引脚只能连接到输出引脚，而输出引脚只能连接到输入引脚。</p>\n<p><a href=\"https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic1.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Awiresandaliases\"><img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic1.png\" alt=\"img\" /></a></p>\n<p><strong>选择：</strong></p>\n<p>要选择一条导线，请用鼠标左键单击它。选定的电线用绿色正方形（点）表示，如下所示。<strong>位置：</strong></p>\n<p><a href=\"https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic2.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Awiresandaliases\"><img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic2.png\" alt=\"img\" /></a></p>\n<p>要更改导线的位置，请将鼠标光标放在一个点上。接下来，在导线点上<strong>单击</strong>鼠标左键，并在按住鼠标键的同时拖动光标以重新放置导线。</p>\n<p><a href=\"https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic3.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Awiresandaliases\"><img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic3.png\" alt=\"img\" /></a></p>\n<p><strong>菜单：</strong></p>\n<p>右键单击导线以调出导线菜单。该菜单包括以下命令：</p>\n<p><a href=\"https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic4.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Awiresandaliases\"><img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic4.png\" alt=\"img\" /></a></p>\n<p><strong>电线颜色：</strong></p>\n<p>电线根据其关联的DSP处理器进行着色。导线的输入和输出引脚必须与同一DSP关联，否则您将无法在引脚之间建立导线。具有多个处理器IC的项目的每个IC将具有不同的颜色。</p>\n<p><a href=\"https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic5.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Awiresandaliases\"><img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic5.png\" alt=\"img\" /></a></p>\n<hr />\n<p><strong>引脚（导线）备注：</strong></p>\n<p>为了直观地组织项目，通常有助于创建备注，以在原理图中的信号流中提供清晰的连接参考（“跳转”）。一个<strong>备注</strong>由一对输入的备注和备注输出块组成。使用备注块可以减少长导线连接所造成的原理图窗口中的视觉混乱。</p>\n<p>要创建备注，请<strong>右键单击</strong>块的输出引脚（蓝色引脚），然后从菜单中选择“<strong>备注</strong>”。</p>\n<p><a href=\"https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic6.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Awiresandaliases\"><img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic6.png\" alt=\"img\" /></a></p>\n<p>当您单击<strong>Alias时</strong>，将出现两个块，分别是输入和输出。备注输入自动连接到源模块的输出引脚。接下来，创建一条从备注输出块（在下面的示例中为备注2）到信号目标的导线。</p>\n<p><a href=\"https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic7.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Awiresandaliases\"><img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic7.png\" alt=\"img\" /></a></p>\n<p><strong>注意：</strong>使用备注在功能上等同于用电线连接两个引脚。以下示例中的信号流与上面的备注示例相同。</p>\n<p><a href=\"https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic8.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Awiresandaliases\"><img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic8.png\" alt=\"img\" /></a></p>\n<h3 id=\"hardware-configuration-tab\">Hardware Configuration Tab</h3>\n<p>硬件配置工作区允许您为设计选择一个或多个处理器。它还允许您设置SigmaStudio与硬件之间的通信。</p>\n<p>要了解可以在“硬件配置”选项卡中访问的高级操作（包括“输出捕获”，“ Flash / E2Prom下载”，“寄存器控制”窗口和“寄存器读/写”窗口），请参阅“硬件Windows”部分中的主题。</p>\n<p><strong>要将处理器（IC / DSP）插入设计中：</strong></p>\n<ol type=\"1\">\n<li><p>用鼠标左键从工具箱中选择一个“处理器”：</p>\n<ol type=\"1\">\n<li><a href=\"https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic1.png?id=resources%3Atools-software%3Asigmastudio%3Adevelopmentenvironment%3Ahardwareconfigurationtab\"><img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic1.png\" alt=\"img\" /></a></li>\n</ol></li>\n<li><p>将处理器模块拖放到右侧的“硬件配置”窗口中：</p>\n<p><a href=\"https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic2.png?id=resources%3Atools-software%3Asigmastudio%3Adevelopmentenvironment%3Ahardwareconfigurationtab\"><img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic2.png\" alt=\"img\" /></a></p></li>\n</ol>\n<p><strong>注意：</strong>一旦在“硬件配置”窗口中插入DSP，就会出现“原理图（Schematic）”选项卡。</p>\n<p><strong>在DSP处理器和硬件之间建立连接：</strong></p>\n<ol type=\"1\">\n<li>单击“通信渠道（Communication Channel）”类别（在“工具箱”列的底部）。</li>\n<li>从列表中选择评估板或USB设备，并将其拖放到工作区中。</li>\n<li>通过在通信通道和处理器模块之间画线来连接两个模块，从蓝色菱形到绿色菱形。对于使用AD1940的USB连接，工作空间中的单元格应如下所示：</li>\n</ol>\n<p><strong>注意</strong>：“通信通道”菜单列出了带有前缀EvalBoard的名称和板号。这些通信通道将在不使用评估板设置的平台上适用于相同的IC类型。还有通用的通信通道，USBSerialConv和USBi。（有关更多信息，请参见USB串行转换器通信通道或USBi。）</p>\n<p><a href=\"https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic3.png?id=resources%3Atools-software%3Asigmastudio%3Adevelopmentenvironment%3Ahardwareconfigurationtab\"><img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic3.png\" alt=\"img\" /></a></p>\n<p>通信模块上USB标签 的颜色表示是否已建立USB通信通道。如果您已正确配置USB硬件，则背景色将为浅橙色或白色。如果未初始化通信，则背景将为红色。请注意，这仅表示USB连接处于活动状态，不能保证与SigmaDSP IC的通信或SigmaDSP硬件已正确配置。</p>\n<p><a href=\"https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic4.png?id=resources%3Atools-software%3Asigmastudio%3Adevelopmentenvironment%3Ahardwareconfigurationtab\"><img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic4.png\" alt=\"img\" /></a></p>\n<p>连接所有板卡IC时，“已连接”背景色为白色，而仅连接部分IC（但不是全部）时为“橙色”。例如，ADAU1701评估板包括ADAU1701 IC和E2Prom IC。仅连接ADAU1701时，背景将为浅橙色，但同时连接ADAU1701和E2Prom IC时，背景将为白色。</p>\n<p><a href=\"https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic5.png?id=resources%3Atools-software%3Asigmastudio%3Adevelopmentenvironment%3Ahardwareconfigurationtab\"><img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic5.png\" alt=\"img\" /></a></p>\n<p>https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/gettingstarted/usbinterfaces/usbpic4.png?id=resources%3Atools-software%3Asigmastudio%3Agettingstarted%3Ausbinterfaces%3Ausbserialconverter)</p>\n<hr />\n<p><strong>EVAL-ADUSB1板开关和跳线：</strong></p>\n<ul>\n<li>S1-将闪存中保存的程序加载到SigmaDSP。</li>\n<li>S2-选择当按下S1时将加载八个SigmaDSP程序中的哪一个。</li>\n<li>S3-重置USB适配器板。</li>\n<li>TP1-+ 5Vdc连接，用于适配器未通过PC的USB端口供电的情况。</li>\n<li>TP2-接地，用于适配器未通过PC的USB端口供电的情况。</li>\n<li>J3-当该接头连接器上有跳线时，将启用对闪存的写操作（用于存储SigmaDSP程序）。</li>\n<li>D4-此LED指示USB板已通电。</li>\n</ul>\n<p>可以使用SigmaStudio中的Flash Downloader工具将SigmaDSP程序和参数文件保存到USB板上的闪存中。通过将S2设置为适当的设置，然后按下程序加载按钮S1，可以将每个程序加载到SigmaDSP。请参阅Flash Downloader页面。 有关更多信息，请参见EVAL-ADUSB1数据手册，analog.com / sigmadsp。</p>\n<h2 id=\"digital-attenuator\">Digital Attenuator</h2>\n<p>即数字衰减器， 与可变衰减器不同，数字衰减器在离散和有限衰减状态下切换。该切换通常以二进制步骤实现。数字衰减器采用半导体器件来实现每个衰减步骤。为此目的而使用的一些半导体器件包括：PIN二极管，MOSFET和GaAs MESFET。数字衰减器能够实现与固态开关速度相当的开关速率。数字衰减器使用的最常见逻辑类型 是CMOS逻辑电平和晶体管晶体管逻辑（TTL）。</p>\n<p>数字衰减器利用驱动器电路来确定要使用的逻辑类型。驱动器电路的复杂性取决于所使用的位数。复杂度随着位数的增加而增加。通常根据数字衰减器设计提供的衰减状态对其进行分类。使用的位数决定了这些衰减状态。最高有效位提供最大的衰减，而最低有效位提供组件提供的最小衰减。其余位提供中间衰减值。通常，这些产品采用1位，5位，8位和6位数字衰减器。</p>\n<p>如果选择了所有位，则数字衰减器旨在提供最大的额定衰减。另一方面，其最小衰减步长仅通过选择最低有效位来实现。数字衰减器在3G和4G蜂窝网络，点对点节点，中继器以及广泛的测试和测量应用中具有广泛的用途。</p>\n<p class=\"italicp\" style=\"font-style: italic; color: #BBB;\">\nShop Arrow.com选择了数字RF步进衰减器，数字音频衰减器等。 <a hre=\"https://www.arrow.com/en/categories/attenuators/fixedvariable-attenuators/digital-attenuators#\">&gt;&gt;&gt; read more</a>\n</p>\n<h2 id=\"asrc\">ASRC</h2>\n<p>异步采样速率转换器(ASRC，Asynchronous Sample Rate Converter)是一款可同时用于消费电子和专业应用的音频采样速率转换通用软件模块。 ASRC支持多种不同的采样速率配置。</p>\n<p><strong>ASRC软件模块</strong> 可用于以小步长改变采样频率，步长随着时间改变，且在变化过程中不生成任何输出音频干扰。 在许多多媒体系统中，时变采样速率的改变是非常重要的功能，例如能实现多个数据流的精密同步以及服务器和客户端的同步等。</p>\n<p>ADI公司的ASRC实施方案经过高度优化，适合在ADI公司的Blackfin系列处理器上运行。它是一个基于ADI专利设计的独立自足软件模块。该模块已经过各种根据音频信号质量分析定义的策略质量测试。</p>\n<p>ASRC模块是应用于PCM（脉冲编码调制）上的后处理模块，通过模拟输入、数字输入通道或解码应用的PCM输出接收数据。 ASRC模块能够处理多个通道的输入信息，并能够输出至同样多的通道。 开发的模块支持全面的重入和多实例。 ASRC模块是一个独立的模块，不依赖其他任何模块。 ADRC模块配备一个示例轻型包装器API，将模块插入至整体系统。 这使得该应用的系统集成简单易行。</p>\n<h3 id=\"asrc-inputoutput\">ASRC INPUT/OUTPUT</h3>\n<p>ASRC输入和输出模块在原理图设计和硬件ASRC（异步采样率转换器）之间路由信号。</p>\n<p>使用输入块的复选框来启用或禁用特定输入。使用输出块的下拉列表控件从可用的ASRC中进行选择。</p>\n<ul>\n<li>每个ASRC输出必须连接其输入，否则编译时将出错。</li>\n<li>可以看到，随着将更多的ASRC输出块拖到原理图中，下拉列表中的可用输出数量会减少，因为一次只能由一个块表示。</li>\n<li>要更改ASRC <strong>输入采样率</strong>，请右键单击块名称，然后选择“设置采样率”，这将打开“采样率”窗口（默认值为44.1 kHz）。</li>\n</ul>\n<figure>\n<img src=\"https://wiki.analog.com/_media/resources/tools-software/sigmastudio/toolbox/io/asrc_input_output_020.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<h2 id=\"limiter-限幅器\">Limiter 限幅器</h2>\n<p>限幅器（Limiter）是指能按限定的范围削平信号电压波幅的电路，又称削波器。限幅电路的作用是把输出信号幅度限定在一定的范围内，亦即当输入电压超过或低于某一参考值后，输出电压将被限制在某一电平（称作限幅电平），且再不随输入电压变化。</p>\n<h2 id=\"lsb-aligned\">LSB-aligned</h2>\n<p>LSB(Least Significant Bit)是“最低有效位”。MSB(Most Significant Bit)是“最高有效位”。</p>\n<p>最高有效位是指二进制中最高值的比特，如：</p>\n<blockquote>\n<ol type=\"1\">\n<li><p>在16比特的数字音频中，其第1个比特便对16bit的字的数值有最大的影响。</p></li>\n<li><p>在十进制的15，389这一数字中，相当于万数那1行（1）的数字便对数值的影响最大。比较与之相反的“最低有效位”（LSB）。</p></li>\n<li><p>汇编中，比如8位2进制数10000001，其中第一个1是MSB,第二个1是LSB。<mark>1</mark>（MSB）100 001<mark>1</mark>（LSB）</p></li>\n<li><p>在计算时，如果是整数，那么小数点（实际上是没有小数点的，但就把那一位和下一位之间看作有）在LSB后面；如果是小数，小数点在MSB后面；其中MSB在有符号数中又是符号位。</p></li>\n</ol>\n</blockquote>\n<p>在网络通信方面，大家说的更多的是：“<strong>Big-Endian</strong>”和“<strong>Small-Endian</strong>”的问题。指的都是对于多字节的数据类型（比如4字节的32位整数），其多个字节的顺序问题，是最高字节在前（Big-Endian）还是最低字节在前（Small-Endian）。</p>\n<p>比如对于123456789这个整数，其16进制为0x075BCD15，那么按照Big-Endian的方式，它在网络上传输（或者在内存里存储）的4个字节依次是：<code>07 4B CD 15</code>，而Small-Endian的顺序正相反，是：<code>15 CD 4B 07</code>。</p>\n<p><strong>MSB</strong> 和 <strong>LSB</strong> 虽然跟这个事情看起来有点相似，但不是一回事。</p>\n<p>通常，一个芯片的管脚中，对于一个多比特的信号，比如32根的地址线，从低开始按0到31编个号。MSB就是31，LSB就是0。那么如果标记为：ADDR[31:0]就是MSB first的方式，如果标记为ADDR[0:31]就是LSB first的方式。</p>\n<p><strong>MSB LSB</strong>：起始地址为最高位， 最后地址为最低位。</p>\n<p><strong>LSB MSB</strong>：起始地址为最低位，最后地址为最高位。</p>\n<p>比如AD中，8位，最低有效位指D0</p>\n<h2 id=\"cofficient-write\">Cofficient Write</h2>\n<p>即 <strong>参数写入</strong>，是指对参数中两组 <strong><em>寄存器参数集</em></strong> 的系数写入。当然也可以单独写入某个寄存器的数值。</p>\n<p>可写入的参数如：filter coefficients、limiter settings、volume control settings等。</p>\n<p>每组 <strong>寄存器参数集</strong> 可写入至多 160个参数（32个过滤器*5个系数）。</p>\n<h2 id=\"filters\">Filters</h2>\n<p>在ADAU1772的General(2<sup>nd</sup> Order) Filter Setting中有几项过滤器，分别是 Parametric 、 Shelving 、 General HP/LP/BP/BS 、 Butterworth/Bessel 、 Tone Control、IIR Coefficient 、First Order Filters 、All Pass 、Peaking 、Notch 、 Chebyshev 共11中过滤器。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/04/image-20210428152357233.png\" alt=\"image-20210428152357233\" /><figcaption aria-hidden=\"true\">image-20210428152357233</figcaption>\n</figure>\n<h1 id=\"sigmastudio\">SigmaStudio</h1>\n<p>以下简称sigma</p>\n<h2 id=\"capture\">Capture</h2>\n<p>Capture 窗口会捕捉开发者对设置的相关改动记录。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/04/image-20210422165857465.png\" alt=\"image-20210422165857465\" /><figcaption aria-hidden=\"true\">image-20210422165857465</figcaption>\n</figure>\n<h2 id=\"register-control\">Register Control</h2>\n<figure>\n<img src=\"https://pic.islet.space/2021/04/image-20210422163633005.png\" alt=\"image-20210422163633005\" /><figcaption aria-hidden=\"true\">image-20210422163633005</figcaption>\n</figure>\n<h3 id=\"outputserial-port\">Output/Serial Port</h3>\n<h4 id=\"下压式音量按键\">下压式音量按键</h4>\n<p>使用前需要进行跳线，跳线方法如下：</p>\n<p><img src=\"https://pic.islet.space/2021/04/image-20210422163804275.png\" alt=\"image-20210422163804275\" style=\"zoom:50%;\" /></p>\n<p>控制界面如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/04/image-20210422163228410.png\" alt=\"image-20210422163228410\" /><figcaption aria-hidden=\"true\">image-20210422163228410</figcaption>\n</figure>\n<blockquote>\n<p>？？ Time</p>\n<p>Initial PB Volume 初始化下压式按键的音量值</p>\n<p>Gain Step 增益速度</p>\n<p>Ramp Speed 增加速度</p>\n<p>Converters Controlled by PushButton Volume 被控制的转换器</p>\n</blockquote>\n<h2 id=\"download-program\">Download Program</h2>\n<p><img src=\"https://pic.islet.space/2021/04/image-20210422170248954.png\" alt=\"image-20210422170248954\" style=\"zoom:67%;\" /></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/04/image-20210422170328013.png\" alt=\"image-20210422170328013\" /><figcaption aria-hidden=\"true\">image-20210422170328013</figcaption>\n</figure>\n<h2 id=\"microphone\">Microphone</h2>\n<p>TRS 1/8-inch mini-plug stereo headphones</p>\n<p><img src=\"https://pic.islet.space/2021/04/048f07ee-e357-4c06-a8e4-1724e62765a4_1.e937ba0bd42739fc09e9ef63602645b8.jpeg\" alt=\"查看源图像\" style=\"zoom:50%;\" /></p>\n<p>standard 0.100” headers</p>\n<p><img src=\"https://pic.islet.space/2021/04/R68f2db356a43d3653db1298ccd26e835\" alt=\"查看源图像\" style=\"zoom:50%;\" /></p>\n<h3 id=\"bias-setting\">Bias Setting</h3>\n<figure>\n<img src=\"https://pic.islet.space/2021/04/image-20210423102647330.png\" alt=\"image-20210423102647330\" /><figcaption aria-hidden=\"true\">image-20210423102647330</figcaption>\n</figure>\n<p>ADAU1772包括两个麦克风偏置输出：MICBIAS0和MICBIAS1。这些引脚为驻极体模拟麦克风提供电压参考。</p>\n<ol type=\"1\">\n<li>MICBIASx引脚也可用于为具有独立电源引脚的数字或模拟MEMS麦克风干净地提供电压。</li>\n<li>MICBIASx电压在麦克风偏置控制寄存器（地址0x002D）中设置。可以利用这个寄存器对MICBIAS0或MICBIAS1的输出进行启用或禁用。</li>\n<li>增益选项提供了两种可能的电压：0.65 × AVDD或0.90 × AVDD。许多应用要求只启用两个偏置输出中的一个。当系统中使用许多传声器时，或者当传声器在PCB上的位置不允许一个引脚对所有传声器进行偏置时，两个偏置输出都应该被启用。</li>\n</ol>\n<p>dataword byte : 在突发模式（burst mode）中使用。</p>\n<p>data byte : 在单字模式（single-word mode）下写入。</p>\n<h2 id=\"由dsp启动1772\">由DSP启动1772</h2>\n<p>1772启动可以通过以下两种方式执行：</p>\n<ol type=\"1\">\n<li>通过SPI或I2C协议，将执行代码写入到SRAM的方式来执行</li>\n<li>通过将代码写入EEPROM，并设置自启动的方式来读取和执行代码。</li>\n</ol>\n<p>由DSP启动1772，其实是通过上述第一种方式来进行，其中又可以再分为两种方法：</p>\n<ol type=\"1\">\n<li>通过在SigmaStudio中导出项目系统文件，并加载至DSP项目工程的方式来执行，具体方法后述。</li>\n<li>通过SPI协议，由DSP片选1772后逐各写入寄存器的方式来执行（注意：使用本方法时，单次写入量不可超过128个字节）。</li>\n</ol>\n<h3 id=\"通过导出系统文件的方式\">通过导出系统文件的方式</h3>\n<p>在SigmaStudio中，执行过 <code>Link Compile Downloa</code> 后，可以点击 <code>Export System Files</code> 导出项目工程文件（C格式）</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210510084234044.png\" alt=\"image-20210510084234044\" style=\"zoom:80%;\" />，并将 <code>.h</code> 、<code>_PARAM.h</code> 及<code>_REG.h</code> 三个类型文件插入到DSP的项目文件中。</p>\n<p><strong>注意</strong>：如图所示，所选的三个文件为主IC（1772）的工程文件，另外三个同后缀名的IC_2是另一个芯片（EEPROM）的文件，看情况决定是否使用。</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210510091831286.png\" alt=\"image-20210510091831286\" style=\"zoom:67%;\" /></p>\n<p>其中，<code>_PARAM.h</code> 及<code>_REG.h</code> 提供了对寄存器的定义，<code>.h</code> 文件中提供了唯一的执行方法 <code>default_download_IC_1()</code>，在DSP项目工程文件中执行即可。</p>\n<p><img src=\"https://pic.islet.space/2021/06/20210601105542.png\" alt=\"image-20210510092602442\" style=\"zoom: 50%;\" /></p>\n<p><strong>注意：</strong>本文件依赖于 <code>SigmaStudioFW.h</code> 头文件，<img src=\"https://pic.islet.space/2021/05/image-20210510093228165.png\" alt=\"image-20210510093228165\" />，可以复制粘贴以下原代码，也可以在SigmaStudio的安装目录下查找。</p>\n<p><mark>需要注意的是，以下所有宏定义内容都为空，需要开发者自行编写。</mark></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * File:\t\t\tSigmaStudioFW.h</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Description:  \tSigmaStudio System Framwork macro definitions. These </span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t\t\tmacros should be implemented for your system&#x27;s software.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This software is distributed in the hope that it will be useful,</span></span><br><span class=\"line\"><span class=\"comment\"> * but is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR </span></span><br><span class=\"line\"><span class=\"comment\"> * CONDITIONS OF ANY KIND, without even the implied warranty of</span></span><br><span class=\"line\"><span class=\"comment\"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * This software may only be used to program products purchased from</span></span><br><span class=\"line\"><span class=\"comment\"> * Analog Devices for incorporation by you into audio products that </span></span><br><span class=\"line\"><span class=\"comment\"> * are intended for resale to audio product end users. This software</span></span><br><span class=\"line\"><span class=\"comment\"> * may not be distributed whole or in any part to third parties.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Copyright � 2008 Analog Devices, Inc. All rights reserved.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span>\t</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __SIGMASTUDIOFW_H__</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __SIGMASTUDIOFW_H__</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">TODO:</span> Update for your system&#x27;s data type</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> ADI_DATA_U16;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>  ADI_REG_TYPE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * Parameter data format</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIGMASTUDIOTYPE_FIXPOINT \t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIGMASTUDIOTYPE_INTEGER \t1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * Write to a single Device register</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIGMA_WRITE_REGISTER( devAddress, address, dataLength, data ) &#123;<span class=\"comment\">/*<span class=\"doctag\">TODO:</span> implement macro or define as function*/</span>&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">TODO:</span> CUSTOM MACRO IMPLEMENTATION</span></span><br><span class=\"line\"><span class=\"comment\"> * Write to multiple Device registers </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIGMA_WRITE_REGISTER_BLOCK( devAddress, address, length, pData ) &#123;<span class=\"comment\">/*<span class=\"doctag\">TODO:</span> implement macro or define as function*/</span>&#125; </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">TODO:</span> CUSTOM MACRO IMPLEMENTATION</span></span><br><span class=\"line\"><span class=\"comment\"> * Writes delay (in ms) </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIGMA_WRITE_DELAY( devAddress, length, pData ) &#123;<span class=\"comment\">/*<span class=\"doctag\">TODO:</span> implement macro or define as function*/</span>&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Read device registers </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIGMA_READ_REGISTER( devAddress, address, length, pData ) &#123;<span class=\"comment\">/*<span class=\"doctag\">TODO:</span> implement macro or define as function*/</span>&#125; </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Set a register field&#x27;s value</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIGMA_SET_REGSITER_FIELD( regVal, fieldVal, fieldMask, fieldShift )  \\</span></span><br><span class=\"line\">\t\t&#123; (regVal) = (((regVal) &amp; (~(fieldMask))) | (((fieldVal) &lt;&lt; (fieldShift)) &amp;&amp; (fieldMask))) &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Get the value of a register field</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIGMA_GET_REGSITER_FIELD( regVal, fieldMask, fieldShift )  \\</span></span><br><span class=\"line\">\t\t&#123; ((regVal) &amp; (fieldMask)) &gt;&gt; (fieldShift) &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * Convert a floating-point value to SigmaDSP (5.23) fixed point format </span></span><br><span class=\"line\"><span class=\"comment\"> *    This optional macro is intended for systems having special implementation</span></span><br><span class=\"line\"><span class=\"comment\"> *    requirements (for example: limited memory size or endianness)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIGMASTUDIOTYPE_FIXPOINT_CONVERT( _value ) &#123;<span class=\"comment\">/*<span class=\"doctag\">TODO:</span> IMPLEMENT MACRO*/</span>&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * Convert integer data to system compatible format</span></span><br><span class=\"line\"><span class=\"comment\"> *    This optional macro is intended for systems having special implementation</span></span><br><span class=\"line\"><span class=\"comment\"> *    requirements (for example: limited memory size or endianness)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIGMASTUDIOTYPE_INTEGER_CONVERT( _value ) &#123;<span class=\"comment\">/*<span class=\"doctag\">TODO:</span> IMPLEMENT MACRO*/</span>&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"通过写入寄存器的方式\">通过写入寄存器的方式</h3>\n<p>在 Capture 面板中，对寄存器的所有操作都会以 <strong>参数名</strong>、<strong>地址</strong> 和 <strong>数据</strong> 的方式展现，几乎所有参数名都可以在《ADAU1772》中查询。</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210510091150821.png\" alt=\"image-20210510091150821\" style=\"zoom: 67%;\" /></p>\n<ol type=\"1\">\n<li>全选面板中所有的值，可以点选第一个值，按 <code>SHIFT</code> + <code>END</code> 来全选，然后右键选择 <code>Save as Raw Data</code> 下的 <code>Address+Data(Text)...</code> ，会以文本格式 (.txt) 保存。</li>\n</ol>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210510085052186.png\" alt=\"image-20210510085052186\" style=\"zoom:67%;\" /></p>\n<p>保存结果：</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210510085331956.png\" alt=\"image-20210510085331956\" style=\"zoom:67%;\" /></p>\n<ol start=\"2\" type=\"1\">\n<li>将地址和值整理到DSP项目文件中进行写入，这种方式不太好操作，需要开发人员自行编写对应的代码，较为不友好。</li>\n</ol>\n<h1 id=\"chip-adau1772\">CHIP-ADAU1772</h1>\n<ul>\n<li>ADAU1772以下简称1772</li>\n<li>《Evaluation Board User Guide UG-477》以下简称UG</li>\n</ul>\n<h2 id=\"i2s及i2c接口\">I2S及I2C接口</h2>\n<p><img src=\"https://pic.islet.space/2021/06/20210601105550.png\" alt=\"image-20210513171416187\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/06/20210601105615.png\" alt=\"image-20210513171524562\" style=\"zoom:67%;\" /></p>\n<h2 id=\"usbi-仿真器\">USBi 仿真器</h2>\n<ul>\n<li>USBi驱动安装：进入设备管理器，安装驱动在SigmaStudio安装目录 <code>\\Analog Devices\\SigmaStudio 4.6\\USB drivers\\</code> 下。</li>\n<li>连接到USBi未成功时是红色，设备驱动安装且连接成功时，USBi 在sigma中会由红变绿。</li>\n<li>USBi作为中间板对1772进行控制，在USBi右键可以控制1772设备开断，开断时板上D1区的VDD指示灯也会通断（见page10）。</li>\n<li>如果需要对设备进行实时控制，请务必记得打开设备，否则无法操作。</li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/04/image-20210428150645112.png\" alt=\"image-20210428150645112\" style=\"zoom: 67%;\" /></p>\n<ul>\n<li>USBi将例程down到了板子上ADAU1772的SRAM上，断电就没有了。USBi的这种调试是为了快速验证功能，最终需要把这个例程的代码导出，并通过单片机的 <strong>启动工程集成</strong>，烧写到单片机中，实现单片机启动。</li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/04/image-20210427110916316.png\" alt=\"image-20210427110916316\" style=\"zoom:67%;\" /></p>\n<h3 id=\"编译烧录\">编译烧录</h3>\n<ul>\n<li>烧录按键如下：</li>\n</ul>\n<figure>\n<img src=\"https://pic.islet.space/2021/04/image-20210427162529600.png\" alt=\"image-20210427162529600\" /><figcaption aria-hidden=\"true\">image-20210427162529600</figcaption>\n</figure>\n<ul>\n<li>编译完毕后，SS会在右边的output窗体里显示编译结果，如有错误会提示错误信息，用户可据此信息去修改设计；</li>\n<li>如成功则会显示资源占用信息，用户可根据百分比来增减模块。</li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/04/image-20210427111013493.png\" alt=\"image-20210427111013493\" style=\"zoom:67%;\" /></p>\n<h3 id=\"芯片\">芯片</h3>\n<p>板上共有4颗芯片，分别是 <strong>DSP</strong>、<strong>EEPROM</strong>、<strong>线性整流芯片</strong> 和 <strong>升压芯片</strong></p>\n<p><img src=\"https://pic.islet.space/2021/04/image-20210427171901213.png\" alt=\"image-20210427171901213\" style=\"zoom:50%;\" /></p>\n<h4 id=\"u2-eeprom\">U2: EEPROM</h4>\n<p>ST官网对M24C32-F串行E2PROM的描述：</p>\n<p>容量：32-Kbit</p>\n<p>电压：1.7 ~ 5.5V</p>\n<p>温差：-40 ~ +85℃</p>\n<p><img src=\"https://pic.islet.space/2021/04/Snipaste_2021-04-27_17-18-01.png\" alt=\"Snipaste_2021-04-27_17-18-01\" style=\"zoom: 67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/04/Snipaste_2021-04-27_17-18-18.png\" alt=\"Snipaste_2021-04-27_17-18-18\" style=\"zoom:67%;\" /></p>\n<h2 id=\"输入输出控制\">输入输出控制</h2>\n<h3 id=\"供电电压\">供电电压</h3>\n<p>以下为实际测量数值</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>USB_5V</th>\n<th>SCL/SDA(H)</th>\n<th></th>\n<th>VDD</th>\n<th>IOVDD</th>\n<th>AVDD</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>接USBi实测电压(V)-3.3V档</td>\n<td>3.471</td>\n<td>1.961</td>\n<td></td>\n<td>1.997</td>\n<td>1.997</td>\n<td>1.988</td>\n</tr>\n<tr class=\"even\">\n<td>接21479实测电压(V)-3.3V档</td>\n<td>4.463</td>\n<td>3.518</td>\n<td></td>\n<td>3.518</td>\n<td>3.518</td>\n<td>3.518</td>\n</tr>\n<tr class=\"odd\">\n<td>接21479实测电压(V)-1.8V档</td>\n<td>4.468</td>\n<td>2.260</td>\n<td></td>\n<td>1.934</td>\n<td>1.934</td>\n<td>1.933</td>\n</tr>\n<tr class=\"even\">\n<td>接21479实测电压(V)-3.3V档</td>\n<td>3.3</td>\n<td>3.3088</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"hp输出\">HP输出</h2>\n<p>HP即Headphone缩写，HP输出有两个输出端，分别是DAC0 和 DAC1，分别对应为 EVAL板 上的 OUT R(HP Right) 和 OUT L(HP Left)。</p>\n<p><img src=\"https://pic.islet.space/2021/04/image-20210427152251539.png\" alt=\"image-20210427152251539\" style=\"zoom:50%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/04/image-20210427143628880.png\" alt=\"image-20210427143628880\" style=\"zoom: 33%;\" /></p>\n<h3 id=\"输出静音\">输出静音</h3>\n<p><img src=\"https://pic.islet.space/2021/04/image-20210427153425633.png\" alt=\"image-20210427153425633\" style=\"zoom:50%;\" /></p>\n<h3 id=\"输出断电\">输出断电</h3>\n<p>关于HP输出的寄存器 <code>HP_EN_R</code> 及 <code>HP_EN_L</code> 说明：</p>\n<p><img src=\"https://pic.islet.space/2021/04/image-20210427152528194.png\" alt=\"image-20210427152528194\" style=\"zoom:50%;\" /></p>\n<p><code>0x31</code> 即 <code>0011 0001</code> ，最后两位 <code>01</code> 即 <code>HP_PDN_L</code> 中的 <code>01</code> 。</p>\n<h3 id=\"输出音量控制\">输出音量控制</h3>\n<ul>\n<li>对输出音量进行控制需要先对S5、S6进行跳针。</li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/04/image-20210427110159648.png\" alt=\"image-20210427110159648\" style=\"zoom:67%;\" /></p>\n<h3 id=\"talkthru-dsp-bypass\">TALKTHRU / DSP BYPASS</h3>\n<blockquote>\n<p>DSP BYPASS MODE When DSP bypass mode is enabled, a direct path from the ADC outputs to the DACs is set up to enable bypassing the core processing to listen to environmental sounds.</p>\n<p>This is useful for listening to someone speaking without having to remove the noise cancelling headphones. The DSP bypass path is <strong>enabled by setting an MPx pin low</strong>.</p>\n<p>Figure 92 shows the DSP bypass path disabled, and Figure 93 shows the DSP bypass path enabled by pressing the push-button switch.</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/04/image-20210427144110884.png\" alt=\"image-20210427144110884\" /><figcaption aria-hidden=\"true\">image-20210427144110884</figcaption>\n</figure>\n<p>The DSP bypass feature works for both analog and digital microphone inputs.</p>\n<ul>\n<li>Enabled when <strong><em>a switch</em></strong> connected to an MPx pin that is set to DSP bypass mode is closed and the MPx pin signal is pulled low.</li>\n</ul>\n<p>Pressing and holding the switch closed enables the DSP bypass signal path as defined in the TALKTHRU register (Address 0x002A).</p>\n<p>The DAC volume control setting is switched from the default gain setting to the new TALKTHRU_GAINx register setting (Address 0x002B and Address 0x002C).</p>\n<ul>\n<li>DSP bypass is enabled only on ADC0 and ADC1.</li>\n</ul>\n<p>The DSP bypass signal path is from the output of ADCx to the input of the DAC(s). When DSP bypass is enabled, the current DAC volume setting is ramped down to −95.625 dB and the DSP bypass volume setting is ramped up to avoid pops when switching paths.</p>\n</blockquote>\n<h1 id=\"chip-adsp21479\">CHIP-ADSP21479</h1>\n<h2 id=\"芯片及评估板资料\">芯片及评估板资料</h2>\n<p><strong>关于芯片特性</strong>：《ADSP-21477 / ADSP-21478 / ADSP-21479》</p>\n<p><strong>关于评估板</strong>：《ADSP-21479 EZ-Board® Evaluation System Manual》</p>\n<h2 id=\"仿真器配置\">仿真器配置</h2>\n<p>与《HPUSB, USB, and HPPCI Emulators User’s Guide》所描述的并不完全一致。</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210519104127472.png\" alt=\"image-20210519104127472\" style=\"zoom: 50%;\" /></p>\n<p>下图为实际安装后，查看官方对21479提供的相关仿真器的信息和从设备管理器中可查看到的设备信息。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210519110546.png\" alt=\"image-20210519104034539\" /><figcaption aria-hidden=\"true\">image-20210519104034539</figcaption>\n</figure>\n<p><img src=\"https://pic.islet.space/2021/05/20210519110551.png\" alt=\"image-20210519104001549\" style=\"zoom:67%;\" /></p>\n<p>本评估板提供的仿真器使用的是14针脚的HPPCI JTAG，PCI仿真器支持的<mark>操作模式取决于目标机上</mark>14针JTAG接头<mark>的连接方式</mark>。表1-2显示了目标机JTAG头在传统和自动检测模式下的连接方式。</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210519105525684.png\" alt=\"image-20210519105525684\" style=\"zoom:67%;\" /></p>\n<p><strong>注意</strong>：其中3口是无针脚的防呆设计。</p>\n<h3 id=\"hpusb-jtag模式\">HPUSB JTAG模式</h3>\n<p>在实际开发中，使用的是HPUSB传统模式。</p>\n<p>传统模式用于不提供目标VDDIO输入的旧目标，供仿真器自动检测电压。 在这种模式下，JTAG信号运行的电压是通过配置器工具手动设置的。在配置目标时，配置器工具提供了一个电压选择设置。</p>\n<blockquote>\n<p>Legacy mode is used for older targets that do not provide a target VDDIO input for automatic voltage detection by the emulator.</p>\n<p>In this mode, the voltage at which the JTAG signals run is set manually through the Configurator utility.</p>\n<p>The configurator utility provides a voltage selection setting when configuring the target.</p>\n</blockquote>\n<p><strong>注意</strong>：HPUSB-ICE 和 USB-ICE 仿真器都不支持自动电压检测模式。</p>\n<p>以下为JTAG的电路示意：</p>\n<p><img src=\"https://pic.islet.space/2021/05/20210519111130.png\" alt=\"image-20210519111126670\" style=\"zoom:80%;\" /></p>\n<h2 id=\"i2ctwi串行通信\">I2C/TWI串行通信</h2>\n<p>根据文件《ADSP-21477_21478_21479_cn》的描述，可知21479支持TWI接口，进而支持I2C。</p>\n<p><img src=\"https://pic.islet.space/2021/05/20210519112440.png\" alt=\"image-20210519112357298\" style=\"zoom:67%;\" /></p>\n<p>21479没有针对TWI做专门的驱动，Blackfin系列大部分产品都提供了。</p>\n<h2 id=\"dai接口\">DAI接口</h2>\n<p><strong>Digital Application Interface</strong>，即数字应用接口。所有数字应用接口都以SRU的方式连接至处理器。</p>\n<p><strong>SRU</strong>（Signal Routing Unit），即信号路由单元。SRU是处理器内部的一个提供超大系统信号流的复杂路由系统。通过SRU可以将DAI针脚利用不同组合路由至不同的内部设备。DAI所能连接的设备在每块评估板上都不同。下图展示了DAI接口的针脚、所连接的设备及其网络、所连接的开关和默认设置。</p>\n<p><mark>要在扩展II接口上使用DAI，请先用相关开关禁用驱动DAI引脚上的任何信号。</mark></p>\n<p><img src=\"https://pic.islet.space/2021/05/20210520110351.png\" alt=\"image-20210520110207578\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/05/20210520110355.png\" alt=\"image-20210520110221920\" style=\"zoom:67%;\" /></p>\n<h2 id=\"dpi接口\">DPI接口</h2>\n<p>Digital Peripheral Interface，即数字外围（设备）接口 或 数字设备接口。DPI连接至第二块信号路由单元（SRU2）。</p>\n<p>与SRU相似，SRU2也是一块能将大型系统信号流路由至处理器的复杂路由系统。</p>\n<p>同样，每块评估板的DPI所连接的设备也不同。下图同：</p>\n<p><img src=\"https://pic.islet.space/2021/06/20210601105459.png\" alt=\"image-20210520111001486\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/06/20210612111612.png\" alt=\"image-20210612111607855\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/06/20210612111852.png\" alt=\"image-20210612111848897\" style=\"zoom:67%;\" /></p>\n<h2 id=\"sru.h\">SRU.H</h2>\n<h3 id=\"sru\">SRU()</h3>\n<p>以下是 <code>&lt;sru21479.h&gt;</code> 中对 <code>SRU()</code> 的宏定义，<code>SRU2()</code> 与其相同 ：<code>#define SRU2(out,in)   SRU(out,in)</code>。</p>\n<p>读取、修改和写回一个特定的SRU寄存器，以改变一个SRU的分配（即选择一个输入到一个输出）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** Macro: SRU</span></span><br><span class=\"line\"><span class=\"comment\">** Reads, modifies and writes back a particular SRU register to change a single</span></span><br><span class=\"line\"><span class=\"comment\">** SRU assignment (i.e. selects an input to an output).</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">ifdef</span> _LANGUAGE_C</span></span><br><span class=\"line\"><span class=\"meta\">#  <span class=\"meta-keyword\">define</span> SRU(out,in)                        \\</span></span><br><span class=\"line\">     <span class=\"keyword\">do</span> &#123;                                    \\</span><br><span class=\"line\">       *(<span class=\"keyword\">volatile</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *) in##_REG = \\</span><br><span class=\"line\">         ((<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)sru_field(out,in) |  \\</span><br><span class=\"line\">         (* (<span class=\"keyword\">volatile</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *) in##_REG &amp; (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)sru_mask(out,in))); \\</span><br><span class=\"line\">     &#125; <span class=\"keyword\">while</span> (<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#  <span class=\"meta-keyword\">define</span> SRU(out,in)        \\</span></span><br><span class=\"line\">     r0=dm(in##_REG);        \\</span><br><span class=\"line\">     r1=sru_mask(out,in);    \\</span><br><span class=\"line\">     r0=r0 <span class=\"keyword\">and</span> r1;           \\</span><br><span class=\"line\">     r1=sru_field(out,in);   \\</span><br><span class=\"line\">     r0=r0 <span class=\"keyword\">or</span> r1;            \\</span><br><span class=\"line\">     dm(in##_REG)=r0;</span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sru_field\">sru_field()</h3>\n<p>为一个给定的输入和输出信号创建位域（bit field）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">**   Macro: sru_field</span></span><br><span class=\"line\"><span class=\"comment\">**   Creates the bit field for a given input and output signal.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> sru_field(out,in) \\</span></span><br><span class=\"line\">    (((in##_GROUP &amp; GROUP_A) &gt;&gt; LOG_GROUP_A) * A_#<span class=\"meta\">#out \\</span></span><br><span class=\"line\">    |((in##_GROUP &amp; GROUP_B) &gt;&gt; LOG_GROUP_B) * B_#<span class=\"meta\">#out \\</span></span><br><span class=\"line\">    |((in##_GROUP &amp; GROUP_C) &gt;&gt; LOG_GROUP_C) * C_#<span class=\"meta\">#out \\</span></span><br><span class=\"line\">    |((in##_GROUP &amp; GROUP_D) &gt;&gt; LOG_GROUP_D) * D_#<span class=\"meta\">#out \\</span></span><br><span class=\"line\">    |((in##_GROUP &amp; GROUP_E) &gt;&gt; LOG_GROUP_E) * E_#<span class=\"meta\">#out \\</span></span><br><span class=\"line\">    |((in##_GROUP &amp; GROUP_F) &gt;&gt; LOG_GROUP_F) * F_#<span class=\"meta\">#out \\</span></span><br><span class=\"line\">    |((in##_GROUP &amp; GROUP_G) &gt;&gt; LOG_GROUP_G) * G_#<span class=\"meta\">#out \\</span></span><br><span class=\"line\">    |((in##_GROUP &amp; GROUP_H) &gt;&gt; LOG_GROUP_H) * H_#<span class=\"meta\">#out \\</span></span><br><span class=\"line\">    |((in##_GROUP &amp; GROUP_I) &gt;&gt; LOG_GROUP_I) * I_#<span class=\"meta\">#out \\</span></span><br><span class=\"line\">    |((in##_GROUP &amp; GROUP_A2)&gt;&gt; LOG_GROUP_A2)* A2_#<span class=\"meta\">#out \\</span></span><br><span class=\"line\">    |((in##_GROUP &amp; GROUP_B2)&gt;&gt; LOG_GROUP_B2)* B2_#<span class=\"meta\">#out \\</span></span><br><span class=\"line\">    |((in##_GROUP &amp; GROUP_C2)&gt;&gt; LOG_GROUP_C2)* C2_#<span class=\"meta\">#out ) &lt;&lt; in##_SHIFT</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sru_mask\">sru_mask()</h3>\n<p>创建一个掩码，可用于清除属于给定输入和输出信号的位域。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">**   Macro: sru_mask </span></span><br><span class=\"line\"><span class=\"comment\">**   Creates a mask which can be used for clearing the bitfield belonging </span></span><br><span class=\"line\"><span class=\"comment\">**   to the given input and output signal.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> sru_mask(out,in) \\</span></span><br><span class=\"line\">     ~((((in##_GROUP &amp; GROUP_A) &gt;&gt; LOG_GROUP_A) * MASK_A \\</span><br><span class=\"line\">       |((in##_GROUP &amp; GROUP_B) &gt;&gt; LOG_GROUP_B) * MASK_B \\</span><br><span class=\"line\">       |((in##_GROUP &amp; GROUP_C) &gt;&gt; LOG_GROUP_C) * MASK_C \\</span><br><span class=\"line\">       |((in##_GROUP &amp; GROUP_D) &gt;&gt; LOG_GROUP_D) * MASK_D \\</span><br><span class=\"line\">       |((in##_GROUP &amp; GROUP_E) &gt;&gt; LOG_GROUP_E) * MASK_E \\</span><br><span class=\"line\">       |((in##_GROUP &amp; GROUP_F) &gt;&gt; LOG_GROUP_F) * MASK_F \\</span><br><span class=\"line\">       |((in##_GROUP &amp; GROUP_G) &gt;&gt; LOG_GROUP_G) * MASK_G \\</span><br><span class=\"line\">       |((in##_GROUP &amp; GROUP_H) &gt;&gt; LOG_GROUP_H) * MASK_H \\</span><br><span class=\"line\">       |((in##_GROUP &amp; GROUP_I) &gt;&gt; LOG_GROUP_I) * MASK_I \\</span><br><span class=\"line\">       |((in##_GROUP &amp; GROUP_A2)&gt;&gt; LOG_GROUP_A2)* MASK_A2\\</span><br><span class=\"line\">       |((in##_GROUP &amp; GROUP_B2)&gt;&gt; LOG_GROUP_B2)* MASK_B2\\</span><br><span class=\"line\">       |((in##_GROUP &amp; GROUP_C2)&gt;&gt; LOG_GROUP_C2)* MASK_C2) &lt;&lt; in##_SHIFT)</span><br></pre></td></tr></table></figure>\n<h3 id=\"示例\">示例</h3>\n<p>如下图所示，1~8的LED灯珠都与一个处理器针脚相连。DPI和DAI在此处并没有严格划分界限，但是用法上仍有些差异，如前三个LED连接的是DPI针脚，其函数<code>SRU()</code>的第一个参数写的是 <code>FLAG</code>，而其他 DAI 的第一个参数是 <code>LOW</code> 。</p>\n<p><img src=\"https://pic.islet.space/2021/05/20210520113348.png\" alt=\"image-20210520113025876\" style=\"zoom:50%;\" /></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void Init_LEDs(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;* 设置SRU和路由，使标志引脚连接到DPI引脚缓冲区 *&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;* 只使用标志4至15，标志0至3在DPI上不可用。 *&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSRU(FLAG4_O,DPI_PB06_I);\t&#x2F;* 将 Flag4 输出 连接到 DPI_PB06 输入（用于LED1） *&#x2F;</span><br><span class=\"line\">\tSRU(FLAG5_O,DPI_PB13_I);\t&#x2F;* 将 Flag5 输出 连接到 DPI_PB13 输入（用于LED2） *&#x2F;</span><br><span class=\"line\">\tSRU(FLAG6_O,DPI_PB14_I);\t&#x2F;* 将 Flag6 输出 连接到 DPI_PB14 输入（用于LED3） *&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSRU(LOW,DAI_PB03_I);\t    &#x2F;* connect Input LOW to LED4 *&#x2F;</span><br><span class=\"line\">\tSRU(LOW,DAI_PB04_I);    \t&#x2F;* connect Input LOW to LED5 *&#x2F;</span><br><span class=\"line\">\tSRU(LOW,DAI_PB15_I);\t\t&#x2F;* connect Input LOW to LED6 *&#x2F;</span><br><span class=\"line\">\tSRU(LOW,DAI_PB16_I);\t\t&#x2F;* connect Input LOW to LED7 *&#x2F;</span><br><span class=\"line\">\tSRU(LOW,DAI_PB17_I);\t\t&#x2F;* connect Input LOW to LED8 *&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;* 使用以下顺序启用缓冲器：高电平-&gt;输出，低电平-&gt;输入 *&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSRU(HIGH,DPI_PBEN06_I);\t\t&#x2F;* LED1 *&#x2F;</span><br><span class=\"line\">\tSRU(HIGH,DPI_PBEN13_I);\t\t&#x2F;* LED2 *&#x2F;</span><br><span class=\"line\">\tSRU(HIGH,DPI_PBEN14_I);\t\t&#x2F;* LED3 *&#x2F;</span><br><span class=\"line\">\tSRU(HIGH,PBEN03_I);\t\t\t&#x2F;* LED4 *&#x2F;</span><br><span class=\"line\">\tSRU(HIGH,PBEN04_I);\t\t\t&#x2F;* LED5 *&#x2F;</span><br><span class=\"line\">\tSRU(HIGH,PBEN15_I);\t\t\t&#x2F;* LED6 *&#x2F;</span><br><span class=\"line\">\tSRU(HIGH,PBEN16_I);\t\t\t&#x2F;* LED7 *&#x2F;</span><br><span class=\"line\">\tSRU(HIGH,PBEN17_I);\t\t\t&#x2F;* LED8 *&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;* 将标志引脚设置为输出 *&#x2F;</span><br><span class=\"line\">\tsysreg_bit_set( sysreg_FLAGS, (FLG4O|FLG5O|FLG6O) );</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;* 清除标志引脚 *&#x2F;</span><br><span class=\"line\">\tsysreg_bit_clr( sysreg_FLAGS, (FLG4|FLG5|FLG6) );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"定时器\">定时器</h2>\n<p>《ADSP-21477_21478_21479_cn》</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210611170206.png\" alt=\"image-20210611170204474\" /><figcaption aria-hidden=\"true\">image-20210611170204474</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210611170307.png\" alt=\"image-20210611170253655\" /><figcaption aria-hidden=\"true\">image-20210611170253655</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210611170344.png\" alt=\"image-20210611170342735\" /><figcaption aria-hidden=\"true\">image-20210611170342735</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210611170357.png\" alt=\"image-20210611170355842\" /><figcaption aria-hidden=\"true\">image-20210611170355842</figcaption>\n</figure>\n<h3 id=\"创建定时器\">创建定时器</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Install and enable a handler for the high priority core timer interrupt.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">adi_int_InstallHandler(ADI_CID_TMZHI, <span class=\"comment\">/*iid - high priority core timer */</span></span><br><span class=\"line\">\t\t               timer_isr,     <span class=\"comment\">/*handler*/</span></span><br><span class=\"line\">\t\t               (<span class=\"keyword\">void</span> *)&amp;timer_isr_count1, <span class=\"comment\">/*handler parameter*/</span></span><br><span class=\"line\">\t\t                <span class=\"literal\">true</span>           <span class=\"comment\">/*do enable*/</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"定时器中断句柄\">定时器中断句柄</h3>\n<p>来自实例《core_timer》:</p>\n<ul>\n<li>在定时器中断句柄 <code>timer_isr</code> 里面，不能调用标准IO函数，或者更新非volatile全局变量</li>\n<li>可以使用处理程序参数来识别被处理的中断 <code>iid</code>，并通过中断特定的回调指针参数 <code>handlerArg</code> 来访问数据。</li>\n</ul>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210621154021.png\" alt=\"image-20210612151008408\" /><figcaption aria-hidden=\"true\">image-20210612151008408</figcaption>\n</figure>\n<h1 id=\"examples\">EXAMPLES</h1>\n<h2 id=\"exp1\">EXP1</h2>\n<p>本案例使用麦克风采集信号并从前两个通道输入，经过信号增益放大器调整后经过立体声通道输出。</p>\n<p>具体步骤如下：</p>\n<ol type=\"1\">\n<li>从左侧 <strong>树状工具箱</strong>(TreeToolBox)中拖出1772和USBi，并进行连接。</li>\n</ol>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210428094527305.png\" alt=\"image-20210428094527305\" style=\"zoom: 67%;\" /></p>\n<ol start=\"2\" type=\"1\">\n<li>在 <strong>原理图（SCHEMATIC)</strong> <img src=\"https://pic.islet.space/2021/05/image-20210506150111553.png\" alt=\"image-20210506150111553\" style=\"zoom:80%;\" />中需要对输入输出路径进行定义，在此处定义的所有图形编程内容都是对 <strong>可编程增益放大器（PGA）</strong>的使用，即此处的输入到输出所有内容都不经过 <strong>信号通路（SIGNAL ROUTING）</strong> 选项卡中的 <strong>音频处理核心（AUDIO PROCESSING CORE）</strong>，是由 <strong>核心输入选择器（CORE INPUT SELECTION）</strong>完成的，<mark>也可以理解为PGA就是在其中，且PGA的设置在原理图中进行。</mark></li>\n</ol>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210506145903478.png\" alt=\"image-20210506145903478\" style=\"zoom:67%;\" /></p>\n<ol start=\"3\" type=\"1\">\n<li>在原理图中，从左侧 <img src=\"https://pic.islet.space/2021/05/image-20210506150230833.png\" alt=\"image-20210506150230833\" style=\"zoom:80%;\" /> 拖出组件并连线如下，其中需要用到四个通道中的第1及第2通道，每个通告分别连接到一个 <strong>线性增益器（LINEAR GAIN）</strong>，增益50分贝，将原本的麦克风信号从-60分贝左右提升一下。然后经过 <strong>全通角过滤器（ALL POLE FILTER）</strong>,对1500Hz以下的声音增益10分贝。再经过 <strong>分线器（T CONNECTION）</strong>，将信号分别传输给 <strong>分贝显示器（DISPLAY DBREG）</strong>及 <strong>输出通道（OUTPUT）</strong>。</li>\n</ol>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210428095433721.png\" alt=\"image-20210428095433721\" style=\"zoom:80%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210506144919655.png\" alt=\"image-20210506144919655\" style=\"zoom: 80%;\" /></p>\n<ol start=\"4\" type=\"1\">\n<li>另，PGA的设置还需要在 <strong>PGA/ADC</strong> 选项卡中进行设置：</li>\n</ol>\n<ul>\n<li>启用<strong>PGA<sub>x</sub></strong> 及 <strong>PGA<sub>x</sub> Boost</strong></li>\n<li>启用 <strong>Mic<sub>x</sub> Bias</strong></li>\n<li>调整 各通道的增益大小等</li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210506145534521.png\" alt=\"image-20210506145534521\" style=\"zoom:80%;\" /></p>\n<ol start=\"5\" type=\"1\">\n<li>对 <strong>信号通路</strong> 选项卡进行设置，使信号不经过 <strong>音频处理核心</strong> ，启用 <strong>输出ASRC源选择器（OUTPUT ASRC SOURCE SELECT）</strong> ，信号经流如图示：</li>\n</ol>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210506150516695.png\" alt=\"image-20210506150516695\" style=\"zoom: 80%;\" /></p>\n<ol start=\"6\" type=\"1\">\n<li>​ 如果设置芯片使用，可以在 <strong>芯片控制（CHIP CONTROL）</strong>选项卡中设置性能增强模式</li>\n</ol>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210506151533990.png\" alt=\"image-20210506151533990\" style=\"zoom:80%;\" /></p>\n<ol start=\"7\" type=\"1\">\n<li>接入正常的TS接口麦克风即可输入正常波形。</li>\n</ol>\n<h2 id=\"exp2\">EXP2</h2>\n<p>本案例为PLL及时钟案例，首先需要明确以下几点：</p>\n<ol type=\"1\">\n<li>1772的工作频率为12.288兆赫，PLL的输出频率被要求一定是24.576兆赫。</li>\n<li>且从MCLKIN输入的频率范围为8至27兆赫，可以通过整数或分数分频来获得1772所需的工作频率（最终必须是12.288兆赫）。</li>\n<li>通过设置4个参数 <code>x</code> 、<code>R</code>、<code>N</code> 及 <code>M</code> 对PLL进行参数调整，其中整数倍分频时只有在 <code>MCLKIN = 12.288MHz</code> 或 <code>MCLKIN = 24.576MHz</code> 时可用。</li>\n</ol>\n<p>已知，MCLK的输入频率16.625MHz，符合输入范围要求，以及最终目标输出频率24.576MHz。</p>\n<p>首先启用PLL，点击<img src=\"https://pic.islet.space/2021/05/image-20210513100438475.png\" alt=\"image-20210513100438475\" style=\"zoom: 67%;\" />，然后通过对 <code>PLL M and N Calculator</code> 进行设置，并点击 <code>Load Parameters</code> 进行自动计算和加载即可。</p>\n<p>在主时钟源选项（Main Clock Source）中选择经过PLL处理的时钟源，并设置主时钟和核心时钟的分频率为 1/2即可。</p>\n<p>从旁边也可以看到自动计算出来的分频系数：<img src=\"https://pic.islet.space/2021/05/image-20210513100800163.png\" alt=\"image-20210513100800163\" /></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210513100908671.png\" alt=\"image-20210513100908671\" /><figcaption aria-hidden=\"true\">image-20210513100908671</figcaption>\n</figure>\n<p>除了可以直接应用 SigmaStudio 的 <code>load parameters</code> 直接进行参数计算外，可以参考《在linux上编写求解ADAU1772的PLL系数》文章，自行系数计算。</p>\n<h2 id=\"exp3\">EXP3</h2>\n<p>本例中主要完成TWI代码的编写，具体可以参见《I2C通信》笔记。以下是一开始的开发思路：</p>\n<p>利用ADI官方提供（导出）的C代码，通过I2C协议向ADAU1772 codec芯片写入寄存器值，在ADAU寄存器写入的C代码中，依赖头文件<code>&lt;SigmaStudioFW.h&gt;</code>，其所有宏定义类型的函数都需要用户自行定义。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210520095649.png\" alt=\"image-20210520095648245\" /><figcaption aria-hidden=\"true\">image-20210520095648245</figcaption>\n</figure>\n<h3 id=\"arduino示例\">Arduino示例</h3>\n<p>在Github上的 <strong><a href=\"https://github.com/ColeMahlowitz/ADAU1761-Self-Boot-With-Arduino\">ADAU1761-Self-Boot-With-Arduino</a></strong> 中，适用于 Arduino 和 ADAU1761 的寄存器块（WRITE_REGISTER_BLOCK）定义实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void SIGMA_WRITE_REGISTER_BLOCK(byte IC_address, word subAddress, int dataLength, byte pdata[]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; start I2C transfer</span><br><span class=\"line\">  if (!i2c_start((IC_address)|I2C_WRITE)) &#123; </span><br><span class=\"line\">    Serial.println(&quot;I2C device busy for WRITE REGISTER BLOCK&quot;);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; write subAddresses. (ADAU1761 needs the 16 bit subAddress written as two 8 bit bytes with an &quot;ACK&quot; inbetween</span><br><span class=\"line\">  uint8_t addressLowByte &#x3D; subAddress &amp; 0xff;</span><br><span class=\"line\">  uint8_t addressHighByte &#x3D; (subAddress &gt;&gt; 8);</span><br><span class=\"line\"></span><br><span class=\"line\">  i2c_write(addressHighByte); </span><br><span class=\"line\">  i2c_write(addressLowByte); </span><br><span class=\"line\"></span><br><span class=\"line\">  if (dataLength &lt; 50 ) &#123;</span><br><span class=\"line\">    for (int i&#x3D;0; i&lt;dataLength; i++) &#123; </span><br><span class=\"line\">      i2c_write(pdata[i]); &#x2F;&#x2F;write data bytes</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  else &#123; </span><br><span class=\"line\">    for (int i&#x3D;0; i&lt;dataLength; i++) &#123;</span><br><span class=\"line\">      i2c_write(pgm_read_byte_near(pdata + i)); &#x2F;&#x2F;write data bytes from PROGMEM (for param and program data)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  i2c_stop(); &#x2F;&#x2F; stop the I2C communication</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在MBED网站中，大量往右对ADAU1701的 <code>&lt;SigmaStudioFW.h&gt;</code> 提供了支持，原网页如：<a href=\"https://os.mbed.com/forum/electronics/topic/4784/\">ADAU1701</a></p>\n<p>将宏定义改为函数形式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SIGMA_WRITE_REGISTER_BLOCK</span><span class=\"params\">(<span class=\"keyword\">int</span> devAddress, <span class=\"keyword\">int</span> address, <span class=\"keyword\">int</span> length, ADI_REG_TYPE *pData )</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ii = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> zz = <span class=\"number\">0</span>;</span><br><span class=\"line\">    Tx_Idx = <span class=\"number\">0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">/*----- Transmission Phase -----*/</span></span><br><span class=\"line\">    ThisBufferSize = Address_Length + length; </span><br><span class=\"line\"> </span><br><span class=\"line\">    I2C1_Buffer_Tx[<span class=\"number\">0</span>] =   (address &amp; <span class=\"number\">0xFF00</span>)&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">    I2C1_Buffer_Tx[<span class=\"number\">1</span>] =   address &amp; <span class=\"number\">0x00FF</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(zz=<span class=\"number\">0</span>;zz&lt;length;zz++)&#123;</span><br><span class=\"line\">    \tI2C1_Buffer_Tx [zz + Address_Length] =   pData[zz];</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    Tx_Idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ii =<span class=\"number\">0</span>;ii &lt; ThisBufferSize;ii++)&#123;    </span><br><span class=\"line\">        NextBufferEnd =  ThisBufferSize;<span class=\"comment\">//I2C1_numbytes[ii];    </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ii == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            I2C_GenerateSTART(I2C1, ENABLE);</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"comment\">/* Send data */</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(Tx_Idx &lt; NextBufferEnd)   </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SIGMA_WRITE_DELAY</span><span class=\"params\">(<span class=\"keyword\">int</span> devAddress, <span class=\"keyword\">int</span> length, ADI_REG_TYPE *pData )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nCount=<span class=\"number\">0</span>;</span><br><span class=\"line\">    nCount=<span class=\"number\">0xFFFFF</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(; nCount != <span class=\"number\">0</span>; nCount--);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体的代码已经贴在《I2C通信》了，21478和21479支持TWI的寄存器控制，但是更为复杂，官方没有给示例，因此使用了引脚高低高低电平的控制来实现通信。</p>\n<h3 id=\"数字逻辑分析仪\">数字逻辑分析仪</h3>\n<p>在EXP3中会频繁采集I2C、I2S、SPI等通信协议发过来的数据，因此需要使用数字逻辑分析仪进行数据采集和分析，在本次开发过程中使用了两种数字逻辑分析仪，分别是 <strong><em>USBee Suite</em></strong> 和 <strong><em>Saleae Logic</em></strong> ，推荐使用后者，软件更夹稳定、成熟和易使用。如果采用前者，那么软件经常崩溃。后者在采集I2S等高速通信协议中的电平信号时，需要将采样速率提升一下，24MS/s 的速度仍然能会采样变形。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210623161904.png\" alt=\"image-20210623134058687\" /><figcaption aria-hidden=\"true\">image-20210623134058687</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210623161909.png\" alt=\"image-20210623134114244\" /><figcaption aria-hidden=\"true\">image-20210623134114244</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210623161911.png\" alt=\"image-20210623133953887\" /><figcaption aria-hidden=\"true\">image-20210623133953887</figcaption>\n</figure>\n<p>​</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210623161914.png\" alt=\"image-20210623134006076\" /><figcaption aria-hidden=\"true\">image-20210623134006076</figcaption>\n</figure>\n","categories":["Hardware"],"tags":["ADI"]},{"title":"ADSP21479 寄存器解读","url":"/2021/05/25/Hardware/DSP/2021-05-25-ADSP21479%20%E5%AF%84%E5%AD%98%E5%99%A8%E8%A7%A3%E8%AF%BB/","content":"<p>以下所有对寄存器的描述均来自于《ADSP-214xx SHARC Processor Hardware Reference》，后简称《HWR》。</p>\n<p>本笔记主要是针对芯片 ADSP21479 寄存器（PLL、SDRAM、SRU、中断等）进行总结和记录。</p>\n<p>[TOC]</p>\n<h1 id=\"register-preview\">Register Preview</h1>\n<h2 id=\"位类型和操作\">位类型和操作</h2>\n<p>许多寄存器旁边都会标注位类型和操作方法，位类型包括 可读可写（RW）、只读（RO）、只读清除（ROC）、只写清除（WOC）、可读可写1清除（RW1C）、 可读可写1设置（RW1S）。</p>\n<p><img src=\"https://pic.islet.space/2021/05/20210528141056.png\" alt=\"image-20210528134312811\" style=\"zoom: 80%;\" /></p>\n<p><strong>注意</strong>：<mark>不要尝试去写入这些 <strong><em>reversed位</em></strong> ，读取的值就会使这些位上的值进行更新或者复位。</mark></p>\n<p><img src=\"https://pic.islet.space/2021/05/20210528141255.png\" alt=\"image-20210528134457084\" style=\"zoom:67%;\" /></p>\n<h2 id=\"头文件-外围设备及寄存器宏定义\">头文件-外围设备及寄存器宏定义</h2>\n<p><code>&lt;def21479.h&gt;</code> 是关于 <strong>外围设备</strong>（peripherals）和 <strong>寄存器</strong>（registers）的子集。</p>\n<p><code>&lt;cdef21479.h&gt;</code> 包含了对IOP寄存器的宏定义，对C/C++可用。所有定义均和 <code>&lt;def21479.h&gt;</code> 一致，除了以 <code>p</code> 作为前缀的宏定义 和 （relevant casts）以外，它们的用法如 <code>*pSYSTAT = 0x12345678;</code>。</p>\n<p>《HWR》仅有第99页中提及了这两份文件。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210602171620.png\" alt=\"image-20210602171608976\" /><figcaption aria-hidden=\"true\">image-20210602171608976</figcaption>\n</figure>\n<h3 id=\"def21479.h\">DEF21479.H</h3>\n<ul>\n<li><p>外部接口IOP寄存器（IOP registers for External Port）、SDRAM控制寄存器、AMI寄存器、DMA地址寄存器、SPORT（SP0~SP7）（包含串行接口寄存器、多通道发送接收（Multichannel tx/rx）、SPORT计数寄存器、错误中断控制寄存器、控制寄存器、多通道选择（Multichannel select））、SPI和SPIB寄存器、定时器寄存器、POWER MGT寄存器、外围设备中断优先级控制寄存器（Peripheral interrupt priority control register）、DAI寄存器（DAI参数寄存器、边缘中断锁存寄存器、中断优先级寄存器、（shadow）高/低优先级中断锁存寄存器、DAI状态寄存器、DAI针脚缓存状态寄存器、）、SRU寄存器（包括SRU时钟控制寄存器、数据控制寄存器、FS控制寄存器、针脚控制寄存器、外部Misc.A/B控制寄存器、针脚使能寄存器、shift寄存器的时钟控制和数据控制）、精度时钟控制寄存器（Precision Clock A/B Control Register 0/1）（包括脉冲宽度控制、幅度同步、脉冲宽度控制）、MTM寄存器、PWM寄存器、UART寄存器、TWI寄存器、FIR加速寄存器、IIR加速寄存器、FFT加速寄存器、MLB设备寄存器、WDT寄存器、Shift寄存器、RTC寄存器。</p></li>\n<li><p>DPI、DTCP模块</p></li>\n</ul>\n<hr />\n<ul>\n<li><p>系统寄存器位定义（MODE1和MMASK寄存器、MODE2寄存器、ASTAT、STKYx和STKYy寄存器、IRPTL寄存器、IMASK寄存器、IMASKP寄存器、LIRPTL寄存器、FLAGS寄存器）</p></li>\n<li><p>IOP控制/状态寄存器位定义（EEMUSTAT寄存器、RUNRSTCTL寄存器、SYSCTL寄存器、BRKCTL寄存器、REVPID、SDCTL寄存器位、SDRRC（SDRAM刷新速率控制）寄存器、SDSTAT（SDRAM状态）寄存器、SDSTAT（SDRAM状态）寄存器2、EPCTL寄存器位）</p></li>\n<li><p>AMICTL寄存器位（DMAC寄存器控制位、SPICTL寄存器、SPISTAT寄存器、SPCTL（0~5、N0~N7）寄存器、GP计时器状态寄存器、GP计时器控制寄存器、电源管理控制寄存器、外部时钟管理控制寄存器、DAI中断锁存寄存器、IDP控制寄存器、IDP PDAP控制寄存器、DAI针脚缓存状态寄存器（0~19）、DAI状态寄存器、DPI针脚缓存状态寄存器（0~13）、DPI中断锁存寄存器）</p></li>\n<li><p>精度时钟控制寄存器（A0、A1、B0、B1、C0、C1、D0、D1）、精度时钟脉冲宽度控制寄存器、精度时钟幅度同步、精度时钟脉冲宽度控制寄存器</p></li>\n<li><p>优先级中断控制（Priority Interrupt Control）寄存器（可编程中断（Programmable Interrupt）寄存器位）</p></li>\n<li><p>PWM全局控制寄存器、PWM全局状态寄存器、PWM控制寄存器、PWM状态寄存器、PWM输出禁用、PWM调试状态、PWM极性选择寄存器（Polarity Select Register）</p></li>\n<li><p>TWI寄存器、主设备内部时钟寄存器（TWIMITR）、TWI从设备控制寄存器（TWISCTL）、TWI从设备状态寄存器（TWISSTAT）、TWI主设备控制寄存器（TWIMCTL）、TWI主设备状态寄存器（TWIMSTAT）、TWI中断控制寄存器（TWIIMASK/TWIIRPTL）、TWI先进先出控制寄存器（TWIFIFOCTL）、TWI先进先出状态寄存器（TWIFIFOSTAT）</p></li>\n<li><p>UART寄存器、UARTIIR、UARTLCR、UARTMODE、UARTLSR、UARTTXCTL/RXCTL、UARTTXSTAT/RXSTAT</p></li>\n<li><p>SPDIF传输寄存器、SPDIF通道状态寄存器、SPDIF用户位状态寄存器、SPDIF接收器寄存器、SPDIF传输控制寄存器、SPDIF TX输入数据格式、SPDIF接收控制寄存器、SPDIF接收状态（只读）</p></li>\n<li><p>采样率转换控制寄存器（0~3）、输入数据格式、输出数据格式、SRC频应复元（Deemphasis）设置、彩艳率转换率（0~3）、采样率转换静音（MUTE）寄存器（SRCMUTE）</p></li>\n<li><p>FIR加速器、IIR加速器、FFT加速器</p></li>\n<li><p>MLB位定义（DCCR/SSCR/SMCR/IBCR/CECR/CSCR）、WDT寄存器位定义、Shift寄存器位定义、RTC寄存器位定义（控制、初始化、状态、初始化状态）</p></li>\n</ul>\n<h3 id=\"cdef21479.h\">CDEF21479.H</h3>\n<ul>\n<li>仿真、断点寄存器</li>\n<li>外部接口的IOP寄存器</li>\n<li>SDRAM控制寄存器</li>\n<li>AMI的IOP寄存器</li>\n<li>DAM地址寄存器</li>\n<li>SPORT（0~7）（串行接口寄存器、MT/MR寄存器、TDM寄存器、）</li>\n<li>SPI寄存器、SPIB寄存器（通过DAI进行路由）</li>\n<li>计时器寄存器</li>\n<li>电源管理寄存器</li>\n<li>外围中断优先级控制寄存器</li>\n<li>DAI寄存器（DMA参数寄存器、SRU寄存器、采样率转换寄存器）</li>\n<li>DPI寄存器</li>\n<li>DTCP模块</li>\n<li>SPDIF传输寄存器（通道状态缓存、用户位缓存、SPDIF接收寄存器）</li>\n<li>PCG精度时钟控制寄存器</li>\n<li>MTM（Memory to Memory）寄存器</li>\n<li>PWM脉冲调制寄存器</li>\n<li>UART寄存器</li>\n<li>TWI寄存器</li>\n<li>FIR加速寄存器</li>\n<li>IIR加速寄存器</li>\n<li>FFT加速寄存器</li>\n<li>MLB设备寄存器</li>\n<li>WDT寄存器</li>\n<li>Shift寄存器</li>\n<li>RTC寄存器</li>\n</ul>\n<p>在《HWR》“自己眼”中，可能自己就这么点儿寄存器。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210529114430.png\" alt=\"image-20210528140017190\" /><figcaption aria-hidden=\"true\">image-20210528140017190</figcaption>\n</figure>\n<h1 id=\"reset-register\">Reset Register</h1>\n<p><strong><em>RUNRSTCTL</em></strong>，运行中复位控制寄存器（Running Reset Control Register）。</p>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n表A-5 RUNRSTCTL寄存器位功能描述\n</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210527170843.png\" alt=\"image-20210527170816951\" /><figcaption aria-hidden=\"true\">image-20210527170816951</figcaption>\n</figure>\n<h1 id=\"可编程中断优先级控制寄存器\">可编程中断优先级控制寄存器</h1>\n<ul>\n<li><p>supports 19 programmable prioritized interrupts</p></li>\n<li><p>任何外部中断输出都可能被连接至任何可编程优先级中断输入。</p></li>\n</ul>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n表A-6 默认中断路由\n</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210527171222.png\" alt=\"image-20210527171119962\" /><figcaption aria-hidden=\"true\">image-20210527171119962</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210527171224.png\" alt=\"image-20210527171204914\" /><figcaption aria-hidden=\"true\">image-20210527171204914</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210527171227.png\" alt=\"image-20210527171219793\" /><figcaption aria-hidden=\"true\">image-20210527171219793</figcaption>\n</figure>\n<h1 id=\"目标信号控制寄存器\">目标信号控制寄存器</h1>\n<p>本寄存器控制了：</p>\n<ul>\n<li><p>programmable priority interrupts</p></li>\n<li><p>default interrupt sources</p></li>\n</ul>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210527172018.png\" alt=\"image-20210527171809869\" /><figcaption aria-hidden=\"true\">image-20210527171809869</figcaption>\n</figure>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n图 A-4 PICR0 寄存器\n</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210527172024.png\" alt=\"image-20210527171824344\" /><figcaption aria-hidden=\"true\">image-20210527171824344</figcaption>\n</figure>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n图 A-5 PICR1 寄存器\n</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210527172027.png\" alt=\"image-20210527171841316\" /><figcaption aria-hidden=\"true\">image-20210527171841316</figcaption>\n</figure>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n图 A-6 PICR2 寄存器\n</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210527172029.png\" alt=\"image-20210527171852287\" /><figcaption aria-hidden=\"true\">image-20210527171852287</figcaption>\n</figure>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n图 A-7 PICR3 寄存器\n</p>\n<h1 id=\"twi-in-master-tx\">TWI IN MASTER-TX</h1>\n<p><strong>Peripherals with Multiple Interrupt Request Signals</strong></p>\n<blockquote>\n<p>TWI和UART有分离的中断输出。两者都默认连接至P14I（DPI）。然而，两者都允许分离连接至默认不路由的PICR，反而提供了更多可通过DAI/DPI中断优先级更改的混合模型。</p>\n<p>The TWI and the UART have separate interrupt outputs. Both peripherals are already connected via the P14I (DPI) by default. However both peripherals allow separate connectivity into the PICR that are not routed by default. This provides more flexibility for priority change across the DAI/DPI interrupts.</p>\n</blockquote>\n<h2 id=\"twi-register\">TWI Register</h2>\n<p>《HWR》第1193页起定义了TWI的寄存器。第1244页同样给了TWI相关的寄存器一个列表。</p>\n<p><img src=\"https://pic.islet.space/2021/05/20210528140307.png\" alt=\"image-20210528140209933\" style=\"zoom:67%;\" /></p>\n<p><code>&lt;cdef21479.h&gt;</code> 对TWI相关的寄存器定义如下，p为前缀的定义是该寄存器的地址位，通过与<code>&lt;def21479.h&gt;</code> 的定义进行 <code>或</code> 运算并赋值给对应的寄存器地址进行控制，如 <code>*pTWIMITR = (0x14) | TWIEN;</code> 。</p>\n<p>TWI中所有的Status相关寄存器都是 “只读” 状态，其《位描述》表上都有一个 <code>RO</code> 标志。</p>\n<p><img src=\"https://pic.islet.space/2021/05/20210527095059.png\" alt=\"image-20210527095053483\" style=\"zoom:80%;\" /></p>\n<p>在VisualDSP++这款IDE中，也可以通过 直接观察到所有TWI的寄存器值。</p>\n<p><img src=\"https://pic.islet.space/2021/06/20210607103819.png\" alt=\"image-20210607103816755\" style=\"zoom:80%;\" /> <img src=\"https://pic.islet.space/2021/06/20210607103750.png\" alt=\"image-20210607103747655\" /></p>\n<h3 id=\"twimitr\">TWIMITR</h3>\n<p>TWIMITR（<strong>Master Internal Time Register</strong>），即主机内部时间寄存器（如图A-143所示，并在表A-129中描述）。</p>\n<ul>\n<li>用于启用TWI模块，以及建立外围时钟（PCLK）和TWI控制器内部定时事件之间的关系。\n<ul>\n<li>内部时间参考是从PCLK得出的，使用的是预标定值。<code>PRESCALE = fPCLK / 10 MHz</code></li>\n</ul></li>\n</ul>\n<blockquote>\n<p>The internal time reference is <strong><em>derived from PCLK</em></strong> using the prescaled value shown below.</p>\n<p><code>PRESCALE = fPCLK/10 MHz</code></p>\n</blockquote>\n<p><img src=\"https://pic.islet.space/2021/05/20210525135455.png\" alt=\"image-20210525133555377\" style=\"zoom: 67%;\" /></p>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n图 A-143 TWIMITR 寄存器\n</p>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n表A-129 寄存器位功能描述\n</p>\n<table>\n<colgroup>\n<col style=\"width: 5%\" />\n<col style=\"width: 11%\" />\n<col style=\"width: 83%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>BITS</th>\n<th>NAME</th>\n<th>DESCRIPTION</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>6-0</td>\n<td>PRESCALE</td>\n<td><strong>预分频</strong><br>用于生成一个内部时间参考的外围时钟（PCLK）周期数。<br>必须设置PRESCALE的值，以创建一个周期为10MHz的内部时间参考。这表示为一个7位的二进制值。</td>\n</tr>\n<tr class=\"even\">\n<td>7</td>\n<td>TWIEN</td>\n<td><strong>TWI使能</strong><br>该位必须设置为从属或主模式操作。<br>建议在初始化PRESCALE时设置该位，并保持设置，以确保总线繁忙检测逻辑的精确运行。<br/>- 0 = 禁用TWI<br/>- 1 = 启用TWI主、从模式操作。<mark>如果该位从高电平过渡到低电平，缓冲器将被刷新，需要2个时钟周期。</mark></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"twidiv\">TWIDIV</h3>\n<p>在主模式运行期间，跟SCL相关的TWIDIV（<strong>Clock Divider Register</strong>），即时钟分频器寄存器（如图A-144所示，并在表A-130中描述）。</p>\n<ul>\n<li>被用来创建串行时钟（SCL）的 <strong>高</strong> 和 <strong>低</strong> 持续时间。</li>\n<li>串行时钟的频率可以从400KHz到小于20KHz不等。产生的时钟分辨率为1/10 MHz或100 ns。</li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/05/20210525135457.png\" alt=\"image-20210525134728762\" style=\"zoom: 67%;\" /></p>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n图 A-144 TWIDIV 寄存器\n</p>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n表A-130 TWIDIV 寄存器位功能描述\n</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>BITS</th>\n<th>NAME</th>\n<th>DESCRIPTION</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>7-0</td>\n<td>CLKLOW</td>\n<td>时钟低电平<br>该时间映射了串行时间低电平的周期。<br>以8位二进制数表示。</td>\n</tr>\n<tr class=\"even\">\n<td>15-8</td>\n<td>CLKHI</td>\n<td>时钟高电平<br>该时间映射了串行时钟在等到一个新时钟低电平到来之前的持续时间。<br>以8位二进制数表示。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"twimctl\">TWIMCTL</h3>\n<p>TWIMCTL（Master Control Register），即TWI主机控制寄存器。</p>\n<ul>\n<li>控制了控制与主机模式操作相关的逻辑。</li>\n<li>该寄存器内的操作不会影响到从寄设备的操作；且不应该被修改以控制从属模式的功能。</li>\n</ul>\n<blockquote>\n<p>The TWI master mode control register controls the logic associated with master mode operation.</p>\n<p>Bits in this register do not affect slave mode operation and should not be modified to control slave mode functionality.</p>\n</blockquote>\n<p><img src=\"https://pic.islet.space/2021/05/20210525143535.png\" alt=\"image-20210525140532502\" style=\"zoom: 67%;\" /></p>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n图 A-145 TWIMCTL 寄存器\n</p>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n表A-131 TWIMCTL 寄存器位功能描述\n</p>\n<p><img src=\"https://pic.islet.space/2021/05/20210525143532.png\" alt=\"image-20210525143454398\" style=\"zoom: 67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/05/20210525143531.png\" alt=\"image-20210525143529519\" style=\"zoom: 67%;\" /></p>\n<h3 id=\"twimaddr\">TWIMADDR</h3>\n<p>在传输的寻址阶段中，TWI控制器的主机使能，并传输TWI主机模式地址寄存器中的内容。</p>\n<p>在对本寄存器进行编程时，忽略读/写位。只有从机地址的前7位（6-0）会被写入本寄存器。</p>\n<p>例如：从机的地址是 <code>1010 000x</code> ，则本寄存器的写入内容则是 <code>1010 000</code>（16进制的 <code>0x50</code> ）。<mark>将该地址发送至总线时，TWI控制器根据 主机控制寄存器上TWIMDIR 位来决定对从机的读写。</mark></p>\n<blockquote>\n<p>During the addressing phase of a transfer, the TWI controller, with its master enabled, transmits the contents of the TWI master mode address register. When programming this register, omit the read/write bit. That is, only the upper 7 bits that make up the slave address should be written to this register. For example, if the slave address is 1010000X, then TWIMADDR is programmed with 1010000, which corresponds to 0x50. When sending out the address on the bus, the TWI controller appends the read/write bit as appropriate, based on the state of the TWIMDIR bit in the master mode control register.</p>\n</blockquote>\n<p><img src=\"https://pic.islet.space/2021/05/20210525143542.png\" alt=\"image-20210525140743855\" style=\"zoom: 67%;\" /></p>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n图 A-146 TWIMADDR 寄存器\n</p>\n<h3 id=\"twimstat\">TWIMSTAT</h3>\n<ul>\n<li>Not directly associated with the generation of interrupts but offer information on the current transfer.</li>\n<li>Slave mode operation does not affect master mode status bits.</li>\n</ul>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210603153454.png\" alt=\"image-20210603153452903\" /><figcaption aria-hidden=\"true\">image-20210603153452903</figcaption>\n</figure>\n<p>如果TWIMSTAT寄存器中的第2位是1</p>\n<p><img src=\"https://pic.islet.space/2021/06/20210603153720.png\" alt=\"image-20210603153655529\" style=\"zoom:80%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/06/20210603153724.png\" alt=\"image-20210603153719024\" style=\"zoom:80%;\" /></p>\n<h3 id=\"twififoctl\">TWIFIFOCTL</h3>\n<p>TWIFIFOCTL（<strong>FIFO Control Register</strong>），即先进先出控制寄存器，只控制FIFO，<mark>完全不与主机模式 或 从机模式操作绑定。</mark></p>\n<p><img src=\"https://pic.islet.space/2021/05/20210525144902.png\" alt=\"image-20210525144403383\" style=\"zoom: 67%;\" /></p>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n图 A-151 TWIFIFOCTL 寄存器\n</p>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n表A-135 TWIFIFOCTL 寄存器位功能描述\n</p>\n<p><img src=\"https://pic.islet.space/2021/05/20210525144904.png\" alt=\"image-20210525144738016\" style=\"zoom:67%;\" /></p>\n<h3 id=\"twififostat\">TWIFIFOSTAT</h3>\n<ul>\n<li>指示FIFO缓冲区的接收和发送内容的状态。</li>\n<li>FIFO缓冲器不区分主数据和从数据。</li>\n<li>可以对FIFO进行管理，允许同时进行主、从操作。</li>\n</ul>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210603152241.png\" alt=\"image-20210603152156841\" /><figcaption aria-hidden=\"true\">image-20210603152156841</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210603152239.png\" alt=\"image-20210603152211766\" /><figcaption aria-hidden=\"true\">image-20210603152211766</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210603152242.png\" alt=\"image-20210603152235432\" /><figcaption aria-hidden=\"true\">image-20210603152235432</figcaption>\n</figure>\n<blockquote>\n<p><strong>TWITXS</strong>: 传输FIFO状态。</p>\n<p>这些只读位表示FIFO缓冲器中有效数据字节的数量。该状态在每次使用外围数据总线写入FIFO缓冲区或通过传输移位寄存器读取时被更新。</p>\n<p>在每次使用外设数据总线写FIFO缓冲区或通过传输移位寄存器读访问时更新。允许同时访问。</p>\n<ul>\n<li>00 = FIFO是空的。无论是单字节还是双字节的FIFO外设写入都会立即通过。</li>\n<li>01 = FIFO包含一个字节的数据。对FIFO的单字节外围写立即通过。一个双字节的外设写入要等到FIFO为空时才进行。</li>\n<li>11 = FIFO已满，包含两个字节的数据。</li>\n<li>10 = 保留</li>\n</ul>\n</blockquote>\n<h3 id=\"twiirptl\">TWIIRPTL</h3>\n<p>TWIIRPTL（TWI interrupt sources register），即TWI中断源寄存器。</p>\n<ul>\n<li><p>包含了有关 <em>functional areas requiring servicing</em> 的信息。</p></li>\n<li><p>大量的比特被当做鉴定器/指示器来使用，主要用于 <em>further read</em> 以及 为 不同的状态寄存器提供服务（service various status register）。</p></li>\n<li><p>在维护了与位绑定的中断源后，用户需要清除该中断源位。</p></li>\n<li><p>所有的位都是粘性的 （sticky）和 <strong><em>RW1C</em></strong>。</p></li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/05/20210525163021.png\" alt=\"image-20210525163016113\" style=\"zoom: 50%;\" /></p>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n图 A-1534 TWIIRPTL 寄存器\n</p>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n表A-137 TWIIRPTL 寄存器位功能描述\n</p>\n<p><img src=\"https://pic.islet.space/2021/05/20210525164025.png\" alt=\"image-20210525163933340\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/05/20210525164028.png\" alt=\"image-20210525163959598\" style=\"zoom:67%;\" /></p>\n<h4 id=\"twitxint\">TWITXINT</h4>\n<p>首先要搞清楚，这个TWITXINT 是寄存器还是寄存器位，如果是寄存器位，哪它来自于哪个寄存器呢。目前已知包含TWITXINT的寄存器有：<code>TWIIRPTL</code> 、 <code>TWIIMASK</code> 、 <code>TWIFIFOCTL</code>(TWITXINT<strong><em>2</em></strong>)</p>\n<blockquote>\n<p>在TWIIRPT寄存器中的TWITXINT寄存器位：</p>\n<p>发送FIFO服务。</p>\n<p>如果 TWIFIFOCTL 寄存器中的 <code>XMTINTLEN2</code> 为 0，则每次 TWIFOSTAT 寄存器中的 TWITXS 字段被更新为 01 或 00 时，该位都被设置。</p>\n<p>如果 <code>XMTINTLEN</code> 为 1，则每次 TWITXS 被更新为 00 时，该位都被设置。</p>\n<p>1 = 发送 FIFO 缓冲区有一个或两个 8 位位置可供写入。</p>\n<p>0 = FIFO不需要服务或TWITXS字段在该位最后被清除后没有变化。</p>\n</blockquote>\n<h5 id=\"twitxint-interrupt\">TWITXINT interrupt</h5>\n<blockquote>\n<p>This interrupt is generated when there is one or two bytes of empty space in the FIFO. Simple data handling is all that is required.</p>\n</blockquote>\n<h3 id=\"twiimask\">TWIIMASK</h3>\n<p>TWIIMARK （<strong>TWI Interrupt mask register</strong>），即TWI中断<strong><em>隐藏</em></strong>寄存器。</p>\n<ul>\n<li>使能中断源（interrupt sources）插入中断输出（Interrupt output）</li>\n<li>每一个<strong>使能位</strong>（enable bit）都会与 <strong>TWI中断延迟寄存器</strong>（TWIIRPTL，即TWI interrupt latch register）一个<strong>中断延迟位</strong>（interrupt latch bit）通信。</li>\n<li>对TWIIMASK寄存器的读写不会影响 TWIIRPTL 寄存器的内容。</li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/05/20210525164217.png\" alt=\"image-20210525145706357\" style=\"zoom: 67%;\" /></p>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n图 A-154 TWIIMASK 寄存器\n</p>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n表A-138 TWIIMASK 寄存器位功能描述\n</p>\n<p><img src=\"https://pic.islet.space/2021/05/20210525150124.png\" alt=\"image-20210525150058029\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/05/20210525164016.png\" alt=\"image-20210525150122857\" style=\"zoom:67%;\" /></p>\n<h3 id=\"txtwi8\">TXTWI8</h3>\n<p>8位传输用FIFO寄存器（TWI 8-bit transmit FIFO register），做数据缓存之用。</p>\n<ul>\n<li>存储数据以“先进先出”的顺序进入通信传输缓存。</li>\n<li>尽管外围总线写入带宽是32位，但是只有一个字节会被写入8位的 <strong><em>TXTWI8</em></strong>。</li>\n<li>伴随着每一次数据写入，<strong>TWIFIFOSTAT</strong> 寄存器中的 <strong>TWITXS</strong> 传输状态位都会被更新。</li>\n<li>当FIFO缓存存满时，仍有数据需要写入的话，核心就会让数据等着，直到转运缓存（TRANSMIT FIFO BUFFER）由至少一个字节的空间时才能完成写入操作。</li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/05/20210525161210.png\" alt=\"image-20210525155309392\" style=\"zoom:67%;\" /></p>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n图 22-7 8位传输FIFO寄存器\n</p>\n<p><img src=\"https://pic.islet.space/2021/05/20210527133602.png\" alt=\"image-20210527114613231\" style=\"zoom:67%;\" /></p>\n<h3 id=\"例程\">例程</h3>\n<h4 id=\"主寄存器初始化函数\">主寄存器初始化函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">ADAU1772_1_ADDR = <span class=\"number\">0X3C</span>;  <span class=\"comment\">//第一个从设备的地址是0x3C，其ADDR1和ADDR0引脚均为0；</span></span><br><span class=\"line\">ADAU1772_2_ADDR = <span class=\"number\">0X3D</span>;  <span class=\"comment\">//第一个从设备的地址是0x3D，其ADDR1和ADDR0引脚为0和1；</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Master_TWI_Init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 预分频为 fPCLK/10 MHz</span></span><br><span class=\"line\">\t*pTWIMITR = (<span class=\"number\">0x14</span>) | TWIEN;  <span class=\"comment\">//0x14和0x80进行 位或操作，将结果148写入TWI主机时间寄存器中</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// CLKDIV = TWI SCL period ? 10 MHz time reference</span></span><br><span class=\"line\">\t<span class=\"comment\">// CLKDIV = (1/100 KHz) / 100 ns = 100</span></span><br><span class=\"line\">\t<span class=\"comment\">// For 40 - 60 duty cycle, CLKHI = 40 and CLKLOW = 60</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t*pTWIDIV = (CLKHI &lt;&lt; <span class=\"number\">8</span>) | CLKLOW;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 需要被访问的从设备的地址</span></span><br><span class=\"line\">\t*pTWIMADDR = ADAU1772_1_ADDR; </span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 传送至从属设备的第一个字节数据</span></span><br><span class=\"line\">\t*pTXTWI8 = <span class=\"number\">0x00</span>;</span><br><span class=\"line\">    *pTXTWI8 = <span class=\"number\">0x85</span>; <span class=\"comment\">//(0101 0101b)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*  // 配置TWIFIFOCTL寄存器，为每个数据字节(byte)生成中断</span></span><br><span class=\"line\"><span class=\"comment\">\t*pTWIFIFOCTL = TWITXFLUSH | TWIRXFLUSH;</span></span><br><span class=\"line\"><span class=\"comment\">\t*pTWIFIFOCTL = 0;</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span>  <span class=\"comment\">//暂时禁用该数据写入寄存器配置（包括中断和写入读取规则等）</span></span><br><span class=\"line\">    *pTWIFIFOCTL = <span class=\"number\">0x15</span>;  <span class=\"comment\">//即（0 1111b），详细配置信息请参照《ADSP-214xx SHARC Processor Hardware Reference》</span></span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"comment\">// 中断使能位，上方已经写过了，有些重复</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> INTERRUPT_MODE</span></span><br><span class=\"line\">\t*pTWIIMASK |= TWITXINT;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 打开TWI的控制寄存器</span></span><br><span class=\"line\">\t*pTWIMCTL = (N &lt;&lt; <span class=\"number\">6</span>);  <span class=\"comment\">//？？</span></span><br><span class=\"line\">\t*pTWIMCTL |= TWIMEN;  <span class=\"comment\">// 打开主机模式（Master Mode enable）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"特性-features\">特性 Features</h2>\n<p>《HWR》第855页起对TWI进行了描述。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210603140236.png\" alt=\"image-20210603140215469\" /><figcaption aria-hidden=\"true\">image-20210603140215469</figcaption>\n</figure>\n<ul>\n<li>需要使用DPI进行针脚信号的路由，不能使用DAI</li>\n<li>支持主从模式</li>\n<li>支持数据缓存接入和核心数据接入，不支持DMA</li>\n<li>最大时钟频率400KHz</li>\n<li>7-bit 寻址</li>\n<li>支持多播主机仲裁</li>\n<li>主时钟同步和时钟低延伸支持</li>\n<li>低中断速率</li>\n<li>分离多字节接收和传输的FIFOs</li>\n<li>在总线锁死时，对数据和时钟线的独立复写控制</li>\n<li>峰值抑制的输入滤波器</li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/05/20210527100924.png\" alt=\"image-20210527100834503\" style=\"zoom: 67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/05/20210527133611.png\" alt=\"image-20210527100951355\" style=\"zoom:67%;\" /></p>\n<h2 id=\"针脚描述-pin-descriptions\">针脚描述 Pin Descriptions</h2>\n<p><img src=\"https://pic.islet.space/2021/05/20210527102109.png\" alt=\"image-20210527101956389\" style=\"zoom:67%;\" /></p>\n<h2 id=\"sru编程-sru-programming\">SRU编程 SRU Programming</h2>\n<p>TWI信号可以通过 <code>SRU2</code> ，如表22-3所示进行路由。</p>\n<p><img src=\"https://pic.islet.space/2021/05/20210527102114.png\" alt=\"image-20210527102029529\" style=\"zoom:67%;\" /></p>\n<blockquote>\n<p>Identify the peripherals that you are trying to connect to the SHARC DSP, and count the unique signals. List the unique I/O signals and look carefully to see what else you may be able to eliminate.</p>\n<ul>\n<li><p>如果时钟或帧同步连接至多个设备，算作一个信号。If the same <strong><em>clock</em></strong> or <strong><em>frame</em></strong> sync is connected to multiple devices, it counts as one signal.</p></li>\n<li><p>如果与一个串行数据流驱动多个设备，也算作一个信号。When a <strong><em>serial data stream</em></strong> drives multiple output devices, it also counts as a single signal.</p></li>\n<li><p>如果两个信号相同，但极性相反（倒置），算作一个信号。（因为SRU可以从另一个信号中产生任何一个）</p></li>\n<li><p>如果一个时钟信号是另一个时钟信号的相位对齐的整数子倍数，则将它们组合在一起。</p></li>\n</ul>\n<p>大多数引脚缓冲区在给定的设计中只在一个方向上使用。请注意，许多外设都具有能够实现双向操作的引脚，但仅在系统中的一个方向上使用。当针脚缓冲区是单向的时，SRU的编程会大大简化。</p>\n<p>如果针是双向的，确定方向改变的原因。这是另一个别针的状态吗？它是处理器级控制寄存器的状态吗？它是一个端口的软件配置吗？想想当SHARC将逻辑值驱动到双向针上时，以及当针刚刚读取逻辑输入时，可能会控制什么。</p>\n<p><strong><em>注意</em></strong> 下图中的 <code>PBxx_O</code> / <code>PBxx_I</code> / <code>PBENxx_I</code> 。针脚缓冲器就像一个小型缓冲器放大器，可以提供足够的电流来驱动针脚和电路板上的痕迹。打开时（即当其启用输入为逻辑高时），针缓冲输入处的逻辑值被驱动到针缓冲输出上。当关闭时（即，当其启用输入为逻辑低时），缓冲器放大器为高阻抗，并且引脚缓冲器输出的逻辑电平很容易由外部源控制。引脚缓冲区是与DAI相关联的物理IC包引线的逻辑网关。</p>\n<p><img src=\"https://pic.islet.space/2021/06/20210603170450.png\" alt=\"image-20210603170447943\" style=\"zoom: 80%;\" /></p>\n<p>由于引脚缓冲器是一个片上外设，连接到物理封装上的信号被称为引脚缓冲器的输出。虽然它是SHARC的一个输入，但它是引脚缓冲器的一个输出。请注意，图1显示了两个连接的轨迹，它们被标记为 <code>PBxx_O</code>（引脚缓冲器输出）。其中一个是SRU接口的一部分，另一个是外部封装连接引脚。当引脚缓冲器被用作输入时，信号会沿着这个路径。换句话说，SRU内的引脚缓冲器输出总是等于外部引脚的逻辑值。</p>\n<p>——《<em>Configuring the Signal Routing Unit of ADSP-2126x SHARC® DSPs</em>》</p>\n<p><mark>只有DAI有 PBEN ，DPI只有 PB。</mark></p>\n</blockquote>\n<p><em>PAGE 874</em> - <strong><em>SRU PROGRAMMING MODE</em></strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">SRU(LOW, DPI_PBxx_I); <span class=\"comment\">/* input buffer is low */</span></span><br><span class=\"line\">SRU(TWI_DATA_PBEN_O, DPI_PBENxx_I); <span class=\"comment\">/* TWI data output*/</span></span><br><span class=\"line\"><span class=\"comment\">//SRU(DPI_PBxx_O, TWI_DATA_I); /* TWI data input */</span></span><br><span class=\"line\"></span><br><span class=\"line\">SRU2(LOW, DPI_PByy_I); <span class=\"comment\">/* input buffer is low */</span></span><br><span class=\"line\">SRU2(TWI_CLK_PBEN_O, DPI_PBENyy_I); <span class=\"comment\">/* TWI clock output*/</span></span><br><span class=\"line\"><span class=\"comment\">//SRU2(DPI_PByy_O, TWI_CLK_I); /* TWI clock input*/</span></span><br></pre></td></tr></table></figure>\n<p>​</p>\n<h2 id=\"时钟频率-clocking\">时钟频率 Clocking</h2>\n<ul>\n<li>外围时钟（f<sub>PCLK</sub>）是TWI时钟频率的基础。</li>\n<li>串行时钟频率最高400KHz，最低20KHz；其分辨率为 1/10MHz 或 100ns。</li>\n</ul>\n<p>分频数的计算案例如下：</p>\n<p><img src=\"https://pic.islet.space/2021/05/20210527102916.png\" alt=\"image-20210527102754286\" style=\"zoom:67%;\" /></p>\n<h2 id=\"功能描述-functional-description\">功能描述 Functional Description</h2>\n<p>下图22-1展示了TWI控制器的架构。</p>\n<ul>\n<li><strong>外围接口</strong>（peripheral interface）支持32位宽的数据传输，并被处理器用于支持寄存器和FIFO缓冲器的读写。</li>\n<li><strong>寄存器块</strong> 包含了所有的控制和状态位，并依托程序模型来反映了可以写入或读取的内容。状态位可由其各自的（respective）功能块更新。</li>\n<li><strong>FIFO缓冲器</strong> 被配置为一个1字节宽、2字节深的发送/接收FIFO缓冲器。</li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/05/20210527133616.png\" alt=\"image-20210527103515471\"  /></p>\n<ul>\n<li><strong>发送移位寄存器</strong>（transmit shift）串行地将其数据从外部移出芯片（shift its data out externally off chip）。该输出可以被控制以产生确认，也可以被手动改写。</li>\n<li><strong>接收移位寄存器</strong>（receive shift）从片外串行接收其数据（receive its data serially from off chip）。接收移位寄存器的宽度为1个字节，收到的数据可以被转移到FIFO缓冲区或用于地址比较（address comparison）。</li>\n<li><strong>地址比较块</strong> （address compare block）支持在TWI控制器模块作为从机访问时的地址比较。</li>\n<li><strong>预分频器块</strong> （prescaler block）必须被编程以产生一个相对于外设时钟的 <code>10MHz</code> 时间基准。这个时间基准用于过滤数据和数据表中电气参数指定的定时事件（见飞利浦的I2C总线规范），以及 <code>TWI_CLOCK</code> 的时钟信号生成。</li>\n<li><strong>时钟生成模块</strong> （clock generation module）用于在主模式下生成一个外部串行时钟（<code>TWI_CLOCK</code>）。它包括在多主时钟配置中进行同步所需的逻辑，以及在从属模式下配置时的时钟拉伸。</li>\n</ul>\n<h3 id=\"时钟输出\">时钟输出</h3>\n<p>TWI控制器的时钟输出遵循以下规则。</p>\n<ol type=\"1\">\n<li><p>一旦时钟高电平（<code>CLKHI</code>）计数完成，串行时钟输出（serial clock output）被驱动为低电平，时钟低电平（<code>CLKLOW</code>）计数开始。</p></li>\n<li><p>一旦时钟低电平计数完成，串行时钟线被三振（three-stated），时钟同步逻辑进入延迟模式（阴影区），直到 <code>TWI_CLOCK</code> 线被检测到逻辑1电平。这时，时钟高电平计数开始。</p></li>\n</ol>\n<p><mark>TWI控制器只在主控模式运行时发出时钟，而且只在传输启动时发出</mark>。如果总线的仲裁（arbitration）丢失，串行时钟输出立即进入三态（three-states）。如果多个时钟试图驱动串行时钟线，TWI控制器将其时钟与其他剩余的时钟同步。这在图22-2中有所说明。</p>\n<blockquote>\n<p>The TWI controller only issues a clock during master mode operation and only at the time a transfer has been initiated.</p>\n</blockquote>\n<p><img src=\"https://pic.islet.space/2021/06/20210603144929.png\" alt=\"image-20210603144317584\" style=\"zoom:80%;\" /></p>\n<p>TWI控制器遵守《<em>Philips I2C Bus Specification version 2.1 dated January 2000</em>》传输协议。图22-3是简易的TWI传输示意。</p>\n<p><img src=\"https://pic.islet.space/2021/06/20210603172309.png\" alt=\"image-20210603145223033\" style=\"zoom:80%;\" /></p>\n<p>图22-4是TWI控制器在传输过程中的寄存器映射。</p>\n<p><img src=\"https://pic.islet.space/2021/06/20210603172312.png\" alt=\"image-20210603145235075\" style=\"zoom: 80%;\" /></p>\n<h3 id=\"总线仲裁-bus-arbitration\">总线仲裁 Bus Arbitration</h3>\n<p>略</p>\n<p><img src=\"https://pic.islet.space/2021/06/20210603145741.png\" alt=\"image-20210603145739629\" style=\"zoom:67%;\" /></p>\n<h3 id=\"开始与结束情景-start-stop-condition\">开始与结束情景 Start &amp; Stop condition</h3>\n<p>略</p>\n<p>​</p>\n<h2 id=\"操作模式-operating-modes\">操作模式 Operating Modes</h2>\n<h3 id=\"通用呼叫寻址-general-call-addressing\">通用呼叫寻址 General Call Addressing</h3>\n<p>如果TWI控制器被启用为从机（TWISEN），并且使用TWIGCE位启用了一般呼叫，则TWI控制器总是解码并确认一般呼叫地址。一般呼叫寻址（0x00）由GCALL位的设置表示，根据传输的性质，TWI控制器是一个从属接收者。如果与传输相关的数据不被确认（NAKed），TWINAK位可以被设置。</p>\n<p>如果TWI控制器作为主发射器发出一个总调用，可以设置适当的地址和传输方向，同时加载发送FIFO数据。</p>\n<blockquote>\n<p>The TWI controller always decodes and acknowledges a general call address if it is enabled as a slave (TWISEN) and if general call is enabled using the TWIGCE bit. General call addressing (0x00) is indicated by the setting of the GCALL bit, and by the nature of the transfer, the TWI controller is a slave-receiver. If the data associated with the transfer is to be not acknowledged (NAKed), the TWINAK bit can be set.</p>\n<p>If the TWI controller is to issue a general call as a master-transmitter, the appropriate address and transfer direction can be set along with loading transmit FIFO data.</p>\n</blockquote>\n<h3 id=\"从设备模式寻址-slave-mode-addressing\">从设备模式寻址 Slave Mode Addressing</h3>\n<blockquote>\n<p>With the appropriate selection of 7-bit addressing using the TWISLEN bit, the corresponding number of address bits (SADDR) are referenced during the address phase of a transfer.</p>\n</blockquote>\n<h3 id=\"主设备模式寻址-master-mode-addressing\">主设备模式寻址 Master Mode Addressing</h3>\n<p>无论是启用主发送器还是使用 <strong><em>TWIMLEN</em></strong> 位进行7位寻址的主接收器，TWI主站都会按要求执行所有寻址和数据传输。这包括产生重复启动条件，重新传输第一个地址字节的7位，以及确认和产生一个新的传输方向变化（由 <strong><em>TWIMLEN</em></strong> 位指示）。</p>\n<blockquote>\n<p>Whether enabled as a master-transmitter or master-receiver with 7-bit addressing using the <strong><em>TWIMLEN</em></strong> bit, the TWI master performs all addressing and data transfers as required. This includes generating the repeated start condition, re-transmission of the 7-bits of the first address byte, and acknowledgement and generation of a new transfer direction change (indicated by the <strong><em>TWIMLEN</em></strong> bit).</p>\n</blockquote>\n<h3 id=\"快速模式-fast-mode\">快速模式 Fast Mode</h3>\n<blockquote>\n<p>Fast mode (400 kHz) uses essentially the same mechanics as standard mode (100 kHz). It is the electrical specifications and timing that are different. When fast mode is enabled using the <strong><em>TWIFAST</em></strong> bit, the following timings are modified to meet the electrical requirements.</p>\n<ul>\n<li>Serial data rise times before arbitration evaluation (tr)</li>\n<li>Stop condition setup time from serial clock to serial data (tSUSTO)</li>\n<li>Bus free time between a stop and start condition (tBUF)</li>\n</ul>\n</blockquote>\n<h2 id=\"数据传输-data-transfer\">数据传输 Data Transfer</h2>\n<p>PAGE867:</p>\n<p>数据传输部分介绍 <strong>3个寄存器</strong>、<strong>4个缓冲区域</strong> 和 <strong>3个缓存状态</strong>。</p>\n<h3 id=\"寄存器-register\">寄存器 Register</h3>\n<p><strong>Serial Shift Register</strong>： TWI有一个输入和输出的串行移位器，下面将介绍。</p>\n<p><strong>Output Shift Register</strong>： 发送移位寄存器接收字节宽的缓冲区数据或寄存器数据（地址），并将其数据从外部串行移出芯片。该输出可以被控制以产生确认信号，也可以被手动改写。</p>\n<p><strong>Input Shift Register</strong>： 接收移位寄存器从芯片外串行地接收数据。在内部，接收移位寄存器是字节宽的，收到的数据可以被转移到缓冲区或用于地址比较。</p>\n<h2 id=\"中断-interrupt\">中断 Interrupt</h2>\n<p><img src=\"https://pic.islet.space/2021/05/20210527133619.png\" alt=\"image-20210527104039047\" style=\"zoom:67%;\" /></p>\n<h2 id=\"调试特征-debug-feature\">调试特征 Debug Feature</h2>\n<h3 id=\"masking\">Masking</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">bit <span class=\"built_in\">set</span> IMASK P14I; <span class=\"comment\">/* unmasks P14I interrupt */</span></span><br><span class=\"line\">ustat1=dm(DPI_IMASK_RE); <span class=\"comment\">/* set TWI Int */</span></span><br><span class=\"line\">bit <span class=\"built_in\">set</span> ustat1 TWI_INT;</span><br><span class=\"line\">dm(DPI_IMASK_RE)=ustat1;</span><br></pre></td></tr></table></figure>\n<h3 id=\"service\">Service</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">TWI_ISR:</span><br><span class=\"line\">ustat1 = dm(TWIIRPTL); <span class=\"comment\">/* read IRPTL to identify cause*/</span></span><br><span class=\"line\">bit TST ustat1 TWITXINT; <span class=\"comment\">/* test TX buffer bit*/</span></span><br><span class=\"line\">IF TF jump TX_BUF;</span><br><span class=\"line\"></span><br><span class=\"line\">TX_BUF:</span><br><span class=\"line\">dm(TWIIRPTL) = ustat1; <span class=\"comment\">/* RW1C to clear TWI TX buffer </span></span><br><span class=\"line\"><span class=\"comment\"> interrupt */</span></span><br><span class=\"line\">r0=dm(TWIMCTL); <span class=\"comment\">/* dummy read*/</span></span><br><span class=\"line\">instruction;</span><br><span class=\"line\">rti;</span><br></pre></td></tr></table></figure>\n<h2 id=\"主设备发送模式\">主设备发送模式</h2>\n<p>以下为单主机传输模式的的编程过程： 1. Program the <code>TWIMADDR</code> register. - This defines the address transmitted during the address phase of the transfer. 2. Program the <code>TXTWI8</code> or <code>TXTWI16</code> registers. - This is the initial data transmitted. - It is considered an error to complete the address phase of the transfer and not have data available in the transmit FIFO buffer. 3. Program the <code>TWIFIFOCTL</code> register. - Indicate if transmit FIFO buffer interrupts should occur with each byte transmitted (8 bits) or with each 2 bytes transmitted (16 bits). 4. Program the <code>TWIIMASK</code> register. - Enable the bits associated with the desired interrupt sources. - For example, programming the value <code>0x0030</code> results in an interrupt output to the processor when the master transfer completes, or if a master transfer error has occurred. 5. Program the <code>TWIMCTL</code> register. - This prepares and enables master mode operation. - As an example, programming the value <code>0x0201</code> enables master mode operation, generates a 7-bit address, sets the direction to master-transmit, uses standard mode timing, and transmits 8 data bytes before generating a stop condition.</p>\n<p><img src=\"https://pic.islet.space/2021/05/20210527105334.png\" alt=\"image-20210527104628291\" style=\"zoom:67%;\" /></p>\n<h1 id=\"clock\">Clock</h1>\n<blockquote>\n<p>The PLLD bits define the VCO output clock to core clock ratio to build the processor core clock (CCLK). The post divider can be changed any time and new division ratios are implemented on the fly.</p>\n</blockquote>\n<blockquote>\n<p>The PCLK and CLKIN clocks are used in the arbitration logic for the shared external bus.</p>\n</blockquote>\n<blockquote>\n<p>The PLL bit settings PLLM/PLLD in PMCTL register need to be programmed such that the PLLM/PLLD ratio is integer (for example 15/2=7.5 fractional, is not allowed).</p>\n</blockquote>\n<h2 id=\"iop-clock-pclk\">IOP Clock (PCLK)</h2>\n<p>The <strong><em>peripheral clock</em></strong> is derived from the <strong><em>core clock</em></strong> with <strong><em>a fixed post divisor of 2</em></strong>.</p>\n<p>This clock is the <strong><em>master clock for</em></strong> most peripherals including the <strong><em>I/O processor</em></strong> (IOP).</p>\n<h1 id=\"pll\">PLL</h1>\n<h2 id=\"pll-registers\">PLL Registers</h2>\n<h3 id=\"pmctl\">PMCTL</h3>\n<p><code>PMCTL</code> 寄存器，Power management control register。（是的，没错，就是不知道为啥管PLL的要叫PMCTL）</p>\n<ul>\n<li>Controls the <strong><em>SDCLK</em></strong> to core clock ratio <mark>or</mark> <strong><em>DDR2CLK</em></strong> to core clock ratio related to the external port timing.\n<ul>\n<li>The fundamental timing clock of the external port is <strong><em>SDRAM clock</em></strong> (SDCLK). The SDRAM clock ratio settings are independent from the peripheral clock (PCLK).\n<ul>\n<li>The AMI/SDRAM controller is capable of running at up to <strong><em>133 MHz</em></strong> for ADSP-2147x processors. See Table 4-2 for more information about <em>EXTERNAL PORT CLOCK FREQUENCIES</em>.</li>\n</ul></li>\n<li>The fundamental timing clock of the external port is <strong><em>DDR2 clock</em></strong> (DDR2_CLK). The DDR2 clock ratio settings are independent from the <strong><em>peripheral clock</em></strong> (PCLK).</li>\n</ul></li>\n<li>32位内存映射寄存器（32-bit memory-mapped register）</li>\n<li>包含控制位，可控制：锁相环（PLL, phase lock loop）(PLL乘法器值（multiplier）、PLL除法器值（divider）、锁相环旁路模式（PLL bypass mode） 和 外围设备使能时钟控制（clock control for enabling peripherals）)</li>\n<li>包含状态位，可追踪：CLK_CFG针脚（可读写）</li>\n<li>PMCTL 寄存器的复位值取决于 <code>CLK_CFG</code> 引脚（bits 5-0 &amp; 17-16）</li>\n<li>包含三选一的加速器（FIR、IIR、FFT）</li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/06/20210608103432.png\" alt=\"image-20210608101359924\" style=\"zoom: 67%;\" /></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210527150918.png\" alt=\"image-20210527150852485\" /><figcaption aria-hidden=\"true\">image-20210527150852485</figcaption>\n</figure>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n图 A-2 PMCTL 寄存器\n</p>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n表A-3 PMCTL寄存器位功能描述\n</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210527151117.png\" alt=\"image-20210527151035867\" /><figcaption aria-hidden=\"true\">image-20210527151035867</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210527151120.png\" alt=\"image-20210527151017770\" /><figcaption aria-hidden=\"true\">image-20210527151017770</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210527151124.png\" alt=\"image-20210527151110432\" /><figcaption aria-hidden=\"true\">image-20210527151110432</figcaption>\n</figure>\n<h3 id=\"pmctl1\">PMCTL1</h3>\n<p><img src=\"https://pic.islet.space/2021/05/20210527152316.png\" alt=\"image-20210527152044822\" style=\"zoom:67%;\" /></p>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n图 A-3 PMCTL1 寄存器\n</p>\n<p style=\"text-align: center; color: gray; font-weight: 800;\">\n表A-4 PMCTL1寄存器位功能描述\n</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210527152313.png\" alt=\"image-20210527152155406\" /><figcaption aria-hidden=\"true\">image-20210527152155406</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210527152318.png\" alt=\"image-20210527152229763\" /><figcaption aria-hidden=\"true\">image-20210527152229763</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210527152322.png\" alt=\"image-20210527152251696\" /><figcaption aria-hidden=\"true\">image-20210527152251696</figcaption>\n</figure>\n<h3 id=\"plld\">PLLD</h3>\n<p><mark style=\"font-weight: 900;\">Page 888:</mark> <strong>PLLD</strong>（PLL Divider）定义了 <strong>VCO输出时钟</strong> 和 <strong>核心时钟</strong> 的比值，以构建 <strong>处理器核心时钟</strong>（CCLK）。正在使用的分频器可以被随时改变，新的分频比率可以实时被应用。</p>\n<p><mark style=\"font-weight: 900;\">Page 957:</mark> <strong>PLLD</strong>只有2位，可以设置为2、4、8、16。</p>\n<p><img src=\"https://pic.islet.space/2021/05/20210529113458.png\" alt=\"image-20210529113003651\" style=\"zoom:67%;\" /></p>\n<p><mark style=\"font-weight: 900;\">&lt;def21479.h&gt;</mark>:<img src=\"https://pic.islet.space/2021/05/20210529113406.png\" alt=\"image-20210529113403231\" /></p>\n<p>以下这几个操作中均需要用到PLLD，分别是：</p>\n<ul>\n<li>输出时钟生成器编程模型 （Output Clock Generator Programming Model）</li>\n<li>改变链接口时钟（Changing the Link Port Clock）</li>\n<li>发布分频器（Post Divider）</li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/05/20210529113238.png\" alt=\"image-20210529111641680\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/05/20210529113241.png\" alt=\"image-20210529111748944\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/05/20210529113244.png\" alt=\"image-20210529112121464\" style=\"zoom:67%;\" /></p>\n<h2 id=\"官方示例\">官方示例</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Init_PLL</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp,i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Step 1 - change the PLLD to 4</span></span><br><span class=\"line\">\ttemp=*pPMCTL;   <span class=\"comment\">//备份PMCTL寄存器的值至temp</span></span><br><span class=\"line\">\ttemp&amp;=~PLLD16 ;     <span class=\"comment\">//0x20，将PLLD16的值和temp进行逐位“与”运算</span></span><br><span class=\"line\">\ttemp|=(PLLD4 | DIVEN) ;   <span class=\"comment\">//0x260    0010 0110 0000</span></span><br><span class=\"line\">\t*pPMCTL = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Step 2 - 等待分频器稳定</span></span><br><span class=\"line\">\tSysWait(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Step 3 - set INDIV bit now to bring down the VCO speed and enter the bypass mode</span></span><br><span class=\"line\">\ttemp&amp;=~DIVEN;</span><br><span class=\"line\">\ttemp|=(INDIV | PLLBP);</span><br><span class=\"line\">\t*pPMCTL = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Step 4 -等待PLL锁定</span></span><br><span class=\"line\">\tSysWait(<span class=\"number\">4096</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Step 5 - come out of the bypass mode</span></span><br><span class=\"line\">\ttemp=*pPMCTL;</span><br><span class=\"line\">\ttemp&amp;=~PLLBP;</span><br><span class=\"line\">\t*pPMCTL = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Step 6 - 等待分频器稳定</span></span><br><span class=\"line\">\tSysWait(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Step 7 - set the required PLLM and INDIV values here  and enter the bypass mode</span></span><br><span class=\"line\">\t <span class=\"comment\">//PLLM=16, INDIV=0,  fVCO=2*PLLM*CLKIN = 2*16*16.625 = 532 MHz</span></span><br><span class=\"line\">\ttemp = *pPMCTL;</span><br><span class=\"line\">\ttemp&amp;=~ (INDIV | PLLM63);</span><br><span class=\"line\">\ttemp|= (PLL_MULT| PLLBP);</span><br><span class=\"line\">\t*pPMCTL = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Step 8 - wait for the PLL to lock</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4096</span>;i++);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Step 9 - come out of the bypass mode</span></span><br><span class=\"line\">\ttemp = *pPMCTL;</span><br><span class=\"line\">\ttemp&amp;=~PLLBP;</span><br><span class=\"line\">\t*pPMCTL=temp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Step 10 - wait for dividers to stabilize</span></span><br><span class=\"line\">\tSysWait(<span class=\"number\">16</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// Step 11 - set the required values of PLLD(=2) and SDCKR (=2.5 for ADSP-21489 and 2 for ADSP-21479) here</span></span><br><span class=\"line\">\t<span class=\"comment\">// fCCLK = fVCO/PLLD = 532/2 = 266 MHz, fSDCLK = fCCLK/SDCKR = 266/2 = 133 MHz</span></span><br><span class=\"line\">\ttemp=*pPMCTL;</span><br><span class=\"line\">\ttemp&amp;=~(PLLD16 | <span class=\"number\">0x1C0000</span> );</span><br><span class=\"line\">\ttemp|= (SDCKR2 | PLLD2 | DIVEN);</span><br><span class=\"line\">\t*pPMCTL=temp;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// Step 12 - wait for the dividers to stabilize</span></span><br><span class=\"line\">\tSysWait(<span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>问题</strong>1： 为啥一定要使用temp变量来进行处理，直接使用 <code>*pPMCTL</code> 不是更方便吗？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initPLL</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/********************************************************************************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i, pmctlsetting;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Set INDIV bit in PMCTL register</span></span><br><span class=\"line\">\tpmctlsetting = *pPMCTL; <span class=\"comment\">// 备份PMCTL寄存器的原始值</span></span><br><span class=\"line\">\tpmctlsetting |= INDIV;\t<span class=\"comment\">//设置锁相环输出的分频率，0则是1分频，1则是2分频，此处通过或运算设置为二分频</span></span><br><span class=\"line\">\t*pPMCTL = pmctlsetting; <span class=\"comment\">// 将至重新写入PMCTL寄存器</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Program PLL multiplier to same value as CLK_CFGx pins/previously programmed value in software……</span></span><br><span class=\"line\">\t*pPMCTL = pmctlsetting;</span><br><span class=\"line\">\tpmctlsetting |= PLLBP; <span class=\"comment\">//设置锁相环旁路模式</span></span><br><span class=\"line\">\t*pPMCTL = pmctlsetting;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//Wait for recommended number of cycles</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4096</span>; i++)</span><br><span class=\"line\">\t\tNOP;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Bring PLL out of bypass mode by clearing PLLBP bit</span></span><br><span class=\"line\">\t*pPMCTL ^= PLLBP; <span class=\"comment\">// 通过异或操作 取消旁路模式</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">16</span>; i++)</span><br><span class=\"line\">\t\tNOP;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpmctlsetting = *pPMCTL;</span><br><span class=\"line\">\tpmctlsetting &amp;= ~PLLM63; <span class=\"comment\">//通过按位取反操作和与操作，清除PLLM所有位</span></span><br><span class=\"line\">\tpmctlsetting &amp;= ~INDIV;\t <span class=\"comment\">//通过按位取反操作和与操作，清除分频</span></span><br><span class=\"line\">\t<span class=\"comment\">// *pMCTL |= INDIV;</span></span><br><span class=\"line\">\t*pPMCTL = pmctlsetting;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// CLKIN = 16.625 MHz, PLLM=32, PLLD = 1, INDIV= 1 =&gt; fINPUT = 16.625/2 = 8.3125 MHz</span></span><br><span class=\"line\">\t<span class=\"comment\">// CCLK = 2*PLLM*fINPUT/2*PLLD = (2*32*8.3125)/(2*1) = 266 MHz, SDCLK = CCLK/2 = 133 MHz</span></span><br><span class=\"line\">\t<span class=\"comment\">// VCO frequency = 2*fINPUT*PLLM = 2*8.3125*32 = 532 &lt;= fVCOmax (532 MHz)</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tpmctlsetting = SDCKR2 | PLLM32 | INDIV | DIVEN; <span class=\"comment\">//设置</span></span><br><span class=\"line\">\t*pPMCTL = pmctlsetting;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpmctlsetting |= PLLBP;\t<span class=\"comment\">//Setting the Bypass bit</span></span><br><span class=\"line\">\tpmctlsetting ^= DIVEN;\t<span class=\"comment\">//Clearing the DIVEN bit</span></span><br><span class=\"line\">\t*pPMCTL = pmctlsetting; <span class=\"comment\">// Putting the PLL into bypass mode</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//Wait for around 4096 cycles for the pll to lock.</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000</span>; i++)</span><br><span class=\"line\">\t\tNOP;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpmctlsetting = *pPMCTL;</span><br><span class=\"line\">\tpmctlsetting ^= PLLBP; <span class=\"comment\">//清除旁路模式</span></span><br><span class=\"line\">\t*pPMCTL = pmctlsetting;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//Wait for around 15 cycles for the output dividers to stabilize.</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">16</span>; i++)</span><br><span class=\"line\">\t\tNOP;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更改之后：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SystemWait</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> MAX)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; MAX; i++) NOP;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initPLL</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t*pPMCTL |= INDIV;\t<span class=\"comment\">//设置锁相环输出的分频率，0则是1分频，1则是2分频，此处通过或运算设置为二分频</span></span><br><span class=\"line\">\t*pPMCTL |= PLLBP; <span class=\"comment\">//设置锁相环旁路模式</span></span><br><span class=\"line\">\tSystemWait(<span class=\"number\">4096</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">    *pPMCTL ^= PLLBP; <span class=\"comment\">// 通过异或操作 取消旁路模式</span></span><br><span class=\"line\">\tSystemWait(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    *pPMCTL &amp;= ~( PLLM63 | INDIV );  <span class=\"comment\">//PLLM和INDIV位全部或操作后取反，再与原PMCTL里的数据与操作，清除该两个定义位的数据</span></span><br><span class=\"line\">\t*pPMCTL = SDCKR2 | PLLM32 | INDIV | DIVEN; <span class=\"comment\">//设置这几个位置的值</span></span><br><span class=\"line\">    *pPMCTL = (*pPMCTL | PLLBP) ^ DIVEN</span><br><span class=\"line\">\tSystemWait(<span class=\"number\">4096</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t*pPMCTL ^= PLLBP; <span class=\"comment\">//清除旁路模式</span></span><br><span class=\"line\">\tSystemWait(<span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当使用乘法器（multipliers）和已发布的分频器（post dividers）对PLL进行编程时，<code>DIVEN</code> 和 <code>PLLBP</code> 不可以在同一个时钟周期内被编程。注意：<code>DIVEN</code> 位会自动清零（self clearing）。</p>\n<blockquote>\n<p>∵ CLKIN = 16.625 MHz, PLLM=32, PLLD = 1, INDIV= 1 ∴ f<sub>INPUT</sub> = 16.625/2 = 8.3125 MHz ∴ CCLK = 2*PLLM *f<sub>INPUT</sub>/2*PLLD = (2*32*8.3125)/(2*1) = 266 MHz ∴ SDCLK = CCLK/2 = 133 MHz， 符合 2147X 对 SDRAM 时钟的要求 VCO frequency = 2*f<sub>INPUT</sub>*PLLM = 2<em>8.3125</em>32 = 532 &lt;= f<sub>VCOmax</sub> (532 MHz)</p>\n</blockquote>\n<h3 id=\"步骤总结\">步骤总结</h3>\n<p>从官方给出的示例代码中，可以将步骤总结如下：</p>\n<ol type=\"1\">\n<li><mark>设置PLLD</mark> - 等待分频器稳定</li>\n<li><mark>设置INDIV位以降低VCO速度，并进入旁路模式</mark> - 等待PLL锁定</li>\n<li><mark>从旁路模式出来</mark> - 等待分频器稳定</li>\n<li><mark>设置PLLM和INDIV，并进入旁路模式</mark> - 等待PLL锁定</li>\n<li><mark>从旁路模式出来</mark> - 等待分频器稳定</li>\n<li><mark>设置PLLD和SDCKR</mark> - 等待分频器稳定</li>\n</ol>\n<p>从以上步骤可以看出，PLL的初始化，主要是设置 <strong>PLLD</strong> 、 <strong>INDIV</strong> 、 <strong>PLLM</strong> 、 <strong>SDCKR</strong> 的值，途中反复等待 <strong>分频器稳定</strong> 和 <strong>PLL锁定</strong>。</p>\n<h3 id=\"问题总结\">问题总结</h3>\n<ol type=\"1\">\n<li>进入旁路模式的意义：</li>\n</ol>\n<h1 id=\"interrupt-control-of-pins\">Interrupt Control of PINs</h1>\n<p><em>Page93</em>：</p>\n<blockquote>\n<p>For information on the IRPTL, LIRPTL, and IMASK registers, see <em>SHARC Processor Programming Reference</em>.</p>\n</blockquote>\n<p>下表2-1介绍了经过DAI和DPI的数据通道：</p>\n<ul>\n<li>DAI共有32个通道（22个外围设备通道，10个miscellaneous通道），DPI共有12个通道（3个外围设备通道，9个miscellaneous通道）</li>\n<li>DAI允许设置优先级，而DPI不允许</li>\n<li>DAI和DPI都能识别上升沿（Rising Edge）或下降沿（Falling Edge）</li>\n<li>到核心的中断（Interrupt to Core)，DAI为2，DPI为1</li>\n<li>DAI和DPI都是4分频</li>\n</ul>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210602150124.png\" alt=\"image-20210602150117965\" /><figcaption aria-hidden=\"true\">image-20210602150117965</figcaption>\n</figure>\n<h2 id=\"特征\">特征</h2>\n<ul>\n<li><p>两个系统中断控制器（SIC, System Interrupt Controller），分别为DAI SIC 和 DPI SIC，连接至核心中断控制器（CIC, Core Interrupt Controller）。</p></li>\n<li><p>DAI SIC 允许高/低中断优先级配置选项</p></li>\n<li><p>DAI中断控制器提供最高32条独立可配置通道</p></li>\n<li><p>DPI中断控制器提供最高12条独立可配置通道</p></li>\n<li><p>DAI SIC和DPI SIC都允许针对波形的上升沿或下降沿进行锁存</p></li>\n<li><p>与核心锁存中断一致的中断延迟</p></li>\n<li><p>时钟：系统中断控制器的基础时钟是 <em>4分频</em> (f<sub>PCLK</sub>)/4 ；所有中断的确认响应速度为4分频最高。</p></li>\n</ul>\n<h2 id=\"中断寄存器\">中断寄存器</h2>\n<p><strong>可编程中断控制寄存器</strong>（<strong>PICR</strong>3 - 0）： 为了登记（assign）独立优先级（individual priorities）到各外围通道，19个外围设备可路由至可编程中断输入。</p>\n<p><strong>DAI 中断屏蔽寄存器</strong>（<strong>DAI_IMASK</strong>）：屏蔽上升或下降沿波形。因可屏蔽的边沿有上升沿或下降沿，因此DAI中断屏蔽寄存器分为 DAI_IMASK_RE 和 DAI_IMASK_FE。</p>\n<p><strong>DAI 中断屏蔽优先级寄存器</strong>（<strong>DAI_IMASK_PRI</strong>）：为DAI高/低中断优先级屏蔽中断。</p>\n<p><strong>DAI 中断锁存寄存器</strong>（<strong>DAI_IRPTL</strong>）: 为DAI高/低优先级中断锁存中断。</p>\n<p><strong>DPI 中断屏蔽寄存器</strong>（<strong>DPI_IMASK</strong>）：屏蔽上升或下降沿波形。因可屏蔽的边沿有上升沿或下降沿，因此DPI中断屏蔽寄存器分为 DPI_IMASK_RE 和 DPI_IMASK_FE。</p>\n<p><strong>DPI 中断锁存寄存器</strong>（<strong>DPI_IRPTL</strong>）：为DPI中断锁存中断。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210603134601.png\" alt=\"image-20210603134437928\" /><figcaption aria-hidden=\"true\">image-20210603134437928</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210603134603.png\" alt=\"image-20210603134453465\" /><figcaption aria-hidden=\"true\">image-20210603134453465</figcaption>\n</figure>\n<h2 id=\"功能描述\">功能描述</h2>\n<h3 id=\"可编程中断优先级控制\">可编程中断优先级控制</h3>\n<h4 id=\"外围中断\">外围中断</h4>\n<h4 id=\"软件中断\">软件中断</h4>\n<h4 id=\"多重中断请求信号的外围设备\">多重中断请求信号的外围设备</h4>\n<h3 id=\"系统中断控制器\">系统中断控制器</h3>\n<p>DAI/DPI外围相关事件发生时，这些针脚各自拥有能够指向核心的系统中断控制器。</p>\n<p>相对于SHARC核心，音频事件通常发生不频繁，DAI/DPI中断控制器将其所有中断减少到核心主中断系统中的三个中断信号上：</p>\n<ul>\n<li>一个映射为DAI低优先级</li>\n<li>一个映射为DAI高优先级</li>\n<li>第三个映射到DPI中断。</li>\n</ul>\n<p>以上这种操作，允许程序更加粗略地去表示优先级。</p>\n<p>输出总线中断信号可以有逻辑地导向（ORed）一个中断线并递交至（fed to）核心中断控制逻辑。</p>\n<blockquote>\n<p>The output bus interrupt signals are logically ORed into one interrupt line and fed to the core’s interrupt controller logic.</p>\n</blockquote>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210602155414.png\" alt=\"image-20210602154656729\" /><figcaption aria-hidden=\"true\">image-20210602154656729</figcaption>\n</figure>\n<p><strong>注意</strong>：DAI/DPI中断控制器拥有与核心中断控制器相同的中断延迟，或6个延时周期以相应异步中断。</p>\n<p>被用于配置DAI中断控制器的有3个寄存器，被用于配置DPI中断控制器的有2个寄存器。32个DAI中断源和12个DPI中断源中的任意一个都可以用于独立配置开关，来控制进入信号的上升沿、下降沿、上升下降沿（both edges）或无沿（neither edge）。</p>\n<p>需要注意的是，当核心中断寄存器是系统寄存器时，DAI/DPI中断控制寄存器是被内存映射的寄存器（memory mapped registers），且通过外围设备总线被接入（accessed via the peripheral bus）。</p>\n<h4 id=\"daidpi中断源\">DAI/DPI中断源</h4>\n<p>DAI有5个外围（中断）源都被多路复用至（multiplexed into）32个中断源里，并以 <code>DAI_INT 0 ~ 31</code> 作为标签名称。</p>\n<p>DPI有3个外围（中断）源都被多路复用至（multiplexed into）12个中断源里，并以 <code>DPI_INT 0 ~ 13</code> 作为标签名称。</p>\n<p>下表介绍了DAI/DPI在不同的通信方式和信号响应的关系。</p>\n<p><img src=\"https://pic.islet.space/2021/06/image-20210602195334432.png\" alt=\"image-20210602195334432\" style=\"zoom:67%;\" /></p>\n<h4 id=\"dai中断锁存优先级设置\">DAI中断锁存优先级设置</h4>\n<p>DAI系统中断控制器寄存器对（ <code>DAI_IRPTL_H</code> 和 <code>DAI_IRPTL_L</code>）取代了通常由核心中断控制器的IRPTL寄存器执行的功能。一个单一的寄存器（ <code>DAI_IRPTL_PRI</code>）指定了这些中断被映射到哪个锁存器中。</p>\n<p>当一个DAI中断被配置为低优先级（<code>DAI_IMASK_PRI</code> 位被清除，默认设置），它将被锁在 <code>DAI_IRPTL_L</code> 寄存器中。低优先级的DAI中断，<code>DAILI</code>，被连接到 <code>P12I</code> 核心中断上。默认情况下。<code>PICR</code> 寄存器可以改变这种连接。每当DAI的低优先级中断被设置，<code>LIRPTL</code>寄存器中的 <code>DAILI</code> 位就会被设置，核心就会为该低优先级中断服务。</p>\n<p><img src=\"https://pic.islet.space/2021/06/image-20210602200433030.png\" alt=\"image-20210602200433030\" style=\"zoom:67%;\" /></p>\n<p><strong>注意</strong>： DAI会在<strong>中断向量表</strong>中触发一个高优先级一个低优先级的中断。当任一来自DAI的中断需要服务时，两个核心ISR之一必须审查（interrogate）DAI的中断控制器以判定其中断源。</p>\n<blockquote>\n<p>中断向量表（Interrupt Vector Table, IVT）, Page 177</p>\n<p><img src=\"https://pic.islet.space/2021/06/image-20210602205507981.png\" alt=\"image-20210602205507981\" style=\"zoom:67%;\" /></p>\n</blockquote>\n<h4 id=\"dpi中断锁存\">DPI中断锁存</h4>\n<p>DPI系统中断控制寄存器（<code>DPI_IRPTL</code>）取代了通常是由核心控制器寄存器（<code>IRPTL</code>）的功能。</p>\n<p>当DPI中断配置时，将被锁存在 <code>DPI_IRPTL</code> 寄存器中。默认情况下，DPI中断被连接至P14I核心中断。PICR寄存器可以改变其连接。无论何时，DPI中断一旦设置，<code>LIRPTL</code> 寄存器中已编程的DPI位会被设置，且核心将会为已编程优先级的中断服务。</p>\n<h4 id=\"daidpi边沿触发中断屏蔽\">DAI/DPI边沿触发中断屏蔽</h4>\n<p>DAI上升沿中断屏蔽寄存器 <code>DAI_IMASK_RE</code> 和 DAI下降沿中断屏蔽寄存器 <code>DAI_IMASK_FE</code> 取代了核心中断控制器 <code>IMASK</code> 的版本。与 <code>IMASK</code> 寄存器一样，这些DAI寄存器提供了一种指定（specify）哪条中断被确认和处理，哪条中断会被忽略的方法。这对寄存器的功能与 <code>IMASK</code> 一致，但具有更高程度的细化。</p>\n<p>对 <code>DAI_IMASK_RE</code> 、 <code>DAI_IMASK_FE</code> 、 <code>DPI_IMASK_RE</code> 、<code>DPI_IMASK_FE</code>这些寄存器的使用，能够使程序对上升沿、下降沿、上升下降沿、或者无沿（neither rising or falling edge）的程序确认或响应能够分别独立地屏蔽（masked separately）。</p>\n<p>从SRU过来的信号能够被用于生成中断。例如，当 <code>DAI_IMASK_FE</code> 寄存器的 <code>DAI_30_INT</code> 位被设置为1时，任何从外部通道过来的下降沿信号都能在核心中生成中断，且中断锁存器会被设定。对 <code>MASK</code> 寄存器的读取不会清除 <code>IRPTL</code> 寄存器。</p>\n<h4 id=\"daidpi事件中断屏蔽\">DAI/DPI事件中断屏蔽</h4>\n<p>系统中断控制器需要一个外设的中断源与事件信号相对应的信息（参考第2-8页中的表2-2）。如此一来，就只有上升沿被当做中断源。对于被标记为事件的DAI/DPI外设，程序可以只在上升沿解除中断源的屏蔽。</p>\n<h4 id=\"daidpi中断服务\">DAI/DPI中断服务</h4>\n<p>当多通道被复用至一个中断输出信号时，中断确认的操作方式不尽相同。当DAI/DPI中的服务必须被处理时，三者任一的中断服务程序（interrupt service routines）（<code>DAILI</code>, <code>DAIHI</code> 和 <code>DPII</code>）必须查询RIC以确定中断源。该中断源可能是一个或多个DAI/DPI通道（<code>DAI_INT31-0</code> 、 <code>DPI_INT13-0</code>）。</p>\n<ul>\n<li>当 <code>DAI_IRPTL_H</code> 被读取时，高优先级锁存的中断将会被清除。</li>\n<li>当 <code>DAI_IRPTL_L</code> 被读取时，低优先级锁存的中断将会被清除。</li>\n<li>当 <code>DPI_IRPTL</code> 被读取时，锁存中断将会被清除。</li>\n<li>当 <code>DAI_IRPTL_H/L</code> 寄存器被读取时， <code>IDP_FIFO_GTN_INT</code> 中断不会被清除。当中断需要离开的情况发生时，中断自然会被清除。（This interrupt is cleared automat\u0002ically when the situation that caused the interrupt goes away.）</li>\n<li><code>DPI_IRPTL_SH</code> 是被用于读取主寄存器 <code>DPI_IRPTL</code>的影子寄存器。读取这些影子寄存器将会返回 <code>DPI_IRPTL</code> 寄存器中的数据却不会清除里面的内容。</li>\n</ul>\n<p>如果在清空锁存器的同一周期内发生中断，则该机制的优先级较低，新的中断器被注册。</p>\n<p><strong>注意</strong>：</p>\n<ul>\n<li>TWII 和UARTRXI 中断不遵循这条原则。确认信号将在这些外围锁存器中发生。</li>\n<li>读取中断锁存器（<code>DAI_IRPTL_X</code> 或 <code>DPI_IRPTL</code> ）将会清除中断（只读清除类型）。因此，ISR必须为所有已发现的中断提供服务。即如果复用中断（mumtiple interrupts）被锁存在复用屏蔽寄存器（multiple mask registers）中，必须在执行 <strong><em>RTI</em></strong> 指令前，对所有中断进行服务。</li>\n</ul>\n<blockquote>\n<p><strong>RTI</strong> （(interrupt) return instruction）：中断返回指令</p>\n<p>在中断服务程序中用于返回中断指令，在运行中断之前，用JSR指令将PC（程序计数器）和SR（状态寄存器）压入堆栈，当中断服务程序结束时，执行RTI或RTIS指令，将PC和SR从堆栈中弹出。</p>\n<p>——<a href=\"https://baike.baidu.com/item/RTI/7461669\">RTI</a></p>\n</blockquote>\n<h3 id=\"中断服务\">中断服务</h3>\n<p>中断服务部分主要描述了中断服务程序操作（interrupt service routines operate）如何正确清除中断请求。</p>\n<p>中断驱动I/O是较为有利（advantageous）的，因为核心并不需要去轮询（poll）输入信号。当一次中断触发时，定序器（sequencer）通常会完成其现有的指令并跳转至中断向量表（IVT）。（向量）地址（the address）通常会从向量表里指向ISR程序。定序器（sequencer）跳转至该程序，完成程序执行并通过执行RTI指令退出程序。然而，这条规则并不对所有情况适用，在ISR程序中，有三种中断确认机制，均取决于外围设备：</p>\n<ul>\n<li>RTI指令</li>\n<li>只读清除（ROC）状态位 + RTI指令</li>\n<li>写1清除（W1C，Write-1-to-clear）状态为 + RTI指令</li>\n</ul>\n<p><mark>锁存器必须在被读取的时候清除中断源</mark>，因此DAI/DPI被设计来正确地执行此项工作。需要注意的是，锁存器读取操作会在退出中断程序（exiting an interrupt routine）前自动确认请求（automatically acknowledges the request）。在W1C机制，程序必须写入锁存器的特定位（specific bit）以正确清除中断（terminate the interrupt properly）。</p>\n<p><strong>注意</strong>：如果确认机制没有被正确遵守，中断将可能在未可预知且频率不定（unwanted and sporadic）的情况下发生。</p>\n<h4 id=\"核心缓存服务请求输入输出模式\">核心缓存服务请求（输入输出模式）</h4>\n<p>如果数据流外围设备通过核心访问各自DMA FIFO的数据缓存，则缓存（器）在中断确认过程中发挥着重要作用。</p>\n<p>例如，一个接收缓存已满，中断生成时ISR中的缓存被读取，就会触发清除请求（ROC + RTI）。同样的，如果一个传输缓存已空，中断生成时，写入操作将会清除请求（WOC + RTI）。</p>\n<h4 id=\"dma接入\">DMA接入</h4>\n<p>如果外设通过DMA访问缓冲区，逻辑操作就不同了。在DMA中，缓存状态对中断没有影响。相反，每当DMA计数寄存器达到0时就会产生一个中断。不同的外围设备所使用的中断确认机制都不同。</p>\n<blockquote>\n<p><strong>DMA</strong> Direct Memory Access 直接内存访问</p>\n<p>是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。否则，CPU 需要从来源把每一片段的资料复制到暂存器，然后把它们再次写回到新的地方。在这个时间中，CPU 对于其他的工作来说就无法使用。</p>\n</blockquote>\n<h3 id=\"中断延迟\">中断延迟</h3>\n<p>优秀的编程会要求一条（完整的）中断服务 <em>确认</em> 中断请求尽可能简洁地返回至外围设备。这种（中断）响应允许外围设备尽可能快地感知到其他事件。</p>\n<p>此（中断确认）服务程序（routine）必须去确保（中断）请求在RTI指令执行前被释放，否则（中断）服务程序会在执行完RTI指令后被立即调用。</p>\n<p>有些中断请求通过W1C操作来清除，该写入指令并没有让核心停滞（stall the core）。相反，该操作被自动锁存在写缓存中，并在被发送至外围总线前会通过外围时钟（<strong><em>PCLK</em></strong>）进行同步。</p>\n<p>在W1C操作到达外围设备前，此操作可能会需要多个 <strong><em>CCLK</em></strong> 周期（cycles）。如果 W1C 操作在服务程序的结束点进行操作，一个 dummy 读取操作需要在RTI指令前被执行，以确保外围设备能够在RTI之前释放请求。</p>\n<p>下列案例描述了中断延迟：</p>\n<ul>\n<li>对于具有W1C确认机制的外设来说，写入外设的状态寄存器以清除中断会导致一定的延迟（因为寄存器的写入效应延迟）。</li>\n<li>中断驱动的数据传输（核心或DMA）来自任何产生中断和使用ISR程序（routine）的外设，写入外设数据缓冲区（以清除中断）或控制寄存器会导致一定的延迟（因为存在寄存器写入效果延迟和缓冲区时钟域）。</li>\n</ul>\n<p>如果像案例所示，程序在延迟的周期内（最多10个CCLK周期），程序从中断服务程序（RTI指令）中生成，中断再次出现。为了避免中断多次出现，需要采取下列其中一种措施：（<strong>注意</strong>：中断再生的限制（interrupt regeneration restriction）不适用于DMA操作模式下的任何SPORT。）</p>\n<ol type=\"1\">\n<li><strong>在中断返回（RTI）前，从相同的外围区块中读取IOP寄存器。读取操作（的同时）会强制写入，如下列样例所示。</strong></li>\n</ol>\n<p><strong>SPI中断服务程序</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">R0 &#x3D; dm(i0,m0);</span><br><span class=\"line\">dm(TXSPI) &#x3D; R0; &#x2F;&#x2F; 写入SPI数据缓存</span><br><span class=\"line\">R0 &#x3D; dm(SPICTL); &#x2F;* this dummy read forces the previous write to complete *&#x2F;</span><br><span class=\"line\">rti;</span><br></pre></td></tr></table></figure>\n<p><strong>PWM中断服务程</strong>序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">r1 &#x3D; PWM_STAT3;</span><br><span class=\"line\">dm(PWMGSTAT)&#x3D;r1; &#x2F;* W1C to PWM status reg *&#x2F;</span><br><span class=\"line\">r0&#x3D;dm(PWMGSTAT); &#x2F;* this dummy read forces the previous write to complete *&#x2F;</span><br><span class=\"line\">rti;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\" type=\"1\">\n<li><strong>在写入操作后添加足够的NOP指令。在最坏的情况下，程序需要在写入后添加10条NOP指令，如下面的示例代码所示。</strong></li>\n</ol>\n<p><strong>中断服务程序</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">R0 &#x3D; 0x0;</span><br><span class=\"line\">dm(SPICTL) &#x3D; R0; &#x2F;* or disable SPI control *&#x2F;</span><br><span class=\"line\">nop; nop; nop; nop; nop; </span><br><span class=\"line\">nop; nop; nop; nop; nop; </span><br><span class=\"line\">rti;</span><br></pre></td></tr></table></figure>\n<h4 id=\"dma完成类型\">DMA完成类型</h4>\n<p>在SHARC处理器中，中断在内部传输完成（此时DMA计数器过期（expired））后被生成。但是，在某些案例中，传输可能尚未完成（不同通道优先级的原因）且有效的数据仍然存在于（resides in）外设的缓冲区中等待着被传输。为了解决此问题，引入了中断访问完成模式（interrupt access completion mode），在此模式下，上一个数据离开缓存时，中断会被生成。此模式可用于 SPORT 、 SPI 、 连接口 和 外部接口DMA。</p>\n<h2 id=\"调试特征\">调试特征</h2>\n<h4 id=\"影子中断寄存器\">影子中断寄存器</h4>\n<ul>\n<li><p>影子中断寄存器（Shadow Interrupt Register）可用于 IDP, S/PDIF, ASRC, UART, TWI 和 DAI/DPI。</p></li>\n<li><p>DAI/DPI 中断控制器拥有可以简化调试活动且不会操纵状态控制（manipulate status control）的影子寄存器。</p></li>\n<li><p>任何对 <code>DAI_IRPTL_x_SH</code> 或 <code>DPI_IRPTL_SH</code> 影子寄存器的读取都会提供 和 读取 <code>DAI_IRPTL_x</code> 或 <code>DPI_IRPTL</code> 寄存器一样的数据。</p></li>\n<li><p>对DAI/DPI影子寄存器的读取不会改变核心中断控制器（core interrupt controller）对中断的确认状态。</p></li>\n</ul>\n<h2 id=\"术语总结\">术语总结</h2>\n<p>中断确认</p>\n<p>中断请求</p>\n<p>中断服务</p>\n<p>中断延迟</p>\n<h1 id=\"sport\">SPORT</h1>\n<p>对所有SPORT的研究仅限于对I2S开发中需要的研究。</p>\n<p>首先，SPORT是指Serial Port，即串行接口。有0 ~ 7 共8个这样的SPORT。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210629151248.png\" alt=\"image-20210629151245935\" /><figcaption aria-hidden=\"true\">image-20210629151245935</figcaption>\n</figure>\n<p>如果需要用到I2S模式，则需要针对 <code>SPCTLx</code> 和 <code>SPMCTLx</code> 两个寄存器中的某些位做单独设置，其设置指引表格如下 ：</p>\n<p><img src=\"https://pic.islet.space/2021/06/20210629151016.png\" alt=\"image-20210629150923785\" style=\"zoom:80%;\" /></p>\n<h2 id=\"spctl\">SPCTL</h2>\n<p>SPCTL 寄存器在多种模式下具有不同的位定义。</p>\n<h3 id=\"寄存器位指示\">寄存器位指示</h3>\n<p><img src=\"https://pic.islet.space/2021/06/20210629162516.png\" alt=\"image-20210629162509309\" style=\"zoom: 80%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/06/20210629162554.png\" alt=\"image-20210629162550029\" style=\"zoom:80%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/06/20210629162731.png\" alt=\"image-20210629162728195\" style=\"zoom:80%;\" /></p>\n<h3 id=\"寄存器位说明\">寄存器位说明</h3>\n<p><img src=\"https://pic.islet.space/2021/06/20210629172559.png\" alt=\"image-20210629172318405\" style=\"zoom: 67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/06/20210629172604.png\" alt=\"image-20210629172412087\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/06/20210629172610.png\" alt=\"image-20210629172430662\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/06/20210629172614.png\" alt=\"image-20210629172455121\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/06/20210629172619.png\" alt=\"image-20210629172510903\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/06/20210629172625.png\" alt=\"image-20210629172534214\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/06/20210629172628.png\" alt=\"image-20210629172549089\" style=\"zoom:67%;\" /></p>\n<h2 id=\"spctlnx\">SPCTLNx</h2>\n<p><strong><em>FE</em></strong>: frame edge 帧边沿</p>\n<p><strong><em>FS</em></strong>: frame sync 帧同步</p>\n<blockquote>\n<p>These registers (where x signifies SPORT 0 through 7) allow programs to <mark>set frame sync edge detection for I2S compatibility</mark>. These registers also <mark>allow interrupts to be generated</mark> when transmit DMA count is expired or when the last bit of last word is shifted out.</p>\n</blockquote>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/image-20210630162335568.png\" alt=\"image-20210630162335568\" /><figcaption aria-hidden=\"true\">image-20210630162335568</figcaption>\n</figure>\n<p>注意：212XX系列和213xx系列芯片上并没有这个寄存器。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/image-20210630162415539.png\" alt=\"image-20210630162415539\" /><figcaption aria-hidden=\"true\">image-20210630162415539</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/image-20210630162442482.png\" alt=\"image-20210630162442482\" /><figcaption aria-hidden=\"true\">image-20210630162442482</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/image-20210630162505383.png\" alt=\"image-20210630162505383\" /><figcaption aria-hidden=\"true\">image-20210630162505383</figcaption>\n</figure>\n<h2 id=\"spmctlx\">SPMCTLx</h2>\n<p>串行接口多通道控制寄存器，Serial ports multichannel control registers</p>\n<p>在214xx系列芯片中，该寄存器独立工作，并不成对操作；因此每一个SPORT都有其独立的多通道控制寄存器，所以只需要向两个SPMCTLx寄存器写一次，就可以将SPORT作为一对来操作。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/image-20210630162916913.png\" alt=\"image-20210630162916913\" /><figcaption aria-hidden=\"true\">image-20210630162916913</figcaption>\n</figure>\n<p>其中，x表示0、2、4、6，y表示1、3、5、7。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/image-20210630163319226.png\" alt=\"image-20210630163319226\" /><figcaption aria-hidden=\"true\">image-20210630163319226</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/image-20210630163357041.png\" alt=\"image-20210630163357041\" /><figcaption aria-hidden=\"true\">image-20210630163357041</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/image-20210630163451919.png\" alt=\"image-20210630163451919\" /><figcaption aria-hidden=\"true\">image-20210630163451919</figcaption>\n</figure>\n<h1 id=\"dma\">DMA</h1>\n<blockquote>\n<p>DMA(Direct Memory Access，直接存储器访问) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。否则，CPU 需要从来源把每一片段的资料复制到暂存器，然后把它们再次写回到新的地方。在这个时间中，CPU 对于其他的工作来说就无法使用。</p>\n</blockquote>\n<p>CPU和DMA控制器对内存的访问是交替进行的，因为对内存的访问涉及到总线控制，而DMA控制器和CPU在同一时刻仅有一个能获取总线控制权。更具体的DMA控制器与CPU工作方式见下方 <em>传送方式</em>。</p>\n<blockquote>\n<p>DMA传输方式无需CPU直接控制传输，也没有中断处理方式那样保留现场和恢复现场过程，通过硬件为RAM和IO设备开辟一条直接传输数据的通道，使得CPU的效率大大提高。</p>\n</blockquote>\n<p>DMA 传输将数据从一个地址空间复制到另外一个地址空间。当CPU 初始化这个传输动作，传输动作本身是由 DMA 控制器来实行和完成。典型的例子就是移动一个外部内存的区块到芯片内部更快的内存区。像是这样的操作并没有让处理器工作拖延，反而可以被重新排程去处理其他的工作。DMA 传输对于高效能 嵌入式系统算法和网络是很重要的。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/format,f_auto.jpeg\" alt=\"DMA\" /><figcaption aria-hidden=\"true\">DMA</figcaption>\n</figure>\n<p>在实现DMA传输时，是由 <strong><em>DMA控制器</em></strong> 直接掌管总线，因此，存在着一个总线控制权转移问题。即DMA传输前，CPU要把总线控制权交给DMA控制器，而在结束DMA传输后，DMA控制器应立即把总线控制权再交回给CPU。一个完整的DMA传输过程必须经过 <strong>DMA请求</strong>、<strong>DMA响应</strong>、<strong>DMA传输</strong>、<strong>DMA结束</strong> 4个步骤。</p>\n<blockquote>\n<p><strong>请求</strong>：CPU对DMA控制器初始化，并向I/O接口发出操作命令，I/O接口提出DMA请求。</p>\n<p><strong>响应</strong>：DMA控制器对DMA请求判别优先级及屏蔽，向总线裁决逻辑提出总线请求。当CPU执行完当前总线周期即可释放总线控制权。此时，总线裁决逻辑输出总线应答，表示DMA已经响应，通过DMA控制器通知I/O接口开始DMA传输。</p>\n<p><strong>传输</strong>：DMA控制器获得总线控制权后，CPU即刻挂起或只执行内部操作，由DMA控制器输出读写命令，直接控制RAM与I/O接口进行DMA传输。在DMA控制器的控制下，在存储器和外部设备之间直接进行数据传送，在传送过程中不需要中央处理器的参与。开始时需提供要传送的数据的起始位置和数据长度。</p>\n<p><strong>结束</strong>：当完成规定的成批数据传送后，DMA控制器即释放总线控制权，并向I/O接口发出结束信号。当I/O接口收到结束信号后，一方面停 止I/O设备的工作，另一方面向CPU提出中断请求，使CPU从不介入的状态解脱，并执行一段检查本次DMA传输操作正确性的代码。最后，带着本次操作结果及状态继续执行原来的程序。</p>\n</blockquote>\n<p>由此可见，DMA传输方式无需CPU直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件为RAM与I/O设备开辟一条直接传送数据的通路，使CPU的效率大为提高。</p>\n<h2 id=\"传送原理\">传送原理</h2>\n<p>DMA技术的出现，使得外围设备可以通过DMA控制器直接访问内存，与此同时，CPU可以继续执行程序。那么DMA控制器与CPU怎样 <mark>分时使用内存</mark> 呢?通常采用以下三种方法：</p>\n<ol type=\"1\">\n<li><p>停止CPU访问内存；</p></li>\n<li><p>周期挪用；</p></li>\n<li><p>DMA与CPU交替访问内存。</p></li>\n</ol>\n<h3 id=\"停止cpu访问内存\">停止CPU访问内存</h3>\n<p>当外围设备要求传送一批数据时，由DMA控制器发一个停止信号给CPU，要求CPU放弃对地址总线、数据总线和有关控制总线的使用权。DMA控制器获得总线控制权以后，开始进行数据传送。在一批数据传送完毕后，DMA控制器通知CPU可以使用内存，并把总线控制权交还给CPU。图(a)是这种传送方式的时间图。很显然，在这种DMA传送过程中，CPU基本处于不工作状态或者说保持状态。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/image-20210630135714198.png\" alt=\"image-20210630135714198\" /><figcaption aria-hidden=\"true\">image-20210630135714198</figcaption>\n</figure>\n<p><strong>优点</strong>: 控制简单，它适用于数据传输率很高的设备进行成组传送。</p>\n<p><strong>缺点</strong>: <mark>在DMA控制器访问内存阶段，内存的效能没有充分发挥，相当一部分内存工作周期是空闲的</mark>。这是因为，<mark>外围设备传送两个数据之间的间隔一般总是大于内存存储周期，即使高速I/O设备也是如此</mark>。例如，软盘读出一个8位二进制数大约需要32us，而半导体内存的存储周期小于0.5us，因此许多空闲的存储周期不能被CPU利用。</p>\n<h3 id=\"周期挪用\">周期挪用</h3>\n<p>当I/O设备没有DMA请求时，CPU按程序要求访问内存；一旦I/O设备有DMA请求，则由I/O设备挪用一个或几个 <strong>内存周期</strong>。这种传送方式的时间图如下图(b)：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/image-20210630135800538.png\" alt=\"image-20210630135800538\" /><figcaption aria-hidden=\"true\">image-20210630135800538</figcaption>\n</figure>\n<p>I/O设备要求DMA传送时可能遇到两种情况： 1. 此时CPU不需要访内，如CPU正在执行乘法指令。由于乘法指令执行时间较长，此时<mark>I/O访内与CPU访内没有冲突，即I/O设备挪用一二个内存周期对CPU执行程序没有任何影响</mark>。</p>\n<ol start=\"2\" type=\"1\">\n<li>I/O设备要求访内时CPU也要求访内，这就产生了访内冲突，在这种情况下<mark>I/O设备访内优先，因为I/O访内有时间要求，前一个I/O数据必须在下一个访问请求到来之前存取完毕</mark>。显然，在这种情况下I/O 设备挪用一二个内存周期，意味着CPU延缓了对指令的执行，或者更明确地说，在CPU执行访内指令的过程中插入DMA请求，挪用了一二个内存周期。 与停止CPU访内的DMA方法比较，周期挪用的方法既实现了I/O传送，又较好地发挥了内存和CPU的效率，是一种广泛采用的方法。但是I/O设备每一次周期挪用都有申请总线控制权、建立线控制权和归还总线控制权的过程，所以传送一个字对内存来说要占用一个周期，但对DMA控制器来说一般要2—5个内存周期(视逻辑线路的延迟而定)。因此，周期挪用的方法适用于I/O设备读写周期大于内存存储周期的情况。</li>\n</ol>\n<h3 id=\"dma与cpu交替访问内存\">DMA与CPU交替访问内存</h3>\n<p>如果CPU的工作周期比内存存取周期长很多，此时采用交替访内的方法可以使DMA传送和CPU同时发挥最高的效率。这种传送方式的时间图如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/image-20210630135821665.png\" alt=\"image-20210630135821665\" /><figcaption aria-hidden=\"true\">image-20210630135821665</figcaption>\n</figure>\n<p>此图是DMA与CPU交替访内的详细时间图．假设CPU工作周期为1.2us，内存存取周期小于0.6us，那么一个CPU周期可分为C1和C2两个分周期，其中C1专供DMA控制器访内，C2专供CPU访内。</p>\n<p>这种方式不需要总线使用权的申请、建立和归还过程，总线使用权是通过C1和C2分时制的。<mark>CPU和DMA控制器各自有自己的访内地址寄存器、数据寄存器和读/写信号等控制寄存器</mark>。在C1周期中，如果DMA控制器有访内请求，可将地址、数据等信号送到总线上。在C2周期中，如CPU有访内请求，同样传送地址、数据等信号。事实上，对于总线，这是用C1，C2控制的一个多路转换器，这种总线控制权的转移几乎不需要什么时间，所以对DMA传送来讲效率是很高的。</p>\n<p>这种传送方式又称为 <strong><em>透明的DMA</em></strong> 方式，其来由是这种DMA传送对CPU来说，如同透明的玻璃一般，没有任何感觉或影响。在透明的DMA方式下工作，CPU既不停止主程序的运行，也不进入等待状态，是一种高效率的工作方式。当然，相应的硬件逻辑也就更加复杂。</p>\n<h2 id=\"adsp芯片中的dma\">ADSP芯片中的DMA</h2>\n<p>此处仅以《HWR》文件做参考。</p>\n<ol type=\"1\">\n<li>外围设备可以通过DMA（控制器）访问缓存，但其逻辑操作会有所区别。</li>\n<li>在DMA中，缓存器状态与中断没有差别。相反，不管是否归零，DMA计数寄存器都会生成一个中断。</li>\n<li>DMA控制器的确认机制与外设不同。</li>\n<li>外部接口拥有两个可以控制 <strong>SDRAM/DDR2</strong> 或 <strong>异步内存接口</strong>（AMI，Asynchronous Memory Interface）的DMA通道。AMI控制器通过额外的8/16bits数据宽度以支持DMA；SDRAM/DDR2 通过额外的16bits数据宽度以支持DMA。</li>\n<li>外部接口DMA通过不同的寻址类型（由内向外或由内向内）以支持两种不同的DMA通道。</li>\n</ol>\n<h2 id=\"external-ports\">External ports</h2>\n<p><strong>外部接口</strong>（External ports）具有以下特征：</p>\n<ol type=\"1\">\n<li>支持两种DMA通道</li>\n<li>支持4种模式：<strong>标准模式</strong>、可以自由选择方向的<strong>链式模式</strong>（chained mode）、<strong>点选列表模式</strong>（tap list mode）(Scatter 或 Gather)、<strong>延迟线模式</strong>（delay line mode）(写入以读取)</li>\n<li>所有以上模式可以循环运行（operate in circular fashion）；且在循环模式下，一些模式允许回写索引指针，以正确寻址下一个传输控制块（TCB）</li>\n<li>支持<strong>由内向外 </strong>或 <strong>由内向内</strong>寻址。</li>\n</ol>\n<h3 id=\"寻址\">寻址</h3>\n<p>外部接口DMA不仅支持由内向外寻址，还支持由内向内寻址。通过所有外部参数寄存器的内部地址索引以完成该项任务。DMA控制器通过地址以辨别传输（工作）而不是通过额外的控制位设置（control bit setting）。</p>\n<p><strong>注意</strong>：如果使用内部或外部索引地址，DMA通道的优先级将会改变。</p>\n<p>SHARC芯片支持另一种具有更高优先级，但是只支持标准DMA模式的索引模式，即由内向内的DMA索引模式。</p>\n<p><strong>注意</strong>：DMAC，即Directory Memory Access Control (Rigister)，直接内存访问控制寄存器。</p>\n<h1 id=\"tcb\">TCB</h1>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* TCB = &quot;Transfer Control Block&quot; */</span></span><br><span class=\"line\"><span class=\"comment\">/* TCB format:    ECx (length of destination buffer),</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t  EMx (destination buffer step size),</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t  EIx (destination buffer index (initialized to start address)),</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t  GPx (&quot;general purpose&quot;),</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t  CPx (&quot;Chain Point register&quot;; points to last address (IIx) of next TCB to jump to upon completion of this TCB.),</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t  Cx  (length of source buffer),</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t  IMx (source buffer step size),</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t  IIx (source buffer index (initialized to start address))       */</span></span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210701013537361.png\" alt=\"image-20210701013537361\" /><figcaption aria-hidden=\"true\">image-20210701013537361</figcaption>\n</figure>\n<p><img src=\"https://pic.islet.space/2021/06/20210629172133.png\" alt=\"image-20210629155207745\" style=\"zoom:80%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/06/20210629172128.png\" alt=\"image-20210629160318759\" style=\"zoom: 80%;\" /></p>\n<h1 id=\"others\">Others</h1>\n<h2 id=\"dmatcbsport之间的关系\">DMA、TCB、SPORT之间的关系</h2>\n<p>DMA，Directly Memory Access，直接内存访问。</p>\n<p>TCB，Transfer Control Block，传输控制块。</p>\n<p>SPORT，Serial Port，串行接口。</p>\n<p>Serial Peripheral ，即串行外设。</p>\n<h2 id=\"clockarbitrationpllprescale\">Clock、Arbitration、PLL、prescale</h2>\n<p>《HWR》第884页——PLL</p>\n<p>PCLK</p>\n<p>CLKIN</p>\n<h2 id=\"latency\">LATENCY</h2>\n<h3 id=\"twi-效果延迟时间\">TWI 效果延迟（时间）</h3>\n<p>在TWI寄存器设置后，其效果延迟大概是 1.5到2个PCLK周期。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210525153905.png\" alt=\"image-20210525153855627\" /><figcaption aria-hidden=\"true\">image-20210525153855627</figcaption>\n</figure>\n<h2 id=\"asmnop\">ASM(\"NOP\")</h2>\n<p><a href=\"https://blog.csdn.net/Mr_White01/article/details/68488802#:~:text=asm%20(“nop”)是内嵌汇编做空指令延时用的，其中asm%20()的作用是指函数内部的参数翻译为汇编指令，其作用是在C语言环境下直接使用汇编指令执行。%20nop是一个空等待汇编指令，这个指令执行时，单片机是什么也不做，仅仅起一个时间延时作用。,CC2530属于8051系列单片机，asm%20(“nop”)执行的是一条空指令（单周期指令），占用时间是一个机器周期，晶振为32Mhz。%20于是，机器周期%3D12*1%2F32%3D0.375us。%20即一句asm%20(“nop”)延时了0.375us。\">blog.csdn.net</a></p>\n<h3 id=\"asm作用\">asm()作用</h3>\n<p>将函数内部的参数翻译为汇编指令，在C语言环境下直接使用汇编指令执行。</p>\n<ul>\n<li><p><code>asm(\"nop\")</code>是内嵌汇编做空指令延时用的；</p></li>\n<li><p><code>nop</code>是一个空等待汇编指令，这个指令执行时，单片机是什么也不做，仅仅起一个时间延时作用。</p></li>\n</ul>\n<blockquote>\n<p>CC2530属于8051系列单片机，asm(“nop”)执行的是一条空指令（单周期指令），占用时间是一个机器周期，晶振为32Mhz。</p>\n<p>于是，机器周期=12*1/32=0.375us ; 即一句asm(“nop”)延时了0.375us。</p>\n</blockquote>\n<h3 id=\"时钟周期\">时钟周期</h3>\n<p>时钟周期也称为振荡周期，定义为时钟脉冲的倒数(可以这样来理解，时钟周期就是单片机外接晶振的倒数，例如12M的晶振，它的时间周期就是1/12 us)，是计算机中最基本的、最小的时间单位。</p>\n<p>在一个时钟周期内，CPU仅完成一个最基本的动作。对于某种单片机，若采用了1MHZ的时钟频率，则时钟周期为1us;若采用4MHZ的时钟频率，则时钟 周期为250us。由于时钟脉冲是计算机的基本工作脉冲，它控制着计算机的工作节奏(使计算机的每一步都统一到它的步调上来)。显然，对同一种机型的计算机，时钟频率越高，计算机的工作速度就越快。具体计算就是1/fosc。也就是说如果晶振为1MHz，那么时钟周期就为1us；6MHz的话，就是1/6us。</p>\n<p>8051单片机把一个时钟周期定义为一个节拍(用P表示)，二个节拍定义为一个状态周期(用S表示)。</p>\n<h3 id=\"机器周期\">机器周期</h3>\n<p>在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶段，每一阶段完成一项工作。例如，取指令、存储器读、存储器写等，这每一项工作称为一个基本操作。完成一个基本操作所需要的时间称为机器周期。一般情况下，一个机器周期由若干个S周期(状态周期)组成。</p>\n<p>8051系列单片机的一个机器周期同6个 S周期(状态周期)组成。前面已说过一个时钟周期定义为一个节拍(用P表示)，二个节拍定义为一个状态周期(用S表示)，8051单片机的机器周期由6个 状态周期组成，也就是说一个机器周期=6个状态周期=12个时钟周期。 具体计算为：时钟周期 X cycles。如果单片机是12周期的话，那么机器周期就是T×12。假设晶振频率为12M，单片机为12周期的话，那么机器周期就是1us。</p>\n<p>例如外接24M晶振的单片机，他的一个机器周期=12/24M 秒；52系列单片机一个机器周期等于12个时钟周期。设晶振频率为12MHz时，52单片机是12T的单片机，即频率要12分频。12M经过分频变为1M，由T=1/f,即一个机器周期变为1us。</p>\n<h3 id=\"指令周期\">指令周期</h3>\n<p>执行一条指令所需要的时间，一般由若干个机器周期组成。指令不同，所需的机器周期也不同。通常，包含一个机器周期的指令成为单周期指令，比如CLR,MOV等等。包含两个机器周期的指令称为双周期指令。另外还有4周期指令，比如乘法和除法指令。对于一些简单的的单字节指令，在取指令周期中，指令取出到指令寄存器后，立即译码执行，不再需要其它的机器周期。对于一些比较复杂的指令，例如转移指令、乘法指令，则需要两个或者两个以上的机器周期。</p>\n<h3 id=\"总线周期\">总线周期</h3>\n<p>由于存贮器和I/O端口是挂接在总线上的，CPU对存贮器和I/O接口的访问，是通过总线实现的。通常把CPU通过总线对微处理器外部(存贮器或 I/O接口)进行一次访问所需时间称为一个总线周期。</p>\n<p>总结一下，时钟周期是最小单位，机器周期需要1个或多个时钟周期，指令周期需要1个或多个机器周期;机器周期指的是完成一个基本操作的时间，这个基本操作有时可能包含总线读写，因而包含总线周期，但是有时可能与总线读写无关，所以，并无明确的相互包含的关系。 指令周期：是CPU的关键指标，指取出并执行一条指令的时间。一般以机器周期为单位，分单指令执行周期、双指令执行周期等。现在的处理器的大部分指令(ARM、DSP)均采用单指令执行周期。机器周期：完成一个基本操作的时间单元，如取指周期、取数周期。时钟周期：CPU的晶振的工作频率的倒数。</p>\n<h2 id=\"问题\">问题</h2>\n<p>个人对TWI作为主设备时，数据的发送流程框图的理解如下：</p>\n<ul>\n<li>TWI在需要发送数据时，才生成TWI时钟信号，通过SCLK线（对应评估板上的 <strong><em>DPI11</em></strong>， 以及下图的 <strong><em>TWI_CLK_PBEN_O</em></strong> ）输出。</li>\n<li>需要传输的数据通过TWI接口写入FIFO中（对应的寄存器是<code>TXTWI8</code> ），并通过SDA线（对应21479评估板上的 <strong><em>DPI12</em></strong> , 以及下图的 <strong><em>TWI_DATA_PBEN_O</em></strong> ）输出，从机收到数据后通过SDA线（对应下图的 <strong><em>TWI_DATA_ I</em></strong>）返回确认（ACK）信息。\n<ul>\n<li>在 <code>TWIIRPTL</code> 寄存器中，<code>TWIMCOM</code> 位为1则指示TWI初始化完毕，<code>TWITXINT</code> 为1则指示FIFO寄存器有空位，如果为0则说明 <code>TWIFIFOSTAT</code> 寄存器中的 <code>TWITXS</code> 位没有变化，即数据无法通过SDA发送出去；<code>TWIMERR</code> 则指示主设备传输过程中存在错误，具体错误需要查看 <code>TWIMSTAT</code> 寄存器。</li>\n</ul></li>\n<li>查看 <code>TWIMSTAT</code> 寄存器可知，<code>TWIMSTAT_REER</code> 位为1，该位为1则指示传输缓冲区读取错误，传输移位寄存器需要数据而缓冲区为空。</li>\n<li>检查显示，<code>TXTWI8</code> 写入存在问题，写入语句 <code>*pTXTWI8 = 0xAA;</code> 执行后，观察寄存器窗口查看到数据仍为0x00。</li>\n</ul>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210607155909.png\" alt=\"image-20210607155906359\" /><figcaption aria-hidden=\"true\">image-20210607155906359</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/20210607163901.png\" alt=\"image-20210607163859502\" /><figcaption aria-hidden=\"true\">image-20210607163859502</figcaption>\n</figure>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li><a href=\"https://baike.baidu.com/item/DMA/2385376\">DMA</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/138573828\">DMA原理介绍</a></li>\n</ol>\n","categories":["Hardware"],"tags":["ADI","21478","21479","register"]},{"title":"ADSP混合编程","url":"/2021/06/30/Hardware/DSP/2021-06-30-ADSP%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/","content":"<h1 id=\"伪操作和伪指令\">伪操作和伪指令</h1>\n<p><strong><em>Directives</em></strong>，即 <strong>伪操作</strong>，是汇编语言中的特殊指令助记符。主要作用是为完成汇编程序做各种准备。伪操作仅是在源程序进行汇编时由汇编程序处理，而不是在计算机运行期间由机器执行的指令。即，伪操作只在汇编时起作用，一旦汇编结束，其使命也就结束了。</p>\n<p><strong><em>Pseudo-Instruction</em></strong>，即 <strong><em>伪指令</em></strong>，是汇编语言程序里的特殊指令助记符，不是 真指令。伪指令在汇编时被替换成合适的机器指令（根据芯片架构而定，不同芯片架构之间指令可能不同），故其也只在汇编时其作用，不在机器运行期间由机器执行。</p>\n<h1 id=\"adi汇编文件样式\">ADI汇编文件样式</h1>\n<p>.asm 文件具有以下样式，包含 <strong><em>预处理指令</em></strong>（主要是C/C++宏定义）、汇编伪操作类别（assembler direcitives）、数据块、代码块、条件编译预处理 和 汇编标签。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/image-20210630170546778.png\" alt=\"image-20210630170546778\" /><figcaption aria-hidden=\"true\">image-20210630170546778</figcaption>\n</figure>\n<h2 id=\"混合编程\">混合编程</h2>\n<h3 id=\"使用asm\">使用asm()</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> img288; <span class=\"comment\">//定义C语言变量</span></span><br><span class=\"line\"><span class=\"keyword\">asm</span>(<span class=\"string\">&quot;ax0 = 0x5C;&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">asm</span>(<span class=\"string\">&quot;dm(img288_) = ax0;&quot;</span>);  <span class=\"comment\">//用汇编语言赋值时，变量需要加后置下划线？？？</span></span><br><span class=\"line\">img288 = <span class=\"number\">0x5C</span>;  <span class=\"comment\">//直接用C语言赋值</span></span><br></pre></td></tr></table></figure>\n<p>以上C语言与汇编代码经过编译后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ax0 &#x3D; 0x5C;</span><br><span class=\"line\">dm(img288_) &#x3D; ax0;</span><br><span class=\"line\">my1 &#x3D; 92;</span><br><span class=\"line\">dm(img288_) &#x3D; my1;</span><br></pre></td></tr></table></figure>\n<p><mark>此处可否把 <code>dm()</code> 当成一个类似于指针的东西</mark></p>\n<h3 id=\"使用汇编子程序\">使用汇编子程序</h3>\n<p>使用汇编子程序是C语言程序与汇编语言接口的另一种方法。<mark>用户定义的子程序放在单独的汇编文件中，或是做成二进制的库文件，并将子程序的定义用GLOBEL输出，汇编后就可以供C语言程序调用</mark>。下面是一个不需要参数的子程序的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.MODULE&#x2F;RAM_delay_;</span><br><span class=\"line\">.external del_cycle;  &#x2F;&#x2F;声明del_cycle是外部变量</span><br><span class=\"line\">.global delay;  &#x2F;&#x2F;声明delay是全局变量</span><br><span class=\"line\"></span><br><span class=\"line\">delay_:</span><br><span class=\"line\">function_entry;  &#x2F;&#x2F;子程序开始标志，必不可少</span><br><span class=\"line\">ar &#x3D; dm(del_cycle_);</span><br><span class=\"line\">cntr &#x3D; ar;</span><br><span class=\"line\">do d_loop until ce;</span><br><span class=\"line\">d_loop:nop;</span><br><span class=\"line\">exit;  &#x2F;&#x2F;子程序结束标志，必不可少</span><br><span class=\"line\">.ENDMOD;</span><br></pre></td></tr></table></figure>\n<p>注意：以上代码源自参考链接4，实际上代码中的关键字相差可能较大，需要根据实际情况进行改动。</p>\n<p>比如，21479系列芯片与ADAU1939芯片一同工作，其ADC采样代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.section&#x2F;pm seg_pmco;  &#x2F;&#x2F;程序代码块，procedure memory section</span><br><span class=\"line\"></span><br><span class=\"line\">_Receive_ADC_Samples:  &#x2F;*应该类似于 &#123; *&#x2F;</span><br><span class=\"line\">.global _Receive_ADC_Samples;  &#x2F;&#x2F;定义自己为全局函数</span><br><span class=\"line\"></span><br><span class=\"line\">\tr1 &#x3D; -31;     </span><br><span class=\"line\">\tr0 &#x3D; dm(_rx1a_buf + Internal_ADC_L1);\t</span><br><span class=\"line\">\tf0 &#x3D; float r0 by r1;\t</span><br><span class=\"line\">\tdm(_Left_Channel_In1) &#x3D; r0;</span><br><span class=\"line\">  </span><br><span class=\"line\">\tr0 &#x3D; dm(_rx1a_buf + Internal_ADC_R1);\t</span><br><span class=\"line\">\tf0 &#x3D; float r0 by r1;\t</span><br><span class=\"line\">\tdm(_Right_Channel_In1) &#x3D; r0;\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tr0 &#x3D; dm(_rx1b_buf + Internal_ADC_L2);\t</span><br><span class=\"line\">\tf0 &#x3D; float r0 by r1;\t</span><br><span class=\"line\">\tdm(_Left_Channel_In2) &#x3D; r0;\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tr0 &#x3D; dm(_rx1b_buf + Internal_ADC_R2);\t</span><br><span class=\"line\">\tf0 &#x3D; float r0 by r1;\t</span><br><span class=\"line\">\tdm(_Right_Channel_In2) &#x3D; r0;\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tr0 &#x3D; DM(AD1939_audio_frame_timer);</span><br><span class=\"line\">\tr0 &#x3D; r0 + 1;</span><br><span class=\"line\">\tDM(AD1939_audio_frame_timer) &#x3D; r0;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tleaf_exit;  &#x2F;&#x2F;程序结束标志，应该类似于return;吧</span><br><span class=\"line\">_Receive_ADC_Samples.end:  &#x2F;*应该类似于 &#125;*&#x2F;</span><br></pre></td></tr></table></figure>\n<h1 id=\"dual-memory-support-keywords-dm-pm\">Dual Memory Support Keywords (dm / pm)</h1>\n<p>This section describes <strong><em>cc21k</em></strong> language extension keywords to C and C++ that support the dual-memory space, modified Harvard architecture of the ADSP-21xxx processors. There are two keywords used to designate memory space: <strong><em>dm</em></strong> and <strong><em>pm</em></strong>. They can be used to specify the location of a static or global variable or to qualify a pointer declaration.</p>\n<p>以下规则适用于两种内存关键字（dm/pm）：</p>\n<ul>\n<li>The memory space keyword (dm or pm) refers to the expression to the right of the keyword.</li>\n<li>You can specify a memory space for each level of pointer. This corresponds to one memory space for each * in the declaration.</li>\n<li>The compiler uses <strong><em>Data Memory</em></strong> (DM) as the default memory space for all variables. All undeclared spaces for data are Data Memory spaces.</li>\n<li>The compiler always uses <strong><em>Program Memory</em></strong> (PM) as the memory space for functions. Function pointers always point to Program Memory.</li>\n<li>You cannot assign memory spaces to <strong><em>automatic variables</em></strong>. <mark>All automatic variables reside on the stack, which is always in Data Memory</mark>.</li>\n<li>Literal character strings always reside in Data Memory.</li>\n</ul>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li>《<a href=\"https://www.analog.com/media/en/dsp-documentation/software-manuals/50_21k_cc_mn_rev_1.5.pdf\">VisualDSP++ 5.0 C/C++ Compiler Manual for SHARC Processors</a>》</li>\n<li>《<a href=\"https://www.analog.com/media/en/dsp-documentation/processor-manuals/236999443isr_21xxx.pdf\">ADSP-21160 SHARC DSP Instruction Set Reference</a>》</li>\n<li>《嵌入式系统原理与应用设计》王光学，电子工业出版社</li>\n<li><a href=\"http://www.gzweix.com/article/sort0250/sort0251/sort0288/info-228197_2.html\">嵌入式C语言开发ADSP21XX系列</a></li>\n</ol>\n","categories":["Hardware"],"tags":["ADI","21479","register"]},{"title":"F280041PM开发笔记","url":"/2021/07/10/Hardware/DSP/2021-07-10-F280041PM%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","content":"<p>[TOC]</p>\n<h1 id=\"概述\">概述</h1>\n<h2 id=\"命名方法\">命名方法</h2>\n<p>TMS320F28004x 下称 本系列芯片，本系列设备型号命名方法：</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210719092842059.png\" alt=\"image-20210719092842059\" style=\"zoom:67%;\" /></p>\n<h2 id=\"开发手册\">开发手册</h2>\n<p>开发本系列芯片可能需要使用到的文件如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210724112707176.png\" alt=\"image-20210724112707176\" /><figcaption aria-hidden=\"true\">image-20210724112707176</figcaption>\n</figure>\n<p><strong>注意</strong>：下文中《TRM》 与《SPRUI33D》为同一份文件。</p>\n<h2 id=\"封装形式\">封装形式</h2>\n<p>C28004x 共有2种芯片封装形式： LQFP 和 VQFN 。VQFN 仅有56针，LQFP 有 100针和 64针的区别。分别用 PZ 、PM 和 RSH 三种型号尾缀与 100-pin 、64-pin 和 56-pin 相关联。根据section4.3，可以知道还有个64PMQ的尾缀。</p>\n<p>如型号TMS320F280041PM，仅有64针脚，引脚分布如下图所示：</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210710144933414.png\" alt=\"image-20210710144933414\" style=\"zoom:100%;\" /></p>\n<h1 id=\"specification\">Specification</h1>\n<p>下图应该是F280049的系统功能框图，与F280041PM仍有些出入。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210710141413564.png\" alt=\"image-20210710141413564\" /><figcaption aria-hidden=\"true\">image-20210710141413564</figcaption>\n</figure>\n<p><strong>注意</strong>：<span style=\"text-decoration: line-through\">F280041PM不支持 CLA（控制律加速器，Control Law Accelerator）</span>，Flash为128KB（64KW），GPIO数量为26，AIO数量为14，ADC通道为14，同时280041支持5个PGA</p>\n<p><strong>更正</strong>： F28004x系列均支持 CLA（控制律加速器，Control Law Accelerator），如《spru566n》中的下表示，支持type2型CLA。</p>\n<p>TMS320F28004x 所支持外设如下：</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210710142641475.png\" alt=\"image-20210710142641475\" style=\"zoom:110%;\" /></p>\n<blockquote>\n<p><strong>Q</strong>: 为什么要区分type？</p>\n<p><strong>A</strong>: 就同一类功能而言，在C2000系列上，都会有许多不同的增强/阉割版本，就出现了支持全部基础功能的、出现支持部分扩展功能的 和 支持全部扩展功能的等各种版本，那么就需要从功能范围的本质上去描述这些区别，再用相应的 “功能+type x” 的方式来表示其支持的类别。如下图所示，为《spru556n》page 24 所描述的关于CLA的功能类别。</p>\n<p><code>CLA type 0</code>，表示的是支持原始CLA功能的模块类型。</p>\n<p><code>CLA type 2</code> ，表示在原始功能的基础上，增加了后台代码模式，可以在后台运行通信和清理程序等任务；后台任务持续运行，直到禁用或设备/软复位；后台任务可以由外设或软件触发；其他前台任务可以按照定义的优先顺序中断后台任务；增加了使后台代码部分不被中断的规定；增加了调试功能，具有真正的软件断点支持，在调试停止期间，CLA从同一地址重新获取数据会被停止。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210712141632913.png\" alt=\"image-20210712141632913\" style=\"zoom: 67%;\" /></p>\n</blockquote>\n<p>贴一张 <strong><em>系统控制基础地址</em></strong> 的总表：<img src=\"https://pic.islet.space/2021/07/image-20210802135651683.png\" alt=\"image-20210802135651683\" /></p>\n<h2 id=\"引脚\">引脚</h2>\n<h3 id=\"引脚分配\">引脚分配</h3>\n<p>Page17 4.2 <strong><em>Pin Attributes</em></strong> 下可以查看各封装芯片引脚的名称、编号 及 功能。（共有10页左右，不粘贴了）</p>\n<h3 id=\"引脚路由\">引脚路由</h3>\n<p>Page30 4.3 <strong><em>Signal Routing</em></strong> 下可以查看引脚的路由信息。包括模拟引脚和数字引脚的复用信息。</p>\n<h3 id=\"引脚复用\">引脚复用</h3>\n<p>Page41 4.4 <strong><em>Pin Multiplexing</em></strong> 下可以查看引脚的复用信息，GPIO口的默认功能就是GPIO，除了GPIO35 和 GPIO37（默认情况下是TDI 和 TDO）。GPIO口的次级功能可以通过设置 <code>GPyGMUXn.GPIOz</code> 和 <code>GPyMUXn.GPIOz</code> 寄存器位来进行。</p>\n<p><strong>注意</strong>：</p>\n<ul>\n<li><code>GPyGMUXn</code> 寄存器应在 <code>GPyMUXn</code> 之前配置，以避免交替复用选择对GPIO产生瞬时脉冲。</li>\n<li>GPIO20 , GPIO21 和 GPIO41 至 GPIO55在任何封装上都不可复用。</li>\n</ul>\n<p>表6 为GPIO的针脚复用说明，表中未列明项为GPIO复用设置保留位。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210712094430159.png\" alt=\"image-20210712094430159\" /><figcaption aria-hidden=\"true\">image-20210712094430159</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210712094455163.png\" alt=\"image-20210712094455163\" /><figcaption aria-hidden=\"true\">image-20210712094455163</figcaption>\n</figure>\n<h3 id=\"引脚置高低\">引脚置高/低</h3>\n<p>部分引脚可以被置高/低，下表展示了各引脚的设置类型。默认情况下，GPIO不可置高，但是可以通过软件进行使能。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210712093251720.png\" alt=\"image-20210712093251720\" /><figcaption aria-hidden=\"true\">image-20210712093251720</figcaption>\n</figure>\n<h2 id=\"x-bar\">X-BAR</h2>\n<p><strong>X-BAR</strong> 即 Crossbar。</p>\n<p>X-BAR 包含四种，分别是 <strong>输入X-BAR</strong> 、 <strong>输出X-BAR</strong> 、 <strong>CLB X-BAR</strong> 和 <strong>ePWM X-BAR</strong>。每一种 X-BAR 都以其携带的信号命名，例如输入X-BAR携带外部信号“进入”芯片内部；输出X-BAR携带内部芯片信号“输出”至GPIO上；CLB和ePWM X-BAR 则对应其外设。</p>\n<h3 id=\"输入x-bar\">输入X-BAR</h3>\n<p>输入X-BAR被用于从GPIO口引导信号至许多不同的IP块，如ADC、eCAP、ePWM 和 外部中断。</p>\n<p>图5 展示了X-BAR的架构，表8 展示了各X-BAR输入可能的路由目的地。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210712095049189.png\" alt=\"image-20210712095049189\" /><figcaption aria-hidden=\"true\">image-20210712095049189</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210712095346292.png\" alt=\"image-20210712095346292\" /><figcaption aria-hidden=\"true\">image-20210712095346292</figcaption>\n</figure>\n<h3 id=\"clbepwm-和-输出x-bar\">CLB、ePWM 和 输出X-BAR</h3>\n<p>输出X-BAR有8个可以路由至各GPIO模块的输出口。ePWM X-BAR 有8个可以路由至各ePWM模块的输出口。</p>\n<p>图6 展示了 <strong>输出 X-BAR</strong> 和 <strong>ePWM X-BAR</strong> 的 信号源，这些信号源都是 <strong>内部外设</strong> 或者 <strong>输入X-BAR</strong> 的输出。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210712095838640.png\" alt=\"image-20210712095838640\" style=\"zoom:120%;\" /></p>\n<h4 id=\"clb-x-bar\">CLB X-BAR</h4>\n<p>暂略</p>\n<h4 id=\"epwm-x-bar\">ePWM X-BAR</h4>\n<p>ePWM X-BAR将是信号带到ePWM模块。特殊注意，ePWM X-BAR与每一个ePWM模块处理TZ和同步的数字比较器（Digital Compare）子模块相连。</p>\n<p><strong>注意</strong>：ePWM X-BAR的架构 与 GPIO输出X-BAR的架构 相同（除了 <strong>输出闩</strong> / <strong>输出锁存器</strong>（output latch））</p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210824141830457.png\" alt=\"image-20210824141830457\" style=\"zoom:80%;\" /></p>\n<p>ePWM X-BAR 拥有8个能够路由至每个ePWM模块的输出。图9-2仅展示了单条输出（Single Output）的架构，其他输出与上图一致。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210824142639712.png\" alt=\"image-20210824142639712\" /><figcaption aria-hidden=\"true\">image-20210824142639712</figcaption>\n</figure>\n<p><strong>配置流程</strong></p>\n<ol type=\"1\">\n<li>从表9-2中挑选出应该传递给PWM的信号，最多为每个mux（最多32个mux）选择一个信号。</li>\n<li>通过 <code>TRIPxMUX0TO15CFT</code> 和 <code>TRIPxMUX16TO31CFG</code> 寄存器选择每个mux的输入。</li>\n<li>为了将任意信号传递至ePWM，必须在 <code>TRIPxMUXENABLE</code> 寄存器中使能mux。</li>\n<li>所有已开启的mux会在被传递到对应ePWM的 TRIPx 信号前进行逻辑or操作。可以适当利用 <code>TRIPOUTINV</code> 寄存器地对信号进行取反操作（optionally invert）。</li>\n</ol>\n<h4 id=\"gpio-输出x-bar\">GPIO 输出X-BAR</h4>\n<p>GPIO 输出 X-BAR 将信号从设备内部带到GPIO引脚。图9-4展示了GPIO 输出 X-BAR的架构。X-BAR包含8个输出，且每个输出都包含至少1个 GPIO mux位置（at least one position on the GPIO mux），表示为 <code>OUTPUTXBARx</code> 。X-BAR允许 <strong>单个信号的选择</strong> 或者 <strong>最多32个信号的逻辑or操作</strong>。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210824143551921.png\" alt=\"image-20210824143551921\" /><figcaption aria-hidden=\"true\">image-20210824143551921</figcaption>\n</figure>\n<p>GPIO输出X-BAR也有8个能够路由至GPIO模块的输出。图9-4展示了单输出的架构，与其他剩余输出的架构一致。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210824143615399.png\" alt=\"image-20210824143615399\" /><figcaption aria-hidden=\"true\">image-20210824143615399</figcaption>\n</figure>\n<p><strong>配置流程</strong>：</p>\n<ol type=\"1\">\n<li>根据表9-4确定需要传递到GPIO的信号。最多为每个 <code>OUTPUTXBARx</code> 输出配置一个信号（on signal per mux）（最多32 mux）。</li>\n<li>通过 <code>OUTPUTxMUX0TO15CFG</code> 和 <code>OUTPUTxMUX16TO31CFG</code> 寄存器位每个mux选择输入。</li>\n</ol>\n<p>为了能够传递任何信号至GPIO，必须在 <code>OUTPUTxMUXENABLE</code> 寄存器中使能mux。所有已启用的mux将会在被传递到对应的 <code>OUTPUTx</code> 信号之前进行逻辑or操作。</p>\n<p>可以选择性的使用 <code>OUTPUTINV</code> 取反信号，</p>\n<h2 id=\"电压\">电压</h2>\n<p>本系列芯片支持以下三种之一的电源供应（在要求核心电压 <code>VDD = 1.2V</code> 的情况下）：</p>\n<ul>\n<li>外接电源（不支持56针RSH封装）</li>\n<li>内部 1.2V LDO电压整流器</li>\n<li>内部 1.2V 开关整流器</li>\n</ul>\n<p><strong>注意</strong>：必须使用同一个系统电压调节器来驱动VDDIO和VDDIO_SW。</p>\n<p>下方是有关两个电压调节器的详细描述：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210710154834139.png\" alt=\"image-20210710154834139\" /><figcaption aria-hidden=\"true\">image-20210710154834139</figcaption>\n</figure>\n<h2 id=\"复位\">复位</h2>\n<p>暂略</p>\n<h2 id=\"时钟\">时钟</h2>\n<p>设备时钟域为设备上的不同模块提供时钟输入支持，这些设备与派生时钟（derived clock）直接相连， 或通过额外的分频器连接。</p>\n<p>F28004x 支持 <strong>内源</strong> 和 <strong>外源</strong> 两种类型时钟。<strong>内源</strong> 即芯片自带的，上电即起振的内源性时钟。<strong>外源</strong> 即需要通过引脚外接配置的。</p>\n<p>下图展示了 本系列芯片支持的时钟系统框图，可以看到时钟源 有 <strong><em>INTOSC1</em></strong> / <strong><em>INTOSC2</em></strong> / <strong><em>X1(XTAL)</em></strong> 三个，由时钟源配置产生的时钟最终会产生 <strong><em>看门狗时钟</em></strong>、<strong><em>PLL系统时钟</em></strong>、<strong><em>芯片时钟</em></strong> 主要是这三种。其中 <strong><em>芯片时钟</em></strong> 又会 <em><u>进一步</u></em> 配置到给各种外设。</p>\n<p>外设的时钟使用也是有区别的，其中 <strong><em>SYSCLK</em></strong> 被 ePIE、RAMs、GPIOs 和 DCSM 所使用；<strong><em>PERx.LSPCLK</em></strong> 被 SCIs 和 SPIs 所使用；<strong><em>CAN-Bit-Clock</em></strong> 被 CAN总线使用（注意，此时必须使用外源时钟进行配置）；<strong><em>PERx.SYSCLK</em></strong> 被 剩余其他外设所使用。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210710155206953.png\" alt=\"image-20210710155206953\"  /></p>\n<p>下表 3-40 所示为《SPRUI33D》第173页 关于时钟配置相关的寄存器。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210726121525047.png\" alt=\"image-20210726121525047\" /><figcaption aria-hidden=\"true\">image-20210726121525047</figcaption>\n</figure>\n<h3 id=\"内源时钟\">内源时钟</h3>\n<blockquote>\n<p>At power-up, the device is clocked from an on-chip 10 MHz oscillator (INTOSC2). INTOSC2 is the primary internal clock source, and is the default system clock at reset. It is used to run the boot ROM and can be used as the system clock source for the application.</p>\n</blockquote>\n<p>下图展示了本系列芯片的时钟系统，本系列芯片支持两个独立的 <strong>内源时钟</strong>，直接映射为 <strong><em>INTOSC1</em></strong> 和 <strong><em>INTOSC2</em></strong> 。默认情况下，都会在芯片启动时开启，且 <strong><em>INTOSC2</em></strong> 才是 内源时钟的主时钟源，<strong>INTOSC1</strong> 是备用时钟源。<u>这一点可以手动修改</u>。</p>\n<p>芯片启动时，<strong><em>INTOSC2</em></strong> 以10MHz速率起振，为 ROM的启动做准备，且可以被配置为 系统时钟。</p>\n<p>即系统内部自带的内源时钟，<strong><em>INTOSCx</em></strong> ，可以在不外接晶振的情况下，仅用内源时钟即可驱动工作，且《sprui33》3.7.11中就以内源时钟 <strong><em>INTOSC2</em></strong> 为主时钟（仅有10MHz），讲述了系统运行时钟 <strong><em>SYSCLK</em></strong> （100MHz）的配置方法。</p>\n<p>注意：</p>\n<ul>\n<li><p>如果需要使用 CAN 外设，那么仅使用 <strong><em>INTOSCx</em></strong> 的频率是不足以达到CAN的频率要求的，必须使用外部时钟 <strong><em>XTAL</em></strong> 。</p></li>\n<li><p><mark style=\"font-weight: 900;\">在使用内源时钟时，用于接外源时钟的X1引脚必须通过一个 1KΩ的电阻接地。</mark></p></li>\n<li><p>与其他GPIO相比，<mark>GPIO18拥有不一样的电气特性</mark>，因为是可以被当做X2来使用的。</p></li>\n</ul>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210730085027137.png\" alt=\"image-20210730085027137\" /><figcaption aria-hidden=\"true\">image-20210730085027137</figcaption>\n</figure>\n<h4 id=\"看门狗\">看门狗</h4>\n<p>如图5-10所示，如果要启用看门狗，其速率最高与 <strong><em>INTOSC1</em></strong> 一致。</p>\n<h3 id=\"外源时钟\">外源时钟</h3>\n<p><span style=\"text-decoration-line: line-through;\">系统还可以使用 <strong><em>X1</em></strong> 或 <strong><em>X2</em></strong> 两个接口其中之一来连接 至 <strong>外部时钟</strong> 。</span></p>\n<p>外源时钟有两个接口，分别是 <strong><em>第41</em></strong>（<em>GPIO18_X2</em>） 和 <strong><em>第42</em></strong>（<em>X1</em>）。按照连接方式分类，可以分为 <strong>外源时钟模式</strong> 和 <strong>单端外源时钟模式</strong>：</p>\n<ul>\n<li>外源时钟模式时，<em>X1</em> 和 <em>X2</em> 都进行连接。进一步区分为 <strong>EC</strong>（外部晶振器，External Crystal）和 <strong>ER</strong>（外部谐振器，External Resonator）。</li>\n<li>单端外源时钟模式时，仅 <em>X1</em> 连接，<em>X2</em> 留空，VSS需要接地。</li>\n</ul>\n<p>图 5-12 至 5-14 展示了三种不同的外部时钟源电路：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210711172426297.png\" alt=\"image-20210711172426297\" /><figcaption aria-hidden=\"true\">image-20210711172426297</figcaption>\n</figure>\n<p><strong>注意</strong>：<mark>当 <strong><em>X1</em></strong> 接口被当作外源时钟接口使用时，X2接口不能被当做GPIO使用。仅当使用内源时钟时， <strong><em>X2</em></strong> 可以配置成 GPIO。</mark></p>\n<p>如下方所示，为 LaunchPad 硬件的时钟电路，其中 Boosterpack 是指 ？？？</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210730134835054.png\" alt=\"image-20210730134835054\" /><figcaption aria-hidden=\"true\">image-20210730134835054</figcaption>\n</figure>\n<p>需要使用到Boosterpack时，需要移除R35，在R31和R38上焊上0Ω的跨电阻连接器，下图为LaunchPad背面的镜像示意。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210730141929361.png\" alt=\"image-20210730141929361\" /><figcaption aria-hidden=\"true\">image-20210730141929361</figcaption>\n</figure>\n<p>从C2000WARE套件里的《MCU025A(001)_BOM.xls》可以找到launchpads板上的板载时钟一共有2个，分别是Y1和Y2。其中，与F280049只接相连的是Y2，为Crystal。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210730145344856.png\" alt=\"image-20210730145344856\" /><figcaption aria-hidden=\"true\">image-20210730145344856</figcaption>\n</figure>\n<h4 id=\"表格\">表格</h4>\n<p>表13 展示了（外部）输入时钟频率的范围要求</p>\n<p>表14 展示了（外部）晶体振荡器的电气特性</p>\n<p>表15 展示了X1的计时要求</p>\n<p>表16 展示了PLL锁定的时间</p>\n<p>表17 展示了内部时钟频率</p>\n<p>表18 展示了输出时钟XCLKOUT的开断性能</p>\n<p>表19 展示了（外部）晶体振荡器参数</p>\n<p>表20 展示了（外部）晶体振荡器的等效电阻要求</p>\n<p>表21 展示了（外部）晶体振荡器的电气特性</p>\n<p>表22 展示了（内部）晶体振荡器的电气特性</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210710155540889.png\" alt=\"image-20210710155540889\" /><figcaption aria-hidden=\"true\">image-20210710155540889</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210710160134644.png\" alt=\"image-20210710160134644\" /><figcaption aria-hidden=\"true\">image-20210710160134644</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210710160150517.png\" alt=\"image-20210710160150517\" /><figcaption aria-hidden=\"true\">image-20210710160150517</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210711172100592.png\" alt=\"image-20210711172100592\" /><figcaption aria-hidden=\"true\">image-20210711172100592</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210711173148615.png\" alt=\"image-20210711173148615\" /><figcaption aria-hidden=\"true\">image-20210711173148615</figcaption>\n</figure>\n<h3 id=\"pll计算方法\">PLL计算方法</h3>\n<p>下图展示了系统PLL的设置框图。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210710155140640.png\" alt=\"image-20210710155140640\"  /></p>\n<p>系统PLL（PLLSYSCLK）的计算方法：<code>PLLSYSCLK = OSCCLK * IMULT * FMULT / PLLSYSCLKDIV</code></p>\n<blockquote>\n<p>PLLSYSCLK : 输出时钟频率</p>\n<p>OSCCLK : 输入时钟频率</p>\n<p>IMULT : 整数倍频，取值范围为 [0, 127]</p>\n<p>FMULT : 分数倍频，取值范围为 [0 , 3]</p>\n<p>PLLSYSCLKDIV : 分频， 取值范围为 {0, 1, 2, 4, 6, 8, ..., 124, 126}</p>\n</blockquote>\n<h3 id=\"内源时钟配置方法\">内源时钟配置方法</h3>\n<p>需要注意的是，内源时钟配置时，X1需要通过一个1KΩ的电阻接地。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210730085027137.png\" alt=\"image-20210730085027137\" style=\"zoom:67%;\" /></p>\n<p>Once the application requirements are understood, a specific clock configuration can be determined. The default configuration is for <strong><em>INTOSC2</em></strong> to be used as the system clock (<strong><em>PLLSYSCLK</em></strong>) with a divider of 1.</p>\n<p>The following procedure can be used to set up the desired application configuration:</p>\n<ol type=\"1\">\n<li><p>Select the reference clock source (<strong><em>OSCCLK</em></strong>) by writing to <strong><em>CLKSRCCTL1.OSCCLKSRCSEL</em></strong>. To enable XTAL, follow the instructions in the previous sections.</p></li>\n<li><p>Select the reference clock source (<strong><em>OSCCLK</em></strong>) by writing to <strong><em>CLKSRCCTL1.OSCCLKSRCSEL</em></strong>. Allow at least 300 <em><u>NOP instructions</u></em> for this to take effect.</p></li>\n<li><p>Set up the system PLL if desired. TI recommends using the C2000Ware <code>SysCtl:setClock()</code> function for proper configuration of the PLL clock.</p></li>\n<li><p>Select the <strong><em>LSPCLK</em></strong> divider by writing to <strong><em>LOSPCP</em></strong>.</p></li>\n<li><p>If an alternate CAN bit clock is needed, select it by writing to <strong><em>CLKSRCCTL2.CANABCLKSEL</em></strong> and <strong><em>CLKSRCCTL2.CANBBCLKSEL</em></strong>.</p></li>\n<li><p>Enable the desired peripheral clocks by writing to the <strong><em>PCLKCRx</em></strong> registers.</p></li>\n</ol>\n<p>The system clock configuration can be changed at run time. Changing the <strong><em>OSCCLK</em></strong> source will automatically bypass the PLL and set the multiplier to zero. Changing the multiplier from one non-zero value to another will temporarily bypass the PLL until it re-locks.</p>\n<p><mark style=\"font-weight: 900;\">注意： At least a 300 CPU clock cycles delay is needed after OSSCLK source is changed. </mark></p>\n<h4 id=\"配置示例\">配置示例</h4>\n<p>以下为工作频率设置的样例，利用内源时钟 <code>10MHz</code> ，产生芯片满负工作频率 <code>100MHz</code> ：</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210715170724177.png\" alt=\"image-20210715170724177\"  /></p>\n<h4 id=\"配置代码\">配置代码</h4>\n<p><code>f28004x_examples.h</code> 文件中，包含了对 <code>IMULT</code> 、<code>FMULT</code> 、 <code>PLLSYSCLKDIV</code> 的变量宏定义。</p>\n<p>官方提供的PLL配置函数原型为：<code>void InitSysPll(Uint16 clock_source, Uint16 imult, Uint16 fmult, Uint16 divsel)</code> 。根据配置实例中的参数，函数调用时代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">InitSysPll(INT_OSC2, IMULT_19, FMULT_0pt25, PLLCLK_BY_1);</span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">InitSysPll(<span class=\"number\">0x00</span>, <span class=\"number\">0x13</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0x01</span>);</span><br></pre></td></tr></table></figure>\n<p>即 <code>10MHz * ( 19 + 1/4 ) / (2^1) = 96.25MHz</code>，最后的CPU工作频率为 96.25MHz，但由于内源时钟振荡器可能存在变化，CPU的工作时钟也存在 ±3% 的公差。</p>\n<h3 id=\"外部时钟配置方法\">外部时钟配置方法</h3>\n<p>下面配置步骤由《TRM》第104页提供，按照连接方式，将连接模式分为：<strong>外源时钟模式</strong> 和 <strong>单端外源时钟模式</strong></p>\n<p>两个模式仅在第2和第7个步骤有所区别，其余均相同。</p>\n<table>\n<colgroup>\n<col style=\"width: 50%\" />\n<col style=\"width: 50%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>外源时钟模式：<em>CRYSTAL</em> or <em>RESONATOR</em></th>\n<th>单端外源时钟模式：<em>OSCILLATOR</em></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>1. Clear the <code>XTALCR.OSCOFF</code> bit.</td>\n<td>1. Clear the <code>XTALCR.OSCOFF</code> bit.</td>\n</tr>\n<tr class=\"even\">\n<td>2. Wait for the crystal to power up. 1ms is the typical wait time but this depends on the crystal that is being used.</td>\n<td>2. Set the <code>XTALCR.SE</code> bit to enable <em>single-ended mode</em>.</td>\n</tr>\n<tr class=\"odd\">\n<td>3. Clear the X1 counter by writing a 1 to <code>X1CNT.CLR</code> and keep clearing until the X1 counter value in the <code>X1CNT</code> register is no longer saturated <code>1023 (0x3ff)</code>.</td>\n<td>3. Clear the X1 counter by writing a 1 to <code>X1CNT.CLR</code> and keep clearing until the X1 counter value in the <code>X1CNT</code> register is no longer saturated <code>1023 (0x3ff)</code>.</td>\n</tr>\n<tr class=\"even\">\n<td>4. Wait for the X1 counter value in the <code>X1CNT</code> register to reach <code>1023 (0x3ff)</code>.</td>\n<td>4. Wait for the X1 counter value in the <code>X1CNT</code> register to reach <code>1023 (0x3ff)</code>.</td>\n</tr>\n<tr class=\"odd\">\n<td>5. Repeat steps 3-4 three additional times.</td>\n<td>5. Repeat steps 3-4 three additional times.</td>\n</tr>\n<tr class=\"even\">\n<td>6. Select XTAL as the OSCCLK source by writing a <code>1</code> to <code>CLKSRCCTL1.OSCCLKSRCSEL</code>.</td>\n<td>6. Select XTAL as the OSCCLK source by writing a <code>1</code> to <code>CLKSRCCTL1.OSCCLKSRCSEL</code>.</td>\n</tr>\n<tr class=\"odd\">\n<td>7. Check the <code>MCLKSTS</code> bit in the <code>MCDCR</code> register. If it's set, the oscillator has not finished powering up, and more time is required:<br><strong><em>a.</em></strong> Clear the missing clock status by writing a <code>1</code> to <code>MCDCR.MCLKCLR</code>.<br><strong><em>b.</em></strong> Repeat steps 2-7. Do not reset the device. Doing so will power down the oscillator, which requires the procedure to be restarted from step 1.<br><strong><em>c.</em></strong> <mark style=\"font-style: italic;\">If the oscillator has not finished powering up in 10 milliseconds, there is a real clock failure.</mark></td>\n<td>7. Check the <code>MCLKSTS</code> bit in the <code>MCDCR</code> register. <mark style=\"font-style: italic;\">If it's set, either the external oscillator or the device has failed.</mark></td>\n</tr>\n<tr class=\"even\">\n<td>8. If <code>MCDCR.MCLKSTS</code> is clear, the oscillator startup is a success. The system clock is now derived from XTAL.</td>\n<td>8. If <code>MCLKSTS</code> is clear, the switch to the external clock is a success. The system clock is now derived from XTAL.</td>\n</tr>\n</tbody>\n</table>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210730164642361.png\" alt=\"image-20210730164642361\" /><figcaption aria-hidden=\"true\">image-20210730164642361</figcaption>\n</figure>\n<h3 id=\"子系统时钟sysclk-perx.sysclk\">子系统时钟（SYSCLK / PERx.SYSCLK）</h3>\n<p>CPU 为 CLA / DMA 和 绝大多数（片上）外设直接提供时钟信号，该时钟就是 <strong><em>PLLSYSCLK</em></strong> ， 但会在CPU进入 HALT模式时被栅断（gate off）。</p>\n<p>每一个外设都拥有使用 <strong><em>PCLKCRx</em></strong> 寄存器进行独立控制的时钟。</p>\n<p><strong>注意</strong>：当使用 PCLKCRx 时，应用需要在时钟接入外设后，等待5个 <strong><em>SYSCLK</em></strong> 周期。</p>\n<p>如《SPRUI33D》中，表3-55所示，从第195页起可查看 <strong><em>PCLKCRx</em></strong> 相关寄存器的所有说明。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210726095356897.png\" alt=\"image-20210726095356897\" /><figcaption aria-hidden=\"true\">image-20210726095356897</figcaption>\n</figure>\n<h2 id=\"闪存\">闪存</h2>\n<p>表23 展示了不同时钟源和频率下所需的最小闪存等待状态</p>\n<p>表24 展示了闪存的性能参数</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210711173614732.png\" alt=\"image-20210711173614732\" /><figcaption aria-hidden=\"true\">image-20210711173614732</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210711173721809.png\" alt=\"image-20210711173721809\" /><figcaption aria-hidden=\"true\">image-20210711173721809</figcaption>\n</figure>\n<h2 id=\"jtag\">JTAG</h2>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210730135537700.png\" alt=\"image-20210730135537700\" style=\"zoom: 80%;\" /></p>\n<h2 id=\"gpio\">GPIO</h2>\n<p><mark>在复位时，GPIO会被配置为输入。</mark></p>\n<p>对于特定的输入，用户还可以选择 <strong>输入鉴定周期</strong>（input qualification cycles）的数量来过滤不需要的 <strong>噪声突变</strong>（unwanted noise glitches）。</p>\n<p><strong><em>表 29</em></strong> 展示了GPIO的特性参数，<mark style=\"text-decoration-line: line-through;\">需要注意的是，GPIO的频率只有25MHz最高。</mark></p>\n<p><strong><em>表 30</em></strong> 展示了GPIO的输入时间要求</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210711174357812.png\" alt=\"image-20210711174357812\" /><figcaption aria-hidden=\"true\">image-20210711174357812</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210711174530164.png\" alt=\"image-20210711174530164\" /><figcaption aria-hidden=\"true\">image-20210711174530164</figcaption>\n</figure>\n<p>除了CPU控制的I/O功能外，最多可有12个独立的外设信号在一个GPIO功能口上进行多路复用。每个功能口的输出都可以被外设或者CPU主机（CPU1或者CPU1.CLA）进行控制。</p>\n<p>有两个可输入输出接口：</p>\n<ul>\n<li><p>接口A包含GPIO1 ~ GPIO31</p></li>\n<li><p>接口B包含GPIO32 ~ GPIO59</p></li>\n</ul>\n<p>本设备上的模拟信号被复用在数字输入上，这些模拟输入输出口（AIO）引脚不具备数字输出的能力。接口范围为：</p>\n<ul>\n<li>接口H包含GPIO224 ~ GPIO247</li>\n</ul>\n<p>虽然上述GPIO看起来很多，但实际上本系列芯片只有GPIOA和GPIOB的部分引脚，引脚总数为26个。</p>\n<h3 id=\"引脚复用-1\">引脚复用</h3>\n<p>在 <code>GPyMUXx</code> 寄存器中，每个区域（field）都决定了每个引脚（IO PIN）的GPIO复用配置。设置为 <code>0x0</code> , <code>0x4</code> , <code>0x8</code> , <code>0xC</code> 时可以将该引脚配置为 GPIO，配置为其他值时，可以选择一个外设以控制该引脚。查看设备数据手册以获得《外设复用选项表格》。</p>\n<p>引脚必须在改变 <code>GPyGMUXx</code> 对应域之前，通过寄存器设置为GPIO模式。</p>\n<h3 id=\"流程图解读\">流程图解读</h3>\n<p>下图8-1 展示了单个GPIO引脚上的功能框图：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210823153758838.png\" alt=\"image-20210823153758838\" /><figcaption aria-hidden=\"true\">image-20210823153758838</figcaption>\n</figure>\n<p>从上图可以看出来，GPIO可以设置为输出或输入</p>\n<ol type=\"1\">\n<li><p>输入时可以通过 <code>GPyPUD</code> 寄存器设置为是否 <strong>拉高</strong>，然后通过 <code>GPyINV</code> 寄存器设置是否信号 <strong>反转</strong>，<code>GPyCTRL</code> 寄存器控制着4个字段（每个字段独立控制8个GPIO）的 <strong>确认采样周期</strong>（qualification sampling period），通过设置该寄存器可以设置其 <strong>采样速率范围</strong> 为 {0, 2, 4, ...508, 510} 个 SYSCLK 周期；<code>GPyQSEL1/2</code> 寄存器控制着 <strong>输入确认类型</strong>（可选为 同步/三采样/六采样/异步），最后可以输出至 <strong>四个方向</strong>（外设、X-BAR、CPU1 和 CPU1CLA）。</p></li>\n<li><p>输出暂略。</p></li>\n<li><p>The input and output paths are entirely separate, connecting only at the pin.</p></li>\n<li><p>Peripheral muxing takes place far from the pin.</p></li>\n</ol>\n<p>As a result, it is always possible for both CPUs and CLAs to read the physical state of the pin independent of CPU mastering and peripheral muxing.</p>\n<p>Likewise, external interrupts can be generated from peripheral activity. All pin options such as input qualification and open-drain output are valid for all masters and peripherals.</p>\n<p>However, the peripheral muxing, CPU muxing, and pin options can only be configured by CPU1.</p>\n<h3 id=\"寄存器\">寄存器</h3>\n<p>《SPRUI33D》第857页起讲述GPIO特性，第870页起讲述相关寄存器信息。</p>\n<p>如 <strong><em>表 8-8</em></strong> 所示，GPIO拥有两类寄存器，分别是 <strong><em>GPIO控制寄存器</em></strong> 和 <strong><em>GPIO数据寄存器</em></strong> 。另，控制/数据寄存器 下都有 <strong><em>GPIO A</em></strong> / <strong><em>GPIO B</em></strong> / <strong><em>GPIO H</em></strong> 三种区别。<strong><em>表 8-9</em></strong> 是GPIO控制寄存器的详细介绍，<strong><em>表 8-54</em></strong> 是GPIO数据寄存器的详细介绍。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>FUNCTIONS</th>\n<th>GPIO A</th>\n<th>GPIO B</th>\n<th>GPIO H</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>PINS</td>\n<td><code>GPIO0</code> ~ <code>GPIO31</code></td>\n<td><code>GPIO32</code> ~ <code>GPIO63</code></td>\n<td><code>GPIO224</code> ~ <code>GPIO255</code></td>\n</tr>\n<tr class=\"even\">\n<td>QUALIFICATION SAMPLING PERIOD</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr class=\"odd\">\n<td>QUALIFICATION TYPE</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr class=\"even\">\n<td>PERIPHERAL MUX</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr class=\"odd\">\n<td>DIRECTION</td>\n<td>Y</td>\n<td>Y</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>PULL-UP DISABLE</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr class=\"odd\">\n<td>INPUT INVERSION</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr class=\"even\">\n<td>OPEN DRAIN OUTPUT MODE</td>\n<td>Y</td>\n<td>Y</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>ANALOG MODE SELECT</td>\n<td>Y</td>\n<td></td>\n<td>Y</td>\n</tr>\n<tr class=\"even\">\n<td>PERIPHERAL GROUP MAX</td>\n<td>Y</td>\n<td>Y</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>MASTER CORE SELECT</td>\n<td>Y</td>\n<td>Y</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>LOCK</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr class=\"odd\">\n<td>LOCK COMMIT</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n</tbody>\n</table>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210728104527100.png\" alt=\"image-20210728104527100\" /><figcaption aria-hidden=\"true\">image-20210728104527100</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210728105035255.png\" alt=\"image-20210728105035255\" /><figcaption aria-hidden=\"true\">image-20210728105035255</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210728105057621.png\" alt=\"image-20210728105057621\" /><figcaption aria-hidden=\"true\">image-20210728105057621</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210728105118549.png\" alt=\"image-20210728105118549\" /><figcaption aria-hidden=\"true\">image-20210728105118549</figcaption>\n</figure>\n<h3 id=\"配置\">配置</h3>\n<p>配置GPIO的通用流程如下：</p>\n<ol type=\"1\">\n<li><strong>规划设备的引脚布局</strong> 列出应用所需的所有外围设备的清单。使用设备数据手册中的外设复用信息，选择哪些GPIO用于外设信号。决定在剩余的GPIO中，哪些作为每个CPU和CLA的输入和输出。一旦选择了外设复用，就应该通过向 <code>GPyMUX1/2</code> 和 <code>GPyGMUX1/2</code> 寄存器写入适当的值来实现。当改变一个引脚的GPyGMUX值时，一定要先将相应的GPyMUX位设置为0，以避免在复用中出现突发。默认情况下，所有引脚都是通用的I/O，而不是外围信号。</li>\n<li>(可选）<strong>启用内部上拉电阻</strong> 要启用或禁用上拉电阻，请写到GPIO上拉禁用寄存器 <code>GPyPUD</code> 中的相应位。所有的上拉电阻在默认情况下是禁用的。当没有外部信号驱动时，上拉可以用来保持输入引脚处于已知状态。</li>\n<li><strong>选择输入资格</strong> 如果该引脚将被用作输入，请指定所需的输入鉴定（如果有）。在 <code>GPyCTRL</code> 寄存器中选择输入鉴定的采样周期，而在 <code>GPyQSEL1</code> 和 <code>GPyQSEL2</code> 寄存器中选择鉴定的类型。默认情况下，所有鉴定都是同步的，采样周期等于 <code>PLLSYSCLK</code>。关于输入鉴定的解释，请参见第8.4节。</li>\n<li><strong>选择任何通用I/O引脚的方向</strong> 对于每个配置为GPIO的引脚，使用 <code>GPyDIR</code> 寄存器指定该引脚的方向为输入或输出。<mark>默认情况下，所有的GPIO引脚都是输入</mark>。在改变引脚为输出之前，通过向 <code>GPySET</code> 、<code>GPyCLEAR</code> 或 <code>GPyDAT</code> 寄存器写入要驱动的值来加载输出闩锁。一旦锁存器被加载，写入 <code>GPyDIR</code> 来改变引脚的方向。默认情况下，所有输出锁存器为零。</li>\n<li><strong>选择低功耗模式的唤醒源</strong> <code>GPIO 0-63</code> 可以用来将系统从低功耗模式唤醒。要选择一个或多个GPIO进行唤醒，请写到 <code>GPIOLPMSEL0</code> 和 <code>GPIOLPMSEL1</code> 寄存器的相应位。这些寄存器是CPU系统寄存器空间的一部分。关于低功耗模式和GPIO唤醒的更多信息，请参见系统控制和中断章节中的低功耗模式部分。</li>\n<li><strong>选择外部中断源</strong> 配置外部中断是一个两步的过程。首先，中断本身必须被启用，其极性必须通过 <code>XINTnCR</code> 寄存器进行配置。其次，必须通过选择输入X-BAR信号4、5、6、13和 14 的来源来设置XINT1-5 GPIO引脚。关于输入X-BAR结构的更多信息，请参见本手册的Crossbar(XBAR)章节。</li>\n</ol>\n<h4 id=\"案例\">案例</h4>\n<p>如 <a href=\"http://code.islet.space/TI/f28004x/group__gpio__api.html\">GPIO配置手册</a> 所示，<code>GPIO_SetupPinMux();</code> 和 <code>GPIO_SetupPinOption();</code> 并不存在，这两个是存在于 <code>f28004x_gpio.h</code> 中的自定义。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// AFE_InitGpio - Initialize the GPIOs on launchpad and boosterpack</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">AFE_InitGpio</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    EALLOW; <span class=\"comment\">// below registers are &quot;protected&quot;, allow access.</span></span><br><span class=\"line\">    <span class=\"comment\">//GPIO-23 - LaunchPad RED LED</span></span><br><span class=\"line\">    GPIO_SetupPinMux(<span class=\"number\">23</span>, GPIO_MUX_CPU1, <span class=\"number\">0</span>);</span><br><span class=\"line\">    GPIO_SetupPinOptions(<span class=\"number\">23</span>, GPIO_OUTPUT, GPIO_PUSHPULL);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// GPIO-34 - LaunchPad GREEN LED</span></span><br><span class=\"line\">    GPIO_SetupPinMux(<span class=\"number\">34</span>, GPIO_MUX_CPU1, <span class=\"number\">0</span>);</span><br><span class=\"line\">    GPIO_SetupPinOptions(<span class=\"number\">34</span>, GPIO_OUTPUT, GPIO_PUSHPULL);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// GPIO AFE BoosterPack LED</span></span><br><span class=\"line\">    GPIO_SetupPinMux(<span class=\"number\">4</span>, GPIO_MUX_CPU1, <span class=\"number\">0</span>);</span><br><span class=\"line\">    GPIO_SetupPinOptions(<span class=\"number\">4</span>, GPIO_OUTPUT, GPIO_PUSHPULL);</span><br><span class=\"line\"></span><br><span class=\"line\">    GPIO_SetupPinMux(<span class=\"number\">5</span>, GPIO_MUX_CPU1, <span class=\"number\">0</span>);</span><br><span class=\"line\">    GPIO_SetupPinOptions(<span class=\"number\">5</span>, GPIO_OUTPUT, GPIO_PUSHPULL);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    GPIO_WritePin(<span class=\"number\">4</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    GPIO_WritePin(<span class=\"number\">5</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    EDIS;</span><br><span class=\"line\">    <span class=\"comment\">// Disable register access</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"函数说明\">函数说明</h4>\n<h5 id=\"引脚复用设置函数\">引脚复用设置函数</h5>\n<p>本函数用于将指定引脚与函数进行绑定，绑定前会自动检查对应的CPU和外设是否可用。</p>\n<p>然后，创建指向相应寄存器的指针，这是对GPIO寄存器定义方式的一种变通。</p>\n<p>头文件中的标准定义使得对一个寄存器或位进行命名访问非常容易，但很难进行任意的数字访问。有一个具有相同寄存器的GPIO模块阵列，包括像 <code>GPyCSEL1-4</code> 这样的多寄存器组的阵列，会更容易。但是头文件没有定义任何我们可以变成数组的东西，所以就用手动指针运算来代替。</p>\n<p>要改变多路复用，首先将外设多路复用设置为0/GPIO，以避免出现故障，然后改变组复用，再将外设多路复用设置为目标值。最后，设置CPU选择。这个过程在《TRM》中有所描述。不幸的是，由于我们事先不知道引脚，我们不能硬编码一个位域参考，所以这里有一些棘手的位操作。</p>\n<p><strong>警告</strong>：该代码不涉及模拟模式选择寄存器。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// GPIO_SetupPinMux - Set the peripheral muxing for the specified pin.</span></span><br><span class=\"line\"><span class=\"comment\">// The appropriate parameters can be found in the pinout spreadsheet.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GPIO_SetupPinMux</span><span class=\"params\">(Uint16 gpioNumber, Uint16 cpu, Uint16 muxPosition)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Uint32 *gpioBaseAddr;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Uint32 *mux, *gmux, *csel;</span><br><span class=\"line\">    Uint16 pin32, pin16, pin8;</span><br><span class=\"line\"></span><br><span class=\"line\">    pin32 = gpioNumber % <span class=\"number\">32</span>;</span><br><span class=\"line\">    pin16 = gpioNumber % <span class=\"number\">16</span>;</span><br><span class=\"line\">    pin8 = gpioNumber % <span class=\"number\">8</span>;</span><br><span class=\"line\">    gpioBaseAddr = (Uint32 *)&amp;GpioCtrlRegs + (gpioNumber/<span class=\"number\">32</span>)*GPY_CTRL_OFFSET;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// Sanity check for valid cpu and peripheral values</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cpu &gt; GPIO_MUX_CPU1CLA || muxPosition &gt; <span class=\"number\">0xF</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// Create pointers to the appropriate registers. This is a workaround</span></span><br><span class=\"line\">    <span class=\"comment\">// for the way GPIO registers are defined. The standard definition</span></span><br><span class=\"line\">    <span class=\"comment\">// in the header file makes it very easy to do named accesses of one</span></span><br><span class=\"line\">    <span class=\"comment\">// register or bit, but hard to do arbitrary numerical accesses. It&#x27;s</span></span><br><span class=\"line\">    <span class=\"comment\">// easier to have an array of GPIO modules with identical registers,</span></span><br><span class=\"line\">    <span class=\"comment\">// including arrays for multi-register groups like GPyCSEL1-4. But</span></span><br><span class=\"line\">    <span class=\"comment\">// the header file doesn&#x27;t define anything we can turn into an array,</span></span><br><span class=\"line\">    <span class=\"comment\">// so manual pointer arithmetic is used instead.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    mux = gpioBaseAddr + GPYMUX + pin32/<span class=\"number\">16</span>;</span><br><span class=\"line\">    gmux = gpioBaseAddr + GPYGMUX + pin32/<span class=\"number\">16</span>;</span><br><span class=\"line\">    csel = gpioBaseAddr + GPYCSEL + pin32/<span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// Now for the actual function</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    EALLOW;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// To change the muxing, set the peripheral mux to 0/GPIO first to avoid</span></span><br><span class=\"line\">    <span class=\"comment\">// glitches, then change the group mux, then set the peripheral mux to</span></span><br><span class=\"line\">    <span class=\"comment\">// its target value. Finally, set the CPU select. This procedure is</span></span><br><span class=\"line\">    <span class=\"comment\">// described in the TRM. Unfortunately, since we don&#x27;t know the pin in</span></span><br><span class=\"line\">    <span class=\"comment\">// advance we can&#x27;t hardcode a bitfield reference, so there&#x27;s some tricky</span></span><br><span class=\"line\">    <span class=\"comment\">// bit twiddling here.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    *mux &amp;= ~(<span class=\"number\">0x3</span>UL &lt;&lt; (<span class=\"number\">2</span>*pin16));</span><br><span class=\"line\">    *gmux &amp;= ~(<span class=\"number\">0x3</span>UL &lt;&lt; (<span class=\"number\">2</span>*pin16));</span><br><span class=\"line\">    *gmux |= (Uint32)((muxPosition &gt;&gt; <span class=\"number\">2</span>) &amp; <span class=\"number\">0x3</span>UL) &lt;&lt; (<span class=\"number\">2</span>*pin16);</span><br><span class=\"line\">    *mux |= (Uint32)(muxPosition &amp; <span class=\"number\">0x3</span>UL) &lt;&lt; (<span class=\"number\">2</span>*pin16);</span><br><span class=\"line\"></span><br><span class=\"line\">    *csel &amp;= ~(<span class=\"number\">0x3</span>L &lt;&lt; (<span class=\"number\">4</span>*pin8));</span><br><span class=\"line\">    *csel |= (Uint32)(cpu &amp; <span class=\"number\">0x3</span>L) &lt;&lt; (<span class=\"number\">4</span>*pin8);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// WARNING: This code does not touch the analog mode select registers.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EDIS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"引脚属性设置函数\">引脚属性设置函数</h5>\n<p>为指定的引脚设置输入/出，可以通过已定义的标志（flags）来设置，这些标志都是16位的掩码。</p>\n<p>输入引脚可用的标志如：</p>\n<blockquote>\n<p><code>GPIO_PULLUP</code> 使能拉高</p>\n<p><code>GPIO_INVERT</code> 输入极性翻转</p>\n<p><code>GPIO_SYNC</code> 与PLLSYSCLK同步输入阀（这条是默认的，可以不单独设置）</p>\n<p><code>GPIO_QUAL3</code> 使用3采样质量</p>\n<p><code>GPIO_QUAL6</code> 使用6采样质量</p>\n<p><code>GPIO_ASYNC</code> 不使用同步或质量</p>\n</blockquote>\n<p>输出引脚可用标志如下：</p>\n<blockquote>\n<p><code>GPIO_OPENDRAIN</code> 工作在输出开漏模式</p>\n<p><code>GPIO_PULLUP</code> 输出置高，</p>\n</blockquote>\n<p>注意：如果输出开漏模式打开，也就自动打开了置高。输入配置里的 SYNC / QUAL3 / QUAL6 / ASYNC 只允许启用一个。</p>\n<p><strong>默认输入状态</strong>：<strong>未同步</strong>（ASYNC）且无 <strong>置高</strong>（PULL-UP）和 <strong>极性翻转</strong>（INVERT）。</p>\n<p><strong>默认输出状态</strong>：标准数字输出。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GPIO_SetupPinOptions</span><span class=\"params\">(Uint16 gpioNumber, Uint16 output, Uint16 flags)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Uint32 *gpioBaseAddr;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Uint32 *dir, *pud, *inv, *odr, *qsel;</span><br><span class=\"line\">    Uint32 pin32, pin16, pinMask, qual;</span><br><span class=\"line\"></span><br><span class=\"line\">    pin32 = gpioNumber % <span class=\"number\">32</span>;</span><br><span class=\"line\">    pin16 = gpioNumber % <span class=\"number\">16</span>;</span><br><span class=\"line\">    pinMask = <span class=\"number\">1UL</span> &lt;&lt; pin32;</span><br><span class=\"line\">    gpioBaseAddr = (Uint32 *)&amp;GpioCtrlRegs + (gpioNumber/<span class=\"number\">32</span>)*GPY_CTRL_OFFSET;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// Create pointers to the appropriate registers. This is a workaround</span></span><br><span class=\"line\">    <span class=\"comment\">// for the way GPIO registers are defined. The standard definition</span></span><br><span class=\"line\">    <span class=\"comment\">// in the header file makes it very easy to do named accesses of one</span></span><br><span class=\"line\">    <span class=\"comment\">// register or bit, but hard to do arbitrary numerical accesses. It&#x27;s</span></span><br><span class=\"line\">    <span class=\"comment\">// easier to have an array of GPIO modules with identical registers,</span></span><br><span class=\"line\">    <span class=\"comment\">// including arrays for multi-register groups like GPyQSEL1-2. But</span></span><br><span class=\"line\">    <span class=\"comment\">// the header file doesn&#x27;t define anything we can turn into an array,</span></span><br><span class=\"line\">    <span class=\"comment\">// so manual pointer arithmetic is used instead.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    dir = gpioBaseAddr + GPYDIR;</span><br><span class=\"line\">    pud = gpioBaseAddr + GPYPUD;</span><br><span class=\"line\">    inv = gpioBaseAddr + GPYINV;</span><br><span class=\"line\">    odr = gpioBaseAddr + GPYODR;</span><br><span class=\"line\">    qsel = gpioBaseAddr + GPYQSEL + pin32/<span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    EALLOW;</span><br><span class=\"line\"></span><br><span class=\"line\">    *dir &amp;= ~pinMask;      <span class=\"comment\">// Set the data direction</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (output == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        *dir |= pinMask;   <span class=\"comment\">// Output, with optional open drain mode and pull-up</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flags &amp; GPIO_OPENDRAIN) *odr |= pinMask;  <span class=\"comment\">// Enable open drain if necessary</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> *odr &amp;= ~pinMask;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flags &amp; (GPIO_OPENDRAIN | GPIO_PULLUP)) *pud &amp;= ~pinMask;  <span class=\"comment\">// Enable pull-up if necessary. Open drain mode must be active.</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> *pud |= pinMask;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        *dir &amp;= ~pinMask;        <span class=\"comment\">// Input, with optional pull-up, qualification, and polarity inversion</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flags &amp; GPIO_PULLUP) *pud &amp;= ~pinMask;     <span class=\"comment\">// Enable pull-up if necessary</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> *pud |= pinMask;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flags &amp; GPIO_INVERT) *inv |= pinMask;   <span class=\"comment\">// Invert polarity if necessary</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> *inv &amp;= ~pinMask;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// Extract the qualification parameter and load it into the register.</span></span><br><span class=\"line\">    <span class=\"comment\">// This is also needed for open drain outputs, so we might as well do it</span></span><br><span class=\"line\">    <span class=\"comment\">// all the time.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    qual = (flags &amp; GPIO_ASYNC) / GPIO_QUAL3;</span><br><span class=\"line\">    *qsel &amp;= ~(<span class=\"number\">0x3</span>L &lt;&lt; (<span class=\"number\">2</span> * pin16));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (qual != <span class=\"number\">0x0</span>) *qsel |= qual &lt;&lt; (<span class=\"number\">2</span> * pin16);</span><br><span class=\"line\"></span><br><span class=\"line\">    EDIS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"中断\">中断</h2>\n<p>此处的中断更多的是讲 <strong>外设中断</strong>，当然后面也会涉及到定时器中断部分，因此统称为中断了，阅读是需要加以区分。</p>\n<p><mark>C28x系列芯片有14条外设中断可用，其中13和14中断被直接关联至CPU定时器1和定时器2。</mark> 从中断向量表里，也只能看到第1组到第12组中断向量，要绑定定时器1和定时器2的中断程序的话，需要绑定到（不存在与中断向量表）上的第13和第14中断。</p>\n<p>剩余12条中断（就是第1~第12条中断）可以通过 <strong>增强型外围中断扩展</strong>（enhanced Peripheral Interrupt Expansion，ePIE)模块进行信号引导。<mark>本模块将最多16个外设中断复用到每个CPU中断线中，并扩展了向量表，允许每个中断有自己的ISR。</mark>允许芯片支持数量众多的外围设备。</p>\n<p>中断路径一共有三个阶段—— <strong><em>外设中断阶段</em></strong>、<strong><em>PIE模块阶段</em></strong> 和 <strong><em>CPU阶段</em></strong>。每个阶段都有其使能和标志寄存器。本系统允许CPU在其他中断等待时处理一个中断，在软件中实现并优先处理嵌套中断，并在某些关键任务中禁用中断。</p>\n<p>外部中断（external interrupt, XINT）电气特性数据和时序特性：</p>\n<p><strong>表31</strong> 列出了外部中断的时间要求</p>\n<p><strong>表32</strong> 列出了外部中断开断特性</p>\n<p><strong>图25</strong> 展示了外部中断的时序</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210712083326344.png\" alt=\"image-20210712083326344\" /><figcaption aria-hidden=\"true\">image-20210712083326344</figcaption>\n</figure>\n<h3 id=\"中断架构\">中断架构</h3>\n<p>下图展示了本系列芯片的中断架构。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210728111202805.png\" alt=\"image-20210728111202805\" /><figcaption aria-hidden=\"true\">image-20210728111202805</figcaption>\n</figure>\n<h4 id=\"stage0---外设中断阶段\">STAGE0 - 外设中断阶段</h4>\n<p>每个外设都有其独立的中断配置，在每个设备的章节中都有描述。某些外设允许多种事件来触发相同的中断信号。例如，通信外设就可能使用相同的中断来检查数据是否被接收或者是否存在传输错误。中断的触发状态可以通过查看外设状态寄存器来确定。通常，在下一次中断生成前，需要手动清除前一次在状态寄存器上的数据位。</p>\n<h4 id=\"stage1---pie阶段\">STAGE1 - PIE阶段</h4>\n<p>PIE控制器是指用于外围设备中断控制（Peripheral Interrupt Control）的寄存器。</p>\n<p>PIE为每一个外设中断信号都提供了独立的标志和使能寄存器位，这些外设中断信号通常也被称为 <strong><em>PIE通道</em></strong>。这些通道根据关联的CPU中断（associated CPU interrupt）被进行绑定成 <strong>组</strong>（group）。每一个PIE组都拥有一个16bit的 <strong>使能寄存器</strong> <strong><em>PIEIERx</em></strong> 和 一个16bit的 <strong>标志寄存器</strong> <strong><em>PIEIFRx</em></strong> ，并且在PIE确认寄存器 <strong><em>PIEACK</em></strong> 中还有一个bit。<mark><strong><em>PIEACK</em></strong> register bit acts as a common interrupt mask for the entire <strong><em>PIE</em></strong> group.</mark></p>\n<p>当CPU接收一个中断时，从PIE中查找到中断服务程序的地址（fetches the address of the ISR）。【因此写完中断服务程序时需要将程序的地址绑定到PIE上，如下面代码。】PIE返回组中 <strong>同时被使能且被标志了的</strong>（both flagged and enabled） <strong>最低数字的通道</strong>（lowest-numbered channel）的向量地址。在多数中断都被 <strong>阻塞</strong>（pending）时，这相当于给了低优先级中断一个较高的权限。</p>\n<p>如果没有中断被同时标志和使能，PIE就会返回通道1的向量地址。这种情况通常不会发生，只有在 <strong>PIE改变状态时</strong> <strong>中断也同时</strong> 生成才会。（software changes the state of the PIE while an interrupt is propagating）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">EALLOW;</span><br><span class=\"line\">PieVectTable.ADCA1_INT = &amp;adcA1ISR;   <span class=\"comment\">//为通道ADCA1绑定中断应用 adcA1ISR</span></span><br><span class=\"line\">EDIS;</span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210728110450590.png\" alt=\"image-20210728110450590\" /><figcaption aria-hidden=\"true\">image-20210728110450590</figcaption>\n</figure>\n<h4 id=\"stage2---cpu阶段\">STAGE2 - CPU阶段</h4>\n<p>和PIE相似，CPU 也为每一个中断提供了对应的标志和使能寄存器位。在CPU内部寄存器中，有一个 <strong>中断使能寄存器</strong>（<strong>IER</strong>）和一个 <strong>中断标志寄存器</strong>（<strong>IFR</strong>）。CPU内部还有一个由 <strong><em>ST1</em></strong> 寄存器下的 <strong><em>INTM</em></strong> 位 控制的 <strong>全局中断屏蔽</strong>（global interrupt mask），该屏蔽可以用CPU的 <code>SETC</code> 和 <code>CLRC</code> 指令进行进行设置和清除操作。对应到C语言的代码中，就是C2000套件的宏定义 <code>DINT</code> 和 <code>EINT</code> 。</p>\n<p>对 <code>IER</code> 和 <code>INTM</code> 的写入都是原子操作。原则上，一旦设置了 <code>INTM</code> 位，队列（pipeline）里的下个指令将会在所有中断都被关闭的情况下运行，不需要软件延迟。</p>\n<h3 id=\"中断顺序\">中断顺序</h3>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210816112840611.png\" alt=\"image-20210816112840611\" /><figcaption aria-hidden=\"true\">image-20210816112840611</figcaption>\n</figure>\n<p>当外设生成中断（在第x组PIE，第y通道）时，以下事件顺序将会触发：</p>\n<ol type=\"1\">\n<li>中断被锁定在 <code>PIEIFRx.y</code></li>\n<li>如果 <code>PIEIERx.y</code> 被设置 ，中断生成</li>\n<li>如果 <code>PIEACK.x</code> 被清除，中断生成且 <code>PIEACK</code> 被设置</li>\n<li>中断被锁定在 <code>IFR.x</code></li>\n<li>如果 <code>IER.x</code> 被设置，中断生成</li>\n<li>如果 <code>INTM</code> 被清除，CPU接收中断</li>\n<li>任何在管道里的D2或更后面的阶段的指令将会运行到完成。更早阶段的指令将会被清除（flushed）。</li>\n<li>CPU在堆（stack）上保存内容</li>\n<li><code>IFR.x</code> 和 <code>IER.x</code> 被清除。<code>INTM</code> 被设置。<code>EALLOW</code> 被清除。</li>\n<li>CPU中PIE中索引到ISR的地址。<code>PIEIFR.y</code> 被清除</li>\n</ol>\n<p>所谓中断延迟是指介于 <code>PIEIFRx.y</code> <strong>锁存中断</strong> 和 <strong>第一个ISR指令进入CPU队列的执行阶段</strong> 之间的时间。</p>\n<p>最小的中断延迟时间是14个系统周期，在ISR或堆内存中的等待时间也会增加延迟。</p>\n<p>外部中断为了 <strong>GPIO同步</strong> 和 <strong>输入限制</strong>（input qualification），增加了最少2个系统周期。</p>\n<p>使用C28x <code>RPT</code> 指令创建的循环无法被中断。</p>\n<h3 id=\"定时器中断\">定时器中断</h3>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210830140222956.png\" alt=\"image-20210830140222956\" /><figcaption aria-hidden=\"true\">image-20210830140222956</figcaption>\n</figure>\n<p>在 <code>cputimer.h</code> 头文件中，可以看到定时器配置的结构体如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CPUTIMER_REGS</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span>   <span class=\"title\">TIM_REG</span>                          <span class=\"title\">TIM</span>;</span>                          <span class=\"comment\">// CPU-Timer, Counter Register</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span>   <span class=\"title\">PRD_REG</span>                          <span class=\"title\">PRD</span>;</span>                          <span class=\"comment\">// CPU-Timer, Period Register</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span>   <span class=\"title\">TCR_REG</span>                          <span class=\"title\">TCR</span>;</span>                          <span class=\"comment\">// CPU-Timer, Control Register</span></span><br><span class=\"line\">    Uint16                                   rsvd1;                        <span class=\"comment\">// Reserved</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span>   <span class=\"title\">TPR_REG</span>                          <span class=\"title\">TPR</span>;</span>                          <span class=\"comment\">// CPU-Timer, Prescale Register</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span>   <span class=\"title\">TPRH_REG</span>                         <span class=\"title\">TPRH</span>;</span>                         <span class=\"comment\">// CPU-Timer, Prescale Register High</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在 <code>cputimervars.h</code> 头文件中，直接配置了如下结构体：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// CPU Timer Support Variables:</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CPUTIMER_VARS</span> &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">volatile</span> <span class=\"class\"><span class=\"keyword\">struct</span>  <span class=\"title\">CPUTIMER_REGS</span>  *<span class=\"title\">RegsAddr</span>;</span></span><br><span class=\"line\">   Uint32    InterruptCount;</span><br><span class=\"line\">   <span class=\"keyword\">float</span>   CPUFreqInMHz;</span><br><span class=\"line\">   <span class=\"keyword\">float</span>   PeriodInUSec;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>通过在结构体内声明寄存器指针，并在结构体外定义对应的结构体变量：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Globals</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CPUTIMER_VARS</span> <span class=\"title\">CpuTimer0</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CPUTIMER_VARS</span> <span class=\"title\">CpuTimer1</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CPUTIMER_VARS</span> <span class=\"title\">CpuTimer2</span>;</span></span><br></pre></td></tr></table></figure>\n<p>在对CPU定时器初始化时，则不是操作 <code>struct CPUTIMER_VARS</code> ，而是直接操作对应的三个定时器（timer0 ~ timer2）的寄存器。</p>\n<p>在后续对定时器的配置中，也只是将 <strong>系统频率</strong> <code>CPUFreqInMHz</code> 和 <strong>定时器周期</strong> <code>PeriodInUSec</code> 的配置进行了较为方便的配置而已，书写成嵌套结构体的形式也节省了在函数内声明变量，方便了多个定时器不同配置的相似处理，在代码实际执行过程中，仍然是对寄存器进行直接操作。</p>\n<p>定时器清空：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">CpuTimer0.RegsAddr = &amp;CpuTimer0Regs;    <span class=\"comment\">// 初始化地址指针指向对应的定时器寄存器</span></span><br><span class=\"line\">CpuTimer0Regs.PRD.all  = <span class=\"number\">0xFFFFFFFF</span>;    <span class=\"comment\">// 初始化定时器周期至最大（PRD寄存器）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将定时器的预分频初始化并保持与系统时钟一致的速率</span></span><br><span class=\"line\">CpuTimer0Regs.TPR.all  = <span class=\"number\">0</span>;  <span class=\"comment\">// 初始化预分频寄存器为0</span></span><br><span class=\"line\">CpuTimer0Regs.TPRH.all = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化定时器控制寄存器</span></span><br><span class=\"line\">CpuTimer0Regs.TCR.bit.TSS = <span class=\"number\">1</span>;</span><br><span class=\"line\">CpuTimer0Regs.TCR.bit.TRB = <span class=\"number\">1</span>;    <span class=\"comment\">// 使用周期值重新载入所有计数器寄存器</span></span><br><span class=\"line\">CpuTimer0.InterruptCount = <span class=\"number\">0</span>;    <span class=\"comment\">// 复位中断计数器</span></span><br></pre></td></tr></table></figure>\n<p>定时器配置：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uint32 temp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化定时器周期</span></span><br><span class=\"line\">Timer-&gt;CPUFreqInMHz = Freq;</span><br><span class=\"line\">Timer-&gt;PeriodInUSec = Period;</span><br><span class=\"line\">temp = (<span class=\"keyword\">long</span>) (Freq * Period);</span><br><span class=\"line\">Timer-&gt;RegsAddr-&gt;PRD.all = temp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将定时器的预分频初始化并保持与系统时钟一致的速率</span></span><br><span class=\"line\">Timer-&gt;RegsAddr-&gt;TPR.all  = <span class=\"number\">0</span>;</span><br><span class=\"line\">Timer-&gt;RegsAddr-&gt;TPRH.all  = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化定时器控制寄存器</span></span><br><span class=\"line\">Timer-&gt;RegsAddr-&gt;TCR.bit.TSS = <span class=\"number\">1</span>;    <span class=\"comment\">// 1 = Stop timer, 0 = Start/Restart Timer</span></span><br><span class=\"line\">Timer-&gt;RegsAddr-&gt;TCR.bit.TRB = <span class=\"number\">1</span>;    <span class=\"comment\">// 1 = reload timer</span></span><br><span class=\"line\">Timer-&gt;RegsAddr-&gt;TCR.bit.SOFT = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Timer-&gt;RegsAddr-&gt;TCR.bit.FREE = <span class=\"number\">0</span>;    <span class=\"comment\">// Timer Free Run Disabled</span></span><br><span class=\"line\">Timer-&gt;RegsAddr-&gt;TCR.bit.TIE = <span class=\"number\">1</span>;    <span class=\"comment\">// 0 = Disable 1 = Enable Timer Interrupt</span></span><br><span class=\"line\">Timer-&gt;InterruptCount = <span class=\"number\">0</span>;    <span class=\"comment\">// Reset interrupt counter</span></span><br></pre></td></tr></table></figure>\n<p>将定时器的清空和配置两个操作步骤类似，可以简单归纳成流程图形式：</p>\n<pre class=\"mermaid\">graph LR\n初始化周期 --> 设定定时器速率 --> 设置定时器工作方式</pre>\n<h3 id=\"配置方法\">配置方法</h3>\n<p>上电时，默认情况下任何中断都不被使能。PIEIER 寄存器和 IER寄存器被清除， INTM寄存器被设置。应用代码负责配置和使能所有外设中断。</p>\n<h4 id=\"使能中断\">使能中断</h4>\n<p>以下为中断使能步骤：</p>\n<ol type=\"1\">\n<li>全局性地关闭中断（<code>DINT</code> 或者 <code>SETC INTM</code>)</li>\n<li>通过设置 <code>PIECTRL</code> 寄存器的 <code>ENPIE</code> 位来使能PIE。</li>\n<li>为每个中断在PIE向量表里的对应位置上写ISR向量（中断服务程序地址），如下表3所示，注意下表是 EALLOW 保护的。</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210817095119399.png\" alt=\"image-20210817095119399\" /><figcaption aria-hidden=\"true\">image-20210817095119399</figcaption>\n</figure>\n<ol start=\"4\" type=\"1\">\n<li>为每个中断设置对应的 <code>PIEIERx</code> 位。（不要使用直接连接至CPU的定时器1和定时器2）</li>\n<li>为所有拥有已启用中断的PIE组（for any PIE group containing enabled interrupts）设置CPU的IER位</li>\n<li>启用外设中断</li>\n<li>全局性启动中断（<code>EINT</code> 或 <code>CLRC INTM</code>）</li>\n</ol>\n<p>上表中，横向为组，如 [x,y]，x为组。</p>\n<p><mark>上方使能中断的流程，即中断初始化和配置的流程，重新用流程图的方式总结如下：</mark></p>\n<pre class=\"mermaid\">graph LR\n初始化PIE --> 关闭所有中断 --> 清空PIE向量表 --> 将ISR绑定中断向量表 -->初始化CPU定时器 -->调整CPU定时器周期和工作方式 --> 打开对应的组中断 --> 打开对应的中断向量 --> 使能中断</pre>\n<p>以下代码为上方流程的示例，部分代码也仅为函数封装，具体内容需要参考详细文档描述。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">InitPieCtrl();            <span class=\"comment\">//初始化PIE（外设中断）模块</span></span><br><span class=\"line\">ClearCPUInterrupt();      <span class=\"comment\">//关闭并清除所有CPU中断</span></span><br><span class=\"line\">InitPieVectTable();       <span class=\"comment\">//清空PIE（外设中断）向量表</span></span><br><span class=\"line\"></span><br><span class=\"line\">EALLOW;  <span class=\"comment\">//关闭中断向量表寄存器写保护</span></span><br><span class=\"line\">PieVectTable.ADCA1_INT = &amp;adcA1ISR;   <span class=\"comment\">//为ADCA的中断INT1（即ADCA1）绑定中断应用（的向量地址） &amp;adcA1ISR</span></span><br><span class=\"line\">PieVectTable.ADCC2_INT = &amp;adcC2ISR;   <span class=\"comment\">//绑定中断服务程序至中断向量表，C0通道和C2通道同用一个程序</span></span><br><span class=\"line\">PieVectTable.TIMER0_INT = &amp;cpuTimer0ISR;   <span class=\"comment\">// 将cpuTimer0ISR定时器0中断服务器程序绑定至对应的中断向量表</span></span><br><span class=\"line\">EDIS;</span><br><span class=\"line\"></span><br><span class=\"line\">InitCpuTimers();  <span class=\"comment\">//初始化CPU定时器</span></span><br><span class=\"line\"></span><br><span class=\"line\">ConfigCpuTimer(&amp;CpuTimer0, <span class=\"number\">100</span>, TIMER0_PRD);   <span class=\"comment\">//第一个参数填写定时器序号，第二个参数填写CPU主频，第三个参数填写定时器中断周期（微秒）</span></span><br><span class=\"line\"></span><br><span class=\"line\">CpuTimer0Regs.TCR.all = <span class=\"number\">0x4000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">IER |= M_INT1;               <span class=\"comment\">// 打开组1中断（group 1 interrupt）， ADC A模块 和 CPU定时器0 的 中断处理程序需要使用</span></span><br><span class=\"line\">IER |= M_INT10;             <span class=\"comment\">// 打开组10中断（group 10 interrupt），ADC C模块中断处理程序需要使用</span></span><br><span class=\"line\"></span><br><span class=\"line\">PieCtrlRegs.PIEIER1.bit.INTx1 = ON;  <span class=\"comment\">//打开中断向量表中的1.1中断，其中PIEIER是中断使能寄存器，其后的数字1是组1，INTx1是指第一个中断</span></span><br><span class=\"line\">PieCtrlRegs.PIEIER10.bit.INTx10 = ON;  <span class=\"comment\">//打开ADCC2对应的中断向量</span></span><br><span class=\"line\">PieCtrlRegs.PIEIER1.bit.INTx7 = ON;  <span class=\"comment\">//打开定时器0对应的中断向量</span></span><br><span class=\"line\"></span><br><span class=\"line\">EINT;                               <span class=\"comment\">// 使能中断</span></span><br><span class=\"line\">ERTM;                             <span class=\"comment\">// 打开调试模式</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"处理中断\">处理中断</h4>\n<p>ISR中断处理程序基本与普通程序一直，以下几点需要遵守：</p>\n<ol type=\"1\">\n<li>保存和恢复特定的CPU寄存器状态（如果需要）</li>\n<li>为中断组清除 <code>PIEACK</code> 位</li>\n<li>使用 <code>IRET</code> 指令来返回</li>\n</ol>\n<p>如果函数定义时使用了 <code>__interrupt</code> 关键字，第一条和第三条会由C编译器自动处理。</p>\n<p>与中断组相关的PIEACK 位必须在用户代码中手动清除，通常是在ISR的末尾执行该操作。如果PIEACK没有被清除，那么CPU将不会继续接收改组的中断。此处与不经过PIE的定时器中断有所不同。</p>\n<p><mark>在使用了 <code>__interrupt</code> 关键字后，中断处理时，唯一需要注意的就是对该中断的组进行中断确认，如果没有确认，该中断只会被进行一次，确认组中断的代码如下：</mark></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;  <span class=\"comment\">//确认组1的中断</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"关闭中断\">关闭中断</h4>\n<p>为关闭所有中断，需通过 <code>DINT</code> 和 <code>SETC INTM</code> 来设置CPU的全局中断屏蔽。不需要在设置 <code>INTM</code> 或 修改IER后添加 <code>NOP</code>，在中断关闭后会有下一条指令将被执行。</p>\n<p>通过操作 <code>PIEIERx</code> 寄存器能够关闭独立中断，但需要避免竞争发生。当 <code>PIEIER</code> 写入完成时，如果中断信号准备好要生成，该中断信号将会直接到达CPU并且造成假中断的触发。为避免假中断的触发，应循以下步骤：</p>\n<ol type=\"1\">\n<li>全局性禁止中断（<code>DINT</code> 或 <code>SETC INTM</code>）</li>\n<li>为中断清除 <code>PIEIER</code> 位</li>\n<li>等待5个周期（系统周期？）以确保任何已生成的中断能够到达CPU的IFR寄存器</li>\n<li>为中断的PIE组清除CPU的IFR位 和 <code>PIEACK</code> 位</li>\n<li>全局性启用中断（<code>EINT</code> 或 <code>CLRC INTM</code>）</li>\n</ol>\n<p>使用CPU的 <strong><em>IER</em></strong> 寄存器可以禁用中断组。此时不会产生竞争，因此无需特殊的程序进行处理。</p>\n<p><code>PIEIER</code> 位不可以被软件清除（must never be cleared in software），因为 读/写/改 操作可能会对进入CPU的中断造成影响（may cause incoming interrupts to be lost）。唯一安全的清除 <code>PIEIER</code> 位的方法是让CPU处理该中断。以下程序步骤可以用于绕过普通ISR：</p>\n<ol type=\"1\">\n<li>全局性禁止中断（<code>DINT</code> 或 <code>SETC INTM</code>）</li>\n<li>修改PIE向量表以将 <code>PIEIFR</code> 位的中断向量映射至空的ISR上，该ISR将只包含一个来自中断指令 <code>IRET</code> 的返回（contain a return from interrupt instruction）</li>\n<li>在外设寄存器上禁用中断</li>\n<li>全局性启用中断（<code>EINT</code> 或 <code>CLRC INTM</code>）</li>\n<li>等待空的ISR为阻塞中断服务</li>\n<li>全局性禁止中断（<code>DINT</code> 或 <code>SETC INTM</code>）</li>\n<li>修改PIE向量表以将中断向量映射回至其原始的ISR（original ISR）</li>\n<li>为中断的PIE组清除 <code>PIEACK</code> 位</li>\n<li>全局性启用中断（<code>EINT</code> 或 <code>CLRC INTM</code>）</li>\n</ol>\n<h4 id=\"嵌套式中断\">嵌套式中断</h4>\n<p>默认情况下，中断不会嵌套。通过软件操控 <code>IER</code> 和 <code>PIEIERx</code> 寄存器可以实现对中断的嵌套和优先级排序。详见 <a href=\"https://processors.wiki.ti.com/index.php/Interrupt_Nesting_on_C28x\">TI Wiki</a></p>\n<h4 id=\"向量地址有效性检查\">向量地址有效性检查</h4>\n<p>ePIE向量表有两个备份，初级向量表地址在 <code>0xD00</code> 到 <code>0xEFF</code> 之间，冗余向量表的地址在 <code>0x01000D00</code> 到 <code>0x01000EFF</code> 之间。对初级向量表的写入时也将会对冗余向量表进行写入，对冗余向量表的写入仅对冗余向量表有效。读取时，两个向量表互相独立。</p>\n<p>在向量地址获取时，ePIE将会对两个向量表的输出进行比较。如果没有差别，CPU会生成一个地址并存放到 <strong><em>PIEVERRADDR</em></strong> 寄存器中（the CPU branches to the address in the <strong><em>PIEVERRADDR</em></strong> register）并发送错误信号（trip signals）给PWM外设。如果 <strong><em>PIEVERRADDR</em></strong> 寄存器值没有被设置，地址 <code>0x003FFBE</code> 上用于默认启动的ROM句柄将会被使用。</p>\n<h3 id=\"向量表\">向量表</h3>\n<p>《TRM》P89至P95.</p>\n<h3 id=\"不可屏蔽中断和意外\">不可屏蔽中断和意外</h3>\n<h3 id=\"相关寄存器\">相关寄存器</h3>\n<p>下表来自《TRM》P506。下表中，寄存器分为4类：<strong>总控制</strong>、<strong>确认</strong>、<strong>使能</strong> 和 <strong>标志</strong>。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210818103607977.png\" alt=\"image-20210818103607977\" /><figcaption aria-hidden=\"true\">image-20210818103607977</figcaption>\n</figure>\n<h2 id=\"低电量模式\">低电量模式</h2>\n<p>本系列芯片拥有两种 时钟门（clock-gating） 低电量模式，分别是 HALT 和 IDLE，STANDARD 模式不支持进入低电量。</p>\n<p>低电量模式的进入和退出代码，以及更多关于低电量模式的描述信息，需要参考《TRM》手册。</p>\n<p>表33 描述了系统进入任何 时钟门 低电量模式后的影响</p>\n<p>表34 列明了IDLE模式下的时序要求</p>\n<p>表35 列明了IDLE模式下的开断特性</p>\n<p>表36 列明了HALT模式下的时序要求</p>\n<p>表37 列明了HALT模式下的开断特性</p>\n<p>图26 展示了IDLE模式的时序框图</p>\n<p>图27 展示了HALT模式的时序框图</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210712100908714.png\" alt=\"image-20210712100908714\" /><figcaption aria-hidden=\"true\">image-20210712100908714</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210712101034377.png\" alt=\"image-20210712101034377\" /><figcaption aria-hidden=\"true\">image-20210712101034377</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210712101211183.png\" alt=\"image-20210712101211183\" /><figcaption aria-hidden=\"true\">image-20210712101211183</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210712101225955.png\" alt=\"image-20210712101225955\" /><figcaption aria-hidden=\"true\">image-20210712101225955</figcaption>\n</figure>\n<h1 id=\"系统控制\">系统控制</h1>\n<h2 id=\"cla\">CLA</h2>\n<p>在涉及到一些需要使用浮点数计算的场景，就需要打开CLA。如果不打开，会发现32bit的系统上居然出现了int数据类型只有16bit的情况。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210824202520424.png\" alt=\"image-20210824202520424\" /><figcaption aria-hidden=\"true\">image-20210824202520424</figcaption>\n</figure>\n<p>控制律加速器(CLA)2型是一个独立的、完全可编程的、32位浮点数学处理器，它为C28x系列带来了并发的控制回路执行。CLA的低中断延迟允许它“及时”读取ADC示例。这显著减少了ADC样本的输出延迟，以实现更快的系统响应和更高的MHz控制回路。通过使用CLA服务于时间关键的控制回路，主CPU可以自由地执行其他系统任务，如通信和诊断。</p>\n<p>CLA有以下特性：</p>\n<ol type=\"1\">\n<li>C编译器适用于CLA软件开发</li>\n<li>与主核心（SYSCLKOUT）频率一致</li>\n<li>允许CLA算法独立于主核心执行的独立架构\n<ul>\n<li>完整总线架构\n<ul>\n<li>程序地址总线 和 程序数据总线</li>\n<li>数据读取地址总线</li>\n</ul></li>\n</ul></li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210824203000371.png\" alt=\"image-20210824203000371\" /><figcaption aria-hidden=\"true\">image-20210824203000371</figcaption>\n</figure>\n<h3 id=\"cla接口\">CLA接口</h3>\n<p>C28x的主芯片可以接入至CLA和vice versa。</p>\n<p>CLA能够接入三种内存，包括：程序内存、数据内存和信息内存。每一种内存的行为和仲裁后续都会进行描述，CLA内存由DCSM模块（Dual Code Security Module，双代码安全模块）进行保护，可以参考系统控制和中断章节以获取更多安全计划相关的细节。</p>\n<h3 id=\"cla-dma-cpu-仲裁\">CLA / DMA / CPU 仲裁</h3>\n<p>暂略</p>\n<h3 id=\"cla-配置和调试\">CLA 配置和调试</h3>\n<p>暂略</p>\n<h3 id=\"管道\">管道</h3>\n<p>暂略</p>\n<h3 id=\"指令集\">指令集</h3>\n<p>暂略</p>\n<h3 id=\"寄存器-1\">寄存器</h3>\n<p>暂略</p>\n<h2 id=\"dma\">DMA</h2>\n<p>暂略</p>\n<h1 id=\"模拟外设\">模拟外设</h1>\n<p>本系列芯片的模拟外设包含 <strong>ADC</strong> 、 <strong>PGA</strong> 、 <strong>DAC</strong> 和 <strong>CMPSS</strong>。</p>\n<p>所有的模拟引脚一共有16个，包括ADC三个模块（module，A、B、C）、PGA、DAC等都是复用的。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210805172817997.png\" alt=\"image-20210805172817997\" /><figcaption aria-hidden=\"true\">image-20210805172817997</figcaption>\n</figure>\n<p>《TRM》P1420， 下表为模拟子系统寄存器详细：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210809140243693.png\" alt=\"image-20210809140243693\" /><figcaption aria-hidden=\"true\">image-20210809140243693</figcaption>\n</figure>\n<p>模拟子系统寄存器特征：（《TRM》P1410）</p>\n<ul>\n<li>灵活的电压基准\n<ul>\n<li>ADC模块使用 <code>VREFHIx</code> 和 <code>VSSA</code> 引脚提供电压参考</li>\n<li>缓存DAC模块使用 <code>VREFHIx</code> 和 <code>VSSA</code> 引脚提供参考</li>\n<li>比较器DAC模块使用 <code>VDDA</code> 和 <code>VSSA</code> 引脚提供参考</li>\n</ul></li>\n<li>灵活的针脚使用\n<ul>\n<li>缓存DAC输出、比较器子系统输入、PGA功能 和 数字输入 都与 ADC输入复用</li>\n<li>Internal connection to VREFLO on all ADCs for offset self-calibration.</li>\n</ul></li>\n</ul>\n<p>以下为64针封装芯片的模拟系统框图：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210809142619290.png\" alt=\"image-20210809142619290\" /><figcaption aria-hidden=\"true\">image-20210809142619290</figcaption>\n</figure>\n<h2 id=\"adc\">ADC</h2>\n<p>本系列芯片的ADC外设是 <strong>第5类</strong>（TYPE 5）ADC，只支持12位单端模式。以下讨论中可能会看到 ADCA / ADCB / ADCC 三种不同的描述，其实是ADC三个大的模块，模块下面又有很多个通道。</p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210804113737347.png\" alt=\"image-20210804113737347\" style=\"zoom:67%;\" /></p>\n<p>单个ADC模块的简化示意图如下：</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210730103920701.png\" alt=\"image-20210730103920701\" style=\"zoom:67%;\" /></p>\n<p>ADC模拟外设的内部架构如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210730092532193.png\" alt=\"image-20210730092532193\" /><figcaption aria-hidden=\"true\">image-20210730092532193</figcaption>\n</figure>\n<p>SOC和EOC的内部架构如下：</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210730105429591.png\" alt=\"image-20210730105429591\" style=\"zoom:67%;\" /></p>\n<h3 id=\"adc特点\">ADC特点</h3>\n<ul>\n<li>12bit 分辨率</li>\n<li>VREFHI VREFLO</li>\n<li>可选内部参考电压为 2.5V 或 3.3V</li>\n<li>单端信号转换器</li>\n<li>最多16个ADC通道</li>\n<li>16个配置SOC（<code>ADCSOC0</code> ~ <code>ADCSOC15</code>）</li>\n<li>16个独立的可寻址结果寄存器</li>\n<li>四个高级的（flexible）外设中断（每个模块都有 <code>INT1</code> ~ <code>INT4</code>）</li>\n<li>可配置的中断（interrupt placement）</li>\n<li>可以设置爆发模式（Burst Mode）</li>\n<li>多触发源\n<ul>\n<li>S/W ，软件立即启动</li>\n<li>所有的ePWMs（<mark>只有ADC A 或 ADC B 所配置 SOC能够被触发</mark>）</li>\n<li>GPIO XINT2</li>\n<li>可以使用 CPU定时器 0/1/2触发</li>\n<li>可以使用ADC A/B/C 的 INT1/2来配置触发SOC（<mark>可且仅可</mark>）</li>\n</ul></li>\n<li>四个PPB（post-processing blocks），每一个都有：\n<ul>\n<li>Saturating offset calibration</li>\n<li>Error from setpoint calculation</li>\n<li>High, low and zero-crossing compare, with interrupt and ePWM trip capability</li>\n<li>Trigger-to-sample delay capture</li>\n</ul></li>\n</ul>\n<h3 id=\"adc输入模型\">ADC输入模型</h3>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210730091825651.png\" alt=\"image-20210730091825651\" /><figcaption aria-hidden=\"true\">image-20210730091825651</figcaption>\n</figure>\n<p>每个通道的寄生电容</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210730093537064.png\" alt=\"image-20210730093537064\" /><figcaption aria-hidden=\"true\">image-20210730093537064</figcaption>\n</figure>\n<h3 id=\"adc配置项\">ADC配置项</h3>\n<p>ADC模块的 配置项 分为 <strong>可配置</strong>（Configurable）、<strong>不可配置</strong>（Unconfigurable） 两种。可配置项又分为 <strong>可按模块独立配置</strong> 和 <strong>全局配置</strong>（Globally configurable） 两种。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>Options</th>\n<th>Configurability</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong>时钟</strong> Clock</td>\n<td>每个模块（A/B/C）</td>\n</tr>\n<tr class=\"even\">\n<td><strong>分辨率</strong> Resolution</td>\n<td>不可配置（仅12bit）</td>\n</tr>\n<tr class=\"odd\">\n<td><strong>信号模式</strong> Signal mode</td>\n<td>不可配置（仅单端（Single-ended））</td>\n</tr>\n<tr class=\"even\">\n<td><strong>参考电压源</strong> Reference voltage source</td>\n<td>每个模块（外部或内部）</td>\n</tr>\n<tr class=\"odd\">\n<td><strong>触发源</strong> Trigger source</td>\n<td>每个SOC</td>\n</tr>\n<tr class=\"even\">\n<td><strong>转换通道</strong> Converted Channel</td>\n<td>每个SOC</td>\n</tr>\n<tr class=\"odd\">\n<td><strong>获取窗口期</strong> Acquisition window duration</td>\n<td>每个SOC</td>\n</tr>\n<tr class=\"even\">\n<td><strong>EOC定位</strong> EOC location</td>\n<td>每个模块</td>\n</tr>\n<tr class=\"odd\">\n<td><strong>爆发模式</strong> Burst mode</td>\n<td>每个模块</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意</strong>：这里的 <strong>SOC</strong> 是指 <strong>ADCSOC</strong>，start of conversion。</p>\n<h4 id=\"时钟-1\">时钟</h4>\n<p>ADC基础时钟由系统时钟 <strong><em>SYSCLK</em></strong> 提供，用以生成ADC <strong>获取窗口</strong>（acquisition window）。寄存器 <strong><em>ADCCTL2</em></strong> 有一个决定ADC时钟 <strong><em>ADCCLK</em></strong> 的预分频（prescale）区域。<strong><em>ADCCLK</em></strong> 直接为转换器（converter）提供时钟信号。</p>\n<p>转换核心需要约10.5个 <strong><em>ADCCLK</em></strong> 时钟周期来将 输入电压转换成 数字信号，因此需要自行决定和配置获取窗口所需要的周期大小。</p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210805153739063.png\" alt=\"image-20210805153739063\" style=\"zoom: 67%;\" /></p>\n<h4 id=\"分辨率\">分辨率</h4>\n<p>ADC分辨率决定着最终模拟信号能够转换成的数值大小。本系列芯片支持12bit分辨率。</p>\n<h4 id=\"参考电压源\">参考电压源</h4>\n<p>本系列芯片的第16、17引脚是ADC的参考电压：</p>\n<ul>\n<li>第16pin 是ADC A/B/C的高参考电压（Voltage Reference High） <strong><em>VREFHIx</em></strong></li>\n<li>第17pin 是ADC A/B/C的低参考电压（Voltage Reference Low） <strong><em>VREFLOx</em></strong></li>\n</ul>\n<p>根据《TRM》P1442可知，每个ADC模块都可以配置一个单独的参考电压（包括 <strong>VREFHI</strong>和 <strong>VREFLO</strong>），参考电压源可以是内部或外部。需要注意的是，引脚数较少的封装可能在多个ADC之间共享一个VREFHI引脚。在这种情况下，共享一个参考引脚的ADC必须将它们的参考模式配置得完全一样。</p>\n<h5 id=\"外部参考电源\">外部参考电源</h5>\n<p>在外部参考电压模式下，参考电压源的针脚被当做比率测量参考，以测定ADC转换的输入范围。</p>\n<p>以下几点需要注意：</p>\n<ul>\n<li>如果没有连接到具体的外部 <strong><em>VREFLO</em></strong> 信号，需将 <strong><em>VREFLO</em></strong> 连接至 设备模拟地 <strong><em>VSSA</em></strong>。</li>\n<li>外部参考电源（高/低）的输入范围：</li>\n<li><strong><em>VREFHI</em></strong> 针脚要求外接电容。</li>\n</ul>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/08/image-20210805090011967.png\" alt=\"image-20210805090011967\" style=\"zoom:70%;\" /> <img src=\"https://pic.islet.space/2021/08/image-20210805090028640.png\" alt=\"image-20210805090028640\" style=\"zoom:70%;\" />\n</div>\n<h5 id=\"内部参考电源\">内部参考电源</h5>\n<p>选择内部参考电源时，将由芯片设备来为 <strong><em>VREFHI</em></strong> 提供参考电源。 此电源电压可以被配置为 <code>2.5V</code> 或 <code>1.65V</code>，当配置 <code>1.65V</code> 时，模拟输入的范围最大为 <code>3.3V</code> 。</p>\n<p><strong>注意</strong>：内部参考模式同样要求给 VREFHI针脚外接一个电容（具体电容值视具体情况而定）。</p>\n<h5 id=\"ganged参考电源\">Ganged参考电源</h5>\n<p>某些封装中，多个ADC电压参考针脚可能被捆绑在了一起。这种情况下，当选择外部或内部参考模式，以及选择 <code>3.3V</code> 或 <code>2.5V</code> 内部参考电压范围时，有必要对ganged参考进行相同的配置。</p>\n<p>例如，如果 ADC B 和 ADC C参考电源针脚被捆绑在一起，并且需要一个2.5V的内部参考电源时，以下配置代码可供参考：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ADCB VREFHI and ADCC VREFHI share a pin</span></span><br><span class=\"line\"><span class=\"comment\">//ADCB VREFLO and ADCC VREFLO share a pin</span></span><br><span class=\"line\"><span class=\"comment\">//Both references must be explicitly configured</span></span><br><span class=\"line\"><span class=\"comment\">//Both references must be configured identically</span></span><br><span class=\"line\">SetVREF(ADC_ADCB, ADC_INTERNAL, ADC_VREF2P5);</span><br><span class=\"line\">SetVREF(ADC_ADCC, ADC_INTERNAL, ADC_VREF2P5);</span><br></pre></td></tr></table></figure>\n<p>内部硬件设备将确保相同针脚上的多个参考电源不会冲突。（ensure multiple references don't drive conflicting voltages onto the same pin）正因如此，参考电源可以被配置于任意顺序及任意时间。</p>\n<h5 id=\"选择参考模式\">选择参考模式</h5>\n<p>电压参考模式可以用C2000套件提供的 <code>SetVREF()</code> 或 <code>ADC_setVREF()</code> 函数进行配置。使用这些函数时需确保 <strong>修正值</strong>（correct trim）已被载入 ADC trim 寄存器，需要确保设备复位后这些函数至少被调用一次，同时不要通过直接写入 <strong><em>ANAREFCTL</em></strong> 寄存器来配置电压参考模式。</p>\n<h4 id=\"信号模式\">信号模式</h4>\n<p>本系列芯片支持单端模式，通过单根针脚 <code>ADCINx</code> 采样转换器的输入电压，参考点为 <code>VREFLO</code>。</p>\n<h5 id=\"预期expected转换结果\">预期（Expected）转换结果</h5>\n<p>基于给定的模拟输入电压，预期情况下的数字转换结果如下表所示。小数部分省略。</p>\n<table>\n<colgroup>\n<col style=\"width: 50%\" />\n<col style=\"width: 50%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>模拟输入</th>\n<th>数字输出</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>当输入电压低于参考低电压<br><strong><em>ADCINy</em></strong> ≤ <strong><em>VREFLO</em></strong></td>\n<td><strong>最小量程</strong> <code>0x00</code></td>\n</tr>\n<tr class=\"even\">\n<td>当输入电压在高低参考电压之间<br><strong><em>VREFLO</em></strong> &lt; <strong><em>ADCINy</em></strong> &lt; <strong><em>VREFHI</em></strong></td>\n<td><strong>最大量程</strong> <code>0xFFF</code> 和 <strong>输入电压差</strong> / <strong>参考电压差</strong> 之积<br>即 <code>0xFFF * (ADCINy - VREFLO) / (VREFHI - VREFLO)</code></td>\n</tr>\n<tr class=\"odd\">\n<td>当输入电压超过参考高电压<br><strong><em>ADCINy</em></strong> ≥ <strong><em>VREFHI</em></strong></td>\n<td><strong>最大量程</strong> <code>0xFFF</code>（即 <code>2^(12)-1</code>）</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"解释interpreting转换结果\">解释（Interpreting）转换结果</h5>\n<p>基于给定的ADC数字转换结果，来反推理想的对应模拟输入的结果。公式就用上面的表格来反推就好了。</p>\n<h3 id=\"adc寄存器\">ADC寄存器</h3>\n<p>寄存器这边除了描述最基本的 <strong>基地址</strong> （Base Address）以外，还有两类寄存器：<strong>结果寄存器</strong>（Result Register）和 <strong>控制寄存器</strong>（Control Register）。</p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210805085945157.png\" alt=\"image-20210805085945157\" style=\"zoom: 85%;\" /></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210805090938982.png\" alt=\"image-20210805090938982\" /><figcaption aria-hidden=\"true\">image-20210805090938982</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210805090858805.png\" alt=\"image-20210805090858805\" /><figcaption aria-hidden=\"true\">image-20210805090858805</figcaption>\n</figure>\n<p><code>BSY</code> 即 <strong><em>busy</em></strong> ，繁忙状态。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210809100855861.png\" alt=\"image-20210809100855861\" /><figcaption aria-hidden=\"true\">image-20210809100855861</figcaption>\n</figure>\n<ul>\n<li><code>ADCCTL1</code> 包括只读位和读写位。\n<ul>\n<li>只读位主要是涉及一些工作状态的读取，例如，<code>ADCBSY</code> 为 ADC是否正在工作，<code>ADCBSYCHN</code> 为 哪个通道在工作。</li>\n<li>读写位涉及一些可操控的权限，例如 <code>ADCPWDNZ</code> 为 ADC的打开和关闭、<code>INTPULSEPOS</code> 为 ADC脉冲位置</li>\n</ul></li>\n<li><code>ADCCTL2</code> 目前仅有 一个可读写位，即 <code>PRESCALE</code> ，ADC模块的时钟预分频。</li>\n</ul>\n<h3 id=\"adc启动顺序\">ADC启动顺序</h3>\n<p>设备开启或系统级复位时，ADC会被断电禁用。为ADC上电启用时，请遵循以下顺序：</p>\n<ol type=\"1\">\n<li>设置 <code>PCLKCR13</code> 寄存器中的指定位来启用所需 ADC 时钟</li>\n<li>设置 <code>ADCCTL2</code> 寄存器中的 预分频 <code>PRESCALE</code> 位来设置 ADC的时钟分频</li>\n<li>设置 <code>ADCCTL1</code> 寄存器中的 <code>ADCPWDNZ</code> 位来启用 ADC</li>\n<li>采样前启用一个延迟（需要查询具体需要多长）</li>\n</ol>\n<p><strong>注意</strong>：如果多路ADC需要同步开启，第一步和第三步可以通过 <em>同一条写入指令</em>（in one write instruction）来进行配置。因此，也就可以用同一条延迟指令来等待ADC上电启动。</p>\n<h3 id=\"adc时序\">ADC时序</h3>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210807142240064.png\" alt=\"image-20210807142240064\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210807142256816.png\" alt=\"image-20210807142256816\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210807142458766.png\" alt=\"image-20210807142458766\" style=\"zoom:50%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210807142514410.png\" alt=\"image-20210807142514410\" style=\"zoom:50%;\" /></p>\n<h3 id=\"soc操作原则\">SOC操作原则</h3>\n<blockquote>\n<p>Each SOC is a configuration set defining the single conversion of a single channel.</p>\n</blockquote>\n<p>注意上面这句话，<mark>每一个SOC都是一个定义着单通道转换器的配置集</mark>（Configuration Set）。</p>\n<p>如果有需要，多个SOC可以配置于使用相同的触发器、通道 或 采样周期。使用相同的触发器来配置多个SOC的话，触发器可以生成一个转换序列（generate a sequence of conversions），同时相同的触发器和通道可以过采样（oversampling）。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210730094148462.png\" alt=\"image-20210730094148462\" style=\"zoom:80%;\" /></p>\n<p>在SOC配置集中有三个可配置项：</p>\n<ul>\n<li><code>ADCSOCFLG1</code> 启动转换的触发源（the trigger source that starts the conversion），操作某个bit可以启动某个SOC，详见《TRM》P1519</li>\n<li><code>CHSEL</code> 转换通道（the channel to convert），可取值范围为 <code>0h</code> ~ <code>Fh</code>，代表 ADC0 ~ ADC15</li>\n<li><code>ACQPS</code> 捕获窗口/采样周期（the acquisition window duration），可取值范围为 <code>000h</code> ~ <code>1FFh</code></li>\n</ul>\n<blockquote>\n<p>Upon receiving the trigger configured for a soc, the wrapper will ensure that the specified channel is captured using the specified acquisition window duration.</p>\n</blockquote>\n<h4 id=\"acqps的计算\">ACQPS的计算</h4>\n<p><strong>注意</strong>：Acquisition Window 和 ACQPS 不是同一个概念，Acquisition Window 就是下方所述的 <strong><em>S</em> 和 <em>H</em> 的持续时间</strong>。</p>\n<p>参考ADC输入模型简图：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210730091825651.png\" alt=\"image-20210730091825651\" /><figcaption aria-hidden=\"true\">image-20210730091825651</figcaption>\n</figure>\n<p>采样周期和 ACQPS的关系如下：</p>\n<div style=\"text-align: center; font-weight: 900; font-style: italic;\">\nAcquisition window = (ACQPS + 1)∙(System Clock (SYSCLK) cycle time)\n</div>\n<p>以下案例在求解采样周期的基础上，倒推 ACQPS 的设置：</p>\n<p>为了能够正确读取ADC数据，ADC输入信号必须有足够的时间为 <strong>采样和保持电容</strong> <code>Ch</code>（the sample and hold capacitor）充电。通常来说，<em>S</em> 和 <em>H</em> 的持续时间的选择是为了使采样电容被充电到最终值的 ½ LSB 或者 ¼ LSB ，具体取决于可容忍的 settling 误差（tolerable settling error）。</p>\n<p>可以用 RC settling 模块来确定所需的 settling 时间近似值。具体时间常数模型如下方公式：</p>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/08/image-20210805180321634.png\" alt=\"image-20210805180321634\" style=\"zoom:100%;\" />\n</div>\n<p>所需时间常数的数量也由下面等式给出：</p>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/08/image-20210805180508541.png\" alt=\"image-20210805180508541\" style=\"zoom:100%;\" />\n</div>\n<p>最终<em>S</em> 和 <em>H</em> 的持续时间如下方公式所示：</p>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/08/image-20210805180522951.png\" alt=\"image-20210805180522951\" style=\"zoom:100%;\" />\n</div>\n<blockquote>\n<p>ADC输入模块需要提供以下参数：</p>\n<ul>\n<li><code>n</code> = ADC 分辨率 (in bits)</li>\n<li><code>RON</code> = ADC 采样开关电阻 (in Ohms)</li>\n<li><code>CH</code> = ADC 采样电容 (in pF)</li>\n<li><code>Cp</code> = ADC 通道寄生输入电容 (in pF)</li>\n</ul>\n<p>以下参数则取决于应用（硬件/软件）设计： - settling error = tolerable settling error (in LSBs) - Rs = ADC 驱动电流源电阻值 (in Ohms) - CS = ADC 输入引脚上的 <strong><em>寄生电容值</em></strong> (in pF)</p>\n</blockquote>\n<p>通过以下参数来说明计算方式：</p>\n<ul>\n<li>n = 12-bits</li>\n<li>RON = 500Ω</li>\n<li>CH = 12.5pF</li>\n<li>Cp = 12.7pF</li>\n<li>settling error = ¼ LSB</li>\n<li>Rs = 180Ω</li>\n<li>Cs = 150pF</li>\n</ul>\n<p>时间常数计算如下：</p>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/08/image-20210805180544244.png\" alt=\"image-20210805180544244\" style=\"zoom:100%;\" />\n</div>\n<p>所需时间常数的数量如下：</p>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/08/image-20210805180556088.png\" alt=\"image-20210805180556088\" style=\"zoom:100%;\" />\n</div>\n<p>最终结果：</p>\n<div style=\"text-align: center; font-weight: 900;\">\n37.8ns · 7.13 = 270ns\n</div>\n<p>如果系统时间 <strong><em>SYSCLK</em></strong> 为 <code>100 MHz</code> ，周期为 <code>10ns</code> ，则 S和H的持续时间应该是 <code>270 ns/10 ns = 27.0 SYSCLKs</code>，即27个系统时钟周期，为ADC输入信号所要提供的充足的ACQPS应该至少是 <code>CEILING(27.0) – 1 = 26</code></p>\n<p>While this gives a rough estimate of the required acquisition window, a better method would be to setup a circuit with the ADC input model, a model of the source impedance/capacitance, and any board parasitics in SPICE (or similar software) and simulate to verify that the sampling capacitor settles to the desired accuracy.</p>\n<p>参数计算代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*-------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * HEADER FILES</span></span><br><span class=\"line\"><span class=\"comment\">-------------------------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * DATA TYPE DEFINITION</span></span><br><span class=\"line\"><span class=\"comment\">-------------------------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">double</span> ADCPARAM;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * MACRO DEFINITION</span></span><br><span class=\"line\"><span class=\"comment\">-------------------------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ADC_RESOLUTION 12  <span class=\"comment\">//定义分辨率为12位</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LSB 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * GLOBAL PARAMETERS</span></span><br><span class=\"line\"><span class=\"comment\">-------------------------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"comment\">// r for Resistance , c for Capacitance </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">adc_parameters</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">short</span> resolution;  <span class=\"comment\">//分辨率</span></span><br><span class=\"line\">    ADCPARAM r_on;  <span class=\"comment\">// ADC采样开关电阻</span></span><br><span class=\"line\">    ADCPARAM c_hold;   <span class=\"comment\">// ADC采样和保持电容</span></span><br><span class=\"line\">    ADCPARAM c_parasitic;   <span class=\"comment\">// ADC通道寄生输入电容</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ADCPARAM settling_error;  <span class=\"comment\">//可容忍的沉降误差</span></span><br><span class=\"line\">    ADCPARAM r_source;  <span class=\"comment\">//ADC驱动电流源上的电阻值</span></span><br><span class=\"line\">    ADCPARAM c_source;  <span class=\"comment\">//ADC输入引脚上的寄生电容值</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * FUNCTION DECLARATION</span></span><br><span class=\"line\"><span class=\"comment\">-------------------------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"function\">ADCPARAM <span class=\"title\">timeConstanceCalc</span><span class=\"params\">(ADCPARAM, ADCPARAM, ADCPARAM, ADCPARAM, ADCPARAM)</span></span>;</span><br><span class=\"line\"><span class=\"function\">ADCPARAM <span class=\"title\">numberCalc</span><span class=\"params\">(ADCPARAM, ADCPARAM, ADCPARAM, ADCPARAM, ADCPARAM)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * MAIN FUNCTIONS</span></span><br><span class=\"line\"><span class=\"comment\">-------------------------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意： 所有电容值单位为 pF， 所有电阻值单位为 Ω</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">adc_parameters</span> <span class=\"title\">ADC1</span>;</span></span><br><span class=\"line\">    ADC1.resolution = ADC_RESOLUTION;  <span class=\"comment\">// 不可修改</span></span><br><span class=\"line\">    ADC1.r_on = <span class=\"number\">500</span>;  <span class=\"comment\">//不变</span></span><br><span class=\"line\">    ADC1.c_hold = <span class=\"number\">12.5</span>;  <span class=\"comment\">//不变</span></span><br><span class=\"line\">    ADC1.c_parasitic = <span class=\"number\">12.7</span>;  <span class=\"comment\">//不变</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ADC1.settling_error = <span class=\"number\">1</span>/<span class=\"number\">4.0</span> *LSB;  <span class=\"comment\">//不要写1/4 *LSB，会得出无限大的数据（inf）</span></span><br><span class=\"line\">    ADC1.r_source = <span class=\"number\">1000</span>;   <span class=\"comment\">//实际使用1kΩ，原180</span></span><br><span class=\"line\">    ADC1.c_source = <span class=\"number\">10000</span>;     <span class=\"comment\">//带入0.1uF计算，原150</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ADCPARAM result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    result = <span class=\"built_in\">timeConstanceCalc</span>(ADC1.r_source, ADC1.r_on, ADC1.c_hold, ADC1.c_source, ADC1.c_parasitic) * <span class=\"built_in\">numberCalc</span>(ADC1.resolution, ADC1.settling_error, ADC1.c_source, ADC1.c_parasitic, ADC1.c_hold);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;ADC采样和保持的时间为&quot;</span>  &lt;&lt; result &lt;&lt; <span class=\"string\">&quot;ns&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * FUNCTION DEFINITIONS</span></span><br><span class=\"line\"><span class=\"comment\">-------------------------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"function\">ADCPARAM <span class=\"title\">timeConstanceCalc</span><span class=\"params\">(ADCPARAM Rs, ADCPARAM Ron, ADCPARAM Ch, ADCPARAM Cs, ADCPARAM Cp)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ( ( Rs + Ron ) * Ch + Rs * ( Cs + Cp ) ) /<span class=\"number\">1000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ADCPARAM <span class=\"title\">numberCalc</span><span class=\"params\">(ADCPARAM n, ADCPARAM se, ADCPARAM Cs, ADCPARAM Cp, ADCPARAM Ch)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">log</span>( <span class=\"built_in\">exp2</span>(n) / se ) - <span class=\"built_in\">log</span>( (Cs + Cp) / Ch);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"触发配置示例\">触发配置示例</h4>\n<p>官方SOC配置样例提供了四种：<strong>ePWM触发单次转换</strong>，<strong>ePWM触发超采样转换</strong>，<strong>CPU定时器触发多重转换</strong> 和 <strong>软件触发转换</strong></p>\n<h5 id=\"epwm触发单次转换\">ePWM触发单次转换</h5>\n<p>当ePWM计时器到达周期时，为了配置好 ADCA模块，以生成通道 ADCIN1 上的单次转换，有以下步骤需要操作：</p>\n<ol type=\"1\">\n<li>ePWM3必须被配置并生成一个SOCA 或 SOCB 信号（这种状态下，SOC的转换启动信号就由ePWM模块提供）。</li>\n<li>以SOCB为例，使用SOC5，且选择任意16通道的其中一个。</li>\n<li>假设在 系统频率为 100MHz时，需要100ns的采样周期，那么就需要AW（Acquisition Window）的持续时间为 <code>100ns / 10ns = 10 cycles</code>，<code>ACQPS</code> 需要设置为 <code>10 - 1 = 9</code> 。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">AdcaRegs.ADCSOC5CTL.bit.CHSEL = <span class=\"number\">1</span>; <span class=\"comment\">//SOC5 will convert ADCINA1</span></span><br><span class=\"line\">AdcaRegs.ADCSOC5CTL.bit.ACQPS = <span class=\"number\">9</span>; <span class=\"comment\">//SOC5 will use sample duration of 10 SYSCLK cycles </span></span><br><span class=\"line\">AdcaRegs.ADCSOC5CTL.bit.TRIGSEL = <span class=\"number\">10</span>; <span class=\"comment\">//SOC5 will begin conversion on ePWM3 SOCB</span></span><br></pre></td></tr></table></figure>\n<p>如上配置后，当ePWM3 到达其周期并生成一个SOCB信号，如果ADC此时处于空闲状态，ADC将会对通道 ADCINA1（SOC5） 立即进行采样；如果此时ADC繁忙，ADCINA1将会在SOC5获得权限后开始采样。ADC控制逻辑将会使用指定100ns的捕获窗口宽度对ADCINA1进行采样。在捕获完成后，ADC会立即开始转换采样电压为数字信号。当ADC转换完成时，结果将存放在 <code>ADCRESULT5</code> 寄存器。</p>\n<h5 id=\"epwm触发超采样转换\">ePWM触发超采样转换</h5>\n<p>ADC可以配置超采样，即在相同的采样周期下，对同一个通道采样超过1次的采样方法。因为 SOC / 通道 / 触发 等配置参数可重复的特殊性，因此可以用于配置超采样。</p>\n<p>为了配置ADC对通道 ADCINA1 超采样到达4次，此处使用和之前相同的配置，分别应用到 SOC5 / SOC6 / SOC7 和 SOC8 上。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">AdcaRegs.ADCSOC5CTL.bit.CHSEL = <span class=\"number\">1</span>; <span class=\"comment\">//SOC5 will convert ADCINA1</span></span><br><span class=\"line\">AdcaRegs.ADCSOC5CTL.bit.ACQPS = <span class=\"number\">9</span>; <span class=\"comment\">//SOC5 will use sample duration of 10 SYSCLK cycles </span></span><br><span class=\"line\">AdcaRegs.ADCSOC5CTL.bit.TRIGSEL = <span class=\"number\">10</span>; <span class=\"comment\">//SOC5 will begin conversion on ePWM3 SOCB</span></span><br><span class=\"line\">AdcaRegs.ADCSOC6CTL.bit.CHSEL = <span class=\"number\">1</span>; <span class=\"comment\">//SOC6 will convert ADCINA1</span></span><br><span class=\"line\">AdcaRegs.ADCSOC6CTL.bit.ACQPS = <span class=\"number\">9</span>; <span class=\"comment\">//SOC6 will use sample duration of 10 SYSCLK cycles </span></span><br><span class=\"line\">AdcaRegs.ADCSOC6CTL.bit.TRIGSEL = <span class=\"number\">10</span>; <span class=\"comment\">//SOC6 will begin conversion on ePWM3 SOCB</span></span><br><span class=\"line\">AdcaRegs.ADCSOC7CTL.bit.CHSEL = <span class=\"number\">1</span>; <span class=\"comment\">//SOC7 will convert ADCINA1</span></span><br><span class=\"line\">AdcaRegs.ADCSOC7CTL.bit.ACQPS = <span class=\"number\">9</span>; <span class=\"comment\">//SOC7 will use sample duration of 10 SYSCLK cycles </span></span><br><span class=\"line\">AdcaRegs.ADCSOC7CTL.bit.TRIGSEL = <span class=\"number\">10</span>; <span class=\"comment\">//SOC7 will begin conversion on ePWM3 SOCB</span></span><br><span class=\"line\">AdcaRegs.ADCSOC8CTL.bit.CHSEL = <span class=\"number\">1</span>; <span class=\"comment\">//SOC8 will convert ADCINA1</span></span><br><span class=\"line\">AdcaRegs.ADCSOC8CTL.bit.ACQPS = <span class=\"number\">9</span>; <span class=\"comment\">//SOC8 will use sample duration of 10 SYSCLK cycles </span></span><br><span class=\"line\">AdcaRegs.ADCSOC8CTL.bit.TRIGSEL = <span class=\"number\">10</span>; <span class=\"comment\">//SOC8 will begin conversion on ePWM3 SOCB</span></span><br></pre></td></tr></table></figure>\n<p>如上配置后，当ePWM3 到达其周期并生成一个SOCB信号，如果ADC此时处于空闲状态，ADC将会对通道 ADCINA1（SOC5） 立即进行采样；如果此时ADC繁忙，ADCINA1将会在SOC5获得权限后开始采样。一旦SOC5的转换完成，SOC5 的结果将会存放于 <code>ADCRESULT5</code> 寄存器，同时 SOC6 将会开始转换。该组转换（4个单次转换）将会依次完成（completed sequentially），转换结果也是依次存放于对应序号的寄存器中。</p>\n<div style=\"color: red; font-weight: 900;\">\n采样转换结果存储的寄存器编号 与其 SOC编号一致，与SOC所选择的通道无关。\n</div>\n<p><strong>注意</strong>：ADC转换启动顺序可以设置为 SOC6 / SOC7 / SOC8 / SOC5，取决于接收ePWM触发时 round-robin 指针的位置，以上情况虽然可以实现，但没有必要这样搞。详见 13.5 部分。</p>\n<h5 id=\"cpu定时器触发多重转换\">CPU定时器触发多重转换</h5>\n<p>基于不同的采样周期对多个信号进行采样。</p>\n<p>CPU1 定时器2 被用以生成采样触发器（具体配置方法看《系统控制和中断（System Control and Interrupt）》章节的《CPU定时器（CPU Timer）》部分）</p>\n<p>步骤如下：</p>\n<ol type=\"1\">\n<li>当设置多重采样方法时，先列写出所有信号及其所需要的采样周期。</li>\n<li>计算每个信号所需的系统时间 SYSCLK 周期 及其 ACQPS 寄存器值，如下表 13-5。</li>\n<li>决策哪个ADC针脚连接到每个信号，取决于应用板的布局。一旦针脚选定，通道值就可以直接设定了，如下表13-6。</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210807110435097.png\" alt=\"image-20210807110435097\" /><figcaption aria-hidden=\"true\">image-20210807110435097</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210807110451836.png\" alt=\"image-20210807110451836\" /><figcaption aria-hidden=\"true\">image-20210807110451836</figcaption>\n</figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">AdcaRegs.ADCSOC0CTL.bit.CHSEL = <span class=\"number\">5</span>; <span class=\"comment\">//SOC0 will convert ADCINA5</span></span><br><span class=\"line\">AdcaRegs.ADCSOC0CTL.bit.ACQPS = <span class=\"number\">23</span>; <span class=\"comment\">//SOC0 will use sample duration of 24 SYSCLK cycles </span></span><br><span class=\"line\">AdcaRegs.ADCSOC0CTL.bit.TRIGSEL = <span class=\"number\">3</span>; <span class=\"comment\">//SOC0 will begin conversion on CPU1 Timer 2</span></span><br><span class=\"line\">AdcaRegs.ADCSOC1CTL.bit.CHSEL = <span class=\"number\">0</span>; <span class=\"comment\">//SOC1 will convert ADCINA0</span></span><br><span class=\"line\">AdcaRegs.ADCSOC1CTL.bit.ACQPS = <span class=\"number\">88</span>; <span class=\"comment\">//SOC1 will use sample duration of 89 SYSCLK cycles </span></span><br><span class=\"line\">AdcaRegs.ADCSOC1CTL.bit.TRIGSEL = <span class=\"number\">3</span>; <span class=\"comment\">//SOC1 will begin conversion on CPU1 Timer 2</span></span><br><span class=\"line\">AdcaRegs.ADCSOC2CTL.bit.CHSEL = <span class=\"number\">3</span>; <span class=\"comment\">//SOC2 will convert ADCINA3</span></span><br><span class=\"line\">AdcaRegs.ADCSOC2CTL.bit.ACQPS = <span class=\"number\">21</span>; <span class=\"comment\">//SOC2 will use sample duration of 22 SYSCLK cycles </span></span><br><span class=\"line\">AdcaRegs.ADCSOC2CTL.bit.TRIGSEL = <span class=\"number\">3</span>; <span class=\"comment\">//SOC2 will begin conversion on CPU1 Timer 2</span></span><br><span class=\"line\">AdcaRegs.ADCSOC3CTL.bit.CHSEL = <span class=\"number\">2</span>; <span class=\"comment\">//SOC3 will convert ADCINA2</span></span><br><span class=\"line\">AdcaRegs.ADCSOC3CTL.bit.ACQPS = <span class=\"number\">58</span>; <span class=\"comment\">//SOC3 will use sample duration of 59 SYSCLK cycles </span></span><br><span class=\"line\">AdcaRegs.ADCSOC3CTL.bit.TRIGSEL = <span class=\"number\">3</span>; <span class=\"comment\">//SOC3 will begin conversion on CPU1 Timer 2</span></span><br></pre></td></tr></table></figure>\n<p>如上配置后，当CPU1 定时器2生成事件，SOC0 / SOC1 / SOC2 / SOC3 将会按顺序启动采样和转换。ADCIN5 的结果将会存放在 <code>ADCRESULT0</code> 中，其他采样结果也是依次存储。</p>\n<div style=\"color: red; font-weight: 900;\">\n采样转换结果存储的寄存器编号 与其 SOC编号一致，与SOC所选择的通道无关。\n</div>\n<h5 id=\"软件触发转换\">软件触发转换</h5>\n<p>不论SOC是否配置具体的触发器，软件触发都可以让SOC实现转换。可以通过对 <code>ADCSOCFRC1</code> 寄存器写入来实现。</p>\n<p>前述案例使用定时器2来触发转换，使用软件触发可以在不等待定时器的情况下实现立即采样和转换：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">AdcaRegs.ADCSOCFRC1.all = <span class=\"number\">0x000F</span>; <span class=\"comment\">//set SOC flags for SOC0 to SOC3</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"转换优先级\">转换优先级</h4>\n<p>当同一时间配置多重SOC标志时，多个SOC的优先级顺序有两种决定模式：<strong><em>Round-Robin 模式</em></strong> 和 <strong><em>High-Priority 模式</em></strong>。</p>\n<p>默认优先级模式是 Round-Robin（后简称RR），这种模式下所有SOC优先级都一致。优先级由RR指针决定，RR指针 <code>RRPOINTER</code> 映射在 <code>ADCSOCPRIORITYCTL</code> 寄存器中，</p>\n<blockquote>\n<p>The <code>RRPOINTER</code> reflected in the <code>ADCSOCPRIORITYCTL</code> register points to the last SOC converted. ?????</p>\n</blockquote>\n<h3 id=\"eoc操作原则\">EOC操作原则</h3>\n<p>每一个SOC都有一个对应的EOC（End of Conversion）信号。EOC信号可以从来触发ADC中断。</p>\n<p>ADC能够配置于在 <strong>捕获窗口期结束时</strong>（end of the acquisition window） 或 <strong>电压转换结束时</strong>（end of the voltage conversion） 生成EOC脉冲，使用 <code>ADCCTL1</code> 寄存器的 <code>INTPULSEPOS</code> 位来进行配置。</p>\n<p>每个ADC模块都拥有4个可配置的ADC中断，这些中断能够被16个EOC的任意一个触发。每一个 <code>ADCINT</code> 的标志位都能够被直接读取，用以判断绑定的SOC是否完成或中断能否被传递至PIE。</p>\n<p><strong>注意</strong>：<code>ADCCTL1.ADCBSY</code> 位被清除不代表一个SOC里的所有转换都完成了，只有ADC准备好处理下一次转换时才能说明上一次已经完成。为了确定一组SOC是否已经完成，将 <code>ADCINT</code> 标志连接到 队列中的上一个SOC里，并观察它。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210730105429591.png\" alt=\"image-20210730105429591\" style=\"zoom:67%;\" /></p>\n<h4 id=\"中断溢出\">中断溢出</h4>\n<p>如果EOC信号在 <code>ADCINTFLG</code> 寄存器中设置一个标志，但该位置上早已设置过标志了，就会出现中断溢出（interrupt overflow）。默认情况下，溢出中断不会被传递给PIE模块。当 <code>ADCINTFLG</code> 寄存器发生溢出时，对应的 <code>ADCINOVF</code> 寄存器就会被设置。<code>ADCINOVF</code> 寄存器上的标志位仅用于检测是否溢出，并不会阻止中断溢出到PIE模块。</p>\n<p>当ADC中断溢出可能发生时，软件应该在ISR 或 后台循环 中检查 <code>ADCINOVF</code> 对应的标志位，并当检测到溢出时采取相应的措施。以下代码演示了如何在尝试清除 <code>ADCINT</code> 标志后，在ISR中检查 <code>ADCINOVF</code> 标志：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = <span class=\"number\">1</span>; <span class=\"comment\">//clear INT1 flag for ADC-A</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"number\">1</span> == AdcaRegs.ADCINTOVF.bit.ADCINT1)&#123; <span class=\"comment\">//ADCINT overflow occurred</span></span><br><span class=\"line\"> AdcaRegs.ADCINTOVFCLR.bit.ADCINT1 = <span class=\"number\">1</span> <span class=\"comment\">//Clear overflow flag </span></span><br><span class=\"line\"> AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = <span class=\"number\">1</span> <span class=\"comment\">//Re-clear ADCINT flag</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"adc中断\">ADC中断</h3>\n<p>查询《TRM》第1496页可以看到有关ADC中断控制，主要有以下几个寄存器，涉及 <strong>中断标志设置</strong>、<strong>中断溢出设置</strong>、<strong>中断信号选择设置</strong>、<strong>中断SOC选择设置</strong> 和 <strong>SOC优先级控制</strong>。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210809083644966.png\" alt=\"image-20210809083644966\" /><figcaption aria-hidden=\"true\">image-20210809083644966</figcaption>\n</figure>\n<ul>\n<li><code>ADCINTSELxNx</code> 是负责控制ADC中断输出的 <strong>模式</strong>（Mode）、<strong>使能</strong>（Enable） 和 <strong>触发源</strong>（Trigger Source）。\n<ul>\n<li><strong>模式</strong>：<u>手动清除<code>ADCINTFLG</code> 寄存器的 <code>ADCINTx</code> 位时生成ADC 中断脉冲</u> 或 <u>EOC脉冲生成时ADC中断脉冲</u></li>\n<li><strong>使能</strong>：中断脉冲打开或关闭</li>\n<li><strong>触发源</strong>：由 <code>EOCx</code> 触发 本中断</li>\n</ul></li>\n<li><code>ADCINTFLG</code> 是 <strong>只读</strong> 寄存器，每个ADC模块都有该寄存器，<code>0</code> 则代表 没有脉冲生成， <code>1</code> 则代表脉冲已生成</li>\n<li><code>ADCINTFLGCLR</code> 是 <strong><em>只能写 <code>1</code></em></strong> 的寄存器，读取时会默认写0，在对应中断位写 <code>1</code> 时清除该中断 和 对应的中断结果标志</li>\n<li><code>ADCINTOVF</code> 也是个 <strong>只读</strong> 的标志寄存器，检测是否有中断溢出。</li>\n<li><code>ADCINTOVFCLR</code> 为中断溢出清除寄存器，同样也是 <strong><em>只能写 <code>1</code></em></strong> 的寄存器。</li>\n<li><code>ADCINTSOCSELx</code> 为 ADC中断生成后是否会触发其他 SOC的设置寄存器，只有 第一中断（INT1）和第二中断（INT2）可以触发 SOC。</li>\n<li><code>ADCSOCPRICTL</code> 为中断优先级寄存器，需要联系SOC的转换优先级和《TRM》P1513来查看。</li>\n</ul>\n<h3 id=\"配置样例\">配置样例</h3>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210809100254146.png\" alt=\"image-20210809100254146\" /><figcaption aria-hidden=\"true\">image-20210809100254146</figcaption>\n</figure>\n<h4 id=\"配置流程\">配置流程</h4>\n<p>在配置ADC时，需要思考好项目应用的具体场景和功能，设置哪个通道（Channel，如ADCA1）来检测信号，设置哪个模块的哪个SOC来绑定该通道（如ADCA的SOC1），SOC和EOC是一一对应的，接着需要设置EOC和哪个模块中断（<code>INTx</code>）进行绑定。</p>\n<pre class=\"mermaid\">graph TD\n将通道中断/中断程序与中断向量表绑定 --> 设置参考电压VREF --> 配置Module --> 配置SOC --> 配置EOC/中断</pre>\n<p>如果不涉及超采样、多重采样等模式，可以不考虑SOC的优先级配置。</p>\n<h3 id=\"总结\">总结</h3>\n<p>外设ADC配置过程中，最容易将ADC模块（A/B/C）、SOC序号、EOC序号、通道序号 和 模块中断序号之间互相搞混，配置时需要先画草图理清思路再行配置。</p>\n<p>启用多个ADC通道时，需要注意模拟外设的引脚有限，某些SOC、ADC模块会复用，画图工作量会大些。</p>\n<figure>\n<img src=\"I:\\00.LEARNING\\ADC模块理解_1.png\" alt=\"ADC模块理解\" /><figcaption aria-hidden=\"true\">ADC模块理解</figcaption>\n</figure>\n<h1 id=\"控制外设\">控制外设</h1>\n<p>本系列芯片的控制外设包含 <strong>eCAP</strong>、<strong>HRCAP</strong>、<strong>ePWM</strong>、<strong>HRPWM</strong>、<strong>eQEP</strong> 和 <strong>SDFM</strong>。</p>\n<p>根据《SPRU566N》表11 可知，ePWM 和 HRPWM 都是4型增强外设，具体功能可以参见《SPRUI33D》。</p>\n<h2 id=\"epwm\">ePWM</h2>\n<p>ePWM是商业和工业控制电力系统的关键组成部分。这些系统包括 <u>数字电机控制</u>、<u>开关电源控制</u>、<u>不间断电源供应</u> 或 其他形式的电源转换。</p>\n<p>ePWM这个大的外设模块（Module）组成，是由8个子模块（Submodule）构成的。所有的ePWM模块用数字尾缀来表示第几个ePWM模块，如 <code>ePWM1</code>、<code>ePWM3</code> 。每个ePWM模块又有两个输出，分别是 A 和 B，例如 <code>ePWM1A</code> 和 <code>ePWM1B</code> 。</p>\n<p>ePWM模块通过一条时钟同步表（clock synchronization scheme）同步和串联在一起，形成可以统一操作的整体。此外，这个时钟同步表能够被扩展至 eCAP 外设使用。子模块的数量是由设备（设计）和实际使用需求决定的，每个子模块都能够支持单独操作。</p>\n<p>ePWM 模块通过两个PWM输出（<code>EPWMxA</code> 和 <code>EPWMxB</code>）来组成一条完整的PWM通道。多路 ePWM被在一个设备内实现，几乎每一个ePWM通道实例都是相同的，只有一个例外。有些实例包括一个硬件扩展，可以更精确地控制PWM输出。这种扩展是高分辨率脉宽调制器（HRPWM），在第18.15节中有描述。每个ePWM模块都用一个以1开头的数值表示，例如，<code>ePWM1</code> 是系统中的第一个实例，<code>ePWM3</code> 是第三个实例，<code>ePWMx</code> 表示任何实例。</p>\n<p>每一个ePWM模块都被连接至输入和输出信号。每一个ePWM模块都包含着8个子系统，并通过图18-2的方式连接至系统内部。</p>\n<h3 id=\"图表\">图表</h3>\n<p><strong><em>表 5-57</em></strong> 展示了PWM的时间要求，主要是 同步（Sync）/非同步（Async）/带输入验证（With input qualifier）的 <strong><em>同步输入脉冲宽度</em></strong>（Sync Input Pulse Width）的三种时间</p>\n<p><strong><em>表 5-58</em></strong> 展示了PWM的开关特性，包括最小脉冲周期，同步输出脉冲宽度 和 t<span style=\"font-size: 0.6rem;\">d(TZ-PWM)</span></p>\n<p><strong><em>表 5-59</em></strong></p>\n<p><strong><em>表 18-21</em></strong> 展示了ePWM外设下的各寄存器（自《SPRUI33D》Page 1885）,<mark>约有81个寄存器</mark>。</p>\n<p><strong><em>图 18-1</em></strong> 描述的是外围总线上的多个PWM模块，及输入信号和输出信号通路示例</p>\n<p><strong><em>图 18-2</em></strong> 描述的是PWM模块下各子模块和信号连接方式（简图）</p>\n<p><strong><em>图 5-58</em></strong> 描述的是ePWM内部的子模块和信号连接方式（结构图）</p>\n<p><strong><em>图 5-59</em></strong></p>\n<p><strong><em>图 5-60</em></strong> 为TB计数器同步链。</p>\n<p><strong><em>图 5-61</em></strong> PWM高阻态时序特性</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210715140249937.png\" alt=\"image-20210715140249937\" style=\"zoom:80%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210715141719524.png\" alt=\"image-20210715141719524\" style=\"zoom:80%;\" /></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210712104641579.png\" alt=\"image-20210712104641579\" /><figcaption aria-hidden=\"true\">image-20210712104641579</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210712104655718.png\" alt=\"image-20210712104655718\" /><figcaption aria-hidden=\"true\">image-20210712104655718</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210712104857729.png\" alt=\"image-20210712104857729\" /><figcaption aria-hidden=\"true\">image-20210712104857729</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210712104928659.png\" alt=\"image-20210712104928659\" /><figcaption aria-hidden=\"true\">image-20210712104928659</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210723095251220.png\" alt=\"image-20210723095251220\" /><figcaption aria-hidden=\"true\">image-20210723095251220</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210723095318306.png\" alt=\"image-20210723095318306\" /><figcaption aria-hidden=\"true\">image-20210723095318306</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210723095334783.png\" alt=\"image-20210723095334783\" /><figcaption aria-hidden=\"true\">image-20210723095334783</figcaption>\n</figure>\n<p>《TRM》P1841，简化过的ePWM模型：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210802142302371.png\" alt=\"image-20210802142302371\" /><figcaption aria-hidden=\"true\">image-20210802142302371</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210802142447715.png\" alt=\"image-20210802142447715\" /><figcaption aria-hidden=\"true\">image-20210802142447715</figcaption>\n</figure>\n<h3 id=\"time-base-submodule\">【#】Time-Base Submodule</h3>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210723083549303.png\" alt=\"TB子模块的信号和寄存器\" /><figcaption aria-hidden=\"true\">TB子模块的信号和寄存器</figcaption>\n</figure>\n<p>PWM事件的周期被 <strong><em>TBPRD寄存器</em></strong> 和 <strong><em>TB计数器的模式</em></strong> 控制着。TB计数器的三种工作模式由 <strong><em>TB控制寄存器</em></strong> （<em>TBCTL</em>）控制，分别为 <strong>增计数</strong>（Up-Count）、<strong>减计数</strong>（Down-Count）和 <strong>增减计数</strong>（Up-Down-Count）。</p>\n<p>影子周期寄存器（shadow period register）的内存地址（memory address）与活跃寄存器相同。<strong><em>TB控制寄存器</em></strong> （<em>TBCTL</em>）下的 <strong><em>PRDLD位</em></strong> 控制着要读写哪个寄存器，同时控制着是否使能影子寄存器，此时可分为 <strong><em>TB周期影子模式</em></strong>（Time-Base Period Shadow Mode） 或 <strong><em>TB周期即刻载入模式</em></strong>（Time-Base Period Immediate Load Mode）。</p>\n<p>在TB计数器同步链中，<strong><em>EXTSYNC1</em></strong> 由 <strong><em>INPUTXBAR5</em></strong> 输入而得，<strong><em>EXTSYNC2</em></strong> 由 <strong><em>INPUTXBAR6</em></strong> 输入而得。而这些输入信号可以通过配置选择任意GPIO作为同步输入源。<mark>在使用 SYNCSEL 寄存器配置同步链传播路径时，应确保最长的路径不超过四个 ePWM/eCAP 模块。</mark></p>\n<p>每个ePWM模块配置时都可以选择使用或者无视同步输入。如果 TBCTL[PHSEN] 位被设置了，且发生 <strong>同步输入脉冲</strong>（Synchronization Input Pulse）、 <strong>软件强制同步脉冲</strong>（Software Forced Synchronization Pulse） 或 <strong>数字比较事件同步脉冲</strong>（Digital Compare Event Synchronization Pulse） 三者之一的情况时，<strong>TB计数器</strong>（<strong>TBCTR</strong>）会自动加载 <strong>相位寄存器</strong>（<strong>TBPHS</strong>） 的内容。</p>\n<h4 id=\"术语\">术语</h4>\n<p><em>Up-Down-Count Mode</em>: <strong>增减计数</strong>，TB计数器从0开始自增计数直到等于周期值（TBPRD值）。当与该值相等时，TB计数器会 <mark>逐步自减至0</mark>。接着周而复始，重新开始自增。</p>\n<p><em>Up-Count Mode</em>: <strong>增计数</strong>，TB计数器从0开始自增计数直到等于周期值（TBPRD值）。当与该值相等时，TB计数器 <mark>直接归零</mark>，接着周而复始，重新开始自增。</p>\n<p><em>Down-Count Mode</em>: <strong>减计数</strong>，TB计数器从周期值（TBPRD值）开始自减至0。当到达0值时，TB计数器直接重置TBPR值，接着周而复始，重新开始自减。</p>\n<p><em>Active Register</em>: <strong>活跃寄存器</strong>，控制着硬件，并对硬件触发或调用（ causes or invokes）的事件进行响应。</p>\n<p><em>Shadow Register</em>: <strong>影子寄存器</strong>，为活跃寄存器提供缓存，即临时存储空间（ temporary holding location）。不对任何控制硬件造成直接影响。 在关键时刻（at a strategic point in time ），影子寄存器的内容将会传递给活跃寄存器。可以避免因软件异步修改造成的崩溃或假操作（corruption or spurious operation）。</p>\n<p><em>Time-Base Period Shadow Mode</em>: <strong>TB周期影子模式</strong>，当 <code>TBCTL[PRDLD]=0</code> 时，影子寄存器打开。对<strong><em>TBPRD</em></strong>内存地址的读写操作将会影响到影子寄存器。当TB计数器为零（<code>TBCTR=0x00</code>）时，影子寄存器的内容会被传输到活跃寄存器。<strong><em>TBCTL2</em></strong>[PRDLDSYNC] 位决定着同步时间。当且仅当 <strong><em>TBCTL</em></strong>[PRDLD] 值为0时，PRDLDSYNC位的值有效。默认情况下，影子寄存器开启。 通过配置 <strong>全局负载配置寄存器</strong>（<strong><em>GLDCFG</em></strong>）中对应的位，全局负载控制机制就能够和TB周期寄存器被一起使用。当全局复杂模式选通时，从影子寄存器到活跃寄存器的内容传输</p>\n<p><em>Time-Base Period Immediate Load Mode</em>: <strong>TB周期即刻载入模式</strong>，当 <code>TBCTL[PRDLD]=1</code> 时，即刻载入模式开启。对TBPRD内存地址的读写操作将会直接载入到活跃寄存器。</p>\n<p><em>Time-Base Clock Synchronization</em>: <strong>TB时钟同步</strong>，外设时钟使能寄存器（peripheral clock enable registers）里的 <strong><em>TBCLKSYNC</em></strong> 位 允许所有用户将所有已开启的ePWM模块同步至TB时钟（TBCLK）。开启时，所有已开启的模块时钟会与TBCLK的第一个上升沿对齐。为了完美地同步TBCLK，所有ePWM模块的预分频都要明确设置。</p>\n<p><em>Time-Base Counter Synchronization</em>: <strong>TB计数同步</strong>，每个ePWM模块都有一个 <strong>同步输入</strong>（SYNCI）、一个 <strong>同步输出</strong>（SYNCO） 和 一个 <strong>外设同步输出</strong>（SYNCPER）。</p>\n<p><em>Synchronization Input Pulse</em>: <strong>同步输入脉冲</strong>，当检测到输入同步脉冲时，相位寄存器的值被载入至计数器中。这个载入操作会在下一个有效的TB时钟（TBCLK）边沿发生。</p>\n<p><em>Software Forced Synchronization Pulse</em>: <strong>软件强制同步脉冲</strong>，</p>\n<p><em>Digital Compare Event Synchronization Pulse</em>: <strong>数字比较事件同步脉冲</strong>，</p>\n<p>开启ePWM时钟的步骤如下：</p>\n<ol type=\"1\">\n<li>在 PCLKCRx 寄存器里，使能ePWM模块时钟</li>\n<li>设置 <code>TBCLKSYNC = 0</code></li>\n<li>配置模块</li>\n<li>设置 <code>TBCLKSYNC = 1</code></li>\n</ol>\n<blockquote>\n<p>CTR，Counter的缩写。</p>\n</blockquote>\n<h4 id=\"图表-1\">图表</h4>\n<p><strong><em>图 18-6</em></strong> 展示了当TB计数器周期设置为4时，增计数、减计数 和 增减计数 三种模式下的PWM周期和频率的关系。时间自增的步长由从ePWM时钟分频而来的时基时钟（TBCLK）定义。</p>\n<p><strong><em>表 18-2</em></strong> 是对关键TB信号的详细描述。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210723090439017.png\" alt=\"image-20210723090439017\"  /></p>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/07/image-20210723104144586.png\" alt=\"image-20210723104144586\" style=\"zoom:60%;\" /><img src=\"https://pic.islet.space/2021/07/image-20210723104124781.png\" alt=\"image-20210723104124781\" style=\"zoom:66.6%;\" />\n</div>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/07/image-20210723104110747.png\" alt=\"image-20210723104110747\" style=\"zoom:63%;\" /><img src=\"https://pic.islet.space/2021/07/image-20210723104533742.png\" alt=\"image-20210723104533742\" style=\"zoom:55%;\" />\n</div>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210723083704637.png\" alt=\"image-20210723083704637\" style=\"zoom:80%;\" /></p>\n<h3 id=\"counter-compare-submodule\">【#】Counter Compare Submodule</h3>\n<p>CC子模块， 以TB计数值为输入源。这个值被不断地拿来与CMPA/CMPB/CMPC/CMPD进行比较，当TB计数器的值与其中一个寄存器的值相等时CC子模块就会生成一个适当的事件。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210724100317179.png\" alt=\"image-20210724100317179\" /><figcaption aria-hidden=\"true\">image-20210724100317179</figcaption>\n</figure>\n<p>CC子模块的作用：</p>\n<ul>\n<li>通过CMPA/CMPB/CMPC/CMPD寄存器，基于可编程时间戳生成时间\n<ul>\n<li>当 <code>CTR=CMPA</code> 时， TB计数器的值等于计数比较器A的值（TBCTR=CMPA）</li>\n<li>当 <code>CTR=CMPB</code> 时， TB计数器的值等于计数比较器B的值（TBCTR=CMPB）</li>\n<li>当 <code>CTR=CMPC</code> 时， TB计数器的值等于计数比较器C的值（TBCTR=CMPC）</li>\n<li>当 <code>CTR=CMPD</code> 时， TB计数器的值等于计数比较器D的值（TBCTR=CMPD）</li>\n</ul></li>\n<li>如果用CMPA和CMPB对AQ子模块正确地配置，可以控制PWM的占空比</li>\n<li>可以在PWM周期活跃时备份（shadows）新的比较值以防崩坏或错误</li>\n</ul>\n<p>CC子模块的内部信号通路结构示意如下图18-15。可以看出，CC子模块前一级是TB子模块，接收其时间信号。CC子模块不间断地对比 CMPx 和 TBCTR 的值，一旦符合要求，则输出结果给AQ子模块。所有CMPx的输出结果均会导向ET（事件触发器和中断），但是导向AQ子模块的只有 CMPA / CMPB。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210724102101254.png\" alt=\"image-20210724102101254\" /><figcaption aria-hidden=\"true\">image-20210724102101254</figcaption>\n</figure>\n<h3 id=\"action-qualifier-submodule\">【#】Action Qualifier Submodule</h3>\n<p>AQ子模块在 <strong>波形结构</strong> 和 <strong>PWM生成</strong> 上扮演着重要的角色。它决定了哪个事件可以被转换为不同的动作类型（converted into various action types），进而产生 <strong><em>EPWMxA</em></strong> 和 <strong><em>EPWMxB</em></strong> 输出需要的开关波形（producing the required switched waveforms）。</p>\n<p>AQ子模块控制着当特定事件发生时，ePWM外设的两条输出线（EPWMxA / EPWMxB）该如何进行输出。输入至AQ子模块的事件 会由 计数器方向（自增或自减）进一步限定。这允许在计数上升和计数下降阶段对输出进行独立操作。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210724082155433.png\" alt=\"image-20210724082155433\" /><figcaption aria-hidden=\"true\">image-20210724082155433</figcaption>\n</figure>\n<p><strong>AQ子模块的作用</strong>：</p>\n<ul>\n<li>根据以下（特定）事件 <em>限定并生成</em>（qualifying and generating）动作（包括 <strong>设置</strong>、<strong>清除</strong> 和 <strong>标记</strong>）:\n<ul>\n<li>当 <code>CTR = PRD</code> ，TB计数器等于周期（TBCTR = TBPRD）</li>\n<li>当 <code>CTR = ZERO</code> ，TB计数器等于0（TBCTR = 0x00）</li>\n<li>当 <code>CTR = CMPA</code> ，TB计数器等于 计数比较器A （TBCTR = CMPA）</li>\n<li>当 <code>CTR = CMPB</code> ，TB计数器等于 计数比较器B（TBCTR = CMPB）</li>\n</ul></li>\n<li>T1、T2事件：基于比较器（comparator）、跳闸（trip） 或 同步器（syncin）的触发事件</li>\n<li>当这些事件同时发生时管理好它们的优先级</li>\n<li>当TB计数器自增或自减时提供对事件的独立控制</li>\n</ul>\n<p>从下图18-21 或 表 18-3 中可以看出，AQ子模块的输入信号源除了TB时钟意外，剩下的触发事件有7种，分别是 PRD / ZERO / CMPA / CMPB / DIR / T1 / T2。只有前四种需要使用到TB计数器。软件强制动作（software forced action）是个非常有用的异步事件，由 <strong><em>AQSFRC</em></strong> 和 <strong><em>AQCSFRC</em></strong> 寄存器控制。</p>\n<p><strong>注意</strong>：如果在影子模式下 <strong><em>CSFA</em></strong> 未被使用，必须配置 <strong><em>RLDCSF</em></strong> 位以关闭影子模式。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210724083434622.png\" alt=\"image-20210724083434622\" style=\"zoom: 80%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210724083824488.png\" alt=\"image-20210724083824488\" style=\"zoom:80%;\" /></p>\n<p>对输出（EPWMxA / EPWMxB）可能施加（imposed）的动作如下：</p>\n<ul>\n<li><strong>置高</strong>（Set High）：将输出置高。</li>\n<li><strong>置低</strong>（Clear Low）：将输出置低。</li>\n<li><strong>切换</strong>（Toggle）：如果任一输出（EPWMxA / EPWMxB）被同时置高，则将它们置低。如果任一输出被同时置低，则将它们置高。</li>\n<li><strong>无视</strong>（Do Nothing）：让输出保持与当前相同的电平，不做处理。虽然“无视”选项阻止了事件对输出的可能动作，但是这些事件仍然可以去触发中断和ADC的开启。</li>\n</ul>\n<p>输出（EPWMxA / EPWMxB）的动作需要分别单独指定（specified independently）。在特定输出上，所有或任一事件都可以被配置以生成动作。</p>\n<p>比如说，<code>CTR=CMPA</code> 和 <code>CTR=CMPB</code> 都可以被配置到 <strong><em>EPWMxA</em></strong> 上。所有限定动作都可以通过控制寄存器被配置。</p>\n<p>每一个符号代表着一个动作，就像是时间上的标记。某些动作在时间上是固定的（如，0和周期），而CMPA和CMPB动作是非固定的（moveable）且其时间位置可以通过CMPA/B寄存器来编程。</p>\n<p>使用 <strong>无视</strong> 操作可以关闭或无效某个动作，无视动作是复位后的默认值。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210724090622329.png\" alt=\"image-20210724090622329\" /><figcaption aria-hidden=\"true\">image-20210724090622329</figcaption>\n</figure>\n<p>AQ触发事件源选择寄存器（AQTSRCSEL, Action Qualifier Trigger Event Source Selection register）被用于为T1/T2事件选择源。在AQ子模块中，一个trip/数字比较事件的T1/T2的选择和配置 与 Trip-zone子模块事件的配置 是相互独立的。特定的trip事件是不确定能否在TZ子模块里通过配置来触发trip动作的，但是相同事件是能够确定可以被配置于AQ子模块中，以生成T1/T2来控制PWM生成的。</p>\n<p>PWM动作限定器（AQ）是可以在相同时间内接受一个以上事件的，此时，硬件会为事件排好优先级。优先级规则是，事件生成越晚，优先级越高，而且 <strong>软件强制事件</strong>（software forced event）拥有最高优先级。</p>\n<p>增减计数模式下的动作限定事件优先级如下表18-4所示，优先级按数字从小到大依次递减，共分10级。</p>\n<p><mark>优先级会因TB计数器的计数模式改变而改变。</mark> 但是从下表18-5和 18-6中可以看到，自增模式和自减模式下，只有7个优先级，在任一模式下，其相反动作的触发都不会被考虑，如在自减模式下，自增事件不会被考虑，自增模式下，自减事件不会被考虑。</p>\n<p><strong>注意</strong>：CMPA或者CMPB是可以设置得比PRD还大的，此时需要考虑依据所处模式进行考虑，如表18-7所示。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210724092138218.png\" alt=\"image-20210724092138218\" /><figcaption aria-hidden=\"true\">image-20210724092138218</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210724092919402.png\" alt=\"image-20210724092919402\" /><figcaption aria-hidden=\"true\">image-20210724092919402</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210724092932350.png\" alt=\"image-20210724092932350\" /><figcaption aria-hidden=\"true\">image-20210724092932350</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210724094334396.png\" alt=\"image-20210724094334396\" /><figcaption aria-hidden=\"true\">image-20210724094334396</figcaption>\n</figure>\n<p>图18-25 展示了如何使用TBCTR的增减计数模式来生成一个symmetric PWM波形。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210724172530959.png\" alt=\"image-20210724172530959\" style=\"zoom:80%;\" /></p>\n<h3 id=\"dead-band-generator-submodule\">【#】Dead-Band Generator Submodule</h3>\n<p>下方为DB死区时间生成子系统的功能框图，主要是设置两个寄存器值 <code>DBFED</code> 和 <code>DBRED</code> ，需要注意的是，他们都是 14bit 的，传递数值的时候需要进行限定。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211008160842.png\" alt=\"image-20211008160601600\" /><figcaption aria-hidden=\"true\">image-20211008160601600</figcaption>\n</figure>\n<h3 id=\"pwm-chopper-submodule\">PWM Chopper Submodule</h3>\n<p>暂略</p>\n<h3 id=\"trip-zone-submodule\">【#】Trip Zone Submodule</h3>\n<p>TZ子模块，每个ePWM模块都连接了6个 TZ<em>n</em>（TZ1 ~ TZ6） 信号 ， 其中：</p>\n<ul>\n<li>前三个信号来自于GPIO 复用</li>\n<li>TZ4 来自于 带有 EQEP 模块设备的 反转（inverted）的 <strong><em>EQEPxERR</em></strong> 信号</li>\n<li>TZ5 连接至了系统时钟故障（fail）逻辑</li>\n<li>TZ6 来自于 CPU 的 EMUSTOP 输出</li>\n</ul>\n<p>这些信号指示了外部的故障或跳闸情况，并且可以对ePWM的输出进行编程，以便在故障发生时作出相应的反应。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210724104412883.png\" alt=\"image-20210724104412883\" style=\"zoom:80%;\" /></p>\n<p>TZ子模块的特点：</p>\n<ul>\n<li>错误输入TZ1 ~ TZ6 能够被高级地（flexibly）路由至（mapped to）任何ePWM模块</li>\n<li>在出现错误时，输出（EPWMxA / EPWMxB）状态可以被强制指定为其中之一：\n<ul>\n<li>置高</li>\n<li>置低</li>\n<li>高阻抗（High-impedance）</li>\n<li>无动作（no action taken）</li>\n</ul></li>\n<li>为主要的 <strong>短路</strong> 或 <strong>过流</strong>（short circuits or over-current）提供 <strong>一次性错误</strong>（one-shot trip, OSHT）</li>\n<li>为 <strong>限流操作</strong>（current limiting operation）提供 <strong>循环错误</strong>（cycle-by-cycle tripping）</li>\n<li>基于 片上模拟比较模块输出 和/或 TZ1 至 TZ3 提供 <strong>数字比较错误</strong>（digital compare tripping）</li>\n<li>每一个TZ输入和DC子模块 DCAEVT1/2 或 DCBEVT1/2 强制事件能够被定位于 一次性错误 或 循环错误上。</li>\n<li>中断生成可用于任何一个TZ输入</li>\n<li>软件强制错误也可用</li>\n<li>如果不需要使用，TZ子模块也能够被完全屏蔽。</li>\n</ul>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210824152702184.png\" alt=\"image-20210824152702184\" /><figcaption aria-hidden=\"true\">image-20210824152702184</figcaption>\n</figure>\n<h3 id=\"event-trigger-submodule\">Event Trigger Submodule</h3>\n<p>如果需要使用ePWM的事件触发，则需要配置ET模块。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210809171747297.png\" alt=\"image-20210809171747297\" /><figcaption aria-hidden=\"true\">image-20210809171747297</figcaption>\n</figure>\n<p>例如，如果需要使用ePWM作为ADC_SOC的触发源，则需要使用以下配置：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">EPwm6Regs.ETSEL.bit.INTEN = ON;                <span class=\"comment\">// 关闭EPWM外设的中断</span></span><br><span class=\"line\">EPwm6Regs.ETSEL.bit.SOCAEN = ON;            <span class=\"comment\">// 打开ePWM6dSOCA脉冲</span></span><br><span class=\"line\">EPwm6Regs.ETSEL.bit.SOCASEL = <span class=\"number\">0x02</span>;          <span class=\"comment\">// TB计数器等予周期时触发事件</span></span><br><span class=\"line\">EPwm6Regs.ETPS.bit.SOCAPRD = <span class=\"number\">0x01</span>;          <span class=\"comment\">// 在第一次事件时生成脉冲</span></span><br></pre></td></tr></table></figure>\n<p>如果不需要，则使用以下配置：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">EPwm6Regs.ETSEL.bit.INTEN = OFF;                <span class=\"comment\">// 关闭EPWM外设的中断</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"digital-compare-submodule\">Digital Compare Submodule</h3>\n<p>暂略</p>\n<h2 id=\"ecap\">eCAP</h2>\n<p>本系列芯片使用的是第1类eCAP，特性如下所示：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210818150848657.png\" alt=\"image-20210818150848657\" /><figcaption aria-hidden=\"true\">image-20210818150848657</figcaption>\n</figure>\n<p>eCAP模块有如下特性：</p>\n<ul>\n<li>旋转机械的速度测量 （例如，通过霍尔传感器检测齿形链轮）</li>\n<li>多个位置传感器脉冲的时间差测量</li>\n<li>脉冲串（Pulse Train）信号的周期和占空比测量</li>\n<li>将来自任务占空比解码的电流/电压传感器的电流/电压振幅进行解码</li>\n</ul>\n<p>后续会描述到的eCAP特性如：</p>\n<ul>\n<li>4个事件时间戳寄存器（每个32bit）</li>\n<li>最多能够为四个顺序时间戳捕获事件的 <strong>边沿极性选择</strong>（edge polarity selection）</li>\n<li>对四个时间的任何一个进行中断（interrupt on either of the four events）</li>\n<li>单次捕获（Single-shot capture）最多可捕获4个事件的时间戳</li>\n<li>在一个四层的环形缓冲器中连续捕获时间戳的模式</li>\n<li>绝对时间戳捕获</li>\n<li>差分（德尔塔）模式的时间戳捕获</li>\n<li>当不启用捕获模式时，eCAP模块可以被配置为一个单通道的PWM输出</li>\n</ul>\n<p>第一类eCAP 较 第0类eCAP增加了以下特性：</p>\n<ul>\n<li>事件过滤器复位位（reset bit）</li>\n<li>以计数器状态位为模</li>\n<li>DMA触发源</li>\n<li>输入多路器</li>\n<li>EALLOW保护</li>\n</ul>\n<h3 id=\"配置引脚\">配置引脚</h3>\n<p>为了将设备输入引脚连接至模块，输入X-BAR必须要用上。设备上的任何GPIO都能够配置为输入。通过设置 <code>GPxQSELn</code> 寄存器位可以将GPIO输入验证（input qualification）设置为同步模式或异步模式。</p>\n<p>使用同步输入能够有效提高抗噪性，但是让eCAP丢失±2个周期的精度。在 <code>GPyPUD</code> 寄存器中能够配置内部拉高。一旦GPIO模式开启，<code>GPyINV</code> 寄存器就能够倒置信号了（invert the signals）。</p>\n<p>必须配置128:1的输入多路器也是一类eCAP模块的新特性。从下表19-1可以看出，该多路器能够配置不同的输入细节。</p>\n<p>下图为《TRM》P966图9-1，可以看到eCAP的输入可以被配置为 <strong><em>INPUT[16:1]</em></strong> 或 <strong><em>Other Sources</em></strong> 。而 <strong><em>INPUT[16:1]</em></strong> 则是INPUTXBAR的16个可配置通道，</p>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/08/image-20210824090004384.png\" alt=\"image-20210824090004384\" style=\"zoom:100%;\" /> <img src=\"https://pic.islet.space/2021/08/image-20210824090259786.png\" alt=\"image-20210824090259786\" style=\"zoom: 50%;\" />\n</div>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210818171451027.png\" alt=\"image-20210818171451027\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210818171518769.png\" alt=\"image-20210818171518769\" style=\"zoom:67%;\" /></p>\n<p>输出X-BAR能够用于连接输出信号至 OUTPUTXBARx 输出定位（output location）。</p>\n<p>从下表4-8可以看出，INPUT XBAR所有16个输入都可以被配置至其目的地为eCAP。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210712095346292.png\" alt=\"image-20210712095346292\" /><figcaption aria-hidden=\"true\">image-20210712095346292</figcaption>\n</figure>\n<p>在配置引脚时有以下步骤：</p>\n<ol type=\"1\">\n<li>将输入XBAR与对应的GPIO连接，连接时通过 <code>InputXbarRegs.INPUT10SELECT</code> 进行配置。</li>\n<li>将eCAPx与对应的XBAR输入序号连接，连接时通过 <code>ECCTL0.INPUTSEL</code> 寄存器为进行配置。</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210824093524933.png\" alt=\"image-20210824093524933\" /><figcaption aria-hidden=\"true\">image-20210824093524933</figcaption>\n</figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">InputXbarRegs.INPUT10SELECT = <span class=\"number\">0xA</span>; <span class=\"comment\">// 将GPIO10(0xA)与输入XBAR 10进行连接</span></span><br><span class=\"line\">ECap1Regs.ECCTL0.bit.INPUTSEL = <span class=\"number\">0xA</span>;    <span class=\"comment\">//为eCAP1选择输入源为XBAR的INPUT10，参见《TRM》P2048</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"capture模式\">Capture模式</h3>\n<p>下图19-3展示了实现捕获功能的不同元件（various components）</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210819200405541.png\" alt=\"image-20210819200405541\" /><figcaption aria-hidden=\"true\">image-20210819200405541</figcaption>\n</figure>\n<h4 id=\"事件分频器\">事件分频器</h4>\n<p>输入捕获信号（脉冲串）能够被N预分频（N的取值范围为[2,62]，所有可取值均为2的倍数），也可以绕过该预分频，在输入信号频率非常高时有用。</p>\n<p>下图19-4 展示了事件预分频器的功能框图。</p>\n<p>下图19-5 展示了分频功能的操作。</p>\n<p>通过设置 <code>ECCTL2.CTRFILTRSET</code> 寄存器位即可让 事件分频器（Event Prescalar）复位。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210819202019366.png\" alt=\"image-20210819202019366\" /><figcaption aria-hidden=\"true\">image-20210819202019366</figcaption>\n</figure>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819202037557.png\" alt=\"image-20210819202037557\" style=\"zoom:80%;\" /></p>\n<h4 id=\"边沿极性选择和限定器\">边沿极性选择和限定器</h4>\n<p>功能和特性如下：</p>\n<ul>\n<li>四个独立边沿极性（上升沿/下降沿）选择复用（selection muxes are used），每一个边沿极性都可以对应一个捕捉事件（one for each capture event）。</li>\n<li>每个边沿（最多4个）都是由 Modulo 4 序列器进行事件鉴定。（Each edge (up to 4) is event qualified by the Modulo4 sequencer.）</li>\n<li>边沿事件通过Mod4计数器导向其各自对应的 <code>CAPx</code> 寄存器。<code>CAPx</code> 寄存器在下降沿时载入（loaded on the falling edge）。</li>\n</ul>\n<h4 id=\"连续一次性控制\">连续/一次性控制</h4>\n<p>在连续/一次性控制模式（Continuous / One-shot mode）下的eCAP操作：</p>\n<ul>\n<li>Mod4（2位）计数器通过边沿限定事件（edge qualified events）（CEVT1 ~ CEVT4）进行增加</li>\n<li>Mod4计数器持续计数（0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 0）且往复循环永不停歇，除非被停下（wraps around unless stopped）</li>\n<li>在一次操作模式过程中，会使用到一个2位停止寄存器（STOP_WRAP）来与Mod4计数输出进行比较，当数值相等时，停止Mod4计数器并阻止更多数据载入 <code>CAP1</code> ~ <code>CAP4</code> 寄存器。在本模式下，如果 TSCCTR 计数器通过配置 <code>ECCTL1.CTRRSTx</code> 位来 用于在捕获事件（<strong><em>CEVTx</em></strong>）上的复位，它将会在 <code>STOP_WRAP</code> 值满（reached）且 <strong>重新装载</strong>（re-arm，REARM）尚未发生时 在捕获事件是上对 TSCCTR 计数器一直复位（keep resetting the TSCCTR counter on capture event）。</li>\n</ul>\n<p>连续/一次性块 通过软件控制的能够触发 <strong>单次操作</strong>（mono-shot type of action）的 <strong>停值比较器</strong>（stop-value comparator）和 <strong>重新装载</strong>（re-armed） 控制着Mod4计数器的启动、停止和复位。</p>\n<p>一旦装载，eCAP模块会 在冻结Mod4计数器和 <code>CAP1</code> ~ <code>CAP4</code> 寄存器（时间戳）之前 等待 1 ~ 4 个（由 <strong>停值</strong> 决定）捕获事件。</p>\n<p>重新装载（re-arming）会将eCAP模块作为另一个捕获顺序的准备，同时清除（至0）Mod4计数器 并 允许再次装载（permits loading again） <code>CAP1</code> ~ <code>CAP4</code> 寄存器，前提是 <code>CAPLDEN</code> 位已经设置了。</p>\n<p>在连续模式下，Mod4计数器连续运行（0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 0），一次性操作将会被忽略且捕获到的值会被以循环缓存顺序（circular buffer sequence）持续写入至<code>CAP1</code> ~ <code>CAP4</code> 寄存器。</p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819205730800.png\" alt=\"image-20210819205730800\" style=\"zoom:80%;\" /></p>\n<h4 id=\"位计数器和相位控制\">32位计数器和相位控制</h4>\n<p>本32位计数器为时间捕获提供TB，并通过系统时钟锁定（is locked via the system clock）。</p>\n<p>相位寄存器的作用是通过硬件和软件强制同步（forced sync），完成与其他计数器的同步。在APWM模式下，当模块间需要相位偏移时比较有用。</p>\n<p>对四个任一事件的装载而言，都有一个选项可以重置32bit计数器，对时差捕获有用。先是32位计数器值被捕获，接着被LD1 ~ LD4的任一信号复位为 <code>0</code>。</p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210820093838065.png\" alt=\"image-20210820093838065\" style=\"zoom:80%;\" /></p>\n<h4 id=\"cap1-cap4寄存器\">CAP1-CAP4寄存器</h4>\n<p><code>CAP1</code>~<code>CAP4</code> 为32位的寄存器，由32位计数定时器总线和 <code>CTR[0-31]</code> 驱动（fed by the 32-bit counter timer bus, CTR[0-31]），并在对应的LD输入被触发（strobed）时被加载以捕获其时间戳。</p>\n<p><code>CAPLDEN</code> 控制位能够抑制捕获寄存器的加载。在一次性捕获操作器件，当停止情况发生时（停值 = Mod4），该位会被自动清空（禁止载入）。</p>\n<p>在APWM模式下，<code>CAP1</code> <code>CAP2</code> 寄存器对应地称为（活跃的）<strong>周期</strong> 和 <strong>比较</strong> 寄存器（the active period and compare register）,<code>CAP3</code> <code>CAP4</code> 成为了对应活跃寄存器的影子寄存器。</p>\n<h4 id=\"ecap同步\">eCAP同步</h4>\n<p>eCAP模块能够通过选择相同的同步源（a common source） <code>SYNCIN</code> 来与其他模块同步。eCAP的同步源可以是软件同步源或者外部同步源，外部同步源信号能够来自 ePWM、eCAP或者X-BAR。</p>\n<p>图19-7所示，eCAP模块的 <code>SWSYNC</code> 与 <code>SYNC</code> 信号进行逻辑 或（OR）。</p>\n<p>图19-8所示，<code>SYNC</code> 信号是由 <code>SYNCSELECT[ECAPxSYNCIN]</code> 的选择来定义的。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210822115215346.png\" alt=\"image-20210822115215346\" /><figcaption aria-hidden=\"true\">image-20210822115215346</figcaption>\n</figure>\n<h5 id=\"使用软件同步-swsync\">使用软件同步 SWSYNC</h5>\n<p>按一下步骤进行操作可以实现对 ECAP1 和 ECAP3 的软件同步：</p>\n<ol type=\"1\">\n<li>配置 <code>ECAP[1..3].ECCTL2.SYNCO_SEL = 0x0</code> ，以使能 同步输入（sync-in）事件成为同步输出（sync-out）信号的通道。</li>\n<li>配置 <code>ECAP[2..3].ECCTL2.SWSYNC = 0x0</code>，以关断 ECAP2 和 ECAP3 的软件同步。</li>\n<li>从 ePWM1配置默认的同步信号来源，如果 <code>TBCTL[SYNCOSEL]</code> 信号没有被正确配置，则可能对时间戳寄存器 <code>TSCTR</code> 造成意料之外的结果。在 <code>InputXbarRegs</code> 中选择一个没有使用过的GPIO并配置为输出模式，并往GPIO <code>DAT</code> 寄存器中写入 <code>0</code> 。默认情况下会配置为 GPIO0，但该针脚上的任何活动都会对 <code>SWSYNC</code> 造成影响。</li>\n<li>配置 <code>SYNCSEL[ECAP1SYNCIN] = 0x5</code> ，将 <code>ECAPx.EXTSYNCIN</code> 外部同步输入关断。</li>\n<li>配置 <code>ECAP1.ECCTL2.SWSYNC=0x1</code> ，强制开启 时间戳计数器 （<code>TSCTR</code> counter）的软件同步。</li>\n</ol>\n<p>为了将 <code>SWSYNC</code> 应用至其他 eCAP模块，需要确保前面的eCAP链条没有生成可能干扰软件同步的 <code>SYNCOUT</code> 信号。</p>\n<h4 id=\"中断控制\">中断控制</h4>\n<p>eCAP中断控制的操作和特征如下：</p>\n<ul>\n<li>捕获事件（CEVT1 ~ CEVT4, CTROVF）或者APWM事件（<code>CTR = PRD</code>, <code>CTR=CMP</code>）都能够生成中断。</li>\n<li>计数器溢出事件（<code>FFFFFFFF -&gt; 00000000</code>）也提供了中断源（CTROVF）。</li>\n<li>这些捕获事件由对应的极性选择和Mod4门控的边缘和序列器进行限定（在时间上排序）。The capture events are edge and sequencer-qualified (ordered in time) by the polarity select and Mod4 gating, respectively.</li>\n<li>这些事件任一能够被选择为中断源（从eCAPx 模块）以导向PIE和CLA。</li>\n<li>七个中断事件（CEVT1 / CEVT2 / CEVT3 / CEVT4 / CNTOVF / CTR=PRD / CTR=CMP）都能够被生成。中断使能寄存器 <code>ECEINT</code> 被用于使能/禁止独立中断事件源。中断标志寄存器 <code>ECFLG</code> 鉴定是否有任何中断事件被锁定 并 维持着全局中断标志位 <code>INT</code> 。只有在任何中断事件被使能，其标志位为 <code>1</code> 且 <code>INT</code> 标志位为 <code>0</code> 时，中断脉冲会被生成并送至 PIE。中断服务程序必须清楚全局中断标志位 并 在任何其他中断脉冲生成前通过中断清除寄存器 <code>ECCLR</code> 服务事件。往 <code>ECCTL2[CLRFILTRESET]</code> 位 写 <code>1</code> 来对事件滤波器进行复位时，所有中断标志都会被清除。可以通过中断强制寄存器 <code>ECFRC</code> 来强制中断事件，对测试目的非常有效。</li>\n</ul>\n<p><strong>注意</strong>：CEVT1 / CEVT2 / CEVT3 / CEVT4 标志仅在捕获模式下可用（<code>ECCTL2[CAP/APWM==0]</code>）。CTR=PRD / CTR=CMP 标志仅在APWM模式下可用<code>ECCTL2[CAP/APWM==1]</code>。CNTOVF在两个模式下都可用。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210822121542134.png\" alt=\"image-20210822121542134\" /><figcaption aria-hidden=\"true\">image-20210822121542134</figcaption>\n</figure>\n<h4 id=\"dma中断\">DMA中断</h4>\n<p>在0类eCAP模块下，CPU被要求使用DAM来启动数据传输。</p>\n<p>在1类eCAP模块下，分立式（separate）DMA触发器（<code>ECAP_DMA_INT</code>）通过使用DMA，控制着从eCAP寄存器 到 片上内存（on-chip memory）的捕获数据的不间断传输。</p>\n<p>通过对 <code>ECCTL2[DMAEVTSEL]</code> 进行操控，可实现四个任一可用中断事件（CEVT1 / CEVT2 / CEVT3 / CEVT4 ）都可以被当做 <code>ECAP_DMA_INT</code> 的触发源。</p>\n<h4 id=\"影子载入和锁定控制lockout-control\">影子载入和锁定控制（lockout control）</h4>\n<p>在捕获模式下，该逻辑禁止（锁定）任何从<code>APRD</code> 和 <code>ACMP</code> 到 <code>CAP1</code> 和 <code>CAP2</code> 的影子载入。</p>\n<p>在APWM模式下，影子载入被激活，且有以下两个选择可用：</p>\n<ul>\n<li>立即——在写入新值时，<code>APRD</code> 或 <code>ACMP</code> 将会立即传输至 <code>CAP1</code> 或 <code>CAP2</code>。</li>\n<li>在周期相等时（on period equal），<code>CTR[31:0] = PRD[31:0]</code></li>\n</ul>\n<h3 id=\"apwm操作模式\">APWM操作模式</h3>\n<p><strong><em>APWM</em></strong>，即 Asymmetrical Pulse Width Modulation，非对称脉冲宽度调制。</p>\n<p>当eCAP模块没有被用来输入和捕捉信号时，可以改成单通道PWM生成器（32位分辨率）。计数器将工作在 <strong>增模式</strong> 下，为非对称脉冲宽度调制（APWM）提供TB（Time-base）。其中 <code>CAP1</code> 和 <code>CAP2</code> 寄存器 将被当做对应PWM中存放 <strong>周期</strong>（period） 和 <strong>比较</strong>（compare） 的寄存器，对应的 <code>CAP3</code> 和 <code>CAP4</code> 寄存器 将被当做 周期和比较的影子寄存器。</p>\n<p>下图19-1捕获和辅助脉冲宽度调制器模式操作的高级视图</p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819195912993.png\" alt=\"image-20210819195912993\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819200302044.png\" alt=\"image-20210819200302044\" style=\"zoom:80%;\" /></p>\n<h3 id=\"ecap模块应用\">eCAP模块应用</h3>\n<p>eCAP模块的应用通过边沿可以分为两类：<strong>上升沿</strong>（rising edge） 和 <strong>上升下降沿</strong>（rising and falling edge）。通过操作方式也可以分为两类：<strong>时间戳</strong>（time stamp） 和 <strong>时间差</strong>（time difference）。</p>\n<p>边沿和操作方式可以互相组合成共4中应用：<strong>时间戳上升沿操作</strong>、<strong>时间戳上升下降沿操作</strong>、<strong>时间差上升沿操作</strong> 和 <strong>时间差上升下降沿操作</strong>。</p>\n<h4 id=\"时间戳上升沿操作\">时间戳上升沿操作</h4>\n<p>下图19-12中，为连续捕获操作（Mod4计数器周期翻转（wraps around））的例子</p>\n<p>图表中， TSCTR 计数器在没有复位的情况下持续上升计数，捕获事件仅被限定在上升沿（注意观察图中所有CAPx旁边都有一个上升沿的标志，即所有CAPx都被设置为在MOD4的上升沿时才能出发CAPx PIN的输出）。从图中也可以看出周期和频率信息。</p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210822144050400.png\" alt=\"image-20210822144050400\" style=\"zoom:67%;\" /></p>\n<p>在一个事件中，TSCTR内容（时间戳）被首先捕获，然后Mod4计数器进入下一阶段。当 TSCTR到达最大值 <code>FFFFFFFF</code> 时，翻转回 <code>00000000</code>，此时 计数器溢出标志 <code>CTROVF</code> 为 <code>1</code> ，中断（使能时）会生成。</p>\n<p>被捕获的时间戳在图中所示的时间点上是有效的（在第4个事件之后），因此事件CEVT4可以方便地用来触发一个中断，CPU可以从 CAPx 寄存器中读取数据。</p>\n<h4 id=\"时间戳上升下降沿操作\">时间戳上升下降沿操作</h4>\n<p>在19-13图中，eCAP操作模式几乎与 <strong>时间戳上升沿操作</strong> 一致，除了捕获事件限定在了上升下降沿。给出相同的周期和任务占空比信息：</p>\n<ul>\n<li><p>周期1 = t3 - t1，周期2 = t5 - t3 ......</p></li>\n<li><p>任务占空比（高电平占比）1 = (t2-t1)/周期1 * 100% ，......</p></li>\n<li><p>任务占空比（低电平占比）1 = (t3-t2)/周期1 * 100% ，......</p></li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210822144108477.png\" alt=\"image-20210822144108477\" style=\"zoom:67%;\" /></p>\n<h4 id=\"时间差上升沿操作\">时间差上升沿操作</h4>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210822144128846.png\" alt=\"image-20210822144128846\" style=\"zoom:67%;\" /></p>\n<h4 id=\"时间差上升下降沿操作\">时间差上升下降沿操作</h4>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210822144142670.png\" alt=\"image-20210822144142670\" style=\"zoom:67%;\" /></p>\n<h3 id=\"apwm模式应用\">APWM模式应用</h3>\n<p>通过APWMx 输出引脚生成简易单通道PWM波形。</p>\n<p>The PWM polarity is active high, which means that the compare value (CAP2 reg is now a compare register) represents the on-time (high level) of the period. Alternatively, if the APWMPOL bit is configured for active low, then the compare value represents the off time.</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210822143359948.png\" alt=\"image-20210822143359948\" /><figcaption aria-hidden=\"true\">image-20210822143359948</figcaption>\n</figure>\n<h3 id=\"寄存器-2\">寄存器</h3>\n<p>《TRM》P2041</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210819194706453.png\" alt=\"image-20210819194706453\" /><figcaption aria-hidden=\"true\">image-20210819194706453</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210819195110220.png\" alt=\"image-20210819195110220\" /><figcaption aria-hidden=\"true\">image-20210819195110220</figcaption>\n</figure>\n<h3 id=\"ecap配置流程\">eCAP配置流程</h3>\n<p>以下流程总结自C2000WareV3.4的driverlib样例代码：</p>\n<ol type=\"1\">\n<li>禁用/复位所有捕获标志和中断</li>\n<li>禁用CAP1~CAP4寄存器载入</li>\n<li>配置eCAP\n<ul>\n<li>使能捕获模式</li>\n<li>一次捕获模式，在事件4停止捕获</li>\n<li>设置事件极性为上升沿/下降沿/上升沿/下降沿</li>\n<li>设置为不同时间模式下的捕获（time difference mode）</li>\n<li>从XBAR7选择输入</li>\n<li>使能eCAP模块</li>\n<li>使能中断</li>\n</ul></li>\n</ol>\n<h3 id=\"ecap中断程序流程\">eCAP中断程序流程</h3>\n<ol type=\"1\">\n<li>获取捕获计数（捕获速度应为ePWM计数的2倍）</li>\n<li>将获取到的捕获计数与周期值进行比较</li>\n<li>追踪ePWM的方向，并相应地调整周期，以产生一个可变频率的PWM。</li>\n<li>为正确的捕获进行计数</li>\n<li>为更多中断清除中断标志</li>\n<li>使能eCAP</li>\n<li>为更多中断确认组中断</li>\n</ol>\n<h2 id=\"hrcap\">HRCAP</h2>\n<h3 id=\"hrcap时钟\">HRCAP时钟</h3>\n<p>与之前的0类HRCAP模块不同，1类eCAP具有HRCAP的功能但不要求二次PLL。然而本HRCAP模块仍然要求 SYSCLK 和 HRCLK 异步时钟源（Asynchronous clock source）。HRCLK对温度和电压的变化较为敏感。因此，当使用时间转换测量（time-converted measurements）时，要求定期进行持续性的校准（periodic continuous calibrations）。</p>\n<h3 id=\"hrcap初始化顺序\">HRCAP初始化顺序</h3>\n<ol type=\"1\">\n<li>按需配置eCAP模块，包括中断</li>\n<li>使用 <code>HRCAP_enableCalibrationInterrupt()</code> 使能中断</li>\n<li>使用 <code>HRCAP_setCalibrationMode()</code> 使能校准</li>\n<li>使用 <code>HRCAP_setCalibrationPeriod()</code> 配置周期性校准</li>\n<li>使用 <code>HRCAP_enableHighResolution()</code> 使能HR模式</li>\n<li>使用 <code>HRCAP_enableHighResolutioniClock()</code> 使能 HRCLK</li>\n<li>延迟 1us</li>\n<li>使用 <code>HRCAP_startCalibration()</code> 启动校准</li>\n</ol>\n<p>步骤 2、3、4 和 8 仅应用在时间转换的测量。当使用HRCAP来进行相关事件测量时仅需 1、5、6 和 7 即可。</p>\n<h3 id=\"hrcap中断\">HRCAP中断</h3>\n<p>除了HRCALINT之外，HRCAP的增强功能还利用了现有的eCAP中断，该中断是由硬件校准块专门使用的。HRCALINT能够被以下情况触发：</p>\n<ol type=\"1\">\n<li><code>SYSCLKCTR = HRCALIBPERIOD</code></li>\n<li><code>SYSCLKCTR</code> / <code>HRCLKCTR</code> 处于溢出态（experience an overflow condition）</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210823142406296.png\" alt=\"image-20210823142406296\" /><figcaption aria-hidden=\"true\">image-20210823142406296</figcaption>\n</figure>\n<h1 id=\"通信外设\">通信外设</h1>\n<h2 id=\"spi\">SPI</h2>\n<p>本系列芯片的SPI具有如下特性：</p>\n<ul>\n<li>支持主模式或从模式</li>\n<li>支持125种可编程速率，最高波特率（baud rate）由IO缓存的最大速度决定。</li>\n<li>支持1~16比特数据传输</li>\n<li>支持4种时钟模式</li>\n<li>支持全双工通信（同时接受和发送），传输模式可以在软件中关闭</li>\n<li>传输或接收操作通过 <strong>中断驱动</strong>（interrupt-driven）算法 或 <strong>轮询</strong>（polled）算法来完成</li>\n<li>16级接收和传输FIFO</li>\n<li>支持直接内存访问（DMA）</li>\n<li>支持高速模式</li>\n<li>延迟传输控制</li>\n<li>支持3线模式</li>\n<li>在有两个SPI模块的设备上实现数字音频接口接收模式的SPISTE反转（SPISTE inversion for digital audio interface receive mode on devices with two SPI modules）</li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819084943717.png\" alt=\"image-20210819084943717\" style=\"zoom:67%;\" /></p>\n<p>下表为SPI模块的信号总结，其中有关中断信号和DMA触发的信号可能需要注意。</p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819090520768.png\" alt=\"image-20210819090520768\" style=\"zoom:67%;\" /></p>\n<h3 id=\"系统集成部分\">系统集成部分</h3>\n<h4 id=\"特别注意事项\">特别注意事项</h4>\n<p>在SPI处于从模式时，<strong>使能</strong>/<strong>片选</strong> 信号 <strong><em>SPISTE</em></strong> 为提供了阻挡假时钟信号和数据脉冲的作用。拉高使能信号时将不会允许从设备接收数据，同时也阻止了从设备从主设备那儿断开同步。这也是TI不推荐将使能信号一直绑定到拉高（active state）状态的原因。</p>\n<p>如果从设备确实已经跟主设备断开同步，切换（toggling）寄存器 <code>SPISWRESET</code> 会像复位模块里的不同状态标志（various status flags）一样，将内部的 <strong>位计数器</strong>（internal bit counter）进行复位。将该位计数器复位后，SPI会将下一个时钟信号当做一个新传输的开始。</p>\n<h4 id=\"引脚配置\">引脚配置</h4>\n<p>GPIO多路寄存器必须将外设和对应的针脚连接起来，为了避免连接时的电压尖峰出现，必须首先配置 <code>GPyGMUX</code> 位（当保持对应位为0时），向其写入对应的值。</p>\n<p>某些IO口的功能由GPIO寄存器独立定义。对于输入信号，通过将对应的 <code>GPxQSELn</code> 寄存器位设置为 <code>11b</code> 可以将GPIO输入验证（input qualification）设置为异步模式。内部拉高可以在 <code>GPyPUD</code> 寄存器中进行设置。</p>\n<h3 id=\"主从模式\">主/从模式</h3>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210819113506076.png\" alt=\"image-20210819113506076\" /><figcaption aria-hidden=\"true\">image-20210819113506076</figcaption>\n</figure>\n<h4 id=\"主模式\">主模式</h4>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210819113451472.png\" alt=\"image-20210819113451472\" /><figcaption aria-hidden=\"true\">image-20210819113451472</figcaption>\n</figure>\n<h4 id=\"从模式\">从模式</h4>\n<h3 id=\"数据格式\">数据格式</h3>\n<p>The four-bit SPICHAR register field specifies the number of bits in the data character (1 to 16). This information directs the state control logic to count the number of bits received or transmitted to determine when a complete character has been processed.</p>\n<p>The following statements apply to characters with fewer than 16 bits:</p>\n<ul>\n<li><p>Data must be left-justified when written to SPIDAT and SPITXBUF.</p></li>\n<li><p>Data read back from SPIRXBUF is right-justified.</p></li>\n<li><p>SPIRXBUF contains the most recently received character, right-justified, plus any bits that remain from</p></li>\n</ul>\n<p>previous transmission(s) that have been shifted to the left (shown in Example 22-1).</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210819114723402.png\" alt=\"image-20210819114723402\" /><figcaption aria-hidden=\"true\">image-20210819114723402</figcaption>\n</figure>\n<h3 id=\"波特率\">波特率</h3>\n<p>SPI支持125种不同的波特率和4种不同的时钟模式，取决于SPI的工作模式（主/从），SPICLK引脚是向外提供工作时钟还是接受外部时钟。</p>\n<ul>\n<li>从模式下，从SPICLK引脚接收外部时钟作为SPI时钟。</li>\n<li>主模式下，SPI生成外部从设备所需时钟，由SPICLK引脚引出。</li>\n</ul>\n<p>以上所有模式下，SPICLK 的速率不能够大于 <code>LSPCLK</code> 的频率除以4。即</p>\n<div style=\"text-align: center; font-size: 1.35rem; font-weight: 900; font-style: italic;\">\nF <span style=\"font-size: 0.7rem;\">(SPICLK)</span> &lt; F <span style=\"font-size: 0.7rem;\">(LSPCLK)</span> / 4\n</div>\n<p><strong>注意</strong>：所配置的波特率不应超过GPIO的最大切换频率（the maximum rated GPIO toggle frequency）。</p>\n<h4 id=\"波特率公式\">波特率公式</h4>\n<p>在 SPIBRR 的可设置范围为<code>3</code> ~ <code>127</code> 时，其计算公式如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210819151042265.png\" alt=\"image-20210819151042265\" /><figcaption aria-hidden=\"true\">image-20210819151042265</figcaption>\n</figure>\n<p>在 SPIBRR 的可设置范围为 <code>0</code> 、<code>1</code> 或 <code>2</code> 时，其计算公式如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210819151424040.png\" alt=\"image-20210819151424040\" /><figcaption aria-hidden=\"true\">image-20210819151424040</figcaption>\n</figure>\n<p>其中：</p>\n<ul>\n<li>LSPCLK 为低速外设时钟频率</li>\n<li>SPIBRR 为 SPI主机SPIBRR的内容</li>\n</ul>\n<p>为了确定SPIBRR应该载入何值，必须确定设备系统时钟（LSPCLK）频率 和 目标SPI时钟。</p>\n<h4 id=\"波特率计算案例\">波特率计算案例</h4>\n<p>在标准SPI模式下（<strong>HS_MODE</strong> = 0）SPI模块的波特率计算，首先需要知道LSPCLK的控制寄存器，查找下图可知，对应LSPCLK由 LOSPCP 寄存器控制，该寄存器的信息在《TRM》P173 及 P185 可查询，如下表 3-40 和 表 3-51。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210710155206953.png\" alt=\"image-20210710155206953\" style=\"zoom: 70%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819152113556.png\" alt=\"image-20210819152113556\" style=\"zoom: 67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819152141919.png\" alt=\"image-20210819152141919\" style=\"zoom:67%;\" /></p>\n<p><strong>如</strong>：</p>\n<p>在 <code>SYSCLK = 100MHz</code> 时，设置 LOSPCP 寄存器下的 <code>LSPCLKDIV</code> 设置为 <code>001b</code> 或 <code>0x01</code> ，则对应的 LSPCLK = SYSCLK / LSPCLKDIV = 100MHz / 2 = 50MHz，此时，据前面SPI计算公式可知，SPI的波特率最高可为 <strong>LSPCLK</strong> / (<strong>SPIBRR</strong> +1) = 50000000 / (3+1) = 12500000Hz = <code>12.5MHz</code>。</p>\n<p>在 <code>LSPCLKDIV</code> 为 <code>000b</code> 或 <code>0x00</code> 时，SPI的最高波特率为 <code>25MHz</code>。</p>\n<h3 id=\"时钟时序\">时钟/时序</h3>\n<p>时钟极性选择位 <code>CLKPROLARITY</code> 和 时钟相位选择位 <code>CLK_PHASE</code> 控制 SPICLK 引脚上的 4个不同时钟模式，其中极性选择控制时钟的上升沿或者下降沿，相位延迟控制是否延迟半个时钟周期。</p>\n<ul>\n<li><strong>下降沿无相位延迟</strong>：在时钟 <strong>下降沿</strong> 传输数据，在时钟 <strong>上升沿</strong> 接收数据。</li>\n<li><strong>下降沿有相位延迟</strong>：在时钟 <strong>下降沿</strong> 半个周期上传输数据，在时钟 <strong>下降沿</strong> 接收数据。</li>\n<li><strong>上升沿无相位延迟</strong>：在时钟 <strong>上升沿</strong> 传输数据，在时钟 <strong>下降沿</strong> 接收数据。</li>\n<li><strong>上升沿有相位延迟</strong>：在时钟 <strong>上升沿</strong> 半个周期上传输数据，在时钟 <strong>上升沿</strong> 接收数据。</li>\n</ul>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819084200284.png\" alt=\"image-20210819084200284\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819115248790.png\" alt=\"image-20210819115248790\" style=\"zoom: 80%;\" /></p>\n<p>只有当 <code>SPIBRR +1</code> 的值为偶数时， <code>SPICLK</code> 才能保持器对称性。当 <code>SPIBRR +1</code> 为奇数 且 <code>SPIBRR</code> 大于 <code>3</code>，<code>SPICLK</code> 则为非对称性。</p>\n<p>当 <code>CLKPOLARITY</code> 为 <code>0</code> 时，<code>SPICLK</code> 的 <strong>低电平</strong>（low pulse） 会比 <strong>高电平</strong>（high pulse）长一个 <code>LSPCLK</code> 的宽度。</p>\n<p>当 <code>CLKPOLARITY</code> 为 <code>1</code> 时，<code>SPICLK</code> 的 <strong>高电平</strong>（high pulse） 会比 <strong>低电平</strong>（low pulse）长一个 <code>LSPCLK</code> 的宽度。</p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819133534654.png\" alt=\"image-20210819133534654\" style=\"zoom: 80%;\" /></p>\n<h3 id=\"中断-1\">中断</h3>\n<p>SPI模块包含两条中断线： <code>SPIINT</code> / <code>SPIRXINT</code> 或 <code>SPITXINT</code>。</p>\n<p>当工作在非FIFO模式时，所有可用中断都被路由到一起，并生成中断信号 <code>SPIINT</code> 。</p>\n<p>当工作在FIFO模式下时，<code>SPIRXINT</code> 和 <code>SPITXINT</code> 都能够被生成。</p>\n<h4 id=\"spiint-spirxint\">SPIINT / SPIRXINT</h4>\n<p>SPIINT会在非FIFO模式下出现。当FIFO增强开启时，会产生 SPIRXINT 中断，这两种中断会在PIE中共享同一个中断向量。</p>\n<p>在非FIFO模式下，以下两种情况能够触发同一个中断，使用的同一个中断向量为 <code>SPIINT</code> 。</p>\n<ul>\n<li>传输完成（<code>INT_FLAG</code>）</li>\n<li>接收超限（overrun in receiver）（<code>OVERRUN_FLAG</code>）</li>\n</ul>\n<p>传输完成标志 <code>INT_FLAG</code> 说明SPI已经完成发送或接收最后一个比特，并且准备好继续服务下一次传输了。在该标志为1时，说明接收到的数据已经被放在接收缓存 <code>SPIRXBUF</code> 中。如果 <code>SPIINTENA</code> 位设置过了，此时该标志位还会在中断向量表 的 <code>SPIINT</code> 上生成中断。</p>\n<p>接收超限标志 <code>OVERRUN_FLAG</code> 说明在当前字符数据被从缓冲区读取出来之前，传输或者接收操作已经完成。如果<code>OVERRUNINTENA</code> 位为 <code>1</code> 且 <code>OVERRUN_FLAG</code> 已经被清除了，则该标志会在 <code>SPIINT</code> 向量上生成一个中断。</p>\n<p>在FIFO模式下，SPI能够在 <strong>当前接收FIFO状态</strong>（RXFFST）和 <strong>接收FIFO中断水平</strong>（RXFFIL）之间的某个条件下中断CPU。如果 <code>RXFFST ≥ RXFFIL</code>，则 <strong>接收FIFO中断标志</strong> <code>RXFFINT</code> 将置 <code>1</code> ，如果<code>RXFFINT</code> 被置 <code>1</code> 且 <strong>接收FIFO中断</strong> （receive FIFO interrupt）被使能（<code>RXFFIENA</code> 为 <code>1</code>），则 <code>SPIRXINT</code> 将会被触发。</p>\n<h4 id=\"spitxint\">SPITXINT</h4>\n<p>在非FIFO模式下，SPITXINT中断不可用。在FIFO模式下，SPITXINT 和 SPIRXINT 相近。</p>\n<p>在FIFO模式下，SPI能够在 当前传输FIFO状态（TXFFST） 和 传输FIFO中断水平（TXFFIL）之间的某个条件下中断CPU。如果 <code>TXFFST ≤ TXFFIL</code> ，则 发送FIFO中断标志 <code>TXFFINT</code> 将置 <code>1</code>，如果 <code>TXFFINT</code> 被置 <code>1</code> 且 传输FIFO中断 被使能（<code>TXFFIENA</code> 为 <code>1</code>），则 <code>SPITXINT</code> 将会被触发。</p>\n<p>下图 22-2 展示了上述这些控制位如何影响SPI的中断生成：</p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819110332529.png\" alt=\"image-20210819110332529\" style=\"zoom: 80%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819110454056.png\" alt=\"image-20210819110454056\" style=\"zoom: 80%;\" /></p>\n<h3 id=\"dma支持\">DMA支持</h3>\n<p>CPU和DMA都可以通过内部外设总线来访问SPI数据的寄存器，最高可以读/写16bit的寄存器。每个SPI模块能够生成两个DMA事件 <code>SPITXDMA</code> 和 <code>SPIRXDMA</code> 。通过配置对应的 <code>SPIFFTX.TXFFIL</code> 和 <code>SPIFFRX.RXFFIL</code> 可以控制 DMA事件。当 <code>TXFFST ＜ TXFFIL</code> 时，<code>SPITXDMA</code> 激活。当 <code>RXFFST ≥ RXFFIL</code> 时，<code>SPIRXDMA</code> 激活。</p>\n<p>必须先开启FIFO增强，才能让DMA触发生成。（The SPI must have FIFO enhancements enabled in order for the DMA triggers to be generated.）</p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210819112140163.png\" alt=\"image-20210819112140163\" style=\"zoom:80%;\" /></p>\n<h3 id=\"高速模式\">高速模式</h3>\n<p>SPI的高速模式为所有GPIO多路器选项可用。为了开启 <strong>高速增强</strong>（High-Speed Enhancements），需要设置 <code>SPICCR.HS_MODE</code> 为 <code>1</code>。仍需确保针脚上的容性负载（capacitive loading ）不会超过（exceed）数据手册上的规定值（the value stated）。</p>\n<p>当关闭高速模式，或当针脚上的容性负载超过规定值时，<code>SPICCR.HS_MODE</code> 需要被设置为 <code>0</code> 。</p>\n<p>根据前面波特率计算案例可知，SPI最高能在 <code>LSPCLK == SYSCLK</code> 时达到其全双工通信最高速率 <code>25MHz</code> 。</p>\n<h3 id=\"三线模式\">三线模式</h3>\n<p>三线模式在设备为主机或从机模式下时均可设置，都需要设置 <code>TRIWIRE</code> 位，此时SPI的全时双工将变为半时双工模式，以下为主/从机模式下使用三线半双工模式时引脚的功能转变情况：</p>\n<p><strong>主机模式</strong>：<strong><em>SPISIMOx</em></strong> 则变成了 双向半双工（bi-directional, half-duplex） 的 <strong><em>SPIMOMIx</em></strong> 引脚，<strong><em>SPISOMIx</em></strong>则不再使用。</p>\n<p><strong>从机模式</strong>： <strong><em>SPISOMIx</em></strong> 变成了 双向半双工（bi-directional, half-duplex） 的 <strong><em>SPISISOx</em></strong> 引脚，对应的 <strong><em>SPISIMOx</em></strong> 则不再使用。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210819153841825.png\" alt=\"image-20210819153841825\" /><figcaption aria-hidden=\"true\">image-20210819153841825</figcaption>\n</figure>\n<p>由于需要在同一根信号线上完成读取和写入操作，<code>TALK</code> 位起了决定作用。该数据位写入时将数据传送出去，擦除时则读取数据。</p>\n<blockquote>\n<p>In master mode, in order to initiate a read, the application software must write dummy data to the SPI data register (SPIDAT or SPIRXBUF) while the TALK bit is cleared (no data is transmitted out the SPIMOMI pin) before reading from the data register.</p>\n</blockquote>\n<p>在主机模式下，为了初始化读取操作，软件必须配置为 在 <strong><em>TALK</em></strong> 位 被清除的情况下 向SPI数据寄存器（<code>SPIDAT</code> 或者 <code>SPIRXBUF</code> ）写入假数据（实际上没有数据被传送到SPIMOMI引脚），然后再从数据寄存器中读取。</p>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/08/image-20210819154636295.png\" alt=\"image-20210819154636295\" style=\"zoom:67%;\" /> <img src=\"https://pic.islet.space/2021/08/image-20210819154652213.png\" alt=\"image-20210819154652213\" style=\"zoom:67%;\" />\n</div>\n<h3 id=\"程序配置\">程序配置</h3>\n<p>暂略</p>\n<h2 id=\"sci\">SCI</h2>\n<p>SCI外设负责UART协议的编码部分，可以使用CH340芯片的串口助手进行读写测试。</p>\n<p>SCI外设支持 <strong>单线模式</strong>（Idle-line Mode）或 <strong>网络模式</strong>（Address-bit Mode）。</p>\n<blockquote>\n<p>此处 Idle-line Mode 由本人意译为 UART/RS中仅有两个CPU通信的 <strong>单线模式</strong>，Address-bit Mode 由本人意译为 UART/RS中有多个CPU通信的 <strong>网络模式</strong>。</p>\n</blockquote>\n<h3 id=\"外设架构\">外设架构</h3>\n<p><img src=\"https://pic.islet.space/2021/09/image-20210910111251456.png\" alt=\"image-20210910111251456\" style=\"zoom:67%;\" /></p>\n<h3 id=\"通信数据格式\">通信数据格式</h3>\n<p>不管是单线模式还是网络模式，都有统一的通信数据格式。</p>\n<p>SCI数据，包括接收和传输，都是 <strong>NRZ</strong> （non-return-to-zero）格式，该格式具有以下特点：</p>\n<ol type=\"1\">\n<li>1个起始位，必不可少。</li>\n<li>1~8个数据长度位，但一般传输都使用8bit，即一个字符大小，某些串口助手甚至不让发送低于5个bit的数据。</li>\n<li>1个奇偶校验位（可选），即可选NONE / ODD / EVEN。</li>\n<li>1个/2个停止位，必不可少。</li>\n<li>1个额外的位来区分地址和数据（仅在地址位模式下），即不设置地址位模式则可以不用改数据位。</li>\n</ol>\n<p>数据的基础格式被称为字符（8 bits）或1~8个数据位的长度。每个字符型数据有 <strong>1个起始位</strong>、<strong>1~2个结束位</strong>、<strong>可选的校验位</strong> 和 <strong>地址位</strong>。字符型数据的格式称为 <strong>帧</strong>（frame），如下图23-3所示。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210910152755579.png\" alt=\"image-20210910152755579\" /><figcaption aria-hidden=\"true\">image-20210910152755579</figcaption>\n</figure>\n<p>使用 <code>SCICCR</code> 寄存器即可编辑数据格式，编辑数据格式的寄存器位如下所示：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210913095605940.png\" alt=\"image-20210913095605940\" /><figcaption aria-hidden=\"true\">image-20210913095605940</figcaption>\n</figure>\n<h3 id=\"引脚配置-1\">引脚配置</h3>\n<p>GPIO复用寄存器必须配置为从外设连接至设备引脚。为了避免引脚上的电流尖峰，<code>GPyGMUX</code> 寄存器位必须先配置（当对应的<code>GPyMUX</code> 寄存器位默认保持为 <code>0</code> 时），然后在对应 <code>GPyMUX</code> 位上载入数值。</p>\n<p>某些IO口的功能由外设的GPIO寄存器独立设定。对于输入信号，GPIO输入限定器应该通过设置对应的 <code>GPxQSELn</code> 寄存器位为 <code>11b</code> 来设置为异步模式。内部拉高可以通过 <code>GPyPUD</code> 寄存器来设定。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210913094310841.png\" alt=\"image-20210913094310841\" /><figcaption aria-hidden=\"true\">image-20210913094310841</figcaption>\n</figure>\n<h3 id=\"通信格式\">通信格式</h3>\n<p>SCI或者UART即使再不一样，都跟I2C一样，一次传送一个 <code>unsigned char</code> 字符。</p>\n<p>SCI异步通信格式使用单线（单向）或者双线（双向）通信。在该模式下，帧内存在一个开始位，1~8位数据，一个可选的奇偶校验位 和 1~2个停止位，如下图23-7所示。</p>\n<p>线路一直都是置高状态，每次都在收到开始位（拉低）时开始进行数据接收操作。一个有效的起始位由4个0bit的连续的 <code>SCICLK</code> 周期组成，一旦该低电平无法保持4个 <code>SCICLK</code> 周期，则将重头开始等待新的起始位。</p>\n<p>为了能够成功采集到开始位之后的数据，处理器会对数据进行三次采样。这些采样发生在第四、第五和第六个SCICLK周期，比特值的确定是以 <strong>多数</strong>（Majority Vote）（三个中的两个）为基础，即如果该数据不能保持平稳（例如发送方波特率过高 或 噪声干扰等），可能会导致数据采样不稳。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/20210915203421.png\" alt=\"image-20210915203147266\" /><figcaption aria-hidden=\"true\">image-20210915203147266</figcaption>\n</figure>\n<h3 id=\"多核工作模式\">多核工作模式</h3>\n<p>多核通信格式允许单个处理器在同一条串行链路（on the same serial link）上高效传输一组数据（blocks of data）给其他处理器。在单条 <strong>串行线</strong>（serial line）上，任一时刻只能有一种传输，换句话说就是任一时刻只有一个发送者和一个接受者，即 <strong>分时双工</strong> / <strong>半双工</strong>。</p>\n<h4 id=\"地址字\">地址字</h4>\n<p>发送者（talker）发送的第一组数据（the first byte of a block of information）包含一个给所有接收者的地址字（address byte）。只有地址一致的接收者才会接收该地址后面传输的数据（can be interrupted by the data bytes that follow the address byte）。其他地址不一致的接收者在下一次收到地址一致的数据前都会保持原来的工作，不会被中断。</p>\n<blockquote>\n<p>注意，是地址字，不是地址位。</p>\n</blockquote>\n<h4 id=\"睡眠位\">睡眠位</h4>\n<p>在多个连接上的所有处理器都应该设置 SCI 睡眠位（<code>SCICTL1</code> 的第2位）为 <code>1</code> ，只有在检测到对应的地址位时才会被中断睡眠。当处理器读取到通过软件设置的对应CPU设备地址的地址块（a block address）时，程序必须清除睡眠位以使能SCI生成中断来接收数据位。</p>\n<p>虽然睡眠位为 <code>1</code> 时，接收端仍然独立操作，但是不会设置 <code>RXRDY</code> 、<code>RXINT</code> 或其他接收错误状态位 为 <code>1</code>，除非地址位被检测到且接收到的帧的地址位为 <code>1</code>（地址位模式下可用）。</p>\n<p><strong>注意</strong>：<mark>SCI外设不会自动切换 <code>SLEEP</code> 位的数据，必须手动切换。</mark>（The SCI does not alter the SLEEP bit; your software must alter the SLEEP bit.）</p>\n<h4 id=\"地址字节确定\">地址字节确定</h4>\n<p>每个处理器确定地址字节都不同，取决于多个模式的选择。</p>\n<ul>\n<li>在IL模式下</li>\n<li>在AB模式下</li>\n</ul>\n<h4 id=\"idle-line-多核模式\">Idle-Line 多核模式</h4>\n<p>在IL多核协议中（<code>ADDR</code> / <code>IDLE</code> 模式位为 <code>0</code>）</p>\n<p>多个独立的帧块之间会有 <mark style=\"font-weight: 900;\">10bit以上的空闲周期</mark>。</p>\n<p>一次地址多帧数据</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210913095703284.png\" alt=\"image-20210913095703284\" /><figcaption aria-hidden=\"true\">image-20210913095703284</figcaption>\n</figure>\n<h4 id=\"地址位多核模式\">地址位多核模式</h4>\n<ul>\n<li>多个帧块之间的空闲周期没有明显特征</li>\n<li>地址帧上存在地址位。</li>\n</ul>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210913100054258.png\" alt=\"image-20210913100054258\" /><figcaption aria-hidden=\"true\">image-20210913100054258</figcaption>\n</figure>\n<h3 id=\"sci中断\">SCI中断</h3>\n<p>SCI 的接受端和发送端都可以被中断控制。</p>\n<ul>\n<li><strong><em>SCICTL2</em></strong> 寄存器拥有 <strong>标志位</strong> 和 <strong>控制位</strong>，\n<ul>\n<li>控制位：使能接收缓存断点中断，<strong>RXBKINTENA</strong> 和 <strong>TXINTENA</strong></li>\n<li>标志位：鉴定活跃中断情况 <strong><em>TXRDY</em></strong> ，该寄存器跟数据发送准备相关。</li>\n</ul></li>\n<li><strong><em>SCIRXST</em></strong> 寄存器仅拥有 <strong>标志位</strong>，且都是与接收状态有关的，其中2个可以生成中断。\n<ul>\n<li>拥有两个中断标志位 <strong><em>RXRDY</em></strong> 和 <strong><em>BRKDT</em></strong> ，加上一个能够对 <strong>FE</strong>、<strong>OE</strong>、<strong>BRKDT</strong> 和 <strong>PE</strong> 情况进行逻辑或并记录的 <strong>RX ERROR</strong> 中断标志。发送端和接收端都拥有独立的中断使能位，当中断未使能时，中断活动不会被启用（the interrupts are not asserted），但是情况标志仍然活跃（the condition flags remain active），时刻反映着传输和接收状况。</li>\n</ul></li>\n</ul>\n<p>SCI的接收端和发送端都拥有独立外设中断向量。外设中断请求可以设置为高优先级或低优先级，通过从外设输出到PIE控制器上的优先级位进行鉴定。当RX和TX优先级一致时，接收端优先，以减少 <strong>接收端过载</strong>（receiver overrun）的可能性。</p>\n<p>外设中断的操作在 《系统控制和中断》章节下的《外设中断》部分已经说明。</p>\n<ul>\n<li>如果RX/BK INT ENA 位（SCICTL2，位1）已经设置，当以下任意事件发生时，接收端外设中断请求活动会被启用：\n<ul>\n<li>SCI接收到完整的帧（complete frame）并将 <strong>RXSHF</strong> 寄存器中数据转移到 <strong>SCIRXBUF</strong> 寄存器。以上动作就会设置 RXRDY 标志（SCIRXST寄存器第6bit）并初始化生成一个中断。</li>\n<li>断点检测情况（break detect condition）发生（SCIRXD 在丢失了结束位之后，置低了9.625个bit 周期），该动作会设置BRKDT标志位（SCIRXST寄存器第5bit）并初始化生成一个中断。</li>\n</ul></li>\n<li>如果TX INT ENA 位（SCICTL2 的第0位）被设置了，每当 <strong>SCITXBUF</strong> 中的数据被传输至 <strong>TXSHF</strong> 寄存器时，发送端外设中断请求会被断言（asserted)，表明CPU能够写入 <strong>SCITXBUF</strong> 了。该动作会设置 <strong>TXRDY</strong> 标志位（SCICTL2的第7位）并初始化一个中断。</li>\n</ul>\n<h3 id=\"波特率计算\">波特率计算</h3>\n<p>内部生成的串行时钟由 <strong>低速设备时钟</strong> <strong><em>LSPCLK</em></strong> 和 <strong>波特选择寄存器</strong>（baud-select registers）共同决定。SCI使用16 bit 的 波特选择寄存器在给定的 <strong>LSPCLK</strong> 值上 以选择一个可用的 <strong>64K差分串行时钟速率</strong>（one of the 64K different serial clock rates）。</p>\n<p>查看寄存器信息和SCI异步波特率计算公式。下表展示了 <strong>通用SCI比特率</strong>（common SCI bit rates）的波特率选择值。<code>LSPCLK/16</code> 是最大的波特率，例如，<code>LSPCLK=100MHz</code> 时，波特率最大为 <code>6.25Mbps</code> 。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210913171945217.png\" alt=\"image-20210913171945217\" /><figcaption aria-hidden=\"true\">image-20210913171945217</figcaption>\n</figure>\n<p>BRR等于高位寄存器 <code>SCIHBAUD</code> 左移8位和低位寄存器 <code>SCILBAUD</code> 的合成值。 <span class=\"math display\">\\[\nBRR = (SCIHBAUD&lt;&lt;8)+(SCILBAUD) \\tag{BRR计算公式}\n\\]</span> 异步波特率的计算公式为： <span class=\"math display\">\\[\nF_{Asynchronous} = \\frac{LSPCLK}{(BRR+1)·8} \\tag{异步波特率计算公式}\n\\]</span> 同步波特率的计算公式为： <span class=\"math display\">\\[\nF_{Synchronous}=\\frac{LSPCLK}{16} \\tag{同步波特率计算公式}\n\\]</span></p>\n<p>下表23-3是 LSPCLK =100MHz时， <strong>常见的BRR配置值</strong> 和 <strong>误差情况</strong>。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210910161523738.png\" alt=\"image-20210910161523738\" /><figcaption aria-hidden=\"true\">image-20210910161523738</figcaption>\n</figure>\n<h3 id=\"寄存器-3\">寄存器</h3>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210910111834789.png\" alt=\"image-20210910111834789\" /><figcaption aria-hidden=\"true\">image-20210910111834789</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210910111903444.png\" alt=\"image-20210910111903444\" /><figcaption aria-hidden=\"true\">image-20210910111903444</figcaption>\n</figure>\n<p>​</p>\n<h2 id=\"i2c\">I2C</h2>\n<p>暂略，在ADI的21479开发笔记中有类似，可以参考。</p>\n<h1 id=\"新建项目step-by-step\">新建项目（Step by step)</h1>\n<h2 id=\"新建c28xx项目\">新建C28xx项目</h2>\n<ol type=\"1\">\n<li>选择新建 CCS 项目</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210719094604082.png\" alt=\"image-20210719094604082\" /><figcaption aria-hidden=\"true\">image-20210719094604082</figcaption>\n</figure>\n<ol start=\"2\" type=\"1\">\n<li>可暂时不选择具体芯片，选择 F28xx 系列即可，也可以选择 <code>28004x Piccolo</code>，在选择具体芯片。</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210719094942412.png\" alt=\"image-20210719094942412\" /><figcaption aria-hidden=\"true\">image-20210719094942412</figcaption>\n</figure>\n<ol start=\"3\" type=\"1\">\n<li>设置项目名称并保存。</li>\n</ol>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210719094813670.png\" alt=\"image-20210719094813670\" style=\"zoom: 80%;\" /></p>\n<h2 id=\"设置处理器选项\">设置处理器选项</h2>\n<p>C2000系列编译器中，关于处理器选项，需要设置 <code>CLA</code>、 <code>FPU</code>、 <code>TMU</code>、 <code>IDIV</code> 和 <code>VCU</code> 这几个参数，其中《spru566n》全文关于 <code>IDIV</code> 的描述仅有 F28002x 和 2838x 支持，此处就默认 28004x 不支持（暂时先留空），其余支持项均可以在《spru566n》表11中查找到。</p>\n<ul>\n<li><code>IDIV</code> 是指 <strong><em>增强型整数除法</em></strong> ，enhanced integer division，也是快速整数除法，fast integer division。</li>\n<li><code>FPU</code> 有 FPU32 / FPU64 / SOFTLIB 三种选项，其中如果设置了 <code>TMU</code> 和 <code>VCU</code>，则默认设置为 FPU32。</li>\n</ul>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210719091534852.png\" alt=\"image-20210719091534852\" /><figcaption aria-hidden=\"true\">image-20210719091534852</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210719090718448.png\" alt=\"image-20210719090718448\" /><figcaption aria-hidden=\"true\">image-20210719090718448</figcaption>\n</figure>\n<p>各选项设置如下：</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210719094501999.png\" alt=\"image-20210719094501999\" style=\"zoom:67%;\" /></p>\n<h2 id=\"设置头文件选项\">设置头文件选项</h2>\n<p>向头文件包含设置中，添加几条 c2000Ware 套件安装包提供的支持库信息：</p>\n<p><code>D:\\ti\\c2000Ware\\C2000Ware_2_01_00_00\\driverlib\\f28004x\\driverlib</code></p>\n<p><code>D:\\ti\\c2000Ware\\C2000Ware_2_01_00_00\\device_support\\f28004x\\common\\include</code></p>\n<p><code>D:\\ti\\c2000Ware\\C2000Ware_2_01_00_00\\device_support\\f28004x\\headers\\include</code></p>\n<p><strong>注意</strong>：以上路径信息仅供参考，具体路径仍需依据套件安装地址来修改。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210719095520123.png\" alt=\"image-20210719095520123\" style=\"zoom:80%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210719095713314.png\" alt=\"image-20210719095713314\" style=\"zoom:80%;\" /></p>\n<p>最后一共有4条信息：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210719095934052.png\" alt=\"image-20210719095934052\" /><figcaption aria-hidden=\"true\">image-20210719095934052</figcaption>\n</figure>\n<h2 id=\"设置文件搜索路径\">设置文件搜索路径</h2>\n<p>先在 <span style=\"font-style: italic; color: #aaa; font-weight: 900;\">Add &lt;dir&gt; to library search path (--search_path, -i)</span> 中添加可以处理链接器的（.cmd）文件路径 <code>D:\\ti\\c2000Ware\\C2000Ware_2_01_00_00\\device_support\\f28004x\\common\\cmd</code>，然后将 <span style=\"font-style: italic; color: #aaa; font-weight: 900;\">Include library file or command files as input (--input, -I)</span> 中的 <code>libc.a</code> 删除，添加具体的链接器全名 <code>28004x_generic_ram_lnk.cmd</code> 和 <code>rts2800_fpu32.lib</code> 。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210719100817504.png\" alt=\"image-20210719100817504\" style=\"zoom:80%;\" /></p>\n<h2 id=\"设置代码启动点\">设置代码启动点</h2>\n<p>此步骤为 <strong><em>可选</em></strong> 步骤，在 <span style=\"font-style: italic; color: #aaa; font-weight: 900;\">Advance Options</span> 下的 <span style=\"font-style: italic; color: #aaa; font-weight: 900;\">Symbol Management</span> 中设置 <em>程序入口点</em> <code>code_start</code> 。</p>\n<p><strong>注意</strong>：本步骤是用于设置编译参数的，可以在完全新建项目的时候不操作本步骤，此时进行编译 <code>Build Project</code> 的话也是可以编译成功的。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210719101229117.png\" alt=\"image-20210719101229117\" style=\"zoom:80%;\" /></p>\n<blockquote>\n<p><em>code_start</em> is the first code that is executed after exiting the boot ROM code for the example f28004x projects. The projects are setup such that the codegen entry point is also set to the code start label using linker options. The code start code will automatically re-direct the execution to <code>_c_init00</code>.</p>\n</blockquote>\n<h2 id=\"设置字体集\">设置字体集</h2>\n<p>此步骤为 <strong><em>可选</em></strong> 步骤，在 <span style=\"font-style: italic; color: #aaa; font-weight: 900;\">Resource</span> 下可以设置 <em>字体编码</em> 和 <em>回行</em> 格式。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210719101527907.png\" alt=\"image-20210719101527907\" style=\"zoom:80%;\" /></p>\n<h2 id=\"添加文件\">添加文件</h2>\n<p>添加文件有两种形式，一种是以链接形式添加，编译时不会修改到源文件。另一种是直接添加至项目中（复制副本 或 新建文件）。</p>\n<ol type=\"1\">\n<li>先用官方提供的文件进行预试添加和调试。在项目上右击选择 <code>Add Files</code> ，以 <strong><em>链接形式</em></strong> 添加文件：</li>\n</ol>\n<ul>\n<li><code>D:\\ti\\c2000Ware\\C2000Ware_2_01_00_00\\driverlib\\f28004x\\driverlib\\ccs\\Debug\\driverlib.lib</code></li>\n<li><code>D:\\ti\\c2000Ware\\C2000Ware_2_01_00_00\\device_support\\f28004x\\common\\source\\device.c</code></li>\n<li><code>D:\\ti\\c2000Ware\\C2000Ware_2_01_00_00\\device_support\\f28004x\\common\\source\\f28004x_codestartbranch.asm</code></li>\n</ul>\n<ol start=\"2\" type=\"1\">\n<li>在项目名上右键点击 Add Files。</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210719102326890.png\" alt=\"image-20210719102326890\" /><figcaption aria-hidden=\"true\">image-20210719102326890</figcaption>\n</figure>\n<ol start=\"3\" type=\"1\">\n<li>选择对应路径文件。</li>\n</ol>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210719102359274.png\" alt=\"image-20210719102359274\" style=\"zoom:80%;\" /></p>\n<ol start=\"4\" type=\"1\">\n<li>选择添加方式 Link to files ，可以看到项目中已经添加了一个文件。</li>\n</ol>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/07/image-20210719102420155.png\" alt=\"image-20210719102420155\" style=\"zoom:80%;\" /> <img src=\"https://pic.islet.space/2021/07/image-20210719102438745.png\" alt=\"image-20210719102438745\" style=\"zoom:80%;\" />\n</div>\n<ol start=\"5\" type=\"1\">\n<li>到此处后仍不能进行 <code>Build Project</code> ，会报错 <code>error #10234-D: unresolved symbols remain c28</code>，需要执行下一步，将 <code>main.c</code> 以 <strong><em>新文件形式</em></strong> 添加进去。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;driverlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;device.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Initialize device clock and peripherals</span></span><br><span class=\"line\">    Device_init();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Initialize GPIO and configure the GPIO pin as a push-pull output</span></span><br><span class=\"line\">    Device_initGPIO();</span><br><span class=\"line\">    GPIO_setPadConfig(DEVICE_GPIO_PIN_LED1, GPIO_PIN_TYPE_STD);</span><br><span class=\"line\">    GPIO_setDirectionMode(DEVICE_GPIO_PIN_LED1, GPIO_DIR_MODE_OUT);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Initialize PIE and clear PIE registers. Disables CPU interrupts.</span></span><br><span class=\"line\">    Interrupt_initModule();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Initialize the PIE vector table with pointers to the shell Interrupt</span></span><br><span class=\"line\">    <span class=\"comment\">// Service Routines (ISR).</span></span><br><span class=\"line\">    Interrupt_initVectorTable();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Enable Global Interrupt (INTM) and realtime interrupt (DBGM)</span></span><br><span class=\"line\">    EINT;</span><br><span class=\"line\">    ERTM;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Loop Forever</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;;)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Turn on LED</span></span><br><span class=\"line\">        GPIO_writePin(DEVICE_GPIO_PIN_LED1, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Delay for a bit.</span></span><br><span class=\"line\">        DEVICE_DELAY_US(<span class=\"number\">500000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Turn off LED</span></span><br><span class=\"line\">        GPIO_writePin(DEVICE_GPIO_PIN_LED1, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Delay for a bit.</span></span><br><span class=\"line\">        DEVICE_DELAY_US(<span class=\"number\">500000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"项目编译\">项目编译</h2>\n<p>修改完之后进行编译 Build Project ，会报错 <strong><em>内存不足</em></strong>，信息如下：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;D:/ti/c2000Ware/C2000Ware_2_01_00_00/device_support/f28004x/common/<span class=\"built_in\">cmd</span>/<span class=\"number\">28004</span>x_generic_ram_lnk.<span class=\"built_in\">cmd</span>&quot;, line <span class=\"number\">81</span>: error #<span class=\"number\">10099</span>-D: program will <span class=\"keyword\">not</span> fit into available memory.  run placement with alignment/blocking fails <span class=\"keyword\">for</span> section &quot;.stack&quot; size <span class=\"number\">0</span>x400 page <span class=\"number\">1</span>.  Available memory ranges:</span><br><span class=\"line\">   RAMM1        size: <span class=\"number\">0</span>x3f8        unused: <span class=\"number\">0</span>x3f8        max hole: <span class=\"number\">0</span>x3f8     </span><br></pre></td></tr></table></figure>\n<p>以上错误信息的大意是，软件需要使用到的 <strong>堆</strong> <code>.stack</code> 的大小是 <code>0x400</code> 而 <code>RAMM1</code> 的大小只有 <code>0x3f8</code> 。</p>\n<p>从错误提示中看到报错的文件名，打开在 <strong>设置文件搜索路径</strong> 中添加的 <code>28004x_generic_ram_lnk.cmd</code> 文件，已知TI公司利用 <code>.cmd</code> 文件来描述芯片内部地址，打开该文件并搜索可以看到 <code>RAMM1</code> 的确大小不足 <code>0x40</code>，且此时 <code>RAMM1_RSVD</code> 并未被使用，适当修改 <code>RAMM1</code> 的地址长度，注意不要和其他地址长度重叠即可。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210719110002751.png\" alt=\"image-20210719110002751\" style=\"zoom:80%;\" /></p>\n<p>重新编译即可成功。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210719111024816.png\" alt=\"image-20210719111024816\" /><figcaption aria-hidden=\"true\">image-20210719111024816</figcaption>\n</figure>\n<h1 id=\"评估板硬件连接\">评估板硬件连接</h1>\n<p>TI官方的评估板型号为 LAUNCHXL-F280049C （如下示），支持使用JTAG连接与PC进行通信，关于评估板的手册文档如<a href=\"https://www.ti.com/lit/spruii7\">《SPRUII7》</a>所示。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210726152918902.png\" alt=\"image-20210726152918902\" /><figcaption aria-hidden=\"true\">image-20210726152918902</figcaption>\n</figure>\n<p>连接完毕之后，设备管理器 会出现如下图所示硬件：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210726154218244.png\" alt=\"image-20210726154218244\" /><figcaption aria-hidden=\"true\">image-20210726154218244</figcaption>\n</figure>\n<div style=\"text-align: center; font-weight: 900;\">\n图 设备管理器界面\n</div>\n<p>本评估板自带了XDS110接口，只需要使用USB mini 线和PC进行，并在项目文件路径 <code>targetConfigs\\TMS320F280049C_LaunchPad.ccxml</code> 文件下确保连接器和设备正确即可。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210726153612834.png\" alt=\"image-20210726153612834\" /><figcaption aria-hidden=\"true\">image-20210726153612834</figcaption>\n</figure>\n<div style=\"text-align: center; font-weight: 900;\">\n图 Project Explorer窗口下的文件路径\n</div>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210726153524140.png\" alt=\"image-20210726153524140\" /><figcaption aria-hidden=\"true\">image-20210726153524140</figcaption>\n</figure>\n<div style=\"text-align: center; font-weight: 900;\">\n图 配置文件下的连接器配置\n</div>\n<p>在<code>.ccxml</code> 文件中进行修改，点击下方的 <em>Advanced</em>，然后选择 <code>cJTAG(1149.7)2-pin advance mode</code>，然后 <em>save</em> 保存即可。具体操作如下图：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210726155434636.png\" alt=\"image-20210726155434636\" /><figcaption aria-hidden=\"true\">image-20210726155434636</figcaption>\n</figure>\n<div style=\"text-align: center; font-weight: 900;\">\n图 选择cJTAG连接方式\n</div>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210726160136365.png\" alt=\"image-20210726160136365\" /><figcaption aria-hidden=\"true\">image-20210726160136365</figcaption>\n</figure>\n<div style=\"text-align: center; font-weight: 900;\">\n图 点击测试按钮进行连接测试\n</div>\n<h1 id=\"f28004x-api指南\">F28004x API指南</h1>\n<p>截止2020年7月21日，最新版 <a href=\"https://code.islet.space/TI/f28004x/3_04/intro.html\">F28004x API指南 3.04版</a> 已上传。可以直接在联网电脑上打开，使用Google chrome浏览器可以右键翻译查阅。</p>\n<h2 id=\"文件组织概述\">文件组织概述</h2>\n<p>以下是外围驱动库源代码的组织概览。</p>\n<ul>\n<li>{driverlib} - 此目录包含驱动程序的源代码。</li>\n<li>{driverlib/inc/} - 此目录包含用于直接寄存器访问编程模型的外设、中断和寄存器访问头文件。</li>\n<li>{hw_*.h} - 头文件，每个外设一个，描述每个外设的所有寄存器和这些寄存器中的位域。驱动程序使用这些头文件直接访问外设，应用程序代码可以使用这些头文件绕过外设驱动程序库 API。</li>\n</ul>\n<h2 id=\"编程模型\">编程模型</h2>\n<p>外设驱动程序库支持两种编程模型：<strong><em>直接寄存器访问模型</em></strong> 和 <strong><em>软件驱动程序模型</em></strong>。根据应用程序的需要或开发人员所需的编程环境，每个模型都可以单独使用或组合使用。</p>\n<p>每种编程模型都有优点和缺点。与使用软件驱动程序模型相比，<mark>使用直接寄存器访问模型通常会产生更小、更高效的代码</mark>。然而，直接寄存器访问模型<mark>需要详细了解每个寄存器和位域的操作，以及它们的相互作用和外围设备正常操作所需的任何顺序</mark>；<mark>软件驱动程序模型</mark>使开发人员与这些细节更加隔绝，<mark>通常需要更少的时间来开发应用程序</mark>。软件驱动程序模型还产生了<mark>更具可读性的代码</mark>。</p>\n<h1 id=\"f28004x-伪操作\">F28004x 伪操作</h1>\n<p>在 <code>F28004x_device.h</code> 文件中包含一部分伪操作，参考《SPRU430F》做出解释</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>  EINT   __asm(<span class=\"meta-string\">&quot; clrc INTM&quot;</span>)   <span class=\"comment\">//INTM置0，打开（enable）中断</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>  DINT   __asm(<span class=\"meta-string\">&quot; setc INTM&quot;</span>)   <span class=\"comment\">//INTM置1，关闭（disable）中断</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>  ERTM   __asm(<span class=\"meta-string\">&quot; clrc DBGM&quot;</span>)   <span class=\"comment\">//打开调试模式（Debug Mode）</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>  DRTM   __asm(<span class=\"meta-string\">&quot; setc DBGM&quot;</span>)   <span class=\"comment\">//关闭调试模式（Debug Mode）</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>  EALLOW __asm(<span class=\"meta-string\">&quot; EALLOW&quot;</span>)   <span class=\"comment\">//打开保护区域写入权限（Enable Write Access to Protected Space）</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>  EDIS   __asm(<span class=\"meta-string\">&quot; EDIS&quot;</span>)   <span class=\"comment\">//关闭保护区域写入权限（Disable Write Access to Protected Space）</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>  ESTOP0 __asm(<span class=\"meta-string\">&quot; ESTOP0&quot;</span>)   <span class=\"comment\">//Emulation Stop 0</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>： 以上伪操作中，最常使用的 <code>EALLOW</code> 和 <code>EDIS</code> 会在操作某些 写保护的寄存器时使用，利用这两句伪操作来暂时关闭写保护，写完寄存器后再打开保护。</p>\n<p>以下为《SPRU430F》第107 ~ 113页提供的伪操作指令合集。</p>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/07/image-20210721145040598.png\" alt=\"image-20210721145040598\" style=\"zoom: 67%;\" /><img src=\"https://pic.islet.space/2021/07/image-20210721145100629.png\" alt=\"image-20210721145100629\" style=\"zoom:67%;\" />\n</div>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/07/image-20210721145123473.png\" alt=\"image-20210721145123473\" style=\"zoom:67%;\" /><img src=\"https://pic.islet.space/2021/07/image-20210721145138283.png\" alt=\"image-20210721145138283\" style=\"zoom:67%;\" />\n</div>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/07/image-20210721145157425.png\" alt=\"image-20210721145157425\" style=\"zoom:67%;\" /><img src=\"https://pic.islet.space/2021/07/image-20210721145226082.png\" alt=\"image-20210721145226082\" style=\"zoom:67%;\" />\n</div>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/07/image-20210721145242594.png\" alt=\"image-20210721145242594\" style=\"zoom:67%;\" />\n</div>\n<h1 id=\"c2000ware\">C2000Ware</h1>\n<p>C2000Ware是C28系列芯片的IDE组成部分，开发过程一共安装了两个版本，2.01版与3.04版，<marK>两者的文件结构基本一致</mark>，包括 <u>样例应用</u>、<u>头文件存放路径</u> 等基本一致，不一致的地方是文件内容，包括 <u>例程的增删</u> 和 <u>说明文档的更新</u>。始终不变的是C2000Ware的例程类别，总共有两种，分别在两个路径下：</p>\n<ul>\n<li><code>D:\\ti\\c2000Ware\\C2000Ware_2_01_00_00\\driverlib\\f28004x\\examples</code>，存放的是 <strong><em>驱动库样例应用</em></strong>（Driver Library Example Applications），是以驱动及其案例来进行代码编写的，每个project都可能会涉及许多外设，因此使用前需要先阅读相关文档去了解该案例的开发目标，再结合实际进行修改。</li>\n<li><code>D:\\ti\\c2000Ware\\C2000Ware_2_01_00_00\\device_support\\f28004x\\examples</code>， 存放的是 <strong><em>位域样例应用</em></strong>（Bit-Field Example Applications），是以最小外设功能为目标的代码编写过程，并不是以project作为分类单元的，而是以外设为分类方法，每个外设的某个细节功能作为代码间的区别。</li>\n</ul>\n<p><strong>例如</strong>：同样是了解PWM外设的使用案例，从 <strong><em>驱动库样例应用</em></strong>（3.04版） 中能找到的案例只有3个：<code>boostxl_afe031_f28004x_pwmmode</code>、<code>hrpwm</code> 和 <code>adc_ex1_soc_epwm</code>，具体如何使用，使用到PWM里的何种功能并不能从项目案例中直接看出来。但是从 <strong><em>位域样例应用</em></strong>（3.04版） 中，可以找到13个PWM下的应用：<code>trip_zone</code> / <code>updown_aq</code> / <code>synchronization</code> / <code>digital_compare</code> / <code>digital_compare_event_filter</code> / <code>valley_switching</code> / <code>edge_filter</code> / <code>deadband</code> / <code>dma</code> / <code>chopper</code> / <code>configure_signal</code> / <code>monoshot_mode</code> / <code>up_aq</code> 。</p>\n<blockquote>\n<p><em>PS</em>：以上信息因C2000Ware版本不同而不同。</p>\n</blockquote>\n<p>以上信息，从《F28004x_DEV_USER_GUIDE》中也可以查看到，理清套件下的文件结构需要阅读的文件有两个，但在3.04版本的C2000Ware中未提供：</p>\n<ol type=\"1\">\n<li><a href=\"https://code.islet.space/TI/f28004x/docs/F28004x_DriverLib_Users_Guide.pdf\">《F28004x_DriverLib_Users_Guide》</a></li>\n<li><a href=\"https://code.islet.space/TI/f28004x/docs/F28004x_DEV_USER_GUIDE.pdf\">《F28004x_DEV_USER_GUIDE》</a></li>\n</ol>\n<p>2.01与3.04版本都提供了网页版的手册，可以在对应 <code>\\docs\\</code> 文件夹下查阅。推荐使用网页版 <a href=\"https://code.islet.space/TI/f28004x/3_04/index.html\">API指南</a> 进行函数原型速查。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210721154709745.png\" alt=\"image-20210721154709745\" /><figcaption aria-hidden=\"true\">image-20210721154709745</figcaption>\n</figure>\n<div style=\"text-align: center; font-weight: 900;\">\n图 3.04版本函数的搜索查阅\n</div>\n<h1 id=\"高频逆变器开发\">高频逆变器开发</h1>\n<p><strong>逆变器</strong>，即将直流DC变换为交流AC的过程。利用 DSP输出波形，控制接入高压直流电的（高位 和 地位）两个IGBT输出正向和反向两种电压，形成交流AC。</p>\n<p>逆变电路根据直流侧电源的性质不同（电压源/电流源）分为两种类别： <strong>电压型逆变电路</strong> 和 <strong>电流型逆变电路</strong>。</p>\n<blockquote>\n<p>电压源逆变电路的特点：</p>\n<ol type=\"1\">\n<li>直流侧为电压源，或并联有大电容，相当于电压源。直流侧电压基本无脉动，直流回路呈现低阻抗。</li>\n<li>由于直流电压源的钳位作用，交流侧输出电压波形为矩形波，且与负载阻抗角无关。而交流侧输出电流波形与相位因负载阻抗情况的不同而不同。</li>\n<li>当交流侧为阻感负载时需要提供无功功率，直流侧电容起缓冲无功能能量的作用。为了给交流侧向直流侧反馈的无功能量提供通道，逆变桥各臂都并联了 反馈二极管。</li>\n</ol>\n</blockquote>\n<p><strong>单相电压型逆变电路</strong> 可以根据变换出来的波形分为 <strong>半桥</strong> 或 <strong>全桥</strong>，即 <strong>单相半桥变压型逆变电路</strong> 和 <strong>单相全桥变压型逆变电路</strong>。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210719162954288.png\" alt=\"image-20210719162954288\" /><figcaption aria-hidden=\"true\">image-20210719162954288</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210719162958021.png\" alt=\"image-20210719162958021\" /><figcaption aria-hidden=\"true\">image-20210719162958021</figcaption>\n</figure>\n<p><strong>具体为</strong>：利用型号为 <code>TMS320F280041</code> 芯片的GPIO（最高输出频率为25MHz）输出一个30KHz的PWM波形，需要使用到 ePWM外设。使用官方C2000套件示例中提供的 <code>ePWM6</code> 案例进行开发，输出高位和低位两个幅频合适的波形后，接到型号为 <code>2EDL05I06PF</code> 的驱动上，由驱动控制型号为 <code>IKW50N65WR5</code> 的IGBT 高频开断。</p>\n<h2 id=\"工作目标\">工作目标</h2>\n<ol type=\"1\">\n<li>使用内源时钟，使芯片工作在100Mhz</li>\n<li>输出占空比为50%的PWM波形，频率在30KHz</li>\n<li>采集输出的波形和IGBT输出的波形（可能需要检测相位和波纹）</li>\n<li>完成过零饱和电压检测</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210719160255497.png\" alt=\"image-20210719160255497\" /><figcaption aria-hidden=\"true\">image-20210719160255497</figcaption>\n</figure>\n<div style=\"text-align: center; font-weight: 900;\">\n图 占空比为20%的测试波形\n</div>\n<h2 id=\"工作流程\">工作流程</h2>\n<pre class=\"mermaid\">graph TB\n系统初始化 --> 使能PWM模块时钟 --> 初始化PWM模块 --> PWM工作</pre>\n<h3 id=\"初始化pwm流程\">初始化PWM流程</h3>\n<pre class=\"mermaid\">graph TB\n配置TB子系统 --> 配置CMPA和CMPB --> 设置CMPC寄存器 --> 配置TZ子系统 --> 配置AQ子系统 --> 配置DB子系统 --> 配置ET子系统</pre>\n<h2 id=\"pll设置\">PLL设置</h2>\n<ul>\n<li><code>TMS320F280041</code> 的外部晶振输入频率 f<span style=\"font-size: 0.8rem;\">XTAL</span> 在 10 ~ 20 MHz 之间，自身工作频率f<span style=\"font-size: 0.8rem;\">SYSCLK</span> 在 2 ~ 100MHz之间。</li>\n</ul>\n<p>以下为工作频率设置的样例，利用内源时钟 <code>10MHz</code> ，产生芯片满负工作频率 <code>100MHz</code> ：</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210715170724177.png\" alt=\"image-20210715170724177\" style=\"zoom:67%;\" /></p>\n<p>本系统采用10MHz的内源时钟 <strong><em>INTOSC2</em></strong> 作为 <strong><em>OSCCLK</em></strong>，其配置方法（包括设置公式和函数原型）都已在前文详细描述和记录，请参考该代码。</p>\n<h2 id=\"epwm-1\">ePWM</h2>\n<p>以下为两个版本下案例所给的 <code>main()</code>函数的流程对比。</p>\n<p>左侧用的是Bitfield模式，右边用的是driver-lib模式。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210722084618101.png\" alt=\"image-20210722084618101\" /><figcaption aria-hidden=\"true\">image-20210722084618101</figcaption>\n</figure>\n<div style=\"text-align: center; font-weight: 900;\">\n图 新旧版本main()函数流程对比\n</div>\n<p>同样是将中断重新映射至ISR函数里，下图左侧是2.01版本下的driver-lib模式，右侧是3.04bit-field模式。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210721154450124.png\" alt=\"image-20210721154450124\" /><figcaption aria-hidden=\"true\">image-20210721154450124</figcaption>\n</figure>\n<div style=\"text-align: center; font-weight: 900;\">\n图 不同的调用配置方法\n</div>\n<h3 id=\"宏定义\">宏定义</h3>\n<h4 id=\"epwm外设定义\">ePWM外设定义</h4>\n<p>在Driver-Lib的 <code>&lt;f28004x_globalVariabledefs.c&gt;</code> 中，提供了ePWM下各模块的定义，如下面代码所示，定义了 外设 ePWM1所有的寄存器（结构体）<code>EPwm1Regs</code> ，是EPWM_REGS的结构体实例。</p>\n<p><strong>使用方法</strong>：使用该外设下的寄存器时直接按照结构体变量的方法使用即可，如 <code>EPwm1Regs.TBPRD = EPWM1_TIMER_TBPRD</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> DATA_SECTION(<span class=\"meta-string\">&quot;EPwm1RegsFile&quot;</span>)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> DATA_SECTION(EPwm1Regs,<span class=\"meta-string\">&quot;EPwm1RegsFile&quot;</span>);</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EPWM_REGS</span> <span class=\"title\">EPwm1Regs</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//----------------------------------------</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> DATA_SECTION(<span class=\"meta-string\">&quot;EPwm2RegsFile&quot;</span>)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> DATA_SECTION(EPwm2Regs,<span class=\"meta-string\">&quot;EPwm2RegsFile&quot;</span>);</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EPWM_REGS</span> <span class=\"title\">EPwm2Regs</span>;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"设置上下桥\">设置上下桥</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> EPWM1_TIMER_TBPRD = <span class=\"number\">800</span>; <span class=\"comment\">// 设置PWM的周期PRD为1600</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> EPWM1_CMPA = <span class=\"number\">200</span>;  <span class=\"comment\">//设置高边CMPA为800</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> EPWM1_CMPB = <span class=\"number\">200</span>;  <span class=\"comment\">//设置低边CMPB为800</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> EPWM1_DBRED = <span class=\"number\">35</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> EPWM1_DBFED = <span class=\"number\">35</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"初始化外设\">初始化外设</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*-----------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 【函数】：void EPWM1_Init(void);</span></span><br><span class=\"line\"><span class=\"comment\"> * 【参数】：无</span></span><br><span class=\"line\"><span class=\"comment\"> * 【说明】：需要查阅《TRM》或开发文档相关说明</span></span><br><span class=\"line\"><span class=\"comment\"> *                     本代码文件中仅包含ePWM6模块的使用，其中ET开头的寄存器为事件</span></span><br><span class=\"line\"><span class=\"comment\"> *                     触发相关寄存器，用以触发ADC转换（SOC）</span></span><br><span class=\"line\"><span class=\"comment\"> *                     需要配置的寄存器有：</span></span><br><span class=\"line\"><span class=\"comment\"> * 【其他】：注意，EPWM设置时必须开着时钟（PCLKCR2）进行配置，否则配置</span></span><br><span class=\"line\"><span class=\"comment\"> *                     会失败</span></span><br><span class=\"line\"><span class=\"comment\"> * 【参考】：</span></span><br><span class=\"line\"><span class=\"comment\">----------------------------------------------------------------------- */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">EPWM1_Init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    EALLOW;                                                           <span class=\"comment\">//打开保护区域写入权限</span></span><br><span class=\"line\">    CpuSysRegs.PCLKCR2.bit.EPWM1 = ON;           <span class=\"comment\">// 打开CPUSYSREG 地址下PCLKCR2寄存器上的EPWM1位</span></span><br><span class=\"line\">    CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = OFF;   <span class=\"comment\">//关闭TBCLK时钟同步</span></span><br><span class=\"line\">    EDIS;                                                                 <span class=\"comment\">//关闭保护区域写入权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EPwm1Regs.TBPRD = EPWM1_TIMER_TBPRD;       <span class=\"comment\">// 设定定时器周期</span></span><br><span class=\"line\">    EPwm1Regs.TBPHS.bit.TBPHS = <span class=\"number\">0x0000</span>;                 <span class=\"comment\">// 初始化相位</span></span><br><span class=\"line\">    EPwm1Regs.TBCTR = <span class=\"number\">0x0000</span>;                                  <span class=\"comment\">// 初始化（清空）TB计数器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EPwm1Regs.CMPA.bit.CMPA = EPWM1_CMPA;    <span class=\"comment\">// 设定高边值</span></span><br><span class=\"line\">    EPwm1Regs.CMPB.bit.CMPB = EPWM1_CMPB;    <span class=\"comment\">// 设定低边值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN;      <span class=\"comment\">//设置TB计数器为增减计数模式</span></span><br><span class=\"line\">    EPwm1Regs.TBCTL.bit.PHSEN = TB_DISABLE;                              <span class=\"comment\">// 关闭相位载入</span></span><br><span class=\"line\">    EPwm1Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_DISABLE;            <span class=\"comment\">//关闭各PWM间的同步</span></span><br><span class=\"line\">    EPwm1Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1;                            <span class=\"comment\">// 调节本值可以设置TB速率，详见开发文档</span></span><br><span class=\"line\">    EPwm1Regs.TBCTL.bit.CLKDIV = TB_DIV2;                                   <span class=\"comment\">// 调节本值可以设置TB速率，详见开发文档</span></span><br><span class=\"line\">    EPwm1Regs.TBCTL.bit.FREE_SOFT = <span class=\"number\">0x03</span>;                                   <span class=\"comment\">//不停止，free-run 模式</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EPwm1Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW;    <span class=\"comment\">//打开CC子模块下的影子寄存器A</span></span><br><span class=\"line\">    EPwm1Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW;</span><br><span class=\"line\">    EPwm1Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO_PRD; <span class=\"comment\">// Load on Zero</span></span><br><span class=\"line\">    EPwm1Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO_PRD;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    EPwm1Regs.TZSEL.bit.OSHT1 = <span class=\"number\">1</span>;   <span class=\"comment\">//为PWM1使能单次事件触发TZ</span></span><br><span class=\"line\">    EPwm1Regs.TZCTL.bit.TZA = <span class=\"number\">2</span>;    <span class=\"comment\">// EPWMA会被强制置低</span></span><br><span class=\"line\">    EPwm1Regs.TZCTL.bit.DCAEVT1 = TZ_LOW_STATE;</span><br><span class=\"line\">    EPwm1Regs.TZCTL.bit.DCAEVT2 = TZ_LOW_STATE;</span><br><span class=\"line\"></span><br><span class=\"line\">    EPwm1Regs.TZCTL.bit.TZB = <span class=\"number\">2</span>;   <span class=\"comment\">// EPWMB会被强制置低</span></span><br><span class=\"line\">    EPwm1Regs.TZCTL.bit.DCBEVT1 = TZ_LOW_STATE;</span><br><span class=\"line\">    EPwm1Regs.TZCTL.bit.DCBEVT2 = TZ_LOW_STATE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设定事件触发结果，当CMPx == TBCTR时该如何动作，此处需要高边A和低边B的动作随着TB增减而相反</span></span><br><span class=\"line\">    EPwm1Regs.AQCTLA.bit.CAU = AQ_SET;</span><br><span class=\"line\">    EPwm1Regs.AQCTLB.bit.CBU = AQ_CLEAR;</span><br><span class=\"line\">    EPwm1Regs.AQCTLA.bit.CAD = AQ_CLEAR;</span><br><span class=\"line\">    EPwm1Regs.AQCTLB.bit.CBD = AQ_SET;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//死区控制</span></span><br><span class=\"line\">    EPwm1Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE;   <span class=\"comment\">//0x3   MODE2 AHC high level delay</span></span><br><span class=\"line\">    EPwm1Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC;        <span class=\"comment\">//0x2</span></span><br><span class=\"line\">    EPwm1Regs.DBCTL.bit.IN_MODE = DBA_ALL;</span><br><span class=\"line\">    EPwm1Regs.DBRED.all = <span class=\"number\">120</span>;                        <span class=\"comment\">// 上升沿延时   0us  0个(15MHz)   注意：只有10位，最大1023</span></span><br><span class=\"line\">    EPwm1Regs.DBFED.all = <span class=\"number\">120</span>;                        <span class=\"comment\">// 下降沿延时   0us  (15MHz)   注意：只有10位，最大1023</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EPwm1Regs.ETSEL.bit.INTEN = ON;                <span class=\"comment\">// 关闭EPWM外设的中断</span></span><br><span class=\"line\">    EPwm1Regs.ETSEL.bit.SOCAEN = ON;            <span class=\"comment\">// 打开ePWM1的SOCA脉冲</span></span><br><span class=\"line\">    EPwm1Regs.ETSEL.bit.SOCASEL = <span class=\"number\">0x02</span>;          <span class=\"comment\">// TB计数器等予周期时触发事件</span></span><br><span class=\"line\">    EPwm1Regs.ETPS.bit.SOCAPRD = <span class=\"number\">0x01</span>;          <span class=\"comment\">// 在第一次事件时生成脉冲</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EALLOW;</span><br><span class=\"line\">    EPwm1Regs.TBCTL.bit.PHSEN = ON;                  <span class=\"comment\">//打开从相位寄存器载入</span></span><br><span class=\"line\">    EPwm1Regs.TBCTL.bit.SYNCOSEL = OFF;          <span class=\"comment\">//同步输出源选择</span></span><br><span class=\"line\">    EPwm1Regs.TBCTL.bit.SWFSYNC = OFF;           <span class=\"comment\">//软件强制同步脉冲</span></span><br><span class=\"line\">    CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = ON;   <span class=\"comment\">//打开TBCLK时钟同步</span></span><br><span class=\"line\">    EDIS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面代码里总结出下面配置步骤：</p>\n<pre class=\"mermaid\">graph LR\n配置开始 --> 配置TBCLK --> 配置影子寄存器ShadowRegister --> 配置CMP --> 配置TripZone --> 配置AactionQualifier --> 配置ePWM中断 --> 配置结束</pre>\n<h3 id=\"epwmclk\">EPWMCLK</h3>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210726110116356.png\" alt=\"image-20210726110116356\" /><figcaption aria-hidden=\"true\">image-20210726110116356</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210802172012594.png\" alt=\"image-20210802172012594\" /><figcaption aria-hidden=\"true\">image-20210802172012594</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210802171937172.png\" alt=\"image-20210802171937172\" /><figcaption aria-hidden=\"true\">image-20210802171937172</figcaption>\n</figure>\n<p>通过配置下方代码中 <code>main()</code> 函数的参数，来对CPU 、ePWM的相关寄存器参数进行调节，可以实现目标PWM周期为30.8Khz的设置。</p>\n<p>参数计算代码就不贴了，可以直接下载：<a href=\"http://code.islet.space/VisualStudioStudio/F28004x_ParamsCalculate/main.cpp\">main.cpp</a></p>\n<p>从系统时钟设置到外设时钟设置过程中，需要设置的寄存器、位及其数值具体如下（仅供参考）：</p>\n<ol type=\"1\">\n<li>设置时钟源。选择时钟源为 <strong><em>内源时钟2</em></strong>（INTOSC2），修改 <code>CLKSRCCTL1</code> 寄存器下的 <code>OSCCLKSRCSEL</code> 值为 <code>0x00</code> 。</li>\n<li>设置系统PLL频率。需要分别设置整数分频、分数分频 和 系统分频，对应修改 <code>SYSPLLMULT</code> 寄存器下的 <code>IMULT</code> / <code>FMULT</code> / <code>ODIV</code> 值为 <code>0x13</code> / <code>0x3</code> / <code>0x1</code> （或使用十进制赋值 <code>19</code> / <code>3</code> / <code>1</code>）。</li>\n<li>设置需要使用的PWM设备序号。打开对应控制的 <code>PCLKCRx</code> 寄存器下的对应位，参考《SPRUI33D》第195页相关寄存器说明。</li>\n<li>设定PWMCLK频率。修改 <code>TBCTL</code> 寄存器下的 <code>HSPCLKDIV</code> 及 <code>CLKDIV</code> 为 <code>0x00</code>（<code>1</code>） 及 <code>0x01</code> （<code>2</code>）（默认情况下也是这个值），以获得 <strong>CPU时钟速率一半值的外设时钟</strong>。</li>\n<li>设定TB计数器模式。修改 <code>TBCTL</code> 寄存器下的 <code>CTRMODE</code> 为 <code>0x2</code> ，打开 TB counter 的增减计数模式。</li>\n<li>设定TB周期。修改 <code>TBPRD</code> 寄存器的值为十进制的 <code>1600</code> 。</li>\n</ol>\n<h4 id=\"公式总结\">公式总结</h4>\n<p><span class=\"math display\">\\[\nF_{TBCLK} = {F_{EPWMCLK} \\over HSPCLKDIV · CLKDIV} \\tag{PWM工作频率公式}\n\\]</span></p>\n<p><span class=\"math display\">\\[\nT_{EPWM} = (TBPRD +1) · T_{TBCLK} =  {(TBPRD +1) · HSPCLKDIV · CLKDIV \\over F_{EPWMCLK}} \\tag{单个ePWM波周期公式}\n\\]</span> 根据《TRM》P1888，<strong>HSPCLKDIV</strong> 的可取值范围是 <span class=\"math inline\">\\(\\{1,2,4,6,8,10,12,14\\}\\)</span> ，而 <strong>CLKDIV</strong> 的可取值范围是 <span class=\"math inline\">\\(\\{1,2,4,8,16,32,64,128\\}\\)</span>​ 。</p>\n<p>如果不修改 <strong>TBCTL</strong> 寄存器下的 <strong>HSPCLKDIV</strong> 和 <strong>CLKDIV</strong>，默认情况下这两个的乘积就是 <code>2</code>，而 <span class=\"math inline\">\\(F_{EPWMCLK} = 100MHz\\)</span> ，也就是最终 <span class=\"math inline\">\\(T_{EPWM}\\)</span> 的值完全由 <span class=\"math inline\">\\(T_{PRD}\\)</span> 来决定。已知 <strong>TBPRD</strong> 寄存器是16位寄存器， 取值范围是 <span class=\"math inline\">\\([0,65535]\\)</span> ，在本项目情况下，可以写成如下等式：</p>\n<p>此处需要注意，因为设定的ePWM使用 <strong>增减计数模式</strong>，<strong>TBPRD</strong> 值实际上是设定值的两倍。</p>\n<h2 id=\"死区时间设定\">死区时间设定</h2>\n<p>死区时间需要联系实际电路中的 <strong>IGBT</strong> 及其 <strong>驱动器</strong> 进行综合分析。</p>\n<h3 id=\"igbt特性\">IGBT特性</h3>\n<p>下表为温度范围在 [25℃, 175℃] 时，IGBT开关特性和二极管特性表。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210907200102300.png\" alt=\"image-20210907200102300\" /><figcaption aria-hidden=\"true\">image-20210907200102300</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210907200144294.png\" alt=\"image-20210907200144294\" /><figcaption aria-hidden=\"true\">image-20210907200144294</figcaption>\n</figure>\n<p>已知死区时间最高需要达到 <span class=\"math inline\">\\(145ns\\)</span>，而系统频率在100MHz时，<span class=\"math inline\">\\(T_{SYSCLK} = 10^{-8}s = 10ns\\)</span>​​​​，而外设 ePWM1 的工作频率为50MHz，<span class=\"math inline\">\\(T_{ePWM} = 20ns\\)</span>，也就是说，​​至少需要等待15个系统周期或 <span class=\"math inline\">\\([5.5,7.25]\\)</span> 个PWM工作周期。</p>\n<p>根据公式 $CMP = T_{HighLevel} / (T_{TBCLK} *2) $，已知所需</p>\n<h3 id=\"驱动器特性\">驱动器特性</h3>\n<p>IGBT 驱动器内部有个 <strong>内部死区时间</strong>（Internal Deadtime） <span class=\"math inline\">\\(t_{DT(internal)} = 100ns\\)</span></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210908141224008.png\" alt=\"image-20210908141224008\" /><figcaption aria-hidden=\"true\">image-20210908141224008</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210908142609386.png\" alt=\"image-20210908142609386\" /><figcaption aria-hidden=\"true\">image-20210908142609386</figcaption>\n</figure>\n<h3 id=\"死区计算\">死区计算</h3>\n<p>根据 <strong>死区时间计算公式</strong> <span class=\"math inline\">\\(t_{DT} = [ (t_{d(off),max} + t_{f,max}-t_{d(on),min}) + (t_{PHL,max} - t_{PLH, min})] · S\\)</span> ，代入计算​：</p>\n<ul>\n<li><span class=\"math inline\">\\(T_{vj} = 25℃\\)</span>​ 时， $t_{DT} = (417ns+16ns-45ns) + (270ns - ns) · 150% = $​​</li>\n</ul>\n<h1 id=\"数模转换开发\">数模转换开发</h1>\n<p>首先需要弄明白以下几个问题：</p>\n<ol type=\"1\">\n<li>ADC采样的信号有何种特征（ADCIN），此处所述为电气特性（电压、电流、频率等）</li>\n<li>ADC采样所需要的最小精度应该是多少，即ADC模块应该多久转换一次采样电容的电压值来转换成数值，ADC模块读取转换电容的最小周期应该是多少最合适</li>\n<li>CPU对数值的读取又是多久读取一次，每一次转换都读取还是间隔多次转换再读取（即，ADC采样触发的周期和数据读取的周期是分开配置的），可以配置为单次采样、超采样、多重采样 或 软触发采样。</li>\n</ol>\n<p>数模转换开发不同于ePWM配置开发，不仅信号输入和子模块配置方式上有许多不同点，最明显的不同是高频逆变器不需要使用到触发中断，但ADC模块不论是转换触发还是读取数值都需要中断来进行操作，即由外部中断脉冲输入ADC模块，促使ADC模块将电容电压依据参考电压转换为数值并存写到寄存器中，然后生成中断脉冲，触发中断程序来读取其中的数值。</p>\n<h2 id=\"工作流程-1\">工作流程</h2>\n<pre class=\"mermaid\">graph TB\n进入ADC中断 --> 读取ADC寄存器数值并存储至全局变量 --> 交由主循环计算电压/电流/温度值并判断是否安全 --> id1[定时器中断检查开关/安全] --是--> 保持PWM开启\nid1 --否--> 关闭PWM</pre>\n<h3 id=\"adc配置流程\">ADC配置流程</h3>\n<pre class=\"mermaid\">graph LR\n系统初始化 --> 使能ADC模块时钟 --> 配置模块参考电压 --> 配置模块时钟 --> 配置SOC通道 --> 配置采样周期 --> 配置采样触发源 --> 配置EOC中断触发源</pre>\n<h3 id=\"配置示例-1\">配置示例</h3>\n<p>ADC模块在功能描述上也有别于ePWM，ePWM采用许多子模块的描述方法，ADC则使用 <strong>通道</strong>（CHNL，或 channel）、<strong>SOC</strong>、<strong>EOC</strong>、<strong>INT</strong> 等描述词汇，需要区分理解，且ADC模块从顶自下参数都有许多配置限制，具体看前面的描述吧。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*-----------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 【函数】：void ADC_Init(void);</span></span><br><span class=\"line\"><span class=\"comment\"> * 【参数】：无</span></span><br><span class=\"line\"><span class=\"comment\"> * 【说明】：配置ADC模块的电压、时钟、脉冲生成时间和开关</span></span><br><span class=\"line\"><span class=\"comment\"> * 【其他】：以下所有配置项（电压、时钟、脉冲生成时间和开关）都是以模块（A</span></span><br><span class=\"line\"><span class=\"comment\"> *                      /B/C）为最小单位进行配置的，需要启动ADCB和ADCC则需要在此处</span></span><br><span class=\"line\"><span class=\"comment\"> *                      进行相似配置</span></span><br><span class=\"line\"><span class=\"comment\"> * 【参考】：</span></span><br><span class=\"line\"><span class=\"comment\">----------------------------------------------------------------------- */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ADC_Init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    SetVREF(ADC_ADCA, ADC_EXTERNAL, ADC_VREF2P5);  <span class=\"comment\">//为ADC A提供外部参考电压</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EALLOW;</span><br><span class=\"line\">    AdcaRegs.ADCCTL2.bit.PRESCALE = <span class=\"number\">0x02</span>;         <span class=\"comment\">//`0010`，ADCCLK = 输入时钟 / 2.0，即50MHz</span></span><br><span class=\"line\">    AdcaRegs.ADCCTL1.bit.INTPULSEPOS = <span class=\"number\">0x1</span>;    <span class=\"comment\">// 写1的话，在ADC转换完成时（ADC捕获窗口周期结束时）生成脉冲中断</span></span><br><span class=\"line\">                                               <span class=\"comment\">// 写0的话，就是在窗口周期结束时加上一组系统时钟周期后再生成中断，具体看《TRM》P1499</span></span><br><span class=\"line\">    AdcaRegs.ADCCTL1.bit.ADCPWDNZ = ON;     <span class=\"comment\">// 打开ADC A 的所有模拟电路</span></span><br><span class=\"line\">    EDIS;</span><br><span class=\"line\"></span><br><span class=\"line\">    DELAY_US(<span class=\"number\">1000</span>);  <span class=\"comment\">//延迟1ms</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 【函数】：void ADC_SOC_Init(void);</span></span><br><span class=\"line\"><span class=\"comment\"> * 【参数】：无</span></span><br><span class=\"line\"><span class=\"comment\"> * 【说明】：配置ADC模块下的SOC，设置通道和中断相关内容</span></span><br><span class=\"line\"><span class=\"comment\"> * 【其他】：ADCINTSEL1N2寄存器是设置中断源相关的，</span></span><br><span class=\"line\"><span class=\"comment\"> * 【参考】：</span></span><br><span class=\"line\"><span class=\"comment\">----------------------------------------------------------------------- */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ADC_SOC_Init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    EALLOW;</span><br><span class=\"line\">    AdcaRegs.ADCSOC0CTL.bit.CHSEL = <span class=\"number\">0x1</span>;           <span class=\"comment\">// channel select，为SOC0选择通道ADCA1，可设置范围为0~F</span></span><br><span class=\"line\">    AdcaRegs.ADCSOC0CTL.bit.ACQPS = <span class=\"number\">0x1FF</span>;      <span class=\"comment\">// acquisition window, AW = (ACQPS+1) * SYSCLK，需要结合实际硬件设计进行计算，计算代码在文档中，1~511</span></span><br><span class=\"line\">    AdcaRegs.ADCSOC0CTL.bit.TRIGSEL = <span class=\"number\">0x0F</span>;      <span class=\"comment\">// trigger select，触发源选择为ePWM6，每一次ePWM</span></span><br><span class=\"line\">    AdcaRegs.ADCINTSEL1N2.bit.INT1SEL = <span class=\"number\">0x0</span>;     <span class=\"comment\">// 由EOC0来触发ADCA模块的第一个中断（INT1）</span></span><br><span class=\"line\">    AdcaRegs.ADCINTSEL1N2.bit.INT1E = ON;        <span class=\"comment\">// 打开ADCA模块的第一个中断（INT1）</span></span><br><span class=\"line\">                                                 <span class=\"comment\">// 此处没有设置ADC A的 中断生成模式（INT1CONT），默认为0x0，即手动清除中断标志时生成中断脉冲</span></span><br><span class=\"line\">    AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = <span class=\"number\">0x1</span>;   <span class=\"comment\">//  清除ADC中断1的标志</span></span><br><span class=\"line\">    EDIS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 【函数】：__interrupt void adcA1ISR(void);</span></span><br><span class=\"line\"><span class=\"comment\"> * 【参数】：无</span></span><br><span class=\"line\"><span class=\"comment\"> * 【说明】：ADC外设中断的处理程序</span></span><br><span class=\"line\"><span class=\"comment\"> * 【其他】：注意需要加 __interrupt 关键字，加了的话编译器会自动处理 保持和恢</span></span><br><span class=\"line\"><span class=\"comment\"> *                     复特定的CPU寄存器状态（如果需要）且在人为清除中断组PIEACK位</span></span><br><span class=\"line\"><span class=\"comment\"> *                     后会自动使用IRET指令来返回；如果不加，则保持和恢复工作 以及 返</span></span><br><span class=\"line\"><span class=\"comment\"> *                     回工作需要人为处理。</span></span><br><span class=\"line\"><span class=\"comment\"> * 【参考】：详见开发文档的处理中断部分，或《TRM》P85</span></span><br><span class=\"line\"><span class=\"comment\">----------------------------------------------------------------------- */</span></span><br><span class=\"line\"><span class=\"function\">__interrupt <span class=\"keyword\">void</span> <span class=\"title\">adcA1ISR</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    sampleResult = AdcaResultRegs.ADCRESULT0;</span><br><span class=\"line\"></span><br><span class=\"line\">    AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = <span class=\"number\">1</span>;   <span class=\"comment\">// ADCA模块上的第一个中断</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"number\">1</span> == AdcaRegs.ADCINTOVF.bit.ADCINT1)&#123;</span><br><span class=\"line\">        AdcaRegs.ADCINTOVFCLR.bit.ADCINT1 = <span class=\"number\">1</span>;  <span class=\"comment\">//清除中断溢出</span></span><br><span class=\"line\">        AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = <span class=\"number\">1</span>;   <span class=\"comment\">// ADCA模块上的第一个中断</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;    <span class=\"comment\">// 确认中断</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"转换修正\">转换修正</h3>\n<p>ADC为12bit分辨率的电压转换外设，下面为读取数值和特定量程之间的电压转换代码，可以通过宏定义来修改最高量程、参考电压最高值 和 单个引脚的偏差值</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>    ADCDATA_OFFSET   40   <span class=\"comment\">// ADC2通道的量程偏差</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>    VOLTAGE_RANGE   3.30   <span class=\"comment\">//电压量程3.3V</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>    ADC_RANGE  4096   <span class=\"comment\">//ADC量程4096</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 【函数】：float AdcVoltage(ADCDATA regData);</span></span><br><span class=\"line\"><span class=\"comment\"> * 【参数】：1. 瞬时读取的ADC寄存器的值 regData</span></span><br><span class=\"line\"><span class=\"comment\"> * 【说明】：将ADC寄存器结果的值转换为对应量程电压的处理程序</span></span><br><span class=\"line\"><span class=\"comment\"> * 【其他】：</span></span><br><span class=\"line\"><span class=\"comment\"> * 【参考】：</span></span><br><span class=\"line\"><span class=\"comment\">----------------------------------------------------------------------- */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">AdcVoltage</span><span class=\"params\">(ADCDATA regData)</span></span>&#123;</span><br><span class=\"line\">    ADCDATA tempData = <span class=\"number\">0</span>;    <span class=\"comment\">//初始化中转变量 tempData</span></span><br><span class=\"line\"></span><br><span class=\"line\">    tempData = regData + ADCDATA_OFFSET ;  <span class=\"comment\">//修正某个模拟端口的偏差值，偏差值可以人为修改（假设测试设备输出电压经过计量）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tempData &lt;= <span class=\"number\">0</span>) tempData = <span class=\"number\">0</span>;   <span class=\"comment\">//超量程偏差修正</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tempData &gt;=ADC_RANGE) tempData = ADC_RANGE;   <span class=\"comment\">//超量程偏差修正</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((<span class=\"keyword\">float</span>)tempData / ADC_RANGE * VOLTAGE_RANGE);   <span class=\"comment\">//转换成电压值，返回浮点数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"温度传感\">温度传感</h2>\n<p>通过热敏电阻和普通10KΩ电阻的串联，施以3.3V电压，并在两个电阻之间引出导线接入ADC，ADC通过检测电压数值来输出对应 电压值。</p>\n<p>由下方的热敏电阻 <strong>阻值特性表</strong> 可知，热敏电阻的温度升高和阻值之间并非线性关系。阻值偏差也在各温度间情况不同。</p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210820212823758.png\" alt=\"image-20210820212823758\" style=\"zoom:77%;\" /></p>\n<p style=\"text-align: center; color: gray; font-size: 0.8rem; font-style: italic;\">\n中间部分省略......\n</p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210820212605911.png\" alt=\"image-20210820212605911\" style=\"zoom:80%;\" /></p>\n<p style=\"text-align: center; color: gray; font-size: 0.8rem; font-style: italic;\">\n中间部分省略......\n</p>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210820212218560.png\" alt=\"image-20210820212218560\" style=\"zoom:105%;\" /></p>\n<h3 id=\"阻值与温度公式\">阻值与温度公式</h3>\n<p>已知热敏电阻的阻值和温度关系公式—— <strong>B常数求解公式</strong> ，如下式1： <span class=\"math display\">\\[\nB = {ln(R_{T1}) - ln(R_{T2})\\over {1 \\over {T_1}} -{ 1 \\over T_2}}\n\\]</span> 将阻值特性表中的目标温度 <code>110℃</code> <strong>安全限制温度</strong> 作为 $ T2 $​​​，其 <strong>热敏电阻值</strong>（均值） <code>2508Ω</code> 作为 $ R_{T2} <span class=\"math inline\">\\(​​​​，\\)</span> T_1 <span class=\"math inline\">\\(​​​ 则为 `25℃` ，\\)</span> R_{T1} $​​​​​​ （均值）为 <code>50000Ω</code>，代入进行计算，求得B常数为 <code>4021.84</code> 。</p>\n<p>将B常数作为已知参数，将式1进行变换获得可求解实时温度的公式2： <span class=\"math display\">\\[\nT_2 = {B · T_1 \\over {T_1· (ln(R_{T2}/R_{T1}) + B} }\n\\]</span> 注意，以上的 $ T_1 $ 和 $ T_2 $ 指的是在绝对零度的基础上，即 <code>25℃ + 273.15</code> 才是 $ T_1 $​​ ，目标温度在公式计算出来之后也需要减去 <code>273.15</code> 。</p>\n<h3 id=\"电压与阻值读数关系\">电压与阻值读数关系</h3>\n<p>已知ADC寄存器的度数结果为 $ ADC $​​​​，其读数最大值为 $ ADC_{MAX} $​​​​，对应的电压分别为 $ V_{ADC} $​​​​ 和 $ V_{REF} $​​​​ 。ADC模块的参考电压 <span class=\"math inline\">\\(V_{REF}\\)</span>​​ 并不会收到外接ADC电路的影响，该参数是由参考电压和内部定义进行设置的，此处可以看做恒常 <code>3.3V</code> 。 <span class=\"math display\">\\[\n{ADC \\over ADC_{MAX} } ={V_{ADC} \\over V_{REF}}\n\\]</span> 由 <strong>式3</strong> 可以变形成 <strong>式4</strong>，ADC是寄存器中容易读取的数值，公式变形如下： <span class=\"math display\">\\[\nV_{ADC} = {ADC · V_{REF} \\over {ADC_{MAX}}}\n\\]</span></p>\n<h3 id=\"adc外接电路电压关系\">ADC外接电路电压关系</h3>\n<p><img src=\"https://pic.islet.space/2021/08/image-20210821150320248.png\" alt=\"image-20210821150320248\" style=\"zoom:80%;\" /></p>\n<p>已知上方电路图中的<span class=\"math inline\">\\(R_{76}\\)</span>​​ 和 <span class=\"math inline\">\\(R_{78}\\)</span>​​​ 的阻值均为 <code>10KΩ</code> ，用 <span class=\"math inline\">\\(R\\)</span>​​​ 来表示，向ADC电路施加的 <code>3.3V</code> 电压用 <span class=\"math inline\">\\(V_{thermal}\\)</span>​​​ 来表示，此时，ADC电路内的电压公式如下： <span class=\"math display\">\\[\nV_{ADC} = {V_{thermal} \\over {R_{thermal} + R}} · R\n\\]</span> 联立 <strong>式4</strong> 和 <strong>式5</strong> ，可得热敏电阻的实时电阻计算公式如下： <span class=\"math display\">\\[\nR_{thermal} = {ADC_{MAX} · V_{thermal} · R \\over ADC · V_{REF}} -R\n\\]</span> 若电路设计时，确保此处 <span class=\"math inline\">\\(V_{thermal}\\)</span>​ 和 <span class=\"math inline\">\\(V_{REF}\\)</span>​​ 一致，进行公式简化得： <span class=\"math display\">\\[\nR_{thermal} = {ADC_{MAX} · 3.3 · R \\over ADC · 3.3} - R = {ADC_{MAX}·R \\over ADC} - R = {(ADC_{MAX}-ADC)·R \\over ADC} ={ (4095-ADC)·10000 \\over ADC}\n\\]</span> 热敏电阻的阻值实时求算公式与B常数、初始温度、初始阻值等无关，仅与外围电路的电阻 <span class=\"math inline\">\\(R\\)</span>​ 有关。</p>\n<h4 id=\"限温策略\">限温策略</h4>\n<p>有两种方法可以设定安全关断：</p>\n<ol type=\"1\">\n<li>不要求计算B系数，但是只需要设置对应的安全温度阻值即可。即 <strong>式7</strong> 所示，当 <span class=\"math inline\">\\(R_{thermal}\\)</span>​​​ 小于安全温度阻值时，即触发中断。</li>\n<li>设置其安全温度，在上方步骤1 的基础联立公式2进一步求解，计算量会增加，而且并不是非常准确的。</li>\n</ol>\n<h2 id=\"数值转换程序\">数值转换程序</h2>\n<p>宏定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下方为ADC读值配置相关宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>    ADCDATA_OFFSET   40   <span class=\"comment\">// ADC2通道的量程偏差</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>    ADC_RANGE  4096   <span class=\"comment\">//ADC量程4096</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下方为热敏电阻电路相关宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>    TEMPERATURE_RANGE    110  <span class=\"comment\">//温度量程180（摄氏度）</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>    VOLTAGE_RANGE   3.30   <span class=\"comment\">//电压量程3.3V</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>    THM_ABSTEMP    273.15</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>    THM_BCONST    4021.84  <span class=\"comment\">//根据阻值特性表和公式确定的，在T2 = 110摄氏度时的拟合B常数</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>    THM_T1    (25.0+THM_ABSTEMP)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>    THM_RT1    50000.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>    THM_R_SAFE    2550    <span class=\"comment\">//确定安全温度对应的拟合公式内的RT2为2.55KΩ</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>    THM_R    10000.0  <span class=\"comment\">//设置外接ADC电路的电阻值（10KΩ，需转换成Ω）</span></span></span><br></pre></td></tr></table></figure>\n<p>电压转换：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*-----------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 【函数】：ADC_RESULTDATA AdcVoltage(ADCDATA);</span></span><br><span class=\"line\"><span class=\"comment\"> * 【参数】：1. 瞬时读取的ADC寄存器的值 regData</span></span><br><span class=\"line\"><span class=\"comment\"> * 【说明】：将ADC寄存器结果的值转换为对应量程电压的处理程序</span></span><br><span class=\"line\"><span class=\"comment\"> * 【其他】：对应的12bit量程、参考电压和偏差值可以在本文件前方的宏定义处修改</span></span><br><span class=\"line\"><span class=\"comment\"> * 【参考】：</span></span><br><span class=\"line\"><span class=\"comment\">----------------------------------------------------------------------- */</span></span><br><span class=\"line\"><span class=\"function\">ADC_RESULTDATA <span class=\"title\">AdcVoltage</span><span class=\"params\">(ADCDATA regData)</span></span>&#123;</span><br><span class=\"line\">    ADCDATA tempData = <span class=\"number\">0</span>;    <span class=\"comment\">//初始化中转变量 tempData</span></span><br><span class=\"line\"></span><br><span class=\"line\">    tempData = regData + ADCDATA_OFFSET ;  <span class=\"comment\">//修正某个模拟端口的偏差值，偏差值可以人为修改（假设测试设备输出电压经过计量）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tempData &lt;= <span class=\"number\">0</span>) tempData = <span class=\"number\">0</span>;   <span class=\"comment\">//超量程偏差修正</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tempData &gt;=ADC_RANGE) tempData = ADC_RANGE;   <span class=\"comment\">//超量程偏差修正</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((<span class=\"keyword\">float</span>)tempData / ADC_RANGE * VOLTAGE_RANGE);   <span class=\"comment\">//转换成电压值，返回浮点数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>阻值转换：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*-----------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 【函数】：ADC_RESULTDATA AdcTemperature(ADCDATA);</span></span><br><span class=\"line\"><span class=\"comment\"> * 【参数】：1. 瞬时读取的ADC寄存器的值 regData</span></span><br><span class=\"line\"><span class=\"comment\"> * 【说明】：将ADC寄存器结果的值转换为对应量程温度的处理程序</span></span><br><span class=\"line\"><span class=\"comment\"> * 【其他】：函数中使用到的T1、RT1、BCONST等参数均可以在本文件前方的宏定</span></span><br><span class=\"line\"><span class=\"comment\"> *         义处找到</span></span><br><span class=\"line\"><span class=\"comment\"> * 【参考】：《F280041PM开发文档》下的温度传感</span></span><br><span class=\"line\"><span class=\"comment\">----------------------------------------------------------------------- */</span></span><br><span class=\"line\"><span class=\"function\">ADC_RESULTDATA <span class=\"title\">AdcTemperature</span><span class=\"params\">(ADCDATA regData)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ( (THM_BCONST * THM_T1)  /  (THM_T1 * <span class=\"built_in\">log</span>( AdcResistance(regData)  /THM_RT1 )  + THM_BCONST) ) - THM_ABSTEMP;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>温度转换：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*-----------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 【函数】：ADC_RESULTDATA AdcTemperature(ADCDATA);</span></span><br><span class=\"line\"><span class=\"comment\"> * 【参数】：1. 瞬时读取的ADC寄存器的值 regData</span></span><br><span class=\"line\"><span class=\"comment\"> * 【说明】：将ADC寄存器结果的值转换为对应量程温度的处理程序</span></span><br><span class=\"line\"><span class=\"comment\"> * 【其他】：函数中使用到的T1、RT1、BCONST等参数均可以在本文件前方的宏定</span></span><br><span class=\"line\"><span class=\"comment\"> *         义处找到</span></span><br><span class=\"line\"><span class=\"comment\"> * 【参考】：《F280041PM开发文档》下的温度传感</span></span><br><span class=\"line\"><span class=\"comment\">----------------------------------------------------------------------- */</span></span><br><span class=\"line\"><span class=\"function\">ADC_RESULTDATA <span class=\"title\">AdcTemperature</span><span class=\"params\">(ADCDATA regData)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ( (THM_BCONST * THM_T1)  /  (THM_T1 * <span class=\"built_in\">log</span>( AdcResistance(regData)  /THM_RT1 )  + THM_BCONST) ) - THM_ABSTEMP;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"谐振检测开发\">谐振检测开发</h1>\n<p><strong>开发目标</strong>：实现对 <strong>PWM边沿</strong> 和 <strong>IGBT分压电流过零点</strong> 的相位时间差 <em>δt</em> 的检测，已达到是否达到谐振。</p>\n<h2 id=\"工作流程-2\">工作流程</h2>\n<pre class=\"mermaid\">graph TB\n系统初始化 --> 使能ECAP模块时钟</pre>\n<h1 id=\"项目flash烧录\">项目FLASH烧录</h1>\n<p>项目Flash烧录即将代码从Debug模式变成Release模式，将代码的存放区域从RAM变成FLASH。需要在项目属性中修改原有的Release配置，或者复制原有的调试模式进行部分修改。</p>\n<p>在前方已经调试好项目的情况下，FLASH模式较调试时使用DEBUG模式需要增加以下内容或步骤：</p>\n<ul>\n<li>FLASH需要添加指定的标志（Symbol）</li>\n<li>FLASH需要更换指定的 <code>.cmd</code> 内存文件</li>\n<li>FLASH需要添加指定的命令行模式（Command-Line pattern）</li>\n</ul>\n<h2 id=\"新增配置\">新增配置</h2>\n<ol type=\"1\">\n<li>点击 <strong>项目属性</strong>（Properties），选择 <strong>编译器</strong>（C2000 Compiler），选择 <strong>管理配置</strong>（Manage Configurations）</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210830113307673.png\" alt=\"image-20210830113307673\" /><figcaption aria-hidden=\"true\">image-20210830113307673</figcaption>\n</figure>\n<ol start=\"2\" type=\"1\">\n<li>选择 <strong>新建</strong>（New），然后在配置页面下填写新建的配置信息，选择需要基于哪个现有的配置项进行改动。在原有的调试模式上进行更改即可，这样头文件包含路径那些的就不用替换。</li>\n</ol>\n<div style=\"text-align: center;\">\n<p><img src=\"https://pic.islet.space/2021/08/image-20210830113400752.png\" alt=\"image-20210830113400752\" style=\"zoom:100%;\" /> <img src=\"https://pic.islet.space/2021/08/image-20210830113441976.png\" alt=\"image-20210830113441976\" style=\"zoom:100%;\" />&lt;/</p>\n<ol start=\"3\" type=\"1\">\n<li>将新建的配置项设置为 <strong>活跃</strong>（Active）。</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210830113559386.png\" alt=\"image-20210830113559386\" /><figcaption aria-hidden=\"true\">image-20210830113559386</figcaption>\n</figure>\n<h2 id=\"增加标志\">增加标志</h2>\n<p>向 <strong>预定义标志</strong>（Predefined Symbols）添加两个标志名称： <code>CPU1</code> 和 <code>_FLASH</code> 。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210830113650241.png\" alt=\"image-20210830113650241\" /><figcaption aria-hidden=\"true\">image-20210830113650241</figcaption>\n</figure>\n<p>添加成功时可以看到对应标志下的预编译被打开了，如下示：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210830113803514.png\" alt=\"image-20210830113803514\" /><figcaption aria-hidden=\"true\">image-20210830113803514</figcaption>\n</figure>\n<h2 id=\"增加命令行模式\">增加命令行模式</h2>\n<p>选择 <strong>编译器</strong>（C2000 Compiler），并在下方添加<code>$&#123;output_flags&#125; $&#123;output&#125;</code>，修改过后则变成了 <code>$&#123;command&#125; $&#123;flags&#125; $&#123;output_flags&#125; $&#123;output&#125; $&#123;inputs&#125;</code> 。如果只需要使用到调试模式（debug mode），就只需要原来的 <code>$&#123;command&#125; $&#123;flags&#125; $&#123;inputs&#125;</code> 即可。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210830133549942.png\" alt=\"image-20210830133549942\" /><figcaption aria-hidden=\"true\">image-20210830133549942</figcaption>\n</figure>\n<h2 id=\"更换内存文件\">更换内存文件</h2>\n<p>在 <code>D:\\ti\\CodeComposerStudio0930\\ccs\\ccs_base\\c2000\\include</code> 路径下查找到对应的 FLASH 内存文件，并在 <strong>通用页面</strong>（General）的 <strong>链接器命令文件</strong>（Linker command file）栏进行替换。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210830134720224.png\" alt=\"image-20210830134720224\" /><figcaption aria-hidden=\"true\">image-20210830134720224</figcaption>\n</figure>\n<h1 id=\"测试与优化\">测试与优化</h1>\n<p>硬件工作流程要求如下：</p>\n<pre class=\"mermaid\">graph LR\n开机 --> id1[待机模式] --检测到工作设备--> id2[工作模式] --检测到设备离开--> id1</pre>\n<h2 id=\"待机模式\">待机模式</h2>\n<p>开机后立即进入待机模式，对待机模式下的要求：</p>\n<ol type=\"1\">\n<li>IGBT此时并不开启，即PWM外设暂不开启。</li>\n<li>ADC外设需要时刻检测外面温度、电压和电流</li>\n</ol>\n<p>开机启动流程：</p>\n<pre class=\"mermaid\">graph\nid1([开机启动]) --> id2[系统初始化/开启各外设时钟] --> 各外设寄存器清空并初始化 --> id3 --是--> id4([进入待机模式])</pre>\n<p>待机工作流程：</p>\n<pre class=\"mermaid\">flowchart\nid[定时器1启动]</pre>\n<p>为了达到 <span class=\"math inline\">\\(4\\mu s\\)</span>​​ 的脉冲电路，需要设置<code>CMPA = 100</code> ，在 <code>TBCTR = 100</code> 且 <code>TBCTR DIRECTION = UP</code> 时</p>\n<ol type=\"1\">\n<li>能通过直接关闭外设时钟来关闭外设吗？会否清除寄存器相关设置？重新启动时是否有延时？</li>\n<li>读取GPIO 电平高低的状态寄存器，由其电平状态高低来确定外接硬开关是否按下，</li>\n</ol>\n<h3 id=\"工作设备检测\">工作设备检测</h3>\n<p>待机模式下IGBT并不工作，但仍需要对周围的设备进行检波和识别，检波方法：</p>\n<ol type=\"1\">\n<li>每间隔几秒，PWM发射高电平时长为 <span class=\"math inline\">\\(4\\mu s\\)</span> 的脉冲；</li>\n<li>由eCAP外设检测震荡过零的周期，以判断工作设备是否存在。</li>\n</ol>\n<p><strong>注意</strong>：过零检测时两个波形的过零允差需要在一定数值范围内，这个数值范围待测定。</p>\n<p>若在工作设备检测下，检测到设备存在，则进入工作模式，否则维持待机模式，持续进行工作设备的检测。</p>\n<p>已知PWM工作频率公式 和 单个ePWM波周期公式，可求得单个ePWM波的周期最大为： <span class=\"math display\">\\[\nT_{ePWM\\ Max} = (TBPRD_{MAX} +1) · T_{TBCLK} = (65535*2+1) · 0.00000002 = 2.6214 ms \\tag{单ePWM最大周期计算}\n\\]</span> 已知： <span class=\"math display\">\\[\nT_{TBCLK}={1s \\over 50MHz} = {1 \\over 50,000,000} = 2^{-8}s = 20ns\\tag{系统时钟周期}\n\\]</span> 时间单位： <span class=\"math display\">\\[\n1s = 10^{3}ms = 10^{6}\\mu s=10^9ns \\tag{时间单位}\n\\]</span> 反过来，如果已知高电平工作时长，需要求其CMP值，也可以代入 <span class=\"math inline\">\\(T_{TBCLK}\\)</span>​​ ，求得上下边的 <strong>CMP</strong> 值应为100 <span class=\"math display\">\\[\nCMP = T_{HighLevel} / (T_{TBCLK} *2) = 4*10^{-6}s/(2*2*10^{-8}s) = 100\n\\tag{已知高电平时长求CMP值}\n\\]</span></p>\n<h2 id=\"工作模式\">工作模式</h2>\n<p>进入工作模式后，按照预设好的多个工作条件（PWM工作频率、占空比）进行（手动/自动）切换，以调节设备工作功率。</p>\n<p><strong>注意</strong>：不论如何，占空比一定不能超过 50%。</p>\n<h1 id=\"rs485通信开发\">RS485通信开发</h1>\n<p>编码工作由F280041芯片的SCI外设负责，需要在对应的代码中设置好一些参数（数据长度、校验位、停止位等），可以使用CH340芯片的串口助手进行读写测试。</p>\n<p>全部的设置工作如下：</p>\n<ol type=\"1\">\n<li>对应GPIO的设置</li>\n<li>SCI的FIFO设置</li>\n<li>SCI传输编码格式的设置</li>\n<li>使用中断或者主程序对数据进行接收和解读</li>\n</ol>\n<h2 id=\"工作流程-3\">工作流程</h2>\n<pre class=\"mermaid\">graph TB\n系统初始化 --> 使能SCI通信模块时钟 --> 配置LSP时钟分频 --> 配置SCI模块 --> 使用中断或主程序接收处理上位机指令</pre>\n<h3 id=\"sci配置流程\">SCI配置流程</h3>\n<pre class=\"mermaid\">graph LR\n配置SCIFIFO模块 --> 初始化SCI相关寄存器 --> 配置SCI相关寄存器</pre>\n<p>配置SCI相关寄存器需要设置到以下几个参数位：</p>\n<ul>\n<li>单次通信传递字符数量 <code>SCICHAR</code></li>\n<li>通信模式 <code>ADDRIDLE_MODE</code></li>\n<li>数据校验位信息（校验使能 <code>PARITYENA</code> 、校验方式 <code>PARITY</code> ）</li>\n<li>停止位信息 <code>STOPBITS</code></li>\n<li>通信使能 （ 发送端使能 <code>TXENA</code>、接收端使能 <code>RXENA</code>）</li>\n<li>睡眠模式 <code>SLEEP</code></li>\n<li>中断使能（接收错误中断使能 <code>RXERRINTENA</code> 、接收brk中断使能 <code>RXBKINTENA</code> 、传输中断使能 <code>TXINTENA</code>）</li>\n<li>波特率 <code>SCIHBAUD</code> 和 <code>SCILBAUD</code></li>\n</ul>\n<h2 id=\"pc-usb-ttl-f280041\">PC-USB-TTL-F280041</h2>\n<p>PC端使用CH340芯片的USB-TTL 转换器与芯片主板的 <code>RX</code> 口 和 <code>TX</code> 口直接通信，通信期间，PC端需要和发送端保持相同的设置，包括波特率、停止位大小、数据位、奇偶校验是否开启（开启的话为奇校验还是偶校验）等均需要保持一致。如下所示，左侧为上位机设置，右侧为SCI通信的设置。</p>\n<p><mark style=\"font-weight: 900;\">注意：测试设备端口上的 <code>RX</code> <code>TX</code> 端口要和 <code>TX</code> <code>RX</code> 相反连接，且需要共地。</mark></p>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/09/image-20210914111856207.png\" alt=\"image-20210914111856207\" style=\"zoom:120%;\" /><img src=\"https://pic.islet.space/2021/09/image-20210914132833272.png\" alt=\"image-20210914132833272\" style=\"zoom:80%;\" />\n</div>\n<p>下图为SCI_ECHOBACK功能效果演示：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210914132731428.png\" alt=\"image-20210914132731428\" /><figcaption aria-hidden=\"true\">image-20210914132731428</figcaption>\n</figure>\n<p>如下所示，校验位设置错误时，数据乱码。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/image-20210914133403477.png\" alt=\"image-20210914133403477\" /><figcaption aria-hidden=\"true\">image-20210914133403477</figcaption>\n</figure>\n<h2 id=\"pc-rs232-rs485-ttl-f280041\">PC-RS232-RS485-TTL-F280041</h2>\n<p>商用台式电脑主机主板背部自带DB9接口（RS232），使用RS232转RS485的转换器进行连接，然后使用双绞线连接被控设备对应的接口。需要注意的是，转换器上的RS485电路不具备供电接口， <code>VCC</code> / <code>GND</code> 同样需要进行连接，且需要由电气的隔离电路提供。</p>\n<p>转换器与被控设备的引脚连接方式为：<code>T/R-</code> 连接 <code>IC_COM_MAX487EEPPA</code> 芯片上的 <code>B</code> 口；<code>T/R+</code> 连接 <code>IC_COM_MAX487EEPPA</code> 芯片上的 <code>A</code> 口；其中 <code>A</code> / <code>B</code> 口更多地被称为 <code>A+</code> / <code>B-</code> 口。</p>\n<p>连接成功后，使用串口通信助手进行测试，并查看寄存器结果，看出数据传输成功。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/20210915170027.png\" alt=\"image-20210915165949131\" /><figcaption aria-hidden=\"true\">image-20210915165949131</figcaption>\n</figure>\n<p>使用RS485的优势是，RS232/RS485转换器间存在电气隔离，RS485和TTL之间也存在电气隔离，一旦被控设备发生浪涌，不会损坏PC机。</p>\n<h2 id=\"通信控制\">通信控制</h2>\n<p>通信控制相关流程如下：</p>\n<pre class=\"mermaid\">graph \nid1[等待上位机数据] --> 收到通信数据 --> id2{判断FLAG对应的位是否使能} --是--> 修改对应的数据 --> 结束\nid2 --否--> id1</pre>\n<p>传输时，需要注意对应的数据是否为 <code>16bit</code> 或 <code>8bit</code> ，如PWM周期值为 <code>16bit</code> 寄存器，而传输过程需要使用 <code>8bit</code> 的 <code>unsigned char</code> 字符进行传输，则需要下位机对收到的字符进行位移和按位或运算。</p>\n<p><strong>通信格式约定如下</strong>：</p>\n<ol type=\"1\">\n<li>第一个字符，即 <code>char0</code> 是 标志位之用 <code>flag</code>，将字符转换成二进制即为对应数据的修改使能控制，所有对数据的修改首先要求标志位（flag）对应位为1时才激活，如下表所示；</li>\n<li>后续每两个或一个的char数据需要合成为对应的 <code>unit16_t</code> 数据；</li>\n<li>通信传输时，需要使用16进制数据进行发送；</li>\n<li>修改时会暂时关断PWM外设，修改完毕再开启。</li>\n</ol>\n<div style=\"font-weight: 900; font-size: 0.8rem; text-align: center;\">\n表 通信协议中第0个字符的位说明\n</div>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/20210924170147.png\" alt=\"image-20210923143745959\" /><figcaption aria-hidden=\"true\">image-20210923143745959</figcaption>\n</figure>\n<div style=\"font-weight: 900; font-size: 0.8rem; text-align: center;\">\n表 通信协议各字符说明\n</div>\n<figure>\n<img src=\"https://pic.islet.space/2021/09/20210924170150.png\" alt=\"image-20210923143648999\" /><figcaption aria-hidden=\"true\">image-20210923143648999</figcaption>\n</figure>\n<p>8位数据合成为16位数据函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*-----------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 【函数】：uint16_t uchar2ushort(unsigned char, unsigned char);</span></span><br><span class=\"line\"><span class=\"comment\"> * 【参数】：1. 高8位数据 high8bit</span></span><br><span class=\"line\"><span class=\"comment\"> *         2. 低8位数据 low8bit</span></span><br><span class=\"line\"><span class=\"comment\"> * 【说明】：将两个非负整形8bit数拼成非负整形16bit数</span></span><br><span class=\"line\"><span class=\"comment\"> * 【其他】：</span></span><br><span class=\"line\"><span class=\"comment\"> * 【参考】：</span></span><br><span class=\"line\"><span class=\"comment\">----------------------------------------------------------------------- */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uint16_t</span> <span class=\"title\">uchar2ushort</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> high8bit, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> low8bit)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ( (high8bit &lt;&lt; <span class=\"number\">8</span>) | low8bit);  <span class=\"comment\">//先左移8位然后进行按位或运算</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"通信调试参数计算方法\">通信调试参数计算方法</h2>\n<ol type=\"1\">\n<li>死区时间计算</li>\n</ol>\n<p>从《TRM》P1814 中可知，（上升沿或下降沿的）死区时间大小都其自身的 <strong>寄存器设定值</strong>，以及 <span class=\"math inline\">\\(T_{TBCLK}\\)</span> 有关，关系公式如下： <span class=\"math display\">\\[\n\\notag\nFED = DBFED · T_{TBCLK}\\\\\nRED = DBRED · T_{TBCLK}\n\\]</span></p>\n<ol start=\"2\" type=\"1\">\n<li>TBPRD寄存器值计算</li>\n</ol>\n<p>如果要改变 <span class=\"math inline\">\\(f_{EPWM}\\)</span> 的值，则需要改变 <strong>TBPRD</strong> 的值，因为 <span class=\"math inline\">\\(T_{TBCLK}\\)</span> 的值暂时不支持改变（因为涉及到两三个参数，太麻烦了，不想写代码），因此 <strong>TBPRD</strong> 和 <span class=\"math inline\">\\(f_{EPWM}\\)</span> 的关系为： <span class=\"math display\">\\[ {align*}\nTBPRD&amp;=&amp;\\frac{1}{2}(\\frac{T_{EPWM}}{T_{TBCLK}}-1)\\\\ \n&amp;=&amp;\\frac{1}{2}(\\frac{1}{T_{TBCLK}·F_{EPWM}}-1) \\nonumber\n\\]</span></p>\n<blockquote>\n<p>所有计算单位都是 <code>Hz</code> 和 <code>s</code> z。</p>\n<p>因为 <code>HSPCLKDIV=0x00, CLKDIV=0x01</code>，，<span class=\"math inline\">\\(F_{TBCLK} = F_{SYSCLK} /2 = 50MHz\\)</span> ，得 <span class=\"math inline\">\\(T_{TBCLK} = 2*10^{-8}s\\)</span> 。</p>\n<p><span class=\"math inline\">\\(T_{EPWM} = 3.33*10^{-5}s\\)</span> 时，其 <span class=\"math inline\">\\(TBPRD = 1/2 · (3.33*10^{-5} / 2*10^{-8} -1) = 832\\)</span></p>\n<p>当已知需要设置 epwm的目标频率为 <code>30Khz</code> 时，只需要代入公式即可： <span class=\"math display\">\\[\n\\notag\nTBPRD = 1/2 * (\\frac{1}{2e-8*3e4} -1)\n\\]</span></p>\n</blockquote>\n<ol start=\"3\" type=\"1\">\n<li>占空比计算</li>\n</ol>\n<p><mark style=\"font-weight: 900;\">占空比，实际上就是EPWM 在整个周期内部，高电平时长与周期长度的比值。</mark></p>\n<p>占空比如果通过寄存器值来进行表达和设置，会出现误差，因为死区时间的寄存器值工作逻辑和原先设置的ePWM工作逻辑存在差异，存在错误的占空比关系公式： <span class=\"math display\">\\[\nDuty \\ Cycle &amp;=&amp; \\frac{(TBPRD-CMP)·2-DB·2}{TBPRD·2}\\\\\n&amp;=&amp; \\frac{(TBPRD-CMP)-DB}{TBPRD}\n\\nonumber\n\\]</span></p>\n<p>正确的方法就是去计算高电平的时长，然后除以整个任务周期时长： <span class=\"math display\">\\[\nDuty \\ Cycle = \\frac {T_{High \\ Level}}{T_{EPWM}}\n\\notag\n\\]</span> 在C++编写的RS485指令的代码中，则通过人为设定占空比来反向计算高电平时长。</p>\n<p>在已知 死区时间 <strong>DBxED</strong> 寄存器数值、 <strong>TBPRD</strong> 周期寄存器数值 和 任务占空比 三个参数的情况下，目前使用的计算 CMP数值的算法如下： <span class=\"math display\">\\[\nCMP = (1- Duty)·(TBPRD-DB)\n\\tag{CMP-A1}\n\\]</span></p>\n<h2 id=\"通信调试数据\">通信调试数据</h2>\n<p>在使用上方 CMP-A1 算法公式的情况下，输入目标频率、死区时间 和 所要求的占空比大小，以获得RS485通信指令，如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211011172645.png\" alt=\"image-20211009103727624\" /><figcaption aria-hidden=\"true\">image-20211009103727624</figcaption>\n</figure>\n<p>通信数据收到无误后会返回确认和执行字样：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211011172650.png\" alt=\"image-20211009103755175\" /><figcaption aria-hidden=\"true\">image-20211009103755175</figcaption>\n</figure>\n<p>测试结果：</p>\n<p><code>30 50 2.4</code></p>\n<p><code>AB1F034001640164007700770050</code></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211011172638.png\" alt=\"image-20211009102908175\" /><figcaption aria-hidden=\"true\">image-20211009102908175</figcaption>\n</figure>\n<p><code>30 50 1.0</code></p>\n<p><code>AB1F034001870187003200320050</code></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211011172636.png\" alt=\"image-20211009103114948\" /><figcaption aria-hidden=\"true\">image-20211009103114948</figcaption>\n</figure>\n<p><code>30 45 1.0</code></p>\n<p><code>AB1F034001AE01AE003200320050</code></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211011172634.png\" alt=\"image-20211009103933753\" /><figcaption aria-hidden=\"true\">image-20211009103933753</figcaption>\n</figure>\n<p><code>30 45 2.4</code></p>\n<p><code>AB1F034001880188007700770050</code></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211011172632.png\" alt=\"image-20211009104103063\" /><figcaption aria-hidden=\"true\">image-20211009104103063</figcaption>\n</figure>\n<p>开机默认波形如下：</p>\n<p><code>30 30 5</code></p>\n<p><code>AB1F03400198019800F900F90050</code></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211011172628.png\" alt=\"image-20211009110443081\" /><figcaption aria-hidden=\"true\">image-20211009110443081</figcaption>\n</figure>\n<h3 id=\"年10月11日更新信息\">2021年10月11日更新信息</h3>\n<p>经过了三天的努力，终于在10月11日完成了基于C++的 terminal串口通信。哈哈哈哈哈，可以成功实现通信啦~~</p>\n<p>只要先在程序内选择指定接口，然后输入 <strong>目标工作频率</strong>、（下桥臂）<strong>任务占空比</strong> 和 （上桥臂）<strong>死区时间</strong> 就可以计算出指令并进行发送。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211011172910.png\" alt=\"image-20211011172325394\" /><figcaption aria-hidden=\"true\">image-20211011172325394</figcaption>\n</figure>\n<p>可以从逻辑分析仪获得较为粗糙的波形信息，如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211011172557.png\" alt=\"image-20211011172548527\" /><figcaption aria-hidden=\"true\">image-20211011172548527</figcaption>\n</figure>\n<h3 id=\"年10月13日更新信息\">2021年10月13日更新信息</h3>\n<p>之前输入任务占空比的时候，都是控制的EPWMB的任务占空比，每次输入 40%的任务占空比（死区时间为0）时，EPWMA的任务占空比都为 60%。再加上死区时间实际上是在已知EPWMB任务占空比的情况下去减小EPWMA的占空比的时间。经过简单的修改，可以实现输入目标任务占空比，可以实时控制EPWMA的实际占空比了，死区时间只对EPWMB有影响。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211013172224.png\" alt=\"image-20211013163229517\" /><figcaption aria-hidden=\"true\">image-20211013163229517</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211013172222.png\" alt=\"image-20211013163247274\" /><figcaption aria-hidden=\"true\">image-20211013163247274</figcaption>\n</figure>\n<h1 id=\"常见错误处理\">常见错误处理</h1>\n<h2 id=\"memory-range-has-already-been-specified\">#10263 MEMORY RANGE HAS ALREADY BEEN SPECIFIED</h2>\n<p><strong>错误提示</strong>：存储区域范围（Memory Range）重复声明。</p>\n<p><strong>解释</strong>：在两个 <code>.cmd</code> 文件中，对 memory 的 page0 下的存储范围重复声明。</p>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/07/image-20210720171745641.png\" alt=\"image-20210720171745641\" style=\"zoom:80%;\" /> <img src=\"https://pic.islet.space/2021/07/image-20210720171759718.png\" alt=\"image-20210720171759718\" style=\"zoom:80%;\" />\n</div>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;..&#x2F;28004x_RAM_afe031_lnk.cmd&quot;, line 7: error #10263: BEGIN memory range has already been specified</span><br><span class=\"line\">&quot;..&#x2F;28004x_RAM_afe031_lnk.cmd&quot;, line 7: error #10264: BEGIN memory range overlaps existing memory range BEGIN</span><br><span class=\"line\">&quot;..&#x2F;28004x_RAM_afe031_lnk.cmd&quot;, line 8: error #10263: RAMM0 memory range has already been specified</span><br><span class=\"line\">&quot;..&#x2F;28004x_RAM_afe031_lnk.cmd&quot;, line 8: error #10264: RAMM0 memory range overlaps existing memory range RAMM0</span><br><span class=\"line\">&quot;..&#x2F;28004x_RAM_afe031_lnk.cmd&quot;, line 9: error #10263: RAMLS0 memory range has already been specified</span><br><span class=\"line\">.....</span><br></pre></td></tr></table></figure>\n<p><strong>解决办法</strong>：删除、移动 <code>28004x_RAM_afe031_lnk.cmd</code> ，或更改其后缀名；确保在 <em>项目属性</em>（Properties）中的 <strong>连接器命令文件</strong>（Linker Command File）为正确的 <code>280041_RAM_lnk.cmd</code> 。</p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210720172450100.png\" alt=\"image-20210720172450100\" style=\"zoom:80%;\" /></p>\n<p><img src=\"https://pic.islet.space/2021/07/image-20210720172242634.png\" alt=\"image-20210720172242634\" style=\"zoom:80%;\" /></p>\n<h2 id=\"cannot-open-source-file\">#1965 CANNOT OPEN SOURCE FILE</h2>\n<p>无法找到指定头文件，报错如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;D:&#x2F;ti&#x2F;c2000Ware&#x2F;C2000Ware_2_01_00_00&#x2F;device_support&#x2F;f28004x&#x2F;common&#x2F;include&#x2F;F28x_Project.h&quot;, line 47: fatal error #1965: cannot open source file &quot;f28004x_device.h&quot;</span><br></pre></td></tr></table></figure>\n<p>可以借助本地搜索工具everything进行文件搜索，将缺失的头文件的绝对路径复制，并粘贴至 头文件设置 下的搜索路径中。上方的错误缺失 <code>f28004x_device.h</code> ，添加 <code>D:\\ti\\c2000Ware\\C2000Ware_2_01_00_00\\device_support\\f28004x\\headers\\include</code> 绝对路径以供搜索，即可解决。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210721104533304.png\" alt=\"image-20210721104533304\" /><figcaption aria-hidden=\"true\">image-20210721104533304</figcaption>\n</figure>\n<h2 id=\"d-unresolved-symbols-remain\">#10234-D UNRESOLVED SYMBOLS REMAIN</h2>\n<p>在将函数需要的头文件添加到项目后，进行 <em>build project</em> ，出现 “未能解决的标志存留” ，有2种可能原因：</p>\n<ol type=\"1\">\n<li>输出格式（Output Format）不正确。</li>\n<li>头文件缺少对应的 <code>.c</code> 文件。</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"> undefined        first referenced   </span><br><span class=\"line\">  symbol              <span class=\"keyword\">in</span> file        </span><br><span class=\"line\"> ---------        ----------------   </span><br><span class=\"line\"> _ClkCfgRegs      ./SystemControl.obj</span><br><span class=\"line\"> _CpuSysRegs      ./SystemControl.obj</span><br><span class=\"line\"> _Dcc0Regs        ./SystemControl.obj</span><br><span class=\"line\"> _DcsmBank0Z1Regs ./SystemControl.obj</span><br><span class=\"line\"> _DcsmBank0Z2Regs ./SystemControl.obj</span><br><span class=\"line\"> _F28x_usDelay    ./SystemControl.obj</span><br><span class=\"line\"> _Flash0CtrlRegs  ./SystemControl.obj</span><br><span class=\"line\"> _Flash0EccRegs   ./SystemControl.obj</span><br><span class=\"line\"> _WdRegs          ./SystemControl.obj</span><br><span class=\"line\"> </span><br><span class=\"line\">error <span class=\"comment\">#10234-D: unresolved symbols remain</span></span><br><span class=\"line\">error <span class=\"comment\">#10010: errors encountered during linking; &quot;F28004x_WPT.out&quot; not built</span></span><br><span class=\"line\"> </span><br><span class=\"line\">&gt;&gt; Compilation failure</span><br><span class=\"line\">makefile:143: recipe <span class=\"keyword\">for</span> target <span class=\"string\">&#x27;F28004x_WPT.out&#x27;</span> failed</span><br><span class=\"line\">makefile:139: recipe <span class=\"keyword\">for</span> target <span class=\"string\">&#x27;all&#x27;</span> failed</span><br><span class=\"line\">gmake[1]: *** [F28004x_WPT.out] Error 1</span><br><span class=\"line\">gmake: *** [all] Error 2</span><br><span class=\"line\"></span><br><span class=\"line\">**** Build Finished ****</span><br></pre></td></tr></table></figure>\n<p><strong>解决方法</strong>：</p>\n<p>排除第一种情况后，找到 未定义符号（undefined symbol）对应的头文件 <code>f28004x_device.h</code> 和 <code>f28004x_sysctrl.h</code> 所在的文件路径 <code>D:\\ti\\c2000Ware\\C2000Ware_2_01_00_00\\device_support\\f28004x\\headers\\include</code> ，注意到该头文件上一级有个 <code>source</code> 文件夹，存储着头文件对应的 <code>.c</code> 文件： <code>f28004x_globalvariabledefs.c</code> ，将该头文件以链接或复制的形式添加到项目文件中即可。</p>\n<p><strong>注意</strong>：大部分情况下，header files 都会有其对应的 <code>.c</code> 或 <code>.asm</code> 文件，需要去相同的目录下方寻找即可。</p>\n<div style=\"text-align: center;\">\n<img src=\"https://pic.islet.space/2021/07/image-20210727092820296.png\" alt=\"image-20210727092820296\" style=\"zoom:100%;\" /><img src=\"https://pic.islet.space/2021/07/image-20210727094440528.png\" alt=\"image-20210727094440528\" style=\"zoom:100%;\" />\n</div>\n<h2 id=\"sc_err_path_broken\">SC_ERR_PATH_BROKEN</h2>\n<p>在将评估板接到PC过程中，进行连接测试（Test Connection），报错如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">-----[Print the reset-command software log-file]-----------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">This utility has selected a 100- or 510-class product.</span><br><span class=\"line\">This utility will load the adapter <span class=\"string\">&#x27;jioxds110.dll&#x27;</span>.</span><br><span class=\"line\">The library build date was <span class=\"string\">&#x27;Nov 25 2019&#x27;</span>.</span><br><span class=\"line\">The library build time was <span class=\"string\">&#x27;16:55:29&#x27;</span>.</span><br><span class=\"line\">The library package version is <span class=\"string\">&#x27;8.4.0.00006&#x27;</span>.</span><br><span class=\"line\">The library component version is <span class=\"string\">&#x27;35.35.0.0&#x27;</span>.</span><br><span class=\"line\">The controller does not use a programmable FPGA.</span><br><span class=\"line\">The controller has a version number of <span class=\"string\">&#x27;5&#x27;</span> (0x00000005).</span><br><span class=\"line\">The controller has an insertion length of <span class=\"string\">&#x27;0&#x27;</span> (0x00000000).</span><br><span class=\"line\">This utility will attempt to reset the controller.</span><br><span class=\"line\">This utility has successfully reset the controller.</span><br><span class=\"line\"></span><br><span class=\"line\">-----[Print the reset-command hardware log-file]-----------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">The scan-path will be reset by toggling the JTAG TRST signal.</span><br><span class=\"line\">The controller is the XDS110 with USB interface.</span><br><span class=\"line\">The link from controller to target is direct (without cable).</span><br><span class=\"line\">The software is configured <span class=\"keyword\">for</span> XDS110 features.</span><br><span class=\"line\">The controller cannot monitor the value on the EMU[0] pin.</span><br><span class=\"line\">The controller cannot monitor the value on the EMU[1] pin.</span><br><span class=\"line\">The controller cannot control the timing on output pins.</span><br><span class=\"line\">The controller cannot control the timing on input pins.</span><br><span class=\"line\">The scan-path link-delay has been <span class=\"built_in\">set</span> to exactly <span class=\"string\">&#x27;0&#x27;</span> (0x0000).</span><br><span class=\"line\"></span><br><span class=\"line\">-----[An error has occurred and this utility has aborted]--------------------</span><br><span class=\"line\"></span><br><span class=\"line\">This error is generated by TI<span class=\"string\">&#x27;s USCIF driver or utilities.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">The value is &#x27;</span>-233<span class=\"string\">&#x27; (0xffffff17).</span></span><br><span class=\"line\"><span class=\"string\">The title is &#x27;</span>SC_ERR_PATH_BROKEN<span class=\"string\">&#x27;.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">The explanation is:</span></span><br><span class=\"line\"><span class=\"string\">The JTAG IR and DR scan-paths cannot circulate bits, they may be broken.</span></span><br><span class=\"line\"><span class=\"string\">An attempt to scan the JTAG scan-path has failed.</span></span><br><span class=\"line\"><span class=\"string\">The target&#x27;</span>s JTAG scan-path appears to be broken</span><br><span class=\"line\">with a stuck-at-ones or stuck-at-zero fault.</span><br><span class=\"line\"></span><br><span class=\"line\">[End: Texas Instruments XDS110 USB Debug Probe_0]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>因为本开发板设计上使用两线制，为 <em>cJTAG</em>，而默认情况下是标准的 JTAG，只需要 TCK 和 TMS 两个信号（官方文档的常见问答部分有说明）。</p>\n<p>在<code>.ccxml</code> 文件中进行修改，点击下方的 <em>Advanced</em>，然后选择 <code>cJTAG(1149.7)2-pin advance mode</code>，然后 <em>save</em> 保存即可。具体操作如下图：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210726155434636.png\" alt=\"image-20210726155434636\" /><figcaption aria-hidden=\"true\">image-20210726155434636</figcaption>\n</figure>\n<p>再次运行结果如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">-----[Print the reset-command software log-file]-----------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">This utility has selected a 100- or 510-class product.</span><br><span class=\"line\">This utility will load the adapter <span class=\"string\">&#x27;jioxds110.dll&#x27;</span>.</span><br><span class=\"line\">The library build date was <span class=\"string\">&#x27;Nov 25 2019&#x27;</span>.</span><br><span class=\"line\">The library build time was <span class=\"string\">&#x27;16:55:29&#x27;</span>.</span><br><span class=\"line\">The library package version is <span class=\"string\">&#x27;8.4.0.00006&#x27;</span>.</span><br><span class=\"line\">The library component version is <span class=\"string\">&#x27;35.35.0.0&#x27;</span>.</span><br><span class=\"line\">The controller does not use a programmable FPGA.</span><br><span class=\"line\">The controller has a version number of <span class=\"string\">&#x27;5&#x27;</span> (0x00000005).</span><br><span class=\"line\">The controller has an insertion length of <span class=\"string\">&#x27;0&#x27;</span> (0x00000000).</span><br><span class=\"line\">This utility will attempt to reset the controller.</span><br><span class=\"line\">This utility has successfully reset the controller.</span><br><span class=\"line\"></span><br><span class=\"line\">-----[Print the reset-command hardware log-file]-----------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">The scan-path will be reset by toggling the JTAG TRST signal.</span><br><span class=\"line\">The controller is the XDS110 with USB interface.</span><br><span class=\"line\">The link from controller to target is direct (without cable).</span><br><span class=\"line\">The software is configured <span class=\"keyword\">for</span> XDS110 features.</span><br><span class=\"line\">The controller cannot monitor the value on the EMU[0] pin.</span><br><span class=\"line\">The controller cannot monitor the value on the EMU[1] pin.</span><br><span class=\"line\">The controller cannot control the timing on output pins.</span><br><span class=\"line\">The controller cannot control the timing on input pins.</span><br><span class=\"line\">The scan-path link-delay has been <span class=\"built_in\">set</span> to exactly <span class=\"string\">&#x27;0&#x27;</span> (0x0000).</span><br><span class=\"line\"></span><br><span class=\"line\">-----[Perform the Integrity scan-test on the JTAG IR]------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">This <span class=\"built_in\">test</span> will use blocks of 64 32-bit words.</span><br><span class=\"line\">This <span class=\"built_in\">test</span> will be applied just once.</span><br><span class=\"line\"></span><br><span class=\"line\">Do a <span class=\"built_in\">test</span> using 0xFFFFFFFF.</span><br><span class=\"line\">Scan tests: 1, skipped: 0, failed: 0</span><br><span class=\"line\">Do a <span class=\"built_in\">test</span> using 0x00000000.</span><br><span class=\"line\">Scan tests: 2, skipped: 0, failed: 0</span><br><span class=\"line\">Do a <span class=\"built_in\">test</span> using 0xFE03E0E2.</span><br><span class=\"line\">Scan tests: 3, skipped: 0, failed: 0</span><br><span class=\"line\">Do a <span class=\"built_in\">test</span> using 0x01FC1F1D.</span><br><span class=\"line\">Scan tests: 4, skipped: 0, failed: 0</span><br><span class=\"line\">Do a <span class=\"built_in\">test</span> using 0x5533CCAA.</span><br><span class=\"line\">Scan tests: 5, skipped: 0, failed: 0</span><br><span class=\"line\">Do a <span class=\"built_in\">test</span> using 0xAACC3355.</span><br><span class=\"line\">Scan tests: 6, skipped: 0, failed: 0</span><br><span class=\"line\">All of the values were scanned correctly.</span><br><span class=\"line\"></span><br><span class=\"line\">The JTAG IR Integrity scan-test has succeeded.</span><br><span class=\"line\"></span><br><span class=\"line\">-----[Perform the Integrity scan-test on the JTAG DR]------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">This <span class=\"built_in\">test</span> will use blocks of 64 32-bit words.</span><br><span class=\"line\">This <span class=\"built_in\">test</span> will be applied just once.</span><br><span class=\"line\"></span><br><span class=\"line\">Do a <span class=\"built_in\">test</span> using 0xFFFFFFFF.</span><br><span class=\"line\">Scan tests: 1, skipped: 0, failed: 0</span><br><span class=\"line\">Do a <span class=\"built_in\">test</span> using 0x00000000.</span><br><span class=\"line\">Scan tests: 2, skipped: 0, failed: 0</span><br><span class=\"line\">Do a <span class=\"built_in\">test</span> using 0xFE03E0E2.</span><br><span class=\"line\">Scan tests: 3, skipped: 0, failed: 0</span><br><span class=\"line\">Do a <span class=\"built_in\">test</span> using 0x01FC1F1D.</span><br><span class=\"line\">Scan tests: 4, skipped: 0, failed: 0</span><br><span class=\"line\">Do a <span class=\"built_in\">test</span> using 0x5533CCAA.</span><br><span class=\"line\">Scan tests: 5, skipped: 0, failed: 0</span><br><span class=\"line\">Do a <span class=\"built_in\">test</span> using 0xAACC3355.</span><br><span class=\"line\">Scan tests: 6, skipped: 0, failed: 0</span><br><span class=\"line\">All of the values were scanned correctly.</span><br><span class=\"line\"></span><br><span class=\"line\">The JTAG DR Integrity scan-test has succeeded.</span><br><span class=\"line\"></span><br><span class=\"line\">[End: Texas Instruments XDS110 USB Debug Probe_0]</span><br></pre></td></tr></table></figure>\n<h2 id=\"时钟初始化错误\">时钟初始化错误</h2>\n<p>时钟初始化错误是可能新建文件后可能会出现的隐形错误，因为程序编译的时候不报错，只报 WARNING ，因此很难察觉。</p>\n<p>但是，能通过 Expression 界面输入寄存器名称，用以观察其是否被初始化，如下图示，为自建项目后初始化的寄存器数值，只运行第一步PLL初始化，可以观察到 <code>ClkCfgRegs</code> 并未被初始化。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210730170342194.png\" alt=\"image-20210730170342194\" /><figcaption aria-hidden=\"true\">image-20210730170342194</figcaption>\n</figure>\n<p>同样使用官方样例代码进行仅一步的PLL初始化操作，可以发现初始化成功。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210730170350083.png\" alt=\"image-20210730170350083\" /><figcaption aria-hidden=\"true\">image-20210730170350083</figcaption>\n</figure>\n<p>仔细对比和检查后发现，自建项目中缺少了几个，通过link方式或copy方式添加进来，再到项目属性下的 Symbol Management中，为输出模块添加代码入口点 <code>code_start</code> 即可。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210730171218213.png\" alt=\"image-20210730171218213\" /><figcaption aria-hidden=\"true\">image-20210730171218213</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210730171409142.png\" alt=\"image-20210730171409142\" /><figcaption aria-hidden=\"true\">image-20210730171409142</figcaption>\n</figure>\n<h2 id=\"target-must-be-connected\">TARGET MUST BE CONNECTED</h2>\n<p>使用JTAG调试器XDS100 V2连接至目标设备上时，如果出现下图所示的 “Disconnected: Unknown”，说明目标MCU/DSP没有正确识别。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210802160213827.png\" alt=\"image-20210802160213827\" /><figcaption aria-hidden=\"true\">image-20210802160213827</figcaption>\n</figure>\n<p>首先应检查JTAG是否链接正常，打开“设备管理器”进行查看，如果设备连接器中出现了该JTAG设备，则进一步查看项目文件下的<code>.cxxm</code>l文件，该文件用于配置设备连接信息，包括芯片信号、JTAG调试器信号、通信方式、通信速率等。确保所有设置都正确以后进行全面断电、断开连接、重启CCS并重新尝试Debug，如果仍旧出现问题，请按以下步骤进行操作。</p>\n<p>在Debug界面，点击目标CPU，点击 <code>Connect Target</code> 进行手动连接。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210802160242203.png\" alt=\"image-20210802160242203\" /><figcaption aria-hidden=\"true\">image-20210802160242203</figcaption>\n</figure>\n<p>连接正确后，手动导入 <code>Build</code> 完之后的 <code>.out</code> 文件，将该程序手动烧写至CPU的RAM/Flash中</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210802160456548.png\" alt=\"image-20210802160456548\" /><figcaption aria-hidden=\"true\">image-20210802160456548</figcaption>\n</figure>\n<p>选择对应项目下生成的 <code>.out</code> 文件：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210802160358841.png\" alt=\"image-20210802160358841\" /><figcaption aria-hidden=\"true\">image-20210802160358841</figcaption>\n</figure>\n<p>可以在Console台（界面）观察到已经写入和初始化成功：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210802154136487.png\" alt=\"image-20210802154136487\" /><figcaption aria-hidden=\"true\">image-20210802154136487</figcaption>\n</figure>\n<h2 id=\"invalid-combination-of-type-specifiers\">#85 INVALID COMBINATION OF TYPE SPECIFIERS</h2>\n<p>出现以上错误时，我正打算新建函数，但是写到一半忘了，去忙别的，回头编译就出错了。找到最近的修改痕迹，然后果然发现自己只写了一个函数数据类型的声明，其他啥都没写，将其删除即可重新编译。</p>\n<h1 id=\"常见警告处理\">常见警告处理</h1>\n<h2 id=\"object-file-specified-but-linking-not-enabled\">Object file specified, but linking not enabled</h2>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210830135156509.png\" alt=\"image-20210830135156509\" /><figcaption aria-hidden=\"true\">image-20210830135156509</figcaption>\n</figure>\n<h1 id=\"常见优化提示\">常见优化提示</h1>\n<h2 id=\"d-performance-use---fp_moderelaxed-to-enable-tmu-hardware-support-for-fp-division\">#2614-D (Performance) Use --fp_mode=relaxed to enable TMU hardware support for FP division</h2>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210817085055902.png\" alt=\"image-20210817085055902\" /><figcaption aria-hidden=\"true\">image-20210817085055902</figcaption>\n</figure>\n<p>上述提示标志为 <code>i</code> ，也就是有关于性能优化的提示，可以在项目属性的编译器中，打开对应的优化开关，如下图。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/08/image-20210817085234005.png\" alt=\"image-20210817085234005\" /><figcaption aria-hidden=\"true\">image-20210817085234005</figcaption>\n</figure>\n<h1 id=\"术语-1\">术语</h1>\n<p><strong>LDO</strong>: Low dropout, A DC linear voltage regulator which can operate with a very small input/output differential voltage.</p>\n<p><strong>V<span style=\"font-size: 0.8rem;\">REG</span></strong>: Voltage Regulator. 稳压器。</p>\n<p><strong>V<span style=\"font-size: 0.8rem;\">REF</span></strong>: Voltage Reference. 参考电压</p>\n<p><strong>ESD</strong>: Electrostatic Discharge, 静电放电。</p>\n<p><strong>标志</strong>：flag，也可以被称作 操作信号 或其他。</p>\n<p><strong>LSPCLK</strong>: Low-speed peripheral clock frequency of the device， 低速外设时钟频率</p>\n<p><strong>IP</strong>: Internal Peripheral，内部外设。</p>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li><a href=\"https://www.ti.com.cn/cn/lit/gpn/tms320f280049\">《TMS320F28004x 微控制器》</a></li>\n<li><a href=\"\">《F28004x_DEV_USER_GUIDE.pdf》</a></li>\n<li><a href=\"\">《SPRU566N C2000 <strong><em>Real-Time Control MCU Peripherals</em></strong> Reference Guide》</a></li>\n<li><a href=\"\">《SPRUI33D TMS320F28004x <strong><em>Real-Time Microcontrollers</em></strong> Technical Reference Manual》</a></li>\n<li><a href=\"\">《SPRUHS1C TMS320C28x <strong><em>Extended Instruction Sets</em></strong> Technical Reference Manual》</a></li>\n<li><a href=\"https://www.docin.com/p-505058292.html\">基于IGBT的DC-AC变换器设计</a></li>\n<li><a href=\"http://www.henlito.com/chinese/news/10/12717.html\">IGBT模块单相半桥逆变电路设计与应用</a></li>\n<li><a href=\"https://code.islet.space/TI/f28004x/index.html\">Texas Instruments F28004x Peripheral Driver Library</a></li>\n<li><a href=\"https://blog.csdn.net/Simon_cici/article/details/84951920\">280049LaunchPad仿真器连接不上的问题解决办法</a></li>\n<li><a href=\"https://blog.csdn.net/dog_second/article/details/108382419\">DSP 28335 编译过程中的#10234-D、#10010报错</a></li>\n<li>《MCU025A(001)_BOM.xls》</li>\n<li>《MCU025A(001)_Sch.pdf》</li>\n<li>《MCU025A_PCB_LayerPlots.pdf》</li>\n</ol>\n","categories":["Hardware"],"tags":["TI","C2000","DSP"]},{"title":"嵌入式芯片外设","url":"/2021/07/11/Hardware/DSP/2021-07-11-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%8A%AF%E7%89%87%E5%A4%96%E8%AE%BE/","content":"<p>嵌入式芯片（如MCU、DSP等）内部包含众多的模块化外设，如 串口控制模块，SPI模块，I2C模块，A/D模块，PWM模块，CAN模块，EEPROM，比较器模块，等等，它们都集成在芯片内部，有相对应的内部控制寄存器，可通过指令直接控制。</p>\n<p>按照控制信号类别对外设进行分类，可以分为 <strong>模拟外设</strong>（Analog Peripherals）、<strong>控制外设</strong>（Control Peripherals） 和 <strong>通信外设</strong>（Communication Peripherals）。</p>\n<p><strong>模拟外设</strong> 的常见外设如 <strong>模数转换器</strong>（Analog-to-Digital Convertor, ADC）、<strong>可编程增益放大器</strong>（Programmable Gain Amplifier, PGA）、<strong>温度传感器</strong>（Temperature Sensor）、<strong>缓冲数模转换器</strong>（Buffered Digital-to-Analog Convertor, DAC）和 <strong>比较器</strong>（Comparator Subsystem）。</p>\n<p><strong>控制外设</strong> 的常见设备如 <strong>捕获器</strong>（Capture, CAP）、<strong>脉冲幅频调制器</strong>（Pulse Width Modulator, PWM）、<strong>正交编码器脉冲</strong>（ Quadrature Encoder Pulse, QEP）和 <strong>西格玛-德尔塔滤波器模块 </strong>（Sigma-Delta Filter Module, SDFM）。</p>\n<p><strong>通信外设</strong> 的常见设备如 （Controller Area Network, CAN）、<strong>双线通信</strong>（Inter-Integrated Circuit, I2C）、<strong>电源管理总线接口</strong>（Power Management Bus Interface, PMBus）、<strong>串行通信接口</strong>（Serial Communications Interface, SCI）、<strong>串行外设接口</strong>（Serial Peripheral Interface, SPI）、<strong>局域互联网络</strong>（Local Interconnect Network, LIN） 和 <strong>高速串行接口</strong>（Fast Serial Interface, FSI）。</p>\n<h1 id=\"cla\">CLA</h1>\n<p>为了解决DSP在对实时控制要求比较高的场合中CPU计算速度不足以及计算负担过重，TI很早之前就已经推出了具有CLA功能的DSP。</p>\n<p>CLA，即Control Law Accelerator，是一个32位浮点数计算加速器，可以理解为一个专门为浮点数运算而优化的CPU。其可以 <strong>独立</strong> 于CPU进行运算操作，并 <mark>可以同时访问</mark> 到ePWM，eCAP，eQEP，ADC result以及Comparator <mark>寄存器</mark>。相当于两个CPU并行工作，从而减少了主CPU的运算负担。</p>\n<p>也就是说 CLA可以同时访问所有模拟外设的寄存器。</p>\n<p>可以将CLA看作是辅助CPU进行计算的浮点运算协处理器（co-processor）。</p>\n<p>一个典型的应用场景如下：</p>\n<p><img src=\"https://pic.islet.space/2021/07/v2-9fdd0b85b26f7ff8074a8c58b1aba945_720w.jpg\" alt=\"img\" />闭环控制电路</p>\n<p>CPU通过ADC采集主电路的电压、电流信息，计算得到控制逻辑（包括频率以及占空比等），从而控制电路工作。因此如果CPU的计算负担很大，比如说需要计算傅里叶分解，比如说需要计算反三角函数等，那么就造成了极大的控制时延。而CLA应运而生，专门为计算浮点数进行优化，且不会造成CPU阻塞于计算而对异常情况无法响应的情况。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/v2-2d0d2214e132b1a9982d3ab50db429ff_720w.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<div style=\"text-align: center; font-weight: 900;\">\n图 28069和28027对比\n</div>\n<p>上图则对比了具有CLA功能的28069和不具有CLA功能的28027的控制延时。对于没有CLA功能的28027，其CPU在ADC采样结束之后触发SOC中断，随后进行闭环计算，最后再结束一个周期的控制，开始下一个周期。而具有<mark>CLA</mark>功能的28069则<mark>可以在采样结束之后立即自主触发CLA计算</mark>（由于没有菊花链，所以触发迅速），并且由于<mark>CLA针对浮点数计算进行优化，因此计算时间更短</mark>。更重要的是，<mark>CPU不需要进行任何操作，因此CPU可以有空闲完成其他任务，比如异常检测，比如故障上报等等</mark>。</p>\n<p>简单来说，采用CLA的系统具有<strong>更小的计算时延</strong>，<strong>CPU负担更小，</strong>因此其系统更加迅速稳定。</p>\n<h1 id=\"clb\">CLB</h1>\n<p>The C2000 configurable logic block (CLB) is a collection of configurable blocks that interconnect through software to implement custom digital logic functions.</p>\n<p>The CLB subsystem contains a number of identical tiles.</p>\n<h1 id=\"gpio\">GPIO</h1>\n<p>GPIO，即General-purpose input/output，通用型之输入输出（接口）。功能类似8051的P0—P3，其接脚可以供使用者由程控自由使用，PIN脚依现实考量可作为通用输入（GPI）或通用输出（GPO）或通用输入与输出（GPIO），如当clk generator, chip select等。 既然一个引脚可以用于输入、输出或其他特殊功能，那么一定有寄存器用来选择这些功能。对于输入，一定可以通过读取某个寄存器来确定引脚电位的高低；对于输出，一定可以通过写入某个寄存器来让这个引脚输出高电位或者低电位；对于其他特殊功能，则有另外的寄存器来控制它们。</p>\n<h1 id=\"cmpss\">CMPSS</h1>\n<p>CMPSS，即Comparator Subsystem，比较器子系统。由模拟比较器和支持电路组成，可用于峰值电流模式控制、开关电源、功率因数校正、电压跳闸监测等应用。</p>\n<p>每个CMPSS包含两个比较器、两个12位DAC参考、两个数字滤波器和一个斜坡发生器。比较器在每个模块中表示为“H”或“L”，其中“H”和“L”分别表示高和低。每个比较器产生一个数字输出，指示正输入端的电压是否大于负输入端的电压。比较器的正输入由外部引脚或PGA驱动，负输入可由外部引脚或可编程参考12位DAC驱动。每个比较器输出通过一个可编程的数字滤波器，可以消除假跳闸信号。如果不需要滤波，也可以使用未滤波的输出。一个可选的斜坡发生器电路可用于控制高比较器的12位参考DAC值。</p>\n<p><img src=\"https://pic.islet.space/2021/07/20200416154658460.png\" /></p>\n<h1 id=\"can\">CAN</h1>\n<p>A controller area network(CAN) is ideally suited to the many high-level industrial protocols embracing CAN and <strong><em>ISO-11898:2003</em></strong> as their physical layer.</p>\n<h2 id=\"introduction\">Introduction</h2>\n<ul>\n<li><p>The CAN bus was developed by BOSCH as a <strong><em>multi-master</em></strong>, <strong><em>message broadcast</em></strong> system that specifies a maximum signaling rate of <strong><em>1 megabit per second</em></strong>(bps).</p></li>\n<li><p>CAN is an International Standardization Organization (ISO) defined serial communications bus originally developed for the automotive industry to replace the complex wiring harness with a two-wire bus.</p></li>\n<li><p>CAN <em>does not</em> send large blocks of data point-to-point from node A to Node B under the supervision of the central bus master.</p></li>\n<li><p>In a CAN network, <mark>many short messages</mark> like temperature or RPM <mark>are broadcast to the entire network</mark>, which provides for <mark>data consistency in every node of the system</mark>. 保证系统中各节点的数据一致性。</p></li>\n<li><p>CAN's specification calls for high immunity to electrical interface and the ability to self-diagnose and repair data errors.</p></li>\n</ul>\n<p>以下为ISO 11898 对 CAN 标准架构层级解释框图：</p>\n<figure>\n<img src=\"C:\\Users\\431240.IT2004\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210711162150611.png\" alt=\"image-20210711162150611\" /><figcaption aria-hidden=\"true\">image-20210711162150611</figcaption>\n</figure>\n<p>The CAN communication protocol is a <strong><em>carrier-sense</em></strong>, <strong><em>multiple-access</em></strong> protocol with <strong><em>collision detection</em></strong> and <strong><em>arbitration on message priority</em></strong> (<strong><em>CSMA</em></strong> / <strong><em>CD+AMP</em></strong>). <strong><em>CSMA</em></strong> means that each node on a bus must wait for a prescribed period of inactivity before attempting to send a message. <strong><em>CD+AMP</em></strong> means that collisions are resolved through a bit-wise arbitration, based on a preprogrammed priority of each message in the identifier field of a message. The higher priority identifier always wins bus access.</p>\n<p>CAN 包含 standard CAN 和 Extended CAN。</p>\n<figure>\n<img src=\"C:\\Users\\431240.IT2004\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210711163535822.png\" alt=\"image-20210711163535822\" /><figcaption aria-hidden=\"true\">image-20210711163535822</figcaption>\n</figure>\n<figure>\n<img src=\"C:\\Users\\431240.IT2004\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210711163548817.png\" alt=\"image-20210711163548817\" /><figcaption aria-hidden=\"true\">image-20210711163548817</figcaption>\n</figure>\n<h1 id=\"术语\">术语</h1>\n<p><strong>菊花链</strong>：在电子电气工程中菊花链代表一种配线方案，例如设备A和设备B用电缆相连，设备B再用电缆和设备C相连，设备C用电缆和设备D相连，在这种连接方法中不会形成网状的拓扑结构，只有相邻的设备之间才能直接通信，例如在上例中设备A是不能和设备C直接通信的，它们必须通过设备B来中转，这种方法同样不会形成环路。因为最后一个设备不会连向第一个设备。这种连线方法能够用来传输电力，数字信号和模拟信号。</p>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li><a href=\"https://zhuanlan.zhihu.com/p/72232829\">CLA介绍及使用指南</a></li>\n<li><a href=\"https://baike.baidu.com/item/gpio\">GPIO</a></li>\n<li><a href=\"https://blog.csdn.net/whyorwhnt/article/details/105547472\">TMS320F280049C 学习笔记16 比较器子系统(CMPSS)</a></li>\n<li><a href=\"https://www.ti.com/lit/an/sloa101b/sloa101b.pdf\">《Introduction to the Controller Area Network(CAN)》</a></li>\n</ol>\n","categories":["Hardware"],"tags":["TI","嵌入式","外设","peripheral"]},{"title":"ESP32 SDK的配置","url":"/2019/01/10/Hardware/ESP32/2019-01-10-ESP32%20SDK%E7%9A%84%E9%85%8D%E7%BD%AE/","content":"<p>本文将直接摘抄和引用<a href=\"https://docs.espressif.com/projects/esp-idf/zh_CN/latest/get-started/index.html\">ESPRESSIF官网文档</a>对ESP32 SDK配置的描述，并对具体执行步骤加一些自己的备注和注意事项。</p>\n<p>本文中以Ubuntu为Linux系统的代表，在所有安装步骤<code>apt-get install</code>及涉及到其他读写<code>cp</code>、<code>mkdir</code>或<code>rm</code>的操作中，如遇到<code>Permission denied</code>等权限不够的问题，请在命令开头添加<code>sudo</code>或直接另起一行输入<code>sudo -s</code>，然后输入密码(有些命令不需要输入密码)获取 <strong>root</strong> 权限。</p>\n<p>Eclipse的使用可以在三大平台上进行，但是用<code>.bin</code>文件烧录到开发板的过程目前仅在Windows平台找得到烧录工具，望悉知。</p>\n<p>为方便描述，本文定义<code>终端</code>为MSYS2及Terminal的统称，<code>XXXXX</code>为你电脑的用户名，<code>*</code>为你的端口号数字。</p>\n<p>本文分为三部分： - 工具及SDK的下载及配置 - 使用终端运行工程 - 使用Eclipse运行工程</p>\n<h1 id=\"一工具及sdk的下载及配置\">一、工具及SDK的下载及配置</h1>\n<p>本节共有五部分： - 工具(MSYS2和Git) - ESP-IDF - Xtensa - 环境变量设置 - python依赖包</p>\n<h2 id=\"工具\">1. 工具</h2>\n<p>此部分在官方文档里面称为“设置工具链”。</p>\n<h3 id=\"msys2for-windows-only\">1.1 MSYS2(for Windows only)</h3>\n<p>跟Git Bash Shell同理，直接从<a href=\"http://www.msys2.org/\">MSYS2官网</a>下载和安装到C盘根目录<code>C:/</code>下即可。或者直接下载ESPRESSIF提供的<a href=\"https://dl.espressif.com/dl/esp32_win32_msys2_environment_and_toolchain-20181001.zip\">.zip文件</a>，解压到<code>C:/</code>。</p>\n<p>能不能放到其他盘，暂时没有试验过，对于使用MSYS2的开发者而言，最好是到<code>C:\\msys32\\mingw32.exe</code>文件属性中设置好管理员权限。</p>\n<p>本下载仅用于windows平台，对于Mac及Linux平台而言，可以直接调用Terminal进行后续步骤。</p>\n<h3 id=\"gitfor-mac-linux\">1.2 Git(for Mac &amp; Linux)</h3>\n<p>此步骤要在Terminal中进行，便于将ESPRESSIF保存在Github的ESP-IDF下载到本地。</p>\n<p>运行以下命令安装（Debian/Ubuntu）： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">apt-get install git</span><br></pre></td></tr></table></figure> 以及（Mac）：<a href=\"https://git-scm.com/download/mac\">Git下载</a></p>\n<p><strong>ESP-IDF</strong> 是ESP32设备的SDK，另外，MSYS2自带Git工具。如果已经安装过Git工具了，可以使用<code>git</code>或<code>git version</code>语句进行查看。</p>\n<h2 id=\"esp-idf\">2. ESP-IDF</h2>\n<p>在创建文件夹<code>esp</code>的过程中，确保自己没有使用到root权限来创建文件夹，查看的方法是打开<code>Files</code>应用，看看<code>esp</code>文件夹上面是否有个锁的图表。因为后续添加的环境变量局限于 <strong>XXXXX</strong> 用户，而执行文件因为在创建的过程中就属于 <strong>root</strong> 用户了，就不能够识别个人用户创建的环境变量<code>IDF_PATH</code>。为ESP-IDF的获取创建好文件夹，运行以下命令： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd ~&#x2F;</span><br><span class=\"line\">mkdir -p esp</span><br><span class=\"line\">cd esp</span><br></pre></td></tr></table></figure> 如果使用了 <strong>root</strong> 权限来创建esp文件夹，请使用命令<code>rm -d -f ~/esp</code>来删除 空的esp文件夹 或 使用命令<code>rm -r -f ~/esp</code>非空的esp文件夹。然后重启终端，使用普通用户权限再次创建。</p>\n<p><img src=\"https://docs.espressif.com/projects/esp-idf/zh_CN/latest/_images/msys2-terminal-window.png\" alt=\"msys2-terminal-window\" /> 然后运行下面语句，ESP-IDF 将会被下载到 <code>~/esp/esp-idf</code> 目录下。 <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;espressif&#x2F;esp-idf.git</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong> 上面克隆仓库的语句中有个 <code>--recursive</code> 选项。如果你克隆 ESP-IDF 时 <strong><em>没有带这个选项</em></strong> ，你还需要运行额外的命令（如下）来获取子模块： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd esp-idf</span><br><span class=\"line\">git submodule update --init</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"xtensafor-mac-linux-only\">3. Xtensa(for MAC &amp; Linux only)</h2>\n<p><strong>Windows平台因为使用MSYS2的原因，自带了Xtensa，因此可以忽略此步骤。</strong></p>\n<p><strong>Linux平台</strong> <a href=\"https://dl.espressif.com/dl/xtensa-esp32-elf-linux64-1.22.0-80-g6c4433a-5.2.0.tar.gz\">Xtensa-Linux-64bit</a>下载解压。 执行如下命令： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd ~&#x2F;esp</span><br><span class=\"line\">tar -xzf ~&#x2F;Downloads&#x2F;xtensa-esp32-elf-linux64-1.22.0-80-g6c4433a-5.2.0.tar.gz</span><br></pre></td></tr></table></figure></p>\n<p><strong>MAC平台</strong> <a href=\"https://dl.espressif.com/dl/xtensa-esp32-elf-osx-1.22.0-80-g6c4433a-5.2.0.tar.gz\">Xtensa-MAC</a> <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd ~&#x2F;esp</span><br><span class=\"line\">tar -xzf ~&#x2F;Downloads&#x2F;xtensa-esp32-elf-osx-1.22.0-80-g6c4433a-5.2.0.tar.gz</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"环境变量设置\">4. 环境变量设置</h2>\n<p><strong>Windows平台：</strong> 寻找到路径<code>C:/msys32/etc/profile.d/</code>，然后使用记事本或其他文本工具新建一个名为<code>export_idf_path.sh</code>的文件，然后将你的<code>esp-idf</code>路径写入文件中，如： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">export IDF_PATH&#x3D;&quot;C:&#x2F;msys32&#x2F;home&#x2F;XXXXX&#x2F;esp&#x2F;esp-idf&quot;</span><br></pre></td></tr></table></figure></p>\n<p>安装vim工具或使用其他文本工具，打开<code>~/.profile</code>文件。使用vim工具的话，单击<code>i</code>健进行插入，鼠标点击粘贴以下代码后，按<code>ESC</code>键，然后输入<code>:w</code>进行保存，再次输入<code>:q</code>推出vim工具，ubuntu平台的vim工具安装命令： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">apt-get install vim</span><br></pre></td></tr></table></figure></p>\n<p><strong>Linux平台</strong> <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">export PATH&#x3D;&quot;$HOME&#x2F;esp&#x2F;xtensa-esp32-elf&#x2F;bin:$PATH&quot;</span><br><span class=\"line\">export IDF_PATH&#x3D;~&#x2F;esp&#x2F;esp-idf</span><br></pre></td></tr></table></figure></p>\n<p><strong>MAC平台</strong> <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">export PATH&#x3D;$HOME&#x2F;esp&#x2F;xtensa-esp32-elf&#x2F;bin:$PATH</span><br><span class=\"line\">export IDF_PATH&#x3D;~&#x2F;esp&#x2F;esp-idf</span><br></pre></td></tr></table></figure></p>\n<p>完成修改后重启终端，并在终端中输入以下命令可以查看是否设置成功，如果不成功或者后续步骤中出现<code>No such file or directory</code>的错误提示，请尝试重启系统。 <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">printenv IDF_PATH</span><br><span class=\"line\">printenv PATH</span><br></pre></td></tr></table></figure></p>\n<figure>\n<img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/10/ESP32_SDK%E7%9A%84%E9%85%8D%E7%BD%AE/Environment_Setting_PATH.png\" alt=\"Environment_Setting_PATH\" /><figcaption aria-hidden=\"true\">Environment_Setting_PATH</figcaption>\n</figure>\n<h2 id=\"python依赖包安装\">5. python依赖包安装</h2>\n<p>直接输入以下命令，安装依赖于Python的软件包： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python -m pip install --user -r $IDF_PATH&#x2F;requirements.txt</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意</strong> 在终端输入<code>python</code>可查看版本，如果你的电脑安装的是不同版本的Python，则调用不同的语句进行安装，如<code>python2</code> <code>python2.7</code>。 <img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/10/ESP32_SDK%E7%9A%84%E9%85%8D%E7%BD%AE/Tools_Downloads_Python.png\" alt=\"Tools_Downloads_Python\" /> <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">python2.7 -m pip install --user -r $IDF_PATH&#x2F;requirements.txt</span><br></pre></td></tr></table></figure></p>\n<p>如果在此步骤出现<code>/usr/bin/python2.7: No module named pip</code>的问题，则输入以下命令进行pip module安装： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">apt-get install python-pip</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"二使用终端运行工程\">二、使用终端运行工程</h1>\n<p>本节共有四部分： - 工程样例复制 - 开发板连接 - 工程参数设置 - 命令行烧录</p>\n<h2 id=\"工程样例复制\">1. 工程样例复制</h2>\n<p>在<code>C:/msys32/home/XXXXX/esp/esp-idf/examples/</code>下面会有很多ESP-IDF自带的工程样例，按照用途分类。本节将使用<code>/get-started/hello_world</code>作为示范。</p>\n<p>拷贝样例： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd ~&#x2F;esp</span><br><span class=\"line\">cp -r $IDF_PATH&#x2F;examples&#x2F;get-started&#x2F;hello_world .</span><br></pre></td></tr></table></figure></p>\n<p>要注意的是，拷贝样例的语句中，那个点<code>.</code>必不可少，且和前面的路径中有个空格<code></code>。</p>\n<h2 id=\"开发板连接\">2. 开发板连接</h2>\n<p>将 ESP32 开发板连接到 PC，然后检查串口号，看看它能否正常通信。 ### 2.1 驱动 以下是乐鑫 ESP32 开发板驱动程序的链接：</p>\n<p>ESP32-PICO-KIT 和 ESP32-DevKitC - <a href=\"https://www.silabs.com/products/development-tools/software/usb-to-uart-bridge-vcp-drivers\">CP210x USB to UART Bridge VCP Drivers</a> ESP32-WROVER-KIT 和 ESP32 Demo Board - <a href=\"https://www.ftdichip.com/Drivers/VCP.htm\">FTDI Virtual COM Port Drivers</a></p>\n<p>装完驱动之后，Windows平台的设备管理器中是如下显示的： <img src=\"https://docs.espressif.com/projects/esp-idf/zh_CN/latest/_images/esp32-devkitc-in-device-manager1.png\" alt=\"esp32-devkitc-in-device-manager1\" /></p>\n<h3 id=\"端口号\">2.2 端口号</h3>\n<p><strong>Windows平台：</strong> 在<code>设备管理器</code>中查看<code>端口</code>并记录下其设备尾部标注的端口号<code>COM*</code>。 <img src=\"https://docs.espressif.com/projects/esp-idf/zh_CN/latest/_images/esp32-devkitc-in-device-manager1.png\" alt=\"esp32-devkitc-in-device-manager1\" /></p>\n<p><strong>Linux和Mac的平台：</strong> 在终端里面，分别运行查看端口命令两次，一次是在插入开发板前，一次是在插入开发板后。 <strong>Linux:</strong> <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ls &#x2F;dev&#x2F;tty*</span><br></pre></td></tr></table></figure> <strong>Mac:</strong> <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ls &#x2F;dev&#x2F;cu.*</span><br></pre></td></tr></table></figure> 另外，Linux平台还需要为登录用户添加串口读写权限： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo usermod -a -G dialout $XXXXX</span><br></pre></td></tr></table></figure></p>\n<p><strong>Putty工具</strong> 下载和使用<a href=\"https://www.putty.org/\">Putty工具</a>对开发板进行串口连接确认。</p>\n<p>运行终端，设置串口：波特率 = 115200，数据位 = 8，停止位 = 1，奇偶校验 = N。</p>\n<p>以下是设置串口和在 Windows 和 Linux 上传输参数（如 115200-8-1-N）的一些截屏示例。注意选择上述步骤中确认的串口进行设置。</p>\n<p><img src=\"https://docs.espressif.com/projects/esp-idf/zh_CN/latest/_images/putty-settings-windows1.png\" alt=\"putty-settings-windows1\" /> <img src=\"https://docs.espressif.com/projects/esp-idf/zh_CN/latest/_images/putty-settings-linux1.png\" alt=\"putty-settings-linux1\" /></p>\n<h2 id=\"工程参数设置\">3. 工程参数设置</h2>\n<p>在终端窗口中，输入<code>cd ~/esp/hello_world</code>进入<code>hello_world</code>所在目录，然后启动工程配置工具: <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">make menuconfig</span><br></pre></td></tr></table></figure> <img src=\"https://docs.espressif.com/projects/esp-idf/zh_CN/latest/_images/project-configuration1.png\" alt=\"project-configuration1\" /></p>\n<p>在菜单中，进入<code>Serial flasher config</code>&gt;<code>Default serial port</code>输入之前记录下来的串口号(<code>/dev/tty*</code>，<code>/dev/cu.*</code>或<code>/COM*</code>)，工程会加载到该串口上。输入回车确认选择，选择<code>&lt; Save &gt;</code>保存配置，然后选择<code>&lt; Exit &gt;</code>退出应用程序。</p>\n<p>以下是<code>menuconfig</code>的使用小技巧： 1. 使用 <strong>up &amp; down</strong> 组合键在菜单中上下移动 2. 使用 <strong>Enter</strong> 键进入一个子菜单，<strong>Escape</strong> 键退出子菜单或退出整个菜单 3. 输入 <code>?</code> 查看帮助信息，<strong>Enter</strong> 键退出帮助屏幕 4. 使用空格键或 <code>Y</code> 和 <code>N</code> 键来使能 (Yes) 和禁止 (No) 带有复选框 “<code>[*]</code>” 的配置项 5. 当光标在某个配置项上面高亮时，输入 <code>?</code> 可以直接查看该项的帮助信息 6. 输入 <code>/</code> 搜索配置项</p>\n<p><strong>注意</strong> 如果再此步骤出现<code>&lt;command-line&gt;:0:12: fatal error: curses.h: No such file or directory</code>的错误提示，则</p>\n<h2 id=\"命令行烧录\">4. 命令行烧录</h2>\n<h3 id=\"烧录\">4.1 烧录</h3>\n<p>这条命令会编译应用程序和所有的 ESP-IDF 组件，生成 bootloader、分区表和应用程序 bin 文件，并将这些 bin 文件烧写到 ESP32 板子上。 <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">make flash</span><br></pre></td></tr></table></figure> 烧写成功的话，板子将会复位，应用程序 “hello_world” 开始启动，在终端显示如下： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">esptool.py v2.0-beta2</span><br><span class=\"line\">Flashing binaries to serial port &#x2F;dev&#x2F;ttyUSB0 (app at offset 0x10000)...</span><br><span class=\"line\">esptool.py v2.0-beta2</span><br><span class=\"line\">Connecting........___</span><br><span class=\"line\">Uploading stub...</span><br><span class=\"line\">Running stub...</span><br><span class=\"line\">Stub running...</span><br><span class=\"line\">Changing baud rate to 921600</span><br><span class=\"line\">Changed.</span><br><span class=\"line\">Attaching SPI flash...</span><br><span class=\"line\">Configuring flash size...</span><br><span class=\"line\">Auto-detected Flash size: 4MB</span><br><span class=\"line\">Flash params set to 0x0220</span><br><span class=\"line\">Compressed 11616 bytes to 6695...</span><br><span class=\"line\">Wrote 11616 bytes (6695 compressed) at 0x00001000 in 0.1 seconds (effective 920.5 kbit&#x2F;s)...</span><br><span class=\"line\">Hash of data verified.</span><br><span class=\"line\">Compressed 408096 bytes to 171625...</span><br><span class=\"line\">Wrote 408096 bytes (171625 compressed) at 0x00010000 in 3.9 seconds (effective 847.3 kbit&#x2F;s)...</span><br><span class=\"line\">Hash of data verified.</span><br><span class=\"line\">Compressed 3072 bytes to 82...</span><br><span class=\"line\">Wrote 3072 bytes (82 compressed) at 0x00008000 in 0.0 seconds (effective 8297.4 kbit&#x2F;s)...</span><br><span class=\"line\">Hash of data verified.</span><br><span class=\"line\"></span><br><span class=\"line\">Leaving...</span><br><span class=\"line\">Hard resetting...</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"端口监控\">4.2 端口监控</h3>\n<p>如果要查看 “hello_world” 程序是否真的在运行，输入命令 make monitor。这个命令会启动 IDF Monitor 程序（ESP-IDF自带工具），也可以使用其他串口助手进行查看。 <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">make monitor</span><br></pre></td></tr></table></figure> 串口启动时，在终端显示如下： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ make monitor</span><br><span class=\"line\">MONITOR</span><br><span class=\"line\">--- idf_monitor on &#x2F;dev&#x2F;ttyUSB0 115200 ---</span><br><span class=\"line\">--- Quit: Ctrl+] | Menu: Ctrl+T | Help: Ctrl+T followed by Ctrl+H ---</span><br><span class=\"line\">ets Jun  8 2016 00:22:57</span><br><span class=\"line\"></span><br><span class=\"line\">rst:0x1 (POWERON_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)</span><br><span class=\"line\">ets Jun  8 2016 00:22:57</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure> 开发板输出到串口的信息，在终端显示如下： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Hello world!</span><br><span class=\"line\">Restarting in 10 seconds...</span><br><span class=\"line\">I (211) cpu_start: Starting scheduler on APP CPU.</span><br><span class=\"line\">Restarting in 9 seconds...</span><br><span class=\"line\">Restarting in 8 seconds...</span><br><span class=\"line\">Restarting in 7 seconds...</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"三-使用eclipse运行工程\">三、 使用Eclipse运行工程</h1>\n<p>本节共有四部分： - JRE &amp; Eclipse - Eclipse项目运行 - Build Project - Flash tools烧录</p>\n<h2 id=\"jre-eclipse\">1. JRE &amp; Eclipse</h2>\n<h3 id=\"jre安装\">1.1 JRE安装</h3>\n<p><a href=\"https://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html\">JRE(Java Runtime Environment)</a>要在Eclipse之前安装，并在终端使用如下命令验证是否安装成功并查看版本： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -version</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"eclipse安装\">1.2 Eclipse安装</h3>\n<p>Eclipse IDE 是一个可视化的集成开发环境，可用于编写、编译和调试 ESP-IDF 项目。</p>\n<p>下载相应的Eclipse并安装到电脑：<a href=\"https://www.eclipse.org/\">eclipse.org</a>,在安装的过程中记得要选择<code>Eclipse for C/C++ Development</code>(有的版本也可能显示为 CDT)。</p>\n<h2 id=\"eclipse项目运行\">2. Eclipse项目运行</h2>\n<h3 id=\"导入工程样例\">2.1 导入工程样例</h3>\n<ol type=\"1\">\n<li><p>运行 Eclipse，选择 <strong>File</strong> -&gt; <strong>Import…</strong>。</p></li>\n<li><p>弹出的对话框中选择 <strong>C/C++</strong> -&gt; <strong>Existing Code as Makefile Project</strong>，然后点击 <strong>Next</strong>。</p></li>\n<li><p>在下个界面中 <strong>Existing Code Location</strong> 位置输入您的 IDF 项目的路径（如：<strong>C:/msys32/home/XXXXX/esp/hello_world</strong>）。 <em>注意：这里应输入 ESP-IDF 项目的路径，而非 ESP-IDF 本身的路径。</em></p></li>\n<li><p>在本界面，找到 <strong>Toolchain for Indexer Settings</strong>，选择 <strong>Cross GCC</strong>，最后点击 <strong>Finish</strong>。</p></li>\n</ol>\n<h3 id=\"设置工程项目属性\">2.2 设置工程项目属性</h3>\n<figure>\n<img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/10/ESP32_SDK%E7%9A%84%E9%85%8D%E7%BD%AE/Eclipse_Project_Properties.png\" alt=\"Eclipse_Project_Properties\" /><figcaption aria-hidden=\"true\">Eclipse_Project_Properties</figcaption>\n</figure>\n<p>在本小节中，会 <strong>添加或修改三个主要的环境变量</strong> ：<code>BTACH_BUILD</code>、<code>IDF_PATH</code>和<code>PATH</code>。这些变量可以只在 <strong>项目属性</strong> 中修改，也可以直接到 <strong>系统环境变量</strong> 中修改。（添加到系统环境变量中的方法本文无讲解）</p>\n<figure>\n<img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/10/ESP32_SDK%E7%9A%84%E9%85%8D%E7%BD%AE/Eclipse_Project_Properties_Environment_Value.png\" alt=\"Eclipse_Project_Properties_Environment_Value\" /><figcaption aria-hidden=\"true\">Eclipse_Project_Properties_Environment_Value</figcaption>\n</figure>\n<ol type=\"1\">\n<li><p>新项目将出现在Eclipse左侧的 <strong>Project Explorer</strong> 选项卡中。选择导入的项目，在右键菜单中选择 <strong>Properties</strong>。</p></li>\n<li><p>点击 <strong>C/C++ Build</strong> 下的 <strong>Environment</strong> 属性页，点击 <strong>Add…</strong> 按钮，输入 <code>BATCH_BUILD</code> 和 <code>1</code>。</p></li>\n<li><p>点击 <strong>Add…</strong>，输入 <strong>IDF_PATH</strong> 中输入 ESP-IDF 所在的完整安装路径 <code>C:/msys32/home/XXXXX/esp/esp-idf</code> 。Linux及MAC平台的安装路径 <code>/home/XXXXX/esp/esp-idf</code> .</p></li>\n<li><p>选择 <code>PATH</code> 环境变量，不要改变默认值。</p></li>\n</ol>\n<p><strong>Windows 用户：</strong> 将 <code>C:\\msys32\\mingw32\\bin;C:\\msys32\\opt\\xtensa-esp32-elf\\bin;C:\\msys32\\usr\\bi</code> 添加到 <code>PATH</code> 环境变量的靠前位置（如果您将 msys32 安装到了其它目录，则需要更改对应的路径以匹配您的本地环境）。</p>\n<ol start=\"5\" type=\"1\">\n<li>在 macOS 平台上，增加一个 <code>PYTHONPATH</code> 环境变量，并将其设置为 <code>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages</code>， 保证系统中预先安装的 Python （需安装 pyserial 模块）可以覆盖 Eclipse 内置的任何 Python。</li>\n</ol>\n<figure>\n<img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/10/ESP32_SDK%E7%9A%84%E9%85%8D%E7%BD%AE/Eclipse_Project_Properties_Preprocessor_Include.png\" alt=\"Eclipse_Project_Properties_Preprocessor_Include\" /><figcaption aria-hidden=\"true\">Eclipse_Project_Properties_Preprocessor_Include</figcaption>\n</figure>\n<ol start=\"6\" type=\"1\">\n<li>前往 <strong>C/C++ General</strong> -&gt; <strong>Preprocessor Include Paths</strong> 属性页面，点击 <strong>Providers</strong> 选项卡:</li>\n</ol>\n<p>选择 <strong>CDT Cross GCC Built-in Compiler Settings</strong>，将 <strong>Command to get compiler specs</strong> 修改为 <code>xtensa-esp32-elf-gcc $&#123;FLAGS&#125; -std=c++11 -E -P -v -dD \"$&#123;INPUTS&#125;\"</code>。</p>\n<p>选择 <strong>“CDT GCC Build Output Parser</strong>，将 <strong>Compiler command pattern</strong> 修改为 <code>xtensa-esp32-elf-(gcc|g\\+\\+|c\\+\\+|cc|cpp|clang)</code>。</p>\n<figure>\n<img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/10/ESP32_SDK%E7%9A%84%E9%85%8D%E7%BD%AE/Eclipse_Project_Properties_Indexer.png\" alt=\"Eclipse_Project_Properties_Indexer\" /><figcaption aria-hidden=\"true\">Eclipse_Project_Properties_Indexer</figcaption>\n</figure>\n<ol start=\"7\" type=\"1\">\n<li>前往 <strong>C/C++ General</strong> -&gt; <strong>Indexer</strong> 属性页面，选择 <strong>Enable project specific settings</strong> 以启用本页上的其他设置。然后去除 <strong>Allow heuristic resolution of includes</strong> 勾选，因为启用此选项时，Eclipse 有时无法找到正确的头文件目录。</li>\n</ol>\n<figure>\n<img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/10/ESP32_SDK%E7%9A%84%E9%85%8D%E7%BD%AE/Eclipse_Project_Properties_Build_Behavior.png\" alt=\"Eclipse_Project_Properties_Build_Behavior\" /><figcaption aria-hidden=\"true\">Eclipse_Project_Properties_Build_Behavior</figcaption>\n</figure>\n<ol start=\"8\" type=\"1\">\n<li><p>点击 <strong>C/C++ Build</strong> -&gt; <strong>Behavior</strong> 属性页，选中 <strong>Enable parallel build</strong> 以启用多任务并行构建。</p></li>\n<li><p>保存项目属性并退出属性设置界面。</p></li>\n</ol>\n<h2 id=\"build-project\">3. Build Project</h2>\n<p>选择菜单栏中的 <strong>Project</strong> -&gt; <strong>Build Project</strong>。在此步骤中，将会调用ESP-IDF生成三个文件：<code>bootloader.bin</code>、<code>partition_singleapp.bin</code>和<code>hello_world.bin</code>。分别对应的是启动程序、分区程序和应用主程序。</p>\n<p>成功构建工程项目之后，Eclipse下方的 <strong>Console</strong> 选项卡将会显示如下： <img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/10/ESP32_SDK%E7%9A%84%E9%85%8D%E7%BD%AE/build_successfully.png\" alt=\"build_successfully\" /></p>\n<h2 id=\"flash-tools烧录\">4. Flash tools烧录</h2>\n<p><a href=\"https://www.espressif.com/sites/default/files/tools/flash_download_tools_v3.6.5.zip\">Flash tools</a>（仅在<a href=\"https://www.espressif.com/zh-hans/products/hardware/esp32/resources\">ESPRESSIF官网</a>上找到Windows版本）下载并解压到相应位置，打开后进行如下配置。 正确配置后便可成功烧录，要注意的是，<code>bootloader.bin</code>对应放在地址<code>0x1000</code>的位置,<code>partition_singleapp.bin</code>对应放在地址<code>0x8000</code>的位置,<code>helloworld.bin</code>对应放在地址<code>0x10000</code>的位置。 <img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/10/ESP32_SDK%E7%9A%84%E9%85%8D%E7%BD%AE/flash_download.png\" alt=\"flash_download\" /></p>\n<h1 id=\"参考链接\">参考链接</h1>\n<ol type=\"1\">\n<li>《<a href=\"https://blog.csdn.net/sergeycao/article/details/8210849\">ubuntu下文件拷贝命令cp命令</a>》</li>\n<li>《<a href=\"https://blog.csdn.net/hotmocha/article/details/7354630\">ubuntu rm命令</a>》</li>\n<li>《<a href=\"http://www.cnblogs.com/peida/archive/2012/10/25/2738271.html\">mkdir命令</a>》</li>\n</ol>\n","categories":["InternetOfThings"],"tags":["ESPIDF","ESPRESSIF","Eclipse"]},{"title":"ESP32相关术语整理","url":"/2019/01/14/Hardware/ESP32/2019-01-14-ESP32%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD%E6%95%B4%E7%90%86/","content":"<p>以下为本人在学习ESP32开发的途中的一些资料整理。</p>\n<h1 id=\"gpio\">GPIO</h1>\n<p>General-purpose input/output，通用型输入输出。其接脚可以供使用者由程控自由使用，PIN脚依现实考量可作为通用输入（GPI）或通用输出（GPO）或通用输入与输出（GPIO），如当clk generator, chip select等。 既然一个引脚可以用于输入、输出或其他特殊功能，那么一定有寄存器用来选择这些功能。对于输入，一定可以通过<strong>读取某个寄存器来确定引脚电位的高低</strong> ；对于输出，一定可以通过写入某个寄存器来让这个引脚输出高电位或者低电位；对于其他特殊功能，则有另外的寄存器来控制它们。</p>\n<h1 id=\"xtensa\">Xtensa</h1>\n<p>Xtensa 是Tensilica公司的处理器。</p>\n<h1 id=\"openocd\">OpenOCD</h1>\n<p>OpenOCD（Open On-Chip Debugger）开源片上调试器，是一款开源软件，最初是由Dominic Rath同学还在大学期间发起的（2005年）项目。OpenOCD旨在提供针对嵌入式设备的调试、系统编程和边界扫描功能。</p>\n<p>OpenOCD的功能是在仿真器的辅助下完成的，仿真器是能够提供调试目标的电信号的小型硬件单元。仿真器是必须的，因为调试主机（运行OpenOCD的主机）通常不具备这种电信号的直接解析功能。</p>\n<p>仿真器支持一个或多个传输协议，每个协议涉及不同的电信号，且使用不同的协议栈进行消息传递。市面上有很多种仿真器，并且这些仿真器的命名没有统一的规律。</p>\n<p>仿真器有时候会被封装成独立的加密狗，这种称为硬件接口加密狗。一些开发板上面直接集成了硬件接口加密狗，这样可以使开发板通过USB直接连到主机上进行调试。</p>\n<p>例如，JTAG仿真器支持JTAG协议的信号，可以用来进行TAPs和目标板子之间符合JTAG协议（IEEE 1149.1）的通讯。TAP（Test Access Port）是处理特殊指令和数据的单元。TAPs在芯片与板子之间和之内以菊花链的形式进行连接。JTAG支持调试和边界扫描。</p>\n<p>还有SWD仿真器，这种仿真器支持使用SWD（Serial Wire Debug）信号与一些比较新的ARM芯片进行通讯，而且还可以作为那些同时支持JTAG和SWD的芯片的仿真器。不过SWD仅支持调试，不支持边检扫描。</p>\n<p>对于一些芯片，还有专门的编程下载器，这些下载器仅支持擦写FLASH的功能，不支持调试和边界扫描。对于此类专用下载器，OpenOCD暂时并不支持。</p>\n<h3 id=\"加密狗\">加密狗</h3>\n<p>OpenOCD目前支持多种类型的硬件加密狗：基于USB的，基于并行端口的，以及其他在内部运行OpenOCD的独立盒子。 请参见第2章[仿真器硬件]，第5页。</p>\n<h3 id=\"gdb调试\">GDB调试</h3>\n<p>它允许ARM7（ARM7TDMI和ARM720t），ARM9（ARM920T，ARM922T，ARM926EJ-S，ARM966E-S），XScale（PXA25x，IXP42x），Cortex-M3（Stellaris LM3，ST STM32和Energy Micro EFM32）和基于Intel Quark（x10xx）的内核使用GDB协议进行调试。</p>\n<h3 id=\"flash编程\">Flash编程</h3>\n<p>擦写FLASH支持外部CFI兼容NOR闪存（Intel和AMD / Spansion命令集）和几个内部闪存（LPC1700，LPC1800，LPC2000，LPC4300，AT91SAM7，AT91SAM3U，STR7x，STR9x，LM3，STM32x和EFM32）。包括各种NAND闪存控制器（LPC3180，Orion，S3C24xx等）的初步支持。</p>\n<h2 id=\"at指令\">AT指令</h2>\n<p>即Attention，AT指令集是从终端设备(Terminal Equipment，TE)或数据终端设备(Data Terminal Equipment，DTE)向终端适配器(Terminal Adapter， TA)或数据电路终端设备AT(Data Circuit Terminal Equipment，DCE)发送的。通过TA，TE发送AT指令来控制移动台(Mobile Station，MS)的功能，与GSM 网络业务进行交互。用户可以通过AT指令进行呼叫、短信、电话本、数据业务、传真等方面的控制。</p>\n<h1 id=\"measured-power\">Measured Power</h1>\n<p>之所以所有文档都将Measure_Power变量的值定为C5，是因为此处C5为RSSI 在 1m时强度大小。见（RSSI @ 1m [ RSSI at 1 meter ] ）文档《Active Beacon Packet 170512.pdf》。</p>\n<figure>\n<img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/14/%E5%9B%BE%E7%89%871.png\" alt=\"iBeacon Format\" /><figcaption aria-hidden=\"true\">iBeacon Format</figcaption>\n</figure>\n<p>Measure Power 是Beacon距离测量设备1m时的信号强度（0xC5,要求反码）。实际过程中，根据接收到的RSSI值与0xC5（-59dbm）做对比得出当前设备距离，算法由厂商提供，iOS自带算法。</p>\n<figure>\n<img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/14/%E5%9B%BE%E7%89%872.png\" alt=\"Measure Power\" /><figcaption aria-hidden=\"true\">Measure Power</figcaption>\n</figure>\n<h1 id=\"参考文献\">参考文献</h1>\n<ol type=\"1\">\n<li>《<a href=\"https://blog.csdn.net/zqixiao_09/article/details/52506452\">AT指令介绍及用法,AT 指令集合</a>》</li>\n<li>《<a href=\"http://www.warski.org/blog/2014/01/how-ibeacons-work/\">How do iBeacons work?</a>》</li>\n<li>《<a href=\"https://zh.wikipedia.org/wiki/GPIO\">GPIO</a>》</li>\n</ol>\n","categories":["InternetOfThings"],"tags":["ESP32","Xtensa"]},{"title":"islet家庭物联网","url":"/2021/12/27/Hardware/ESP32/2021-12-27-islet%E5%AE%B6%E5%BA%AD%E7%89%A9%E8%81%94%E7%BD%91/","content":"<p><strong>GITEE</strong>: https://gitee.com/isletspace/esp32iot</p>\n<p>本项目是使用 <strong>微信小程序</strong>+<strong>腾讯云</strong>+<strong>乐鑫开发板</strong>+<strong>5V-多路-继电器</strong>+<strong>220V-AC-电器</strong> 的模式对家庭中的硬件进行检测和控制，本项目涉及到 <strong>网络前端</strong>、<strong>服务器后端</strong>、<strong>网络通信</strong> 和 <strong>物联网硬件控制</strong> 方面的相关知识。</p>\n<p><strong>需要实现的功能</strong>：</p>\n<ol type=\"1\">\n<li>开发板能够自动连接家庭WiFi</li>\n<li>开发板能够通过MQTT协议与后台服务器取得联系</li>\n<li>开发板能够定时自动获取时钟并校准</li>\n<li>开发板能够根据MQTT协议控制外围电路</li>\n<li>开发板能够根据已经设置的参数与实时的传感器参数比对，并在一定环境条件内开启/关闭相关电路</li>\n<li>手机可以通过微信小程序发送MQTT数据至服务器</li>\n</ol>\n<p><strong>软件开发平台</strong>：Mac</p>\n<p><strong>硬件开发IDE</strong>：Arduino</p>\n<h1 id=\"硬件准备\">硬件准备</h1>\n<ol type=\"1\">\n<li>4路5V红板（光耦/高低电平）继电器 *1</li>\n<li>DHT11温度模块 *2</li>\n<li>加热器 *1</li>\n<li>ESP32-WROOM-32开发板 *1</li>\n</ol>\n<p>其他：</p>\n<ol type=\"1\">\n<li>杜邦线</li>\n<li>电烙铁</li>\n<li>锡丝</li>\n<li>松香</li>\n<li>面包板</li>\n</ol>\n<h2 id=\"芯片模组比对选型\">芯片模组比对选型</h2>\n<p>ESP32-WROOM-32X（此处 <code>X</code> 代表不确定） 和 ESP32-WROVER-X（此处 <code>X</code> 代表不确定） 在性能上基本一模一样，包括核心数、最大时钟频率、Flash大小、支持的接口类型 和 特殊传感器等等。除了在 PSRAM、工作温度范围、天线、WiFi最高频率 和 模组尺寸上有所区别外。 ESP32-WROVER-X 则具有PSRAM 和 最大的面积（18mm × 31.4mm × 3.3mm）。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228014701607.png\" alt=\"官方展示的ESP32模组性能参数对比\" /><figcaption aria-hidden=\"true\">官方展示的ESP32模组性能参数对比</figcaption>\n</figure>\n<h2 id=\"芯片选型\">芯片选型</h2>\n<p>无脑选了ESP32-WROOM-32SE，反正自己用，而且便宜（￥21.5包邮）。</p>\n<h2 id=\"芯片基本信息\">芯片基本信息</h2>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228012555509.png\" alt=\"Arduino所展示的开发板可调参数\" /><figcaption aria-hidden=\"true\">Arduino所展示的开发板可调参数</figcaption>\n</figure>\n<h1 id=\"arduino-ide准备\">Arduino IDE准备</h1>\n<p>使用 Arduino IDE 进行开发，但开发配置相关的 <code>.json</code> 文件 及其安装包都在 <code>github.com</code> 上，即使使用了科学上网进行加速，但因为加速器的加速层级可能和IDE拉取资源包所用的数据层级不在同一个上面，无法代理，就白天基本上无法下载，凌晨（正经程序员谁tm熬夜）才有机会下载东西。</p>\n<blockquote>\n<p>英文版下的 <code>首选项</code> 是 <code>Preferences</code> 。</p>\n</blockquote>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228011905234.png\" alt=\"修改附加开发板管理网址\" /><figcaption aria-hidden=\"true\">修改附加开发板管理网址</figcaption>\n</figure>\n<p>然后去 <code>开发板管理器</code> 中搜索 <code>esp32</code> 进行安装。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228012156101.png\" alt=\"目录-开发板-开发板管理器\" /><figcaption aria-hidden=\"true\">目录-开发板-开发板管理器</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228012244049.png\" alt=\"搜索关键词“esp32”\" /><figcaption aria-hidden=\"true\">搜索关键词“esp32”</figcaption>\n</figure>\n<h2 id=\"解决github问题\">解决github问题</h2>\n<h3 id=\"方法一\">方法一</h3>\n<p>本来应该用如下链接进行配置的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://dl.espressif.com/dl/package_esp32_index.json </span><br></pre></td></tr></table></figure>\n<p>自己扒拉了一遍该文件中可能包含的所有资源包（主要是 <code>github.com</code> 上的），然后修改了 <code>.json</code> 文件，放到自己的桶里，然后放出来使用，还好这个文件里有明确提到要哪些资源不然也没法扒拉。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://code.islet.space/espressif/dl/package_esp32_index.json</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：Mac系统下可能会因为曾经下载过的缓存文件无法生效（如果自行修改了网站上的 <code>.json</code> 文件的话），需要自行清除缓存，打开 <code>~/Library/ArduinoXX/cache/</code> 并对应删除该网站的文件夹即可，如 <code>code.islet.space</code> 。（这里的 <code>ArduinoXX</code> 中的 <code>XX</code> 需要自己去看自己的文件夹，应该是受版本控制的）</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228005455101.png\" alt=\"修改链接后可以正常下载\" /><figcaption aria-hidden=\"true\">修改链接后可以正常下载</figcaption>\n</figure>\n<h3 id=\"方法二\">方法二</h3>\n<p>自己去github，用浏览器或者下载器下好了以后放到 <code>用户目录--资源库--程序缓存--指定位置</code>（如下）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">~&#x2F;Library&#x2F;ArduinoXX&#x2F;staging&#x2F;packages&#x2F;</span><br></pre></td></tr></table></figure>\n<p>这个文件夹也就需要放这么多文件吧。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228012028024.png\" alt=\"资源库缓存指定位置下的文件\" /><figcaption aria-hidden=\"true\">资源库缓存指定位置下的文件</figcaption>\n</figure>\n<p>亲测，第二种方法更好用。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228011814461.png\" alt=\"提示安装成功\" /><figcaption aria-hidden=\"true\">提示安装成功</figcaption>\n</figure>\n<h1 id=\"visual-studio-code-ide准备\">Visual Studio Code IDE准备</h1>\n<p>总的来说，VS Code的IDE配置会比Arduino更为复杂，但是无奈在都是科学上网的情况下，VS Code下载毫无压力，且VS Code使用习惯之后更加方便。</p>\n<p>至少前期配置工作来说，VS Code更为友好。</p>\n<h2 id=\"espressif-idf插件安装\">Espressif IDF插件安装</h2>\n<p>首先去插件市场搜索 <code>Espressif IDF</code> 插件进行安装，然后点击 <code>查看</code> -&gt; <code>命令面板</code>。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228182209737.png\" alt=\"image-20211228182209737\" /><figcaption aria-hidden=\"true\">image-20211228182209737</figcaption>\n</figure>\n<p>到这里需要输入 <code>configure esp-idf extension</code> 以进入该插件的配置页面。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228182314161.png\" alt=\"image-20211228182314161\" /><figcaption aria-hidden=\"true\">image-20211228182314161</figcaption>\n</figure>\n<h2 id=\"必要工具安装\">必要工具安装</h2>\n<p>然后它就会提示你需要安装几个必要插件，有 Git / Python / CMake 和 Ninja。这些都可以从Espressif的 <a href=\"https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/get-started/index.html\">官方文档</a> 中获取到安装步骤。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228182508965.png\" alt=\"image-20211228182508965\" /><figcaption aria-hidden=\"true\">image-20211228182508965</figcaption>\n</figure>\n<p>下方为四个工具的官方下载链接，前三个都可以通过官方下载软件包进行安装，第四个 Ninja 我安装不成功，是通过 Mac Ports 进行安装的。</p>\n<p>GIT : https://git-scm.com/</p>\n<p>PYTHON : https://www.python.org/downloads/</p>\n<p>CMAKE : https://cmake.org/download/</p>\n<p>NINJA : https://github.com/ninja-build/ninja/releases</p>\n<p>需要注意的是，CMAKE 和 Ninja 安装完还需要加入到系统环境变量 <code>PATH</code> 中去，Windows系统下的系统环境变量添加比较方便，下方为 Mac 系统下 CMake 的系统环境变量添加方法。</p>\n<h3 id=\"cmake命令行\">CMAKE命令行</h3>\n<p>打开Mac系统下的 CMake GUI，点击 <code>Tools</code> --&gt; <code>How to Install For Command Line Use</code> ，可以查看到三种将 CMake 添加到命令行中去运行的方法。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228183126458.png\" alt=\"点击“工具”菜单中的“如何为命令行使用进行安装”\" /><figcaption aria-hidden=\"true\">点击“工具”菜单中的“如何为命令行使用进行安装”</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228183411724.png\" alt=\"可以查看到三种安装方法\" /><figcaption aria-hidden=\"true\">可以查看到三种安装方法</figcaption>\n</figure>\n<p>使用的是第二种方法，向命令行输入 <code>sudo \"/Applications/CMake.app/Contents/bin/cmake-gui\" --install</code> 并输入管理员密码即可。</p>\n<p>然后通过 <code>cmake --version</code> 可以查看到版本号说明安装成功，但需要注意的是 <code>whereis cmake</code> 还是没有用。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228183403876.png\" alt=\"操作结果\" /><figcaption aria-hidden=\"true\">操作结果</figcaption>\n</figure>\n<h3 id=\"工具安装验证\">工具安装验证</h3>\n<p>四个必须要安装的软件都已经安装完毕，通过 <code>--version</code> 可以查看版本号。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228184801497.png\" alt=\"安装验证\" /><figcaption aria-hidden=\"true\">安装验证</figcaption>\n</figure>\n<h2 id=\"配置继续\">配置继续</h2>\n<p>四个必要工具安装完毕之后，关闭 <code>ESP-IDF Setup</code> 页面，然后重新在 <strong>命令面板</strong> 输入 <code>configure esp-idf extension</code> 以进入该插件的配置页面。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228184938407.png\" alt=\"再次进入配置页面\" /><figcaption aria-hidden=\"true\">再次进入配置页面</figcaption>\n</figure>\n<p>此处选择 <code>EXPRESS</code> 即可，里面会要求选择从哪个服务器下载（自己看情况选择<code>Github</code> / <code>Espressif</code>）、IDF版本（默认选最新）、IDF放置路径、工具路径、使用的Python3路径 等几个信息，选完了就进入下一界面，会自动下载安装 ESP-IDF。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228185458736.png\" alt=\"详细配置页面\" /><figcaption aria-hidden=\"true\">详细配置页面</figcaption>\n</figure>\n<p>耐心等待下载完毕即可，我用 <code>Espressif</code> 服务器下载不下来，然后该用 <code>Github</code> 和 科学上网进行下载的。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228185748221.png\" alt=\"image-20211228185748221\" /><figcaption aria-hidden=\"true\">image-20211228185748221</figcaption>\n</figure>\n<p>下载过程页面如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228190058612.png\" alt=\"image-20211228190058612\" /><figcaption aria-hidden=\"true\">image-20211228190058612</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228190027057.png\" alt=\"image-20211228190027057\" /><figcaption aria-hidden=\"true\">image-20211228190027057</figcaption>\n</figure>\n<p>最后提示的安装成功：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228190438498.png\" alt=\"image-20211228190438498\" /><figcaption aria-hidden=\"true\">image-20211228190438498</figcaption>\n</figure>\n<h1 id=\"示例项目载入\">示例项目载入</h1>\n<p>在 <strong>命令面板</strong> 中输入 <code>show examples projects</code> 。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228190651117.png\" alt=\"image-20211228190651117\" /><figcaption aria-hidden=\"true\">image-20211228190651117</figcaption>\n</figure>\n<p>即可调出 ESP-IDF的示例代码项目列表。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228190738993.png\" alt=\"image-20211228190738993\" /><figcaption aria-hidden=\"true\">image-20211228190738993</figcaption>\n</figure>\n<p>选择 <code>blink</code> 作为测试代码。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228190839371.png\" alt=\"image-20211228190839371\" /><figcaption aria-hidden=\"true\">image-20211228190839371</figcaption>\n</figure>\n<h2 id=\"项目构建\">项目构建</h2>\n<p>这里可以用命令面板输入 <code>esp build your project</code> ，也可以点击GUI下方的 <img src=\"https://pic.islet.space/2021/12/image-20211231124940242.png\" alt=\"image-20211231124940242\" />进行构建。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228191057987.png\" alt=\"命令面板构建\" /><figcaption aria-hidden=\"true\">命令面板构建</figcaption>\n</figure>\n<p>构建完成后，会生成 <code>build</code> 文件夹，下次构建时CMake会查看变动的文件然后只编译变动过的代码。</p>\n<p>也可以删除该 <code>build</code> 文件夹，使其全部重新构建，会比较费时。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228191156613.png\" alt=\"build过程\" /><figcaption aria-hidden=\"true\">build过程</figcaption>\n</figure>\n<p>点击下方的闪电按钮<img src=\"https://pic.islet.space/2021/12/image-20211231125445685.png\" alt=\"烧录按钮\" />即可烧录，烧录成功提示如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228221323556.png\" alt=\"烧录过程\" /><figcaption aria-hidden=\"true\">烧录过程</figcaption>\n</figure>\n<h1 id=\"连接wifi\">连接WiFi</h1>\n<p>下图为使用示例代码更改的项目代码文件内容：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228222302314.png\" alt=\"项目文件内容示例\" /><figcaption aria-hidden=\"true\">项目文件内容示例</figcaption>\n</figure>\n<p>利用ESP自带的示例代码<code>station</code> 进行调试和更改，需要注意以下几点：</p>\n<ol type=\"1\">\n<li><p>不用去更改 <code>isletSpaceIotMain.c</code> 中的 <code>SSID</code> 和 <code>PASS</code> ，只需要在 <code>sdkconfig</code> 文件中进行更改即可（如下图）。</p></li>\n<li><p>所有的 WiFi设置参数 都可以在 <code>sdkconfig</code> 文件中进行修改，如需要连接 AP 的 名称和密码，还有自身设备所显示的名称。</p></li>\n<li><p>修改文件名之后，需要对两个 <code>CMakeList.txt</code>文件 和 一个<code>Makefile</code> 文件中的项目和文件名进行修改（如下图）。</p></li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228222645861.png\" alt=\"如果修改代码名称需要修改main文件夹下的CMakeList文件\" /><figcaption aria-hidden=\"true\">如果修改代码名称需要修改main文件夹下的CMakeList文件</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228222717269.png\" alt=\"如果修改项目名称需要修改根目录下的CMakeList\" /><figcaption aria-hidden=\"true\">如果修改项目名称需要修改根目录下的CMakeList</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228222733903.png\" alt=\"如果修改项目名称需要修改根目录下的Makefile\" /><figcaption aria-hidden=\"true\">如果修改项目名称需要修改根目录下的Makefile</figcaption>\n</figure>\n<h2 id=\"menuconfig\">MENUCONFIG</h2>\n<p>MENUCONFIG 或者说 <code>sdkconfig</code> ，一个是图形界面的，一个是纯文本形式的。</p>\n<p>用menuconfig的话只需要找到下方的齿轮按钮即可。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211231130402110.png\" alt=\"image-20211231130402110\" /><figcaption aria-hidden=\"true\">image-20211231130402110</figcaption>\n</figure>\n<p>可以找到WiFi相关的配置位置：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211231130507316.png\" alt=\"image-20211231130507316\" /><figcaption aria-hidden=\"true\">image-20211231130507316</figcaption>\n</figure>\n<p>对 <code>sdkconfig</code> 文件中的设备名称进行修改。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228223040901.png\" alt=\"image-20211228223040901\" /><figcaption aria-hidden=\"true\">image-20211228223040901</figcaption>\n</figure>\n<p>修改完毕后可以在路由器 AP 的后台查看到已经连接的设备的名称，如下。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228223134009.png\" alt=\"image-20211228223134009\" /><figcaption aria-hidden=\"true\">image-20211228223134009</figcaption>\n</figure>\n<h1 id=\"mqtt协议\">MQTT协议</h1>\n<p>根据 Espressif 官网的 <a href=\"https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/api-reference/protocols/mqtt.html\">ESP-MQTT</a> 开发文档可知，MQTT 协议支持以下几种形式：</p>\n<ul>\n<li><p>MQTT over TCP</p></li>\n<li><p>MQTT over SSL with mbedtls</p></li>\n<li><p>MQTT over Websocket</p></li>\n<li><p>MQTT over Websocket Secure.</p></li>\n</ul>\n<p>各MQTT协议形式（与对应SDK里的 <a href=\"##MQTT相关示例代码\">MQTT示例代码</a>）及其所使用的端口号不同：</p>\n<ul>\n<li><code>protocols/mqtt/tcp</code>: MQTT over tcp, default port 1883</li>\n<li><code>protocols/mqtt/ssl</code>: MQTT over tcp, default port 8883</li>\n<li><code>protocols/mqtt/ssl_psk</code>: MQTT over tcp using pre-shared keys for authentication, default port 8883</li>\n<li><code>protocols/mqtt/ws</code>: MQTT over Websocket, default port 80</li>\n<li><code>protocols/mqtt/wss</code>: MQTT over Websocket Secure, default port 443</li>\n</ul>\n<h2 id=\"mqtt事件结构体\">MQTT事件结构体</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * MQTT event configuration structure</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">esp_mqtt_event_id_t</span> event_id;       <span class=\"comment\">/*!&lt; MQTT event type */</span></span><br><span class=\"line\">    <span class=\"keyword\">esp_mqtt_client_handle_t</span> client;    <span class=\"comment\">/*!&lt; MQTT client handle for this event */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *user_context;                 <span class=\"comment\">/*!&lt; User context passed from MQTT client config */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *data;                         <span class=\"comment\">/*!&lt; Data associated with this event */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data_len;                       <span class=\"comment\">/*!&lt; Length of the data for this event */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> total_data_len;                 <span class=\"comment\">/*!&lt; Total length of the data (longer data are supplied with multiple events) */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> current_data_offset;            <span class=\"comment\">/*!&lt; Actual offset for the data associated with this event */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *topic;                        <span class=\"comment\">/*!&lt; Topic associated with this event */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> topic_len;                      <span class=\"comment\">/*!&lt; Length of the topic for this event associated with this event */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> msg_id;                         <span class=\"comment\">/*!&lt; MQTT messaged id of message */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> session_present;                <span class=\"comment\">/*!&lt; MQTT session_present flag for connection event */</span></span><br><span class=\"line\">    <span class=\"keyword\">esp_mqtt_error_codes_t</span> *error_handle; <span class=\"comment\">/*!&lt; esp-mqtt error handle including esp-tls errors as well as internal mqtt errors */</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> retain;                        <span class=\"comment\">/*!&lt; Retained flag of the message associated with this event */</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">esp_mqtt_event_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">esp_mqtt_event_t</span> *<span class=\"keyword\">esp_mqtt_event_handle_t</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"mqtt相关示例代码\">MQTT相关示例代码</h2>\n<p>了解完官方开发文档中的信息，就可以知道MQTT示例代码里的这些文件夹命名含义，以及自己需要打开哪个示例代码了。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228223617579.png\" alt=\"image-20211228223617579\" /><figcaption aria-hidden=\"true\">image-20211228223617579</figcaption>\n</figure>\n<h2 id=\"menuconfig-1\">MENUCONFIG</h2>\n<p>MENUCONFIG 页面可以看到MQTT的相关配置信息。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211229011902429.png\" alt=\"image-20211229011902429\" /><figcaption aria-hidden=\"true\">image-20211229011902429</figcaption>\n</figure>\n<h1 id=\"mqtt服务器开发\">MQTT服务器开发</h1>\n<p>自行购买了腾讯云的服务器，然后完成了配置（步骤略），发现自测“主题订阅”不成功。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211229033019004.png\" alt=\"image-20211229033019004\" /><figcaption aria-hidden=\"true\">image-20211229033019004</figcaption>\n</figure>\n<p>然后刚好发现服务器的 Ubuntu 20 系统使用的防火墙是 <code>iptables</code> ，顺利打开 <code>1883</code> 端口。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo iptables -A INPUT -p tcp --dport 1883 -j ACCEPT</span><br></pre></td></tr></table></figure>\n<p>然后查看打开情况。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211229032825212.png\" alt=\"image-20211229032825212\" /><figcaption aria-hidden=\"true\">image-20211229032825212</figcaption>\n</figure>\n<p>顺便在服务器页面也打开相关配置。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211229032753559.png\" alt=\"image-20211229032753559\" /><figcaption aria-hidden=\"true\">image-20211229032753559</figcaption>\n</figure>\n<p>最后自测成功：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211229032920902.png\" alt=\"image-20211229032920902\" /><figcaption aria-hidden=\"true\">image-20211229032920902</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211229032953396.png\" alt=\"image-20211229032953396\" /><figcaption aria-hidden=\"true\">image-20211229032953396</figcaption>\n</figure>\n<h1 id=\"小程序开发未完\">小程序开发（未完）</h1>\n<p>因为个人使用腾讯云注册了自己的域名 islet.space，且小程序也属于腾讯自家产品，为了后续开发的兼容性和便利性，就同步参阅了腾讯云的 <a href=\"https://cloud.tencent.com/document/product/1081/47684\">物联网自主品牌小程序开发文档</a> 。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211227202550338.png\" alt=\"image-20211227202550338\" /><figcaption aria-hidden=\"true\">image-20211227202550338</figcaption>\n</figure>\n<h2 id=\"微信开发者工具\">微信开发者工具</h2>\n<p>微信开发者工具下载页面：https://cloud.tencent.com/document/product/1081/47685</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211227202759080.png\" alt=\"image-20211227202759080\" /><figcaption aria-hidden=\"true\">image-20211227202759080</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211227203058077.png\" alt=\"image-20211227203058077\" /><figcaption aria-hidden=\"true\">image-20211227203058077</figcaption>\n</figure>\n<h2 id=\"后台设置\">后台设置</h2>\n<p><a href=\"https://cloud.tencent.com/document/product/1081/34738\">物联网开发平台</a></p>\n<h1 id=\"debug\">DEBUG</h1>\n<h2 id=\"烧录和调试过程报错\">烧录和调试过程报错</h2>\n<p>出现这种情况，可能是所选芯片不正确导致。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228214645589.png\" alt=\"烧录错误提示\" /><figcaption aria-hidden=\"true\">烧录错误提示</figcaption>\n</figure>\n<h3 id=\"解决过程\">解决过程</h3>\n<p>重新选择了芯片，然后将烧录方法改为 <code>UART</code> ，重新烧录即可成功。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228215715687.png\" alt=\"在插件中选择”扩展设置“\" /><figcaption aria-hidden=\"true\">在插件中选择”扩展设置“</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228215826153.png\" alt=\"选择需要调试的设备类型\" /><figcaption aria-hidden=\"true\">选择需要调试的设备类型</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228215747432.png\" alt=\"选择烧录方式\" /><figcaption aria-hidden=\"true\">选择烧录方式</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228215518196.png\" alt=\"烧录成功提示\" /><figcaption aria-hidden=\"true\">烧录成功提示</figcaption>\n</figure>\n<h2 id=\"头文件查找错误\">头文件查找错误</h2>\n<p>这个bug始终没有解决，之后再说吧。。。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211228232022467.png\" alt=\"提示无该文件\" /><figcaption aria-hidden=\"true\">提示无该文件</figcaption>\n</figure>\n<h2 id=\"wifi初始化出错\">WIFI初始化出错</h2>\n<p>将WiFi-station的代码搬到 MQTT-TCP中，发现 <code>wifiStationInit()</code> 函数初始化错误，报错的行数是 <code>117</code> 。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211229143428551.png\" alt=\"wifi初始化函数出错\" /><figcaption aria-hidden=\"true\">wifi初始化函数出错</figcaption>\n</figure>\n<p>经检查，发现该函数示例代码的一部分，并未改动，且未添加其他自定义的 <code>.h</code> 或 <code>.c</code> 文件进行编译，应该不存在人为修改错误。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211229150011594.png\" alt=\"检查函数定义\" /><figcaption aria-hidden=\"true\">检查函数定义</figcaption>\n</figure>\n<p>因为仅修改了本 <code>isletSpaceIotMain.c</code> 文件，就在本文件中搜索 <code>esp_event_loop_create_default</code> 关键字，发现在 <code>app_main()</code> 中也有该语句，初步判断可能是两次调用导致错误，就注释了 <code>298</code> 行 和 <code>299</code> 行进行重新编译和烧录，问题解决，设备可以正常连接到路由器。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211229150054429.png\" alt=\"注释重复语句\" /><figcaption aria-hidden=\"true\">注释重复语句</figcaption>\n</figure>\n<h2 id=\"mqtt服务器连接错误\">MQTT服务器连接错误</h2>\n<p>在设备成功接入WiFi后，发现MQTT客户端无法连接至服务器。给出的错误提示是 <code>There are no transports valid</code> ，大致意思即连接不可用。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211229150744192.png\" alt=\"Monitor提示无可用传输\" /><figcaption aria-hidden=\"true\">Monitor提示无可用传输</figcaption>\n</figure>\n<p>经过检查，发现原来填写在 <code>sdkconfig</code> 文件中的 <code>Broker URL</code> 链接为 <code>https://iot.islet.space</code> ，而实际上，官网给出的配置方式如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211229152435708.png\" alt=\"查看官方URI定义\" /><figcaption aria-hidden=\"true\">查看官方URI定义</figcaption>\n</figure>\n<p>打开项目配置菜单，修改为 <code>mqtt://iot.islet.space</code> ，并重新 Build 和 Flash。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211229151252895.png\" alt=\"修改URL\" /><figcaption aria-hidden=\"true\">修改URL</figcaption>\n</figure>\n<p>可以发现错误已解决，设备已经正常连接至服务器。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211229152118764.png\" alt=\"Monitor提示成功\" /><figcaption aria-hidden=\"true\">Monitor提示成功</figcaption>\n</figure>\n<p>尝试在对应主题下发布信息进行测试：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211229152036214.png\" alt=\"尝试发布信息\" /><figcaption aria-hidden=\"true\">尝试发布信息</figcaption>\n</figure>\n<p>通过终端Monitor可以观察到，设备正常接收到数据：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211229152141547.png\" alt=\"设备接收成功\" /><figcaption aria-hidden=\"true\">设备接收成功</figcaption>\n</figure>\n<h2 id=\"eventhandler未进入\">eventHandler未进入</h2>\n<figure>\n<img src=\"https://pic.islet.space/2021/12/image-20211229182911935.png\" alt=\"image-20211229182911935\" /><figcaption aria-hidden=\"true\">image-20211229182911935</figcaption>\n</figure>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li><a href=\"https://blog.csdn.net/xujiuba/article/details/107234040\">Mac 安装 CMake 配置及环境配置</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=Lc6ausiKvQM\">Quick User Guide for the ESP-IDF VS Code Extension</a></li>\n<li><a href=\"https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/get-started/index.html#id2\">ESP-IDF 编程指南</a></li>\n<li><a href=\"https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/protocols/mqtt.html\">ESP-MQTT</a></li>\n</ol>\n","categories":["InternetOfThings"]},{"title":"FreeRTOS术语","url":"/2019/01/22/Hardware/FreeRTOS/2019-01-22-FreeRTOS%E6%9C%AF%E8%AF%AD/","content":"<p>以下术语解释为本人在学习FreeRTOS途中的整理，大多直接引用了官网的原解释，部分用自己的话进行描述。</p>\n<h1 id=\"task\">1. Task</h1>\n<p>Task is used to process a serial of things. A task must be declared as void type and have a void-type pointer parameter , like: <code>void BLE_TASK(void * pvParameters);</code></p>\n<p>And when used, it’s used in the function xTaskCreate() with 6 parameters, like: <code>xTaskCreate(BLE_TASK, “BEL_TASK”,4000, NULL, 5, NULL);</code></p>\n<ul>\n<li>The 1st parameter should be the task you defined, and it only need the name of your task function.</li>\n<li>The 2nd parameter is the custom string you made in order to recognize it in the tasks list.</li>\n<li>The 3rd parameter is task stack memory it need. <code>MEMORY = STACK DEPTH * STACK WIDTH</code></li>\n<li>The 4th parameter is passed to the the task when it need, and it used to be NULL.</li>\n<li>The 5th parameter is the priority of the task, the lowest priority is 0, the highest priority is 32. But it always advisable to keep it at the minimum necessary.</li>\n<li>The 6th parameter is the return value: pdPASS or pdFAIL.</li>\n</ul>\n<h1 id=\"scheduler\">2. Scheduler</h1>\n<p>Scheduler is used to manage the tasks. It runs in the tick interrupt and select the highest priority task and bring it into RUNNING-STATE.</p>\n<h1 id=\"idle-task\">3. IDLE Task</h1>\n<p>IDLE Task is automatically created by the scheduler when vTaskStartScheduler() is called and it is always able to run.</p>\n<h1 id=\"task-state\">4. Task State</h1>\n<p>All the task has two big states: <strong>RUNNING-STATE</strong> or <strong>NOT-RUNNING-STATE</strong>. BLOCKED-STATE, SUSPENDED-STATE and SUSPENDED-STATE are NON-RUNNING-STATE.</p>\n<figure>\n<img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/01/22/%E5%9B%BE%E7%89%871.png\" alt=\"Task State\" /><figcaption aria-hidden=\"true\">Task State</figcaption>\n</figure>\n<h2 id=\"running-state\">4.1 RUNNING-STATE</h2>\n<p>When the task is running, it is in the RUNNING-STATE.</p>\n<h2 id=\"blocked-state\">4.2 BLOCKED-STATE</h2>\n<p>BLOCKED-STATE is a sub-state of NOT-RUNNING STATE. Tasks can enter the BLOCKED-STATE to wait for two different types of event: Temporal Event &amp; Synchronization Events. While in this state, tasks are not able to run, so cannot be selected by the scheduler.</p>\n<h2 id=\"suspended-state\">4.3 SUSPENDED-STATE</h2>\n<p>SUSPENDED-STATE is a sub-state of NOT-RUNNING STATE.</p>\n<h2 id=\"ready-state\">4.4 READY-STATE</h2>\n<p>READY-STATE is a sub-state of NOT-RUNNING STATE.</p>\n<h1 id=\"event\">5. Event</h1>\n<p>Event is also called Interrupt. It is originated by the environment and force the embedded system to take action in response to it.</p>\n<h1 id=\"event-drive-task\">6. Event-drive task</h1>\n<p>Event-drive task has work after the event that triggers it, and is not able to enter the RUNNING-STATE before that event has occurred.</p>\n<h1 id=\"semaphores\">7. Semaphore(s)</h1>\n<ol type=\"1\">\n<li>Binary Semaphore</li>\n<li>Counting Semaphore</li>\n</ol>\n<h1 id=\"queues\">8. Queue(s)</h1>\n<p>Queue provides a task-to-task, task-to-interrupt, interrupt-to-task communication mechanism.</p>\n<h1 id=\"event-groups\">9. Event Group(s)</h1>\n<p>Event groups are another feature of FreeRTOS that allow events to be communicated to tasks.</p>\n<h1 id=\"isr\">10. ISR</h1>\n<p>Interrupt Service Routine. It is a software process invoked by an interrupt request from a hardware device. It handles the request and sends it to the CPU, interrupting the active process. When the ISR is complete, the process is resumed.</p>\n<h1 id=\"task-eventinterrupt\">11. Task &amp; Event(Interrupt)</h1>\n<p>A task is a software feature that is unrelated to the hardware on which FreeRTOS is running. The priority of a task is assigned in software by the application writer, and a software algorithm (the scheduler) decides which task will be in the Running state.</p>\n<p>Although written in software, an interrupt service routine is a hardware feature because the hardware controls which interrupt service routine will run, and when it will run. Tasks will only run when there are no ISRs running, so the lowest priority interrupt will interrupt the highest priority task, and there is no way for a task to pre-empt an ISR.</p>\n<h1 id=\"reference\">Reference</h1>\n<ol type=\"1\">\n<li>&lt;<a href=\"https://freertos.org/Documentation/RTOS_book.html\">FreeRTOS Documentation</a>&gt;</li>\n<li>&lt;<a href=\"https://freertos.org/a00106.html\">API</a>&gt;</li>\n</ol>\n","categories":["InternetOfThings"],"tags":["FreeRTOS","Task","Event"]},{"title":"ARM DEVELOP","url":"/2019/01/30/Hardware/STM32/2019-01-30-ARM%20DEVELOP/","content":"<h1 id=\"cross-compilers\">CROSS COMPILERS</h1>\n<p>ARM交叉编译工具有多个版本，注意区分。</p>\n<blockquote>\n<ul>\n<li>abi(application binary interface): 二进制程序接口</li>\n<li>eabi(embedded): 嵌入式二进制程序接口</li>\n<li>arm-none-eabi: 无操作系统，不支持系统调用的函数，如fork等。其使用专用于嵌入式开发的C程序库。</li>\n<li>arm-none-linux-eabi: 用于linux，使用glibc。</li>\n</ul>\n</blockquote>\n<p>GCC编译器</p>\n<blockquote>\n<ul>\n<li>arm-none-eabi-gcc: 编译裸机程序或系统，适用于ARM7/Cortex-M/Cortex-R，可调用newlib库。</li>\n<li>arm-none-linux-gnueabi-gcc: 编译ARM架构的Linux程序，有uboot/linux kernel/linux应用，适用于ARM9/ARM11/Cortex-A。</li>\n<li>arm-linux-gnueabi-gcc: 适用于armel架构(与armhf有浮点运算间的差异)。</li>\n<li>arm-linux-gnueabihf-gcc: 适用于armhf架构。</li>\n<li>arm-eabi-gcc: android编译器。</li>\n<li>armcc: 功能同arm-none-eabi-gcc，Keil MDK内置，收费。</li>\n</ul>\n</blockquote>\n<h1 id=\"debug-and-flash\">DEBUG AND FLASH</h1>\n<h2 id=\"debug\">DEBUG</h2>\n<p>STM32支持<strong>ISP</strong>和<strong>JTAG/SWD</strong>两种调试方式。</p>\n<blockquote>\n<p>In-System Programmability，即在线系统编程。使用时需要先设置 <strong>BOOT0</strong> 和 <strong>BOOT1</strong> 两脚，然后通过串口 1进行程序烧写，烧写的软件为<strong>Flash_Loader_Demonstrator</strong>。此方法的好处是，可以无需外加编程口，但是只可以烧写程序，无法进行在线仿真。</p>\n<p>JTAG，全称为Joint Test Action Group，联合测试工作组。是一种国际标准测试协议 (IEEE 1149.1兼容)， 主要用于芯片内部测试，早在ARM7上面就已经使用了JTAG作为调试和下载口。</p>\n<p>而SWD模式比JTAG 在高速模式下面更加可靠。 在大数据量的情况下面JTAG下载程序会失败, 但是SWD 发生的几率会小很多。基本使用JTAG仿真模式的情况下是可以直接使用SWD模式的。</p>\n<p>与 ISP 相比，SWD接口可以与大多数IDE完美兼容，比如IAR，并且可以通过IAR和调试器，进行程序的在线调试，这种调试方法可以直接追踪到当前代码处的各变量状态，寄存器状态等等。</p>\n</blockquote>\n<h2 id=\"flash\">FLASH</h2>\n<blockquote>\n<ul>\n<li><p>J-Link是SEGGER公司为支持仿真ARM内核芯片推出的仿真调试工具，支持JTAG和SWD两种模式进行调试。</p></li>\n<li><p>ULINK是由Keil推出的ARM芯片仿真调试工具，是Keil下默认的调试工具，缺点是不支持IAR。ULINK官方提供电路图等资料（半开源资料），可以自行制作仿真调试电路工具。</p></li>\n<li><p>ST-LINK是由意法半导体开发的仿真调试工具。 (ST-LINKV2)适用于STM32与STM8。与STM32连接时支持JTAG与SWD模式，与STM8连接时支持SWIM模式。</p></li>\n</ul>\n</blockquote>\n<h1 id=\"arm-ide\">ARM IDE</h1>\n<h1 id=\"参考材料\">参考材料</h1>\n<ol type=\"1\">\n<li><a href=\"https://en.wikipedia.org/wiki/STMicroelectronics\">意法半导体</a></li>\n<li><a href=\"http://bbs.eeworld.com.cn/thread-431094-1-1.html\">提问+J-LINK、U-LINK和ST-LINK有什么区别？</a></li>\n<li><a href=\"https://www.eefocus.com/component/m/398663\">JTAG与JLink有啥不同？看完这个你就知道了</a></li>\n</ol>\n","categories":["InternetOfThings"],"tags":["STM32","IAR","IDE"]},{"title":"Optical Sensor Development","url":"/2022/01/11/Hardware/STM32/2022-01-11-%E5%85%89%E7%94%B5%E4%BC%A0%E6%84%9F%E5%99%A8/","content":"<h1 id=\"基础技能\">基础技能</h1>\n<ol type=\"1\">\n<li>ARM架构芯片的样例代码加载、编译、烧录、调试工作熟悉。</li>\n<li>bitbucket 如何使用（是否需要配置SSH、repository如何pull和push、add、commit等） √</li>\n<li>confluence 如何使用（任务的查看、提交、文章的发布、协作等等）</li>\n</ol>\n<h1 id=\"ide-for-realtek\">IDE for Realtek</h1>\n<h2 id=\"vscode-arm\">VSCODE ARM</h2>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220112105541195.png\" alt=\"image-20220112105541195\" /><figcaption aria-hidden=\"true\">image-20220112105541195</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220112110410253.png\" alt=\"image-20220112110410253\" /><figcaption aria-hidden=\"true\">image-20220112110410253</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220112110533598.png\" alt=\"image-20220112110533598\" /><figcaption aria-hidden=\"true\">image-20220112110533598</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220112110507665.png\" alt=\"image-20220112110507665\" /><figcaption aria-hidden=\"true\">image-20220112110507665</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220112105734831.png\" alt=\"image-20220112105734831\" /><figcaption aria-hidden=\"true\">image-20220112105734831</figcaption>\n</figure>\n<h2 id=\"keil-arm\">KEIL ARM</h2>\n<p>将Realtek RTL8762D SDK中的项目单独摘出来，放到某个文件夹下进行管理时，需要单独更改好几处内容：</p>\n<ol type=\"1\">\n<li>C/C++的Include Path</li>\n<li>源文件的Source Path</li>\n<li>APP Image（<code>.bin</code> 生成文件），即 <code>after_build_common.bat</code> 的路径和内容。</li>\n</ol>\n<p>如下所示，把单独某个Project摘出来时会产生很多感叹号。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220112111951120.png\" alt=\"image-20220112111951120\" /><figcaption aria-hidden=\"true\">image-20220112111951120</figcaption>\n</figure>\n<h3 id=\"头文件路径修改\">头文件路径修改</h3>\n<p>此时需要进入设置中进行头文件路径修改</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220112133356533.png\" alt=\"image-20220112133356533\" /><figcaption aria-hidden=\"true\">image-20220112133356533</figcaption>\n</figure>\n<p>选择 <code>C/C++</code> 选项卡下的 <code>Include Paths</code> 进行修改。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220112133505056.png\" alt=\"image-20220112133505056\" /><figcaption aria-hidden=\"true\">image-20220112133505056</figcaption>\n</figure>\n<p>原来的路径设置都是使用相对路径进行的，此时需要将 <code>sbee2-sdk-v1.0.0</code> 文件夹放到与你项目文件同盘的某个文件夹下，最好不要相距太远。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220112133731688.png\" alt=\"image-20220112133731688\" /><figcaption aria-hidden=\"true\">image-20220112133731688</figcaption>\n</figure>\n<p>可以使用 VS Code将 <code>.uvprojx</code> 文件打开，使用搜索和替换工具对相关头文件的路径进行替换。</p>\n<h3 id=\"源文件路径修改\">源文件路径修改</h3>\n<p>修改方法同头文件，</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220117094508419.png\" alt=\"image-20220117094508419\" /><figcaption aria-hidden=\"true\">image-20220117094508419</figcaption>\n</figure>\n<h3 id=\"bat文件路径修改\">bat文件路径修改</h3>\n<p><code>.bat</code> 文件是用于在 <code>.o</code> 文件生成后的链接脚本。所以如果该脚本自身路径和脚本内的包含路径出错，可能会导致无法编译出对应的 <code>app_MP_adk#####</code> 文件。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220117095506866.png\" alt=\"image-20220117095506866\" /><figcaption aria-hidden=\"true\">image-20220117095506866</figcaption>\n</figure>\n<p>下方为样例代码原来的设置情况：</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220120134642405.png\" alt=\"image-20220120134642405\" /><figcaption aria-hidden=\"true\">image-20220120134642405</figcaption>\n</figure>\n<p>在 <code>Option-User</code> 设置中，可以查看到 <code>After Build/Rebuild</code> 相关的设置，其中 <code>Run #1</code> 则是 Realtek MP Tools 需要烧录 EVB开发板相关的脚本文件。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220117095438927.png\" alt=\"image-20220117095438927\" /><figcaption aria-hidden=\"true\">image-20220117095438927</figcaption>\n</figure>\n<p>将单独摘放出来的项目文件夹 <code>pixart_i2c</code> 与 <code>sbee2-sdk-v1.0.0</code> 和 <code>sbee2_wristband_sdk_upperstack_img</code> 放到同一个文件夹下。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220117110446703.png\" alt=\"image-20220117110446703\" /><figcaption aria-hidden=\"true\">image-20220117110446703</figcaption>\n</figure>\n<p>因此修改 <code>.uvprojx</code> 文件内容下 <code>after_build_common.bat</code> 的路径时，将该路径修改为如下的相对路径即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">..\\sbee2-sdk-v1.0.0\\tool\\after_build_common.bat <span class=\"variable\">$J</span> <span class=\"comment\">#L @L</span></span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220117104943624.png\" alt=\"image-20220117104943624\" /><figcaption aria-hidden=\"true\">image-20220117104943624</figcaption>\n</figure>\n<p>保存修改后的 <code>.uvprojx</code> 文件，可以看到 Keil V5 自动更新了相关设置。如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220117104955125.png\" alt=\"image-20220117104955125\" /><figcaption aria-hidden=\"true\">image-20220117104955125</figcaption>\n</figure>\n<p><code>after_build_common.bat</code> 控制着自动生成Realtek 的 MP Tool 需要使用的 APP Bin文件，如果该 <code>Run #1</code> 没有启用，则无法生产该文件。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220117105247314.png\" alt=\"image-20220117105247314\" /><figcaption aria-hidden=\"true\">image-20220117105247314</figcaption>\n</figure>\n<p>该<code>.bat</code> 文件下所有的 <code>..\\..\\..\\tool\\</code> 都要修改成 <code>..\\sbee2-sdk-v1.0.0\\tool\\</code>，如果项目文件夹和SDK文件夹路径有异，则需要适当修改。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220117105040885.png\" alt=\"image-20220117105040885\" /><figcaption aria-hidden=\"true\">image-20220117105040885</figcaption>\n</figure>\n<p>启用完成之后即可生成对应 <code>app_MP_adk#####</code> 文件</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220117105414578.png\" alt=\"image-20220117105414578\" /><figcaption aria-hidden=\"true\">image-20220117105414578</figcaption>\n</figure>\n<h1 id=\"hardwares\">HARDWARES</h1>\n<h2 id=\"adapter\">ADAPTER</h2>\n<h3 id=\"specification\">SPECIFICATION</h3>\n<p>A4芯片，即KA8G2芯片用的转接板需要接入5V电压，LDO会转换电压。</p>\n<p>而PAT9126JA芯片则使用两个3.3V进行接入。</p>\n<h2 id=\"chip-board\">CHIP &amp; BOARD</h2>\n<p>开发测试板为 Realtek RTL8762D EVB KIT。</p>\n<p>型号： RTL8762DW</p>\n<h2 id=\"sensor---ka8g2\">SENSOR - KA8G2</h2>\n<blockquote>\n<p><strong><em>KAG2</em></strong> is a high performance and ultra low power <strong><em>CMOS-processed optical image sensor</em></strong> with <em>integrated digital image process circuits</em>. It is based on an optical navigation technology which measures changes in position by optically acquiring sequential surface images(frames) and mathematically determining the speed, the direction and the magnitude of motion. <strong><em>The displacement delta_X and delta_Y information are available in registers which are accessible through SPI serial interface.</em></strong> A host controller reads and translates the data from the SPI serial interface into RF signals before sending them to the host PC.</p>\n</blockquote>\n<h3 id=\"specification-1\">SPECIFICATION</h3>\n<p><img src=\"https://pic.islet.space/2022/01/image-20220113150323525.png\" alt=\"image-20220113150323525\" style=\"zoom:50%;\" /></p>\n<h3 id=\"hardware-linking\">HARDWARE LINKING</h3>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220112172532934.png\" alt=\"image-20220112172532934\" /><figcaption aria-hidden=\"true\">image-20220112172532934</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16391255852712.png\" alt=\"企业微信截图_16391255852712\" /><figcaption aria-hidden=\"true\">企业微信截图_16391255852712</figcaption>\n</figure>\n<h3 id=\"chip-initiate\">CHIP INITIATE</h3>\n<p>这个芯片启动时，需要对一些寄存器进行写入以初始化。下方为二维数组，<code>sensor_init_regs[][0]</code> 为寄存器地址，<code>sensor_init_regs[][1]</code> 为寄存器需要写入的数据。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uint8_t</span> sensor_init_regs[<span class=\"number\">7</span>][<span class=\"number\">2</span>] = &#123;</span><br><span class=\"line\">\t&#123;<span class=\"number\">0X09</span>, <span class=\"number\">0XA5</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"number\">0X26</span>, <span class=\"number\">0X34</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"number\">0X19</span>, <span class=\"number\">0X04</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"number\">0X6D</span>, <span class=\"number\">0X39</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"number\">0X0D</span>, <span class=\"number\">0X20</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"number\">0X0E</span>, <span class=\"number\">0X20</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"number\">0X09</span>, <span class=\"number\">0X00</span>&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>初始化时，需要注意以下问题：</p>\n<ol type=\"1\">\n<li>某些主控芯片在使用两线SPI进行数据写入时，会有要求使用 <code>7bit</code> 地址，且 MSB 为 <code>1</code> 。此时需要判断是否需要认为修改地址的 MSB为 <code>1</code> ，例如 Realtek 的 RTL8762DW 芯片就不需要人为修改，人为修改会导致波形异常。而某些芯片需要人为写入MSB。</li>\n<li>在每一次写入寄存器之后，<mark style=\"font-weight: 900;\">强烈建议进行延时</mark>，可以使用 <code>delay(0xFFFF)</code>，（尝试过 <code>0xFF</code> 太短，不能完成初始化写入）。</li>\n</ol>\n<h2 id=\"sensor---pat9126ja\">SENSOR - PAT9126JA</h2>\n<ol type=\"1\">\n<li>需要确定 <code>ID_SEL</code> 引脚的连接情况，是拉高、接地还是悬空。分别对应的 <code>CHIP ID</code> 都是不一样的，可能是<code>0x73</code>  <code>0x75</code>  <code>0x79</code> 三者之一。</li>\n</ol>\n<p>transformer 上的 <code>VCC</code> 为 <code>3.3V</code></p>\n<h3 id=\"specification-2\">SPECIFICATION</h3>\n<p>这个芯片有两种电压要求，默认为高电压版本 <code>3.3V</code> ，可以通过SPI写入寄存器和硬件并线来达到降低至 <code>1.8V</code> 低电压的模式。</p>\n<h3 id=\"hadware-linking\">HADWARE LINKING</h3>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/OpticalSensorTransfer_I2C.png\" alt=\"OpticalSensorTransfer_I2C\" /><figcaption aria-hidden=\"true\">OpticalSensorTransfer_I2C</figcaption>\n</figure>\n<h1 id=\"sdk-tools\">SDK &amp; Tools</h1>\n<p>此处有 2个SDK包 和 3个tool包，分别是：</p>\n<ol type=\"1\">\n<li><a href=\"https://storage.islet.space/07_Mixosense/01_Realtek/RTL8762D/SDK/sbee2-sdk-v1.0.0.zip\">sbee2-sdk-v1.0.0.zip</a></li>\n<li><a href=\"https://storage.islet.space/07_Mixosense/01_Realtek/RTL8762D/SDK/sbee2_wristband_sdk_upperstack_img.zip\">sbee2_wristband_sdk_upperstack_img.zip</a></li>\n<li><a href=\"https://storage.islet.space/07_Mixosense/01_Realtek/RTL8762D/SDK/MPPackTool_v2.0.5.2.zip\">MPPackTool_v2.0.5.2.zip</a></li>\n<li>日志输出软件：<a href=\"https://storage.islet.space/07_Mixosense/01_Realtek/RTL8762D/SDK/DebugAnalyzer-v4.0.0.14.zip\">DebugAnalyzer-v4.0.0.14.zip</a></li>\n<li>代码烧录软件：<a href=\"https://storage.islet.space/07_Mixosense/01_Realtek/RTL8762D/SDK/BeeMPTool_kits_v1.0.5.0.zip\">BeeMPTool_kits_v1.0.5.0.zip</a></li>\n</ol>\n<h1 id=\"build-flash-log\">BUILD / FLASH / LOG</h1>\n<h2 id=\"build\">BUILD</h2>\n<p>点击 <code>build</code> 按钮即可进行代码构建。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220113090856565.png\" alt=\"image-20220113090856565\" /><figcaption aria-hidden=\"true\">image-20220113090856565</figcaption>\n</figure>\n<p><code>build</code> 完毕之后可以看到下方的成功提示 <code>0 Error(s), 0 Warning(s)</code>。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220113091008941.png\" alt=\"image-20220113091008941\" /><figcaption aria-hidden=\"true\">image-20220113091008941</figcaption>\n</figure>\n<h2 id=\"flash\">FLASH</h2>\n<p>FLAHS需要经过 configuration 、 detect 和 download 三步</p>\n<h3 id=\"configuration\">configuration</h3>\n<p>根据《RTL8762D SDK User Guide CN》文件，RTL8762D 的 EVB KIT 是可以支持 JLINK 的（如下图所示）。</p>\n<p><img src=\"https://pic.islet.space/2022/01/image-20220113095321215.png\" alt=\"image-20220113095321215\" style=\"zoom:50%;\" /></p>\n<p>但这里并未使用 JLINK，而是使用 Realtek 专门的工具 <code>BeeMPTool_kits</code>， 通过 <code>UART</code> 进行烧录。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220113095804076.png\" alt=\"image-20220113095804076\" /><figcaption aria-hidden=\"true\">image-20220113095804076</figcaption>\n</figure>\n<p>打开 <code>MPTool.exe</code> ，并选中对应的芯片型号 <code>RTL8762D</code> ：</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220113095854784.png\" alt=\"image-20220113095854784\" /><figcaption aria-hidden=\"true\">image-20220113095854784</figcaption>\n</figure>\n<p>在这里选择 <code>调试</code> 模式进行烧录</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220113095949881.png\" alt=\"image-20220113095949881\" /><figcaption aria-hidden=\"true\">image-20220113095949881</figcaption>\n</figure>\n<p>在 <code>Config Set</code> 中选择 <code>Confirm</code> ，不需要修改什么东西。</p>\n<p><img src=\"https://pic.islet.space/2022/01/image-20220113100100098.png\" alt=\"image-20220113100100098\" style=\"zoom:50%;\" /></p>\n<p>此处需要设置 Flash 地址映射文件 <code>flash map.ini</code> 。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220113100324900.png\" alt=\"image-20220113100324900\" /><figcaption aria-hidden=\"true\">image-20220113100324900</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220113101953154.png\" alt=\"image-20220113101953154\" /><figcaption aria-hidden=\"true\">image-20220113101953154</figcaption>\n</figure>\n<p>下方为 《RTL8762D SDK User Guide CN》文件中，9.1章节对五个images文件进行了描述。</p>\n<p><img src=\"https://pic.islet.space/2022/01/image-20220113102036834.png\" alt=\"image-20220113102036834\" style=\"zoom:67%;\" /></p>\n<table>\n<colgroup>\n<col style=\"width: 22%\" />\n<col style=\"width: 32%\" />\n<col style=\"width: 45%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>FILE TYPE</th>\n<th>DESCRIPTION</th>\n<th>FILE PATH</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>System Config File</td>\n<td>- 来自 <code>BeeMPTool_kits</code></td>\n<td><code>\\BeeMPTool_kits_v1.0.5.0\\BeeMPTool\\ConfigFile\\</code></td>\n</tr>\n<tr class=\"even\">\n<td>Bank0 OTA Header File</td>\n<td>- 来自 <code>sbee2_wristband_sdk_upperstack_img</code></td>\n<td><code>\\sbee2_wristband_sdk_upperstack_img\\src\\app\\wristband\\firmware\\</code></td>\n</tr>\n<tr class=\"odd\">\n<td>Bank0 Secure Boot Loader Image</td>\n<td>- 来自 <code>sbee2_wristband_sdk_upperstack_img</code></td>\n<td><code>\\sbee2_wristband_sdk_upperstack_img\\src\\app\\wristband\\firmware\\</code></td>\n</tr>\n<tr class=\"even\">\n<td>Bank0 ROM Patch Image</td>\n<td>- 来自 <code>sbee2_wristband_sdk_upperstack_img</code></td>\n<td><code>\\sbee2_wristband_sdk_upperstack_img\\src\\app\\wristband\\firmware\\</code></td>\n</tr>\n<tr class=\"odd\">\n<td>Bank0 APP Image</td>\n<td>- 来自 <code>sbee2-sdk-v1.0.0</code></td>\n<td><code>sbee2-sdk-v1.0.0\\board\\evb\\io_sample\\SPI3WIRE\\spi3wire_polling\\bin</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"关于app-image文件选择\">关于app image文件选择</h4>\n<p>在Build完成后，会生成三个 <code>.bin</code> 文件，如果选择错误，会提示 <code>MD5 check error!Image type doesn't match IC type.</code> ，选择正确的话会提示 <code>File check OK</code> 。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220113111301561.png\" alt=\"image-20220113111301561\" /><figcaption aria-hidden=\"true\">image-20220113111301561</figcaption>\n</figure>\n<h3 id=\"detect\">detect</h3>\n<p>detect 的时候需要注意：</p>\n<ol type=\"1\">\n<li>将 EVB kit上的 <code>J15</code> LOG口接地，否则会检测失败</li>\n<li>如果出现 <code>Failed</code> 字样，则按一下 EVB KIT 上的红色的 <code>RESET</code> 按钮进行复位后再尝试。</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220113111054035.png\" alt=\"image-20220113111054035\" /><figcaption aria-hidden=\"true\">image-20220113111054035</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220113103853161.png\" alt=\"image-20220113103853161\" /><figcaption aria-hidden=\"true\">image-20220113103853161</figcaption>\n</figure>\n<h3 id=\"download\">download</h3>\n<p>最后选择 <code>download</code> 下载即可。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220113104047601.png\" alt=\"image-20220113104047601\" /><figcaption aria-hidden=\"true\">image-20220113104047601</figcaption>\n</figure>\n<h2 id=\"upperstack-flash\">UPPERSTACK FLASH</h2>\n<p>自带的 <code>\\sbee2-sdk-v1.0.0\\doc\\</code> 路径下的教程是，都是有 <code>Bank0 Upperstack Image</code> 需要烧录的。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220120140307997.png\" alt=\"image-20220120140307997\" /><figcaption aria-hidden=\"true\">image-20220120140307997</figcaption>\n</figure>\n<p>步骤如下：</p>\n<ol type=\"1\">\n<li><p>使用 <code>\\sbee2_wristband_sdk_upperstack_img\\src\\app\\wristband\\firmware\\upperstack_img</code> 路径下的 <code>.ini</code> 文件作为 layout 文件。（而之前使用的<code>flash map.ini</code> 地址为 <code>\\sbee2_wristband_sdk_upperstack_img\\src\\app\\wristband\\firmware\\</code>）</p></li>\n<li><p>指定 <code>\\sbee2_wristband_sdk_upperstack_img\\src\\app\\wristband\\firmware\\upperstack_img</code> 路径下的 <code>.bin</code> 文件作为 Upperstack Image 文件。</p></li>\n<li><p>将 <code>\\sbee2_wristband_sdk_upperstack_img\\board\\evb_stack_img\\wristband\\flash_map.h</code> 文件作为项目工程里的唯一内存映射文件依赖。<code>flash_map.h</code> 被放在 <code>mem_config.h</code> 头文件下，间接被 <code>syetem_rtl876x.h</code> 引用。</p></li>\n</ol>\n<h2 id=\"log\">LOG</h2>\n<p>RTL8762D 的 EVB KIT 不支持 JTAG 方式进行观察，（听说是）通信过程容易被打断。</p>\n<p>这里使用 <code>UART</code> 和 EVB KIT 上的 <code>J15</code> 口来观察 LOG数据。</p>\n<h3 id=\"log软件\">LOG软件</h3>\n<p>使用专用工具 <code>DebugAnalyzer</code> 进行日志输出。</p>\n<ol type=\"1\">\n<li>选择合适的串口，即使用 <code>FT232</code> 的UART口，将该芯片口的 <code>RX</code> 连接至 <code>RTL8762D</code> 板子上的 <code>J15</code> 口。并在电脑中选中对应的 <code>FT232</code> 设备。</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220113093030488.png\" alt=\"image-20220113093030488\" /><figcaption aria-hidden=\"true\">image-20220113093030488</figcaption>\n</figure>\n<ol start=\"2\" type=\"1\">\n<li>需要设置 <code>App Trace File</code> 。</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220113093723962.png\" alt=\"image-20220113093723962\" /><figcaption aria-hidden=\"true\">image-20220113093723962</figcaption>\n</figure>\n<ol start=\"3\" type=\"1\">\n<li>观察日志输出</li>\n</ol>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220113104331739.png\" alt=\"image-20220113104331739\" /><figcaption aria-hidden=\"true\">image-20220113104331739</figcaption>\n</figure>\n<h1 id=\"com-setting\">COM SETTING</h1>\n<h2 id=\"uart-setting\">UART SETTING</h2>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220113111953878.png\" alt=\"image-20220113111953878\" /><figcaption aria-hidden=\"true\">image-20220113111953878</figcaption>\n</figure>\n<h1 id=\"peripheral\">PERIPHERAL</h1>\n<h1 id=\"wired-spi\">3-WIRED SPI</h1>\n<p>以下是主控板 RTL8762D 的SDK对3线SPI的相关设置结构体。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> SPI3WIRE_SysClock;     <span class=\"comment\">/*!&lt; Specifies system clock */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> SPI3WIRE_Speed;        <span class=\"comment\">/*!&lt; Specifies SPI clock. */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> SPI3WIRE_Mode;         <span class=\"comment\">/*!&lt; Specifies SPI operation mode.</span></span><br><span class=\"line\"><span class=\"comment\">                                This parameter can be a value of @ref THREE_WIRE_SPI_mode */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> SPI3WIRE_ReadDelay;    <span class=\"comment\">/*!&lt; Specifies the delay time from the end of address phase to the start of read data phase.</span></span><br><span class=\"line\"><span class=\"comment\">                                    This parameter can be a value of 0x0 to 0x1f, delay time = (SPI3WIRE_ReadDelay+1)/(2*SPI3WIRE_Speed) */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> SPI3WIRE_OutputDelay;  <span class=\"comment\">/*!&lt; Specifies SPI output delay 1T or not.</span></span><br><span class=\"line\"><span class=\"comment\">                                 This parameter can be a value of @ref THREE_WIRE_SPI_OE_delay_config */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> SPI3WIRE_ExtMode;      <span class=\"comment\">/*!&lt; Specifies extended timing window for SPI output enable = 0. */</span></span><br><span class=\"line\">&#125; SPI3WIRE_InitTypeDef;</span><br></pre></td></tr></table></figure>\n<h2 id=\"writing-delay\">WRITING-DELAY</h2>\n<p><span class=\"math display\">\\[\n1s = 1^3ms = 1^6us = 1^9ns\\\\\n1Hz = 1^{-3}KHz = 1^{-6}MHz = 1^{-9}GHz\n\\]</span></p>\n<p>在3线SPI的数据线读取过程中，在前一段地址帧结束且尚未开始读取数据前，会有一段延时。由 <code>spiReadDelay</code> 和 <code>spiWireSpeed</code> 两个参数控制。 <span class=\"math display\">\\[\nDelayTime = (spiReadDelay +1) / (2* spiWireSpeed)\n\\tag{延时计算公式}\n\\]</span> 例如， 当 <code>spiWireSpeed = 8e5</code> 时， 设置 <code>spiReadDelay = 0x03</code> ，此时 可以在中间延时 <code>2.5us</code> 。</p>\n<h2 id=\"clock_freq\">CLOCK_FREQ</h2>\n<p>将RTL8762D的SPI通信时钟频率从 <code>2E7</code> 更改为 <code>1E6</code> 后可以短时间正常通信，但是稍微过一段时间就出现了不稳定，度数全为 <code>0</code> ，且复位后读取的 <code>chipID</code> 也为 <code>0x00, 0x00</code> 。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// the actual frequency of spi is set by `SPI3_WIRE_SysClock`</span></span><br><span class=\"line\"><span class=\"comment\">// `1E6` means 1MHz, and `2E7` means 20MHz.</span></span><br><span class=\"line\">SPI3WIRE_InitStruct.SPI3WIRE_SysClock       = <span class=\"number\">1E6</span>;</span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220119152741283.png\" alt=\"image-20220119152741283\" /><figcaption aria-hidden=\"true\">image-20220119152741283</figcaption>\n</figure>\n<h2 id=\"timing\">TIMING</h2>\n<p><span class=\"math display\">\\[\nSysclk = 1e7 \\\\\nwirespeek = 8e5\n\\]</span></p>\n<h1 id=\"wired-spi-1\">2-WIRED SPI</h1>\n<blockquote>\n<p>To recover the correct communication of SPI, the host controller can de-assert the SCLK for at least tRESYNC (1us min), and then keep SCLK asserted for a certain time interval tWDT (1.7ms, min) as shown in below Figure . to force the SPI control circuits of the sensor to reset.</p>\n</blockquote>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220120154724619.png\" alt=\"image-20220120154724619\" /><figcaption aria-hidden=\"true\">image-20220120154724619</figcaption>\n</figure>\n<h1 id=\"debug-records\">DEBUG RECORDS</h1>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220112163300158.png\" alt=\"image-20220112163300158\" /><figcaption aria-hidden=\"true\">image-20220112163300158</figcaption>\n</figure>\n<p>0x05 // 0000 0101</p>\n<p>// 1000 0101</p>\n<h2 id=\"delta_x-delta_y-unread\">DELTA_X &amp; DELTA_Y UNREAD</h2>\n<p><code>Motion</code>  <code>DYOVF</code>  <code>DXOVF</code> 并未读出，未检测到移动。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220114110802052.png\" alt=\"image-20220114110802052\" /><figcaption aria-hidden=\"true\">image-20220114110802052</figcaption>\n</figure>\n<p><code>Operation_Mode = 0xB8, cofiguration = 0x17</code> 均为默认</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220114111325286.png\" alt=\"image-20220114111325286\" /><figcaption aria-hidden=\"true\">image-20220114111325286</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220114111114776.png\" alt=\"image-20220114111114776\" /><figcaption aria-hidden=\"true\">image-20220114111114776</figcaption>\n</figure>\n<p><code>0xB8</code> 使 设备处于睡眠模式，<code>configuration = 0x17</code> 使设备未处于 <code>sleep3</code> 且 <code>powerDown</code> 为正常模式，即未断电。</p>\n<p>所以需要修改 <code>Operation_Mode</code> 为 <code>0x01</code> 。</p>\n<p>在设置了下方的语句之后，LOG记录传送回来的 <code>OperationMode</code> 对应的数据为 <code>0xFC</code> 或 <code>0xB8</code> （ <code>1111 1100</code> 和 <code>1011 1000</code>） 。</p>\n<p>默认情况下 <code>OperationMode</code> 为 <code>0xB8</code> 即 <code>1011 1000</code> 。</p>\n<p>异常情况下 <code>OperationMode</code> 为 <code>0xFC</code> 即 <code>1111 1100</code> 。</p>\n<p>即第 <code>2</code> 位和 第 <code>6</code> 位会变，查数据手册，<mark>只有第 <code>2</code> 位（<code>Slp2mu_Enh</code>）有影响，该位控制芯片强制进入 <code>睡眠2</code> 模式。</mark></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">spi3wire_writebyte(REG_KA8G2_OPERATION_MODE, KA8G2_OM_RUN);  <span class=\"comment\">// edited by liew in 20211114</span></span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220114135400211.png\" alt=\"image-20220114135400211\" /><figcaption aria-hidden=\"true\">image-20220114135400211</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220114135647079.png\" alt=\"image-20220114135647079\" /><figcaption aria-hidden=\"true\">image-20220114135647079</figcaption>\n</figure>\n<p>从《KA8G2 optical mouse sensor》中的 <strong>MOTION Pin Function</strong> 可以看出，<code>Motion</code> 寄存器即运动检测标志相关寄存器。</p>\n<p><img src=\"https://pic.islet.space/2022/01/image-20220114142319440.png\" alt=\"image-20220114142319440\" style=\"zoom:50%;\" /></p>\n<h2 id=\"主控板io口数据异常\">主控板IO口数据异常</h2>\n<p>下方为利用SDK进行 <strong>读数据</strong> 的相关操作：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">extern</span> <span class=\"keyword\">uint32_t</span> random_seed_value;</span><br><span class=\"line\">    srand(random_seed_value);</span><br><span class=\"line\">    spi3wire_demo();</span><br><span class=\"line\">\tDBG_DIRECT(<span class=\"string\">&quot;TEST_20220120&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">uint8_t</span> i = <span class=\"number\">0</span>; i&lt; <span class=\"number\">0xFF</span>; i++)&#123;\t</span><br><span class=\"line\">\t\t\tspi3wire_writebyte(<span class=\"number\">0x7F</span>, i);</span><br><span class=\"line\">\t\t\tdelaySys(<span class=\"number\">0xF</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并用逻辑分析仪进行捕获和分析，发现数据异常：</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220120151632286.png\" alt=\"image-20220120151632286\" /><figcaption aria-hidden=\"true\">image-20220120151632286</figcaption>\n</figure>\n<p>经过检查，发现时序解码无误，所有波形的高低和解码结果一致。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220120151645002.png\" alt=\"image-20220120151645002\" /><figcaption aria-hidden=\"true\">image-20220120151645002</figcaption>\n</figure>\n<p>但是相连的数据之间数据差异较大。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220120151638254.png\" alt=\"image-20220120151638254\" /><figcaption aria-hidden=\"true\">image-20220120151638254</figcaption>\n</figure>\n<p>查看LOG也发现数据的确有按照预定的逻辑进行循环：</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/20220120.png\" alt=\"20220120\" /><figcaption aria-hidden=\"true\">20220120</figcaption>\n</figure>\n<p>但是逻辑分析仪采出来的数据就是异常。</p>\n<p>经过分析，是因为逻辑分析仪的采样率为 <code>1MHz</code> ，与SPI外设的频率 <code>1e6</code> 一致。</p>\n<p>修改了逻辑分析仪的采样率为 <code>2MHz</code> ，提高了1倍，采样出来的逻辑就正常了。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220120162227888.png\" alt=\"image-20220120162227888\" /><figcaption aria-hidden=\"true\">image-20220120162227888</figcaption>\n</figure>\n<p>但是之前的项目只用了写数据的函数。示波器波形和逻辑分析仪都能正常。</p>\n<p>改了项目主循环中的语句为读数据之后，就出现异常了。</p>\n<h3 id=\"问题推断\">问题推断</h3>\n<p>通过注释部分语句，进行间歇性测试和波形观察。</p>\n<p>发现，spi读取语句 <code>uint8_t spi3wire_readbyte(uint8_t address)</code> 可能是波形不正常的原因。</p>\n<p>硬件查找主控板和底板的引脚问题：</p>\n<ol type=\"1\">\n<li>找到扩展板上的GPIO口对应核心板上的哪个口</li>\n<li>使用示波器探头直接接触对应的GPIO口并查看波形，查看主控板和底板之间是否存在问题。</li>\n</ol>\n<p>发现示波器探头从底板更换至主控板之后，示波器所显示波形并无差异。</p>\n","categories":["InternetOfThings"],"tags":["optical sensor"]},{"title":"STM32-NUCLEOL476RG DEVELOP","url":"/2022/01/22/Hardware/STM32/2022-01-22-STM32-NUCLEOL476RG-DEVELOP/","content":"<p>截止2022年1月23日，以下是ST公司的产品线，下图通过Flash大小和Nucleo类型对产品进行了一定划分。</p>\n<p><img src=\"https://pic.islet.space/2022/01/en.ln1847_stm32_nucleo.jpg\" alt=\"img\" style=\"zoom: 67%;\" /></p>\n<h1 id=\"necleo-l476rg-data-brief\">NECLEO-L476RG DATA BRIEF</h1>\n<p>Necleo系列开发板下面有很多型号，且每个型号的板子（除开芯片以外）设计应该都是大同小异的，所以最底层板子也就有了自己的型号。</p>\n<p>而 NecleoL476RG 开发板的底板型号为 <code>MB1136</code> 。且下方所有Necleo的产品都自带 ST-LINK/V2-1 调试器。</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220122193806691.png\" alt=\"image-20220122193806691\" /><figcaption aria-hidden=\"true\">image-20220122193806691</figcaption>\n</figure>\n<h2 id=\"st-linkv2-1\">ST-LINK/V2-1</h2>\n<p>支持USB软件 <strong>重新检查</strong>（re-enumeration） 、支持虚拟COM口、支持大容量储存、支持超过 <code>100mA</code> 电流的电源管理，但是不支持 <strong><em>SWIM</em></strong> 接口且最小输入电压为 <code>3V</code> 。</p>\n<p>注意：一旦激活了 ST-LINK/V2-1 的目标读出保护功能，就会阻止目标应用运行事后运行（prevents the target application from running afterward.）目标读出保护必须被关闭（must be kept disabled on board）。</p>\n<p>可以根据跳线帽的两种状态来使用 ST-LINK/V2-1:</p>\n<ul>\n<li>在线编程和调试STM32（Program/debug the on-board STM32），此时 <code>CN2</code> 的两个跳线帽都连接着，处于在线编程状态（默认）。</li>\n<li>使用连接到SWD连接器CN4的电缆对外部应用板中的MCU进行编程/调试，此时 <code>CN2</code> 的两个跳线帽都不连接，以允许 <code>CN4</code> （即 <code>SWD</code> 接口）连接至外部连接器。</li>\n</ul>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220123183857115.png\" alt=\"image-20220123183857115\" /><figcaption aria-hidden=\"true\">image-20220123183857115</figcaption>\n</figure>\n<h2 id=\"layout\">LAYOUT</h2>\n<p><img src=\"https://pic.islet.space/2022/01/image-20220123182028068.png\" alt=\"image-20220123182028068\" style=\"zoom:50%;\" /></p>\n<p><img src=\"https://pic.islet.space/2022/01/image-20220123182139437.png\" alt=\"image-20220123182139437\" style=\"zoom:50%;\" /></p>\n<h1 id=\"chip-breief\">CHIP BREIEF</h1>\n<p>STM32 Nucleo L476RG 所使用的芯片是 <code>STM32L476RGT6U</code>，其中 <code>L4</code> 是系列号，<code>76</code> 是产线，<code>R</code> 是指64pin，<code>C</code> 是指 256Kbytes 的 Flash内存大小。</p>\n<p>下方为《<a href=\"https://www.st.com/resource/en/data_brief/nucleo-l476rg.pdf\">STM32 Nucleo-64 boards data brief</a>》提供的 <strong>产品芯片命名方法</strong>：</p>\n<figure>\n<img src=\"https://pic.islet.space/2022/01/image-20220122195540612.png\" alt=\"image-20220122195540612\" /><figcaption aria-hidden=\"true\">image-20220122195540612</figcaption>\n</figure>\n<h1 id=\"reference\">REFERENCE</h1>\n<ol type=\"1\">\n<li><a href=\"https://www.st.com/en/evaluation-tools/nucleo-l476rg.html\">NUCLEO-L476RG</a></li>\n</ol>\n","categories":["InternetOfThings"],"tags":["stm32","nucleo","arm"]},{"title":"Firewalld防火墙详解","url":"/2021/05/13/Linux/Firewalld/2021-05-13-Firewalld%E9%98%B2%E7%81%AB%E5%A2%99%E8%AF%A6%E8%A7%A3/","content":"<p><a href=\"https://blog.51cto.com/andyxu/2137046\">blog.51cto.com</a></p>\n<p>众所周知，在RHEL7系统中，firewalld防火墙取代了iptables防火墙。我们都知道iptables的防火墙策略是交由内核层面的netfilter网络过滤器来处理的，而firewalld则是交由内核层面的nftables包过滤框架来处理。 相较于iptables防火墙而言，firewalld支持动态更新技术并加入了区域（zone）的概念。简单来说，区域就是firewalld预先准备了几套防火墙策略集合（策略模板），用户可以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。</p>\n<blockquote>\n<p>Firewalld provides a dynamically managed firewall with support for network/firewall zones to define the trust level of network connections or interfaces. It has support for IPv4, IPv6 firewall settings and for ethernet bridges and has <strong>a separation of runtime and permanent configuration options.</strong> It also supports an interface for services or applications to add firewall rules directly.</p>\n</blockquote>\n<h1 id=\"基本概念\">基本概念</h1>\n<h2 id=\"区域\">区域</h2>\n<p><strong>表1：firewalld中常用的区域名称及策略规则</strong></p>\n<table>\n<colgroup>\n<col style=\"width: 16%\" />\n<col style=\"width: 83%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>区域（zone）</th>\n<th>默认策略规则</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>trusted</td>\n<td>允许所有的数据包进出</td>\n</tr>\n<tr class=\"even\">\n<td>home</td>\n<td>拒绝进入的流量，除非与出去的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许进入</td>\n</tr>\n<tr class=\"odd\">\n<td>Internal</td>\n<td>等同于home区域</td>\n</tr>\n<tr class=\"even\">\n<td>work</td>\n<td>拒绝进入的流量，除非与出去的流量相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许进入</td>\n</tr>\n<tr class=\"odd\">\n<td>public</td>\n<td>拒绝进入的流量，除非与出去的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许进入</td>\n</tr>\n<tr class=\"even\">\n<td>external</td>\n<td>拒绝进入的流量，除非与出去的流量相关；而如果流量与ssh服务相关，则允许进入</td>\n</tr>\n<tr class=\"odd\">\n<td>dmz</td>\n<td>拒绝进入的流量，除非与出去的流量相关；而如果流量与ssh服务相关，则允许进入</td>\n</tr>\n<tr class=\"even\">\n<td>block</td>\n<td>拒绝进入的流量，除非与出去的流量相关</td>\n</tr>\n<tr class=\"odd\">\n<td>drop</td>\n<td>拒绝进入的流量，除非与出去的流量相关</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>These are the zones provided by firewalld sorted according to the default trust level of the zones <strong>from untrusted to trusted</strong>:</p>\n<p><strong>drop</strong> : Any incoming network packets are dropped, there is no reply. Only outgoing network connections are possible.</p>\n<p><strong>block</strong> : Any incoming network connections are rejected with an icmp-host-prohibited message for IPv4 and icmp6-adm-prohibited for IPv6. Only network connections initiated within this system are possible.</p>\n<p><strong>public</strong> : For use in public areas. You do not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.</p>\n<p><strong>external</strong> : For use on external networks with masquerading enabled especially for routers. You do not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.</p>\n<p><strong>dmz</strong> : For computers in your demilitarized zone that are publicly-accessible with limited access to your internal network. Only selected incoming connections are accepted.</p>\n<p><strong>work</strong> : For use in work areas. You mostly trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.</p>\n<p><strong>home</strong> : For use in home areas. You mostly trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.</p>\n<p><strong>internal</strong> : For use on internal networks. You mostly trust the other computers on the networks to not harm your computer. Only selected incoming connections are accepted.</p>\n<p><strong>trusted</strong> : All network connections are accepted.</p>\n</blockquote>\n<p><strong>动静态更新技术之间的区别</strong>：iptables每一个更改都需要先清除所有旧有的规则，然后重新加载所有的规则（包括新的和修改后的规则）；<mark>而firewalld任何规则的变更都不需要对整个防火墙规则重新加载</mark>。</p>\n<h2 id=\"配置\">配置</h2>\n<p>firewalld服务的主配置文件是firewalld.conf，防火墙策略的配置文件是以xml格式为主，存放在以下两个目录里。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">/etc/firewalld   # 用户配置文件</span><br><span class=\"line\">/usr/lib/firewalld    #系统配置文件，预定义配置文件</span><br></pre></td></tr></table></figure>\n<p>firewalld有基于CLI（命令行界面）和基于GUI（图形用户界面)两种管理方式，即：firewall-cmd（终端管理工具）和firewall-config（图形管理工具）。</p>\n<p>firewalld的参数一般都是以“长格式”来提供的，但是在RHEL7系统里支持部分命令的参数补齐，其中就包括firewall-cmd命令，也就是说可以用Tab键来补齐长格式参数，很酷吧。</p>\n<h2 id=\"命令\">命令</h2>\n<p><strong>表2：firewall-cmd命令中使用的参数以及作用</strong></p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>--get-default-zone</td>\n<td>查访默认的区域名称</td>\n</tr>\n<tr class=\"even\">\n<td>--set-default-zone=<区域名称></td>\n<td>设置默认的区域，使其永久生效</td>\n</tr>\n<tr class=\"odd\">\n<td>--get-zones</td>\n<td>显示可用的区域</td>\n</tr>\n<tr class=\"even\">\n<td>--get-services</td>\n<td>显示预定义的服务</td>\n</tr>\n<tr class=\"odd\">\n<td>--get-active-zones</td>\n<td>显示当前正在使用的区域、来源地址和网卡名称</td>\n</tr>\n<tr class=\"even\">\n<td>--add-source=</td>\n<td>将源自此IP或子网的流量导向指定的区域</td>\n</tr>\n<tr class=\"odd\">\n<td>--remove-source=</td>\n<td>不再将源自此IP或子网的流量导向这个区域</td>\n</tr>\n<tr class=\"even\">\n<td>--add-interface=<网卡名称></td>\n<td>将源自该网卡的所有流量都导向某个指定区域</td>\n</tr>\n<tr class=\"odd\">\n<td>--change-interface=<网卡名称></td>\n<td>将某个网卡与区域进行关联</td>\n</tr>\n<tr class=\"even\">\n<td>--list-all</td>\n<td>显示当前区域的网卡配置参数、资源、端口以及服务等信息</td>\n</tr>\n<tr class=\"odd\">\n<td>--list-all-zones</td>\n<td>显示所有区域的网卡配置参数、资源、端口以及服务等信息</td>\n</tr>\n<tr class=\"even\">\n<td>--add-service=<服务名></td>\n<td>设置默认区域允许该服务的流量</td>\n</tr>\n<tr class=\"odd\">\n<td>--add-port=<端口号/协议></td>\n<td>设置默认区域允许该端口的流量</td>\n</tr>\n<tr class=\"even\">\n<td>--remove-service=<服务名></td>\n<td>设置默认区域不再允许该服务的流量</td>\n</tr>\n<tr class=\"odd\">\n<td>--remove-port=<端口号/协议></td>\n<td>设置默认区域不再允许该端口的流量</td>\n</tr>\n<tr class=\"even\">\n<td>--reload</td>\n<td>让“永久生效”的配置规则立即生效，并覆盖当前的配置规则</td>\n</tr>\n<tr class=\"odd\">\n<td>--panic-on</td>\n<td>开启应急状况模式</td>\n</tr>\n<tr class=\"even\">\n<td>--panic-off</td>\n<td>关闭应急状况模式</td>\n</tr>\n</tbody>\n</table>\n<p>firewalld配置的防火墙策略默认为运行时（Runtime）模式，又称为当前生效模式，而且随着系统的重启会失效。如果想让配置策略一直存在，就需要使用永久（Permanent）模式了，方法就是在firewall-cmd命令后面添加--permanent参数，这样配置的防火墙策略就可以永久生效了。但是，永久生效模式有一个“不近人情”的特点，就是使用它设置的策略只有在系统重启后才会生效。如果想让配置的永久策略立即生效，需要手动执行firewall-cmd --reload命令。</p>\n<p><em>注：remove掉ssh服务或者ssh端口，当前远程登陆会话不会断开，退出后就无法远程连接了。</em></p>\n<p>firewalld服务启动、重启、停止</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl start firewalld</span><br><span class=\"line\">systemctl restart firewalld</span><br><span class=\"line\">systemctl stop firewalld</span><br></pre></td></tr></table></figure>\n<p>重新加载防火墙配置 <code>firewall-cmd --reload</code></p>\n<p>查看firewalld的运行状态 <code>firewall-cmd --state</code></p>\n<p>查看默认当前使用的区域 <code>firewall-cmd --get-default-zone</code></p>\n<p>查看系统默认活动区域名称、来源地址和关联的网卡 <code>firewall-cmd --get-active-zones</code></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/777d5cabb7eb51fbb84c7058129368d9.png\" alt=\"firewalld防火墙详解\" /><figcaption aria-hidden=\"true\">firewalld防火墙详解</figcaption>\n</figure>\n<p>查看所有可用区域 <code>firewall-cmd --get-zones</code></p>\n<p>查看区域的所有设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone&#x3D;internal --list-all   </span><br><span class=\"line\">firewall-cmd --list-all   </span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/4d9b1b3e6c45a33748d4892e6dd2736d.png\" alt=\"firewalld防火墙详解\" /><figcaption aria-hidden=\"true\">firewalld防火墙详解</figcaption>\n</figure>\n<blockquote>\n<p>Target：目标 icmp-block-inversion：ICMP协议类型黑白名单开关（yes/no） Interfaces：关联的网卡接口 sources：来源，可以是IP地址，也可以是mac地址 services：允许的服务 ports：允许的目标端口，即本地开放的端口 protocols：允许通过的协议 masquerade：是否允许伪装（yes/no），可改写来源IP地址及mac地址 forward-ports：允许转发的端口 source-ports：允许的来源端口 icmp-blocks：可添加ICMP类型，当icmp-block-inversion为no时，这些ICMP类型被拒绝；当icmp-block-inversion为yes时，这些ICMP类型被允许。 rich rules：富规则，即更细致、更详细的防火墙规则策略，它的优先级在所有的防火墙策略中也是最高的。</p>\n</blockquote>\n<h3 id=\"开始\">开始</h3>\n<p>查看所有预设的服务 <code>firewall-cmd --get-services</code> 此时将会列出/usr/lib/firewalld/services/目录中所有的服务名称。</p>\n<p>查看所有区域的设置 <code>firewall-cmd --list-all-zones</code></p>\n<p>查看指定网卡所在的区域 <code>firewall-cmd --get-zone-of-interface=ens32</code></p>\n<p>把firewalld的当前默认区域设置为drop，此为永久设置 <code>firewall-cmd --set-default-zone=drop</code></p>\n<p>把ens32网卡关联的区域修改为drop</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">firewall-cmd --permanent --zone&#x3D;drop --change-interface&#x3D;ens32   # 永久设置</span><br><span class=\"line\">firewall-cmd --zone&#x3D;drop --change-interface&#x3D;ens32   # 当前生效</span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/aafb80274a54961a3c0c1a50989b7fd3.png\" alt=\"firewalld防火墙详解\" /><figcaption aria-hidden=\"true\">firewalld防火墙详解</figcaption>\n</figure>\n<p>我们后面的设置命令将全部使用运行时模式，即当前生效模式。 将来自ens33网卡的流量都作用到默认的drop区域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone&#x3D;drop -add-interface&#x3D;ens33   # 作用在指定区域</span><br><span class=\"line\">firewall-cmd -add-interface&#x3D;ens33   # 作用在默认区域</span><br><span class=\"line\">firewall-cmd -remove-interface&#x3D;ens33  # 禁止ens33网卡作用在drop区域</span><br></pre></td></tr></table></figure>\n<p><em>注：不指定--zone参数的话，将会对默认区域进行设置</em> 启动关闭firewalld防火墙服务的应急状况模式，远程连接服务器时请慎用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">firewall-cmd --panic-on  </span><br><span class=\"line\">firewall-cmd --panic-off  </span><br><span class=\"line\">firewall-cmd --query-panic  </span><br></pre></td></tr></table></figure>\n<p>设置一个来源地址作用在drop区域上面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone&#x3D;drop --add-source&#x3D;192.168.1.12  # 作用在指定区域</span><br><span class=\"line\">firewall-cmd --add-source&#x3D;192.168.1.12  # 作用在默认区域</span><br><span class=\"line\">firewall-cmd --remove-source&#x3D;192.168.1.12  # 取消源IP为192.168.1.12的包作用在drop区域</span><br></pre></td></tr></table></figure>\n<p>说明：凡是IP为192.168.1.12发来包将会使用drop区域设置的规则</p>\n<p>对于一个接收到的请求具体使用哪个zone，firewalld是通过三种方式来判断的：</p>\n<p>1、source，来源地址 2、Interface，接收请求的网卡 3、firewalld配置的默认区域（zone）</p>\n<p>这三个方式的优先级按顺序依次降低，也就是说如果按照source可以找到就不会再按interface去找，如果前两个都找不到才会使用第三个默认区域。 查询drop区域是否允许请求ssh和https服务的流量</p>\n<h3 id=\"常用命令\">常用命令</h3>\n<p>在drop区域开放https服务 <code>firewall-cmd --zone=drop --add-service=https</code></p>\n<p>取消开放https服务，即禁止https服务 <code>firewall-cmd --zone=drop --remove-service=https</code></p>\n<p>开放22端口 <code>firewall-cmd --zone=drop --add-port=22/tcp</code></p>\n<p>取消开放22端口 <code>firewall-cmd --zone=drop --remove-port=22/tcp</code></p>\n<p>开放8080和8081端口 <code>firewall-cmd --zone=drop --add-port=8080-8081/tcp</code></p>\n<p><strong>查询drop区域开放了哪些端口</strong> <code>firewall-cmd --zone=drop --list-ports</code></p>\n<p>允许icmp协议流量，即允许ping <code>firewall-cmd --zone=drop --add-protocol=icmp</code></p>\n<p>取消允许icmp协议的流量，即禁ping <code>firewall-cmd --zone=drop --remove-protocol=icmp</code></p>\n<p>查询drop区域开放了哪些协议 <code>firewall-cmd --zone=drop --list-protocols</code></p>\n<h3 id=\"端口转发\">端口转发</h3>\n<p>将原本访问本机888端口的流量转发到本机22端口 <code>firewall-cmd --zone=drop --add-forward-port=port=888:proto=tcp:toport=22</code></p>\n<p>将原本访问本机888端口的流量转发到ip为192.168.2.208的主机的22端口，需要开启masquerade</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone&#x3D;drop --add-masquerade</span><br><span class=\"line\">firewall-cmd --zone&#x3D;drop --add-forward-port&#x3D;port&#x3D;888:proto&#x3D;tcp:toport&#x3D;22:toaddr&#x3D;192.168.2.208</span><br></pre></td></tr></table></figure>\n<p>测试端口转发功能是否生效 在客户端尝试访问192.168.2.210主机的888端口，连上去后发现实际连接的是192.168.2.208主机，测试OK。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/34e156798d037e1dcc1e63d506fd2960.png\" alt=\"firewalld防火墙详解\" /><figcaption aria-hidden=\"true\">firewalld防火墙详解</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/fec17bffb6fb66b9c077d844956a7699.png\" alt=\"firewalld防火墙详解\" /><figcaption aria-hidden=\"true\">firewalld防火墙详解</figcaption>\n</figure>\n<h3 id=\"富规则\">富规则</h3>\n<p>接下来我们来看富规则的设置，即 <strong><em>rich rules</em></strong></p>\n<p>允许192.168.2.208主机的所有流量 <code>firewall-cmd --zone=drop --add-rich-rule=\"rule family=\"ipv4\" source address=\"192.168.2.208\" accept\"</code></p>\n<p>允许192.168.2.208主机的icmp协议，即允许192.168.2.208主机ping <code>firewall-cmd --add-rich-rule=\"rule family=\"ipv4\" source address=\"192.168.2.208\" protocol value=\"icmp\" accept\"</code></p>\n<p>取消允许192.168.2.208主机的所有流量 <code>firewall-cmd --zone=drop --remove-rich-rule=\"rule family=\"ipv4\" source address=\"192.168.2.208\" accept\"</code></p>\n<p>允许192.168.2.208主机访问ssh服务 <code>firewall-cmd --zone=drop --add-rich-rule=\"rule family=\"ipv4\" source address=\"192.168.2.208\" service name=\"ssh\" accept\"</code></p>\n<p>禁止192.168.2.208访问https服务，并返回错误信息 <code>firewall-cmd --zone=drop --add-rich-rule=\"rule family=\"ipv4\" source address=\"192.168.2.208\" service name=\"https\" reject\"</code> <em>注：如果是drop的话是直接丢弃，会返回timeout（连接超时）</em></p>\n<p>允许192.168.2.0/24网段的主机访问22端口 <code>firewall-cmd --zone=drop --add-rich-rule=\"rule family=\"ipv4\" source address=\"192.168.2.0/24\" port protocol=\"tcp\" port=\"22\" accept\"</code></p>\n<p>每分钟允许2个新连接访问ftp服务 <code>firewall-cmd --add-rich-rule=\"rule service name=ftp limit value=2/m accept\"</code></p>\n<p>允许新的ipv4和ipv6连接ftp，并使用日志和审核，每分钟允许访问一次 <code>firewall-cmd --add-rich-rule=\"rule service name=ftp log limit value=\"1/m\" audit accept\"</code></p>\n<p>拒绝来自192.168.2.0/24网段的连接，10秒后自动取消 <code>firewall-cmd --add-rich-rule=\"rule family=ipv4 source address=192.168.2.0/24 reject\" --timeout=10</code></p>\n<p>允许ipv6地址为2001:db8::/64子网的主机访问dns服务，并且每小时审核一次，300秒后自动取消 <code>firewall-cmd --add-rich-rule=\"rule family=ipv6 source address=\"2001:db8::/64\" service name=\"dns\" audit limit value=\"1/h\" reject\" --timeout=300</code></p>\n<p>将来自192.168.2.0/24网段访问本机80端口的流量转发到本机的22端口 <code>firewall-cmd --zone=drop --add-rich-rule=\"rule family=ipv4 source address=192.168.2.0/24 forward-port port=80 protocol=tcp to-port=22\"</code></p>\n<p>将来自192.168.2.0/24网段访问本地80端口的流量转发到192.168.2.208主机的22端口 <code>firewall-cmd --zone=drop --add-rich-rule=\"rule family=ipv4 source address=192.168.2.0/24 forward-port port=80 protocol=tcp to-port=22 to-addr=192.168.2.208\"</code></p>\n<p>伪装，将来自局域网192.168.2.0/24网段访问外网的流量映射为网络出口公网IP，即修改源IP地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone&#x3D;drop --add-masquerade</span><br><span class=\"line\">firewall-cmd --zone&#x3D;drop --add-rich-rule&#x3D;&quot;rule family&#x3D;ipv4 source address&#x3D;192.168.2.0&#x2F;24 masquerade&quot;</span><br></pre></td></tr></table></figure>\n<p>好了，写的差不多了，工作中基本上够用了</p>\n<h2 id=\"gui配置\">GUI配置</h2>\n<p>在RHEL7之前的发行版本默认的防火墙中，几乎没有图形化的防火墙管理工具，但是firewalld却有，firewall-config是firewalld防火墙配置管理工具的GUI（图开用户界面）版本，几乎可以实现所有命令行执行的操作。即使没有扎实的Linux命令基础，也完合可以通过它来妥善配置firewalld防火墙策略。Firewall-config的界面如下图所示，功能具体如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/cfe328ae0f110db0798a9d5edde8a2ba.png\" alt=\"firewalld防火墙详解\" /><figcaption aria-hidden=\"true\">firewalld防火墙详解</figcaption>\n</figure>\n<p>1、选择运行时（Runtime）模式或永久（Permanent）模式。 2、可选的策略集合区域列表。 3、常用的系统服务列表。 4、当前正在使用的区域。 5、管理当前被选中区域中的服务。 6、管理当前被选中区域中的端口。 7、开启或关闭SNAT（源地址转换协议）技术。 8、设置端口转发策略。 9、控制请求icmp服务的流量。 10、管理防火墙的富规则。 11、管理网卡设备。 12、被选中区域的服务，若勾选了相应服务前面的复选框，则表示允许与之相关的流量。 13、Firewall-config工具的运行状态。</p>\n<p>对外开放http服务，如下图</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/fc3e7d116afe83c1bfe5980bfd928849.png\" alt=\"firewalld防火墙详解\" /><figcaption aria-hidden=\"true\">firewalld防火墙详解</figcaption>\n</figure>\n<p>添加一条防火墙规则，使其放行访问8080-8088端口（TCP协议）的流量，并且永久生效</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/b9719667bc933bd079c526d733de7646.png\" alt=\"firewalld防火墙详解\" /><figcaption aria-hidden=\"true\">firewalld防火墙详解</figcaption>\n</figure>\n<p>单击Options菜单中的Reload Firewalld选项，让上面配置的永久规则立即生效，这与在命令行中执行--reload参数的效果一样。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/8bbca43ed6964afbbeeff8ff711dbcde.png\" alt=\"firewalld防火墙详解\" /><figcaption aria-hidden=\"true\">firewalld防火墙详解</figcaption>\n</figure>\n<p>SNAT技术相信很多人都知道，那现在我们来开启SNAT技术，其实就是命令行下的masquerade。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/695086a6a2aaf59d79bfe99bb5a02d85.png\" alt=\"firewalld防火墙详解\" /><figcaption aria-hidden=\"true\">firewalld防火墙详解</figcaption>\n</figure>\n<p>下面我们来配置一个端口转发规则，将888端口的流量转发到其他主机的22端口上。 <em>注：转发本机端口不需要开启masquerade，转发到别的主机才需要开启masquerade。</em></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/e66fb33793bf0ab48346c83b6a383d68.png\" alt=\"firewalld防火墙详解\" /><figcaption aria-hidden=\"true\">firewalld防火墙详解</figcaption>\n</figure>\n<p>配置富规则，允许192.168.2.206主机访问本机的1234端口号</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/5e75f674b7cbf921f7e2c0d3d13384e9.png\" alt=\"firewalld防火墙详解\" /><figcaption aria-hidden=\"true\">firewalld防火墙详解</figcaption>\n</figure>\n<p>最后来看一下区域和网卡的关联，增加网卡的话只需要输入网卡名称即可。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/51e73b7f425667cd83cc981c26fea0a2.png\" alt=\"firewalld防火墙详解\" /><figcaption aria-hidden=\"true\">firewalld防火墙详解</figcaption>\n</figure>\n<p>下面是我自己写的一个简单的防火墙初始化脚本，5210是ssh端口号，192.168.2.208是<strong>保垒机</strong>，192.168.2.206是<strong>备用ssh机器</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl stop firewalld</span><br><span class=\"line\">\\cp -p &#x2F;usr&#x2F;lib&#x2F;firewalld&#x2F;zones&#x2F;drop.xml &#x2F;etc&#x2F;firewalld&#x2F;zones&#x2F;</span><br><span class=\"line\">systemctl start firewalld</span><br><span class=\"line\">firewall-cmd --set-default-zone&#x3D;drop</span><br><span class=\"line\">firewall-cmd --permanent --zone&#x3D;drop --change-interface&#x3D;ens32</span><br><span class=\"line\">firewall-cmd --permanent --zone&#x3D;drop --add-service&#x3D;https</span><br><span class=\"line\">firewall-cmd --permanent --zone&#x3D;drop --add-protocol&#x3D;icmp</span><br><span class=\"line\">firewall-cmd --permanent --zone&#x3D;drop --add-masquerade</span><br><span class=\"line\">firewall-cmd --permanent --zone&#x3D;drop --add-rich-rule&#x3D;&quot;rule family&#x3D;&quot;ipv4&quot; source address&#x3D;&quot;192.168.2.208&quot; port protocol&#x3D;&quot;tcp&quot; port&#x3D;&quot;5210&quot; accept&quot;</span><br><span class=\"line\">firewall-cmd --permanent --zone&#x3D;drop --add-rich-rule&#x3D;&quot;rule family&#x3D;&quot;ipv4&quot; source address&#x3D;&quot;192.168.2.206&quot; port protocol&#x3D;&quot;tcp&quot; port&#x3D;&quot;5210&quot; accept&quot;</span><br><span class=\"line\">firewall-cmd --permanent --zone&#x3D;drop --add-rich-rule&#x3D;&quot;rule family&#x3D;&quot;ipv4&quot; source address&#x3D;&quot;116.226.230.115&quot; port protocol&#x3D;&quot;tcp&quot; port&#x3D;&quot;8023&quot; accept&quot;</span><br><span class=\"line\">firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n<p>​</p>\n<p>​</p>\n<p><a href=\"https://firewalld.org/documentation/howto/enable-and-disable-firewalld.html\">firewalld.org</a></p>\n<h1 id=\"enable-and-disable-firewalld\">Enable and Disable firewalld</h1>\n<p>firewalld provides an init script for systems using classic SysVinit and also a systemd service file. The following documentation is about the systemd service used in Fedora, RHEL and CentOS distributions.</p>\n<p>It is not recommended to use iptables directly while firewalld is running as this could lead into some unexpected issues. If a user, for example, is removing base rules or chains of the chain structure, then a firewalld reload might be needed to create them again.</p>\n<h2 id=\"install-and-enable-firewalld\">Install and enable firewalld</h2>\n<p>If the iptables, ip6tables, ebtables and ipset services are in use:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl disable --now iptables.service</span><br><span class=\"line\">systemctl disable --now ip6tables.service</span><br><span class=\"line\">systemctl disable --now etables.service</span><br><span class=\"line\">systemctl disable --now ipset.service</span><br><span class=\"line\">dnf install firewalld firewall-config firewall-applet</span><br><span class=\"line\">systemctl unmask --now firewalld.service</span><br><span class=\"line\">systemctl enable --now firewalld.service</span><br></pre></td></tr></table></figure>\n<p>To check the firewall state you have different options. The fist option is to use <code>systemctl status firewalld</code> the other one is to use <code>firewall-cmd --state</code>.</p>\n<p>The output of the systemctl command should look like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ systemctl status firewalld</span><br><span class=\"line\">● firewalld.service - firewalld - dynamic firewall daemon</span><br><span class=\"line\">   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;firewalld.service; enabled; vendor pr</span><br><span class=\"line\">   Active: active (running) since Wed 2016-06-29 14:28:51 CEST; 1 weeks 6 days a</span><br><span class=\"line\">     Docs: man:firewalld(1)</span><br><span class=\"line\"> Main PID: 24540 (firewalld)</span><br><span class=\"line\">    Tasks: 2 (limit: 512)</span><br><span class=\"line\">   CGroup: &#x2F;system.slice&#x2F;firewalld.service</span><br><span class=\"line\">           └─24540 &#x2F;usr&#x2F;bin&#x2F;python3 -Es &#x2F;usr&#x2F;sbin&#x2F;firewalld --nofork --nopid</span><br></pre></td></tr></table></figure>\n<p>The output of the firewall-cmd command should look like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ firewall-cmd --state</span><br><span class=\"line\">running</span><br></pre></td></tr></table></figure>\n<h2 id=\"install-and-enable-iptables-ip6tables-ebtables-and-ipset-services\">Install and enable iptables, ip6tables, ebtables and ipset services</h2>\n<p>If firewalld is enabled and you want to enable the iptables, ip6tables, ebtables and ipset services instead:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">dnf install iptables-services ebtables ipset-service</span><br><span class=\"line\">systemctl mask --now firewalld.service</span><br><span class=\"line\">systemctl enable --now iptables.service</span><br><span class=\"line\">systemctl enable --now ip6tables.service</span><br><span class=\"line\">systemctl enable --now etables.service</span><br><span class=\"line\">systemctl enable --now ipset.service</span><br></pre></td></tr></table></figure>\n<p>The use of the mask line is recommended as systemd will start firewalld if there is another service requires it or if the D-Bus interface of firewalld is used. If the service only gets disabled, then it will not be auto started anymore.</p>\n<p>​</p>\n<p>​</p>\n","categories":["Linux"],"tags":["firewalld","firewall"]},{"title":"How to Install GCC (build-essential) on Ubuntu 20.04","url":"/2021/04/23/Linux/GCC/2021-04-23-How%20to%20Install%20GCC%20(build-essential)%20on%20Ubuntu%2020.04/","content":"<p><a href=\"https://linuxize.com/post/how-to-install-gcc-on-ubuntu-20-04/#:~:text=The%20default%20Ubuntu%20repositories%20contain%20a%20meta-package%20named,as%20root%20or%20user%20with%20sudo%20privileges%20%3A\">linuxize.com</a></p>\n<p>The GNU Compiler Collection (GCC) is a collection of compilers and libraries for C, C++, Objective-C, Fortran, Ada, <a href=\"https://linuxize.com/post/how-to-install-go-on-ubuntu-20-04/\">Go</a> , and D programming languages. A lot of open-source projects, including the Linux kernel and GNU tools, are compiled using GCC.</p>\n<p>This article explains how to install GCC on Ubuntu 20.04.</p>\n<h1 id=\"installing-gcc-on-ubuntu-20.04\">Installing GCC on Ubuntu 20.04</h1>\n<p>The default Ubuntu repositories contain a meta-package named “build-essential” that includes the GNU compiler collection, GNU debugger, and other development libraries and tools required for compiling software.</p>\n<p>To install the Development Tools packages, run the following command as root or <a href=\"https://linuxize.com/post/how-to-create-a-sudo-user-on-ubuntu/\">user with sudo privileges</a> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install build-essential</span><br></pre></td></tr></table></figure>\n<p>The command installs a lot of packages, including <code>gcc</code>, <code>g++</code> and <code>make</code>.</p>\n<p>You may also want to install the manual pages about using GNU/Linux for development:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install manpages-dev</span><br></pre></td></tr></table></figure>\n<p>Verify that the GCC compiler is successfully installed by running the following command that prints the GCC version:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">gcc --version</span><br></pre></td></tr></table></figure>\n<p>Ubuntu 20.04 repositories provide GCC version <code>9.3.0</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">gcc (Ubuntu 9.3.0-10ubuntu2) 9.3.0</span><br><span class=\"line\">Copyright (C) 2019 Free Software Foundation, Inc.</span><br><span class=\"line\">This is free software; see the source for copying conditions.  There is NO</span><br><span class=\"line\">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure>\n<p>That’s it. GCC tools and libraries have been installed on your Ubuntu system.</p>\n<h1 id=\"compiling-a-hello-world-example\">Compiling a Hello World Example</h1>\n<p>Compiling a basic C or C++ program using GCC is pretty easy. Open your <a href=\"https://linuxize.com/post/how-to-install-visual-studio-code-on-ubuntu-18-04/\">text editor</a> and create the following file:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">nano hello.c</span><br></pre></td></tr></table></figure>\n<p>hello.c</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; hello.c</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    printf(&quot;Hello, world!\\n&quot;);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Save the file and compile it into an executable:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">gcc hello.c -o hello</span><br></pre></td></tr></table></figure>\n<p>This creates a binary file named <code>hello</code> in the same directory where you run the command.</p>\n<p>Execute the <code>hello</code> program with:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.&#x2F;hello</span><br></pre></td></tr></table></figure>\n<p>The program should print:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hello World!</span><br></pre></td></tr></table></figure>\n<h1 id=\"installing-multiple-gcc-versions\">Installing Multiple GCC Versions</h1>\n<p>This section provides instructions about how to install and use multiple versions of GCC on Ubuntu 20.04. The newer versions of the GCC compiler include new functions and optimization improvements.</p>\n<p>At the time of writing this article, the default Ubuntu repositories include several GCC versions, from <code>7.x.x</code> to <code>10.x.x</code>.</p>\n<p>In the following example, we will install the latest three versions of GCC and G++.</p>\n<p>Install the desired GCC and G++ versions by typing:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt install gcc-8 g++-8 gcc-9 g++-9 gcc-10 g++-10</span><br></pre></td></tr></table></figure>\n<p>The commands below configures alternative for each version and associate a priority with it. The default version is the one with the highest priority, in our case that is <code>gcc-10</code>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;gcc gcc &#x2F;usr&#x2F;bin&#x2F;gcc-10 100 --slave &#x2F;usr&#x2F;bin&#x2F;g++ g++ &#x2F;usr&#x2F;bin&#x2F;g++-10 --slave &#x2F;usr&#x2F;bin&#x2F;gcov gcov &#x2F;usr&#x2F;bin&#x2F;gcov-10sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;gcc gcc &#x2F;usr&#x2F;bin&#x2F;gcc-9 90 --slave &#x2F;usr&#x2F;bin&#x2F;g++ g++ &#x2F;usr&#x2F;bin&#x2F;g++-9 --slave &#x2F;usr&#x2F;bin&#x2F;gcov gcov &#x2F;usr&#x2F;bin&#x2F;gcov-9sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;gcc gcc &#x2F;usr&#x2F;bin&#x2F;gcc-8 80 --slave &#x2F;usr&#x2F;bin&#x2F;g++ g++ &#x2F;usr&#x2F;bin&#x2F;g++-8 --slave &#x2F;usr&#x2F;bin&#x2F;gcov gcov &#x2F;usr&#x2F;bin&#x2F;gcov-8</span><br></pre></td></tr></table></figure>\n<p>Later if you want to change the default version use the <code>update-alternatives</code> command:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo update-alternatives --config gcc</span><br><span class=\"line\">There are 3 choices for the alternative gcc (providing &#x2F;usr&#x2F;bin&#x2F;gcc).</span><br><span class=\"line\"></span><br><span class=\"line\">  Selection    Path            Priority   Status</span><br><span class=\"line\">------------------------------------------------------------</span><br><span class=\"line\">* 0            &#x2F;usr&#x2F;bin&#x2F;gcc-10   100       auto mode</span><br><span class=\"line\">  1            &#x2F;usr&#x2F;bin&#x2F;gcc-10   100       manual mode</span><br><span class=\"line\">  2            &#x2F;usr&#x2F;bin&#x2F;gcc-8    80        manual mode</span><br><span class=\"line\">  3            &#x2F;usr&#x2F;bin&#x2F;gcc-9    90        manual mode</span><br><span class=\"line\"></span><br><span class=\"line\">Press &lt;enter&gt; to keep the current choice[*], or type selection number:</span><br></pre></td></tr></table></figure>\n<p>You will be presented with a list of all installed GCC versions on your Ubuntu system. Enter the number of the version you want to be used as a default and press <code>Enter</code>.</p>\n<p>The command will create <a href=\"https://linuxize.com/post/how-to-create-symbolic-links-in-linux-using-the-ln-command/\">symbolic links</a> to the specific versions of GCC and G++.</p>\n<h1 id=\"conclusion\">Conclusion</h1>\n<p>We’ve shown you how to installed GCC on Ubuntu 20.04. You can now visit the official <a href=\"https://gcc.gnu.org/onlinedocs/\">GCC Documentation</a> page and learn how to use GCC and G++ to compile your C and C++ programs.</p>\n<p>If you hit a problem or have feedback, leave a comment below.</p>\n<p>​</p>\n","categories":["Programming"],"tags":["Linux","C++","gcc","ubuntu"]},{"title":"Linux Commands Cheat Sheet","url":"/2019/03/15/Linux/Maintain/2019-03-15-Linux%20Commands%20Cheat%20Sheet/","content":"<h1 id=\"system-information\">1 – SYSTEM INFORMATION</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Display Linux system information</span><br><span class=\"line\">uname -a</span><br><span class=\"line\"></span><br><span class=\"line\"># Display kernel release information</span><br><span class=\"line\">uname -r</span><br><span class=\"line\"></span><br><span class=\"line\"># Show which version of redhat installed</span><br><span class=\"line\">cat &#x2F;etc&#x2F;redhat-release</span><br><span class=\"line\"></span><br><span class=\"line\"># Show how long the system has been running + load</span><br><span class=\"line\">uptime</span><br><span class=\"line\"></span><br><span class=\"line\"># Show system host name</span><br><span class=\"line\">hostname</span><br><span class=\"line\"></span><br><span class=\"line\"># Display the IP addresses of the host</span><br><span class=\"line\">hostname -I</span><br><span class=\"line\"></span><br><span class=\"line\"># Show system reboot history</span><br><span class=\"line\">last reboot</span><br><span class=\"line\"></span><br><span class=\"line\"># Show the current date and time</span><br><span class=\"line\">date</span><br><span class=\"line\"></span><br><span class=\"line\"># Show this month&#39;s calendar</span><br><span class=\"line\">cal</span><br><span class=\"line\"></span><br><span class=\"line\"># Display who is online</span><br><span class=\"line\">w</span><br><span class=\"line\"></span><br><span class=\"line\"># Who you are logged in as</span><br><span class=\"line\">whoami</span><br></pre></td></tr></table></figure>\n<h1 id=\"hardware-information\">2 – HARDWARE INFORMATION</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Display messages in kernel ring buffer</span><br><span class=\"line\">dmesg</span><br><span class=\"line\"></span><br><span class=\"line\"># Display CPU information</span><br><span class=\"line\">cat &#x2F;proc&#x2F;cpuinfo</span><br><span class=\"line\"></span><br><span class=\"line\"># Display memory information</span><br><span class=\"line\">cat &#x2F;proc&#x2F;meminfo</span><br><span class=\"line\"></span><br><span class=\"line\"># Display free and used memory ( -h for human readable, -m for MB, -g for GB.)</span><br><span class=\"line\">free -h</span><br><span class=\"line\"></span><br><span class=\"line\"># Display PCI devices</span><br><span class=\"line\">lspci -tv</span><br><span class=\"line\"></span><br><span class=\"line\"># Display USB devices</span><br><span class=\"line\">lsusb -tv</span><br><span class=\"line\"></span><br><span class=\"line\"># Display DMI&#x2F;SMBIOS (hardware info) from the BIOS</span><br><span class=\"line\">dmidecode</span><br><span class=\"line\"></span><br><span class=\"line\"># Show info about disk sda</span><br><span class=\"line\">hdparm -i &#x2F;dev&#x2F;sda</span><br><span class=\"line\"></span><br><span class=\"line\"># Perform a read speed test on disk sda</span><br><span class=\"line\">hdparm -tT &#x2F;dev&#x2F;sda</span><br><span class=\"line\"></span><br><span class=\"line\"># Test for unreadable blocks on disk sda</span><br><span class=\"line\">badblocks -s &#x2F;dev&#x2F;sda</span><br></pre></td></tr></table></figure>\n<h1 id=\"performance-monitoring-and-statistics\">3 – PERFORMANCE MONITORING AND STATISTICS</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Display and manage the top processes</span><br><span class=\"line\">top</span><br><span class=\"line\"></span><br><span class=\"line\"># Interactive process viewer (top alternative)</span><br><span class=\"line\">htop</span><br><span class=\"line\"></span><br><span class=\"line\"># Display processor related statistics</span><br><span class=\"line\">mpstat 1</span><br><span class=\"line\"></span><br><span class=\"line\"># Display virtual memory statistics</span><br><span class=\"line\">vmstat 1</span><br><span class=\"line\"></span><br><span class=\"line\"># Display I&#x2F;O statistics</span><br><span class=\"line\">iostat 1</span><br><span class=\"line\"></span><br><span class=\"line\"># Display the last 100 syslog messages  (Use &#x2F;var&#x2F;log&#x2F;syslog for Debian based systems.)</span><br><span class=\"line\">tail 100 &#x2F;var&#x2F;log&#x2F;messages</span><br><span class=\"line\"></span><br><span class=\"line\"># Capture and display all packets on interface eth0</span><br><span class=\"line\">tcpdump -i eth0</span><br><span class=\"line\"></span><br><span class=\"line\"># Monitor all traffic on port 80 ( HTTP )</span><br><span class=\"line\">tcpdump -i eth0 &#39;port 80&#39;</span><br><span class=\"line\"></span><br><span class=\"line\"># List all open files on the system</span><br><span class=\"line\">lsof</span><br><span class=\"line\"></span><br><span class=\"line\"># List files opened by user</span><br><span class=\"line\">lsof -u user</span><br><span class=\"line\"></span><br><span class=\"line\"># Display free and used memory ( -h for human readable, -m for MB, -g for GB.)</span><br><span class=\"line\">free -h</span><br><span class=\"line\"></span><br><span class=\"line\"># Execute &quot;df -h&quot;, showing periodic updates</span><br><span class=\"line\">watch df -h</span><br></pre></td></tr></table></figure>\n<h1 id=\"user-information-and-management\">4 – USER INFORMATION AND MANAGEMENT</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Display the user and group ids of your current user.</span><br><span class=\"line\">id</span><br><span class=\"line\"></span><br><span class=\"line\"># Display the last users who have logged onto the system.</span><br><span class=\"line\">last</span><br><span class=\"line\"></span><br><span class=\"line\"># Show who is logged into the system.</span><br><span class=\"line\">who</span><br><span class=\"line\"></span><br><span class=\"line\"># Show who is logged in and what they are doing.</span><br><span class=\"line\">w</span><br><span class=\"line\"></span><br><span class=\"line\"># Create a group named &quot;test&quot;.</span><br><span class=\"line\">groupadd test</span><br><span class=\"line\"></span><br><span class=\"line\"># Create an account named john, with a comment of &quot;John Smith&quot; and create the user&#39;s home directory.</span><br><span class=\"line\">useradd -c &quot;John Smith&quot; -m john</span><br><span class=\"line\"></span><br><span class=\"line\"># Delete the john account.</span><br><span class=\"line\">userdel john</span><br><span class=\"line\"></span><br><span class=\"line\"># Add the john account to the sales group</span><br><span class=\"line\">usermod -aG sales john</span><br></pre></td></tr></table></figure>\n<h1 id=\"file-and-directory-commands\">5 – FILE AND DIRECTORY COMMANDS</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># List all files in a long listing (detailed) format</span><br><span class=\"line\">ls -al</span><br><span class=\"line\"></span><br><span class=\"line\"># Display the present working directory</span><br><span class=\"line\">pwd</span><br><span class=\"line\"></span><br><span class=\"line\"># Create a directory</span><br><span class=\"line\">mkdir directory</span><br><span class=\"line\"></span><br><span class=\"line\"># Remove (delete) file</span><br><span class=\"line\">rm file</span><br><span class=\"line\"></span><br><span class=\"line\"># Remove the directory and its contents recursively</span><br><span class=\"line\">rm -r directory</span><br><span class=\"line\"></span><br><span class=\"line\"># Force removal of file without prompting for confirmation</span><br><span class=\"line\">rm -f file</span><br><span class=\"line\"></span><br><span class=\"line\"># Forcefully remove directory recursively</span><br><span class=\"line\">rm -rf directory</span><br><span class=\"line\"></span><br><span class=\"line\"># Copy file1 to file2</span><br><span class=\"line\">cp file1 file2</span><br><span class=\"line\"></span><br><span class=\"line\"># Copy source_directory recursively to destination. If destination exists, copy source_directory into destination, otherwise create destination with the contents of source_directory.</span><br><span class=\"line\">cp -r source_directory destination</span><br><span class=\"line\"></span><br><span class=\"line\"># Rename or move file1 to file2. If file2 is an existing directory, move file1 into directory file2</span><br><span class=\"line\">mv file1 file2</span><br><span class=\"line\"></span><br><span class=\"line\"># Create symbolic link to linkname</span><br><span class=\"line\">ln -s &#x2F;path&#x2F;to&#x2F;file linkname</span><br><span class=\"line\"></span><br><span class=\"line\"># Create an empty file or update the access and modification times of file.</span><br><span class=\"line\">touch file</span><br><span class=\"line\"></span><br><span class=\"line\"># View the contents of file</span><br><span class=\"line\">cat file</span><br><span class=\"line\"></span><br><span class=\"line\"># Browse through a text file</span><br><span class=\"line\">less file</span><br><span class=\"line\"></span><br><span class=\"line\"># Display the first 10 lines of file</span><br><span class=\"line\">head file</span><br><span class=\"line\"></span><br><span class=\"line\"># Display the last 10 lines of file</span><br><span class=\"line\">tail file</span><br><span class=\"line\"></span><br><span class=\"line\"># Display the last 10 lines of file and &quot;follow&quot; the file as it grows.</span><br><span class=\"line\">tail -f file</span><br></pre></td></tr></table></figure>\n<h1 id=\"process-management\">6 – PROCESS MANAGEMENT</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Display your currently running processes</span><br><span class=\"line\">ps</span><br><span class=\"line\"></span><br><span class=\"line\"># Display all the currently running processes on the system.</span><br><span class=\"line\">ps -ef</span><br><span class=\"line\"></span><br><span class=\"line\"># Display process information for processname</span><br><span class=\"line\">ps -ef | grep processname</span><br><span class=\"line\"></span><br><span class=\"line\"># Display and manage the top processes</span><br><span class=\"line\">top</span><br><span class=\"line\"></span><br><span class=\"line\"># Interactive process viewer (top alternative)</span><br><span class=\"line\">htop</span><br><span class=\"line\"></span><br><span class=\"line\"># Kill process with process ID of pid</span><br><span class=\"line\">kill pid</span><br><span class=\"line\"></span><br><span class=\"line\"># Kill all processes named processname</span><br><span class=\"line\">killall processname</span><br><span class=\"line\"></span><br><span class=\"line\"># Start program in the background</span><br><span class=\"line\">program &amp;</span><br><span class=\"line\"></span><br><span class=\"line\"># Display stopped or background jobs</span><br><span class=\"line\">bg</span><br><span class=\"line\"></span><br><span class=\"line\"># Brings the most recent background job to foreground</span><br><span class=\"line\">fg</span><br><span class=\"line\"></span><br><span class=\"line\"># Brings job n to the foreground</span><br><span class=\"line\">fg n</span><br></pre></td></tr></table></figure>\n<h1 id=\"file-permissions\">7 – FILE PERMISSIONS</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PERMISSION      EXAMPLE</span><br><span class=\"line\"></span><br><span class=\"line\">U   G   W</span><br><span class=\"line\">rwx rwx rwx     chmod 777 filename</span><br><span class=\"line\">rwx rwx r-x     chmod 775 filename</span><br><span class=\"line\">rwx r-x r-x     chmod 755 filename</span><br><span class=\"line\">rw- rw- r--     chmod 664 filename</span><br><span class=\"line\">rw- r-- r--     chmod 644 filename</span><br><span class=\"line\"></span><br><span class=\"line\"># NOTE: Use 777 sparingly!</span><br><span class=\"line\"></span><br><span class=\"line\">LEGEND</span><br><span class=\"line\">U &#x3D; User</span><br><span class=\"line\">G &#x3D; Group</span><br><span class=\"line\">W &#x3D; World</span><br><span class=\"line\"></span><br><span class=\"line\">r &#x3D; Read</span><br><span class=\"line\">w &#x3D; write</span><br><span class=\"line\">x &#x3D; execute</span><br><span class=\"line\">- &#x3D; no access</span><br></pre></td></tr></table></figure>\n<h1 id=\"networking\">8 – NETWORKING</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Display all network interfaces and ip address</span><br><span class=\"line\">ifconfig -a</span><br><span class=\"line\"></span><br><span class=\"line\"># Display eth0 address and details</span><br><span class=\"line\">ifconfig eth0</span><br><span class=\"line\"></span><br><span class=\"line\"># Query or control network driver and hardware settings</span><br><span class=\"line\">ethtool eth0</span><br><span class=\"line\"></span><br><span class=\"line\"># Send ICMP echo request to host</span><br><span class=\"line\">ping host</span><br><span class=\"line\"></span><br><span class=\"line\"># Display whois information for domain</span><br><span class=\"line\">whois domain</span><br><span class=\"line\"></span><br><span class=\"line\"># Display DNS information for domain</span><br><span class=\"line\">dig domain</span><br><span class=\"line\"></span><br><span class=\"line\"># Reverse lookup of IP_ADDRESS</span><br><span class=\"line\">dig -x IP_ADDRESS</span><br><span class=\"line\"></span><br><span class=\"line\"># Display DNS ip address for domain</span><br><span class=\"line\">host domain</span><br><span class=\"line\"></span><br><span class=\"line\"># Display the network address of the host name.</span><br><span class=\"line\">hostname -i</span><br><span class=\"line\"></span><br><span class=\"line\"># Display all local ip addresses</span><br><span class=\"line\">hostname -I</span><br><span class=\"line\"></span><br><span class=\"line\"># Download http:&#x2F;&#x2F;domain.com&#x2F;file</span><br><span class=\"line\">wget http:&#x2F;&#x2F;domain.com&#x2F;file</span><br><span class=\"line\"></span><br><span class=\"line\"># Display listening tcp and udp ports and corresponding programs</span><br><span class=\"line\">netstat -nutlp</span><br></pre></td></tr></table></figure>\n<h1 id=\"archives-tar-files\">9 – ARCHIVES (TAR FILES)</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Create tar named archive.tar containing directory.</span><br><span class=\"line\">tar cf archive.tar directory</span><br><span class=\"line\"></span><br><span class=\"line\"># Extract the contents from archive.tar.</span><br><span class=\"line\">tar xf archive.tar</span><br><span class=\"line\"></span><br><span class=\"line\"># Create a gzip compressed tar file name archive.tar.gz.</span><br><span class=\"line\">tar czf archive.tar.gz directory</span><br><span class=\"line\"></span><br><span class=\"line\"># Extract a gzip compressed tar file.</span><br><span class=\"line\">tar xzf archive.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"># Create a tar file with bzip2 compression</span><br><span class=\"line\">tar cjf archive.tar.bz2 directory</span><br><span class=\"line\"></span><br><span class=\"line\"># Extract a bzip2 compressed tar file.</span><br><span class=\"line\">tar xjf archive.tar.bz2</span><br></pre></td></tr></table></figure>\n<h1 id=\"installing-packages\">10 – INSTALLING PACKAGES</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Search for a package by keyword.</span><br><span class=\"line\">yum search keyword</span><br><span class=\"line\"></span><br><span class=\"line\"># Install package.</span><br><span class=\"line\">yum install package</span><br><span class=\"line\"></span><br><span class=\"line\"># Display description and summary information about package.</span><br><span class=\"line\">yum info package</span><br><span class=\"line\"></span><br><span class=\"line\"># Install package from local file named package.rpm</span><br><span class=\"line\">rpm -i package.rpm</span><br><span class=\"line\"></span><br><span class=\"line\"># Remove&#x2F;uninstall package.</span><br><span class=\"line\">yum remove package</span><br><span class=\"line\"></span><br><span class=\"line\"># Install software from source code.</span><br><span class=\"line\">tar zxvf sourcecode.tar.gz</span><br><span class=\"line\">cd sourcecode</span><br><span class=\"line\">.&#x2F;configure</span><br><span class=\"line\">make</span><br><span class=\"line\">make install</span><br></pre></td></tr></table></figure>\n<h1 id=\"search\">11 – SEARCH</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Search for pattern in file</span><br><span class=\"line\">grep pattern file</span><br><span class=\"line\"></span><br><span class=\"line\"># Search recursively for pattern in directory</span><br><span class=\"line\">grep -r pattern directory</span><br><span class=\"line\"></span><br><span class=\"line\"># Find files and directories by name</span><br><span class=\"line\">locate name</span><br><span class=\"line\"></span><br><span class=\"line\"># Find files in &#x2F;home&#x2F;john that start with &quot;prefix&quot;.</span><br><span class=\"line\">find &#x2F;home&#x2F;john -name &#39;prefix*&#39;</span><br><span class=\"line\"></span><br><span class=\"line\"># Find files larger than 100MB in &#x2F;home</span><br><span class=\"line\">find &#x2F;home -size +100M</span><br></pre></td></tr></table></figure>\n<h1 id=\"ssh-logins\">12 – SSH LOGINS</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Connect to host as your local username.</span><br><span class=\"line\">ssh host</span><br><span class=\"line\"></span><br><span class=\"line\"># Connect to host as user</span><br><span class=\"line\">ssh user@host</span><br><span class=\"line\"></span><br><span class=\"line\"># Connect to host using port</span><br><span class=\"line\">ssh -p port user@host</span><br></pre></td></tr></table></figure>\n<h1 id=\"file-transfers\">13 – FILE TRANSFERS</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Secure copy file.txt to the &#x2F;tmp folder on server</span><br><span class=\"line\">scp file.txt server:&#x2F;tmp</span><br><span class=\"line\"></span><br><span class=\"line\"># Copy *.html files from server to the local &#x2F;tmp folder.</span><br><span class=\"line\">scp server:&#x2F;var&#x2F;www&#x2F;*.html &#x2F;tmp</span><br><span class=\"line\"></span><br><span class=\"line\"># Copy all files and directories recursively from server to the current system&#39;s &#x2F;tmp folder.</span><br><span class=\"line\">scp -r server:&#x2F;var&#x2F;www &#x2F;tmp</span><br><span class=\"line\"></span><br><span class=\"line\"># Synchronize &#x2F;home to &#x2F;backups&#x2F;home</span><br><span class=\"line\">rsync -a &#x2F;home &#x2F;backups&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\"># Synchronize files&#x2F;directories between the local and remote system with compression enabled</span><br><span class=\"line\">rsync -avz &#x2F;home server:&#x2F;backups&#x2F;</span><br></pre></td></tr></table></figure>\n<h1 id=\"disk-usage\">14 – DISK USAGE</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Show free and used space on mounted filesystems</span><br><span class=\"line\">df -h</span><br><span class=\"line\"></span><br><span class=\"line\"># Show free and used inodes on mounted filesystems</span><br><span class=\"line\">df -i</span><br><span class=\"line\"></span><br><span class=\"line\"># Display disks partitions sizes and types</span><br><span class=\"line\">fdisk -l</span><br><span class=\"line\"></span><br><span class=\"line\"># Display disk usage for all files and directories in human readable format</span><br><span class=\"line\">du -ah</span><br><span class=\"line\"></span><br><span class=\"line\"># Display total disk usage off the current directory</span><br><span class=\"line\">du -sh</span><br></pre></td></tr></table></figure>\n<h1 id=\"directory-navigation\">15 – DIRECTORY NAVIGATION</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># To go up one level of the directory tree.  (Change into the parent directory.)</span><br><span class=\"line\">cd ..</span><br><span class=\"line\"></span><br><span class=\"line\"># Go to the $HOME directory</span><br><span class=\"line\">cd</span><br><span class=\"line\"></span><br><span class=\"line\"># Change to the &#x2F;etc directory</span><br><span class=\"line\">cd &#x2F;etc</span><br></pre></td></tr></table></figure>\n","categories":["Linux"],"tags":["MBR","GPT"]},{"title":"CentOS7安装iptables防火墙","url":"/2019/03/05/Linux/SSH/CentOS7%E5%AE%89%E8%A3%85iptables%E9%98%B2%E7%81%AB%E5%A2%99/","content":"<p>本文转自 <strong>清园</strong> 的《<a href=\"https://www.cnblogs.com/kreo/p/4368811.html\">CentOS7安装iptables防火墙</a>》</p>\n<p>请直接复制第八部分的脚本到服务器，保存成<code>***.sh</code> ，并使用<code>chmod +x ***.sh</code> 提升脚本权限，然后直接使用<code>./***.sh</code> 执行即可。参考链接附《国内端口检测网站》。</p>\n<p>CentOS7默认的防火墙不是iptables，而是firewalld。</p>\n<h1 id=\"一-安装iptables\">一、 安装iptables</h1>\n<p>#先检查是否安装了iptables</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">service iptables status</span><br></pre></td></tr></table></figure>\n<p>#安装iptables</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y iptables</span><br></pre></td></tr></table></figure>\n<p>#升级iptables</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum update iptables </span><br></pre></td></tr></table></figure>\n<p>#安装iptables-services</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install iptables-services</span><br></pre></td></tr></table></figure>\n<h1 id=\"二-禁用停止自带的firewalld服务\">二、 禁用/停止自带的firewalld服务</h1>\n<p>#停止firewalld服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl stop firewalld</span><br></pre></td></tr></table></figure>\n<p>#禁用firewalld服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl mask firewalld</span><br></pre></td></tr></table></figure>\n<h1 id=\"三-设置现有规则\">三、 设置现有规则</h1>\n<p>#查看iptables现有规则</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -L -n</span><br></pre></td></tr></table></figure>\n<p>#先允许所有,不然有可能会杯具</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -P INPUT ACCEPT</span><br></pre></td></tr></table></figure>\n<p>#清空所有默认规则</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -F</span><br></pre></td></tr></table></figure>\n<p>#清空所有自定义规则</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -X</span><br></pre></td></tr></table></figure>\n<p>#所有计数器归0</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -Z</span><br></pre></td></tr></table></figure>\n<p>#允许来自于lo接口的数据包(本地访问)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -A INPUT -i lo -j ACCEPT</span><br></pre></td></tr></table></figure>\n<p>#开放22端口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span><br></pre></td></tr></table></figure>\n<p>#开放21端口(FTP)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -A INPUT -p tcp --dport 21 -j ACCEPT</span><br></pre></td></tr></table></figure>\n<p>#开放80端口(HTTP)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure>\n<p>#开放443端口(HTTPS)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -A INPUT -p tcp --dport 443 -j ACCEPT</span><br></pre></td></tr></table></figure>\n<p>#允许ping</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT</span><br></pre></td></tr></table></figure>\n<p>#允许接受本机请求之后的返回数据 RELATED,是为FTP设置的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -A INPUT -m state --state  RELATED,ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>\n<p>#其他入站一律丢弃</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -P INPUT DROP</span><br></pre></td></tr></table></figure>\n<p>#所有出站一律绿灯</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -P OUTPUT ACCEPT</span><br></pre></td></tr></table></figure>\n<p>#所有转发一律丢弃</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -P FORWARD DROP</span><br></pre></td></tr></table></figure>\n<h1 id=\"四-其他规则设定\">四、 其他规则设定</h1>\n<p>#如果要添加内网ip信任（接受其所有TCP请求）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -A INPUT -p tcp -s 45.96.174.68 -j ACCEPT</span><br></pre></td></tr></table></figure>\n<p>#过滤所有非以上规则的请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -P INPUT DROP</span><br></pre></td></tr></table></figure>\n<p>#要封停一个IP，使用下面这条命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -I INPUT -s ***.***.***.*** -j DROP</span><br></pre></td></tr></table></figure>\n<p>#要解封一个IP，使用下面这条命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -D INPUT -s ***.***.***.*** -j DROP</span><br></pre></td></tr></table></figure>\n<h1 id=\"五-保存规则设定\">五、 保存规则设定</h1>\n<p>#保存上述规则</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">service iptables save</span><br></pre></td></tr></table></figure>\n<h1 id=\"六-开启iptables服务\">六、 开启iptables服务</h1>\n<p>#服务 开启 / 停止 / 重启 / 查看状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">service iptables start &#x2F; stop &#x2F; restart &#x2F; status</span><br></pre></td></tr></table></figure>\n<p># 七、其他</p>\n<p>解决vsftpd在iptables开启后,无法使用被动模式的问题</p>\n<p>1.首先在/etc/sysconfig/iptables-config中修改或者添加以下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#添加以下内容,注意顺序不能调换</span><br><span class=\"line\">IPTABLES_MODULES&#x3D;&quot;ip_conntrack_ftp&quot;</span><br><span class=\"line\">IPTABLES_MODULES&#x3D;&quot;ip_nat_ftp&quot;</span><br></pre></td></tr></table></figure>\n<p>2.重新设置iptables设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iptables -A INPUT -m state --state  RELATED,ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>\n<h1 id=\"八-以上完整脚本如下\">八、 以上完整脚本如下</h1>\n<p>版本一（通用）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#!&#x2F;bin&#x2F;sh</span><br><span class=\"line\">iptables -P INPUT ACCEPT</span><br><span class=\"line\">iptables -F</span><br><span class=\"line\">iptables -X</span><br><span class=\"line\">iptables -Z</span><br><span class=\"line\"></span><br><span class=\"line\">iptables -A INPUT -i lo -j ACCEPT</span><br><span class=\"line\"></span><br><span class=\"line\">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class=\"line\">iptables -A INPUT -p tcp --dport 21 -j ACCEPT</span><br><span class=\"line\">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class=\"line\">iptables -A INPUT -p tcp --dport 443 -j ACCEPT</span><br><span class=\"line\"></span><br><span class=\"line\">iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT</span><br><span class=\"line\"></span><br><span class=\"line\">iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class=\"line\"></span><br><span class=\"line\">iptables -P INPUT DROP</span><br><span class=\"line\">iptables -P OUTPUT ACCEPT</span><br><span class=\"line\">iptables -P FORWARD DROP</span><br><span class=\"line\"></span><br><span class=\"line\">service iptables save</span><br><span class=\"line\">systemctl restart iptables.service</span><br></pre></td></tr></table></figure>\n<p>版本二（自定义）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#!&#x2F;bin&#x2F;sh</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl stop firewalld</span><br><span class=\"line\">systemctl mask firewalld</span><br><span class=\"line\"></span><br><span class=\"line\">iptables -P INPUT ACCEPT</span><br><span class=\"line\">iptables -F</span><br><span class=\"line\">iptables -X</span><br><span class=\"line\">iptables -Z</span><br><span class=\"line\"></span><br><span class=\"line\">iptables -A INPUT -i lo -j ACCEPT</span><br><span class=\"line\"></span><br><span class=\"line\">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class=\"line\">iptables -A INPUT -p tcp --dport 21 -j ACCEPT</span><br><span class=\"line\">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class=\"line\">iptables -A INPUT -p tcp --dport 443 -j ACCEPT</span><br><span class=\"line\"></span><br><span class=\"line\">iptables -A INPUT -p tcp --dport 22222 -j ACCEPT</span><br><span class=\"line\">iptables -A INPUT -p tcp --dport 62666 -j ACCEPT</span><br><span class=\"line\">iptables -A INPUT -p tcp --dport 20188 -j ACCEPT</span><br><span class=\"line\">iptables -A INPUT -p tcp --dport 23333 -j ACCEPT</span><br><span class=\"line\">iptables -A INPUT -p tcp --dport 15347 -j ACCEPT</span><br><span class=\"line\">iptables -A INPUT -p tcp --dport 16666 -j ACCEPT</span><br><span class=\"line\"></span><br><span class=\"line\">iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT</span><br><span class=\"line\"></span><br><span class=\"line\">iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class=\"line\"></span><br><span class=\"line\">iptables -P INPUT DROP</span><br><span class=\"line\">iptables -P OUTPUT ACCEPT</span><br><span class=\"line\">iptables -P FORWARD DROP</span><br><span class=\"line\"></span><br><span class=\"line\">service iptables save</span><br><span class=\"line\">service iptables restart</span><br></pre></td></tr></table></figure>\n<h1 id=\"参考链接\">参考链接</h1>\n<ol type=\"1\">\n<li>《<a href=\"https://www.cnblogs.com/kreo/p/4368811.html\">CentOS7安装iptables防火墙</a>》</li>\n<li>《<a href=\"http://coolaf.com/tool/port\">国内端口检测网站</a>》</li>\n</ol>\n","categories":["Linux"],"tags":["Centos","SSH","iptables"]},{"title":"使用 SSH-Key 登录远程服务器","url":"/2021/05/13/Linux/SSH/%E4%BD%BF%E7%94%A8%20SSH-Key%20%E7%99%BB%E5%BD%95%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":"<p><a href=\"https://www.jianshu.com/p/fab3252b3192\">jianshu.com</a></p>\n<p>ssh 提供两种级别的安全认证：</p>\n<ol type=\"1\">\n<li>基于口令的安全认证</li>\n<li>基于密钥的安全认证</li>\n</ol>\n<h2 id=\"基于口令的安全认证\">基于口令的安全认证</h2>\n<p>需要知道用户名和密码即可登录，该连接是加密的，但客户端不能确认目标主机是否为“伪造的”，也不能保证口令安全。</p>\n<p>远程主机的 /etc/ssh/sshd_config 需配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PasswordAuthentication yes</span><br></pre></td></tr></table></figure>\n<p>重启 sshd 使改动生效：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ &#x2F;etc&#x2F;init.d&#x2F;sshd reload</span><br></pre></td></tr></table></figure>\n<h2 id=\"基于密钥的安全认证\">基于密钥的安全认证</h2>\n<p>需要用户持有“公钥/私钥对”，远程服务器持有公钥，本地持有私钥。</p>\n<p>客户端向服务器发出请求。服务器收到请求之后，先在用户的主目录下找到该用户的公钥，然后对比用户发送过来的公钥。如果一致，服务器用公钥加密“质询”并发送给客户端。客户端收到“质询”后用私钥解密，再发还给服务器。认证结束。</p>\n<p>生成 ssh-key，选加密算法（rsa、dsa），给秘钥命名（可选）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C &quot;name&quot;</span><br></pre></td></tr></table></figure>\n<p>passphrase 是证书口令，以加强安全性，避免证书被恶意复制。</p>\n<p>会在 <code>~.ssh</code> 下生成 <code>id_rsa</code>, <code>id_rsa.pub</code> 两个文件，分别是 私钥/公钥。</p>\n<p><mark>公钥需保存到远程服务器 <code>~/.ssh/authorized_keys</code> 里，私钥由客户端本地留存。</mark></p>\n<p>要保证 <code>.ssh</code> 和 <code>authorized_keys</code> 都只有用户自己有写权限。否则验证无效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ chmod -R 700 ~&#x2F;.ssh&#x2F;</span><br><span class=\"line\">$ chmod 600 ~&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure>\n<h2 id=\"ssh-配置的一些实践\">ssh 配置的一些实践</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PermitRootLogin no</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">StrictModes no</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">RSAAuthentication yes</span><br><span class=\"line\">PubkeyAuthentication yes</span><br><span class=\"line\">AuthorizedKeysFile %h&#x2F;.ssh&#x2F;authorized_keys</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PasswordAuthentication no</span><br></pre></td></tr></table></figure>\n<h2 id=\"持有多个-ssh-key-时的使用方法\">持有多个 ssh-key 时的使用方法</h2>\n<p>简单情况下，通过手动指定私钥文件登录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh username@hostname -i ~&#x2F;.ssh&#x2F;my_id_rsa</span><br></pre></td></tr></table></figure>\n<p>觉得麻烦可以配置客户端的 <code>/etc/ssh/ssh_config</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">IdentityFile ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class=\"line\"></span><br><span class=\"line\">IdentityFile ~&#x2F;.ssh&#x2F;my_id_rsa</span><br></pre></td></tr></table></figure>\n<p>你也可以使用 SSH Agent，下面以使用 GitHub 为场景简单介绍。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C &#39;second@mail.com&#39;</span><br><span class=\"line\">$ ssh-add ～&#x2F;.ssh&#x2F;id_rsa_second</span><br></pre></td></tr></table></figure>\n<p>创建 <code>~/.ssh/config</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Host github.com</span><br><span class=\"line\">HostName github.com</span><br><span class=\"line\">User git</span><br><span class=\"line\">IdentityFile C:&#x2F;Users&#x2F;username&#x2F;.ssh&#x2F;id_rsa</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Host github-second</span><br><span class=\"line\">HostName github.com</span><br><span class=\"line\">User git</span><br><span class=\"line\">IdentityFile C:&#x2F;Users&#x2F;username&#x2F;.ssh&#x2F;id_rsa_second</span><br></pre></td></tr></table></figure>\n<p>配置完成后，在连接非默认账号的仓库时，远端地址要修改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git remote add test git@github-second:second&#x2F;test.git</span><br></pre></td></tr></table></figure>\n<p>​</p>\n","categories":["Linux"],"tags":["Centos","SSH","login"]},{"title":"使用SELinux开放SSH端口","url":"/2019/03/03/Linux/SSH/%E4%BD%BF%E7%94%A8SELinux%E5%BC%80%E6%94%BESSH%E7%AB%AF%E5%8F%A3/","content":"<h1 id=\"什么是selinux\">什么是SELinux</h1>\n<p>SELinux(Security-Enhanced Linux) 是美国国家安全局（NSA）对于强制访问控制的实现，是 Linux历史上最杰出的新安全子系统。</p>\n<p>NSA是在Linux社区的帮助下开发了一种访问控制体系，在这种访问控制体系的限制下，进程只能访问那些在他的任务中所需要文件。SELinux 默认安装在 Fedora 和 Red Hat Enterprise Linux 上，也可以作为其他发行版上容易安装的包得到。</p>\n<h1 id=\"使用selinux开放ssh端口\">使用SELinux开放SSH端口</h1>\n<ol type=\"1\">\n<li>查看SELinux开放给ssh使用的端口</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">semanage port -l|grep ssh</span><br></pre></td></tr></table></figure>\n<p>如果系统打印如下，则说明没有开放新添加端口。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh_port_t                    tcp      22</span><br></pre></td></tr></table></figure>\n<ol start=\"2\" type=\"1\">\n<li>添加新端口</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">semanage port -a -t ssh_port_t -p tcp 22222</span><br></pre></td></tr></table></figure>\n<p>正确添加后再次查看，会显示如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh_port_t                    tcp      22，22222</span><br></pre></td></tr></table></figure>\n<h1 id=\"参考链接\">参考链接</h1>\n<ol type=\"1\">\n<li>《<a href=\"https://baike.baidu.com/item/SElinux\">SELinux</a>》</li>\n<li>《<a href=\"https://blog.csdn.net/ausboyue/article/details/53691953\">CentOS7增加或修改SSH端口号</a>》</li>\n<li>《<a href=\"http://cn.linux.vbird.org/linux_basic/0440processcontrol.php\">第十七章、程序管理与 SELinux 初探</a>》</li>\n</ol>\n","categories":["Linux"],"tags":["Centos","SSH"]},{"title":"保护服务器，为SSH服务修改端口号","url":"/2019/03/03/Linux/SSH/%E4%BF%9D%E6%8A%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E4%B8%BASSH%E6%9C%8D%E5%8A%A1%E4%BF%AE%E6%94%B9%E7%AB%AF%E5%8F%A3%E5%8F%B7/","content":"<p>修改SSH的端口号是为了防止有人恶意使用暴力破解的方法登录你的服务器，其他保护服务器的方法有禁用Root登录、SSH-Key登录等，但更为简单的操作就是修改你的SSH端口号。下文中将添加一个新端口号，待测试新端口号能够正常使用之后就可以关闭旧的端口号了。</p>\n<h1 id=\"一-修改ssh配置文件\">一、 修改SSH配置文件</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br></pre></td></tr></table></figure>\n<p>找到<code>#Port 22</code>，去掉<code>#</code>并在下一行添加<code>Port 22222</code>。</p>\n<ul>\n<li>注意是<code>sshd_config</code>而不是<code>ssh_config</code>，多了个<code>d</code>。</li>\n<li>SSH服务的默认监听端口是22，如果不强制说明别的端口，”Port 22”注不注释都是开放22访问端口的。保留了22端口，是防止之后因为各种权限和配置问题，避免连22端口都不能访问的尴尬。</li>\n<li>如果设置10000以下的端口号，容易被系统或一些特殊软件占用，或是以后新应用准备占用该端口的时候，却被你先占用了，导致软件无法运行。因此，请选择10000~65535之间的任意端口号。</li>\n<li>到时候需要禁用22号端口的时候，重新修改此文件，给 <code>Port22</code> 前面加上 <code>#</code>，并重新启动服务即可。</li>\n</ul>\n<h1 id=\"二查看selinux开放情况\">二、查看SELinux开放情况</h1>\n<p>见文章《<a href=\"https://blog.liewzheng.cn/2019/03/03/Linux/SSH/%E4%BD%BF%E7%94%A8SELinux%E5%BC%80%E6%94%BESSH%E7%AB%AF%E5%8F%A3/\">使用SELinux开放SSH端口</a>》</p>\n<p>如果没有安装SELinux或已关闭则略过。</p>\n<h1 id=\"三开启防火墙对应的端口\">三、开启防火墙对应的端口</h1>\n<p>见文章《<a href=\"https://blog.liewzheng.cn/2019/03/05/Linux/SSH/CentOS7%E5%AE%89%E8%A3%85iptables%E9%98%B2%E7%81%AB%E5%A2%99/\">CentOS7安装iptables防火墙</a>》</p>\n<p>直接下载里面的脚本（或者复制粘贴），然后提升权限并运行。</p>\n<h1 id=\"四-重启服务\">四、 重启服务</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">service sshd restart</span><br><span class=\"line\">service iptables restart</span><br><span class=\"line\">reboot</span><br></pre></td></tr></table></figure>\n<p>此步骤如果使用了第三步骤的脚本之后，便可忽略，而 <code>reboot</code> 则可以看情况使用。</p>\n<h1 id=\"五-尝试用新端口登陆ssh服务\">五、 尝试用新端口登陆SSH服务</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -P 22222 root@******</span><br></pre></td></tr></table></figure>\n<p>更多防护技术请看参考链接里的文章。</p>\n<h1 id=\"参考链接\">参考链接</h1>\n<ol type=\"1\">\n<li>《<a href=\"https://blog.phpgao.com/vps_ssh.html\">VPS安全之SSH设置</a>》</li>\n</ol>\n","categories":["Linux"],"tags":["Centos","SSH"]},{"title":"SSR简易教程","url":"/2019/02/14/Linux/ShadowsocksR/2019-02-14-SSR%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/","content":"<p>本文在参考了各家文章之所长的基础上，亲自实践折腾了1个小时左右，成功搭建科学上网之路。(并不图文并茂呢~)</p>\n<p>首先，本文应用到的工具有Vultr、Xshell、Terminal（windows平台下为cmd工具）、和SS（ShadowSocks）连接器,下文会对工具进行介绍。</p>\n<h1 id=\"一工具介绍\">一、工具介绍</h1>\n<h2 id=\"vultr\">1. Vultr</h2>\n<p>首先了解一下VPS的概念。<strong>VPS</strong>即Virtual private server，虚拟专享服务器，是指将一台服务器分割成多个虚拟专享服务器的服务。</p>\n<p>Vultr是国外的一个大型服务器提供商，可以低价租用他们的虚拟专享服务器。然后通过让我们自己的设备连接到他们的虚拟专享服务器来达到科学上网的目的。（PS：因为他们的虚拟专享服务器在国外）</p>\n<p>也有其他的VPS提供商，见文章《<a href=\"https://www.vpser.net/ten-dollars-vps\">10美元以下国内VPS/美国VPS推荐</a>》。</p>\n<h2 id=\"xshell-和-terminal\">2. Xshell 和 Terminal</h2>\n<p>Xshell是个开启SSH服务工具。<strong>SSH</strong>即Secure Shell，是是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH通过在网络中创建安全隧道来实现SSH客户端与服务器之间的连接。</p>\n<p>Terminal是个命令执行终端，跟Windows下的command窗口同理。我们只需要用Terminal执行一句<code>ping 0.0.0.0</code>而已。（0.0.0.0 更换为你部署的服务器地址）</p>\n<h2 id=\"ssr\">3. SSR</h2>\n<p>见文章《<a href=\"http://blog.liewzheng.cn/2019/02/22/Linux/ShadowsocksR/Beyond%20the%20Wall/\">Beyond the Wall</a>》。</p>\n<h1 id=\"二实践步骤\">二、实践步骤</h1>\n<p>本篇文章也算是给自己下次部署SSR一个笔记，提醒自己有哪些步骤。</p>\n<h2 id=\"下载和安装ssr\">1. 下载和安装SSR</h2>\n<p>提供英文和中文两个版本，都分别有三条语句：<code>wget *****</code>，<code>chmod *****</code> 和 <code>./*****</code>。步骤分别是下载<code>*****.sh</code>文件，提升该文件的权限 和 运行该文件。</p>\n<p>注意：如提示<code>wget not found</code> ， 请先执行<code>yum install -y wget</code>。（CentOS下执行，其他系统请自行Google） ### English Edition <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">wget --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teddysun&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocksR.sh</span><br><span class=\"line\">chmod +x shadowsocksR.sh</span><br><span class=\"line\">.&#x2F;shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"chinese-edition\">Chinese Edition</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">wget -N --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ToyoDAdoubi&#x2F;doubi&#x2F;master&#x2F;ssr.sh </span><br><span class=\"line\">chmod +x ssr.sh </span><br><span class=\"line\">.&#x2F;ssr.sh</span><br></pre></td></tr></table></figure>\n<p>其实我也知道我很懒，也知道以下很多文章都是看不到的，但我不想写了，非常懒地放个链接好了，最怕的是写这些怕被请喝茶。</p>\n<h2 id=\"bbr加速\">2. BBR加速</h2>\n<p>此步骤100%的概率建议用户操作，虽然不操作也能用，原因还是看文章吧。</p>\n<p>《<a href=\"使用BBR一键脚本为你的CentOS/Debian/Ubuntu系统加速\">使用BBR一键脚本为你的CentOS/Debian/Ubuntu系统加速</a>》</p>\n<h2 id=\"添加多用户可选\">3. 添加多用户（可选）</h2>\n<p>centOS使用的防火墙是firewalld不是iptables，添加完多用户之后要开启对应的端口。</p>\n<p>《<a href=\"https://www.lutizi.com/ssr/\">Linux VPS主机搭建ShadowsocksR(ssr)多用户一键脚本带Web查询面板</a>》</p>\n<p>《<a href=\"https://www.cnblogs.com/kreo/p/4368811.html\">CentOS7安装iptables防火墙</a>》</p>\n<h2 id=\"添加ssh服务端口可选\">4. 添加SSH服务端口（可选）</h2>\n<p>虽然是可选，但我还是100%建议这么做。为了防止被GFW屏蔽22端口，多添加几个端口备用，添加端口的方法见上面的文章。</p>\n<p>《<a href=\"https://sebastianblade.com/how-to-modify-ssh-port-in-centos7/\">怎样修改 CentOS 7 SSH 端口</a>》</p>\n<h2 id=\"检查端口\">5. 检查端口</h2>\n<p>在CentOS下查看端口需要先安装Net-tools: <code>yum install net-tools</code>，查看时使用<code>netstat -ntlp</code>。其他用法请参详：</p>\n<p>《<a href=\"https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html\">Linux netstat命令详解</a>》</p>\n<h2 id=\"google-scholar可选\">6. Google Scholar（可选）</h2>\n<p>如果无法打开Google Scholar，可以尝试阅读以下文章。</p>\n<p>《<a href=\"https://cao0507.github.io/2018/12/17/%E8%A7%A3%E5%86%B3vpn%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%B0%B7%E6%AD%8C%E5%AD%A6%E6%9C%AF%E7%9A%84%E9%97%AE%E9%A2%98/\">解决 VPN 无法打开谷歌学术的问题</a>》</p>\n<h2 id=\"伪装ssr可选\">7. 伪装SSR（可选）</h2>\n<p>《<a href=\"https://www.liuboping.com/%E5%87%A0%E6%AD%A5%E6%89%BE%E5%87%BAss%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0/\">几步找出ss科学上网速度慢的原因</a>》</p>\n<p>《<a href=\"https://www.liuboping.com/ss%E9%80%9F%E5%BA%A6%E6%85%A2%E6%9C%80%E5%A4%A7%E7%9A%84%E5%8F%AF%E8%83%BD%E6%98%AF%E8%A2%AB%E8%BF%90%E8%90%A5%E5%95%86qos%E4%BA%86/\">SS速度慢——最大的可能是被运营商QoS了</a>》</p>\n<h2 id=\"kcptun可选\">8. KCPTun（可选）</h2>\n<p>倒腾过，倒也不难，但是下载另外一个客户端麻烦，我就不弄了。推荐操作指数是50%。</p>\n<p>《<a href=\"https://www.gblm.net/209.html\">一步一步教你用Kcptun给Shadowsocks加速！看YouTube1080P一点都不卡！</a>》</p>\n<p>另外，不介绍VMess的使用方法了，感兴趣可以自行Google。 可以多部署几个Server（价格也就上去了），然后启用SSR的负载均衡，降低与某个Sever IP的通信数据过大，导致被防火墙封死。</p>\n<h1 id=\"参考链接\">参考链接</h1>\n<ol type=\"1\">\n<li>《<a href=\"https://segmentfault.com/a/1190000015558387\">超详细 Vultr（VPS）搭建 SS / 新手图文指导教程</a>》</li>\n<li>《<a href=\"https://blog.huihut.com/2016/12/03/BandwagonShadowsocksServer/\">搬瓦工Shadowsocks安装及配置多用户(服务端)</a>》</li>\n<li>《<a href=\"https://zh.wikipedia.org/wiki/Shadowsocks\">Shadowsocks</a>》</li>\n</ol>\n","categories":["Linux"],"tags":["Centos","Vultr","Shadowsocks"]},{"title":"Beyond the Wall","url":"/2019/02/22/Linux/ShadowsocksR/2019-02-22-Beyond%20the%20Wall/","content":"<p>本文几乎九成都是参考链接中的文章的摘写，很多前辈们都写得很好了，但是为了更好的适应现在的网络环境，还是做适当调整和补充说明。</p>\n<p>基础解释部分，完全转自前辈 <strong><span class=\"citation\" data-cites=\"ThomasXu\">@ThomasXu</span></strong> 的文章《<a href=\"https://medium.com/@thomas_summon/%E6%B5%85%E8%B0%88vpn-vps-proxy%E4%BB%A5%E5%8F%8Ashadowsocks%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB-b0198f92db1b\">浅谈vpn、vps、Proxy以及shadowsocks之间的联系和区别</a>》。</p>\n<p>注意，本文不适合完全小白的受众阅读！实践操作部分，需要有一定的Linux基础和网络知识。</p>\n<p>亲自画了个图，示意墙以外的协议和墙以内的协议。 <img src=\"http://uk-liewzheng-blog-pic.oss-eu-west-1.aliyuncs.com/2019/02/22/Beyond_the_Wall/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E5%8D%8F%E8%AE%AE%E7%90%86%E8%A7%A3.jpg\" /></p>\n<h1 id=\"基础解释\">基础解释</h1>\n<h2 id=\"gfw\">GFW</h2>\n<p>如果有机会，可以搜一下<strong>GFW</strong>，此处不做解释。</p>\n<p>GFW实现网络封锁的手段主要有两种：<strong>DNS劫持</strong>和<strong>IP封锁</strong>（除此之外，还有<strong>DNS污染</strong>和<strong>关键词过滤</strong>，此处不做解释）。</p>\n<ul>\n<li><p><strong>DNS劫持</strong>：IP是网络上各主机的“地址”，要想访问“别人家”，当然得要有地址。但IP是一串数字，是给电脑看的，人记起来太麻烦，所以就有了域名Domain（也就是我们常说的网址）和 DNS（网域名称系统，Domain Name System）。域名是一串英文字符串，方便人记忆。DNS将域名和IP关联起来，形成映射及映射表。用户访问域名所在的目标网站前，将域名发给DNS服务器询问这对映射关系，拿到对应的IP后就可以在茫茫网海中找到那个“她”了。而GFW所做的就是站在用户和DNS服务器之间，破坏它们的正常通讯，并向用户回传一个假IP。用户拿不到真正的IP，自然也就访问不到本想访问的网站了。DNS劫持是GFW早期唯一的技术手段，所以那个时候的用户通过修改Hosts文件的方式就可以零成本突破封锁了。</p></li>\n<li><p><strong>IP封锁</strong>：DNS劫持之后，GFW引入了IP封锁，直接锁住了访问目标网站的去路，用户发往被封锁ip的任何数据都会被墙截断。这个时候，依靠类似于修改Hosts文件这种低成本方法突破封锁就显得有些天方夜谭了。那么，解决办法是什么呢？答案是：在第三方架设翻墙服务器，中转与目标服务器间的来往流量。目前为止，GFW采用的是黑名单模式，像Google、Facebook这种在黑名单上的网站的ip无法访问，而不在黑名单上的第三方不记名ip可以。于是，一切就很明朗了，我们目前几乎所有的翻墙手段都是基于上述原理实现的，VPN是，ShadowSocks是，还有一些比较冷门的（比如V2Ray）同样如此，只不过它们的技术细节不同（这个我们不会深入）。</p></li>\n</ul>\n<h2 id=\"vpn\">VPN</h2>\n<p>VPN，全称“虚拟私人网络（Virtual Private Network）”，是一种加密通讯技术。VPN是一个统称，它有很多的具体实现，比如PPTP、L2TP、IPSec和openvpn。vpn出现远早于GFW，所以它不是为了翻墙而生的，它被设计出来的目的是数据传输安全和网络匿名。</p>\n<p>而既然不是为翻墙而生，那从翻墙的角度上讲，VPN协议就存在诸多问题。最严重的一个就是流量特征过于明显。墙目前已经能够精确识别绝大部分VPN协议的流量特征并给予封锁，所以，VPN这种翻墙方式基本已经废了。</p>\n<p>但即便如此，VPN作为过去很长一段时间最主流最热门最常用最为人所知的翻墙手段，已然成为翻墙的代名词。即便是VPN已不再常用的今天，当人们谈及翻墙的时候，说得最多的仍是：“你有什么好用的VPN吗？”。</p>\n<h2 id=\"proxy\">Proxy</h2>\n<p>Proxy（代理）又分为<strong>正向代理</strong>和<strong>反向代理</strong>。翻墙所用的代理都是正向代理。 ### 反向代理 <a href=\"https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86\"><strong>反向代理</strong></a>的作用主要是为服务器做缓存和负载均衡，此处不做解释。</p>\n<p>另外，Shadowsocks里也有负载均衡的概念，但Shadowsocks的负载均衡和反向代理的负载均衡不是一个概念。</p>\n<p>反向代理的负载均衡是指：在多个真正的服务器前架设一个代理服务器，用户所有的数据都发给代理服务器，然后代理服务器根据各个真实服务器的状态将数据转发给一个任务较少的服务器处理。这样，服务商既可以架设多个服务器分担任务、减轻压力，用户也只要记一个域名或ip就可以了。</p>\n<p>Shadowsocks的负载均衡是指：每隔一段时间更改一次翻墙服务器，将用户的数据平均发给多个不同的翻墙服务器，以避免发往某一个翻墙服务器的流量过多。</p>\n<h3 id=\"正向代理\">正向代理</h3>\n<p>正向代理主要有<strong>HTTP</strong>、<strong>HTTP over TLS(HTTPS)</strong>、<strong>Socks</strong>、<strong>Socks over TLS</strong>几种。</p>\n<p>其中，HTTP和Socks无法用于翻墙，HTTPS和Socks over TLS可以用于翻墙。不过，Socks over TLS几乎没人用，我们这里就不多说了。</p>\n<p>Proxy的历史同样早于GFW，它最早被设计出来的目的当然也不是翻墙。正向代理最主要的目的和VPN差不多，都是用于匿名，但HTTP和Socks不能加密，只能匿名，HTTPS既可以匿名，也可以用于加密通信。</p>\n<p>从理论上讲，四种代理协议都可以通过“用户先将数据发给代理服务器，再由代理服务器转发给目的服务器”的方法达到翻墙目的。但由于HTTP和Socks都是明文协议，GFW可以通过检查数据包内的内容得知用户的真实意图，进而拦截数据包。所以，HTTP和Socks一般只用作本地代理。而HTTPS协议是加密通讯，GFW无法得知数据包内的真实内容，类似于<strong>关键词过滤</strong>的手段无法施展。</p>\n<h4 id=\"socks\">Socks</h4>\n<p><strong><a href=\"https://zh.wikipedia.org/wiki/SOCKS\">Socks</a></strong> 代理与其他类型的代理不同，它只是简单地传递数据包，而并不关心是何种应用协议，既可以是HTTP请求，所以SOCKS代理服务器比其他类型的代理服务器速度要快得多。</p>\n<p>Socks代理又分为<strong>Socks4</strong> 和 <strong>Socks5</strong> ，二者不同的是Socks4代理只支持TCP协议，而Socks5代理则既支持TCP协议又支持UDP协议，还支持各种身份验证机制、服务器端域名解析等。Socks4能做到的Socks5都可得到，但Socks5能够做到的Socks4则不一定能做到，比如我们常用的聊天工具QQ在使用代理时就要求用Socks5代理，因为它需要使用UDP协议来传输数据.</p>\n<h4 id=\"https和v2ray\">HTTPS和V2Ray</h4>\n<ul>\n<li>HTTPS代理最大的缺点就是配置复杂。即便能用默认参数就用默认参数，用户自己只作最低限度的配置，对新手而言，这也是一个无比痛苦的过程。更别说，想要正常使用HTTPS代理，你还要购买域名和证书这些，非常麻烦。所以，即便是在shadowsocks出现之前，HTTPS代理也没在大陆流行起来。HTTPS代理只能转发TCP流量，对UDP无能为力。</li>\n<li>V2Ray的VMess over tls也许能和HTTPS代理媲美。但V2Ray存在的时间较短、使用者较少、社区也没有HTTPS代理活跃（从全球范围上看）。相比于HTTPS代理，VMess协议潜在的安全漏洞可能要多。这也是v2ray的小众的主要原因之一（另一个是用户没有从shadowsocks迁移到V2Ray的动力），它的配置同样相当复杂。</li>\n</ul>\n<p><strong>HTTPS代理的流量特征和我们平时访问网站时所产生的HTTPS流量几乎一摸一样，GFW无法分辨，稳定性爆表。</strong></p>\n<p>理论上讲，HTTPS代理无论是安全性还是在隐匿性上，都要比目前最为流行的Shadowsocks好。事实上，在所有已知的翻墙协议中，无论是VPN协议，还是代理协议，它应该都是最好的。</p>\n<p>这里推荐刘亚晨先生的一篇文章「<a href=\"https://medium.com/@Blankwonder/%E5%90%84%E7%A7%8D%E5%8A%A0%E5%AF%86%E4%BB%A3%E7%90%86%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94-1ed52bf7a803\">各种加密代理协议的简单对比</a>」。</p>\n<h2 id=\"vps\">VPS</h2>\n<p>VPS（Virtual private server，虚拟专用服务器）是由VPS提供商维护，租用给站长使用的“不会关机的电脑”。vps不是一台台独立的电脑，而是将一台巨型服务器通过虚拟化技术分割成若干台看似独立的服务器。这台巨型服务器不间断运行，被分割出来的小服务器也跟着不停的运作，站长租用其中一台小服务器，搭载上自己的站点，就可以等着用户访问了。</p>\n<p>Q: VPS和VPN、Proxy以及我们后面会说的Shadowsocks有什么关系呢？ A: 很简单，VPS可以用来搭建网站，当然也可以用来承载VPN服务器、代理服务器或是Shadowsocks的服务器啦。建站固然是VPS最主要的作用，但绝对不是它唯一的作用，既然VPS本质上也是电脑，那电脑能做的事它当然也能做。</p>\n<h2 id=\"shadowsocks\">Shadowsocks</h2>\n<p><a href=\"http://shadowsocks.org/en/index.html\"><strong>Shadowsocks(SS)</strong></a>是既可以指一种基于<strong>Socks5</strong>代理方式的加密传输协议，也可以指实现这个协议的各种开发包。目前包使用 Python、C、C++、C#、Go 等编程语言开发，大部分主要实现（iOS 平台的除外）采用 Apache 许可证、GPL、MIT 许可证等多种自由软件许可协议开放源代码。</p>\n<p>在Shadowsocks之前，墙内网民主要依靠寻找现成的技术实现翻墙。比如VPN、HTTPS、TOR的中继网桥以及之后的MEEK插件等等，虽然也有自己的技术，比如一种依靠Google隐藏IP实现翻墙的技术（名字忘了）,但毕竟难成大器，再加上GFW逐渐加大对VPN的干扰，人们迫切需要一种简单可靠的技术来抵御GFW的进攻。</p>\n<p>于是，大概是在2013年吧（具体时间我也不太清楚），<span class=\"citation\" data-cites=\"clowwindy带着他的shadowsocks横空出世\">@clowwindy带着他的shadowsocks横空出世</span>。</p>\n<p>Shadowsocks同样是一种代理协议，但是作为@clowwindy为国人设计的专门用于翻墙的代理协议，相对于VPN，Shadowsocks有着极强的隐匿性；相对于HTTP代理，Shadowsocks提供了较为完善的加密方案，虽然比不上HTTPS代理和VPN，但使用的也是成熟的工业级的加密算法，普通个人用户完全不用顾虑；相对于HTTPS代理，Shadowsocks的安装配置更为简单，中文社区更为活跃，中文文档教程更完善，更符合中国国情。</p>\n<p>Shdadowsocks最初的版本是由@clowwindy使用Python（一种目前非常热门的脚本编程语言）实现的。所以clowwindy的版本被称为Python版。shadowsocks有点名气之后，不同的开发者使用不同的编程语言为其写了很多分支版本。比如: - <span class=\"citation\" data-cites=\"cyfdecyf开发维护的Go版本\">@cyfdecyf开发维护的Go版本</span>。 - <span class=\"citation\" data-cites=\"madeye开发维护的libev版本\">@madeye开发维护的libev版本</span>（由纯C语言编写，基于libev库开发）。 - <span class=\"citation\" data-cites=\"librehat开发维护的c\">@librehat开发维护的c</span>++版。 - <span class=\"citation\" data-cites=\"zhou0开发维护的Perl版\">@zhou0开发维护的Perl版</span>。</p>\n<p>这些版本的安装使用指南都可以在shadowsocks的官网上查阅。</p>\n<p>2015年，clowwindy因喝茶事件被迫停止了shadowsocks的维护，并删除了其开源在GitHub上的代码，Python版就此停滞。但其它版本仍处于维护更新中。其中，更新最频繁，新技术跟进最快的是由@madeye维护的libev版本。这里有必要说明下，目前，shadowsocks协议（请区分“shadowsocks协议”和“shadowsocks协议的具体实现”这两者的区别）是由shadowsocks社区内的成员共同维护，协议上任何新改进都是社区成员共同商讨的结果。但对这些变化，不同的版本的shadowsocks跟进速度不同。而跟进速度最快的就是我上面说的libev版。无论是SIP007确认的ADEA Ciphers（一种同时进行认证和加密的算法），还是SIP003引进的simple-obfs（tor开发的一种混淆插件），shadowsocks-libev都是最早引入自己软件的。</p>\n<p>Shadowsocks 分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。</p>\n<h2 id=\"shadowsockr\">ShadowsockR</h2>\n<p><strong>ShadowsocksR(SSR)</strong> 是 <strong><span class=\"citation\" data-cites=\"breakwa11\">@breakwa11</span></strong> 发起的Shadowsocks分支，在Shadowsocks的基础上增加了一些数据混淆方式，称修复了部分安全问题并可以提高QoS优先级。后来贡献者@Librehat 也为 Shadowsocks 补上了一些此类特性，甚至增加了类似 Tor 的可插拔传输层功能。</p>\n<p>因为Shadowsocks在普及之后最大的缺点就是加密流量过多，防火墙一旦检测到你的加密流量过多之后，就会进一步开始限制你的IP。因此不适合长期使用，而ShadowsocksR在Shadowsocks的基础上加上了Potocol和Obfs功能，能够进一步伪装成HTTPS流量，让防火墙检测到你的难度加大，安全和稳定性都更高。如果你用SS，那么你被检测到的时间可能需要几个月，短则几天，甚至是几分钟（曾经发生过，一下子就被截胡了），但是SSR能更稳定。</p>\n<h2 id=\"vmess\">VMess</h2>\n<p><strong><a href=\"https://www.v2ray.com/chapter_02/protocols/vmess.html\">VMess</a></strong> 协议是由 V2Ray 原创并使用于 V2Ray 的加密传输协议，如同 Shadowsocks 一样为了对抗墙的深度包检测而研发的。在 V2Ray 上客户端与服务器的通信主要是通过 VMess 协议通信。V2Ray 是 Project V 下的一个工具。Project V 是一个包含一系列构建特定网络环境工具的项目，而 V2Ray 属于最核心的一个。从时间上来说，先有 V2Ray 才有 Project V。Project V还包含其他的传输加密协议，如Shadowsocks和socks。</p>\n<p>VMess 依赖于系统时间，请确保使用 V2Ray 的系统 UTC 时间误差在 90 秒之内，时区无关。</p>\n<p>在 Linux 系统中可以安装ntp服务来自动同步系统时间。</p>\n<h1 id=\"部署实践\">部署实践</h1>\n<p>请见文章《<a href=\"https://blog.liewzheng.cn/2019/02/14/Linux/ShadowsocksR/SSR简易教程/\">SSR简易教程</a>》</p>\n<h1 id=\"参考链接\">参考链接</h1>\n<ol type=\"1\">\n<li>《<a href=\"https://medium.com/@thomas_summon/%E6%B5%85%E8%B0%88vpn-vps-proxy%E4%BB%A5%E5%8F%8Ashadowsocks%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB-b0198f92db1b\">浅谈vpn、vps、Proxy以及shadowsocks之间的联系和区别</a>》</li>\n<li>《<a href=\"https://my.oschina.net/aiguozhe/blog/127279\">http,socks4,socks5代理的区别</a>》</li>\n<li>《<a href=\"https://toutyrater.github.io/basic/vmess.html\">VMess协议·V2Ray配置指南|V2Ray白话文教程</a>》</li>\n<li>《<a href=\"https://www.cnblogs.com/kreo/p/4368811.html\">CentOS7安装iptables防火墙</a>》</li>\n<li>《<a href=\"https://walesexcitedmei.github.io/2018/11/26/SSR-ShadowsocksR-%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/\">ShadowsocksR 配置及使用</a>》</li>\n</ol>\n","categories":["Linux"],"tags":["ShadowsocksR"]},{"title":"Shell脚本编程(未完待续)","url":"/2019/01/13/Linux/Shell/2019-01-13-Shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/","content":"<p>原文：《<a href=\"https://github.com/qinjx/30min_guides/blob/master/shell.md\">Shell脚本编程30分钟入门</a>》</p>\n<p>首先要安装一个wget插件 <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y wget</span><br><span class=\"line\">yum install -y setup</span><br><span class=\"line\">yum install -y perl</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"一shell脚本\">一、Shell脚本</h1>\n<h2 id=\"脚本示例\">1. 脚本示例</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#!&#x2F;bin&#x2F;sh</span><br><span class=\"line\">cd ~</span><br><span class=\"line\">mkdir shell_tut</span><br><span class=\"line\">cd shell_tut</span><br><span class=\"line\"></span><br><span class=\"line\">for ((i&#x3D;0; i&lt;10; i++)); do</span><br><span class=\"line\">\ttouch test_$i.txt</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码解释\">2. 代码解释</h2>\n<ul>\n<li>第1行：指定脚本解释器，这里是用/bin/sh做解释器的</li>\n<li>第2行：切换到当前用户的home目录</li>\n<li>第3行：创建一个目录shell_tut</li>\n<li>第4行：切换到shell_tut目录</li>\n<li>第6行：循环条件，一共循环10次</li>\n<li>第7行：创建一个test_0…9.txt文件</li>\n<li>第8行：循环体结束</li>\n</ul>\n<p>mkdir, touch都是系统自带的程序，一般在/bin或者/usr/bin目录下。for, do, done是sh脚本语言的关键字。</p>\n<h1 id=\"二shell相关概念\">二、Shell相关概念</h1>\n<h2 id=\"基础概念\">1. 基础概念</h2>\n<p><strong>shell</strong> 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务，Windows Explorer是一个典型的图形界面Shell。</p>\n<p><strong>shell脚本</strong> ，shell script，是一种为shell编写的脚本程序。业界所说的shell通常都是指shell脚本。shell和shell script是两个不同的概念。<em>由于习惯的原因，简洁起见，本文出现的“shell编程”都是指shell脚本编程，不是指开发shell自身（如Windows Explorer扩展开发）。</em></p>\n<p><strong>sh命令</strong> 是shell命令语言解释器，执行命令从标准输入读取或从一个文件中读取。通过用户输入命令，和内核进行沟通。</p>\n<h2 id=\"shell类型\">2. Shell类型</h2>\n<p>如果要查看某一个用户使用的是什么 shell 可以通过 <code>finger [USERNAME]</code>命令来查看。 <strong>(kt)sh</strong>，Ken Thompson Shell，历史上第一个Unix shell，1971年由肯·汤普逊写作出第一版并加入UNIX之中。它是一个简单的命令行解释器，但不能被用来运行 <em>指令稿</em>（Shell script）。它的许多特征影响了以后命令行界面的发展。至Version 7 Unix之后，被Bourne shell取代。</p>\n<p><strong>sh</strong>，Bourne Shell，是Version 7 Unix默认的Unix shell，替代执行文件同为.sh的Thompson shell。</p>\n<p><strong>bash</strong> ，Bourne Again Shell，Unix shell的一种，在1987年由布莱恩·福克斯为了GNU计划而编写，与Bourne Shell兼容，还继承了C Shell、Korn Shell等优点。</p>\n<p><strong>zsh</strong>， Z shell是一款可用作交互式登录的shell及脚本编写的命令解释器。Zsh对Bourne shell做出了大量改进，同时加入了Bash、ksh及tcsh的某些功能。</p>\n<h2 id=\"shell模式\">3. Shell模式</h2>\n<h3 id=\"login-shell-和-no-login-shell\">3.1 login shell 和 no-login shell</h3>\n<p><strong>login shell</strong> 代表用户登入, 比如使用 <code>su -</code> 命令, 或者用 ssh 连接到某一个服务器上, 都会使用该用户默认 shell 启动 login shell 模式。</p>\n<p>该模式下的 shell 会去自动执行 <code>/etc/profile</code> 和 <code>~/.profile</code> 文件, 但不会执行任何的 <code>bashrc</code> 文件, 所以一般在 <code>/etc/profile</code> 或者 <code>~/.profile</code> 里我们会手动去 <code>source bashrc</code> 文件。</p>\n<p><strong>no-login shell</strong> 的情况是我们在终端下直接输入 <code>bash</code> 或者 <code>bash -c “CMD”</code> 来启动的 shell。</p>\n<p>该模式下是不会自动去运行任何的 <code>profile</code> 文件。</p>\n<h3 id=\"interactive-shell-和-non-interactive-shell\">3.2 interactive shell 和 non-interactive shell</h3>\n<p><strong>interactive shell</strong> 是交互式shell, 顾名思义就是用来和用户交互的, 提供了命令提示符可以输入命令。</p>\n<p>该模式下会存在一个叫 <code>PS1</code> 的环境变量, 如果还不是 <strong>login shell</strong> 的则会去 <code>source /etc/bash.bashrc</code> 和 <code>~/.bashrc</code> 文件。</p>\n<p><strong>non-interactive shell</strong> 则一般是通过 <code>bash -c “CMD”</code> 来执行的bash。</p>\n<p>该模式下不会执行任何的 <code>rc</code> 文件 <em>(不过还存在一种特殊情况这个我之后详细讲述)</em>。</p>\n<h2 id=\"profile和bashrc\">4. profile和bashrc</h2>\n<p>profile用于交互式login shell，bashrc用于交互式non-login shell。系统中存在许多bashrc和profile文件。 <code>/etc/profile</code>和<code>~/.profile</code>分别对应 <em>所有用户</em> 和 <em>单个用户</em>(bashrc同理)。</p>\n<h3 id=\"profile\">4.1 profile</h3>\n<p>profile 是用户唯一的用来设置环境变量的地方, 因为用户可以有多个 shell 比如 bash, sh, zsh 之类的, 但像环境变量这种其实只需要在统一的一个地方初始化就可以了, 而这就是 profile。<code>/etc/profile</code>中设定的变量(全局)的可以作用于任何用户，profile文件是在用户登录的时候进行初始化的。</p>\n<h3 id=\"bashrc\">4.2 bashrc</h3>\n<p>bashrc 是专门用来给 bash 做初始化的比如用来初始化 bash 的设置, bash 的代码补全, bash 的别名, bash 的颜色. 以此类推也就还会有 shrc, zshrc 这样的文件存在了, 只是 bash 太常用了而已。<code>~/.bashrc</code>等中设定的变量(局部)只能继承<code>/etc/profile</code>中的变量,他们是\"父子\"关系。(此句话待考究！！！！)</p>\n<h1 id=\"三环境\">三、环境</h1>\n<p>shell编程跟java、php编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p>\n<h2 id=\"os\">1. OS</h2>\n<p>当前主流的操作系统都支持shell编程，本文档所述的shell编程是指Linux下的shell，讲的基本都是POSIX标准下的功能，所以，也适用于Unix及BSD（如Mac OS）。</p>\n<p>Linux默认安装就带了shell解释器。Mac OS不仅带了sh、bash这两个最基础的解释器，还内置了ksh、csh、zsh等不常用的解释器。windows出厂时没有内置shell解释器，需要自行安装，为了同时能用grep, awk, curl等工具，最好装一个<a href=\"http://www.cygwin.com/\">cygwin</a>或者<a href=\"http://www.mingw.org/\">mingw</a>来模拟linux环境。</p>\n<h2 id=\"脚本解释器\">2. 脚本解释器</h2>\n<h3 id=\"sh\">2.1 sh</h3>\n<p>即Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh，由Bell Labs开发。</p>\n<p>本文讲的是sh，如果你使用其它语言用作shell编程，请自行参考相应语言的文档。</p>\n<h3 id=\"bash\">2.2 bash</h3>\n<p>Bash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash。<strong><em>业界通常混用bash、sh、和shell</em></strong>，比如你会经常在招聘运维工程师的文案中见到：熟悉Linux Bash编程，精通Shell编程。</p>\n<p>在CentOS里，/bin/sh是一个指向/bin/bash的符号链接: <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@centosraw ~]# ls -l &#x2F;bin&#x2F;*sh</span><br><span class=\"line\">-rwxr-xr-x. 1 root root 903272 Feb 22 05:09 &#x2F;bin&#x2F;bash</span><br><span class=\"line\">-rwxr-xr-x. 1 root root 106216 Oct 17  2012 &#x2F;bin&#x2F;dash</span><br><span class=\"line\">lrwxrwxrwx. 1 root root      4 Mar 22 10:22 &#x2F;bin&#x2F;sh -&gt; bash</span><br></pre></td></tr></table></figure></p>\n<p>但在Mac OS上不是，/bin/sh和/bin/bash是两个不同的文件，尽管它们的大小只相差100字节左右: <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iMac:~ wuxiao$ ls -l &#x2F;bin&#x2F;*sh</span><br><span class=\"line\">-r-xr-xr-x  1 root  wheel  1371648  6 Nov 16:52 &#x2F;bin&#x2F;bash</span><br><span class=\"line\">-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 &#x2F;bin&#x2F;csh</span><br><span class=\"line\">-r-xr-xr-x  1 root  wheel  2180736  6 Nov 16:52 &#x2F;bin&#x2F;ksh</span><br><span class=\"line\">-r-xr-xr-x  1 root  wheel  1371712  6 Nov 16:52 &#x2F;bin&#x2F;sh</span><br><span class=\"line\">-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 &#x2F;bin&#x2F;tcsh</span><br><span class=\"line\">-rwxr-xr-x  1 root  wheel  1103984  6 Nov 16:52 &#x2F;bin&#x2F;zsh</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"高级编程语言\">2.3 高级编程语言</h3>\n<p>理论上讲，只要一门语言提供了解释器（而不仅是编译器），这门语言就可以胜任脚本编程，常见的解释型语言都是可以用作脚本编程的，如：Perl、Tcl、Python、PHP、Ruby。Perl是最老牌的脚本编程语言了，Python这些年也成了一些linux发行版的预置解释器。</p>\n<p>编译型语言，只要有解释器，也可以用作脚本编程，如C shell是内置的（/bin/csh），Java有第三方解释器Jshell，Ada有收费的解释器AdaScript。</p>\n<p>如下是一个PHP Shell Script示例（假设文件名叫test.php）： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#!&#x2F;usr&#x2F;bin&#x2F;php</span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">for ($i&#x3D;0; $i &lt; 10; $i++)</span><br><span class=\"line\">        echo $i . &quot;\\n&quot;;</span><br></pre></td></tr></table></figure></p>\n<p>执行： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;php test.php</span><br></pre></td></tr></table></figure></p>\n<p>或者： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod +x test.php</span><br><span class=\"line\">.&#x2F;test.php</span><br></pre></td></tr></table></figure> chmod命令用来变更文件或目录的权限</p>\n<h1 id=\"四选择shell编程语言\">四、选择Shell编程语言</h1>\n<h2 id=\"熟悉-vs-陌生\">1. 熟悉 vs 陌生</h2>\n<p>如果你已经掌握了一门编程语言（如PHP、Python、Java、JavaScript），建议你就直接使用这门语言编写脚本程序，虽然某些地方会有点啰嗦，但你能利用在这门语言领域里的经验（单元测试、单步调试、IDE、第三方类库）。</p>\n<p>新增的学习成本很小，只要学会怎么使用shell解释器（Jshell、AdaScript）就可以了。 ## 2. 简单 vs 高级 如果你觉得自己熟悉的语言（如Java、C）写shell脚本实在太啰嗦，你只是想做一些备份文件、安装软件、下载数据之类的事情，学着使用sh，bash会是一个好主意。</p>\n<p>shell只定义了一个非常简单的编程语言，所以，如果你的脚本程序复杂度较高，或者要操作的数据结构比较复杂，那么还是应该使用Python、Perl这样的脚本语言，或者是你本来就已经很擅长的高级语言。因为sh和bash在这方面很弱，比如说：</p>\n<ul>\n<li>它的函数只能返回字串，无法返回数组</li>\n<li>它不支持面向对象，你无法实现一些优雅的设计模式</li>\n<li>它是解释型的，一边解释一边执行，连PHP那种预编译都不是，如果你的脚本包含错误(例如调用了不存在的函数)，只要没执行到这一行，就不会报错</li>\n</ul>\n<h2 id=\"环境兼容性\">3. 环境兼容性</h2>\n<p>如果你的脚本是提供给别的用户使用，使用sh或者bash，你的脚本将具有最好的环境兼容性，perl很早就是linux标配了，python这些年也成了一些linux发行版的标配，至于mac os，它默认安装了perl、python、ruby、php、java等主流编程语言。</p>\n<h1 id=\"五-第一个shell脚本\">五、 第一个Shell脚本</h1>\n<h2 id=\"编写\">1. 编写</h2>\n<p>打开文本编辑器，新建一个文件，扩展名为.sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用.php好了。</p>\n<p>输入一些代码，第一行一般是这样： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#!&#x2F;bin&#x2F;bash</span><br><span class=\"line\">#!&#x2F;usr&#x2F;bin&#x2F;php</span><br></pre></td></tr></table></figure> “#!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。</p>\n<h2 id=\"运行\">2. 运行</h2>\n<p>运行Shell脚本有两种方法： ### 2.1 作为可执行程序 <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod +x test.sh</span><br><span class=\"line\">.&#x2F;test.sh</span><br></pre></td></tr></table></figure> <strong>注意</strong> 一定要写成<code>./test.sh</code>，而不是<code>test.sh</code>，运行其它 <strong>二进制的程序</strong> 也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，<em>你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的</em>，要用./test.sh告诉系统说，就在当前目录找。 <code>./</code>表示当前目录。</p>\n<p>通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。</p>\n<p>这里的\"系统\"，其实就是shell这个应用程序（想象一下Windows Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。</p>\n<h3 id=\"作为解释器参数\">2.2 作为解释器参数</h3>\n<p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如： <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;bin&#x2F;sh test.sh</span><br><span class=\"line\">&#x2F;bin&#x2F;php test.php</span><br></pre></td></tr></table></figure> 这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p>\n<h1 id=\"参考链接\">参考链接</h1>\n<ol type=\"1\">\n<li>《<a href=\"http://man.linuxde.net/chmod\">chmod命令</a>》</li>\n<li>《<a href=\"https://zh.wikipedia.org/wiki/Thompson_shell\">Thompson shell</a>》</li>\n<li>《<a href=\"https://zh.wikipedia.org/wiki/Bourne_shell\">Bourne shell</a>》</li>\n<li>《<a href=\"https://zh.wikipedia.org/wiki/Bash\">bash</a>》</li>\n<li>《<a href=\"https://wido.me/sunteya/understand-bashrc-and-profile\">理解 bashrc 和 profile</a>》</li>\n</ol>\n","categories":["Linux"],"tags":["Shell","Ubuntu"]},{"title":"UnixShell常用命令","url":"/2021/05/27/Linux/Shell/2021-05-27-UnixShell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"<h1 id=\"coreshell\">Core/Shell</h1>\n<p>首先，要理解Core / shell的概念，系统内核一般被称之为core，而unix及类unix（即与unix类似）系统（如linux）都继承了这一概念，都有其内核。</p>\n<p>古早时期，都是一台电脑就是一台服务器，为了提高服务器的利用率，大家都在用很多客户端登录系统，系统分时（电脑高效处理任务，看起来像是同时进行，其实还是存在先后顺序的）为许多客户端提供服务，即“一点对多点”式的服务模式，客户端都通过小黑窗进行操作。</p>\n<p>如今，独立PC都已经没了服务器这一概念，一台设备就只为一个客户服务（单点对单点），但是这个小黑窗的高效操作的理念却被保留了下来。</p>\n<p>因为所有的客户端对主机的使用都没有进入到内核层面，仅仅停留在表面，所以这种小黑窗的操作层被称为shell层，即外壳。</p>\n<p>逐渐衍生了终端的概念，即客户端即用户终端，即terminal；现在shell、terminal、command-line（命令行）这几个概念都可以被视为同一个概念。</p>\n<p>但shell的流行，逐渐衍生除了很多个人制作的版本，流行的有bash shell、zsh等。</p>\n<h1 id=\"目录操作\">目录操作</h1>\n<h2 id=\"cd\">cd</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd zplusplus</span><br></pre></td></tr></table></figure>\n<p>即Change directory，改变目录</p>\n<p>类unix中没有路径这个概念，只有目录。</p>\n<blockquote>\n<ul>\n<li><p><code>~</code> 主目录，个人目录</p></li>\n<li><p><code>/</code> 根目录，硬盘目录</p></li>\n</ul>\n</blockquote>\n<p>TIPS:</p>\n<ul>\n<li>按<code>tabs</code>键可以快速补全相符的目录名称</li>\n</ul>\n<p><code>cd ../</code>可以返回上一层文件目录</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210528002003445.png\" alt=\"image-20210528002003445\" /><figcaption aria-hidden=\"true\">image-20210528002003445</figcaption>\n</figure>\n<h2 id=\"mkdir\">mkdir</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir zplusplus</span><br></pre></td></tr></table></figure>\n<p>即make directory，创建目录</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210528001730316.png\" alt=\"image-20210528001730316\" /><figcaption aria-hidden=\"true\">image-20210528001730316</figcaption>\n</figure>\n<h2 id=\"mv\">mv</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mv zplusplus</span><br></pre></td></tr></table></figure>\n<p>即move，移动或删除</p>\n<blockquote>\n<ul>\n<li><code>-f</code> force 强制</li>\n</ul>\n</blockquote>\n<p>也可以用来改名，用法如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">mv main.c test.c</span><br></pre></td></tr></table></figure>\n<p>其他类似的语句如 <code>rm</code>，可以参考手册</p>\n<h2 id=\"ls\">ls</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ls</span><br></pre></td></tr></table></figure>\n<p>即List，（展现）列表</p>\n<p>这个命令非常好用，学会了就基本忘不了，各别shell能够提供不同的色彩显示，对于文档类型识别来说非常高效。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210528001701289.png\" alt=\"image-20210528001701289\" /><figcaption aria-hidden=\"true\">image-20210528001701289</figcaption>\n</figure>\n<h1 id=\"文件编辑\">文件编辑</h1>\n<h2 id=\"vim\">vim</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim main.c</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：如果已经存在了<code>main.c</code> 他就不会新生成一个，否则就会新建。</p>\n<p><strong>操作方法</strong>：</p>\n<ol type=\"1\">\n<li>刚进去的时候需要按 <code>i</code> 进行插入（insert）操作</li>\n<li>编辑完毕之后需要先按 <code>ESC</code> 键，在依次输入 <code>:</code> 及其他指令进行退出，具体参考下方，可以看手册。</li>\n</ol>\n<blockquote>\n<p><code>:</code> instructor 指令输入</p>\n<p><code>w</code> wirte</p>\n<p><code>q</code> quit</p>\n<p><code>!</code> 强制</p>\n</blockquote>\n<p><strong>编辑界面如下</strong>：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210528002252175.png\" alt=\"image-20210528002252175\" /><figcaption aria-hidden=\"true\">image-20210528002252175</figcaption>\n</figure>\n<p><strong>科普视频</strong>：</p>\n<iframe src=\"//player.bilibili.com/player.html?aid=55498503&amp;bvid=BV164411P7tw&amp;cid=97032762&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\">\n</iframe>\n<p><strong>自行科普</strong>：GUI，Graphic User Interface 图形用户界面</p>\n<h1 id=\"代码运行\">代码运行</h1>\n<h2 id=\"gcc\">gcc</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gcc main.c </span><br></pre></td></tr></table></figure>\n<p>是<a href=\"https://baike.baidu.com/item/gnu/671972\">GNU</a>下的GCC编译器之一，c的编译器是<code>gcc</code>，c++的编译器是<code>g++</code></p>\n<blockquote>\n<ul>\n<li><code>-o main</code> 参数</li>\n</ul>\n</blockquote>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210528002708689.png\" alt=\"image-20210528002708689\" /><figcaption aria-hidden=\"true\">image-20210528002708689</figcaption>\n</figure>\n<p>编译完成之后使用 <code>ls</code> 可以查看已生成的文件 <code>a.out</code>（默认命名）。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210528002757152.png\" alt=\"image-20210528002757152\" /><figcaption aria-hidden=\"true\">image-20210528002757152</figcaption>\n</figure>\n<p>这个 <code>a.out</code> 文件是CPU能够直接识别和运行的文件，因此直接使用以下代码运行即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./a.out</span><br></pre></td></tr></table></figure>\n<p>运行效果如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210528002900901.png\" alt=\"image-20210528002900901\" /><figcaption aria-hidden=\"true\">image-20210528002900901</figcaption>\n</figure>\n<p>遇到问题可以再进行调试。</p>\n<p>对GNU和开源的概念可以参考下方视频：</p>\n<iframe src=\"//player.bilibili.com/player.html?aid=413061830&amp;bvid=BV1zV411d7La&amp;cid=186095567&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\">\n</iframe>\n","categories":["Linux"],"tags":["shell","linux","unix","Mac"]},{"title":"MBR和GPT的区别","url":"/2019/03/08/Linux/System/2019-03-08MBR%E5%92%8CGPT%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"<p>1、传统的BIOS只支持从MBR分区的硬盘启动。MBR分区的分区表保存在硬盘的第一个扇区，而且只有64字节，所以最多只能有四个表项。也就是说，我们只能把硬盘分为4主分区，或者分成小于等于3个主分区再加一个扩展分区。扩展分区又可以分为多个逻辑分区。MBR分区的优点就是简单，大家都用，所以大家都懂的嘛，很多操作系统都可以从MBR分区的硬盘启动。缺点就是MBR分区不能识别大于2T的硬盘空间，也不能有大于2T的分区；</p>\n<p>2、GPT分区的硬盘可以解决以上MBR分区的所有缺点，它没有4个主分区的限制，想分几个主分区就可以分几个主分区，它可以识别大于2T的硬盘空间，每个分区的大小也可以超过2T。但是它的缺点是需要操作系统支持。比如只有WinXP 64位、Win Vista、Win 7和Win 8和比较新的Linux发行版支持GPT分区的硬盘。而且，如果没有EFI的支持的话，以上系统也只能将GPT分区的硬盘当成数据盘，不能从GPT分区的硬盘启动；</p>\n<p>3、要从GPT分区的硬盘启动，则主板使用EFI、硬盘使用GPT分区、操作系统支持GPT和EFI这三个条件缺一不可。目前比较新的64位Linux系统和Win8系统都是支持EFI的，所以都是需要从GPT分区的硬盘启动的。现在的电脑主板已经逐渐抛弃legacy BIOS，而只支持EFI了。（像我的工作机这样的过渡产品将越来越少。）目前很多预装Win8的笔记本的主板几乎都只支持EFI了。所以，学习GPT和EFI的相关知识势在必行；</p>\n<p>4、以上分区策略都是固定分区。硬盘分区一旦完成，则分区的大小不可改变，如果要改变分区的大小的话，只有重新分区。而且由于没有办法把多个硬盘分到一个区，所以再怎么分，每个分区的大小都有限。所以我们需要一种动态分区的东西。LVM就是这样一个东西，它叫逻辑卷管理（Logical Volume Manager）。使用LVM的机制是这样的：首先把硬盘分区或者整块硬盘标记为一个物理卷（PV），然后再创建一个卷组（VG），把一个或多个物理卷加入卷组，最后对卷组进行分区，每一个分区称为一个逻辑卷（LV）。LVM的优点就是可以随时向卷组中添加物理卷扩展卷组的大小，以可以动态调整逻辑卷的大小。这在服务器中尤其有用，比如说有一个原本有100个用户的服务器，其/home目录下就会有100个用户的主目录，如果给他们每人分配20G的空间的话，就会占满一个2T的硬盘，如果这时再来100个用户怎么办？如果使用LVM就可以顺利解决这个问题，我们可以再加一个3T的硬盘，然后把这个硬盘加入卷组就可以扩大卷组的大小，然后再调整/home所在的逻辑卷的大小即可。LVM既可以搭配MBR使用，也可以搭配GPT使用。</p>\n","categories":["Linux"],"tags":["MBR","GPT"]},{"title":"Linux分区及文件系统","url":"/2021/04/22/Linux/System/2021-04-22-Linux%E5%88%86%E5%8C%BA%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","content":"<h1 id=\"linux分区与挂载\">Linux分区与挂载</h1>\n<h2 id=\"分区表\">分区表</h2>\n<p><strong>分区表</strong>(partition table)是将大表的数据分成称为分区的许多小的子集，类型有FAT16, FAT32, NTFS, exFAT, Ext2/3/4, HFS+, VMFS。另外，分区表的种类划分主要有：range（范围）、list（列表）和hash（散列）分区。划分依据主要是根据其表内部属性。同时，分区表可以创建其独特的分区索引。倘若硬盘丢失了分区表，数据就无法按顺序读取和写入，导致无法操作。</p>\n<p>Kali Linux支持的分区表类型：aix、amiga、bsd、dvh、gpt、mac、msdos、pc98、sun、atari 及 loop。</p>\n<h2 id=\"磁盘结构\">磁盘结构</h2>\n<p><img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/kzq6k9g8x7.png\" /></p>\n<p>磁盘结构</p>\n<p>磁盘主要分为以下结构：</p>\n<ul>\n<li>磁头（head）：对磁盘的数据进行读写</li>\n<li>磁道（track）：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道。 磁盘上的磁道是一组记录密度不同的同心圆</li>\n<li>扇区（sector）：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区。硬盘的第一个扇区，叫做引导扇区。 一个扇区的大小为512个字节。</li>\n<li>柱面（cylinder）：在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面。</li>\n</ul>\n<p>整个磁盘的存储大小为： <strong>存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数</strong></p>\n<h2 id=\"磁盘的使用\">磁盘的使用</h2>\n<p>一块新的硬盘或者U盘等外部设备在插入PC后，需要完成以下事情：</p>\n<ul>\n<li>在/dev/下创建一个新的目录，用来代表该磁盘。如/dev/hda，/dev/hdb等。</li>\n<li>磁盘最开始需要进行格式化，使用<code>mkfs</code>命令为磁盘进行格式化，确定文件系统类型。</li>\n<li>对硬盘进行分区后才可以使用。</li>\n<li>在Linux中挂载到一个已经存在的目录下才可以访问该磁盘，否则无法访问。使用<code>mount</code>与<code>unmount</code>来进行挂载和卸载。</li>\n</ul>\n<blockquote>\n<p>一般挂在点都在/mnt/xxx目录下，并且该目录必须是已经存在的，否则无法挂载</p>\n</blockquote>\n<h2 id=\"fdisk的使用\">fdisk的使用</h2>\n<p>在Linux中，使用fdisk来查看当前的硬盘以及硬盘的分区、文件系统等信息。并且使用fdisk命令可以为磁盘进行分区。 fdisk的命令有以下这些： Fdisk命令详解：</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: left;\">命令</th>\n<th style=\"text-align: left;\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">m</td>\n<td style=\"text-align: left;\">获取帮助</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">n</td>\n<td style=\"text-align: left;\">新建分区</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">p</td>\n<td style=\"text-align: left;\">显示分区表</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">d</td>\n<td style=\"text-align: left;\">删除分区</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">b</td>\n<td style=\"text-align: left;\">设置卷标</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">w</td>\n<td style=\"text-align: left;\">写入分区表</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">t</td>\n<td style=\"text-align: left;\">改变分区文件系统类型</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">v</td>\n<td style=\"text-align: left;\">检验分区</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">l</td>\n<td style=\"text-align: left;\">显示fdisk所支持的文件系统代码</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">q</td>\n<td style=\"text-align: left;\">退出</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"fdisk示例\">fdisk示例</h5>\n<ol type=\"1\">\n<li>使用<code>fdisk -l</code>查看当前所有硬盘以及分区的状态。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"># fdisk -l</span><br><span class=\"line\"></span><br><span class=\"line\">Disk /dev/sda: <span class=\"number\">10.7</span> GB, <span class=\"number\">10737418240</span> bytes</span><br><span class=\"line\"><span class=\"number\">255</span> heads, <span class=\"number\">63</span> sectors/track, <span class=\"number\">1305</span> cylinders</span><br><span class=\"line\">Units = cylinders <span class=\"keyword\">of</span> <span class=\"number\">16065</span> * <span class=\"number\">512</span> = <span class=\"number\">8225280</span> bytes</span><br><span class=\"line\"></span><br><span class=\"line\">Device Boot   Start     End   Blocks  Id System</span><br><span class=\"line\">/dev/sda1  *      <span class=\"number\">1</span>     <span class=\"number\">13</span>   <span class=\"number\">104391</span>  <span class=\"number\">83</span> Linux</span><br><span class=\"line\">/dev/sda2       <span class=\"number\">14</span>    <span class=\"number\">1305</span>  <span class=\"number\">10377990</span>  8e Linux LVM</span><br><span class=\"line\"></span><br><span class=\"line\">Disk /dev/sdb: <span class=\"number\">5368</span> MB, <span class=\"number\">5368709120</span> bytes</span><br><span class=\"line\"><span class=\"number\">255</span> heads, <span class=\"number\">63</span> sectors/track, <span class=\"number\">652</span> cylinders</span><br><span class=\"line\">Units = cylinders <span class=\"keyword\">of</span> <span class=\"number\">16065</span> * <span class=\"number\">512</span> = <span class=\"number\">8225280</span> bytes</span><br><span class=\"line\"></span><br><span class=\"line\">Disk /dev/sdb doesn<span class=\"string\">&#x27;t contain a valid partition table</span></span><br></pre></td></tr></table></figure>\n<p>可以看到目前有两个磁盘：</p>\n<ul>\n<li>sda：10.7G，255个磁头，63个磁道，1305个扇区\n<ul>\n<li>主分区1：/dev/sda1</li>\n<li>主分区2：/dev/sda2</li>\n</ul></li>\n<li>sdb：5G，255个磁头，63个磁道，652个扇区\n<ul>\n<li>无分区</li>\n</ul></li>\n</ul>\n<h2 id=\"分区的概念\">分区的概念</h2>\n<p>Linux中，磁盘只有被分区完后，才可以被挂载到目录下。</p>\n<p>分区有三种：主分区，扩展分区，逻辑分区，每个磁盘最多只能有四个主分区，而可以有多个扩展分区，在扩展分区中，还可以创建多个逻辑分区。</p>\n<ul>\n<li>主分区：创建完后即可挂载</li>\n<li>扩展分区：扩展分区创建完后，还需要创建逻辑分区才可以被挂载</li>\n</ul>\n<h2 id=\"示例\">示例</h2>\n<p>格式化一块硬盘(hdb)，并且对其进行分区，分区后进行挂载</p>\n<h5 id=\"创建主分区\">创建主分区</h5>\n<ol type=\"1\">\n<li>通过<code>fdisk /dev/hdb</code>进入磁盘的命令模式</li>\n</ol>\n<figure>\n<img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/s22aqd4o24.png\" alt=\"s22aqd4o24\" /><figcaption aria-hidden=\"true\">s22aqd4o24</figcaption>\n</figure>\n<p>进入格式化命令模式</p>\n<ol type=\"1\">\n<li>输入<code>n</code>代表创建分区，<code>e</code>代表扩展分区，<code>p</code>代表主分区</li>\n</ol>\n<figure>\n<img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/0u6woej2nq.png\" alt=\"0u6woej2nq\" /><figcaption aria-hidden=\"true\">0u6woej2nq</figcaption>\n</figure>\n<p>新建主分区</p>\n<ol type=\"1\">\n<li>输入<code>First Cylinder</code>的值代表分区初始的柱面值，以及分区的大小<code>+3G</code>代表为该分区分3G</li>\n</ol>\n<figure>\n<img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/vopy3iwz2v.png\" alt=\"vopy3iwz2v\" /><figcaption aria-hidden=\"true\">vopy3iwz2v</figcaption>\n</figure>\n<p>输入初始柱面的值以及分区大小</p>\n<ol type=\"1\">\n<li>输入<code>p</code>查看创建的分区<code>/dev/hdb1</code></li>\n</ol>\n<figure>\n<img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/rflbc73wpf.png\" alt=\"rflbc73wpf\" /><figcaption aria-hidden=\"true\">rflbc73wpf</figcaption>\n</figure>\n<p>新建分区</p>\n<h5 id=\"创建扩展分区\">创建扩展分区</h5>\n<ol type=\"1\">\n<li>与创建主分区步骤相同，只是在选择<code>command action</code>的时候，选择<code>e</code>，表示创建扩展分区</li>\n</ol>\n<figure>\n<img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/ymjwni22fr.png\" alt=\"ymjwni22fr\" /><figcaption aria-hidden=\"true\">ymjwni22fr</figcaption>\n</figure>\n<p>创建后的扩展分区</p>\n<ol type=\"1\">\n<li>在创建完扩展分区后，来创建逻辑分区，输入<code>l</code>代表创建逻辑分区</li>\n</ol>\n<figure>\n<img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/ra4wa3017d.png\" alt=\"ra4wa3017d\" /><figcaption aria-hidden=\"true\">ra4wa3017d</figcaption>\n</figure>\n<p>创建逻辑分区</p>\n<ol type=\"1\">\n<li>与创建主分区、扩展分区一样，为逻辑分区选择起始的柱面，以及分配的大小</li>\n</ol>\n<figure>\n<img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/y0kb4p9z23.png\" alt=\"y0kb4p9z23\" /><figcaption aria-hidden=\"true\">y0kb4p9z23</figcaption>\n</figure>\n<p>分配分区大小</p>\n<ol type=\"1\">\n<li>查看扩展分区</li>\n</ol>\n<figure>\n<img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/c78q2lt7wi.png\" alt=\"c78q2lt7wi\" /><figcaption aria-hidden=\"true\">c78q2lt7wi</figcaption>\n</figure>\n<p>查看分区信息</p>\n<h5 id=\"分区格式化\">分区格式化</h5>\n<p>在磁盘分区创建完毕后，需要为分区通过<code>mkfs</code>进行格式化，赋予它文件系统： 如<code>ext2</code>,<code>ext3</code>,<code>vfat</code>等</p>\n<p>使用命令 <code>mkfs -t ext3 /dev/hdb1</code>分别对分区<code>hdb1</code>进行格式化处理，格式化为ext3文件类型</p>\n<p>其中<code>mkfs –t ext3</code>命令等价于<code>mkfs.ext3</code>，<code>mkfs -t ext2</code>命令等价于<code>mkfs.ext2</code></p>\n<figure>\n<img src=\"https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/513p7ponts.png\" alt=\"513p7ponts\" /><figcaption aria-hidden=\"true\">513p7ponts</figcaption>\n</figure>\n<p>mkfs命令</p>\n<h5 id=\"分区挂载\">分区挂载</h5>\n<p>当分区格式化完成文件系统后，就可以通过<code>mount</code>与<code>unmount</code>进行挂载与卸载了，当分区挂载到具体目录后，即可进行创建文件、删除文件等文件操作了。</p>\n<p>如<code>mount /dev/hdb1 /mnt/hdb1</code>就会将<code>/dev/hdb1</code>分区挂载到<code>/mnt/hdb1</code>目录下，也就是该目录下的文件都会被写到<code>/dev/hdb1</code>的磁盘分区中保存。</p>\n<p>本文参与<a href=\"https://cloud.tencent.com/developer/support-plan\">腾讯云自媒体分享计划</a>，欢迎正在阅读的你也加入，一起分享。</p>\n<h1 id=\"linux-文件系统\">Linux 文件系统</h1>\n<h2 id=\"文件系统类型\">文件系统类型</h2>\n<p>Kali Linux支持：btrfs、exfat、ext2\\3\\4、f2fs、fat16、fat32、hfs、hfs+、jfs、linux-swap、lvm2 pv、minix、nilfs2、ntfs、reiser4、reiserfs、udf、xfs;</p>\n<h3 id=\"linux-swap\">LINUX-SWAP</h3>\n<p>Swap分区在系统的物理内存不够用的时候，把硬盘空间中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。 本文将从分区开始讲解如何开启SWAP交换空间</p>\n<h4 id=\"分区\">分区</h4>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 查看块设备</span><br><span class=\"line\"># 如图可以看出硬盘sda和vdb还有剩余</span><br><span class=\"line\">[root@rainss ~]# lsblk</span><br></pre></td></tr></table></figure>\n<h2 id=\"分区类型\">分区类型</h2>\n<p>主分区、扩展分区、逻辑分区</p>\n<h2 id=\"对齐类型\">对齐类型</h2>\n<p>对齐到MiB、对齐到柱面</p>\n","categories":["Linux"],"tags":["Filesystem"]},{"title":"硬件系统测试术语整理","url":"/2019/02/13/Others/%E7%A1%AC%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95/%E7%A1%AC%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95%E6%9C%AF%E8%AF%AD%E6%95%B4%E7%90%86/","content":"<h1 id=\"关于测试\">关于测试</h1>\n<p>测试的目的决定了如何去组织测试。如果测试的目的是为了尽可能多的找出错误，那么测试就应该直接针对设计比较复杂的部分，或是以前出错比较多的位置。如果测试的目的是为了给最终用户提供具有一定可信度的质量评价，那么测试就应该直接针对在实际应用中经常用到的商业假设。</p>\n<p>测试并不仅仅是为了要找出错误。通过分析错误产生的原因和错误的分布特征，可以帮助项目管理者发现当前设计过程的缺陷，以便改进。同时，这种分析也能帮助测试人员 设计出有针对性的检测方法，改善测试的有效性。</p>\n<p>没有发现错误的测试也是有价值的，完整的测试时评定测试质量的一种方法。</p>\n<p>硬件系统测试分为 <strong>软件测试</strong> 及 <strong>硬件测试</strong> 两部分。</p>\n<p>软件部分可以依据现行软件测试的流行办法来测试。</p>\n<p>硬件测试部分分为 <strong>硬件基础测试</strong> 和 <strong>硬件功能级以上测试</strong> 两部分。即除了测试各项硬件参数性能是否符合设计要求以外，仍需要测量硬件功能及联动特性是否符合要求。</p>\n<h1 id=\"术语\">术语</h1>\n<h2 id=\"单元测试\">单元测试</h2>\n<p>Unit testing，也称为Module testing（模块测试）。是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。</p>\n<p>单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。</p>\n<p>经常与单元测试联系起来的另外一些开发活动包括代码走读（Code review)，<strong>静态分析</strong>（Static analysis)和<strong>动态分析</strong>（Dynamic analysis)。 <strong>静态分析</strong> 就是对软件的源代码进行研读，查找错误或收集一些度量数据，并不需要对代码进行编译和执行。 <strong>动态分析</strong> 就是通过观察软件运行时的动作，来提供执行跟踪，时间分析，以及测试覆盖度方面的信息。</p>\n<h2 id=\"集成测试\">集成测试</h2>\n<p>Assemble testing，也叫 <strong>组装测试</strong> 或 <strong>联合测试</strong> 。在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。</p>\n<p>实践表明，一些模块虽然能够单独地工作，但并不能保证连接起来也能正常的工作。一些局部反映不出来的问题，在全局上很可能暴露出来。</p>\n<h2 id=\"功能测试\">功能测试</h2>\n<p>Functional testing，也称为Behavioral testing（行为测试）和Black Box testing（黑盒测试），根据产品特性、操作描述和用户方案，测试一个产品的特性和可操作行为以确定它们满足设计需求。</p>\n<h2 id=\"系统测试\">系统测试</h2>\n<p>System Testing，是对整个系统的测试，将硬件、软件、操作人员看作一个整体，检验它是否有不符合系统说明书的地方。这种测试可以发现系统分析和设计中的错误。如安全测试是测试安全措施是否完善，能不能保证系统不受非法侵入。再例如，压力测试是测试系统在正常数据量以及超负荷量(如多个用户同时存取) 等情况下是否还能正常地工作。</p>\n<h2 id=\"冒烟测试\">冒烟测试</h2>\n<p>Smoke testing，对一个硬件或硬件组件进行更改或修复后，直接给设备加电。如果没有冒烟，则该组件就通过了测试。在软件中，“冒烟测试”这一术语描述的是在将代码更改嵌入到产品的源树中之前对这些更改进行验证的过程。在检查了代码后，冒烟测试是确定和修复软件缺陷的最经济有效的方法。冒烟测试设计用于确认代码中的更改会按预期运行，且不会破坏整个版本的稳定性。</p>\n<h2 id=\"验收测试\">验收测试</h2>\n<p>验收测试是部署软件之前的最后一个测试操作。在软件产品完成了单元测试、集成测试和系统测试之后，产品发布之前所进行的软件测试活动。它是技术测试的最后一个阶段，也称为交付测试。验收测试的目的是确保软件准备就绪，并且可以让最终用户将其用于执行软件的既定功能和任务。</p>\n<p>检验系统说明书的各项功能与性能是否实现和满足要求。常见的有α测试、β测试，都是由用户进行的。</p>\n<h1 id=\"参考链接\">参考链接</h1>\n<p>1.《<a href=\"https://zhidao.baidu.com/question/294458045.html\">集成测试与联调测试的区别</a>》 2.《<a href=\"https://blog.csdn.net/u012426327/article/details/78400045\">软件测试方法——单元测试、集成测试、系统测试、确认测试</a>》 3.《<a href=\"http://www.cqvip.com/read/read.aspx?id=32762184\">浅谈电子产品的硬件测试技术</a>》</p>\n","categories":["InternetOfThings"],"tags":["Testing","hardware"]},{"title":"ISO-IEC_9899-2011 学习笔记","url":"/2021/05/24/Programming/C/2021-05-24-ISO-IEC_9899-2011-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"<h1 id=\"预备知识\">预备知识</h1>\n<h2 id=\"c标准库\">C标准库</h2>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210524001458724.png\" alt=\"image-20210524001458724\" /><figcaption aria-hidden=\"true\">image-20210524001458724</figcaption>\n</figure>\n<h3 id=\"文本流\">文本流</h3>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210524001643408.png\" alt=\"image-20210524001643408\" /><figcaption aria-hidden=\"true\">image-20210524001643408</figcaption>\n</figure>\n<h3 id=\"二进制流\">二进制流</h3>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210524001722423.png\" alt=\"image-20210524001722423\" /><figcaption aria-hidden=\"true\">image-20210524001722423</figcaption>\n</figure>\n<h1 id=\"基本概念\">基本概念</h1>\n<h2 id=\"字符集和字符编码\">字符集和字符编码</h2>\n<p><a href=\"https://unicode.org/\">UNICODE主页</a></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210524002528437.png\" alt=\"image-20210524002528437\" /><figcaption aria-hidden=\"true\">image-20210524002528437</figcaption>\n</figure>\n<h3 id=\"字符集对内存的影响\">字符集对内存的影响</h3>\n<p>字符集涉及编码规则，包括单个字符所占用的空间大小，进而影响数据在硬件中的内存占用。</p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210526002443105.png\" alt=\"image-20210526002443105\"  /></p>\n<p>如果将UTF-8转换成更为精简的GBK字符集，则会输出不同的结果。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210526002630693.png\" alt=\"image-20210526002630693\" /><figcaption aria-hidden=\"true\">image-20210526002630693</figcaption>\n</figure>\n","categories":["Programming"],"tags":["C","ISO","IEC","9899","2011"]},{"title":"存储类别、链接和内存管理","url":"/2021/06/21/Programming/C/2021-06-21-%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","content":"<h1 id=\"存储类别\">存储类别</h1>\n<p>即 stroage class，C语言提供了多种不同的模型和存储类别在内存中存储数据。</p>\n<blockquote>\n<p>从硬件方面看， 被存储的每个值都占有一定的物理内存，C语言称之为对象（object）。</p>\n<p>与面向对象编程中的对象不同，面向对象编程的对象指的是“类对象”。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> entity = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<p>该声明创造了一个名为 entity 的 <strong>标识符</strong>（identifier）。标识符可以用来 <strong>指定</strong>（desingate）特定对象的内容，且须遵循变量的命名规则。</p>\n<p>标识符即 软件（C语言）指定硬件内存中的对象（内存区块）的方式。</p>\n<p>同时，那些指定对象的表达式被称为 <strong>左值</strong>。</p>\n<p>左值可以被理解为是 “有具体存储位置的 <strong>对象</strong> ”，区别于 “仅有值而没有具体存储位置” 的数据。</p>\n<p>另，左值中也有可修改的 <strong>普通左值</strong>， 和不能支持修改的 <strong>常量左值</strong>。</p>\n<blockquote>\n<p><em>“左”(left)的原意是指可以放在赋值符号“=”的左边，但其实也表示能作为&amp;和++等操作符的操作数（B语言中已经如此）。而且，现代C/C++中的含义已经不局限于此。lvalue的 <code>l</code> 被重新解释为location。这也对应于ISO C11/ISO C++11的 <strong>内存位置</strong>(memory location)。</em></p>\n<p>——百度百科</p>\n</blockquote>\n<p>从一个左值中必定可以解析出对应对象的地址，除非该对象是位字段（bit-field）或者被声明为寄存器存储类。生成左值的运算符包括下标运算符（subscript operator）[]和间接运算符（indirection operator）*，如下表所示（如果 array 已被声明为数组，而 ptr 被声明为指针变量）。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>表达式</th>\n<th>是左值吗</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>array[1]</td>\n<td>是；一个数组元素是一个具有位置的对象</td>\n</tr>\n<tr class=\"even\">\n<td>&amp;array[1]</td>\n<td>否；此对象的位置，并非一个具有位置的对象</td>\n</tr>\n<tr class=\"odd\">\n<td>ptr</td>\n<td>是；此指针变量是一个具有位詈的对象</td>\n</tr>\n<tr class=\"even\">\n<td>*ptr</td>\n<td>是；指针所指的地方是一个具有位置的对象</td>\n</tr>\n<tr class=\"odd\">\n<td>ptr+1</td>\n<td>否；此加法产生一个新的地址值，但不是一个对象</td>\n</tr>\n<tr class=\"even\">\n<td>*ptr+l</td>\n<td>否；此加法产生一个新的算术值，但不是一个对象</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li>《C Primer Plus》, Stephen Prata</li>\n<li><a href=\"https://baike.baidu.com/item/%E5%B7%A6%E5%80%BC\">左值</a></li>\n<li><a href=\"http://c.biancheng.net/view/281.html\">C语言左值与右值详解</a></li>\n</ol>\n","categories":["Programming"],"tags":["stroage class","linkage","menory management","lvalue"]},{"title":"10进制整型转换成16进制显示的字符串","url":"/2019/01/17/Programming/C++/2019-01-17-C++%20-%2010%E8%BF%9B%E5%88%B6%E6%95%B4%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%88%9016%E8%BF%9B%E5%88%B6%E6%98%BE%E7%A4%BA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"<p>原文出处：《<a href=\"https://blog.csdn.net/ma2595162349/article/details/74590285\">十进制数转为十六进制字符串</a>》</p>\n<p>本文修改了以上原文的代码，修正了[0-16]区间的10进制数转换成16进制数时无法正确转换的问题。</p>\n<p>代码如下： <figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> Hexadecimal_Code[]=<span class=\"string\">&quot;0123456789ABCDEF&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> str_Temp[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">Decimal_To_Hexadecimal_String</span><span class=\"params\">(<span class=\"keyword\">int</span> Decimal_Data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> High,Low,i=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(Decimal_Data &lt;= <span class=\"number\">0</span> || Decimal_Data &gt; <span class=\"number\">255</span>)</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tHigh=Decimal_Data &gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">   \tLow=Decimal_Data &amp; <span class=\"number\">15</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  \tstr_Temp[i++]=Hexadecimal_Code[High];</span><br><span class=\"line\">\tstr_Temp[i++]=Hexadecimal_Code[Low];</span><br><span class=\"line\">\tstr_Temp[i]=<span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> str_Temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>,Decimal_To_Hexadecimal_String(<span class=\"number\">5</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">   \t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","categories":["Programming"],"tags":["C","C++","String","Transform"]},{"title":"C++","url":"/2021/01/05/Programming/C++/2021-01-05-C++/","content":"<h1 id=\"c语法及基础\">C++语法及基础</h1>\n<h2 id=\"运算符\">运算符</h2>\n<p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符：</p>\n<ul>\n<li>算术运算符</li>\n<li>关系运算符</li>\n<li>逻辑运算符</li>\n<li>位运算符</li>\n<li>赋值运算符</li>\n<li>杂项运算符</li>\n</ul>\n<h3 id=\"位运算符\">位运算符</h3>\n<p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>p</th>\n<th>q</th>\n<th>p &amp; q</th>\n<th>p | q</th>\n<th>p ^ q</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr class=\"even\">\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr class=\"odd\">\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr class=\"even\">\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：</p>\n<blockquote>\n<p>A = 0011 1100</p>\n<p>B = 0000 1101</p>\n</blockquote>\n<p>-----------------</p>\n<blockquote>\n<p>A&amp;B = 0000 1100</p>\n<p>A|B = 0011 1101</p>\n<p>A^B = 0011 0001</p>\n<p>~A = 1100 0011</p>\n</blockquote>\n<p>下表显示了 C 语言支持的位运算符。假设变量 <strong>A</strong> 的值为 60，变量 <strong>B</strong> 的值为 13，则：</p>\n<table style=\"width:100%;\">\n<colgroup>\n<col style=\"width: 4%\" />\n<col style=\"width: 47%\" />\n<col style=\"width: 47%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>运算符</th>\n<th>描述</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>&amp;</td>\n<td>按位与操作，按二进制位进行\"与\"运算。运算规则： <code>0&amp;0=0;    0&amp;1=0;     1&amp;0=0;      1&amp;1=1;</code></td>\n<td>(A &amp; B) 将得到 12，即为 0000 1100</td>\n</tr>\n<tr class=\"even\">\n<td>|</td>\n<td>按位或运算符，按二进制位进行\"或\"运算。运算规则： <code>0|0=0;    0|1=1;    1|0=1;     1|1=1;</code></td>\n<td>(A | B) 将得到 61，即为 0011 1101</td>\n</tr>\n<tr class=\"odd\">\n<td>^</td>\n<td>异或运算符，按二进制位进行\"异或\"运算。运算规则： <code>0^0=0;    0^1=1;    1^0=1;   1^1=0;</code></td>\n<td>(A ^ B) 将得到 49，即为 0011 0001</td>\n</tr>\n<tr class=\"even\">\n<td>~</td>\n<td>取反运算符，按二进制位进行\"取反\"运算。运算规则： <code>~1=-2;    ~0=1;</code></td>\n<td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>\n</tr>\n<tr class=\"odd\">\n<td>&lt;&lt;</td>\n<td>二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</td>\n<td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td>\n</tr>\n<tr class=\"even\">\n<td>&gt;&gt;</td>\n<td>二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</td>\n<td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"mangling\">Mangling</h2>\n<p><strong>重载</strong>，包括 <strong>函数重载</strong> 和 <strong>操作符重载</strong> 。</p>\n<h3 id=\"函数重载\">函数重载</h3>\n<blockquote>\n<p><strong>函数重载</strong> 也叫 <strong>方法重载</strong>。是编译器通过把原方法名称与其参数相结合产生一个独特的内部名字来取代原方法名称的技术。</p>\n<p>基本上，支持函数重载的语言都需要进行Name Mangling。Mangling的目的就是为了给重载的函数不同的签名，以避免调用时的二义性调用。</p>\n</blockquote>\n<p><strong>Name Mangling</strong> 不是一个非常新的技术，在C语言中也有，***在汇编C语言时经常看到的以 下划线“_”开头的函数名，其实就是C编译器将函数名进行了 Name Mangling*** 。</p>\n<p>但是在C++中Name-mangling要复杂的多。 因为C++中支持 <strong><em>overload</em></strong> 和 <strong><em>override</em></strong> ，这就导致了C++编译器必须要有完成的Name-mangling把函数名或者变量名进行调整。</p>\n<p>在面向对象编程语言出现之前，如果你想要打印不同类型的数据,需要写多个方法 ,象是 <code>PrintInteger(int i)</code> ，<code>PrintString(string s)</code> 和 <code>PrintFloat(float f)</code> 。也就是说必须<strong>通过命名来区别行为和数据类型</strong>，因为 OOP语言出现前，任一语言都（像是C）不允许使用相同的名字命名函数， 即使参数类型不同。</p>\n<p>但在C++中，像是 Print(int i)、Print(string s) 和 Print(float f)，编译器自会准确调用特定的Print方法。当调用 <code>Print(1)</code> 的时候, 编译器可能在内部用源于参数类型的前缀重命名Print方法，这样一来 <code>Print(1)</code> 可能就变成 <code>i_Print (1)</code> 。</p>\n<p>下面是更详细的例子：</p>\n<p>C++编译器实际上将下面这些重载函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">float</span> f)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span>* s)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>编译为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">_print_int</span><br><span class=\"line\">_print_char</span><br><span class=\"line\">_print_float</span><br><span class=\"line\">_pirnt_string</span><br></pre></td></tr></table></figure>\n<p>这样的函数名，来唯一标识每个函数。</p>\n<p><strong>注：</strong>不同的编译器实现可能不一样，但是都是利用这种机制。所以当连接是调用 <code>print(3)</code> 时，它会去查找 <code>_print_int(3)</code> 这样的函数。下面说个题外话，正是因为这点，重载被认为不是多态，多态是运行时动态绑定（“一种接口多种实现”），<strong>如果硬要认为重载是多态，它顶多是编译时“多态”。</strong></p>\n<p>C++中的变量，编译也类似，如全局变量可能编译g_xx，类变量编译为c_xx等。连接是也是按照这种机制去查找相应的变量。</p>\n<blockquote>\n<p><code>方法重载</code> 仅是多态性的一种情形。</p>\n<p><code>名称重整</code> 是一种支持方法重载的机制。更普遍的情况下，多态性是与继承相联系。</p>\n</blockquote>\n<h2 id=\"inherit\">Inherit</h2>\n<blockquote>\n<p>继承就是一个新类 (称为子类) 从被继承类（称为父类或超类）取得自身的部分定义同时增加一些自己的新的信息。</p>\n</blockquote>\n<p>如果你在相同的类中重载方法, 数据类型必须是不同的。如果你在继承关系下重载方法, 子类与父类的方法可能完全相同，而且名称重整器生成同样的重整名称。</p>\n<p>举例来说，假设一个超类定义一个 <code>Print(int i)</code> 方法而一个从它继承的子类也定义了一个 <code>Print(int i)</code> 方法。当你有一个子类的实例时，运用多态性调用 <code>Child.Print(int)</code> ；而当你产生一个父类的实例时运用多态性调用 <code>Parent.Print(int)</code> 。这就是继承多态性：相同的名字和签字但是类却不同。</p>\n<p><code>继承多态性</code> 是通过使用一种与名称重整相关的另外一种机制实现的。编译器把方法放置在一个被称为虚拟方法表（其实是一个方法数组）的地方。每一个方法在VMT中都有一个索引, 如此当 <code>Print(int)</code> 被调用的时候, 编译器将被路由到VMT处找寻Print方法和类的内在索引。这样一来，编译器就可以调用正确的方法实现。由编译器负责管理所有的VMT索引和类偏移量。</p>\n<p>简言之，多态性使你能够用非常相似的名字定义许多方法，这里的名字往往都是直观易记的。 OOP编译器自会根据调用者类理解到底该调用哪个方法。</p>\n<p>Only one version of an overloaded function can appear within the extern C block. The code in the following example would result in an error.</p>\n<p>While you can use name overloading in your SYS/BIOS C++ applications, only one version of the overloaded function can be called from the configuration.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> “C” &#123; <span class=\"comment\">// Example causes ERROR</span></span><br><span class=\"line\">\t<span class=\"function\">Int <span class=\"title\">addNums</span><span class=\"params\">(Int x, Int y)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">Int <span class=\"title\">addNums</span><span class=\"params\">(Int x, Int y, Int z)</span></span>; <span class=\"comment\">// error, only one version of addNums is allowed</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"inline-function\">Inline Function</h2>\n<p><strong>内联方法 </strong>即内联函数，成员函数，inline functions，是指定义在类体内的函数。</p>\n<p>该函数可以在类体内被声明和定义，也可以在类体内声明同时在体外使用 <code>inline</code> 关键字进行定义，如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">angle</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">double</span> value;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SetValue</span><span class=\"params\">(<span class=\"keyword\">double</span>)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">angle::SetValue</span><span class=\"params\">(<span class=\"keyword\">double</span> x)</span></span>&#123;                <span class=\"comment\">//定义内联函数</span></span><br><span class=\"line\">\tvalue = x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong>内联函数无法递归。</p>\n<h2 id=\"constructor-and-destructor\">Constructor and Destructor</h2>\n<p><strong>构造函数(Constructor Function)</strong> 在调用时会为对象开辟储存空间、作初始化 及 其他管理操作。</p>\n<ul>\n<li>如果为编写，则系统默认生成</li>\n<li>可以接受参数不能有返回值</li>\n<li>可以有多个构造函数，因此可以接受名称重载（Name Mangling）。</li>\n</ul>\n<p><strong>析构函数(Destructor Function)</strong> 仅在释放对象的内存空间时使用，如 <strong><em>程序超出类对象的作用域</em></strong> 或 <strong><em>类指针运行delete运算符</em></strong> 时。</p>\n<h2 id=\"friend-function\">Friend Function</h2>\n<p><strong>友元函数</strong> 是指 <code>在类内部声明</code>，可以 <code>自由访问该类的私有部分</code> 并且 <code>不属于类成员</code> 的 <strong>函数</strong>或<strong>类</strong>。</p>\n<p>在友元函数声明时定义一个该类的对象，可以通过引用该对象作为参数进行对类的访问。</p>\n<p>为了确保数据完整性并遵循数据封装和隐藏的原则，因尽量少用或不用友元。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Student;</span><br><span class=\"line\">class Teacher&#123;</span><br><span class=\"line\">\tpublic:</span><br><span class=\"line\">\t\t&#x2F;&#x2F;....</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\tprotected:</span><br><span class=\"line\">\t\tint NoOfStudent;</span><br><span class=\"line\">\t\tStudent * pList[100];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Student&#123;</span><br><span class=\"line\">\tpublic:</span><br><span class=\"line\">\t\tfriend class Teacher;             &#x2F;&#x2F;友元类声明</span><br><span class=\"line\">\t\t&#x2F;&#x2F;....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"preprocessing\">Preprocessing</h2>\n<p><strong>定义</strong></p>\n<p>预处理是指将源文件的文本作为翻译的第一阶段操作的文本处理步骤。 预处理不会分析源文本，但会为了查找宏调用而将源文本细分为标记。 主要包括了下面三个方面：</p>\n<ul>\n<li>预处理指令</li>\n<li>预处理运算符</li>\n<li>预定义宏，这个有很多了，比如__FILE__、__LINE__和__DATA__等。</li>\n</ul>\n<p><strong>常识</strong> - 预处理并不是编译，也不是“预编译” - 预处理并不是每个语言都有 - C/C++预处理仅仅是把源程序划分和整理成一个个的段（phase），并不进行编译。 - 预处理器在UNIX传统中通常缩写为PP，在自动构建脚本中C预处理器被缩写为CPP的宏指代。为了不造成歧义，C++(c-plus-plus) 经常并不是缩写为CPP，而改成CXX</p>\n<p><strong>Preprocessing Directives 预处理指令</strong></p>\n<table>\n<tbody>\n<tr class=\"odd\">\n<td>#include</td>\n<td>#import</td>\n<td>#using</td>\n<td>#progma</td>\n</tr>\n<tr class=\"even\">\n<td>#if</td>\n<td>#ifdef</td>\n<td>#ifndef</td>\n<td>#elif</td>\n</tr>\n<tr class=\"odd\">\n<td>#lese</td>\n<td>#endif</td>\n<td>#define</td>\n<td>#undef</td>\n</tr>\n<tr class=\"even\">\n<td>#error</td>\n<td>#line</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"预处理运算符号\">预处理运算符号</h3>\n<table>\n<thead>\n<tr class=\"header\">\n<th>运算符</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>字符串化运算符（#）</td>\n<td>导致对应的实参括在双引号内</td>\n</tr>\n<tr class=\"even\">\n<td>Charizing运算符（#@）</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>标记粘贴运算符（##）</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>定义的运算符</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"and\"># and</h4>\n<h5 id=\"字符串化运算符\">字符串化运算符</h5>\n<p><code>#</code> 除了是 <strong><em>预处理符号</em></strong>，也是一种 <strong>运算符</strong> ，即 <strong>字符串化运算符</strong>，只能出现在带参的宏的替换文本中，<strong>将跟在后面的参数转换成一个字符串常量</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PF_INT(i) printf(#i<span class=\"meta-string\">&quot;=%d\\n&quot;</span>,i)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x=<span class=\"number\">100</span>;</span><br><span class=\"line\">    PF_INT(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>预处理后：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;x&quot;</span><span class=\"string\">&quot;=%d\\n&quot;</span>,x);</span><br></pre></td></tr></table></figure>\n<p>C语言常将相邻的字符串合并处理：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;x=%d\\n&quot;</span>,x);</span><br></pre></td></tr></table></figure>\n<h5 id=\"标记粘贴运算符\">标记粘贴运算符</h5>\n<p><code>##</code> 是一种 <strong>运算符</strong> ，即 <strong>标记粘贴运算符</strong>，是将两个 <strong>运算对象</strong> 连接（拼接）在一起，只能出现在带参宏定义的替换文本中。如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NUM(h,t,u)  h##t##u</span></span><br></pre></td></tr></table></figure>\n<p>假设u代表个位，t代表十位，h代表百位，则x=NUM(1,2,3)后,x=123。</p>\n<p><strong>注：</strong><code>##</code>也可以用于拼接一些开头一样，尾巴不一样的宏，这样的宏一般用于描述代表特定意义的对象的不同状态等。宏开头固定，根据不同条件则选择拼接不同尾巴，最后拼接的字符串代表一个具体的状态等。</p>\n<h2 id=\"differences-between-c-c\">Differences between C &amp; C++</h2>\n<ul>\n<li>从语法要求来说，C++的语法要求更为严格，编译器对参数变量的检查要求更高，更容易报错；很多在C中可以被顺利编译的语句，在C++中会被严厉拒绝，例如，在C++中，当形参为unsigned char，而实参为const char时会报错。</li>\n<li>C是面向过程语言，代码复用复杂。C++是面向对象语言。</li>\n</ul>\n<h1 id=\"c11\">C++11</h1>\n<h2 id=\"定义与声明\">定义与声明</h2>\n<p><strong>变量</strong> 只可以被定义（definition）一次，但是可以被多次声明（declaration）。</p>\n<p><code>extern</code> 是跨文件编译（分离式编译，seperate compilation）的 <strong>变量声明符</strong>，只要没有显式（explicitly）地初始化变量，如<code>extern int num  = 100</code> 就可以，<mark>任何包含了显式初始化的声明，即成为了定义</mark>。</p>\n<h3 id=\"关键字\">关键字</h3>\n<p>关于用户自定义的标识符，需要注意的是：</p>\n<ul>\n<li>不能连续出现两个下划线。</li>\n<li>不能以下划线紧连大写字母开头。</li>\n<li>定义在函数体外的标识符不能以下划线开头。</li>\n</ul>\n<figure>\n<img src=\"/Users/liewzheng/Library/Application%20Support/typora-user-images/image-20210801144743194.png\" alt=\"image-20210801144743194\" /><figcaption aria-hidden=\"true\">image-20210801144743194</figcaption>\n</figure>\n<h4 id=\"顶层const\">顶层const</h4>\n<p>指针本身是一个对象，指针本身可以指向另一个对象。</p>\n<p>“指针本身是不是常量” 和 “指针所指的是不是一个常量” 是两个互相独立的问题。</p>\n<p><strong>顶层const</strong>（top-level const）表示 <strong><em>指针本身是个常量</em></strong>。</p>\n<p><strong>底层const</strong>（low-level const）表示 <strong><em>指针所指的对象是一个常量</em></strong>。</p>\n<h2 id=\"初始化\">初始化</h2>\n<p>C++语言定义了初始化的好几种不同 <strong><em>形式</em></strong>，如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> sold = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sold = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sold&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sold</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;  <span class=\"comment\">//亲测可用</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：<mark>初始化并不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义把对象的当前值擦除，并用一个新的值来替代</mark>。</p>\n<p><strong>拷贝初始化</strong>（Copy Initialization）：使用等号（=）初始化一个变量，编译器把等号右侧的初始值拷贝到新创建的对象上去。</p>\n<p><strong>直接初始化</strong>（Direct Initialization）：不使用等号进行初始化。</p>\n<p><strong>列表初始化</strong>（List Initialization）：无论是为对象初始化或赋新值，都可以使用一组由花括号括起来的初始值。</p>\n<h2 id=\"命名空间\">命名空间</h2>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/image-20211009225305135.png\" alt=\"image-20211009225305135\" /><figcaption aria-hidden=\"true\">image-20211009225305135</figcaption>\n</figure>\n<p>这里说的头文件 <strong>不应包含</strong>，是只说不建议包含，</p>\n<h1 id=\"常见问题及错误\">常见问题及错误</h1>\n<h2 id=\"c常见的内存错误及解决方法\">C++常见的内存错误及解决方法</h2>\n<p><strong>（1）内存分配未成功，却使用了它。</strong></p>\n<blockquote>\n<p>在使用内存之前先检查指针是否是NULL。如果是用malloc来申请内存，应该用if(p == NULL)或if（p != NULL）进行防错处理。如果是new来申请内存，申请失败会抛出异常，所以应该捕捉异常来进行防错处理。</p>\n</blockquote>\n<p><strong>（2）内存虽然分配成功，但尚未初始化就引用它。</strong></p>\n<blockquote>\n<p>尽管有时候缺省时会自动初始化，但无论什么时候创建对象均要对其进行初始化，即使是赋0值也是不可忽略的。</p>\n</blockquote>\n<p><strong>（3）内存分配成功，但访问越界</strong></p>\n<blockquote>\n<p>对数组for循环时要把握越界，否则可能会导致数组越界。</p>\n</blockquote>\n<p><strong>（4）忘记释放内存，导致内存泄漏</strong></p>\n<blockquote>\n<p>动态内存的申请和释放必须配对，new-delete和malloc-free其使用次数必须相等。</p>\n</blockquote>\n<p><strong>（5）已经释放内存还在使用它</strong></p>\n<blockquote>\n<p>free或delete后 ，没有将指针设为NULL，产生“野指针”。</p>\n</blockquote>\n<h2 id=\"c中struct与class的区别是什么\">C++中struct与class的区别是什么？</h2>\n<p>如果没有多态和虚拟继承，在C++中，struct和class的存取效率完全相同，存取class的数据成员与非虚函数效率和struct完全相同，不管该数据成员是定义在基类还是派生类。</p>\n<p>class的数据成员在内存中的布局不一定是数据成员的声明顺序，C++只保证处于同一个access section的数据成员按照声明顺序排列。</p>\n<p>C++中，class和struct做类型定义是只有两点区别：</p>\n<ul>\n<li>默认继承权限不同，<strong>class继承默认是private继承，而struct默认是public继承</strong>。</li>\n<li>class还可用于定义模板参数，像typename，但是关键字struct不能同于定义模板参数。</li>\n</ul>\n<p>C++保留struct关键字，原因：</p>\n<ul>\n<li>保证与C语言的向下兼容性，C++必须提供一个struct。</li>\n<li>C++中的struct定义必须百分百地保证与C语言中的struct的向下兼容性，把C++中的最基本的对象单元规定为class而不是struct，就是为了避免各种兼容性要求的限制。</li>\n<li>对struct定义的扩展使C语言的代码能够更容易的被移植到C++中。</li>\n</ul>\n<h2 id=\"如何将结构体传递给函数\">如何将结构体传递给函数？</h2>\n<p>与类对象一样，结构体变量也可以通过值、引用和常量引用传递给函数。</p>\n<p>默认情况下，它们通过值传递，这意味着需要生成整个原始结构的副本并传递给函数。</p>\n<p>因为不希望浪费时间来复制整个结构体，所以，除非结构很小，否则一般会通过 <strong>引用</strong> 将结构体传递给函数。但是，这样意味着函数可以访问原始结构的成员变量，从而可能更改它们。</p>\n<p>如果不想让函数更改任何成员变量值，那么可以考虑将结构体变量作为一个 <strong>常量引用</strong> 传递给函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//程序1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iomanip&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Invltem</span>                       // <span class=\"title\">Holds</span> <span class=\"title\">data</span> <span class=\"title\">for</span> <span class=\"title\">an</span> <span class=\"title\">inventory</span> <span class=\"title\">item</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> partNum;                     <span class=\"comment\">// Part number</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> description;              <span class=\"comment\">// Item description</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> onHand;                      <span class=\"comment\">// Units on hand</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> price;                    <span class=\"comment\">// Unit price</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// Function prototypes</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getltemData</span><span class=\"params\">(InvItem &amp;)</span> </span>;        <span class=\"comment\">//普通引用，函数可能会对结构体数据造成影响</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showItem</span><span class=\"params\">(<span class=\"keyword\">const</span> InvItem &amp;)</span></span>;      <span class=\"comment\">//常量引用，不会让函数对结构体造成数据变化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    InvItem part;                    <span class=\"comment\">// Define an Invltem structure variable.</span></span><br><span class=\"line\">    getItemData(part);</span><br><span class=\"line\">    showItem(part);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getItemData</span><span class=\"params\">(InvItem &amp;item)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Enter the part number: &quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; item.partNum;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Enter the part description: &quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.get();</span><br><span class=\"line\">    getline (<span class=\"built_in\">cin</span>, item.description);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Enter the quantity on hand: &quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; item.onHand;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Enter the unit price: &quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; item.price;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showItem</span><span class=\"params\">(<span class=\"keyword\">const</span> InvItem &amp;item)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; setprecision(<span class=\"number\">2</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Part Number : &quot;</span> &lt;&lt; item.partNum &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Description : &quot;</span> &lt;&lt; item.description &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Units On Hand : &quot;</span> &lt;&lt; item.onHand &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Price : $&quot;</span> &lt;&lt; item.price &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Enter the part number: 800</span><br><span class=\"line\">Enter the part description: Screwdriver</span><br><span class=\"line\">Enter the quantity on hand: 135</span><br><span class=\"line\">Enter the unit price: 1.25</span><br><span class=\"line\"></span><br><span class=\"line\">Part Number : 800</span><br><span class=\"line\">Description : Screwdriver</span><br><span class=\"line\">Units On Hand: 135</span><br><span class=\"line\">Price : $1.25</span><br></pre></td></tr></table></figure>\n<h2 id=\"如何从函数返回一个结构体\">如何从函数返回一个结构体？</h2>\n<p>也可以从函数返回结构体变量。在这种情况下，函数的返回类型是结构体的名称。可以改写程序 1 以允许 getItemData 函数创建 Invltem 结构体的局部实例，将数据值放入其成员变量中，然后将其传递回 main，而不是将其作为引用变量从 main 接收。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">InvItem <span class=\"title\">getItemData</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    InvItem item;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Enter the part number:&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; item.partNum;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Enter the part description: &quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.get();</span><br><span class=\"line\">    getline(<span class=\"built_in\">cin</span>, item.description);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Enter the quantity on hand: &quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; item.onHand;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Enter the unit price: &quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; item.price;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下是从 main 中调用它的方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">part = getItemData();</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong> <em>C++ 只允许从函数返回单个值。然而，结构体提供了解决这一限制的方法。即使一个结构体可能有几个成员，它在技术上还是一个单一的对象。通过在结构体中打包多个值，可以从函数返回任意数量的值。</em></p>\n<h2 id=\"符号区分\">. | -&gt; | :: | :符号区分？</h2>\n<ol type=\"1\">\n<li><p>A.B则A为对象或者结构体；</p></li>\n<li><p>A-&gt;B则A为指针，-&gt;是成员提取，A-&gt;B是提取A中的成员B，A只能是指向类、结构、联合的指针；</p></li>\n<li><p>:: 是作用域运算符，A::B表示作用域A中的名称B，A可以是名字空间、类、结构；</p></li>\n<li><p>: 一般用来表示继承；</p></li>\n</ol>\n<h2 id=\"计算机上正在运行的句柄线程进程分别是什么意思\">计算机上正在运行的句柄、线程、进程分别是什么意思？</h2>\n<p>https://www.cnblogs.com/bluestorm/p/5712238.html</p>\n<blockquote>\n<p>所谓 <code>句柄</code> 实际上是一个数据，是一个Long (整长型)的数据。</p>\n<p>句柄是WONDOWS用来标识被应用程序所建立或使用的对象的唯一整数，WINDOWS使用各种各样的句柄标识诸如应用程序实例，窗口，控制，位图，GDI对象等等。WINDOWS句柄有点像C语言中的文件句柄。</p>\n</blockquote>\n<p>从上面的定义中的我们可以看到，句柄是一个 <code>标识符</code>，是拿来标识对象或者项目的，它就像我们的姓名一样，每个人都会有一个，不同的人的姓名不一样，但是，也可能有一个名字和你一样的人。从数据类型上来看它只是一个 <strong>16位的无符号整数</strong> 。<strong><em>应用程序几乎总是通过调用一个WINDOWS函数来获得一个句柄，之后其他的WINDOWS函数就可以使用该句柄，以引用相应的对象。</em></strong></p>\n<p>句柄是一种 <code>指向指针的指针</code>。所谓指针是一种内存地址。应用程序启动后，组成这个程序的各对象是驻留在内存的。如果简单地理解，似乎只要获知这个内存的首地址，那么就可以随时用这个地址访问对象。但是非也，<strong>Windows是一个以虚拟内存为基础的操作系统</strong>。在这种系统环境下，Windows内存管理器经常在内存中来回移动对象，依此来满足各种应用程序的内存需要。对象被移动意味着它的地址变化了。如果地址总是如此变化，该到哪里去找该对象呢?</p>\n<p>为了解决这个问题，Windows操作系统为各应用程序腾出一些 <code>内存储地址</code>，用来专门登记各应用对象在内存中的地址变化，而这个<strong>地址(存储单元的位置)本身是不变的</strong>。<strong>Windows内存管理器在移动对象在内存中的位置后，把对象新的地址告知这个句柄地址来保存。这样我们只需记住这个句柄地址就可以间接地知道对象具体在内存中的哪个位置。</strong>这个地址是在对象装载(Load)时由系统分配给的，当系统卸载时(Unload)又释放给系统。</p>\n<p>句柄地址(稳定)→记载着对象在内存中的地址→对象在内存中的地址(不稳定)→实际对象</p>\n<p><strong>本质：</strong>WINDOWS程序中并不是用物理地址来标识一个内存块，文件，任务或动态装入模块的，相反的，WINDOWS API给这些项目分配确定的句柄，并将句柄返回给应用程序，然后通过句柄来进行操作。</p>\n<p>但是必须注意的是程序每次从新启动，系统不能保证分配给这个程序的句柄还是原来的那个句柄，而且绝大多数情况的确不一样的。假如我们把进入电影院看电影看成是一个应用程序的启动运行，那么系统给应用程序分配的句柄总是不一样，这和每次电影院售给我们的门票总是不同的一个座位是一样的道理。</p>\n<p><code>线程</code> 是指程序的一个指令执行序列，WIN32 平台支持多线程程序，允许程序中存在多个线程。 在单 CPU 系统中，系统把 CPU 的时间片按照调度算法分配给各个线程，因此各线程实际上是分时执行的，在多 CPU 的 Windows NT 系统中， 同一个程序的不同线程可以被分配到不同的 CPU 上去执行。<em>由于一个程序的各线程是在相同的地址空间运行的，因此设及到了如何共享内存， 如何通信等问题，这样便需要处理各线程之间的同步问题，这是多线程编程中的一个难点。</em></p>\n<blockquote>\n<p>线程,也被称为轻量进程（lightweight processes）。计算机科学术语，指运行中的程序的调度单位。</p>\n<p>线程是进程中的实体，一个进程可以拥有多个线程，一个线程必须有一个父进程。线程不拥有系统资源，只有运行必须的一些数据结构；它与父进程的其它线程共享该进程所拥有的全部资源。线程可以创建和撤消线程，从而实现程序的并发执行。一般，线程具有 <code>就绪</code> 、 <code>阻塞</code> 和 <code>运行</code> 三种基本状态。</p>\n</blockquote>\n<p>在多中央处理器的系统里，不同线程可以同时在不同的中央处理器上运行，甚至当它们属于同一个进程时也是如此。<strong><em>大多数支持多处理器的操作系统都提供编程接口来让进程可以控制自己的线程与各处理器之间的关联度（affinity）。</em></strong></p>\n<p><code>进程</code> 是程序在一个数据集合上运行的过程(注:一个程序有可能同时属于多个进程),它是操作系统进行资源分配和调度的一个独立单位,进程可以简单的分为 <code>系统进程</code> (包括一般Windows程序和服务进程)和 <code>用户进程</code> 。</p>\n<h2 id=\"预编译\">预编译</h2>\n<h3 id=\"error-预编译中断及错误提示\">#Error 预编译中断及错误提示</h3>\n<h4 id=\"encountered-with-text\">Encountered with text</h4>\n<p>错误信息会在预编译期遇到错误的时候停止并给出，也就是错误信息的上一条执行代码出现了错误。</p>\n<p>而上一条代码是 <code>#if !defined( __BYTE_ADDRESSING__ ) &amp;&amp; defined ( __ADSPSHARC__ )</code> ，需要综合给出的错误提示 “Only Byte addressing mode is supported” 。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210520154529.png\" alt=\"image-20210520154525815\" /><figcaption aria-hidden=\"true\">image-20210520154525815</figcaption>\n</figure>\n<h3 id=\"symbol-could-not-be-resolved\">Symbol could not be resolved</h3>\n<p>此类情况都是 “未定义” 或 “定义重复”。按住 <code>左ctrl</code> 并点击该定义可快速查看，是否定义或重复定义。</p>\n<h4 id=\"重复定义\">重复定义</h4>\n<p>以下错误的出现则是因为出现了两处重复定义：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210520154609.png\" alt=\"image-20210520154603077\" /><figcaption aria-hidden=\"true\">image-20210520154603077</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210524195016.png\" alt=\"image-20210521093104044\" /><figcaption aria-hidden=\"true\">image-20210521093104044</figcaption>\n</figure>\n<h4 id=\"未定义\">未定义</h4>\n<p>NULL通常在 <code>&lt;stddef.h&gt;</code> （标准定义）头文件中给出，通常这些文件也被 <code>&lt;stdlib.h&gt;</code> 和 <code>&lt;stdio.h&gt;</code> 头文件引用。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210520154637.png\" alt=\"image-20210520154631949\" /><figcaption aria-hidden=\"true\">image-20210520154631949</figcaption>\n</figure>\n<p>也可以进行自定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> NULL</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NULL ((void *)0)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>以下代码源自 <code>&lt;stddef.h&gt;</code> :</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> NULL</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined (__cplusplus) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NULL 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NULL ((void *)0)\t</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>\t</span></span><br></pre></td></tr></table></figure>\n<p><strong>参考</strong>：<a href=\"https://stackoverflow.com/questions/7433448/eclipse-cdt-symbol-null-could-not-be-resolved\"><em>Eclipse CDT “Symbol NULL could not be resolved”</em></a></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210520232442191.png\" alt=\"image-20210520232442191\" /><figcaption aria-hidden=\"true\">image-20210520232442191</figcaption>\n</figure>\n<h2 id=\"error-li1050---multiply-defined-symbol\">Error: li1050 - MULTIPLY DEFINED SYMBOL</h2>\n<h3 id=\"错误编号\">错误编号</h3>\n<p><code>Error li1050</code></p>\n<h3 id=\"解决方法\">解决方法</h3>\n<p>将错误提示中所涉及到的变量（<code>Tx_Count</code>）或函数（<code>initPLL_SDRAM()</code> 和 <code>Init_TWI()</code>）分离至单独的一个 <code>.c</code> 文件中，在名称对应的头文件中，仅做函数及变量的声明，详细内容不要写在头文件中。</p>\n<p><mark>头文件中不能声明全局变量。</mark></p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20210521163534.png\" alt=\"image-20210521163422688\" /><figcaption aria-hidden=\"true\">image-20210521163422688</figcaption>\n</figure>\n<h3 id=\"实践\">实践</h3>\n<p>将错误提示中的变量或函数逐一移动到新的同名 <code>.c</code> 文件后，错误提示也在变少：</p>\n<p><strong>减少一个</strong>：<img src=\"https://pic.islet.space/2021/05/20210524102039.png\" alt=\"image-20210524100548198\" /></p>\n<p><strong>减少两个</strong>：<img src=\"https://pic.islet.space/2021/05/20210524102044.png\" alt=\"image-20210524100816631\" /></p>\n<p><strong>问题解决</strong>：<img src=\"https://pic.islet.space/2021/05/20210524102048.png\" alt=\"image-20210524101126445\" /></p>\n<p>解决方法的灵感来源于EZ论坛上的发言（以下回答其实也没细看）：</p>\n<p><a href=\"https://ez.analog.com/dsp/blackfin-processors/bf70x/f/q-a/12919/error-li1050-multiply-defined-symbol-in-processor-p0\"><img src=\"https://pic.islet.space/2021/05/20210524102051.png\" alt=\"image-20210524101743988\" /></a></p>\n","categories":["Programming"],"tags":["C++"]},{"title":"Get Started with C++ and Windows Subsystem for Linux in Visual Studio Code","url":"/2021/04/22/Programming/C++/2021-04-22-Get%20Started%20with%20C++%20and%20Windows%20Subsystem%20for%20Linux%20in%20Visual%20Studio%20Code/","content":"<p><a href=\"https://code.visualstudio.com/docs/cpp/config-wsl\">code.visualstudio.com</a></p>\n<h2 id=\"using-c-and-wsl-in-vs-code\">Using C++ and WSL in VS Code</h2>\n<p>In this tutorial, you will configure Visual Studio Code to use the GCC C++ compiler (g++) and GDB debugger on Ubuntu in the <a href=\"https://docs.microsoft.com/windows/wsl/install-win10\">Windows Subsystem for Linux</a> (WSL). GCC stands for GNU Compiler Collection; GDB is the GNU debugger. WSL is a Linux environment within Windows that runs directly on the machine hardware, not in a virtual machine.</p>\n<blockquote>\n<p><strong>Note</strong>: Much of this tutorial is applicable to working with C++ and VS Code directly on a Linux machine.</p>\n</blockquote>\n<p>Visual Studio Code has support for working directly in WSL with the <a href=\"https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl\">Remote - WSL extension</a>. We recommend this mode of <a href=\"https://code.visualstudio.com/docs/remote/wsl\">WSL development</a>, where all your source code files, in addition to the compiler, are hosted on the Linux distro. For more background, see <a href=\"https://code.visualstudio.com/docs/remote/remote-overview\">VS Code Remote Development</a>.</p>\n<p>After completing this tutorial, you will be ready to create and configure your own C++ project, and to explore the VS Code documentation for further information about its many features. This tutorial does not teach you about GCC or Linux or the C++ language. For those subjects, there are many good resources available on the Web.</p>\n<p>If you have any problems, feel free to file an issue for this tutorial in the <a href=\"https://github.com/microsoft/vscode-docs/issues\">VS Code documentation repository</a>.</p>\n<h2 id=\"prerequisites\">Prerequisites<a href=\"about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_prerequisites\">#</a></h2>\n<p>To successfully complete this tutorial, you must do the following steps:</p>\n<ol type=\"1\">\n<li>Install <a href=\"https://code.visualstudio.com/download\">Visual Studio Code</a>.</li>\n<li>Install the <a href=\"https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl\">Remote - WSL extension</a>.</li>\n<li>Install <a href=\"https://docs.microsoft.com/windows/wsl/install-win10\">Windows Subsystem for Linux</a> and then use the links on that same page to install your Linux distribution of choice. This tutorial uses Ubuntu. During installation, remember your Linux user password because you'll need it to install additional software.</li>\n</ol>\n<h2 id=\"set-up-your-linux-environment\">Set up your Linux environment<a href=\"about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_set-up-your-linux-environment\">#</a></h2>\n<ol type=\"1\">\n<li><p>Open the Bash shell for WSL. If you installed an Ubuntu distro, type \"Ubuntu\" in the Windows search box and then click on it in the result list. For Debian, type \"Debian\", and so on.</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/wsl/start-ubuntu.png\" alt=\"Ubuntu in Start Menu\" /><figcaption aria-hidden=\"true\">Ubuntu in Start Menu</figcaption>\n</figure>\n<p>The shell appears with a command prompt that by default consists of your user name and computer name, and puts you in your home directory. For Ubuntu it looks like this:</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/wsl/bash-ubuntu.png\" alt=\"Bash Shell\" /><figcaption aria-hidden=\"true\">Bash Shell</figcaption>\n</figure></li>\n<li><p>Make a directory called <code>projects</code> and then subdirectory under that called <code>helloworld</code>:</p>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir projects</span><br><span class=\"line\">cd projects</span><br><span class=\"line\">mkdir helloworld</span><br></pre></td></tr></table></figure></p></li>\n<li><p>Although you will be using VS Code to edit your source code, you'll be <strong>compiling the source code on Linux using the g++ compiler</strong>. You'll also <strong>debug on Linux using GDB</strong>. These tools are not installed by default on Ubuntu, so you have to install them. Fortunately, that task is quite easy!</p></li>\n<li><p>From the WSL command prompt, first run <code>apt-get update</code> to update the Ubuntu package lists. An out-of-date distro can sometimes interfere with attempts to install new packages.</p>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br></pre></td></tr></table></figure></p>\n<p>If you like, you can run <code>sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade</code> to also download the latest versions of the system packages, but this can take significantly longer depending on your connection speed.</p></li>\n<li><p>From the command prompt, install the GNU compiler tools and the GDB debugger by typing:</p>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install build-essential gdb</span><br></pre></td></tr></table></figure></p></li>\n</ol>\n<figure>\n<img src=\"C:\\Users\\431240\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210419161354074.png\" alt=\"image-20210419161354074\" /><figcaption aria-hidden=\"true\">image-20210419161354074</figcaption>\n</figure>\n<ol start=\"6\" type=\"1\">\n<li>Verify that the install succeeded by locating g++ and gdb. If the filenames are not returned from the <code>whereis</code> command, try running the update command again.</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">whereis g++</span><br><span class=\"line\">whereis gdb</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>Note</strong>: The setup steps for installing the g++ compiler and GDB debugger apply if you are working directly on a Linux machine rather than in WSL. Running VS Code in your helloworld project, as well as the editing, building, and debugging steps are the same.</p>\n</blockquote>\n<h2 id=\"run-vs-code-in-wsl\">Run VS Code in WSL<a href=\"about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_run-vs-code-in-wsl\">#</a></h2>\n<p>Navigate to your helloworld project folder and launch VS Code from the WSL terminal with <code>code .</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd $HOME&#x2F;projects&#x2F;helloworld</span><br><span class=\"line\">code .</span><br></pre></td></tr></table></figure>\n<p>You'll see a message about \"Installing VS Code Server\". <strong>VS Code is downloading and installing a small server on the Linux side that the desktop VS Code will then talk to.</strong></p>\n<figure>\n<img src=\"C:\\Users\\431240\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210419155740210.png\" alt=\"image-20210419155740210\" /><figcaption aria-hidden=\"true\">image-20210419155740210</figcaption>\n</figure>\n<p>VS Code will then start and open the <code>helloWorld</code> folder. The File Explorer shows that VS Code is now running in the context of WSL with the title bar <strong>[WSL: Ubuntu]</strong>.</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/wsl/file-explorer-wsl.png\" alt=\"File Explorer in WSL\" /><figcaption aria-hidden=\"true\">File Explorer in WSL</figcaption>\n</figure>\n<p>You can also tell the remote context from the Status bar.</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/wsl/wsl-status-bar.png\" alt=\"Remote context in the Status bar\" /><figcaption aria-hidden=\"true\">Remote context in the Status bar</figcaption>\n</figure>\n<p>If you click on the Remote Status bar item, you will see a dropdown of Remote commands appropriate for the session.</p>\n<figure>\n<img src=\"C:\\Users\\431240\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210419155444952.png\" alt=\"image-20210419155444952\" /><figcaption aria-hidden=\"true\">image-20210419155444952</figcaption>\n</figure>\n<p>For example, if you want to end your session running in WSL, you can select the <strong>Close Remote Connection</strong> command from the dropdown.</p>\n<p>Running <code>code .</code> from your <em>WSL command prompt</em> will restart VS Code running in WSL.</p>\n<p>The <strong>code .</strong> command opened VS Code in the current working folder, which becomes your \"workspace\". As you go through the tutorial, you will see three files created in a <code>.vscode</code> folder in the workspace:</p>\n<ul>\n<li><code>c_cpp_properties.json</code> (compiler path and IntelliSense settings)</li>\n<li><code>tasks.json</code> (build instructions)</li>\n<li><code>launch.json</code> (debugger settings)</li>\n</ul>\n<h2 id=\"add-a-source-code-file\">Add a source code file<a href=\"about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_add-a-source-code-file\">#</a></h2>\n<p>In the File Explorer title bar, select the <strong>New File</strong> button and name the file <code>helloworld.cpp</code>.</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/wsl/new-file-button.png\" alt=\"New File title bar button\" /><figcaption aria-hidden=\"true\">New File title bar button</figcaption>\n</figure>\n<h3 id=\"install-the-cc-extension\">Install the C/C++ extension<a href=\"about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_install-the-cc-extension\">#</a></h3>\n<p>Once you create the file and VS Code detects it is a C++ language file, you may be prompted to install the <a href=\"https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools\">Microsoft C/C++ extension</a> if you don't already have it installed.</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/wsl/cpp-extension-notification.png\" alt=\"C++ extension notification\" /><figcaption aria-hidden=\"true\">C++ extension notification</figcaption>\n</figure>\n<p>Choose <strong>Install</strong> and then <strong>Reload Required</strong> when the button is displayed in the Extensions view to complete installing the C/C++ extension.</p>\n<p>If you already have C/C++ language extensions installed locally in VS Code, you'll need to go to the Extensions view (Ctrl+Shift+X) and install those extensions into WSL. Locally installed extensions can be installed into WSL by selecting the <strong>Install in WSL</strong> button and then <strong>Reload Required</strong>.</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/wsl/install-in-wsl.png\" alt=\"Install in WSL button\" /><figcaption aria-hidden=\"true\">Install in WSL button</figcaption>\n</figure>\n<h3 id=\"add-hello-world-source-code\">Add hello world source code<a href=\"about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_add-hello-world-source-code\">#</a></h3>\n<p>Now paste in this source code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   vector&lt;string&gt; msg &#123;&quot;Hello&quot;, &quot;C++&quot;, &quot;World&quot;, &quot;from&quot;, &quot;VS Code&quot;, &quot;and the C++ extension!&quot;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   for (const string&amp; word : msg)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; word &lt;&lt; &quot; &quot;;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Now press Ctrl+S to save the file. Notice how the file you just added appears in the <strong>File Explorer</strong> view (Ctrl+Shift+E) in the side bar of VS Code:</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/wsl/file-explorer-helloworld.png\" alt=\"File Explorer\" /><figcaption aria-hidden=\"true\">File Explorer</figcaption>\n</figure>\n<p>You can also enable <a href=\"https://code.visualstudio.com/docs/editor/codebasics#_saveauto-save\">Auto Save</a> to automatically save your file changes, by checking <strong>Auto Save</strong> in the main <strong>File</strong> menu.</p>\n<p>The Activity Bar on the far left lets you open different views such as <strong>Search</strong>, <strong>Source Control</strong>, and <strong>Run</strong>. You'll look at the <strong>Run</strong> view later in this tutorial. You can find out more about the other views in the VS Code <a href=\"https://code.visualstudio.com/docs/getstarted/userinterface\">User Interface documentation</a>.</p>\n<p>若在此处遇到未找到头文件的问题，请参照一下方法。</p>\n<p><img src=\"C:\\Users\\431240\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210419160838596.png\" alt=\"image-20210419160838596\"  /></p>\n<h2 id=\"explore-intellisense\">Explore IntelliSense<a href=\"about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_explore-intellisense\">#</a></h2>\n<p>In your new <code>helloworld.cpp</code> file, hover over <code>vector</code> or <code>string</code> to see type information. After the declaration of the <code>msg</code> variable, start typing <code>msg.</code> as you would when calling a member function. You should immediately see a completion list that shows all the member functions, and a window that shows the type information for the <code>msg</code> object:</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/wsl/msg-intellisense.png\" alt=\"Statement completion IntelliSense\" /><figcaption aria-hidden=\"true\">Statement completion IntelliSense</figcaption>\n</figure>\n<p>You can press the Tab key to insert the selected member; then, when you add the opening parenthesis, you will see information about any arguments that the function requires.您可以按Tab键插入所选的成员;然后，当添加左括号时，您将看到关于函数所需的任何参数的信息。</p>\n<h2 id=\"build-helloworld.cpp\">Build helloworld.cpp<a href=\"about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_build-helloworldcpp\">#</a></h2>\n<p>Next, you will create a <code>tasks.json</code> file to tell VS Code how to build (compile) the program. This task will invoke the g++ compiler on WSL to create an executable file based on the source code.</p>\n<p>From the main menu, choose <strong>Terminal</strong> &gt; <strong>Configure Default Build Task</strong>. In the dropdown, which will display a tasks dropdown listing various predefined build tasks for C++ compilers. Choose <strong>g++ build active file</strong>, which will build the file that is currently displayed (active) in the editor.</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/wsl/build-active-file.png\" alt=\"Tasks C++ build dropdown\" /><figcaption aria-hidden=\"true\">Tasks C++ build dropdown</figcaption>\n</figure>\n<p>This will create a <code>tasks.json</code> file in a <code>.vscode</code> folder and open it in the editor.</p>\n<p>Your new <code>tasks.json</code> file should look similar to the JSON below:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class=\"line\">  &quot;tasks&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;type&quot;: &quot;shell&quot;,</span><br><span class=\"line\">      &quot;label&quot;: &quot;g++ build active file&quot;,</span><br><span class=\"line\">      &quot;command&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;g++&quot;,</span><br><span class=\"line\">      &quot;args&quot;: [&quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;&#x2F;$&#123;fileBasenameNoExtension&#125;&quot;],</span><br><span class=\"line\">      &quot;options&quot;: &#123;</span><br><span class=\"line\">        &quot;cwd&quot;: &quot;&#x2F;usr&#x2F;bin&quot;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &quot;problemMatcher&quot;: [&quot;$gcc&quot;],</span><br><span class=\"line\">      &quot;group&quot;: &#123;</span><br><span class=\"line\">        &quot;kind&quot;: &quot;build&quot;,</span><br><span class=\"line\">        &quot;isDefault&quot;: true</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>The <code>command</code> setting specifies the program to run; in this case that is g++. The <code>args</code> array specifies the command-line arguments that will be passed to g++. These arguments must be specified in the order expected by the compiler. This task tells g++ to take the active file (<code>$&#123;file&#125;</code>), compile it, and create an executable file in the current directory (<code>$&#123;fileDirname&#125;</code>) with the same name as the active file but without an extension (<code>$&#123;fileBasenameNoExtension&#125;</code>), resulting in <code>helloworld</code> for our example.</p>\n<blockquote>\n<p><strong>Note</strong>: You can learn more about <code>tasks.json</code> variables in the <a href=\"https://code.visualstudio.com/docs/editor/variables-reference\">variables reference</a>.</p>\n</blockquote>\n<p>The <code>label</code> value is what you will see in the tasks list; you can name this whatever you like.</p>\n<p>The <code>\"isDefault\": true</code> value in the <code>group</code> object specifies that this task will be run when you press Ctrl+Shift+B. This property is for convenience only; if you set it to false, you can still run it from the Terminal menu with <strong>Tasks: Run Build Task</strong>.</p>\n<h3 id=\"running-the-build\">Running the build<a href=\"about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_running-the-build\">#</a></h3>\n<ol type=\"1\">\n<li><p>Go back to <code>helloworld.cpp</code>. Your task builds the active file and you want to build <code>helloworld.cpp</code>.</p></li>\n<li><p>To run the build task defined in <code>tasks.json</code>, press Ctrl+Shift+B or from the <strong>Terminal</strong> main menu choose <strong>Tasks: Run Build Task</strong>.</p></li>\n<li><p>When the task starts, you should see the Integrated Terminal panel appear below the source code editor. After the task completes, the terminal shows output from the compiler that indicates whether the build succeeded or failed. For a successful g++ build, the output looks something like this:</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/wsl/wsl-task-in-terminal.png\" alt=\"G++ build output in terminal\" /><figcaption aria-hidden=\"true\">G++ build output in terminal</figcaption>\n</figure></li>\n<li><p>Create a new terminal using the <strong>+</strong> button and you'll have a bash terminal running in the context of WSL with the <code>helloworld</code> folder as the working directory. Run <code>ls</code> and you should now see the executable <code>helloworld</code> (no file extension).</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/wsl/wsl-bash-terminal.png\" alt=\"WSL bash terminal\" /><figcaption aria-hidden=\"true\">WSL bash terminal</figcaption>\n</figure></li>\n<li><p>You can run <code>helloworld</code> in the terminal by typing <code>./helloworld</code>.</p></li>\n</ol>\n<h3 id=\"modifying-tasks.json\">Modifying tasks.json<a href=\"about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_modifying-tasksjson\">#</a></h3>\n<p>You can modify your <code>tasks.json</code> to build multiple C++ files by using an argument like <code>\"$&#123;workspaceFolder&#125;/*.cpp\"</code> instead of <code>$&#123;file&#125;</code>. You can also modify the output filename by replacing <code>\"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;\"</code> with a hard-coded filename (for example 'helloworld.out').</p>\n<h2 id=\"debug-helloworld.cpp\">Debug helloworld.cpp<a href=\"about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_debug-helloworldcpp\">#</a></h2>\n<p>Next, you'll create a <code>launch.json</code> file to configure VS Code to launch the GDB debugger when you press F5 to debug the program. From the main menu, choose <strong>Run</strong> &gt; <strong>Add Configuration...</strong> and then choose <strong>C++ (GDB/LLDB)</strong>.</p>\n<p>You'll then see a dropdown for various predefined debugging configurations. Choose <strong>g++ build and debug active file</strong>.</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/wsl/build-and-debug-active-file.png\" alt=\"C++ debug configuration dropdown\" /><figcaption aria-hidden=\"true\">C++ debug configuration dropdown</figcaption>\n</figure>\n<p>VS Code creates a <code>launch.json</code> file, opens it in the editor, and builds and runs 'helloworld'.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class=\"line\">  &quot;configurations&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;name&quot;: &quot;g++ build and debug active file&quot;,</span><br><span class=\"line\">      &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class=\"line\">      &quot;request&quot;: &quot;launch&quot;,</span><br><span class=\"line\">      &quot;program&quot;: &quot;$&#123;fileDirname&#125;&#x2F;$&#123;fileBasenameNoExtension&#125;&quot;,</span><br><span class=\"line\">      &quot;args&quot;: [],</span><br><span class=\"line\">      &quot;stopAtEntry&quot;: false,</span><br><span class=\"line\">      &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class=\"line\">      &quot;environment&quot;: [],</span><br><span class=\"line\">      &quot;externalConsole&quot;: false,</span><br><span class=\"line\">      &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class=\"line\">      &quot;setupCommands&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,</span><br><span class=\"line\">          &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class=\"line\">          &quot;ignoreFailures&quot;: true</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">      &quot;preLaunchTask&quot;: &quot;g++ build active file&quot;,</span><br><span class=\"line\">      &quot;miDebuggerPath&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;gdb&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>The <code>program</code> setting specifies the program you want to debug. Here it is set to the active file folder <code>$&#123;fileDirname&#125;</code> and active filename without an extension <code>$&#123;fileBasenameNoExtension&#125;</code>, which if <code>helloworld.cpp</code> is the active file will be <code>helloworld</code>.</p>\n<p>By default, the C++ extension won't add any breakpoints to your source code and the <code>stopAtEntry</code> value is set to <code>false</code>. Change the <code>stopAtEntry</code> value to <code>true</code> to cause the debugger to stop on the <code>main</code> method when you start debugging.</p>\n<p>The remaining steps are provided as an optional exercise to help you get familiar with the editing and debugging experience.</p>\n<h3 id=\"start-a-debugging-session\">Start a debugging session<a href=\"about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_start-a-debugging-session\">#</a></h3>\n<ol type=\"1\">\n<li>Go back to <code>helloworld.cpp</code> so that it is the active file.</li>\n<li>Press F5 or from the main menu choose <strong>Run &gt; Start Debugging</strong>. Before you start stepping through the code, let's take a moment to notice several changes in the user interface:</li>\n</ol>\n<ul>\n<li><p>The Integrated Terminal appears at the bottom of the source code editor. In the <strong>Debug Output</strong> tab, you see output that indicates the debugger is up and running.</p></li>\n<li><p>The editor highlights the first statement in the <code>main</code> method. This is a breakpoint that the C++ extension automatically sets for you:</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/wsl/wsl-breakpoint-default.png\" alt=\"Initial breakpoint\" /><figcaption aria-hidden=\"true\">Initial breakpoint</figcaption>\n</figure></li>\n<li><p>The Run view on the left shows debugging information. You'll see an example later in the tutorial.</p></li>\n<li><p>At the top of the code editor, a debugging control panel appears. You can move this around the screen by grabbing the dots on the left side.</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/cpp/debug-controls.png\" alt=\"Debugging controls\" /><figcaption aria-hidden=\"true\">Debugging controls</figcaption>\n</figure></li>\n</ul>\n<h2 id=\"step-through-the-code\">Step through the code<a href=\"about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_step-through-the-code\">#</a></h2>\n<p>Now you're ready to start stepping through the code.</p>\n<ol type=\"1\">\n<li><p>Click or press the <strong>Step over</strong> icon in the debugging control panel.</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/cpp/step-over-button.png\" alt=\"Step over button\" /><figcaption aria-hidden=\"true\">Step over button</figcaption>\n</figure>\n<p>This will advance program execution to the first line of the for loop, and skip over all the internal function calls within the <code>vector</code> and <code>string</code> classes that are invoked when the <code>msg</code> variable is created and initialized. Notice the change in the <strong>Variables</strong> window on the left.</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/wsl/debug-view-variables.png\" alt=\"Debugging windows\" /><figcaption aria-hidden=\"true\">Debugging windows</figcaption>\n</figure>\n<p>In this case, the errors are expected because, although the variable names for the loop are now visible to the debugger, the statement has not executed yet, so there is nothing to read at this point. The contents of <code>msg</code> are visible, however, because that statement has completed.</p></li>\n<li><p>Press <strong>Step over</strong> again to advance to the next statement in this program (skipping over all the internal code that is executed to initialize the loop). Now, the <strong>Variables</strong> window shows information about the loop variables.</p></li>\n<li><p>Press <strong>Step over</strong> again to execute the <code>cout</code> statement. (Note that as of the March 2019 release, the C++ extension does not print any output to the <strong>Debug Console</strong> until the loop exits.)</p></li>\n<li><p>If you like, you can keep pressing <strong>Step over</strong> until all the words in the vector have been printed to the console. But if you are curious, try pressing the <strong>Step Into</strong> button to step through source code in the C++ standard library!</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/cpp/gcc-system-header-stepping.png\" alt=\"Breakpoint in gcc standard library header\" /><figcaption aria-hidden=\"true\">Breakpoint in gcc standard library header</figcaption>\n</figure>\n<p>To return to your own code, one way is to keep pressing <strong>Step over</strong>. Another way is to set a breakpoint in your code by switching to the <code>helloworld.cpp</code> tab in the code editor, putting the insertion point somewhere on the <code>cout</code> statement inside the loop, and pressing F9. A red dot appears in the gutter on the left to indicate that a breakpoint has been set on this line.</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/cpp/breakpoint-in-main.png\" alt=\"Breakpoint in main\" /><figcaption aria-hidden=\"true\">Breakpoint in main</figcaption>\n</figure>\n<p>Then press F5 to start execution from the current line in the standard library header. Execution will break on <code>cout</code>. If you like, you can press F9 again to toggle off the breakpoint.</p>\n<p>When the loop has completed, you can see the output in the <strong>Debug Console</strong> tab of the integrated terminal, along with some other diagnostic information that is output by GDB.</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/wsl/debug-console-output-wsl.png\" alt=\"Debug console display\" /><figcaption aria-hidden=\"true\">Debug console display</figcaption>\n</figure></li>\n</ol>\n<h2 id=\"set-a-watch\">Set a watch<a href=\"about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_set-a-watch\">#</a></h2>\n<p>Sometimes you might want to keep track of the value of a variable as your program executes. You can do this by setting a <strong>watch</strong> on the variable.</p>\n<ol type=\"1\">\n<li><p>Place the insertion point inside the loop. In the <strong>Watch</strong> window, click the plus sign and in the text box, type <code>word</code>, which is the name of the loop variable. Now view the Watch window as you step through the loop.</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/cpp/watch-window.png\" alt=\"Watch window\" /><figcaption aria-hidden=\"true\">Watch window</figcaption>\n</figure></li>\n<li><p>Add another watch by adding this statement before the loop: <code>int i = 0;</code>. Then, inside the loop, add this statement: <code>++i;</code>. Now add a watch for <code>i</code> as you did in the previous step.</p></li>\n<li><p>To quickly view the value of any variable while execution is paused on a breakpoint, you can hover over it with the mouse pointer.</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/cpp/mouse-hover.png\" alt=\"Mouse hover\" /><figcaption aria-hidden=\"true\">Mouse hover</figcaption>\n</figure></li>\n</ol>\n<h2 id=\"cc-configurations\">C/C++ configurations<a href=\"about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_cc-configurations\">#</a></h2>\n<p>If you want more control over the C/C++ extension, you can create a <code>c_cpp_properties.json</code> file, which will allow you to change settings such as the path to the compiler, include paths, C++ standard (default is C++17), and more.</p>\n<p>You can view the C/C++ configuration UI by running the command <strong>C/C++: Edit Configurations (UI)</strong> from the Command Palette (Ctrl+Shift+P).</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/cpp/command-palette.png\" alt=\"Command Palette\" /><figcaption aria-hidden=\"true\">Command Palette</figcaption>\n</figure>\n<p>This opens the <strong>C/C++ Configurations</strong> page. When you make changes here, VS Code writes them to a file called <code>c_cpp_properties.json</code> in the <code>.vscode</code> folder.</p>\n<figure>\n<img src=\"https://code.visualstudio.com/assets/docs/cpp/wsl/intellisense-configurations-wsl.png\" alt=\"Command Palette\" /><figcaption aria-hidden=\"true\">Command Palette</figcaption>\n</figure>\n<p>You only need to modify the <strong>Include path</strong> setting if your program includes header files that are not in your workspace or in the standard library path.</p>\n<p>Visual Studio Code places these settings in <code>.vscode/c_cpp_properties.json</code>. If you open that file directly, it should look something like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;configurations&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;name&quot;: &quot;Linux&quot;,</span><br><span class=\"line\">      &quot;includePath&quot;: [&quot;$&#123;workspaceFolder&#125;&#x2F;**&quot;],</span><br><span class=\"line\">      &quot;defines&quot;: [],</span><br><span class=\"line\">      &quot;compilerPath&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;gcc&quot;,</span><br><span class=\"line\">      &quot;cStandard&quot;: &quot;c11&quot;,</span><br><span class=\"line\">      &quot;cppStandard&quot;: &quot;c++17&quot;,</span><br><span class=\"line\">      &quot;intelliSenseMode&quot;: &quot;clang-x64&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;version&quot;: 4</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"closing-the-wsl-session\">Closing the WSL session<a href=\"about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_closing-the-wsl-session\">#</a></h2>\n<p>When you are done working in WSL, you can close your remote session with the <strong>Close Remote Connection</strong> command available in the main <strong>File</strong> menu and the Command Palette (Ctrl+Shift+P). This will restart VS Code running locally. You can easily reopen your WSL session from the <strong>File</strong> &gt; <strong>Open Recent</strong> list by selecting folders with the <strong>[WSL]</strong> suffix.</p>\n<h2 id=\"next-steps\">Next steps<a href=\"about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_next-steps\">#</a></h2>\n<ul>\n<li>Explore the <a href=\"https://code.visualstudio.com/docs/editor/codebasics\">VS Code User Guide</a>.</li>\n<li>Review the <a href=\"https://code.visualstudio.com/docs/languages/cpp\">Overview of the C++ extension</a>.</li>\n<li>Create a new workspace, copy your .json files to it, adjust the necessary settings for the new workspace path, program name, and so on, and start coding!</li>\n</ul>\n<p>11/22/2019</p>\n<p>​</p>\n","categories":["Programming"],"tags":["Linux","C++","VisualStudioCode","Subsystem"]},{"title":"How to Use the C Preprocessor's error Directive","url":"/2021/05/21/Programming/C++/2021-05-21-How-to-Use-the-C-Preprocessors-#error-Directive/","content":"<p><a href=\"https://barrgroup.com/embedded-systems/how-to/c-preprocessor-error-directive\">barrgroup.com</a></p>\n<p>One of the least used but potentially most useful features of the C preprocessor is the <strong><em>ANSI-specified #error directive</em></strong>. Here's a look at a couple of clever uses for <code>#error</code> that have proven invaluable in embedded software development.</p>\n<p>The syntax of <code>#error</code> is very straightforward:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">error</span> <span class=\"meta-string\">&lt;writer supplied error message&gt;</span>  <span class=\"comment\">//开发者提供的错误信息</span></span></span><br></pre></td></tr></table></figure>\n<p><code>&lt;writer supplied error message&gt;</code> 中可包含任何可显示的文本，甚至不需要使用双引号 <code>\"\"</code> 。</p>\n<blockquote>\n<p>The <code>&lt;writer supplied error message&gt;</code> can consist of any printable text. You don't even have to enclose the text in quotes. (Technically, the message is optional--though it rarely makes sense to omit it.)</p>\n</blockquote>\n<p>当C预处理器遇到 <code>#error</code> 语句时，会将停止编译，并将错误信息输出至 <code>stderr</code> 文件。C编译器的典型错误信息如下：</p>\n<blockquote>\n<p>When the C preprocessor encounters a <code>#error</code> statement, it causes compilation to terminate and the writer-supplied error message to be printed to <a href=\"http://en.wikipedia.org/wiki/Standard_streams\">stderr (link is external)</a>. A typical error message from a C compiler looks like this:</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Filename(line_number): Error! </span><br><span class=\"line\">Ennnn: &lt;writer supplied error message&gt; </span><br></pre></td></tr></table></figure>\n<p>where Filename is the source file name, <code>line_number</code> is the line number where the <code>#error</code> statement is located, and <code>Ennnn</code> is a compiler-specific error number. Thus, the <code>#error</code> message is basically indistinguishable from ordinary compiler error messages.</p>\n<p>\"Wait a minute,\" you might say. \"I spend enough time trying to get code to compile and now he wants me to do something that causes more compiler errors?\" Absolutely! The essential point is that code that compiles but is incorrect is worse than useless. I've found three general areas in which this problem can arise and <code>#error</code> can help. Read on and see if you agree with me.</p>\n<h2 id=\"incomplete-code\">Incomplete code</h2>\n<p>I tend to code using a step-wise refinement approach, so it isn't unusual during development for me to have functions that do nothing, for loops that lack a body, and so forth. Consequently, I often have files that are compilable but lack some essential functionality. Working this way is fine, until I'm pulled off to work on something else (an occupational hazard of being in the consulting business). Because these distractions can occasionally run into weeks, I sometimes return to the job with my memory a little hazy about what I haven't completed. In the worst-case scenario (which has occurred), I perform a make, which runs happily, and then I attempt to use the code. The program, of course, crashes and burns, and I'm left wondering where to start.</p>\n<p>In the past, I'd comment the file to note what had been done and what was still needed. However, I found this approach to be rather weak because I then had to read all my comments (and I comment heavily) in order to find what I was looking for. Now I simply enter something like the following in an appropriate place in the file:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#error *** Nigel - Function incomplete. Fix before using *** </span><br></pre></td></tr></table></figure>\n<p>Thus, if I forget that I haven't done the necessary work, an inadvertent attempt to use the file will result in just about the most meaningful compiler message I'll ever receive. Furthermore, it saves me from having to wade through pages of comments, trying to find what work I haven't finished.</p>\n<h2 id=\"compiler-dependent-code\">Compiler-dependent code</h2>\n<p>As much as I strive to write portable code, I often find myself having to trade off performance for portability - and in the embedded world, performance tends to win. However, what happens if a few years later I reuse some code without remembering that the code has <strong><em>compiler-specific peculiarities</em></strong>? The result is a much longer debug session than is necessary. But a <strong><em>judicious</em></strong> <code>#error</code> statement can prevent a lot of grief. A couple of examples may help.</p>\n<h3 id=\"example-1\">Example 1</h3>\n<p>Some floating-point code requires at least 12 digits of resolution to return the correct results. Accordingly, the various variables are defined as type long double. But <strong><em>ISO C</em></strong> only requires that <em><u>a long double have 10 digits of resolution</u></em>. Thus on certain machines, a long double may be <strong><em>inadequate</em></strong> to do the job. To protect against this, I would include the following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;float.h&gt;</span><br><span class=\"line\">#if (LDBL_DIG &lt; 12) </span><br><span class=\"line\">\t#error *** long doubles need 12 digit resolution.</span><br><span class=\"line\">\tDo not use this compiler! *** </span><br><span class=\"line\">#endif </span><br></pre></td></tr></table></figure>\n<p>This approach works by examining the value of an ANSI-mandated constant found in <a href=\"http://en.wikipedia.org/wiki/Float.h\">float.h (link is external)</a>.</p>\n<h3 id=\"example-2\">Example 2</h3>\n<p>An amazing amount of code makes invalid assumptions about the underlying size of the various integer types. If you have code that has to use an int (as opposed to a user-specified data type such as <code>int16</code>), and the code assumes that an int is 16 bits, you can do the following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;limits.h&gt;</span><br><span class=\"line\">#if (INT_MAX !&#x3D; 32767) </span><br><span class=\"line\">\t#error *** This file only works with 16-bit int.</span><br><span class=\"line\">\tDo not use this compiler! *** </span><br><span class=\"line\">#endif </span><br></pre></td></tr></table></figure>\n<p>Again, this works by checking the value of an ANSI-mandated constant. This time the constant is found in the file <a href=\"http://en.wikipedia.org/wiki/Limits.h\">limits.h (link is external)</a>. This approach is a lot more useful than putting these limitations inside a big comment that someone may or may not read. After all, you have to read the compiler error messages.</p>\n<h2 id=\"conditionally-compiled-code\">Conditionally-compiled code</h2>\n<p>Since conditionally compiled code seems to be a necessary evil in embedded programming, it's common to find code sequences such as the following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#if defined OPT_1 </span><br><span class=\"line\">\t&#x2F;* Do option_1 *&#x2F; </span><br><span class=\"line\">#else </span><br><span class=\"line\">\t&#x2F;* Do option_2 *&#x2F; </span><br><span class=\"line\">#endif </span><br></pre></td></tr></table></figure>\n<p>As it is written, this code means the following: if and only if OPT_1 is defined, we will do option_1; otherwise we'll do option_2. The problem with this code is that a user of the code doesn't know (without explicitly examining the code) that OPT_1 is a valid compiler switch. Instead, the naive user will simply compile the code without defining OPT_1 and get the alternate implementation, irrespective of whether that is what's required or not. A more considerate coder might be aware of this problem, and instead do the following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#if defined OPT_1 </span><br><span class=\"line\">\t&#x2F;* Do option 1 *&#x2F; </span><br><span class=\"line\">#elif defined OPT_2 </span><br><span class=\"line\">\t&#x2F;* Do option 2*&#x2F; </span><br><span class=\"line\">#endif </span><br></pre></td></tr></table></figure>\n<p>In this case, failure to define either OPT_1 or OPT_2 will typically result in an obscure compiler error at a point later in the code. The user of this code will then be stuck with trying to work out what must be done to get the module to compile. This is where #error comes in. Consider the following code sequence:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#if defined OPT_1 </span><br><span class=\"line\">\t&#x2F;* Do option_1 *&#x2F; </span><br><span class=\"line\">#elif defined OPT_2 </span><br><span class=\"line\">\t&#x2F;* Do option_2 *&#x2F; </span><br><span class=\"line\">#else </span><br><span class=\"line\">\t#error *** You must define one of OPT_1 or OPT_2 *** </span><br><span class=\"line\">#endif </span><br></pre></td></tr></table></figure>\n<p>Now the compilation fails, but at least it tells the user explicitly what to do to make the module compile. I know that if this procedure had been adopted universally, I would have saved a lot of time over the years trying to reuse other people's code.</p>\n<p>So there you have it. Now tell me, don't you agree that <code>#error</code> is a really useful part of the preprocessor, worthy of your frequent use-and occasional praise?</p>\n<p>​</p>\n","categories":["Programming"],"tags":["C++","preprocessor","error directive","error"]},{"title":"Difference between GCC, gcc and g++","url":"/2021/05/23/Programming/C++/2021-05-23-Difference-between-GCC,-gcc-and-g++/","content":"<p>gcc 和 GCC 是两个不同的东西。</p>\n<blockquote>\n<p><strong>GCC</strong>：GNU Compiler Collection(GUN 编译器集合)，它可以编译C、C++、JAV、Fortran、Pascal、Object-C、Ada等语言。</p>\n<p><strong>gcc</strong>：GCC中的GUN C Compiler（C 编译器）</p>\n<p><strong>g++</strong>：GCC中的GUN C++ Compiler（C++编译器）</p>\n</blockquote>\n<p>一个有趣的事实就是，就本质而言，gcc和g++并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件的类型，调用对应的GUN编译器而已，比如，用gcc编译一个c文件的话，会有以下几个步骤：</p>\n<blockquote>\n<p>Step1：Call a preprocessor, like cpp.</p>\n<p>Step2：Call an actual compiler, like cc or cc1.</p>\n<p>Step3：Call an assembler, like as.</p>\n<p>Step4：Call a linker, like ld</p>\n</blockquote>\n<p>由于编译器是可以更换的，所以gcc不仅仅可以编译C文件</p>\n<p>所以，更准确的说法是：gcc调用了C compiler，而g++调用了C++ compiler</p>\n<h1 id=\"gcc和g的主要区别\">gcc和g++的主要区别</h1>\n<ol type=\"1\">\n<li><p>对于 <em>.c和</em>.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）</p></li>\n<li><p>对于 <em>.c和</em>.cpp文件，g++则统一当做cpp文件编译</p></li>\n<li><p>使用g++编译文件时，<strong>g++会自动链接标准库STL，而gcc不会自动链接STL</strong></p></li>\n<li><p>gcc在编译C文件时，可使用的预定义宏是比较少的</p></li>\n<li><p>gcc在编译cpp文件时/g++在编译c文件和cpp文件时（这时候gcc和g++调用的都是cpp文件的编译器），会加入一些额外的宏，这些宏如下：</p></li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __GXX_WEAK__ 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __cplusplus 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __DEPRECATED 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __GNUG__ 4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __EXCEPTIONS 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __private_extern__ extern</span></span><br></pre></td></tr></table></figure>\n<ol start=\"6\" type=\"1\">\n<li>在用gcc编译c++文件时，为了能够使用STL，需要加参数 –lstdc++ ，但这并不代表 gcc –lstdc++ 和 g++等价，它们的区别不仅仅是这个</li>\n</ol>\n<p>其主要参数：</p>\n<blockquote>\n<p>-g - turn on debugging (so GDB gives morefriendly output)</p>\n<p>-Wall - turns on most warnings</p>\n<p>-O or -O2 - turn on optimizations</p>\n<p>-o - name of the output file</p>\n<p>-c - output an object file (.o)</p>\n<p>-I - specify an includedirectory</p>\n<p>-L - specify a libdirectory</p>\n<p>-l - link with librarylib.a</p>\n</blockquote>\n<p>使用示例：<code>g++ -ohelloworld -I/homes/me/randomplace/include helloworld.C</code></p>\n","categories":["Programming"],"tags":["C","C++","gcc","GCC","g++"]},{"title":"enum in C/C++","url":"/2021/05/23/Programming/C++/2021-05-23-enum-in-CC++/","content":"<p><code>enum</code> 是 Enumeration // 的缩写，是C/C++中的 <strong>枚举</strong> 关键字。</p>\n<h1 id=\"特点\">特点</h1>\n<p>符合以下场景时可能需要使用到枚举：</p>\n<ul>\n<li>需要使用到的变量 <strong>数量较大</strong>，通过枚举以简写代码，提高代码可读性</li>\n<li>使用整形（integer）进行定义（但不同于直接定义成 <code>int</code> 的 <strong>显式整形</strong>，使用枚举类型定义的话会变成 <strong>隐式整形</strong>）</li>\n<li>所有值都是有固定范围的，是可人为预设的。</li>\n<li>具有常量的特性（主要特点是：不可在定义之外的地方被修改）</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li><em>在所有枚举值都未被赋值的情况下</em>，枚举值默认从 0 开始，往后逐个加 1（递增）。</li>\n</ul>\n<h1 id=\"定义\">定义</h1>\n<p><strong>枚举格式</strong>：一般为 <code>enum 枚举名&#123; 枚举值表 &#125;;</code> ，也可以省略枚举名，写成如下格式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">typeName</span>&#123;</span> valueName1, valueName2, valueName3, ...... &#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>enum</code> 定义 <strong>枚举类型的关键字</strong>；</p>\n<p><code>typeName</code>是 枚举类型的名称，即 <strong>枚举名</strong>。</p>\n<p><code>valueName1, valueName2, valueName3, ......</code>是每个值对应的名字的列表，所有元素集合即为 <strong>枚举值表</strong></p>\n<p>注意：最后的<code>;</code>不能少。</p>\n</blockquote>\n<h1 id=\"使用示例\">使用示例</h1>\n<h2 id=\"起始值赋值\">起始值赋值</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">cats</span> &#123;</span></span><br><span class=\"line\">    juran = <span class=\"number\">3</span>,</span><br><span class=\"line\">    guoran,</span><br><span class=\"line\">    dala,</span><br><span class=\"line\">    baomei,</span><br><span class=\"line\">    baodi,</span><br><span class=\"line\">    zhaofeng,</span><br><span class=\"line\">    ainiao</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">juran = 3</span><br><span class=\"line\">guoran = 4</span><br><span class=\"line\">dala = 5</span><br><span class=\"line\">ainiao = 9</span><br></pre></td></tr></table></figure>\n<h2 id=\"值表中途赋值\">值表中途赋值</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">cats</span> &#123;</span></span><br><span class=\"line\">    juran,</span><br><span class=\"line\">    guoran,</span><br><span class=\"line\">    dala = <span class=\"number\">0</span>,</span><br><span class=\"line\">    baomei,</span><br><span class=\"line\">    baodi,</span><br><span class=\"line\">    zhaofeng,</span><br><span class=\"line\">    ainiao</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>给出如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">juran = 0</span><br><span class=\"line\">guoran = 1</span><br><span class=\"line\">dala = 0</span><br><span class=\"line\">ainiao = 4</span><br></pre></td></tr></table></figure>\n<h1 id=\"typedef-enum\">Typedef enum</h1>\n<p>Typedef enum 的用法一般如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span>&#123;</span>....&#125; a; </span><br></pre></td></tr></table></figure>\n<p>enum 的用法一般如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span>&#123;</span>....&#125; a;</span><br></pre></td></tr></table></figure>\n<p>前者是将 <code>enum&#123;….&#125;</code> 定义成一个 <strong><em>a类型</em></strong>，声明变量的时候可以用 <code>a b</code> 格式;可以理解为类似 <code>int i</code>;</p>\n<p>后者是将 <code>enum&#123;….&#125;</code> 声明了一个 <strong><em>变量</em></strong><code>a</code>。</p>\n<h1 id=\"枚举遍历\">枚举遍历</h1>\n<p>在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。</p>\n<p>不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">DAY</span>&#123;</span></span><br><span class=\"line\">      MON=<span class=\"number\">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class=\"line\">&#125; day;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历枚举元素</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (day = MON; day &lt;= SUN; day++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;枚举元素：%d \\n&quot;</span>, day);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"错误示范\">错误示范</h1>\n<p>以下错误示范给出的提示均由 Linux的 <strong><em>GNU</em></strong> 编译器 及 Mac的 <strong><em>Clang</em></strong>（<em>Apple clang version 11.0.0 (clang-1100.0.33.17)</em>）编译器给出。</p>\n<h2 id=\"重复定义\">重复定义</h2>\n<p>不允许 <strong>在同一个作用域内</strong> 定义 <strong>一样的枚举名称</strong> ；也不允许 <strong>在同一个作用域内</strong> 的不同枚举变量中定义 <strong>名称一样的元素</strong>。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210523204125878.png\" alt=\"image-20210523204125878\" /><figcaption aria-hidden=\"true\">image-20210523204125878</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210523204041715.png\" alt=\"image-20210523204041715\" /><figcaption aria-hidden=\"true\">image-20210523204041715</figcaption>\n</figure>\n<p>以上两种情况的错误提示如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210523182310296.png\" alt=\"image-20210523182310296\" /><figcaption aria-hidden=\"true\">image-20210523182310296</figcaption>\n</figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210523204224839.png\" alt=\"image-20210523204224839\" /><figcaption aria-hidden=\"true\">image-20210523204224839</figcaption>\n</figure>\n<p>也就是说 <strong>枚举名称和枚举元素都要绝对唯一</strong>。</p>\n<h2 id=\"数值更改\">数值更改</h2>\n<p>枚举类数据不允许更改数值（包括自增和赋值都不允许），有点类似于常量（const）。</p>\n<p>枚举中的元素自增时的错误提示：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210523202049638.png\" alt=\"image-20210523202049638\" /><figcaption aria-hidden=\"true\">image-20210523202049638</figcaption>\n</figure>\n<p>枚举中的元素赋值时的错误提示：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210523202501260.png\" alt=\"image-20210523202501260\" /><figcaption aria-hidden=\"true\">image-20210523202501260</figcaption>\n</figure>\n<blockquote>\n<p>根据 <a href=\"https://zhidao.baidu.com/question/142755629.html\">网友的回答</a> :</p>\n<p>C支持枚举类型的自增操作，但C++不支持。</p>\n</blockquote>\n<p>以下为常量自增时给出的错误提示：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/image-20210523202757582.png\" alt=\"image-20210523202757582\" /><figcaption aria-hidden=\"true\">image-20210523202757582</figcaption>\n</figure>\n","categories":["Programming"],"tags":["C","C++","enum","typedef"]},{"title":"基本数据类型 与 构造数据类型","url":"/2021/05/23/Programming/C++/2021-05-23-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"<p>[cnblogs.com](https://www.cnblogs.com/ybtools/p/6432464.html#:~:text=构造数据类型指可以通过其他的数据类型进行构造，可由程序员自定义，故又称为 \",自定义数据类型 \"。 基本数据类型包括整型（short%2Cint%2Clong）、实型（又称浮点型）（float和double）、字符型char、布尔型bool等，他们都可以用于定义常量和变量。)</p>\n<p>PS：本文以C++为例介绍数据类型。</p>\n<h1 id=\"数据类型\">数据类型　</h1>\n<p>从广义上根据量的值是否可变，可分为<strong>常量</strong>和<strong>变量</strong>两种数据类型。</p>\n<p>根据数据复杂程度，划分为<strong>基本数据类型</strong>和<strong>构造数据类型</strong>这两大类。</p>\n<p><strong>基本数据类型</strong> 包括：整型（short,int,long）、实型（又称浮点型）（float和double）、字符型char、布尔型bool等。</p>\n<p><strong>构造数据类型</strong> 包括：数组类型、枚举类型enum、指针类型、引用类型、结构体struct、联合体union（又称联合，共用体）、类class等。</p>\n<p>构造数据类型指可以通过其他的数据类型进行构造，可由程序员自定义，故又称为 \"<strong>自定义数据类型</strong>\"。</p>\n<h1 id=\"基本数据类型\">基本数据类型</h1>\n<p>基本数据类型包括整型（short,int,long）、实型（又称浮点型）（float和double）、字符型char、布尔型bool等，他们都可以用于定义常量和变量。</p>\n<p>基本数据类型，也叫做基础类型，或内置类型。</p>\n<p><strong>1、整型（short,int,long）</strong></p>\n<p>整型量，包括短整型short、整型int、长整型long，而且3种类型都可以分别再细分为：有符号(signed)以及无符号(unsigned)。</p>\n<p><strong>2、实型（又称浮点型）（float和double）</strong></p>\n<p>实型，又称为浮点型，它包括两种数据类型：单精度浮点数float和双精度浮点数double。他们都是有符号数据类型。如果一个数值常量，包含小数点、指数部分（字符e），则为浮点数。</p>\n<p>双精度浮点型，还可细分为双精度（double型）、长双精度（long double）</p>\n<p><strong>3、字符型char</strong></p>\n<p>字符型char类型定义的常量，必须要用单括号括起来。</p>\n<p>例如：char ch='a' ; //把字符常量'a'存储到ch中。</p>\n<p>字符型char类型量也可以细分为有符号(char)和无符号(unsigned char)。</p>\n<p><strong>4、布尔型bool</strong></p>\n<p>布尔型的取值为true或者false。</p>\n<p>布尔型变量的说明：例：bool flag，则布尔型数据的变量flag取值：只有 false 和 true 两个值，即分别是0和1。</p>\n<h1 id=\"构造数据类型\">构造数据类型</h1>\n<p>有些比较复杂的数据，单纯用基本数据类型未能表示，在C++中程序员可以用基本数据类型来自定义构造出新的数据类型，称构造数据类型，也称作 <strong><em>构造类型</em></strong>、<strong><em>构造数据类型</em></strong>。</p>\n<p>构造数据类型除了可以用常见的如int、float和double、char、bool等基本数据类型进行构造，也可以包含其他构造类型的数据。</p>\n<p>构造数据类型包括：数组类型、枚举类型enum、指针类型、引用类型、结构体struct、联合体union（又称联合，共用体）、class类等，他们可以通过其他的数据类型进行构造，由程序员自定义，所以又称为自定义数据类型。</p>\n<p>参考：http://blog.csdn.net/u013174689/article/details/17484223</p>\n<p>​</p>\n","categories":["Programming"],"tags":["C","C++","datatype"]},{"title":"C++11 lambda表达式精讲","url":"/2021/05/29/Programming/C++/2021-05-29-C++11-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%B2%BE%E8%AE%B2/","content":"<p><a href=\"http://c.biancheng.net/view/3741.html\">c.biancheng.net</a></p>\n<h1 id=\"编译注意\">编译注意</h1>\n<p><strong>注意</strong>：在clang上使用lambda表达式时可能会报错，编译时需要添加option <code>-std=c++11</code> 。</p>\n<blockquote>\n<p>This is because <strong>clang++</strong> <a href=\"http://clang.llvm.org/cxx_status.html\">by default compiles your code using ISO C++ 1998 standard (including the defects addressed in the ISO C++ 2003 standard) except for 'export' (which has been removed in C++11)</a></p>\n<p>Lambdas are part of <a href=\"http://clang.llvm.org/\">Clang's</a> <a href=\"http://clang.llvm.org/docs/LanguageExtensions.html#cxx11\">C++11 Language Extension</a>, therefore you need to compile your code with <strong>-std=c++11</strong> or <strong>-std=gnu++11</strong></p>\n<p>——<a href=\"https://stackoverflow.com/questions/13351032/clangs-support-of-c-11-lambda#:~:text=Lambdas%20are%20part%20of%20Clang%27s%20C%2B%2B11%20Language%20Extension%2C,support%20status%20and%20Activating%20C%2B%2B11%20support%20in%20Clang\">STACKOVERFLOW</a></p>\n</blockquote>\n<h1 id=\"lambda介绍\">Lambda介绍</h1>\n<p>lambda 表达式是 <a href=\"http://c.biancheng.net/cplus/\">C++</a>11 最重要也最常用的一个特性之一，<a href=\"http://c.biancheng.net/csharp/\">C#</a> 3.5 和 <a href=\"http://c.biancheng.net/java/\">Java</a> 8 中就引入了 lambda 表达式。</p>\n<p>lambda 来源于 <strong>函数式编程</strong> 的概念，也是现代编程语言的一个特点。C++11 这次终于把 lambda 加进来了。</p>\n<p>lambda表达式有如下优点：</p>\n<ul>\n<li><strong>声明式编程风格</strong>：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或者函数对象。以更直接的方式去写程序，好的可读性和可维护性。</li>\n<li><strong>简洁</strong>：不需要额外再写一个函数或者函数对象，避免了代码膨胀和功能分散，让开发者更加集中精力在手边的问题，同时也获取了更高的生产率。</li>\n<li>在需要的时间和地点实现功能闭包，使程序更灵活。</li>\n</ul>\n<p>下面，先从 lambda 表达式的基本功能开始介绍它。</p>\n<h1 id=\"lambda-表达式的概念和基本用法\">Lambda 表达式的概念和基本用法</h1>\n<p>lambda 表达式定义了一个 <strong>匿名函数</strong>，并且可以 <strong>捕获一定范围内的变量</strong>。lambda 表达式的语法形式可简单归纳如下：</p>\n<p><code>[ capture ] ( params ) opt -&gt; ret &#123; body; &#125;;</code></p>\n<blockquote>\n<ul>\n<li>capture 是捕获列表</li>\n<li>params 是参数表</li>\n<li>opt 是函数选项</li>\n<li>ret 是返回值类型</li>\n<li>body是函数体。</li>\n</ul>\n</blockquote>\n<p>因此，一个完整的 lambda 表达式看起来像这样：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> f = [](<span class=\"keyword\">int</span> a) -&gt; <span class=\"keyword\">int</span> &#123; <span class=\"keyword\">return</span> a + <span class=\"number\">1</span>; &#125;;std::cout &lt;&lt; <span class=\"built_in\">f</span>(<span class=\"number\">1</span>) &lt;&lt; std::endl;  </span><br></pre></td></tr></table></figure>\n<p>可以看到，上面通过一行代码定义了一个小小的功能闭包，用来将输入加 1 并返回。</p>\n<p>在 C++11 中，lambda 表达式的返回值是通过前面介绍的《<a href=\"http://c.biancheng.net/view/3727.html\">C++返回值类型后置</a>》语法来定义的。</p>\n<p>其实很多时候，lambda 表达式的返回值是非常明显的，比如这个例子。因此，C++11 中允许省略 lambda 表达式的返回值定义：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> f = [](<span class=\"keyword\">int</span> a)&#123; <span class=\"keyword\">return</span> a + <span class=\"number\">1</span>; &#125;;</span><br></pre></td></tr></table></figure>\n<p>这样编译器就会根据 return 语句自动推导出返回值类型。</p>\n<p>需要注意的是，初始化列表不能用于返回值的自动推导：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> x1 = [](<span class=\"keyword\">int</span> i)&#123; <span class=\"keyword\">return</span> i; &#125;; <span class=\"comment\">// OK: return type is int</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> x2 = []()&#123; <span class=\"keyword\">return</span> &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span> &#125;; &#125;; <span class=\"comment\">// error: 无法推导出返回值类型</span></span><br></pre></td></tr></table></figure>\n<p>这时我们需要显式给出具体的返回值类型。</p>\n<p>另外，lambda 表达式在没有参数列表时，参数列表是可以省略的。因此像下面的写法都是正确的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> f1 = []()&#123; <span class=\"keyword\">return</span> <span class=\"number\">1</span>; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> f2 = []&#123; <span class=\"keyword\">return</span> <span class=\"number\">1</span>; &#125;; <span class=\"comment\">// 省略空参数表</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"捕获列表\">捕获列表</h1>\n<p>lambda 表达式还可以通过捕获列表捕获一定范围内的变量：</p>\n<ul>\n<li>[] 不捕获任何变量。</li>\n<li>[&amp;] 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li>\n<li>[=] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。</li>\n<li>[=，&amp;foo] 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。</li>\n<li>[bar] 按值捕获 bar 变量，同时不捕获其他变量。</li>\n<li>[this] 捕获当前类中的 this <a href=\"http://c.biancheng.net/c/80/\">指针</a>，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 &amp; 或者 =，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。</li>\n</ul>\n<p>下面看一下它的具体用法，如下所示。</p>\n<p>【实例】lambda 表达式的基本用法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span>    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:    </span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i_ = <span class=\"number\">0</span>;    </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>&#123;        </span><br><span class=\"line\">\t\t<span class=\"keyword\">auto</span> x1 = []&#123; <span class=\"keyword\">return</span> i_; &#125;;                            </span><br><span class=\"line\">\t\t<span class=\"keyword\">auto</span> x2 = [=]&#123; <span class=\"keyword\">return</span> i_ + x + y; &#125;;                   </span><br><span class=\"line\">\t\t<span class=\"keyword\">auto</span> x3 = [&amp;]&#123; <span class=\"keyword\">return</span> i_ + x + y; &#125;;                   </span><br><span class=\"line\">\t\t<span class=\"keyword\">auto</span> x4 = [<span class=\"keyword\">this</span>]&#123; <span class=\"keyword\">return</span> i_; &#125;;                        </span><br><span class=\"line\">\t\t<span class=\"keyword\">auto</span> x5 = [<span class=\"keyword\">this</span>]&#123; <span class=\"keyword\">return</span> i_ + x + y; &#125;;                </span><br><span class=\"line\">\t\t<span class=\"keyword\">auto</span> x6 = [<span class=\"keyword\">this</span>, x, y]&#123; <span class=\"keyword\">return</span> i_ + x + y; &#125;;          </span><br><span class=\"line\">\t\t<span class=\"keyword\">auto</span> x7 = [<span class=\"keyword\">this</span>]&#123; <span class=\"keyword\">return</span> i_++; &#125;;                  </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">0</span>, b = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> f1 = []&#123; <span class=\"keyword\">return</span> a; &#125;;               </span><br><span class=\"line\"><span class=\"keyword\">auto</span> f2 = [&amp;]&#123; <span class=\"keyword\">return</span> a++; &#125;;            </span><br><span class=\"line\"><span class=\"keyword\">auto</span> f3 = [=]&#123; <span class=\"keyword\">return</span> a; &#125;;              </span><br><span class=\"line\"><span class=\"keyword\">auto</span> f4 = [=]&#123; <span class=\"keyword\">return</span> a++; &#125;;            </span><br><span class=\"line\"><span class=\"keyword\">auto</span> f5 = [a]&#123; <span class=\"keyword\">return</span> a + b; &#125;;          </span><br><span class=\"line\"><span class=\"keyword\">auto</span> f6 = [a, &amp;b]&#123; <span class=\"keyword\">return</span> a + (b++); &#125;;  </span><br><span class=\"line\"><span class=\"keyword\">auto</span> f7 = [=, &amp;b]&#123; <span class=\"keyword\">return</span> a + (b++); &#125;;  </span><br></pre></td></tr></table></figure>\n<p>从上例中可以看到，lambda 表达式的捕获列表精细地控制了 lambda 表达式能够访问的外部变量，以及如何访问这些变量。</p>\n<p><strong>注意</strong>：默认状态下 lambda 表达式无法修改通过复制方式捕获的外部变量。如果希望修改这些变量的话，我们需要使用引用方式进行捕获。</p>\n<p>一个容易出错的细节是关于 lambda 表达式的延迟调用的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> f = [=]&#123; <span class=\"keyword\">return</span> a; &#125;;      </span><br><span class=\"line\">a += <span class=\"number\">1</span>;                         </span><br><span class=\"line\">std::cout &lt;&lt; <span class=\"built_in\">f</span>() &lt;&lt; std::endl;  </span><br></pre></td></tr></table></figure>\n<p>在这个例子中，lambda 表达式按值捕获了所有外部变量。在捕获的一瞬间，a 的值就已经被复制到f中了。之后 a 被修改，但此时 f 中存储的 a 仍然还是捕获时的值，因此，最终输出结果是 0。</p>\n<p>如果希望 lambda 表达式在调用时能够即时访问外部变量，我们应当使用引用方式捕获。</p>\n<p>从上面的例子中我们知道，按值捕获得到的外部变量值是在 lambda 表达式定义时的值。此时所有外部变量均被复制了一份存储在 lambda 表达式变量中。此时虽然修改 lambda 表达式中的这些外部变量并不会真正影响到外部，我们却仍然无法修改它们。</p>\n<p>那么如果希望去修改按值捕获的外部变量应当怎么办呢？这时，需要显式指明 lambda 表达式为 mutable：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> f1 = [=]&#123; <span class=\"keyword\">return</span> a++; &#125;;             </span><br><span class=\"line\"><span class=\"keyword\">auto</span> f2 = [=]() <span class=\"keyword\">mutable</span> &#123; <span class=\"keyword\">return</span> a++; &#125;;  </span><br></pre></td></tr></table></figure>\n<p>需要注意的一点是，被 mutable 修饰的 lambda 表达式就算没有参数也要写明参数列表。</p>\n<h1 id=\"lambda-表达式的类型\">Lambda 表达式的类型</h1>\n<p>最后，介绍一下 lambda 表达式的类型。</p>\n<p>lambda 表达式的类型在 C++11 中被称为“闭包类型（Closure Type）”。它是一个特殊的，匿名的非 nunion 的类类型。</p>\n<p>因此，我们可以认为它是一个带有 operator() 的类，即仿函数。因此，我们可以使用 std::function 和 std::bind 来存储和操作 lambda 表达式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::function&lt;<span class=\"built_in\"><span class=\"keyword\">int</span></span>(<span class=\"keyword\">int</span>)&gt;  f1 = [](<span class=\"keyword\">int</span> a)&#123; <span class=\"keyword\">return</span> a; &#125;;std::function&lt;<span class=\"built_in\"><span class=\"keyword\">int</span></span>(<span class=\"keyword\">void</span>)&gt; f2 = std::<span class=\"built_in\">bind</span>([](<span class=\"keyword\">int</span> a)&#123; <span class=\"keyword\">return</span> a; &#125;, <span class=\"number\">123</span>);</span><br></pre></td></tr></table></figure>\n<p>另外，对于没有捕获任何变量的 lambda 表达式，还可以被转换成一个普通的函数指针：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">func_t</span> = <span class=\"built_in\"><span class=\"keyword\">int</span></span>(*)(<span class=\"keyword\">int</span>);</span><br><span class=\"line\"><span class=\"keyword\">func_t</span> f = [](<span class=\"keyword\">int</span> a)&#123; <span class=\"keyword\">return</span> a; &#125;;</span><br><span class=\"line\"><span class=\"built_in\">f</span>(<span class=\"number\">123</span>);</span><br></pre></td></tr></table></figure>\n<p>lambda 表达式可以说是就地定义仿函数闭包的“语法糖”。它的捕获列表捕获住的任何外部变量，最终均会变为闭包类型的成员变量。而一个使用了成员变量的类的 operator()，如果能直接被转换为普通的函数指针，那么 lambda 表达式本身的 this 指针就丢失掉了。而没有捕获任何外部变量的 lambda 表达式则不存在这个问题。</p>\n<p>这里也可以很自然地解释为何按值捕获无法修改捕获的外部变量。因为按照 C++ 标准，lambda 表达式的 operator() 默认是 const 的。一个 const 成员函数是无法修改成员变量的值的。而 mutable 的作用，就在于取消 operator() 的 const。</p>\n<p>需要注意的是，没有捕获变量的 lambda 表达式可以直接转换为函数指针，而捕获变量的 lambda 表达式则不能转换为函数指针。看看下面的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span><span class=\"params\">(*Ptr)</span><span class=\"params\">(<span class=\"keyword\">int</span>*)</span></span>;</span><br><span class=\"line\">Ptr p = [](<span class=\"keyword\">int</span>* p)&#123;<span class=\"keyword\">delete</span> p;&#125;;  </span><br><span class=\"line\">Ptr p1 = [&amp;](<span class=\"keyword\">int</span>* p)&#123;<span class=\"keyword\">delete</span> p;&#125;;  </span><br></pre></td></tr></table></figure>\n<p>上面第二行代码能编译通过，而第三行代码不能编译通过，因为第三行的代码捕获了变量，不能直接转换为函数指针。</p>\n<h1 id=\"声明式的编程风格简洁的代码\">声明式的编程风格，简洁的代码</h1>\n<p>就地定义匿名函数，不再需要定义函数对象，大大简化了标准库算法的调用。比如，在 C++11 之前，我们要调用 for_each 函数将 vector 中的偶数打印出来，如下所示。</p>\n<p>【实例】lambda 表达式代替函数对象的示例。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountEven</span>&#123;</span>    </span><br><span class=\"line\">\t<span class=\"keyword\">int</span>&amp; count_;<span class=\"keyword\">public</span>:    </span><br><span class=\"line\">\t<span class=\"built_in\">CountEven</span>(<span class=\"keyword\">int</span>&amp; count) : <span class=\"built_in\">count_</span>(count) &#123;&#125;    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span>    </span>&#123;        <span class=\"keyword\">if</span> (!(val &amp; <span class=\"number\">1</span>))               &#123;            ++ count_;        &#125;    &#125;&#125;;</span><br><span class=\"line\">\tstd::vector&lt;<span class=\"keyword\">int</span>&gt; v = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> even_count = <span class=\"number\">0</span>;for_each(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), <span class=\"built_in\">CountEven</span>(even_count));std::cout &lt;&lt; <span class=\"string\">&quot;The number of even is &quot;</span> &lt;&lt; even_count &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>\n<p>这样写既烦琐又容易出错。有了 lambda 表达式以后，我们可以使用真正的闭包概念来替换掉这里的仿函数，代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::vector&lt;<span class=\"keyword\">int</span>&gt; v = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> even_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">for_each( v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), [&amp;even_count](<span class=\"keyword\">int</span> val)        &#123;            <span class=\"keyword\">if</span> (!(val &amp; <span class=\"number\">1</span>))              &#123;                ++ even_count;            &#125;        &#125;);</span><br><span class=\"line\">std::cout &lt;&lt; <span class=\"string\">&quot;The number of even is &quot;</span> &lt;&lt; even_count &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>\n<p>lambda 表达式的价值在于，就地封装短小的功能闭包，可以极其方便地表达出我们希望执行的具体操作，并让上下文结合得更加紧密。</p>\n<p>​</p>\n","categories":["Programming"],"tags":["C++","lambda"]},{"title":"C++多线程笔记","url":"/2021/05/29/Programming/C++/2021-05-29-C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/","content":"<h1 id=\"线程创建\">线程创建</h1>\n<p>C++中对线程的创建都需要使用到库函数 <code>&lt;thread&gt;</code> ，但是线程的启动和使用可以通过 <strong><em>函数</em></strong> 和 <strong><em>带有函数调用操作符的类实例</em></strong> 来进行。</p>\n<h2 id=\"函数式启动\">函数式启动</h2>\n<h3 id=\"函数名启动\">函数名启动</h3>\n<p>无论是从何处启用多线程，都需要从C++线程库 <code>&lt;thread&gt;</code> 来开始一个线程，通过构造一个 <code>std::thread</code> 对象来启动，以下为最常见的线程创建方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">threadHello</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">std::thread <span class=\"title\">thread1</span><span class=\"params\">(threadHello)</span></span>;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>threadHello()</code> 就是需要执行线程的函数；</p>\n<p><code>std::thread</code> 就是创建线程对象的类型；</p>\n<p><code>thread1</code> 就是被创造的线程对象，而 <code>()</code> 中则填写着被这个对象调用的函数。</p>\n</blockquote>\n<h3 id=\"函数启动\">函数启动</h3>\n<p>不同于通过函数名启动，函数启动时会带上其括号 <code>()</code> ， 多个线程可被同时被一个线程对象启动。</p>\n<p>式1：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::thread <span class=\"title\">my_thread</span><span class=\"params\">((background_task()))</span></span>;</span><br></pre></td></tr></table></figure>\n<p>其中，通过第二层外层 <code>()</code> 将函数及其 <code>()</code> 括起来避免被解释为函数声明，即 <code>my_thread( ( f() ) )</code> 。</p>\n<p>式2：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::thread my_thread&#123; <span class=\"built_in\">background_task</span>() &#125;;</span><br></pre></td></tr></table></figure>\n<p>通过将 <code>background()</code> 包括在 <code>&#123;&#125;</code> 中，同样是将 <code>background()</code> 声明为一个变量的方法。</p>\n<h3 id=\"lambda表达式\">Lambda表达式</h3>\n<p>lambda表达式是在C++11以后的新特性。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 类实例启动</span><br><span class=\"line\"></span><br><span class=\"line\">`std::thread` 可以与任何 可调用（callable）类型一同工作，因此可以将一个带有函数调用操作符的类的实例传递给 `std::thread` 的构造函数来进行代替。</span><br><span class=\"line\"></span><br><span class=\"line\">```c++</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">background_task</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;   <span class=\"comment\">//带有函数调用操作符</span></span><br><span class=\"line\">    <span class=\"built_in\">do_something</span>();</span><br><span class=\"line\">    <span class=\"built_in\">do_something_else</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">background_task threadF;  <span class=\"comment\">//类实例</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::thread <span class=\"title\">thread1</span><span class=\"params\">(threadF)</span></span>;  <span class=\"comment\">//线程调用该类实例</span></span><br></pre></td></tr></table></figure>\n<p>这种情况下，所提供的函数对象被赋值（copied）到属于新创建的执行线程的存储器中，并从那里调用。因此，副本与原版有着灯箱的行为，否则结果可能与预期不符。</p>\n<h3 id=\"函数调用操作符\">函数调用操作符</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AA</span>&#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  \tcout&lt;&lt;<span class=\"string\">&quot;aa&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>AA()()</code> 中，<code>AA()</code> 是构造函数，调用了<code>()</code> 操作符。</p>\n","categories":["Programming"],"tags":["C++","多线程"]},{"title":"C++11多线程join()和detach()的理解","url":"/2021/05/31/Programming/C++/2021-05-31-C%2011%E5%A4%9A%E7%BA%BF%E7%A8%8Bjoin()%E5%92%8Cdetach()%E7%9A%84%E7%90%86%E8%A7%A3/","content":"<p><a href=\"https://blog.csdn.net/qq_36784975/article/details/87699113\">blog.csdn.net</a></p>\n<h1 id=\"简介\">简介</h1>\n<p>每一个程序至少拥有一个线程，那就是执行 <code>main()</code> 函数的主线程，而多线程则是出现两个或两个以上的线程并行运行，即主线程和子线程在同一时间段同时运行。而在这个过程中会出现几种情况：</p>\n<ol type=\"1\">\n<li>主线程先运行结束</li>\n<li>子线程先运行结束</li>\n<li>主子线程同时结束</li>\n</ol>\n<p>在一些情况下需要在子线程结束后主线程才能结束，而一些情况则不需要等待，但需注意一点，并不是主线程结束了其他子线程就立即停止，其他子线程会进入后台运行</p>\n<h1 id=\"join\">join()</h1>\n<p>join()函数是一个等待线程完成函数，<mark>主线程需要等待子线程运行结束了才可以结束</mark></p>\n<p><img src=\"https://pic.islet.space/2021/05/image-20210531223156398.png\" alt=\"image-20210531223156398\" style=\"zoom:80%;\" /></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">-10</span>; i &gt; <span class=\"number\">-20</span>; i--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;from func():&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>  <span class=\"comment\">//主线程</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(func)</span></span>;  <span class=\"comment\">//子线程</span></span><br><span class=\"line\">\tt.<span class=\"built_in\">join</span>();  <span class=\"comment\">//等待子线程结束后才进入主线程</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Nzg0OTc1,size_16,color_FFFFFF,t_70.png\" alt=\"在这里插入图片描述\" /><figcaption aria-hidden=\"true\">在这里插入图片描述</figcaption>\n</figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">-10</span>; i &gt; <span class=\"number\">-20</span>; i--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;from func():&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>\t\t\t<span class=\"comment\">//主线程</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(func)</span></span>;\t<span class=\"comment\">//子线程</span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\tt.<span class=\"built_in\">join</span>();\t\t<span class=\"comment\">//等待子线程结束后才进入主线程</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Nzg0OTc1,size_16,color_FFFFFF,t_70-20210531224629846.png\" alt=\"在这里插入图片描述\" /><figcaption aria-hidden=\"true\">在这里插入图片描述</figcaption>\n</figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">-10</span>; i &gt; <span class=\"number\">-20</span>; i--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;from func():&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>\t\t\t<span class=\"comment\">//主线程</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(func)</span></span>;\t<span class=\"comment\">//子线程</span></span><br><span class=\"line\">\tt.<span class=\"built_in\">join</span>();\t\t<span class=\"comment\">//等待子线程结束后才进入主线程</span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Nzg0OTc1,size_16,color_FFFFFF,t_70-20210531224634866.png\" alt=\"在这里插入图片描述\" /><figcaption aria-hidden=\"true\">在这里插入图片描述</figcaption>\n</figure>\n<h1 id=\"detach\">detach()</h1>\n<figure>\n<img src=\"https://pic.islet.space/2021/06/image-20210601222337419.png\" alt=\"image-20210601222337419\" /><figcaption aria-hidden=\"true\">image-20210601222337419</figcaption>\n</figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">-10</span>; i &gt; <span class=\"number\">-20</span>; i--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;from func():&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>\t\t\t<span class=\"comment\">//主线程</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(func)</span></span>;\t<span class=\"comment\">//子线程</span></span><br><span class=\"line\">\tt.<span class=\"built_in\">detach</span>();\t\t<span class=\"comment\">//分离子线程</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/20190220120254940.png\" alt=\"在这里插入图片描述\" /><figcaption aria-hidden=\"true\">在这里插入图片描述</figcaption>\n</figure>\n<p>可以明显看到，主线程太快了，还没等子线程运行就结束了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">-10</span>; i &gt; <span class=\"number\">-20</span>; i--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;from func():&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>\t\t\t<span class=\"comment\">//主线程</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(func)</span></span>;\t<span class=\"comment\">//子线程</span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\tt.<span class=\"built_in\">detach</span>();\t\t<span class=\"comment\">//分离子线程</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Nzg0OTc1,size_16,color_FFFFFF,t_70-20210531224653683.png\" alt=\"在这里插入图片描述\" /><figcaption aria-hidden=\"true\">在这里插入图片描述</figcaption>\n</figure>\n<p>同样没等子线程运行完就结束了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">-10</span>; i &gt; <span class=\"number\">-20</span>; i--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;from func():&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>\t\t\t<span class=\"comment\">//主线程</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(func)</span></span>;\t<span class=\"comment\">//子线程</span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\tt.<span class=\"built_in\">detach</span>();\t\t<span class=\"comment\">//分离子线程</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Nzg0OTc1,size_16,color_FFFFFF,t_70-20210531224659144.png\" alt=\"在这里插入图片描述\" /><figcaption aria-hidden=\"true\">在这里插入图片描述</figcaption>\n</figure>\n<p>没等子线程运行完就结束</p>\n<h1 id=\"总结\">总结</h1>\n<ul>\n<li><p>如果想要分离一个线程，可以在线程启动后，直接使用 <code>detach()</code> 进行分离。如果打算等待对应线程，则需要细心挑选调用 <code>join()</code> 的位置。当在线程运行之后产生异常，在 <code>join()</code> 调用之前抛出，就意味着很这次调用会被跳过。</p></li>\n<li><p><code>join()</code> 函数是一个<strong>等待线程函数</strong>，主线程需等待子线程运行结束后才可以结束（注意不是才可以运行，运行是并行的），如果打算等待对应线程，<mark>则需要细心挑选调用 <code>join()</code> 的位置</mark></p></li>\n<li><p><code>detach()</code> 函数是子线程的分离函数，当调用该函数后，线程就被分离到后台运行，<mark>主线程不需要等待该线程结束才结束</mark></p></li>\n</ul>\n<p>​</p>\n","categories":["Programming"],"tags":["C++","thread","join","detach"]},{"title":"C++异常处理（try catch throw）完全攻略","url":"/2021/05/31/Programming/C++/2021-05-31-C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%88try-catch-throw%EF%BC%89%E5%AE%8C%E5%85%A8%E6%94%BB%E7%95%A5/","content":"<p><a href=\"http://c.biancheng.net/view/422.html\">c.biancheng.net</a></p>\n<p>程序运行时常会碰到一些异常情况，例如：</p>\n<ul>\n<li>做除法的时候除数为 0；</li>\n<li>用户输入年龄时输入了一个负数；</li>\n<li>用 new 运算符动态分配空间时，空间不够导致无法分配；</li>\n<li>访问数组元素时，下标越界；打开文件读取时，文件不存在。</li>\n</ul>\n<p>这些异常情况，如果不能发现并加以处理，很可能会导致程序崩溃。</p>\n<blockquote>\n<p>所谓“处理”，可以是给出错误提示信息，然后让程序沿一条不会出错的路径继续执行；</p>\n<p>也可能是不得不结束程序，但在结束前做一些必要的工作，如将内存中的数据写入文件、关闭打开的文件、释放动态分配的内存空间等。</p>\n</blockquote>\n<p><strong>一发现异常情况就立即处理未必妥当，因为在一个函数执行过程中发生的异常，在有的情况下由该函数的调用者决定如何处理更加合适。 尤其像库函数这类提供给程序员调用，用以完成与具体应用无关的通用功能的函数，执行过程中贸然对异常进行处理，未必符合调用它的程序的需要。</strong></p>\n<p><strong>此外，将异常分散在各处进行处理不利于代码的维护，尤其是对于在不同地方发生的同一种异常，都要编写相同的处理代码也是一种不必要的重复和冗余。如果能在发生各种异常时让程序都执行到同一个地方，这个地方能够对异常进行集中处理，则程序就会更容易编写、维护。</strong></p>\n<p>鉴于上述原因，<a href=\"http://c.biancheng.net/cplus/\">C++</a> 引入了异常处理机制。其基本思想是：</p>\n<blockquote>\n<p>函数 A 在执行过程中发现异常时可以不加处理，而只是“拋出一个异常”给 A 的调用者，假定为函数 B。</p>\n</blockquote>\n<p>拋出异常而不加处理会导致函数 A 立即中止，在这种情况下，函数 B 可以选择捕获 A 拋出的异常进行处理，也可以选择置之不理。如果置之不理，这个异常就会被拋给 B 的调用者，以此类推。</p>\n<p>【也就是说，在C++中，异常发生时，是否处理可以由函数的上一级调用函数去决定，如果选择不处理则会将该异常交给更上一级函数去决断。】</p>\n<p>如果一层层的函数都不处理异常，异常最终会被拋给最外层的 main 函数。main 函数应该处理异常。如果main函数也不处理异常，那么程序就会立即异常地中止。</p>\n<h1 id=\"c异常处理基本语法\">C++异常处理基本语法</h1>\n<h2 id=\"threw语法定义\">threw语法定义</h2>\n<p>C++ 通过 <code>throw</code> 语句和 <code>try-catch</code> 语句实现对异常的处理。<code>throw</code> 语句的语法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span>  <span class=\"comment\">/*表达式*/</span>;</span><br></pre></td></tr></table></figure>\n<p>该语句拋出一个异常。异常是一个表达式，其值的类型可以是 <mark>基本类型</mark>，也可以是 <mark>类</mark>。</p>\n<h2 id=\"try-catch语法定义\">try-catch语法定义</h2>\n<p><code>try-catch</code> 语句的语法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//语句组</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"built_in\"><span class=\"keyword\">catch</span></span>(<span class=\"comment\">/* 异常类型 */</span>) &#123;</span><br><span class=\"line\">   <span class=\"comment\">//异常处理代码</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> ...</span><br><span class=\"line\"> <span class=\"built_in\"><span class=\"keyword\">catch</span></span>( <span class=\"comment\">/* 异常类型 */</span>) &#123;</span><br><span class=\"line\">   <span class=\"comment\">//异常处理代码</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><code>catch</code> 可以有多个，但至少要有一个。</p>\n<p>不妨把 try 和其后<code>&#123;&#125;</code>中的内容称作“try块”，把 catch 和其后<code>&#123;&#125;</code>中的内容称作“catch块”。</p>\n<h2 id=\"try-catch执行过程\">try-catch执行过程</h2>\n<p><code>try-catch</code> 语句的执行过程是：</p>\n<ul>\n<li>执行 try 块中的语句，如果执行的过程中没有异常拋出，那么执行完后就执行最后一个 catch 块后面的语句，所有 catch 块中的语句都不会被执行；</li>\n<li>如果 try 块执行的过程中拋出了异常，那么拋出异常后立即跳转到第一个“异常类型”和拋出的异常类型匹配的 catch 块中执行（称作异常被该 catch 块“捕获”），执行完后再跳转到最后一个 catch 块后面继续执行。</li>\n</ul>\n<h2 id=\"例程\">例程</h2>\n<p>例如下面的程序：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;    </span><br><span class=\"line\">\t<span class=\"keyword\">double</span> m ,n;    </span><br><span class=\"line\">\tcin &gt;&gt; m &gt;&gt; n;    </span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;        </span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;before dividing.&quot;</span> &lt;&lt; endl;        </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>( n == <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> cout &lt;&lt; m / n &lt;&lt; endl;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;after dividing.&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\"><span class=\"keyword\">catch</span></span>(<span class=\"keyword\">double</span> d)&#123;</span><br><span class=\"line\">  \tcout &lt;&lt; <span class=\"string\">&quot;catch(double) &quot;</span> &lt;&lt; d &lt;&lt;  endl;    </span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">  <span class=\"built_in\"><span class=\"keyword\">catch</span></span>(<span class=\"keyword\">int</span> e)&#123;</span><br><span class=\"line\">  \tcout &lt;&lt; <span class=\"string\">&quot;catch(int) &quot;</span> &lt;&lt; e &lt;&lt; endl;    </span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">  cout &lt;&lt; <span class=\"string\">&quot;finished&quot;</span> &lt;&lt; endl;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序的运行结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">9 6</span><br><span class=\"line\">before dividing.</span><br><span class=\"line\">1.5</span><br><span class=\"line\">after dividing.</span><br><span class=\"line\">finished</span><br></pre></td></tr></table></figure>\n<p>说明当 n 不为 0 时，try 块中不会拋出异常。因此程序在 try 块正常执行完后，越过所有的 catch 块继续执行，catch 块一个也不会执行。</p>\n<p>程序的运行结果也可能如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">9 0</span><br><span class=\"line\">before dividing.</span><br><span class=\"line\">catch\\(int) -1</span><br><span class=\"line\">finished</span><br></pre></td></tr></table></figure>\n<p>当 n 为 0 时，try 块中会拋出一个整型异常。拋出异常后，try 块立即停止执行。该整型异常会被类型匹配的第一个 catch 块捕获，即进入<code>catch(int e)</code>块执行，该 catch 块执行完毕后，程序继续往后执行，直到正常结束。</p>\n<p>如果拋出的异常没有被 catch 块捕获，例如，将<code>catch(int e)</code>，改为<code>catch(char e)</code>，当输入的 n 为 0 时，拋出的整型异常就没有 catch 块能捕获，这个异常也就得不到处理，那么程序就会立即中止，try...catch 后面的内容都不会被执行。</p>\n<h1 id=\"能够捕获任何异常的-catch-语句\">能够捕获任何异常的 catch 语句</h1>\n<p>如果希望不论拋出哪种类型的异常都能捕获，可以编写如下 catch 块：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">catch</span></span>(...) &#123;</span><br><span class=\"line\">   <span class=\"comment\">//...</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>这样的 catch 块能够捕获任何还没有被捕获的异常。例如下面的程序：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> m, n;</span><br><span class=\"line\">  cin &gt;&gt; m &gt;&gt; n;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;before dividing.&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (m == <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> - <span class=\"number\">1.0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> cout &lt;&lt; m / n &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;after dividing.&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (<span class=\"keyword\">double</span> d) &#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;catch (double)&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (...) &#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;catch (...)&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">  cout &lt;&lt; <span class=\"string\">&quot;finished&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序的运行结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">9 0</span><br><span class=\"line\">before dividing.</span><br><span class=\"line\">catch (...)</span><br><span class=\"line\">finished</span><br></pre></td></tr></table></figure>\n<p>当 n 为 0 时，拋出的整型异常被<code>catchy(...)</code>捕获。</p>\n<p>程序的运行结果也可能如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">0 6</span><br><span class=\"line\">before dividing.</span><br><span class=\"line\">catch (double) -1</span><br><span class=\"line\">finished</span><br></pre></td></tr></table></figure>\n<p>当 m 为 0 时，拋出一个 double 类型的异常。虽然<code>catch (double)</code>和<code>catch(...)</code>都能匹配该异常，但是<code>catch(double)</code>是第一个能匹配的 catch 块，因此会执行它，而不会执行<code>catch(...)</code>块。</p>\n<p>由于<code>catch(...)</code>能匹配任何类型的异常，它后面的 catch 块实际上就不起作用，因此不要将它写在其他 catch 块前面。</p>\n<h1 id=\"异常的再拋出\">异常的再拋出</h1>\n<p>如果一个函数在执行过程中拋出的异常在本函数内就被 catch 块捕获并处理，那么该异常就不会拋给这个函数的调用者（也称为“上一层的函数”）；如果异常在本函数中没有被处理，则它就会被拋给上一层的函数。例如下面的程序：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CException</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:    </span><br><span class=\"line\">  string msg;    </span><br><span class=\"line\">  <span class=\"built_in\">CException</span>(string s) : <span class=\"built_in\">msg</span>(s) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">Devide</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">double</span> y)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (y == <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"built_in\">CException</span>(<span class=\"string\">&quot;devided by zero&quot;</span>);</span><br><span class=\"line\">  cout &lt;&lt; <span class=\"string\">&quot;in Devide&quot;</span> &lt;&lt; endl;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x / y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">CountTax</span><span class=\"params\">(<span class=\"keyword\">int</span> salary)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (salary &lt; <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;counting tax&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">  <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (<span class=\"keyword\">int</span>)&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;salary &lt; 0&quot;</span> &lt;&lt; endl;    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  cout &lt;&lt; <span class=\"string\">&quot;tax counted&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> salary * <span class=\"number\">0.15</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> f = <span class=\"number\">1.2</span>;    </span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CountTax</span>(<span class=\"number\">-1</span>);  <span class=\"comment\">//此处会报错，立即抛出错误被catch(int)捕获，并终止运行</span></span><br><span class=\"line\">    f = <span class=\"built_in\">Devide</span>(<span class=\"number\">3</span>, <span class=\"number\">0</span>);  <span class=\"comment\">//此处也会报错，在”devided by zero“处立即停止，且没有返回值返回赋给f</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;end of try block&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (CException e)&#123;</span><br><span class=\"line\">    cout &lt;&lt; e.msg &lt;&lt; endl;    </span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">  cout &lt;&lt; <span class=\"string\">&quot;f = &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class=\"line\">  cout &lt;&lt; <span class=\"string\">&quot;finished&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序的输出结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">salary &lt; 0</span><br><span class=\"line\">tax counted</span><br><span class=\"line\">devided by zero</span><br><span class=\"line\">f=1.2</span><br><span class=\"line\">finished</span><br></pre></td></tr></table></figure>\n<p>CountTa 函数拋出异常后自行处理，这个异常就不会继续被拋给调用者，即 main 函数。因此在 main 函数的 try 块中，CountTax 之后的语句还能正常执行，即会执行<code>f = Devide(3, 0);</code>。</p>\n<p>第 33 行，Devide 函数拋出了异常却不处理，该异常就会被拋给 Devide 函数的调用者，即 main 函数。拋出此异常后，Devide 函数立即结束，第 13 行不会被执行，函数也不会返回一个值，这从第 33 行 f 的值不会被修改可以看出。</p>\n<p><code>Devide()</code> 中第 12 行 拋出的异常被 main 函数中类型匹配的 catch 块捕获。第 36 行中的 e 对象是用<strong>复制构造函数初始化</strong>的。</p>\n<p><mark>如果拋出的异常是派生类的对象，而 catch 块的异常类型是基类，那么这两者也能够匹配，因为派生类对象也是基类对象。</mark></p>\n<blockquote>\n<p>虽然函数也可以通过返回值或者传引用的参数通知调用者发生了异常，但采用这种方式的话，每次调用函数时都要判断是否发生了异常，这在函数被多处调用时比较麻烦。有了异常处理机制，可以将多处函数调用都写在一个 try 块中，任何一处调用发生异常都会被匹配的 catch 块捕获并处理，也就不需要每次调用后都判断是否发生了异常。</p>\n</blockquote>\n<p>有时，虽然在函数中对异常进行了处理，但是还是希望能够通知调用者，以便让调用者知道发生了异常，从而可以作进一步的处理。在 catch 块中拋出异常可以满足这种需要。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">CountTax</span><span class=\"params\">(<span class=\"keyword\">int</span> salary)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">if</span>( salary &lt; <span class=\"number\">0</span> ) <span class=\"keyword\">throw</span> <span class=\"built_in\">string</span>(<span class=\"string\">&quot;zero salary&quot;</span>);</span><br><span class=\"line\">  \tcout &lt;&lt; <span class=\"string\">&quot;counting tax&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (string s )&#123;</span><br><span class=\"line\">  \tcout &lt;&lt; <span class=\"string\">&quot;CountTax error : &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span>;  <span class=\"comment\">//单写一个throw会把最近的错误传给上一级进行处理</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  cout &lt;&lt; <span class=\"string\">&quot;tax counted&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> salary * <span class=\"number\">0.15</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> f = <span class=\"number\">1.2</span>;    </span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CountTax</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;end of try block&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">  <span class=\"built_in\"><span class=\"keyword\">catch</span></span>(string s) &#123;</span><br><span class=\"line\">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">  cout &lt;&lt; <span class=\"string\">&quot;finished&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序的输出结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">CountTax error:zero salary</span><br><span class=\"line\">zero salary</span><br><span class=\"line\">finished</span><br></pre></td></tr></table></figure>\n<p>第 12行的<code>throw;</code>没有指明拋出什么样的异常，因此<mark>拋出的就是 catch 块捕获到的异常</mark>，即 <code>string(\"zero salary”)</code> 。这个异常会被 <code>main</code> 函数中的 <code>catch</code> 块捕获。</p>\n<h1 id=\"函数的异常声明列表\">函数的异常声明列表</h1>\n<p>为了增强程序的可读性和可维护性，使程序员在使用一个函数时就能看出这个函数可能会拋出哪些异常，C++ 允许在函数声明和定义时，加上它所能拋出的异常的列表，称为 <mark>异常声明列表</mark>，具体写法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"title\">throw</span> <span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">double</span>, A, B, C)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"title\">throw</span> <span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">double</span>, A, B, C)</span></span>&#123;…&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的写法表明 func 可能拋出 int 型、double 型以及 A、B、C 三种类型的异常。异常声明列表可以在函数声明时写，也可以在函数定义时写。如果两处都写，则两处应一致。</p>\n<p>如果异常声明列表如下编写：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"title\">throw</span> <span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<p>则说明 func 函数不会拋出任何异常。</p>\n<p><mark>一个函数如果不交待能拋出哪些类型的异常，就可以拋出任何类型的异常。</mark></p>\n<p>函数如果拋出了其异常声明列表中没有的异常，在编译时不会引发错误，但在运行时， Dev C++ 编译出来的程序会出错；用 Visual Studio 2010 编译出来的程序则不会出错，异常声明列表不起实际作用。</p>\n<h1 id=\"c标准异常类\">C++标准异常类</h1>\n<p>C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的。常用的几个异常类如图 1 所示。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/05/1-1P912101914246.jpg\" alt=\"img\" /><figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p style=\"font-weight: 900; text-align: center;\">\n图1：常用的异常类\n</p>\n<p>bad_typeid、bad_cast、bad_alloc、ios_base::failure、out_of_range 都是 exception 类的派生类。<mark>C++ 程序在碰到某些异常时，即使程序中没有写 throw 语句，也会自动拋出上述异常类的对象。这些异常类还都有名为 <code>what()</code> 的成员函数，返回字符串形式的异常描述信息。使用这些异常类需要包含头文件 <code>&lt;stdexcept&gt;</code> 。</mark></p>\n<p>下面分别介绍以上几个异常类。本节程序的输出以 Visual Studio 2010为准，Dev C++ 编译的程序输出有所不同。</p>\n<h2 id=\"bad_typeid\">1) bad_typeid</h2>\n<p>使用 typeid 运算符时，如果其操作数是一个多态类的<a href=\"http://c.biancheng.net/c/80/\">指针</a>，而该指针的值为 NULL，则会拋出此异常。</p>\n<h2 id=\"bad_cast\">2) bad_cast</h2>\n<p>在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常。程序示例如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdexcept&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span>&#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span> :</span> <span class=\"keyword\">public</span> Base&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:    </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Print</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintObj</span><span class=\"params\">(Base &amp; b)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    Derived &amp; rd = <span class=\"keyword\">dynamic_cast</span> &lt;Derived &amp;&gt;(b);</span><br><span class=\"line\">    rd.<span class=\"built_in\">Print</span>();    </span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">  <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (bad_cast &amp; e)&#123;</span><br><span class=\"line\">    cerr &lt;&lt; e.<span class=\"built_in\">what</span>() &lt;&lt; endl;    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  Base b;    </span><br><span class=\"line\">  <span class=\"built_in\">PrintObj</span>(b);    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序的输出结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Bad dynamic_cast!</span><br></pre></td></tr></table></figure>\n<p>在 PrintObj 函数中，通过 dynamic_cast 检测 b 是否引用的是一个 Derived 对象，如果是，就调用其 <code>Print()</code> 成员函数；如果不是，就拋出异常，不会调用 <code>Derived::Print</code>。</p>\n<h2 id=\"bad_alloc\">3) bad_alloc</h2>\n<p>在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常。程序示例如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdexcept&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;    </span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> * p = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">0x7fffffff</span>];</span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">  <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (bad_alloc &amp; e)&#123;</span><br><span class=\"line\">    cerr &lt;&lt; e.<span class=\"built_in\">what</span>() &lt;&lt; endl;    </span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序的输出结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">bad allocation</span><br><span class=\"line\">ios_base::failure</span><br></pre></td></tr></table></figure>\n<p>在默认状态下，输入输出流对象不会拋出此异常。如果用流对象的 exceptions 成员函数设置了一些标志位，则在出现打开文件出错、读到输入流的文件尾等情况时会拋出此异常。此处不再赘述。</p>\n<h2 id=\"out_of_range\">4) out_of_range</h2>\n<p>用 vector 或 string 的 at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdexcept&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;    </span><br><span class=\"line\">  <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">v</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    v.<span class=\"built_in\">at</span>(<span class=\"number\">100</span>) = <span class=\"number\">100</span>;</span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">  <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (out_of_range &amp; e) &#123;</span><br><span class=\"line\">    cerr &lt;&lt; e.<span class=\"built_in\">what</span>() &lt;&lt; endl;</span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">  string s = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c = s.<span class=\"built_in\">at</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">  <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (out_of_range &amp; e) &#123;</span><br><span class=\"line\">    cerr &lt;&lt; e.<span class=\"built_in\">what</span>() &lt;&lt; endl;    </span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序的输出结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">invalid vector subscript</span><br><span class=\"line\">invalid string position</span><br></pre></td></tr></table></figure>\n<p>如果将<code>v.at(100)</code>换成<code>v[100]</code>，将<code>s.at(100)</code>换成<code>s[100]</code>，程序就不会引发异常（但可能导致程序崩溃）。因为 at 成员函数会检测下标越界并拋出异常，而 <code>operator[]</code> 则不会。<code>operator[]</code> 相比 at 的好处就是不用判断下标是否越界，因此执行速度更快。</p>\n<p>​</p>\n","categories":["Programming"],"tags":["C++","trycatch","throw","VisualC++"]},{"title":"在linux上编写求解ADAU1772的PLL系数","url":"/2021/07/05/Programming/C++/2021-07-05-%E5%9C%A8linux%E4%B8%8A%E7%BC%96%E5%86%99%E6%B1%82%E8%A7%A3ADAU1772%E7%9A%84PLL%E7%B3%BB%E6%95%B0/","content":"<p>通过在Linux上编写代码，计算求解ADAU1772在 <strong>输入时钟</strong>（MCLK Input）为16.6MHz时，如何设置内部的4个参数，以达到符合输出时钟要求的目的。</p>\n<p>据《ADAU1772》和SigmaStudio，1772 Codec 内部可修改的参数有 <strong>输入时钟分频</strong>（Input Clock Divider）、<strong>整数设置</strong>（Integer Setting）、<strong>分子</strong>（Numerator） 和 <strong>分母</strong>（Denominator）四个。</p>\n<p><strong>目标输出时钟</strong>（VCO Output） 是 24.576MHz。</p>\n<h1 id=\"原公式\">原公式</h1>\n<p>以下为《ADAU1772》第30页中，关于PLL计算的公式描述：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210706002255187.png\" alt=\"image-20210706002255187\" /><figcaption aria-hidden=\"true\">image-20210706002255187</figcaption>\n</figure>\n<p>以下为SigmaStudio中的PLL设定界面参数设定：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210706002412136.png\" alt=\"image-20210706002412136\" /><figcaption aria-hidden=\"true\">image-20210706002412136</figcaption>\n</figure>\n<h1 id=\"代码编写\">代码编写</h1>\n<p>注意：本代码在Linux上，以C++17的版本进行编译运行。</p>\n<p>编译代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">g++ main.cpp -std=c++17 -lpthread</span><br></pre></td></tr></table></figure>\n<p>在编写代码时，考虑到SigmaStudio和数据手册之间可能存在表述差异，因此计算PLL的源代码中，也包含了开启 <code>1/2</code> 系数的宏定义 <code>#define HALFCOFF 1</code> ，具体代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*---------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * HEADER FILES</span></span><br><span class=\"line\"><span class=\"comment\"> *-------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"comment\">/*---------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * MACRO DEFINITION</span></span><br><span class=\"line\"><span class=\"comment\"> *-------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ACCURACY 1000000000   <span class=\"comment\">//输出时钟精度，小数点后9个0</span></span></span><br><span class=\"line\"><span class=\"comment\">// #define HALFCOFF 1            //打开1/2系数进行计算，SigmaStudio图示中有该系数，但《ADAU1772》数据手册中没有该系数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*---------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * MACRO DEFINITION FOR DEBUG</span></span><br><span class=\"line\"><span class=\"comment\"> *-------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"comment\">// #define DEBUG_MODE         //Debug模式</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*---------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * DATA TYPES</span></span><br><span class=\"line\"><span class=\"comment\"> *-------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">double</span> CLK;           <span class=\"comment\">//数据类型_时钟</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> COFF;  <span class=\"comment\">//数据类型_系数</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*---------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * FILE DOMAIN DATA DECLARATION</span></span><br><span class=\"line\"><span class=\"comment\"> *-------------------------------------------------------*/</span></span><br><span class=\"line\">CLK CLK_IN = <span class=\"number\">16.6</span>;            <span class=\"comment\">//输入时钟</span></span><br><span class=\"line\">CLK CLK_OUT = <span class=\"number\">24.576</span>;         <span class=\"comment\">//输出时钟</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TargetCofficient</span> &#123;</span></span><br><span class=\"line\">    COFF Numerator;</span><br><span class=\"line\">    COFF Denominator;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">COFF Maxiator = <span class=\"number\">65535</span>;</span><br><span class=\"line\">COFF InputClockDivider = <span class=\"number\">4</span>;</span><br><span class=\"line\">COFF IntegerSetting = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*---------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * FUNCTIONS DECLARATION</span></span><br><span class=\"line\"><span class=\"comment\"> *-------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isSafe</span><span class=\"params\">(COFF, COFF)</span></span>;      <span class=\"comment\">//判断系数的分子和分母相除是否满足要求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isOK</span><span class=\"params\">(CLK)</span></span>;               <span class=\"comment\">//判断输出结果是否符合输出时钟的精度要求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">CofficientCalculate</span><span class=\"params\">(CLK, COFF, COFF)</span></span>;         <span class=\"comment\">//计算</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ICD1</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;             <span class=\"comment\">//子线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ICD2</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;             <span class=\"comment\">//子线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ICD3</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;             <span class=\"comment\">//子线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ICD4</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;             <span class=\"comment\">//子线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SysPrintf</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*---------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * MAIN FUNCTIONS</span></span><br><span class=\"line\"><span class=\"comment\"> *-------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;SYSTEM: Procedure starts.&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"function\">thread <span class=\"title\">thread1</span><span class=\"params\">(ICD1)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">thread <span class=\"title\">thread2</span><span class=\"params\">(ICD2)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">thread <span class=\"title\">thread3</span><span class=\"params\">(ICD3)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">thread <span class=\"title\">thread4</span><span class=\"params\">(ICD4)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    thread1.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    thread2.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    thread3.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    thread4.<span class=\"built_in\">join</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;SYSTEM: Procedure ends up.&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*---------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * FUNCTIONS DEFINITION</span></span><br><span class=\"line\"><span class=\"comment\"> *-------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isSafe</span><span class=\"params\">(COFF N, COFF D)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> result = (<span class=\"keyword\">double</span>)N / (<span class=\"keyword\">double</span>)D;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( (result &gt;= <span class=\"number\">0.1</span>) &amp;&amp; (result &lt;= <span class=\"number\">0.9</span>) ) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;       <span class=\"comment\">//判断系数是否满足要求，满足则返回1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isOK</span><span class=\"params\">(CLK clock)</span></span>&#123;</span><br><span class=\"line\">    CLK integerClock , fractClock;</span><br><span class=\"line\">    fractClock = <span class=\"built_in\">modf</span>(clock , &amp;integerClock);                <span class=\"comment\">//分别取出整数和小数部分</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>( ((<span class=\"keyword\">int</span>)(fractClock * ACCURACY) == (<span class=\"keyword\">int</span>)(<span class=\"number\">576</span>/(<span class=\"keyword\">double</span>)<span class=\"number\">1000</span> * ACCURACY)) &amp;&amp; ((<span class=\"keyword\">int</span>)integerClock == (<span class=\"keyword\">int</span>)CLK_OUT) ) &#123;  <span class=\"comment\">//如果小数点精度满足要求，且整数部分相同</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;                                           <span class=\"comment\">//则返回1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">CofficientCalculate</span><span class=\"params\">(CLK ClockInput, COFF ICD, COFF IS)</span></span>&#123;</span><br><span class=\"line\">    CLK tempCLK;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(COFF i = <span class=\"number\">0</span>; i &lt; Maxiator; i++)&#123;                     <span class=\"comment\">//分母</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(COFF j = <span class=\"number\">0</span>; j &lt; Maxiator; j++)&#123;                 <span class=\"comment\">//分子</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">isSafe</span>(j, i))&#123;</span><br><span class=\"line\">                <span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> HALFCOFF</span></span><br><span class=\"line\">                tempCLK = ClockInput /(<span class=\"keyword\">double</span>)ICD * ((<span class=\"keyword\">double</span>)IS + ((<span class=\"keyword\">double</span>)j/(<span class=\"keyword\">double</span>)i)) *<span class=\"number\">1</span>/<span class=\"number\">2</span>;   <span class=\"comment\">//有系数时</span></span><br><span class=\"line\">                <span class=\"meta\">#<span class=\"meta-keyword\">else</span> </span></span><br><span class=\"line\">                tempCLK = ClockInput /(<span class=\"keyword\">double</span>)ICD * ((<span class=\"keyword\">double</span>)IS + ((<span class=\"keyword\">double</span>)j/(<span class=\"keyword\">double</span>)i)) ;       <span class=\"comment\">//无系数时</span></span><br><span class=\"line\">                <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> DEBUG_MODE</span></span><br><span class=\"line\">                cout &lt;&lt; <span class=\"string\">&quot;SYSTEM:IDC = &quot;</span> &lt;&lt; ICD &lt;&lt; <span class=\"string\">&quot;, IS = &quot;</span> &lt;&lt; IS &lt;&lt; hex &lt;&lt;<span class=\"string\">&quot;, Numerator = 0x&quot;</span>&lt;&lt; j &lt;&lt; <span class=\"string\">&quot;, Denominator = 0x&quot;</span> &lt;&lt; i &lt;&lt; <span class=\"string\">&quot;, OutputClock = &quot;</span> &lt;&lt; tempCLK &lt;&lt; endl;</span><br><span class=\"line\">                <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>( <span class=\"built_in\">isOK</span>(tempCLK)) &#123;</span><br><span class=\"line\">                cout &lt;&lt; <span class=\"string\">&quot;SYSTEM:IDC = &quot;</span> &lt;&lt; ICD &lt;&lt; <span class=\"string\">&quot;, IS = &quot;</span> &lt;&lt; IS &lt;&lt; hex &lt;&lt;<span class=\"string\">&quot;, Numerator = 0x&quot;</span>&lt;&lt; j &lt;&lt; <span class=\"string\">&quot;, Denominator = 0x&quot;</span> &lt;&lt; i &lt;&lt; <span class=\"string\">&quot;, OutputClock = &quot;</span> &lt;&lt; tempCLK &lt;&lt; endl;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*---------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * THREAD _ CALCULATOR</span></span><br><span class=\"line\"><span class=\"comment\"> *-------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ICD1</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(COFF enumIS = <span class=\"number\">2</span>; enumIS &lt;= IntegerSetting; enumIS++) <span class=\"built_in\">CofficientCalculate</span>(CLK_IN , <span class=\"number\">1</span>, enumIS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ICD2</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(COFF enumIS = <span class=\"number\">2</span>; enumIS &lt;= IntegerSetting; enumIS++) <span class=\"built_in\">CofficientCalculate</span>(CLK_IN , <span class=\"number\">2</span>, enumIS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ICD3</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(COFF enumIS = <span class=\"number\">2</span>; enumIS &lt;= IntegerSetting; enumIS++) <span class=\"built_in\">CofficientCalculate</span>(CLK_IN , <span class=\"number\">3</span>, enumIS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ICD4</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(COFF enumIS = <span class=\"number\">2</span>; enumIS &lt;= IntegerSetting; enumIS++) <span class=\"built_in\">CofficientCalculate</span>(CLK_IN , <span class=\"number\">4</span>, enumIS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SysPrintf</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// while(1) cout &lt;&lt; &quot;Calculating...&quot;;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Calculating...&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\003&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"运行结果\">运行结果</h1>\n<p>通过自行编写的代码，遍历所有可更改的系数进行计算求解，取得小数点后9位精度，并且符合要求的系数如下（含1/2系数）：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210706001243698.png\" alt=\"image-20210706001243698\" /><figcaption aria-hidden=\"true\">image-20210706001243698</figcaption>\n</figure>\n<p>以下为不含1/2系数的结果：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/07/image-20210706001350802.png\" alt=\"image-20210706001350802\" /><figcaption aria-hidden=\"true\">image-20210706001350802</figcaption>\n</figure>\n<p>经过手工计算，结果（小数点后9位）确实满足要求。</p>\n","categories":["Programming"],"tags":["ADI","Linux","1772","cofficient"]},{"title":"Linux上C++多线程报错解决办法","url":"/2021/07/06/Programming/C++/2021-07-06-Linux%E4%B8%8AC++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","content":"<h1 id=\"pthread报错\">pthread报错</h1>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> namespce std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;hello concurent world!&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * argv[])</span></span>&#123;</span><br><span class=\"line\"><span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(hello)</span></span>;</span><br><span class=\"line\">t.<span class=\"built_in\">join</span>();</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个小例子直接用make编译是无法通过的。报错如下： <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/tmp/ccYB66pt.o：在函数‘std::thread::thread&lt;void (&amp;)()&gt;(void (&amp;)())’中：</span><br><span class=\"line\">1-1.cpp:(.text._ZNSt6threadC2IRFvvEJEEEOT_DpOT0_[_ZNSt6threadC5IRFvvEJEEEOT_DpOT0_]+0x21)：对‘pthread_create’未定义的引用</span><br><span class=\"line\">collect2: 错误：ld 返回 1</span><br><span class=\"line\">&lt;<span class=\"built_in\">builtin</span>&gt;: recipe <span class=\"keyword\">for</span> target <span class=\"string\">&#x27;1-1&#x27;</span> failed</span><br><span class=\"line\">make: *** [1-1] Error 1</span><br></pre></td></tr></table></figure></p>\n<p>解决方法是在编译的时候加上 <code>-lpthread</code> 参数。这个类用到posix实现的线程了。 <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">g++ -o <span class=\"built_in\">test</span> test.cpp -lpthread</span><br><span class=\"line\">./<span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure></p>\n<p>结果输出： <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hello concurent world!</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li><a href=\"https://blog.csdn.net/wuhui20091515/article/details/52531202\">c++使用thread类时编译出错，对‘pthread_create’未定义的引用</a></li>\n</ol>\n","categories":["Programming"],"tags":["Linux","C++","error"]},{"title":"C++ Templates","url":"/2021/10/05/Programming/C++/2021-10-05-C++-Templates/","content":"<h1 id=\"part-1-the-basics\">PART 1 THE BASICS</h1>\n<div style=\"background-color: #555; color: #eeeeee; font-weight: 900;\">\nWHY TEMPLATES?\n</div>\n<p>C++ 要求我们使用指定的类型来声明变量、函数 和 大部分其他实体。然而，很多代码对于不同的类型看起来都是一样的。比如，对于不同的数据结构，如 <code>int</code> 数组或 <code>string</code> 字符串向量，只要包含的类型可以相互比较，快速排序算法的实现在结构上看起来是一样的。</p>\n<p>如果使用的编程语言不支持 <strong>通用性</strong>（genericity）的 <strong>特殊语言功能</strong>（special language feature），将不得不面临如下选择，坏的选择（bad alternatives）：</p>\n<ul>\n<li>你可以为不同的数据类型一遍又一遍地进行着相同的行为声明；</li>\n<li>你可以为常见的基本类型（common base type）编写一段代码，例如 <code>object</code> 或 <code>void*</code> ；</li>\n<li>你可以使用特殊的预处理器。</li>\n</ul>\n<p>如果使用其他语言，可能以前就做过一些或者所有上方所述的内容了。然而，这些方法的每一种都有其缺点：</p>\n<ul>\n<li>如果你一遍又一遍地实现着这些行为，毫无疑问是叠矩重规（reinvent the wheel）。你犯了相同的错误，并且你试图寻找避免复杂但能更好的算法，因为它们会制造出更多的错误。</li>\n<li>如果你为常见基本类编写代码，你会失去类型检查的好处。另外，类可能要求继承于（be derived from）能够使代码更加难以维护的特殊基础类。</li>\n<li>如果你使用特殊的预处理器，代码会被一些没有 <strong>作用范围</strong>（scope）和类型且能够造成 <strong>奇怪语义错误</strong>（strange semantic errors）的 ”愚蠢的文本替换机制“ 替代掉。</li>\n</ul>\n<p>模板是能够解决重复代码编写问题且不会造成上述这些短板的方案。模板是为一种或更多尚未声明类型的函数或者类。当使用模板时，可以隐式或显式地将类型当做参数传递过去。因为模板是语言的特点，可以拥有全部的类型检查和作用范围的支持（full support of type checking and scope）。</p>\n<p>在C++标准库中，几乎所有的代码都是模板代码。该库提供排序算法以对 对象、指定类型的值、数据结构（也叫做 <strong>容器类</strong>（Container Classes）） 进行排序，以管理指定类型的元素 和 字符串（被参数化的字符串类型）等等。</p>\n<p>然而，以上仅是模板的使用入门，模板还允许 <strong>参数化行为</strong>（parameterize behavior） 以 <strong>优化代码</strong>（optimize code） 和 <strong>参数化信息</strong>（parameterize infomation）。</p>\n<h2 id=\"function-templates\">FUNCTION TEMPLATES</h2>\n<p><strong>函数模板</strong>（function templates），即 <strong>参数化的函数</strong>（functions that are parameterized），因此代表了 <strong>一个函数系列</strong>（a family of functions）。</p>\n<p>函数模板为不同的数据类型提供了相同的功能行为调用，或换句话说，代表了一个函数系列。该函数系列看起来就像个普通函数，除了函数的某些元素未被确定，因为这些元素被参数化了。</p>\n<h3 id=\"templates-delaration-and-definition\">TEMPLATES DELARATION AND DEFINITION</h3>\n<div style=\"background-color: #555; color: #eeeeee; font-size: 1.25rem; font-weight: 900;\">\nEXAMPLE\n</div>\n<p>以下样例 <strong>声明</strong> 了一个函数系列，且下面参数的类型被空置（is left open），如参数 <code>T</code> ，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">max</span><span class=\"params\">(T a, T b)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// if b &lt; a then yield a else yield b</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> b &lt; a ? a : b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述样例中，模板参数必须使用 <code>template &lt;comma-separated-list-of-parameters&gt;</code> 的格式进行声明。</p>\n<p>此处的关键字 <code>typename</code> 代表着类型参数，这是迄今为止C++程序中最常见的一种模板参数，当然其他参数也可以，后续介绍。此处的类型参数是 <code>T</code> ，可以使用任意标识符当做参数名称，但使用 <code>T</code> 就是惯例而已。类型参数代表着 <strong>任意类型</strong>（arbitrary type），当函数调用时，由调用的函数决定具体数据类型。开发者可以调用任何类型，只要其提供模板使用的操作。</p>\n<p>在上述样例中，类型 <code>T</code> 必须支持 <strong>操作符</strong>（operator） <code>&lt;</code> ，因为 <code>a</code> 和 <code>b</code> 使用该操作符进行比较，也许在 <code>max()</code> 的定义中很难发现，但要说明的是，<code>T</code> 类型必须是可复制的才能够被返回（T must be copyable in order to be returned）。</p>\n<p>由于历史遗留原因，仍可以使用关键词 <code>class</code> 来定义类型参数。<code>typename</code> 关键字是在 C++98 标准之后才出现的，在那之前，<code>class</code> 是引入类型参数的唯一方法，至今仍可以使用。因此，上述模板也可以用下面的代码平替（在语义上没有区别）。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">temelate&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\">  <span class=\"function\">T <span class=\"title\">max</span><span class=\"params\">(T a, T b)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> b&lt;a?a:b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但因为 <code>class</code> 也是 <strong>类</strong> 的关键字，可能导致二义性，最好在声明模板时使用关键字 <code>typename</code> 。需要注意的是，与类声明不同，当声明类型参数时，关键字 <code>struct</code> 不能用来代替 <code>typename</code> 。</p>\n<p>在C++17之前，类型 <code>T</code> 也必须是可复制的，以确保能够传递参数。但C++17之后，可以传递临时数（temporary），即使没有一个备份或者一个构造器可用（even if neither a copy nor a move constructor is valid）。</p>\n<div style=\"background-color: #555; color: #eeeeee; font-weight: 900;\">\n如何编写多个函数模板，需要注意什么？\n</div>\n<p>同一个文件内可以编写多个不同的模板函数，如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">Max</span><span class=\"params\">(T a, T b)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b&lt;a?a:b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> t2&gt;</span><br><span class=\"line\"><span class=\"function\">t2 <span class=\"title\">foo</span><span class=\"params\">(t2*)</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面两个模板函数就在同一个文件下，<code>typename</code> 关键字后面的 <code>T</code> 或者 <code>t2</code> 需要具有唯一性。</p>\n<h3 id=\"using-templates\">USING TEMPLATES</h3>\n<p>需要注意的是，在使用该函数模板时，要在该函数前加上双冒号 <code>::</code> ，以确保函数模板能够在全局命名空间中被查找到。如果出现下方的 <code>call to ’sth.’ is ambiguous</code> 错误， 即是说需要调用的函数模糊不清，因为标准库中也有一个 <code>std::max()</code>，编译器查找不到该函数具体是在哪个函数文件中。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/image-20211005171952999.png\" alt=\"image-20211005171952999\" /><figcaption aria-hidden=\"true\">image-20211005171952999</figcaption>\n</figure>\n<p>当然，以上错误也可以通过写不同的函数名称来避免。</p>\n<p><mark style=\"font-weight: 900;\">模板并不是被编译成一个可以处理所有数据类型的实体，而是被编译成了所有不同数据类型的实体。</mark> 即，<code>int max()</code>、 <code>short max()</code> 、<code>string max()</code> 等等。单实体多适应 的模板虽然好像可行，但是实际上并不存在。所有的语言规则都遵循 ” <strong>不同的模板参数生成不同的实体</strong>“ 的原则。</p>\n<p>上面这种用具体类型取代模板参数的过程被称为 <strong>实体化</strong>（instantiation）。需要注意的是，仅仅是对函数模板的使用就可以触发该实体化过程，因此开发者就没有必要要求实体化过程单独进行（request the instantiation separately）。</p>\n<p>另外，只要产生的代码是有效的，<code>void</code> 型也是可用的模板参数，例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">foo</span><span class=\"params\">(T*)</span></span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span>* vp = <span class=\"literal\">nullptr</span>;  <span class=\"comment\">// 引出 void foo(void*)</span></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">void</span></span>(vp);</span><br></pre></td></tr></table></figure>\n<h3 id=\"two-phase-translation\">TWO-PHASE TRANSLATION</h3>\n<p><strong>两段式编译</strong>，即Two-phase translation。</p>\n<p>如果试图为一个不支持所有操作的模板进行实例化，将会导致编译时错误。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::complex&lt;<span class=\"keyword\">float</span>&gt; c1, c2;  <span class=\"comment\">//doesn&#x27;t provide operator &lt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">::<span class=\"built_in\">max</span>(c1, c2);  <span class=\"comment\">//ERROR at compile time</span></span><br></pre></td></tr></table></figure>\n<p>因此，模板在被编译时会经过如下两个阶段：</p>\n<ol type=\"1\">\n<li>在定义且没有实例化时，忽略模板参数来检查自身代码的正确性：\n<ul>\n<li>标点符号错误被发现，例如缺少分号 <code>;</code> ；</li>\n<li>使用不依赖已知模板参数的未知命名（类型名，函数名等）；</li>\n<li>不依赖于已检查模板参数的 <strong>静态断言</strong>（static assertions）</li>\n</ul></li>\n<li>在实例化时，模板代码会被再次检查以确保可用，特别是依赖于模板参数的都会被二次检查（double-checked），例如：</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(T t)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">undeclared</span>();</span><br><span class=\"line\">  <span class=\"built_in\">undeclared</span>(t);</span><br><span class=\"line\">  <span class=\"built_in\"><span class=\"keyword\">static_assert</span></span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">int</span>&gt;<span class=\"number\">10</span>, <span class=\"string\">&quot;int too small&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\"><span class=\"keyword\">static_assert</span></span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(T&gt;<span class=\"number\">10</span>, <span class=\"string\">&quot;T too small&quot;</span>);         </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意到某些编译器在第一阶段没有进行全面检查（don’t perform the full checks），所以直到在最后一阶段的模板代码实例化之前都没办法看到问题。</p>\n<div style=\"background-color: #555; color: #eeeeee; font-weight: 900;\">\nCOMPILE AND LINK\n</div>\n<p>在实际处理模板时，两段式编译会导致很多重要的问题：当函数模板被用于触发其实例化时，编译器（在某些点）需要查看模板定义。当一个函数的声明足以编译它时，就打破了普通函数通常的编译和连接的区别。</p>\n<h3 id=\"template-argument-deduction\">TEMPLATE ARGUMENT DEDUCTION</h3>\n<p><strong>模板实参推断</strong>，即 Template argument deduction。</p>\n<p>当给函数模板传递实参时，模板参数由我们传递过去的实参决定。如果传递的是两个 <code>int</code> 型实参给 参数类型 <code>T</code> ，则C++编译器就能推断出此时的 <code>T</code> 一定是 <code>int</code> 。</p>\n<p>然而 <code>T</code> 可能只是该参数类型的一部分。例如，声明 <code>max()</code> 可以使用 <strong>常参</strong>（constant references）。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">max</span><span class=\"params\">(T <span class=\"keyword\">const</span>&amp; a, T <span class=\"keyword\">const</span>&amp; b)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> b&lt;a?a:b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上方代码所示，传递 整型 <code>int</code> 参数，<code>T</code> 又会被推断为 <code>int</code> ，因为函数参数和 <code>int const&amp;</code> 匹配。</p>\n<h4 id=\"类型推导过程中的类型转换\">类型推导过程中的类型转换</h4>\n<p>注意，自动类型转换被限制在类型推导期间：</p>\n<ul>\n<li><strong>引用传递</strong>：当通过引用声明来调用参数（declaring call parameters by reference）时，即使是 微不足道的转换（trivial conersion） 也不适用于类型推导。用同一个模板参数 <code>T</code> 声明的两个参数类型必须完全匹配。</li>\n<li><strong>按值传递</strong>：当按数值声明调用参数时，只支持 <code>decay</code> 的琐碎转换。带有const或volatile的限定被忽略，引用转换为被引用的类型，而原始数组或函数转换为相应的指针类型。对于用同一模板参数T声明的两个参数，<code>decayed</code> 的类型必须匹配。</li>\n</ul>\n<p><strong>错误提示</strong>：对int类型的非恒定值引用不能与int类型的临时值绑定</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/11/image-20211007035818560.png\" alt=\"image-20211007035818560\" /><figcaption aria-hidden=\"true\">image-20211007035818560</figcaption>\n</figure>\n<p>前方已经说了，类型的自动转换相关注意事项，同一模板参数的两个参数类型必须完全匹配。如果在同一个 <code>.cpp</code> 文件中书写下面下面代码，则会出现下方报错提示 “<strong>推导类型冲突</strong>（deduced conflicting types for parameter ’T’）”。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Max</span>(<span class=\"number\">4</span>, <span class=\"number\">7.2</span>);</span><br><span class=\"line\"><span class=\"built_in\">Max</span>(<span class=\"string\">&quot;Hello&quot;</span>,s);</span><br></pre></td></tr></table></figure>\n<p>错误提示如下：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/image-20211007040416472.png\" alt=\"image-20211007040416472\" /><figcaption aria-hidden=\"true\">image-20211007040416472</figcaption>\n</figure>\n<p>但是如果非要使用不一样的数据类型的两个参数来套用同一模板，以下有三种解决方法：</p>\n<ol type=\"1\">\n<li>在 <code>.cpp</code> 文件中进行参数传递时，使用参数类型强制转换。如 <code>Max(static_cast&lt;double&gt;(4), 7.2);</code> 。</li>\n<li>在</li>\n</ol>\n<h1 id=\"terminology\">TERMINOLOGY</h1>\n<ol type=\"1\">\n<li>按值传递 passing by value</li>\n<li>引用传递 passing by reference</li>\n</ol>\n<h1 id=\"reference\">REFERENCE</h1>\n<ol type=\"1\">\n<li>&lt;C++ Templates&gt; David Vandecoorde</li>\n</ol>\n","categories":["Programming"],"tags":["C++","Templates"]},{"title":"C++头文件和编译","url":"/2021/10/12/Programming/C++/2021-10-12-C++%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C%E7%BC%96%E8%AF%91/","content":"<h1 id=\"hpp头文件\">HPP头文件</h1>\n<p><code>.hpp</code>，其实质就是将 <code>.cpp</code> 的实现代码混入 <code>.h</code> 头文件当中，定义与实现都包含在同一文件，则该类的使用只需要调用 <code>#include&lt;xxx.hpp&gt;</code> 以引用该文件即可，无需再将 <code>.cpp</code> 加入到project中进行编译。</p>\n<p>而实现代码将直接编译到调用者的 <code>.obj</code> 文件中，不再生成单独的 <code>.obj</code>，采用 <code>.hpp</code> 将大幅度减少调用 project中的 <code>.cpp</code> 文件数与编译次数，也不用再发布烦人的 <code>.lib</code> 与 <code>.dll</code> 文件，因此非常适合用来编写公用的开源库。</p>\n<h2 id=\"使用注意\">使用注意</h2>\n<p><code>.hpp</code> 头文件的优点不少，但是编写中有以下几点要注意：</p>\n<ol type=\"1\">\n<li><p>与 <code>.h</code> 类似，但 <code>.hpp</code> 是 <strong>Header Plus Plus</strong> 的简写，是 C++程序头文件 。</p></li>\n<li><p>是<a href=\"http://www.huarw.com/program/vc/Index.html\">VC</a>L专用的头文件，已预编译。</p></li>\n<li><p>是一般 <strong>模板类</strong> 的头文件。</p></li>\n<li><p>一般来说，<code>.h</code> 里面只有声明，没有实现，而 <code>.hpp</code> 里声明实现都有，后者可以减少 <code>.cpp</code> 的数量。</p></li>\n<li><p><code>.h</code> 里面可以有 <code>using namespace std;</code>，而 <code>.hpp</code> 里则无。</p></li>\n<li><p>不可包含 <strong>全局对象</strong> 和 <strong>全局函数</strong> 。由于 <code>.hpp</code> 本质上是作为 <code>.h</code> 被调用者所include，所以当 <code>.hpp</code> 文件中存在全局对象或者全局函数，而该 <code>.hpp</code> 被多个调用者include时，<mark>将在链接时导致符号重定义错误</mark>。<mark>要避免这种情况，需要去除全局对象，将全局函数封装为类的静态方法</mark>。</p></li>\n<li><p><strong>类之间不可循环调用</strong></p></li>\n</ol>\n<p>在.h和.cpp的场景中，当两个类或者多个类之间有循环调用关系时，只要预先在头文件做被调用类的声明即可，如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">someMethod</span><span class=\"params\">(B b)</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> :</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">someMethod</span><span class=\"params\">(A a)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在 <code>.hpp</code> 场景中，由于定义与实现都已经存在于一个文件，调用者必需明确知道被调用者的所有定义，而不能等到 <code>.cpp</code> 中去编译。因此hpp中必须整理类之间调用关系，不可产生循环调用。同理，对于当两个类A和B分别定义在各自的 <code>.hpp</code> 文件中，形如以下的循环调用也将导致编译错误：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//a.hpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;b.hpp&quot;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> :</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">someMethod</span><span class=\"params\">(B b)</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//b.hpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;a.hpp&quot;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> :</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">someMethod</span><span class=\"params\">(A a)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"9\" type=\"1\">\n<li><strong>不可使用静态成员</strong></li>\n</ol>\n<p>静态成员的使用限制在于如果类含有静态成员，则在 <code>.hpp</code> 中必需加入静态成员初始化代码，当该 <code>.hpp</code> 被多个文档include时，将产生符号重定义错误。唯一的例外是 <code>const static</code> 整型成员，因为在vs2003中，该类型允许在定义时初始化，如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> intValue = <span class=\"number\">123</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>由于静态成员的使用是很常见的场景，无法强制清除，因此可以考虑以下几种方式（以下示例均为同一类中方法）</p>\n<ol type=\"1\">\n<li>类中仅有一个静态成员时，且仅有一个调用者时，可以通过 <strong>局域静态变量模拟</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方法模拟获取静态成员</span></span><br><span class=\"line\"><span class=\"function\">someType <span class=\"title\">getMember</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> someType <span class=\"title\">value</span><span class=\"params\">(xxx)</span></span>;<span class=\"comment\">//作用域内静态变量</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\" type=\"1\">\n<li>类中有多个方法需要调用静态成员，而且可能存在多个静态成员时，<mark style=\"font-weight: 900;\">可以将每个静态成员封装一个模拟方法，供其他方法调用</mark>。</li>\n</ol>\n<p><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">someType <span class=\"title\">getMemberA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> someType <span class=\"title\">value</span><span class=\"params\">(xxx)</span></span>;<span class=\"comment\">//作用域内静态变量</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">someType <span class=\"title\">getMemberB</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> someType <span class=\"title\">value</span><span class=\"params\">(xxx)</span></span>;<span class=\"comment\">//作用域内静态变量</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">accessMemberA</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    someType member = <span class=\"built_in\">getMemberA</span>();<span class=\"comment\">//获取静态成员</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取两个静态成员</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">accessStaticMember</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    someType a = <span class=\"built_in\">getMemberA</span>();<span class=\"comment\">//获取静态成员</span></span><br><span class=\"line\">    someType b = <span class=\"built_in\">getMemberB</span>();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\" type=\"1\">\n<li>第二种方法对于大部分情况是通用的，但是当所需的静态成员过多时，编写封装方法的工作量将非常巨大，在此种情况下，建议使用 <strong>Singleton模式</strong>，将被调用类定义成普通类，然后使用Singleton将其变为全局唯一的对象进行调用。</li>\n</ol>\n<p>如原 <code>.h</code> 和 <code>.cpp</code> 中的定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> :</span><br><span class=\"line\">    <span class=\"function\">type <span class=\"title\">getMember</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> member;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> type member;<span class=\"comment\">//静态成员</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>采用singleton方式，实现代码可能如下（singleton实现请自行查阅相关文档）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//实际实现类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Aprovider</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> :</span><br><span class=\"line\">    <span class=\"function\">type <span class=\"title\">getMember</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> member;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    type member;<span class=\"comment\">//变为普通成员</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//提供给调用者的接口类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> :</span><br><span class=\"line\">    <span class=\"function\">type <span class=\"title\">getMember</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> Singleton&lt;AProvider &gt;::<span class=\"built_in\">getInstance</span>()-&gt;<span class=\"built_in\">getMember</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"分离式编译\">分离式编译</h1>\n<p>在介绍分离式编译之前需要先介绍一下 <strong>分离式代码</strong>，在C++代码中，声明和定义是可以分开写在多个文件中，当然也可以写在同一个文件里面的，如 <code>.hpp</code> 。</p>\n<p>往往是为了逻辑条理的清晰而分开书写，但使用 g++ 和 Terminal 直接编译 <code>main.cpp</code> 时，都是使用的 <code>g++ main.cpp -o main</code> 的命令，也就是只能编译该 <code>main.cpp</code> 一个文件，以生成 <code>main</code> 为名的二进制可运行文件，实际上，书写在其他 <code>.cpp</code> 文件中的代码也需要一同编译，这些书写在其他 <code>.cpp</code> 文件中的代码被称为 <strong>分离式代码</strong>，只编译 <code>main.cpp</code> 就会出现 <code>undefined reference</code> 之类的错误。</p>\n<h2 id=\"命令行g\">命令行G++</h2>\n<p>在 Windows / Linux / Mac 的 Terminal 下都可以使用 <code>g++</code> 命令进行编译，格式如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">g++ -c main.cpp xxx1.cpp xxx2.cpp</span><br></pre></td></tr></table></figure>\n<p>使用 <code>-c</code> 选项，将包含 <code>main()</code> 的 <code>main.cpp</code> 与 其他分离式代码文件 <code>xxx1.cpp</code> 和 <code>xxx2.cpp</code> 一同编译，然后生成一个个对象文件（ <code>.o</code> 或 <code>.obj</code> ）。上面这种方法会生成三个文件 <code>main.o</code> 、<code>xxx1.o</code> 和 <code>xxx2.o</code> ，每个 <code>.o</code> 都是一个对象文件，但不一定可执行（因为缺少 <code>main()</code> 函数），仍需要通过进一步 <strong>链接</strong> 成可执行文件：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">g++ -o main main.o xxx1.o xxx2.o</span><br></pre></td></tr></table></figure>\n<p>通过上面这一行代码可以生成名为 <code>main</code> 的可执行二进制文件。</p>\n<p>以上两句命令也可以通过下面这句命令替代：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">g++ -o main main.cpp xxx1.cpp xxx2.cpp</span><br></pre></td></tr></table></figure>\n<h2 id=\"makefile\">Makefile</h2>\n<p>Makefile 文件描述了 Linux 系统下 C/C++ 工程的编译规则，它用来自动化编译 C/C++ 项目。一旦写编写好 Makefile 文件，只需要一个 make 命令，整个工程就开始自动编译，不再需要手动执行 GCC 命令。</p>\n<p>一个中大型 C/C++ 工程的源文件有成百上千个，它们按照功能、模块、类型分别放在不同的目录中，Makefile 文件定义了一系列规则，指明了源文件的编译顺序、依赖关系、是否需要重新编译等。</p>\n<p>如果是在 Windows 下作开发的话不需要去考虑这个问题，因为 Windows 下的集成开发环境（IDE）。当然，Windows 下的 Visual Studio Code如果没配置好，也只是个编辑器而已，不算是个IDE。一般的MVS（Microsoft Visual Studio）都已经内置了 Makefile，或者说会自动生成 Makefile，不用去手动编写。</p>\n<p>Linux 中却不能这样，需要去手动的完成这项工作。Linux 下可以学习的开发语言有很多，常见的有 C/C++语言、python、java 等等。在 Linux(Unix) 下做开发的话，不了解 Makefile 是一件非常失败的事情。不懂 Makefile，就操作不了多文件编程，就完成不了相对于大的工程项目的操作。Makefile 可以说是必须掌握的一项技能。</p>\n<p>Makefile 可以简单的认为是一个工程文件的编译规则，描述了整个工程的 <strong>编译</strong> 和 <strong>链接</strong> 等规则。其中包含了那些文件需要编译，那些文件不需要编译，那些文件需要 <strong>先编译</strong>，那些文件需要 <strong>后编译</strong>，那些文件需要 <strong>重建</strong> 等等。编译整个工程需要涉及到的，在 Makefile 中都可以进行描述。换句话说，<mark style=\"font-weight: 900;\">Makefile 可以使得我们的项目工程的编译变得自动化，不需要每次都手动输入一堆源文件和参数。</mark></p>\n<p>Makefile 可以彻底简化编译的操作。把要链接的库文件放在 Makefile 中，制定相应的规则和对应的链接顺序。这样只需要执行 make 命令，工程就会自动编译。每次想要编译工程的时候就执行 <code>make</code> 命令，省略掉手动编译中的参数选项和命令，非常的方便。</p>\n<p>Makefile 支持多线程并发操作，会极大的缩短编译时间，并且当修改了源文件之后，编译整个工程的时候，make 命令只会编译修改过的文件，没有修改的文件不用重新编译，也极大的解决了耗费时间的问题。</p>\n<h3 id=\"makefile-格式\">Makefile 格式</h3>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211012135030.png\" alt=\"image-20211012134610578\" /><figcaption aria-hidden=\"true\">image-20211012134610578</figcaption>\n</figure>\n<blockquote>\n<ul>\n<li>targets：规则的目标，可以是 Object File（一般称它为中间文件），也可以是可执行文件，还可以是一个标签；</li>\n<li>prerequisites：是我们的依赖文件，要生成 targets 需要的文件或者是目标。可以是多个，也可以是没有；</li>\n<li>command：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>注意：我们的 <strong>目标</strong>（target） 和 <strong>依赖文件</strong>（prerequisite） 之间要使用 <strong>冒号</strong> <code>:</code> 分隔开，<strong>命令的开始</strong>（before the command） 一定要使用 <code>Tab</code> 键。</p>\n</blockquote>\n<h1 id=\"reference\">Reference</h1>\n<ol type=\"1\">\n<li><a href=\"https://blog.csdn.net/liuzhanchen1987/article/details/7270005\">hpp.h与.h的区别</a></li>\n<li><a href=\"http://c.biancheng.net/makefile/\">Makefile教程：Makefile文件编写1天入门 (biancheng.net)</a></li>\n</ol>\n","categories":["Programming"],"tags":["hpp","h","c++","compiler","makefile"]},{"title":"C++ Primer Plus 学习笔记","url":"/2021/10/27/Programming/C++/2021-10-27-C++-Primer-Plus-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"<p>本笔记不是全面的C++学习笔记，而是基于个人在原有的C语言基础和浅薄的C++的开发经验上的补足笔记。</p>\n<p>本笔记仅供个人学习记录，不提供完整学习指导，如有需要请自行阅读《<a href=\"https://storage.islet.space/01_Learning/02_CPP/C%2B%2B_Primer_Plus.pdf\">C++ Primer Plus</a>》。</p>\n<p>本文会参考 GNU C++ 进行代码调试，部分文档内容会参考 MS C++ 进行理解。</p>\n<h1 id=\"简介\">简介</h1>\n<p>C++融合了三种不同的编程方式：</p>\n<ul>\n<li>面向过程编程（继承于C）</li>\n<li>面向对象编程</li>\n<li>泛型编程（Generic Programming），即C++模板（Template）</li>\n</ul>\n<h2 id=\"过程-vs-对象\">过程 VS 对象</h2>\n<p><strong>面向过程编程</strong>（Process Oriented Programming），即 <strong>结构化编程</strong> 或 <strong>过程结构化编程</strong>，是指根据执行的操作来构思一个程序。程序任务需要解决的问题按照 “1、2、3、4” 这样的顺序一一编写，如果程序任务过大，则将较大的任务拆解成较小的可以理清结构逻辑的小任务去完成。C语言的编程开发思路就是使用程序模块（函数）来表示各个任务模块。</p>\n<p><strong>面向对象编程</strong>（Object Oriented Programming），简称 OOP。</p>\n<p>结构化编程在程序逻辑的清晰度和可靠性上占据优势，但是在代码量上和面向对象相比不占优势</p>\n<blockquote>\n<p>为了应付代码量的挑战，与强调算法的过程性编程不同，OOP强调数据。过程性编程试图使问题满足语言要求，OOP则是使语言满足问题的要求。</p>\n</blockquote>\n<p><strong>类</strong>（Class） 是规定了 <strong>数据</strong> 和 <strong>操作</strong> 的 <strong>数据类型</strong>（Data Type）。类所创建的实体称为对象。</p>\n<blockquote>\n<p>OOP 强调的是编程的数据方面，GP编程强调的是 <mark style=\"font-weight: 900;\">独立于特定数据类型</mark>，即强调 <strong>通用</strong> 和 <strong>非特定</strong> 类型。</p>\n</blockquote>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211030171646.png\" alt=\"image-20211027135117490\" /><figcaption aria-hidden=\"true\">image-20211027135117490</figcaption>\n</figure>\n<h2 id=\"系统的位数\">系统的位数</h2>\n<ul>\n<li>系统的位数是由什么决定的？包括嵌入式系统的8位、16位、32位和通用系统的32位和64位？</li>\n</ul>\n<p>位数 是由CPU的最大寻址空间决定的。</p>\n<h1 id=\"new-features-in-c\">New Features in C++</h1>\n<p>以下主要从C++和C的区别点进行记录，是个人之前从未掌握过的知识，另外也会记录C++的一些高级用法。</p>\n<h2 id=\"statement\">Statement</h2>\n<ul>\n<li>C与C++的语句申明位置有哪些差异？</li>\n</ul>\n<p>C语言的变量声明通常都应位于函数或过程开始位置（Pascal也是），而C++并没有该限制，因此这点可以说是C++的优点也可以是缺点。</p>\n<h3 id=\"range-based-for\">Range-based for</h3>\n<p>C++11 引入了一种崭新的 <code>for()</code> 循环形式，可以逐一迭代某个给定的 <strong>区间</strong>、<strong>数组</strong> 或 <strong>集合</strong>（range, array or collection） 内的每一个元素。而其他语言可能称之为 <code>foreach</code> 循环，其一般性用法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(decl:coll)&#123;</span><br><span class=\"line\">    statement</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>其中：</p>\n<ul>\n<li><em>decl</em> 是给定之 <em>coll</em> 集合中的每个元素的声明。</li>\n<li><em>statement</em> 会针对给定之 <em>decl</em> 进行执行</li>\n</ul>\n</blockquote>\n<p>使用样例（下左）及其输出结果（下右）如：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211030171650.png\" alt=\"image-20211030084723644\" /><figcaption aria-hidden=\"true\">image-20211030084723644</figcaption>\n</figure>\n<p>而且上面这种是基于 C-style array 的新旧语法搭配的 C++，实际上如果 <em>coll</em> 集合提供成员函数 <code>begin()</code> 和 <code>end()</code> ，那么使用 <code>for(decl:coll)</code> 时便等同于使用 <code>for(auto _pos=coll.begin(), _end=coll.end(); _pos!=_end;++_pos)</code></p>\n<h2 id=\"data-type\">Data Type</h2>\n<ul>\n<li>数据类型的大小由什么决定？数据类型大小（即占空内存空间）与系统位数、编译器的关联性？</li>\n<li>嵌入式系统与通用系统的数据类型大小差异在哪？</li>\n<li>double 和 float 在内存上的差异？</li>\n</ul>\n<p>在 C++ 中， <strong>变量</strong>（Variable） 一词通常用于 引用 <strong>标量数据类型</strong> 的 实例，而 <strong>其他类型</strong>（class / struct）的实例通常称为 <strong>对象</strong>（Object）。</p>\n<p>C++ 是 <strong>强类型语言</strong> ，也是 <strong>静态类型</strong>。</p>\n<p>在代码中声明变量时，必须 <mark>显式指定其类型</mark>，或使用 关键字指示编译器从初始值表达式 <strong><code>auto</code></strong> 推断类型。 在代码中声明函数时，必须指定每个参数的类型及其返回值；如果函数未返回任何 <strong><code>void</code></strong> 值，则必须指定 。当使用允许任意类型参数的函数模板时例外。</p>\n<h3 id=\"基本内置类型\">基本（内置）类型</h3>\n<p><strong>基本数据类型</strong>，简称 <strong>基本类型</strong> 或 <strong>基类型</strong>。</p>\n<p>下图显示了 Microsoft C++ 实现中的内置类型的相对大小：</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211030171653.png\" alt=\"多个内置类型的相对大小（以字节为单位）的关系图。\" /><figcaption aria-hidden=\"true\">多个内置类型的相对大小（以字节为单位）的关系图。</figcaption>\n</figure>\n<p>下表列出了最常用的基本类型及其在 Microsoft C++ 实现中的大小：</p>\n<table>\n<colgroup>\n<col style=\"width: 21%\" />\n<col style=\"width: 9%\" />\n<col style=\"width: 68%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>类型</th>\n<th>大小</th>\n<th>评论</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><strong><code>int</code></strong></td>\n<td>4 个字节</td>\n<td>整数值的默认选择。</td>\n</tr>\n<tr class=\"even\">\n<td><strong><code>double</code></strong></td>\n<td>8 个字节</td>\n<td>浮点值的默认选择。</td>\n</tr>\n<tr class=\"odd\">\n<td><strong><code>bool</code></strong></td>\n<td>1 个字节</td>\n<td>表示可为 true 或 false 的值。</td>\n</tr>\n<tr class=\"even\">\n<td><strong><code>char</code></strong></td>\n<td>1 个字节</td>\n<td>用于早期 C 样式字符串或 std:: 字符串对象中无需转换为 UNICODE 的 ASCII 字符。</td>\n</tr>\n<tr class=\"odd\">\n<td><strong><code>wchar_t</code></strong></td>\n<td>2 个字节</td>\n<td>表示可能以 UNICODE 格式进行编码的“宽”字符值（Windows 上为 UTF-16，其他操作系统上可能不同）。 这是用于 <code>std::wstring</code> 类型字符串的字符类型。</td>\n</tr>\n<tr class=\"even\">\n<td><strong><code>unsigned char</code></strong></td>\n<td>1 个字节</td>\n<td>C++ 没有内置字节类型。 使用 <strong><code>unsigned char</code></strong> 表示字节值。</td>\n</tr>\n<tr class=\"odd\">\n<td><strong><code>unsigned int</code></strong></td>\n<td>4 个字节</td>\n<td>位标志的默认选项。</td>\n</tr>\n<tr class=\"even\">\n<td><strong><code>long long</code></strong></td>\n<td>8 个字节</td>\n<td>表示非常大的整数值。</td>\n</tr>\n</tbody>\n</table>\n<p>类型数据的宽度（Width），即占用内存大小是由 <strong>计算机字长</strong> 和 <strong>编译程序</strong> 决定的。计算机字长提供了硬件计算精度的支持，编译程序则提供了源程序到机器码的转换。</p>\n<p>下方为C/C++ 在通用系统或嵌入式系统中的常见数据类型的大小，所有值的单位均为 <em>bit</em> 。</p>\n<table>\n<colgroup>\n<col style=\"width: 9%\" />\n<col style=\"width: 5%\" />\n<col style=\"width: 8%\" />\n<col style=\"width: 6%\" />\n<col style=\"width: 17%\" />\n<col style=\"width: 18%\" />\n<col style=\"width: 17%\" />\n<col style=\"width: 15%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>BASIC DATA TYPE</th>\n<th>8 bit MCU</th>\n<th>16bit MCU (51)</th>\n<th>32bit (x86)</th>\n<th>32bit (TI F28004x)<br>CLA ON</th>\n<th>32bit (TI F28004x)<br>CLA OFF</th>\n<th>64bit (x86)<br>in C++ (g++)</th>\n<th>64bit (x86)<br>in C (gcc)</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>char</td>\n<td></td>\n<td>8</td>\n<td>8</td>\n<td>8</td>\n<td>8</td>\n<td>8</td>\n<td>8</td>\n</tr>\n<tr class=\"even\">\n<td>short</td>\n<td></td>\n<td>16</td>\n<td>16</td>\n<td>16</td>\n<td>8</td>\n<td>16</td>\n<td>16</td>\n</tr>\n<tr class=\"odd\">\n<td>int</td>\n<td></td>\n<td>16</td>\n<td>32</td>\n<td>32</td>\n<td><mark>16</mark></td>\n<td>32</td>\n<td>32</td>\n</tr>\n<tr class=\"even\">\n<td>long</td>\n<td></td>\n<td>32</td>\n<td>32</td>\n<td>32</td>\n<td><mark>16</mark></td>\n<td>64</td>\n<td>64</td>\n</tr>\n<tr class=\"odd\">\n<td>long long</td>\n<td></td>\n<td>/</td>\n<td>64</td>\n<td>64</td>\n<td>32</td>\n<td>64</td>\n<td>64</td>\n</tr>\n<tr class=\"even\">\n<td>float</td>\n<td></td>\n<td>32</td>\n<td>32</td>\n<td>32</td>\n<td>32</td>\n<td>32</td>\n<td>32</td>\n</tr>\n<tr class=\"odd\">\n<td>double</td>\n<td></td>\n<td>32</td>\n<td>64</td>\n<td></td>\n<td>16</td>\n<td>64</td>\n<td>64</td>\n</tr>\n<tr class=\"even\">\n<td>long double</td>\n<td></td>\n<td>/</td>\n<td></td>\n<td></td>\n<td>32</td>\n<td>128</td>\n<td>128</td>\n</tr>\n</tbody>\n</table>\n<p>下方内容转自网络，待验证。</p>\n<blockquote>\n<p>（x86平台下）<code>long int</code> 即 <code>long</code>，给人的感觉好像是长整型，但实际上，它和 <code>int</code> 一样，只有32位。cppreference 给出的定义如下，但在实际的使用中，<code>long</code> 与 <code>int</code> 几乎没有区别。</p>\n<blockquote>\n<p><strong><em>int</em></strong> - basic integer type. The keyword int may be omitted if any of the modifiers listed below are used. If no length modifiers are present, it’s guaranteed to have a width of at least 16 bits. However, on 32/64 bit systems it is almost exclusively guaranteed to have width of at least 32 bits. <strong><em>long</em></strong> - target type will have width of at least 32 bits.</p>\n</blockquote>\n</blockquote>\n<p><strong>实际上经过测试</strong>：在 x86_64 平台下，C 和 C++ 中的 <code>long</code> 长度都是要比 <code>int</code> 更长的，即 <code>int</code> 默认为 <code>32bit</code> 宽度，<code>long</code> 为 <code>64bit</code> 宽度。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211030171657.png\" alt=\"image-20211028101248341\" /><figcaption aria-hidden=\"true\">image-20211028101248341</figcaption>\n</figure>\n<h3 id=\"embedded-system\">Embedded System</h3>\n<p>嵌入式C语言中常用的数据类型如下图所示，而不同的</p>\n<p><img src=\"https://pic.islet.space/2021/10/20211030171712.png\" alt=\"image-20211027155153218\" style=\"zoom: 67%;\" /></p>\n<h3 id=\"double-float\">double / float</h3>\n<p><strong>IEEE二进制浮点数算术标准</strong>（<strong>IEEE 754</strong>）是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用。这个标准定义了表示浮点数的格式（包括负零-0）与反常值（denormal number）），一些特殊数值（无穷（Inf）与非数值（NaN）），以及这些数值的“浮点数运算符”；它也指明了四种数值舍入规则和五种例外状况（包括例外发生的时机与处理方式）。</p>\n<p>IEEE 754规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80比特实做）。只有32位模式有强制要求，其他都是选择性的。大部分编程语言都有提供IEEE浮点数格式与算术，但有些将其列为非必需的。例如，IEEE 754问世之前就有的C语言，现在有包括IEEE算术，但不算作强制要求（C语言的<code>float</code>通常是指IEEE单精确度，而<code>double</code>是指双精确度）。</p>\n<p>该标准的全称为<strong>IEEE二进制浮点数算术标准（ANSI/IEEE Std 754-1985）</strong>，又称<strong>IEC 60559:1989，微处理器系统的二进制浮点数算术</strong>（本来的编号是IEC 559:1989）。后来还有“与基数无关的浮点数”的“IEEE 854-1987标准”，有规定基数为2跟10的状况。现在最新标准是“IEEE 854-2008标准”。</p>\n<h2 id=\"variable\">Variable</h2>\n<p>C++ 与 ANSI C（C99标准）不同之处，在于后者只保证名称中的前63个字符有意义，即使第64个字符不同，但是只要前63个字符相同的变量则被认为是相同的。</p>\n<p>在某些情况下，其他程序员会使用的变量命名风格及其意义：</p>\n<ul>\n<li><code>str</code> 或 <code>sz</code> 前缀：表示以空字符结束的字符串</li>\n<li><code>b</code> 前缀：表示布尔值</li>\n<li><code>p</code> 前缀：表示指针</li>\n<li><code>c</code> 前缀：表示单个字符</li>\n</ul>\n<h2 id=\"class\">Class</h2>\n<p><strong>类</strong>：（用户定义/标准的）数据类型规范，详细描述了如何表示信息以及对数据执行的操作。</p>\n<p><strong>对象</strong>：是根据类规范创建的实体（好似之于变量和基本数据类型）。</p>\n<p>就像函数可以来自函数库一样，类也可以来自 <strong>类库</strong>。从技术上说，大部分类库都没有被内置到C++语言中，而是语言标准指定的类。<strong>类定义</strong> 位于类库文件中，并没有被内置到编译器里（有需要可以修改，虽然不建议）。</p>\n<p>C++之所以如此有吸引力，很大程度上是由于存在大量支持UNIX、Macintosh 和 Windows 编程的类库。</p>\n<p><strong>类描述</strong> 指定了可以对类对象执行的所有操作。要对特定对象执行这些允许的操作有两种方法，一是直接使用类方法（本质即函数调用），二是重定义运算符（如 <code>cin</code> 和 <code>cout</code> 使用的 <code>&gt;&gt;</code> 和 <code>&lt;&lt;</code> ）</p>\n<h2 id=\"function\">Function</h2>\n<p>被调用的函数称为 <strong>被调用函数</strong>（called function），包含函数调用的函数称为 <strong>调用函数</strong>（calling function）。</p>\n<p><strong>函数原型</strong>：即 <strong>函数声明</strong>，函数原型或声明只描述函数接口，指仅有函数头和分号 <code>;</code> 而没有函数体的语句。函数原型定义了需要传递给函数的参数以及函数本身需要返回的值的类型。</p>\n<p><strong>库文件</strong>：存放了函数编译代码的文件。</p>\n<p><strong>头文件</strong>：包含了函数原型的文件。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211030171703.png\" alt=\"image-20211028085847535\" /><figcaption aria-hidden=\"true\">image-20211028085847535</figcaption>\n</figure>\n<blockquote>\n<p>在有些语言中，有返回值的函数被称为 <strong>函数</strong>（function），无返回值的函数被称为 <strong>过程</strong>（procedure） 或 子程序（subroutine）。</p>\n<p>但在C/C++中，都被称为 <strong>函数</strong>。</p>\n</blockquote>\n<h3 id=\"main-function\">Main Function</h3>\n<ul>\n<li>有什么有些IDE中的main函数的括号里是带参数的？</li>\n</ul>\n<p>是否在 主函数<code>main()</code> 参数括号 <code>()</code> 中使用关键字 <code>void</code> ，在C++和C中有明显的区别：</p>\n<ul>\n<li>在C++中，让括号空着和在括号中写 <code>void</code> 等效。</li>\n<li>而在C中，让括号空着意味着对是否接受参数保持沉默。</li>\n</ul>\n<blockquote>\n<p><code>int main(int argc, const char * argv[])</code> 是UNIX和linux中的标准写法。<code>int main()</code> 只是默许的用法。</p>\n<p>使用main函数时经常都是不带参数的，因此main 后的括号都是空括号。实际上，main函数可以带参数，这个参数可以认为是 main函数的 <strong>形式参数</strong>。</p>\n<p>Ｃ语言规定</p>\n<ol type=\"1\">\n<li>main函数的参数只能有两个，习惯上这两个参数写为 <code>argc</code> 和 <code>argv</code>。因此，main函数的函数头可写为：<code>main (argc,argv)</code> 。</li>\n<li><code>argc</code> （第一个形参）必须是 <strong>整型变量</strong> ，<code>argv</code> （第二个形参）必须是指向字符串的 <strong>指针数组</strong>。</li>\n</ol>\n<p>由于main函数不能被其它函数调用，因此不可能在程序内部取得实际值。那么，在何处把实参值赋予main函数的形参呢?</p>\n<p>实际上，main函数的参数值是从 <strong>操作系统命令行</strong>/Terminal 上获得的。当我们要运行一个可执行文件时，输入空格，输入文件名，再输入实际参数即可把这些实参传送到main的形参中去。</p>\n</blockquote>\n<p><code>argc</code> 的数值会随着通过命令行传递给可执行文件的参数的增加而增加，即 <code>argc</code> 其实是代表着 <strong>参数的数量</strong>。</p>\n<figure>\n<img src=\"https://pic.islet.space/2021/10/20211030171706.png\" alt=\"image-20211027144512641\" /><figcaption aria-hidden=\"true\">image-20211027144512641</figcaption>\n</figure>\n<h2 id=\"编译指令\">编译指令</h2>\n<p><code>using</code> 是编译指令的关键字，</p>\n<h1 id=\"参考\">参考</h1>\n<ol type=\"1\">\n<li>《<a href=\"https://storage.islet.space/01_Learning/02_CPP/C%2B%2B_Primer_Plus.pdf\">C++ Primer Plus</a>》</li>\n<li><a href=\"https://www.jianshu.com/p/ab21bfe6a5b2\">int main(int argc, const char * argv[])</a></li>\n<li><a href=\"https://docs.microsoft.com/zh-cn/cpp/cpp/cpp-type-system-modern-cpp?view=msvc-160\">C++ 类型系统</a></li>\n<li><a href=\"https://www.cnblogs.com/noble/p/4144120.html\">IEEE二进制浮点数算术标准（IEEE 754）</a></li>\n</ol>\n","categories":["Programming"],"tags":["C++"]},{"title":"CSS学习笔记","url":"/2021/02/10/Programming/CSS/2021-02-10-CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"<h1 id=\"css基础\">CSS基础</h1>\n<p><strong>书写方式：</strong> <code>CSS属性:</code> <code>属性值;</code></p>\n<h2 id=\"css-类命名规则\">1. CSS 类命名规则</h2>\n<h3 id=\"公共命名规则\">公共命名规则</h3>\n<table>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: left;\">CSS样式命名</th>\n<th style=\"text-align: left;\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">wrapper</td>\n<td style=\"text-align: left;\">页面外围控制整体布局宽度</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">container或content</td>\n<td style=\"text-align: left;\">容器,用于最外层</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">layout</td>\n<td style=\"text-align: left;\">布局</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">head, header</td>\n<td style=\"text-align: left;\">页头部分</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">foot, footer</td>\n<td style=\"text-align: left;\">页脚部分</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">nav</td>\n<td style=\"text-align: left;\">主导航</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">subnav</td>\n<td style=\"text-align: left;\">二级导航</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">menu</td>\n<td style=\"text-align: left;\">菜单</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">submenu</td>\n<td style=\"text-align: left;\">子菜单</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">sideBar</td>\n<td style=\"text-align: left;\">侧栏</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">sidebar_a, sidebar_b</td>\n<td style=\"text-align: left;\">左边栏或右边栏</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">main</td>\n<td style=\"text-align: left;\">页面主体</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">tag</td>\n<td style=\"text-align: left;\">标签</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">msg message</td>\n<td style=\"text-align: left;\">提示信息</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">tips</td>\n<td style=\"text-align: left;\">小技巧</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">vote</td>\n<td style=\"text-align: left;\">投票</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">friendlink</td>\n<td style=\"text-align: left;\">友情连接</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">title</td>\n<td style=\"text-align: left;\">标题</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">summary</td>\n<td style=\"text-align: left;\">摘要</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">loginbar</td>\n<td style=\"text-align: left;\">登录条</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">searchInput</td>\n<td style=\"text-align: left;\">搜索输入框</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">hot</td>\n<td style=\"text-align: left;\">热门热点</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">search</td>\n<td style=\"text-align: left;\">搜索</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">search_output</td>\n<td style=\"text-align: left;\">搜索输出和搜索结果相似</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">searchBar</td>\n<td style=\"text-align: left;\">搜索条</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">search_results</td>\n<td style=\"text-align: left;\">搜索结果</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">copyright</td>\n<td style=\"text-align: left;\">版权信息</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">branding</td>\n<td style=\"text-align: left;\">商标</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">logo</td>\n<td style=\"text-align: left;\">网站LOGO标志</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">siteinfo</td>\n<td style=\"text-align: left;\">网站信息</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">siteinfoLegal</td>\n<td style=\"text-align: left;\">法律声明</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">siteinfoCredits</td>\n<td style=\"text-align: left;\">信誉</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">joinus</td>\n<td style=\"text-align: left;\">加入我们</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">partner</td>\n<td style=\"text-align: left;\">合作伙伴</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">service</td>\n<td style=\"text-align: left;\">服务</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">regsiter</td>\n<td style=\"text-align: left;\">注册</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">arr/arrow</td>\n<td style=\"text-align: left;\">箭头</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">guild</td>\n<td style=\"text-align: left;\">指南</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">sitemap</td>\n<td style=\"text-align: left;\">网站地图</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">list</td>\n<td style=\"text-align: left;\">列表</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">homepage</td>\n<td style=\"text-align: left;\">首页</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">subpage</td>\n<td style=\"text-align: left;\">二级页面子页面</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">tool, toolbar</td>\n<td style=\"text-align: left;\">工具条</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">drop</td>\n<td style=\"text-align: left;\">下拉</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">dorpmenu</td>\n<td style=\"text-align: left;\">下拉菜单</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">status</td>\n<td style=\"text-align: left;\">状态</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">scroll</td>\n<td style=\"text-align: left;\">滚动</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">.tab</td>\n<td style=\"text-align: left;\">标签页</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">.left .right .center</td>\n<td style=\"text-align: left;\">居左、中、右</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">.news</td>\n<td style=\"text-align: left;\">新闻</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">.download</td>\n<td style=\"text-align: left;\">下载</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">.banner</td>\n<td style=\"text-align: left;\">广告条(顶部广告条)</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"其他div命名规则\">其他DIV命名规则</h3>\n<p>　　登录条:loginBar</p>\n<p>　　标志:logo</p>\n<p>　　侧栏:sideBar</p>\n<p>　　广告:banner</p>\n<p>　　导航:nav</p>\n<p>　　子导航:subNav</p>\n<p>　　菜单:menu</p>\n<p>　　子菜单:subMenu</p>\n<p>　　搜索:search</p>\n<p>　　滚动:scroll</p>\n<p>　　页面主体:main</p>\n<p>　　内容:content</p>\n<p>　　标签页:tab</p>\n<p>　　文章列表:list</p>\n<p>　　提示信息:msg</p>\n<p>　　小技巧:tips</p>\n<p>　　栏目标题:title</p>\n<p>　　友情链接:friendLink</p>\n<p>　　页脚:footer</p>\n<p>　　加入:joinus</p>\n<p>　　指南:guild</p>\n<p>　　服务:service</p>\n<p>　　热点:hot</p>\n<p>　　新闻:news</p>\n<p>　　下载:download</p>\n<p>　　注册:regsiter</p>\n<p>　　状态:status</p>\n<p>　　按钮:btn</p>\n<p>　　投票:vote</p>\n<p>　　合作伙伴:partner</p>\n<p>　　版权:copyRight</p>\n<h2 id=\"选择器\">2. 选择器</h2>\n<h3 id=\"基础选择器\">基础选择器</h3>\n<p>选择器按作用大小（从小到大）分为 <code>ID选择器(使用井字符做特殊标注：#)</code> 、<code>类选择器（使用英文点号做特殊标注：.）</code> 、 <code>标签选择器</code> 及 <code>通配符选择器（使用英文星号做特殊标注：*）</code>。</p>\n<table>\n<colgroup>\n<col style=\"width: 9%\" />\n<col style=\"width: 48%\" />\n<col style=\"width: 22%\" />\n<col style=\"width: 19%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>选择器类型</th>\n<th>选择器特性</th>\n<th>style书写方式</th>\n<th>style应用方式</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>ID选择器</td>\n<td>1. 与其他选择器类型一致，特殊之处是大部分情况作JavaScript调用<br/>2. 需要编写唯一id不可重复使用</td>\n<td>#DivStyle { color: red; }</td>\n<td>id=\"DivStyle\"</td>\n</tr>\n<tr class=\"even\">\n<td>类选择器</td>\n<td>1. 作用于使用class属性的一类标签，同面向对象的其他语言特性一致<br/>2. 单个标签可以使用多个类，中间以空格隔开</td>\n<td>.ClassStyle { color: black;}</td>\n<td>Class=\"ClassStyle .....\"</td>\n</tr>\n<tr class=\"odd\">\n<td>标签选择器</td>\n<td>作用于所有使用本标签的标签</td>\n<td>div { color: blue; }</td>\n<td>/</td>\n</tr>\n<tr class=\"even\">\n<td>通配符选择器</td>\n<td>作用于所有标签</td>\n<td>* { clolor: pink; }</td>\n<td>/</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"复合选择器\">复合选择器</h3>\n<table>\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 44%\" />\n<col style=\"width: 44%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>复合选择器类型</th>\n<th>选择器特性</th>\n<th>style书写方式</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>后代选择器</td>\n<td>1. 可以选择<strong>某个</strong>父标签下的<strong>某个</strong>全部子标签，不管其是否在同一个层级<br/>2. 当标签发生嵌套时，内层标签就称为外层标签的后代<br/>3. 浏览器按照标签层级的关系进行查找，并<u>对最内层标签进行修改</u>，因此可以定义多重标签选择，如可以使用基础选择器（类选择器及ID选择器）进行组合使用<br/>4. 内外层选择器之间 <mark>以空格隔开</mark></td>\n<td>外层标签 内层标签 {属性}<br/>ol li { color: #000; }<br/>ol li a { color: #777; }<br/>.nav li a { color: pruple;}</td>\n</tr>\n<tr class=\"even\">\n<td>子代选择器</td>\n<td>1. 即与后代选择器不同，仅对父级标签下的某一类选择器进行操作，不会作用于其他子代的同类标签<br/>2. 使用符号 <code>&gt;</code> 进行操作</td>\n<td>.nav&gt;a {color: pink;}</td>\n</tr>\n<tr class=\"odd\">\n<td>集选择器（相邻选择器）</td>\n<td>1. 在两个没有从属关系（子代或后代）和相同特点（如同类标签）的同级不同类标签中，定义一个相同的样式<br/>2. 多个标签进行选择时使用英文逗号 <code>,</code> 进行并列选择<br/>3. 并集选择器内可使用 <strong>简单选择器</strong> 和 <strong>复合选择器</strong>（如 后代选择器 和 子代选择器），竖向书写选择器</td>\n<td>div, p {color: pink; }</td>\n</tr>\n<tr class=\"even\">\n<td>伪类选择器</td>\n<td>1. 用于给某些选择器添加特殊效果（如给链接添加特殊效果），或者选择某个元素<br/>2. 结构伪类、链接伪类、表单伪类<br/>3. 伪类选择器其实更像是一个行为选择器（或状态选择器），它定义了一个/类标签在不同状态下的样式，书写形式如：<code>标签</code>: <code>状态/行为</code> <code>&#123;属性&#125;</code></td>\n<td>.OnlineTitle:link {<br/> color: #222222;<br/> text-decoration: none;<br/>}</td>\n</tr>\n</tbody>\n</table>\n<p><strong>并集选择器</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">HTML</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">如要求将下方熊大、熊二及佩奇一家都改为粉色，则按照&lt;style&gt;中的方式进行书写</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">            //在两个没有从属关系（子代或后代）和相同特点（如同类标签）的同级不同类标签中，定义一个相同的样式</span><br><span class=\"line\"><span class=\"css\">            <span class=\"selector-tag\">div</span>,</span></span><br><span class=\"line\"><span class=\"css\">            <span class=\"selector-tag\">p</span>,</span></span><br><span class=\"line\"><span class=\"css\">            <span class=\"selector-class\">.pig</span> <span class=\"selector-tag\">li</span> &#123;                //类选择器</span></span><br><span class=\"line\"><span class=\"css\">                <span class=\"attribute\">color</span>: pink;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>熊大<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>熊二<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>关头强<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;pig&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>PIG 1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>PIG 2<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>PIG 3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>链接伪类选择器</strong></p>\n<p>四个使用方式: link / visited / hover / active</p>\n<ol type=\"1\">\n<li>为了确保生效，应按照LVHA的顺序进行声明。</li>\n<li><code>&lt;a&gt;</code> 链接在浏览器中具有默认样式，不会因为在<code>&lt;body&gt;</code>中而随之改变，实际工作中需要给链接单独指定样式。</li>\n<li>使用时，加上冒号 <code>:</code> 与 四种<code>状态</code>之一 即可</li>\n</ol>\n<p>举例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\t<span class=\"attribute\">background-color</span>:yellow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当鼠标经过父级元素时，显示子元素的遮罩层：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.tudou</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.mask</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">display</span>: block;      <span class=\"comment\">/* 显示遮罩层 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>最小盒子：</strong>即只能存放文字了，不能再存放其他标签/元素，如 <code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code>等文字块级标签；</p>\n<h3 id=\"元素显示模式\">元素显示模式</h3>\n<p>是指在页面上的元素以 <strong>块状模式</strong> 、 <strong>行内模式</strong> 或 <strong>行内块模式</strong> 进行显示。元素按显示模式可以分为 <strong>块状（级）元素</strong> 及 <strong>行内元素（内联元素）</strong> 及 <strong>行内块元素</strong> 三种类型。</p>\n<table>\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 30%\" />\n<col style=\"width: 30%\" />\n<col style=\"width: 30%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>元素类型</th>\n<th>典型标签</th>\n<th>特点</th>\n<th>注意点</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>块状元素</td>\n<td><code>&lt;h1&gt;</code>~<code>&lt;h6&gt;</code> 、 <code>&lt;p&gt;</code>、 <code>&lt;div&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>......</td>\n<td>1. 即使设置标签宽度，也是独占一行<br/>2. 高、宽、外边距及内边距可调节<br/>3. 默认宽度是父级宽度的100%<br/>4. 是一个容器及盒子，可以放任何标签</td>\n<td>文字类的标签内不可以存放块元素</td>\n</tr>\n<tr class=\"even\">\n<td>行内元素（内联元素）</td>\n<td><code>&lt;a&gt;</code>、 <code>&lt;strong&gt;</code>、<code>&lt;b&gt;</code>、 <code>&lt;em&gt;</code>、<code>&lt;i&gt;</code> ......</td>\n<td>1. 相邻行内元素在一行上，一行可以显示多个<br/>2. 直接设置宽高无效，可以间接设置<br/>3. 默认宽度就是其内容宽度<br/>4. 行内元素只能容纳文本及其他行内元素</td>\n<td>1. 链接中不允许再放其他链接<br/>2. <code>&lt;a&gt;</code>中可以放置块元素，但是转换成块级元素最安全</td>\n</tr>\n<tr class=\"odd\">\n<td>行内块元素</td>\n<td><code>&lt;input&gt;</code>、 <code>&lt;image&gt;</code>、<code>&lt;td&gt;</code>......</td>\n<td>1. 同时具有块元素及行内元素的特定<br/>2. 和相邻行内元素（行内块）在一行上，但是有空白缝隙，可以一行显示多个<br/>3. 默认宽度即内容宽度<br/>4. 高度、行高、外边距及内边距可控制</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><strong>元素显示模式的转换</strong></p>\n<p>即一个模式的元素需要另一个模式的特性，可以通过在CSS的标签样式属性中添加display语句进行转换。</p>\n<p>转换为块级元素： <em><code>display: block;</code></em></p>\n<p>转换为行内元素： <em><code>display: inline;</code></em></p>\n<p>转换为行内块元素： <em><code>display: inline-block;</code></em></p>\n<h3 id=\"权重\">权重</h3>\n<table>\n<thead>\n<tr class=\"header\">\n<th>选择器类型</th>\n<th>权重</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>继承</td>\n<td>无</td>\n</tr>\n<tr class=\"even\">\n<td>通配符选择器、子代选择器、相邻选择器（并集选择器）</td>\n<td>0,0,0,0</td>\n</tr>\n<tr class=\"odd\">\n<td>元素选择器、伪元素选择器</td>\n<td>0,0,0,1</td>\n</tr>\n<tr class=\"even\">\n<td>类选择器、伪类选择器、属性选择器</td>\n<td>0,0,1,0</td>\n</tr>\n<tr class=\"odd\">\n<td>ID选择器</td>\n<td>0,1,0,0</td>\n</tr>\n<tr class=\"even\">\n<td>内联选择器</td>\n<td>1,0,0,0</td>\n</tr>\n<tr class=\"odd\">\n<td>!IMPORTANT</td>\n<td>无限</td>\n</tr>\n</tbody>\n</table>\n<p>选择器的加权结果并非二进制，而是在各个数位上进行单独相加，例如元素选择器与类选择器的加权结果为 <code>0,0,1,1</code>，左侧数位的数值越大，权重越高。</p>\n<h2 id=\"list\">3. List</h2>\n<p><code>list-style</code> CSS 属性是一个简写对属性集合，包括<code>list-style-type</code>, <code>list-style-image,</code> 和 <code>list-style-position</code>。</p>\n<p><code>list-style: none | circle | square inside ;</code>表示<code>&lt;ul&gt;</code> 下 <code>&lt;li&gt;</code> 前的小点样式，如“无、圆圈、实心方形”。</p>\n<p>例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;one&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>List Item1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>List Item2<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>List Item3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">List 2</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;two&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>List Item A<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>List Item B<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>List Item C<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>及</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.one</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">list-style</span>: circle;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.two</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">list-style</span>: square inside;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"background\">4. Background</h2>\n<p><code>background-color</code> 可以设置为 <code>transparent</code>，即透明的，不可视的。</p>\n<p><code>background-image</code> 可以设置为 <code>none</code>，也可以跟上一个 <code>url()</code> 链接。如：<code>background-image: url(http://xxxxxx.com/123.jpg)</code></p>\n<p><code>background-repeat: repeat | no-repea | repeat-x | repeat-y</code> ，分别是指 重复（平铺）、不平铺、在x轴上平铺 及 在y轴上平铺 。</p>\n<p><code>background-position: top | bottom | left | right | center;</code> 除了可以使用类似于左侧的方位词定位，还可以使用坐标轴数值定位。</p>\n<h2 id=\"font\">5. Font</h2>\n<p><strong>FONT-FAMILY 字体族</strong></p>\n<p>通用属性之一，用于设置网页显示字体，font-family的使用方式为 <code>font-family=\" \"</code> ，双引号内可以书写多个字体，引擎会按顺序搜索本地字体并使用，如果都没有则使用本地字体。</p>\n<p><strong>注意：</strong>建议使用字体的全英文进行书写，如 <strong>微软雅黑</strong> 全英文为 <strong>Microsoft YaHei</strong>，英文书写时有空格的应用单引号<code>‘’</code> 进行包裹。</p>\n<p><strong>FONT-SIZE 字体大小</strong></p>\n<p>通常用于对body标签内所有正文字体大小的设置，对标题（如<code>h3</code>）大小的设置仍需另起样式。</p>\n<p><strong>复合写法</strong></p>\n<p><code>font: font-style font-weight font-size/line-height font-family;</code></p>\n<p><code>font-size</code> 和 <code>font-family</code> 不可缺省</p>\n<h2 id=\"text\">6. Text</h2>\n<p><strong>文本属性</strong></p>\n<table>\n<colgroup>\n<col style=\"width: 22%\" />\n<col style=\"width: 47%\" />\n<col style=\"width: 30%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>属性</th>\n<th>书写方式</th>\n<th>注意</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>color<br/>颜色</td>\n<td>1. 常见英文表示法，直接书写该颜色英文即可，如 pink  red  blue  purple<br/>2. 16进制表示法，用#号进行书写，如#FF00FF<br/>3. RGB表示法，如rgb(0,0,255)</td>\n<td>16进制简写为#fff<br/>实际开发中用16进制</td>\n</tr>\n<tr class=\"even\">\n<td>text-align<br/>文本对齐</td>\n<td>仅有左、中、右三种表示方式，用英文 left  center  right 进行书写</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>text-indent<br/>文本缩进</td>\n<td>缩进可以用2种方式表示：<br/>1. 精准缩进：即直接使用 <code>px</code> 单位进行书写，表示缩进多少像素点，缺点是容易出现问题<br/>2. 字符单位缩进：即按照字符大小，自适应缩进字符距离，单位是em，如 <code>2em</code>，可以缩进2个字符</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td>text-decoration<br/>文本修饰</td>\n<td>常见的修饰类型有四种：无（none）、上划线（overline）、下划线（underline）、删除线（line-through）</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>line-height</td>\n<td>行高=上行距+下行距+字高，且上行距=下行距</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"box-module\">7. Box Module</h2>\n<p>盒子模型主要分三部分：<strong>border</strong>（边框）、<strong>padding</strong>（内边距）及 <strong>margin</strong>（外边距）。</p>\n<h3 id=\"border\">Border</h3>\n<p>边框主要有一下三种参数：粗细、颜色及样式</p>\n<ul>\n<li>粗细(border-width: 5px;)</li>\n<li>颜色(boder-color: #555) （<em>注意：如果这个值没有设置，它的默认值是元素的 color属性值（是文字颜色而非背景色）</em>），可以定义为transparent（透明的）</li>\n<li>样式(boder-style: none | hidden | dotted | dashed | solid | double(双层线) | groove(内雕刻) | ridge(外浮雕) | inset(内凹陷) | outset(外凹陷) )</li>\n</ul>\n<p>border属性之可以在中间添加上、下、左、右四个方位词和三参数之一，如 border-top-color | border-bottom-style ....</p>\n<p>边框使用时会影响盒子大小，需要注意调整。</p>\n<p><strong>复合写法</strong></p>\n<p><code>border: [border-width ||border-style ||border-color |inherit] ;</code></p>\n<h3 id=\"padding\">Padding</h3>\n<p>内边距涉及到的参数包括 上下左右四边的边距。</p>\n<p>在未设置内盒子的width时，设置padding对内盒子实际显示大小不起影响，一旦设置width，则会让盒子的width在显示时超过设置参数的大小。</p>\n<h3 id=\"margin\">Margin</h3>\n<p>外边距同内边距。</p>\n<p>在标准流下，设置块级盒子width参数后，设置margin左右为auto，可以让盒子实现居中效果。（以下三种写法，推荐第一个，第一个参数表示上下，第二个参数表示左右）</p>\n<p><code>margin: 0 auto;</code></p>\n<p><code>margin: auto;</code></p>\n<p><code>margin-left: auto; margin-right: auto;</code></p>\n<h3 id=\"qa\">Q/A</h3>\n<p><strong>盒子塌陷的解决方案</strong></p>\n<p>以下为两个盒子嵌套，同时设置上边距导致塌陷问题的解决方案：</p>\n<ul>\n<li>可以为父元素定义上边框/上内边距</li>\n<li>可以为父元素添加 <code>overflow: hidden;</code></li>\n<li>利用浮动、固定、绝对定位解决</li>\n</ul>\n<h2 id=\"float\">8. Float</h2>\n<p>浮动最初的开发目的是让图片和文字产生环绕效果的，浮动可以让多个块级元素在一行内显示。</p>\n<p><code>float: none | left | right;</code></p>\n<p><strong>注意：</strong>两个行内块元素中间会有空白间隙存在，如果父级元素设定了宽度，会让元素存放不下。需要给此类行内块元素设定浮动</p>\n<p><strong>浮动特性：</strong></p>\n<ul>\n<li><p>脱标</p></li>\n<li><p>顶端对齐</p></li>\n<li><p>具有行内块元素特性</p></li>\n</ul>\n<p><strong>外边距合并</strong></p>\n<blockquote>\n<p>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p>\n</blockquote>\n<p><strong>注释：</strong>只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。</p>\n<p>在标准流中嵌套一个带有外边距的浮动框，不会让他们产生外边距合并。</p>\n<h2 id=\"clean-float\">9. Clean Float</h2>\n<p>清除浮动也叫闭合浮动，是指在未指定父级元素高度而子级元素为浮动时，会对父级元素同级的标准流造成影响，因而需要清除该类浮动造成的弊端的情况。</p>\n<p>清除浮动的四种方式：</p>\n<table>\n<colgroup>\n<col style=\"width: 9%\" />\n<col style=\"width: 35%\" />\n<col style=\"width: 20%\" />\n<col style=\"width: 35%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>方法</th>\n<th>说明</th>\n<th>写法</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>额外标签</td>\n<td>[w3c推荐]也称隔墙法，指在浮动的块（行内块）级元素后面新增一个带有<code>clear: both;</code>属性的额外标签（要求是块级元素）来屏蔽浮动的影响。</td>\n<td><code>clear: both;</code></td>\n<td>弊端是增加了额外标签，对H5结构造成负担；<br/>要求新增的标签不能是行内元素</td>\n</tr>\n<tr class=\"even\">\n<td>父级添加overflow</td>\n<td>仅给父级元素添加overflow，添加hidden、auto、scroll皆可。</td>\n<td><code>overflow: hidden | auto | scroll</code></td>\n<td>优点是代码简洁，缺点是无法显示溢出的部分</td>\n</tr>\n<tr class=\"odd\">\n<td>:after伪元素</td>\n<td>额外标签法的升级版，利用CSS样式添加额外标签<br/>仅给父级元素添加</td>\n<td>见下方</td>\n<td>没有增加额外标签，样式写法较为复杂；</td>\n</tr>\n<tr class=\"even\">\n<td>双伪元素</td>\n<td>在子级前后各添加一个伪元素</td>\n<td>见下方</td>\n<td>代码简洁，照顾低版本。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>:after伪元素代码示例：</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.clearfix</span>:after &#123;</span><br><span class=\"line\">\tcontent: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">\t<span class=\"attribute\">visibility</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.clearfix</span> &#123;       <span class=\"comment\">/* IE6、7专有 */</span></span><br><span class=\"line\">\t*zoom: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>双伪元素代码示例：</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.clearfix</span>:before, .clearfix:after&#123;</span><br><span class=\"line\">\tcontent: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">display</span>: table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.clearfix</span>:after&#123;</span><br><span class=\"line\">\tclear: both;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.clearfix</span>&#123;</span><br><span class=\"line\">\t*zoom: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"position\">10. Position</h2>\n<h3 id=\"定位的意义\">定位的意义</h3>\n<p>让盒子自由地在某个盒子中移动或固定在屏幕中的某个位置，并且可以压住其他盒子。</p>\n<p><strong>注意：</strong>对于标准流和浮动，不可以使用定位。</p>\n<h3 id=\"定位模式\">定位模式</h3>\n<p><code>position: static | relative | absolute | fixed ;</code></p>\n<table>\n<colgroup>\n<col style=\"width: 12%\" />\n<col style=\"width: 14%\" />\n<col style=\"width: 5%\" />\n<col style=\"width: 27%\" />\n<col style=\"width: 39%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>定位分类</th>\n<th>脱标</th>\n<th>使用情况</th>\n<th>参考系</th>\n<th>其他特点</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>静态定位 <code>static</code></td>\n<td>否，不能使用边偏移</td>\n<td>很少</td>\n<td>无，不设置边偏移</td>\n<td>按照标准流特性摆放位置</td>\n</tr>\n<tr class=\"even\">\n<td>相对定位 <code>relative</code></td>\n<td>否，占用标准流的位置</td>\n<td>常用</td>\n<td>自身原来的位置</td>\n<td>相对于自身原来的位置来移动<br/>设置相对定位后，后面的标准流<strong>不会脱标</strong>，不会让身后的标准流往前挤或往后挤；<br/>通常是给绝对定位当父级元素的属性</td>\n</tr>\n<tr class=\"odd\">\n<td>绝对定位 <code>absolute</code></td>\n<td>是，不占用标准流的位置</td>\n<td>常用</td>\n<td>最近一级父级以上带有定位的盒子（子绝父相）</td>\n<td>如果没有已定位的父级元素，则以浏览器进行绝对定位</td>\n</tr>\n<tr class=\"even\">\n<td>固定定位 <code>fixed</code></td>\n<td>是，不占用标准流的位置</td>\n<td>常用</td>\n<td>浏览器的可视窗口</td>\n<td>与父级元素无关，不随窗口滚动条滚动<br/></td>\n</tr>\n<tr class=\"odd\">\n<td>粘性定位 <code>sticky</code></td>\n<td>否，占用标准流的位置</td>\n<td>很少</td>\n<td>浏览器的可视窗口</td>\n<td>相对定位和固定定位的混合体，具有两者的某些特点<br/>必须添加至少一个边偏移参数<br/>需与滚动搭配使用，对IE兼容性差，类似粘性定位的做法通常用JavaScript来做</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"边偏移\">边偏移</h3>\n<p>相对于父级盒子（或者有定位的祖辈盒子）的边线偏移量（偏移量可以为负值）。</p>\n<p>需要在设置好定位模式后边偏移才能生效。</p>\n<p><strong>四种偏移：</strong>top、bottom、right、left；</p>\n<p><strong>例：</strong><code>top: 10px; right: 20px;</code></p>\n<p><strong>如何将内容固定到版心右侧？</strong></p>\n<p>使用固定定位至左侧的50%，在调整<code>margin-left</code>值至版心宽度的一般（直接书写数值px）。</p>\n<p><strong>如何让内容固定到屏幕正中心？</strong></p>\n<p>使用固定定位至左侧和顶部的50%，再使用<code>margin-left</code>和<code>margin-right</code>的负值来抵消自身宽高的一半。</p>\n<h3 id=\"定位显示优先级\">定位显示优先级</h3>\n<p>定位显示优先级，即定位叠放顺序，是指 <strong>具有定位属性的盒子</strong>（类似于PS图层）在Z轴上的显示优先级，数值越大则优先级越高。</p>\n<p>如果设置为<code>auto</code>，则按照H5结构书写顺序以“后来居上”的原则显示。</p>\n<p>如果设置为数值，则比auto优先级更高，但是不能写单位。</p>\n<p><code>z-index: (number) | auto;</code></p>\n<h3 id=\"定位的特殊性质\">定位的特殊性质</h3>\n<ul>\n<li>给行内元素添加绝对或者固定定位后，可以设置宽度和高度（不等同于与块级元素互换特性？）</li>\n<li>给块级元素添加绝对或者固定宽度后，不设置宽高也可以则应用内容的大小</li>\n</ul>\n<h2 id=\"显示与隐藏\">11. 显示与隐藏</h2>\n<p>显示与隐藏的三种方式：display（显示隐藏）、visibility（显示隐藏）、overflow （溢出显示隐藏）</p>\n<table>\n<colgroup>\n<col style=\"width: 17%\" />\n<col style=\"width: 41%\" />\n<col style=\"width: 41%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>方式</th>\n<th>用法</th>\n<th>特性</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>display（显示隐藏）</td>\n<td>该属性本来是设置元素如何显示的；<br /><code>display: none;</code> 用于隐藏对象；<br /><code>display: block;</code> 除了用于转换成块级元素，还可以用于显示元素；</td>\n<td>隐藏元素后，不再占有其原位置；<br />应用广泛，搭配js做网页特效用；</td>\n</tr>\n<tr class=\"even\">\n<td>visibility（显示隐藏）</td>\n<td>用于设置元素的可见性；<br /><code>visibility: visible | hidden | inherit | collapse ;</code></td>\n<td>隐藏元素后，仍占有其原位置；<br /></td>\n</tr>\n<tr class=\"odd\">\n<td>overflow （溢出显示隐藏）</td>\n<td>仅针对溢出元素框的部分进行显示或隐藏；<br /><code>overflow: visible;</code> 设置时<code>clip</code>属性设置将失效；<br /><code>overflow: hidden;</code> 不显示超过对象尺寸的内容；<br /><code>overflow: scroll;</code> 以滚动条形式显示，不管是否内容是否溢出；<br /><code>overflow: auto;</code> 自动判断内容长度，按需添加滚动条；</td>\n<td>如果带有定位属性，应慎用 <code>overflow: hidden;</code> ，会隐藏多余的部分</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"布局\">12. 布局</h2>\n<h3 id=\"常见的布局形式\">常见的布局形式</h3>\n<p><strong>传统布局方式：</strong>普通流（文档流、标准流）、浮动、定位。</p>\n<p><strong>通栏：</strong>是指和浏览器一样宽。</p>\n<p><strong>布局设计准则：</strong></p>\n<ul>\n<li><p>纵向块级元素用标准流，横向块级元素用浮动。</p></li>\n<li><p>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置，复合网页布局第一准则。</p></li>\n<li><p>浮动的盒子只会影响浮动盒子后方的标准流，不影响前方的标准流。</p></li>\n<li><p>应首先采用“一浮全浮”设计原则。</p></li>\n<li><p>在产品列表数量众多、文字数量众多等不能明确盒子高度的情况下不应指定父级盒子的高度， 否则会出现父级盒子因高度限制而出现子元素无法显示的情况，应让子元素撑开父元素。</p></li>\n<li><p>当给父元素设置标准流却未设置高度，而子元素为浮动时，父元素会高度塌陷。因浮动的子元素不占有高度，因此子元素浮动会会导致无高度的标准流父级元素高度塌陷，影响后续布局。</p></li>\n</ul>\n<h3 id=\"css属性书写建议\">CSS属性书写建议</h3>\n<ol type=\"1\">\n<li>布局定位属性：display / position / float / clear / visibility / overflow (建议display第一个写)</li>\n<li>自身属性：width / height / margin / padding / border / background</li>\n<li>文本属性：color / font / text-decoration / text-align / vertical-align / white-space / break-word</li>\n<li>其他属性：content / cursor / border-radius / box-shadow / text-shadow / background:liner-gradient ....</li>\n</ol>\n<h3 id=\"页面布局的整体思路\">页面布局的整体思路</h3>\n<ol type=\"1\">\n<li>确定版心，即可视区</li>\n<li>分析行、块 以及 块中的列模块</li>\n<li>列模块经常浮动布局，确定列大小后确定列的位置</li>\n<li>先结构，后样式</li>\n</ol>\n<h3 id=\"关于导航栏\">关于导航栏</h3>\n<p>实际开发中，不会直接只用<code>&lt;a&gt;</code>来制作导航栏，而是用<code>&lt;li&gt;</code>包含链接的<code>&lt;li&gt;</code>+<code>&lt;a&gt;</code>来制作。</p>\n<p><code>&lt;li&gt;</code>+<code>&lt;a&gt;</code>语义更加清晰，更为有条理的列表型内容。如果直接用<code>&lt;a&gt;</code>，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字存在被搜索引擎降权的风险），从而影响网站排名。</p>\n<h2 id=\"特殊符号\">13. 特殊符号</h2>\n<p>小于号 &lt; <code>&amp;lt;</code></p>\n<p>大于号 &gt; <code>&amp;gt;</code></p>\n<h1 id=\"高级技巧\">高级技巧</h1>\n<p>目标：</p>\n<ul>\n<li><p>能够使用精灵图</p></li>\n<li><p>能够使用字体图标</p></li>\n<li><p>能够写出CSS三角</p></li>\n<li><p>能够写出常见的CSS用户界面样式</p></li>\n<li><p>能够说出常见的布局技巧</p></li>\n</ul>\n<h2 id=\"css-sprites\">CSS Sprites</h2>\n<p>CSS精灵技术的目的：减少客户端向服务器的请求次数，减小服务器的压力，提高网页的加载速度。</p>\n","categories":["Programming"],"tags":["Web","CSS"]},{"title":"目录","url":"/categories/index.html","content":"\n"},{"title":"友情链接","url":"/friends/index.html","content":"<ul>\n<li><a href=\"https://zplusplus.cn\">zplusplus</a>：半导体工艺检测大神的技术积累</li>\n<li><a href=\"https://liewzheng.cn\">liewzheng</a>：islet私人生活类博客</li>\n</ul>\n"},{"url":"/resume/index.html","content":"<div style=\"font-size: 2.25rem; font-weight: 900; margin-bottom: -1.35rem;\">\n刘吉财\n</div>\n<p><strong>嵌入式DSP软件开发工程师</strong>（驱动级）</p>\n<p><strong>BLOG</strong>: https://islet.space<br> <strong>GITEE</strong>: https://gitee.com/tonyliew<br> <strong>MAIL</strong>: liewzheng@foxmail.com<br> <strong>PHONE</strong>: 177-0306-5347<br> <strong>LOCATION</strong>: 珠海 香洲区<br></p>\n<h1 id=\"教育经历\">教育经历</h1>\n<p>2014年-2018年 北京师范大学珠海分校 <strong>电子信息科学与技术专业</strong> <strong>主修</strong><br> 2015年-2018年 北京师范大学珠海分校 <strong>人力资源管理专业</strong> <strong>辅修</strong></p>\n<h1 id=\"项目经历\">项目经历</h1>\n<div style=\"font-size: 1.25rem; font-weight: 900; margin: 1rem 0 0 0;\">\n2021年7月至今 WPT无线谐振传电项目 <br>TI C2000系列 F28004x MCU芯片软件开发\n</div>\n<p>独立负责无线充电项目产品基于TI芯片（F28004X）驱动程序编写，独立负责PID、adcFilter、RS485等控制算法、滤波算法及通信算法的开发，并自行调试、测试以及出具开发及报告。底层驱动开发主要负责众多芯片外设（PWM、CAP、CMPSS、UART、SPI、ADC等）的协同工作，实现从交流市电转直流高压，再转成谐振交流电的目标。最终实现为其他产品提供电源的目标（因保密不能过多谈及）。</p>\n<div style=\"font-size: 1.25rem; font-weight: 900; margin: 1rem 0 0 0;\">\n2021年4月-6月 ANC主动降噪项目（二期）<br>ADI ADSP21479 DSP芯片软件开发\n</div>\n<p>协助负责ADI底层驱动代码编写、调试和测试，独立编写与ADI ADAU1772音频芯片的 I2C 通信代码和 I2S 串行音频通信代码、与 EEPROM 的 SPI 通信代码，实现了由 DSP 与音频芯片之间的高速串行通信。</p>\n<div style=\"font-size: 1.25rem; font-weight: 900; margin: 1rem 0 0 0;\">\n2021年3月-4月 ANC主动降噪项目（二期）<br>ADI ADAU1772 音频芯片开发\n</div>\n<p>独立编写开发 ADI 的 ADAU1772 的音频滤波、增益 和 通信等功能，具体开发内容因项目保密而不能细述。</p>\n<div style=\"font-size: 1.25rem; font-weight: 900; margin: 1rem 0 0 0;\">\n2021年1月~3月 ANC主动降噪项目（一期）<br>TI C6657双核DSP软件开发\n</div>\n<p>协助负责TI底层代码编写、调试和测试，独立编写DSP网络通信 eMAC 外设的驱动代码和双核通信代码，利用TI自带的SysBIOS嵌入式系统和基于Linux裁剪的Socket接口，在整合了DSP处理高速音频通信、任务切换（context switch）、和核间通信（IPC）的同时，实现DSP通过以太网络与PC设备的长连接稳定通信。</p>\n<div style=\"font-size: 1.25rem; font-weight: 900; margin: 1rem 0 0 0;\">\n2020年12月至今 在线教育网站系统\n</div>\n<p>独立发起该项目活动，主导编写适用于千人级部门的在线教育网站系统功能说明书，该项目目前处于后台功能开发阶段，10月份进入测试阶段。</p>\n<h1 id=\"工作经历\">工作经历</h1>\n<div style=\"font-size: 1.25rem; font-weight: 900; margin: 1rem 0 0 0;\">\n2021年1月至今 珠海格力电器股份有限公司 嵌入式软件开发\n</div>\n<p>从事嵌入式软件开发，曾全面负责TI、ADI、Infineon等公司的DSP、MCU、音频、及其他芯片的开发与测试，独立负责开发TI C6657芯片的eMAC外设、F280049芯片的ePWM和ADC外设，负责独立开发ADI音频芯片ADAU1772及ADI公司的ADSP21479芯片的I2C、I2S、SPI通信。独立开发完成下位机的以太网通信，完成高速串行音频芯片通信，及高频逆变器和电路检测代码的编写设计。</p>\n<div style=\"font-size: 1.25rem; font-weight: 900; margin: 1rem 0 0 0;\">\n2019年3月-2020年12月 珠海格力电器股份有限公司 部门培训管理\n</div>\n<p>一边编写代码，一边从事新员工培训，同时独立负责千人级部门的培训跟进、试听、调研、分析、管理和体系建设，期间获得公司优秀培训管理员奖。</p>\n<div style=\"font-size: 1.25rem; font-weight: 900; margin: 1rem 0 0 0;\">\n2018年10月-2019年3月 珠海原子科技有限公司 嵌入式软件开发\n</div>\n<p>参与智慧校园安全监控系统项目，独立负责ESP8266 和 ESP32的蓝牙、WiFi通信开发，所有开发均基于成熟产品，开发IDE为Arduino，主要工作是代码编写和性能测试。</p>\n<div style=\"font-size: 1.25rem; font-weight: 900; margin: 1rem 0 0 0;\">\n2018年3月-2018年10月 珠海天藤科技有限公司 芯片前端开发\n</div>\n<p>跟随毕业导师（英国毕业博士）从事芯片前端开发（使用Verilog 进行 FPGA 开发）和3D-IC热仿真（使用Ansys Icepak进行芯片建模、材料分析和热仿真）工作。</p>\n<h1 id=\"获奖经历\">获奖经历</h1>\n<div style=\"font-size: 1.25rem; font-weight: 900; margin: 1rem 0 0 0;\">\n2021年2月 创新格力行动·第七届创新大赛 智能家具场景设计三等奖\n</div>\n<p>主导智能家居场景的解决方案设计，主要负责智能场景下的产品选型、电气要求和价格控制等工作。</p>\n<div style=\"font-size: 1.25rem; font-weight: 900; margin: 1rem 0 0 0;\">\n2020年12月 格力电器股份有限公司 年度优秀培训管理员奖\n</div>\n<h1 id=\"计算机语言\">计算机语言</h1>\n<p>以下计算机语言按学习和工作应用时间强度进行排序：</p>\n<ul>\n<li>C/C++</li>\n<li>Letex/Markdown</li>\n<li>gnuplot</li>\n<li>HTML/CSS</li>\n<li>Python</li>\n<li>Verilog</li>\n</ul>\n<h1 id=\"自我介绍\">自我介绍</h1>\n<ul>\n<li>熟悉嵌入式 底层外设（PWM / ADC / MAC 等）控制、大部分常用网络通信协议（TCPIP / BLE / 802.11）以及常用串行通信协议（UART / SPI / I2C / I2S / CAN ）</li>\n<li>对有挑战的事情比较感兴趣，解决bug的能力较强</li>\n<li>自学能力较强（自学Linux操作应用及其内核、HTML、CSS、Wireshark、Python爬虫、网络建站、博客搭建、GNUPLOT绘图、Latex和Markdown等）</li>\n<li>喜欢成就感较高的事情。</li>\n</ul>\n"},{"title":"标签","url":"/tags/index.html","content":"\n"}]