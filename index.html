<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;islet.space&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script>
<meta name="description" content="笔记分享的旮旯孤岛而已">
<meta property="og:type" content="website">
<meta property="og:title" content="Coder的孤岛">
<meta property="og:url" content="http://islet.space/index.html">
<meta property="og:site_name" content="Coder的孤岛">
<meta property="og:description" content="笔记分享的旮旯孤岛而已">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liewzheng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://islet.space/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;en&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Coder的孤岛</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Coder的孤岛</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">islet of the coder</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liewzheng</p>
  <div class="site-description" itemprop="description">笔记分享的旮旯孤岛而已</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/12/26/Hardware/TI/Ti%C2%A0SysBIOS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/26/Hardware/TI/Ti%C2%A0SysBIOS/" class="post-title-link" itemprop="url">Ti SysBios</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-26 23:58:32" itemprop="dateCreated datePublished" datetime="2021-12-26T23:58:32+08:00">2021-12-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-26 00:16:13" itemprop="dateModified" datetime="2021-04-26T00:16:13+08:00">2021-04-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hardware/" itemprop="url" rel="index"><span itemprop="name">Hardware</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[TOC]</p>
<h1 id="SYS-BIOS"><a href="#SYS-BIOS" class="headerlink" title="SYS/BIOS"></a>SYS/BIOS</h1><ul>
<li><p>The Ethernet Media Access Controller (EMAC) module provides an efficient interface between the device core processor and the networked community.</p>
</li>
<li><p>The EMAC controls the flow of packet data from the processor to the PHY. The MDIO module controls PHY configuration and status monitoring.</p>
</li>
<li><p>Both the EMAC and the MDIO modules interface to the DSP through a custom interface that allows efficient data transmission and reception. </p>
</li>
<li><p>This custom interface is referred to as the EMAC control module, and is considered integral to the EMAC/MDIO peripheral.</p>
</li>
<li><p>The EMAC control, EMAC, and MDIO modules all have control registers. These registers are memory <strong>mapped into device memory space</strong> via the device configuration bus.【EMAC控制器、EMAC、MDIO模块都有控制寄存器，寄存器地址通过设备控制总线写入设备内存空间。】</p>
</li>
<li><p>【Descriptor 不存储任何缓冲数据，仅仅作为数据描述包而存在。主要结构为pNext、pBuffer、Buffer Offset、Buffer Length、Flags和Packet Length。其中，pBuffer是指向数据包Packet的指针存储块。】</p>
</li>
</ul>
<h2 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h2><h3 id="IDE-Installation"><a href="#IDE-Installation" class="headerlink" title="IDE Installation"></a>IDE Installation</h3><h4 id="SETUP"><a href="#SETUP" class="headerlink" title="SETUP"></a>SETUP</h4><h4 id="CONFIGURATIONS"><a href="#CONFIGURATIONS" class="headerlink" title="CONFIGURATIONS"></a>CONFIGURATIONS</h4><h3 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h3><h4 id="开发及编译环境"><a href="#开发及编译环境" class="headerlink" title="开发及编译环境"></a>开发及编译环境</h4><ol>
<li>CSS安装</li>
<li>TI编译工具安装</li>
<li>SYS/BIOS安装</li>
<li>BIOS-MCSDK软件包安装</li>
<li>BIOS-MCSDK软件包<em>补丁</em>安装</li>
<li>XDC-Tools安装</li>
<li>pdk_C6657软件包</li>
</ol>
<table>
<thead>
<tr>
<th>安装流程</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CCS安装</strong></td>
<td>CCS工程操作本体软件</td>
</tr>
<tr>
<td><strong>TI编译工具安装</strong></td>
<td>TI某型号设备编译软件，一定要确保是否安装，没有的话无法生成工程文件</td>
</tr>
<tr>
<td><strong>SYS/BIOS安装</strong></td>
<td>SYS/BIOS RTOS系统（可能安装BIOS_MCSDK时自带）</td>
</tr>
<tr>
<td><strong>BIOS-MCSDK软件包安装</strong></td>
<td>安装时会生成 <code>ndk_2_21_01_38</code>，需要删除，不删除会导致后面无法安装其他软件包</td>
</tr>
<tr>
<td><strong>BIOS-MCSDK软件包<em>补丁</em>安装</strong></td>
<td>必须安装，否则会出错</td>
</tr>
<tr>
<td><strong>XDC-Tools安装</strong></td>
<td>装CSS的时候就已经能自带XDC-Tools了，也可以单独更新版本</td>
</tr>
<tr>
<td><strong>pdk_C6657软件包</strong></td>
<td>安装BIOS_MCSDK时自带</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<ul>
<li>部分SDK、组件包可能会线下兼容，但是版本包带不带特殊标识，如XDCTOOLS个别版本带 <code>_core</code> 的，可能会导致不兼容<code>gr</code> platform。</li>
<li>组件包安装完毕之后需要在 CCS 的 <code>Products and Repositories</code> 中进行挂载和选择。</li>
</ul>
<h4 id="工程生成、导入与重编"><a href="#工程生成、导入与重编" class="headerlink" title="工程生成、导入与重编"></a>工程生成、导入与重编</h4><p>工程的生成、导入与重编主要是针对他人写的代码，未针对我的硬件生成对应的工程文件，因而需要按照我的编译环境和硬件生成对应的工程文件，进而应用到我的硬件上。</p>
<h5 id="工程生成"><a href="#工程生成" class="headerlink" title="工程生成"></a>工程生成</h5><p>通过执行命令行工具 <code>pdksetupenv.bat</code> 和 <code>pdkProjectCreate.bat</code> 在对应的工程文件包生成工程文件夹 <code>project</code> 。</p>
<p><strong>注意事项：</strong> </p>
<blockquote>
<p><em>命令行工具中设置了一些关于路径的变量，如果安装了更新版本的软件包则因进入命令行文件对相应的文件路径进行修改。</em> 如下，XDC-TOOLS 可能因为版本问题而导致 <code>XDC_INSTALL_PATH</code> 变量出错，各变量也应一一对照安装路径的文件夹名称进行审核。</p>
<p><code>pdksetupenv.bat</code> 文件下的变量设置：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> MCSDK_INSTALL_PATH=D:\TexasInstruments\</span><br><span class="line"><span class="built_in">set</span> XDC_INSTALL_PATH=<span class="variable">%MCSDK_INSTALL_PATH%</span>\xdctools_3_25_06_96</span><br></pre></td></tr></table></figure>

<p><code>pdkProjectCreate.bat</code> 文件下的变量设置如下：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">@REM 需修改成实际安装路径</span></span><br><span class="line"><span class="built_in">set</span> CCS_INSTALL_PATH=&quot;D:\ti\ccsv7&quot;</span><br><span class="line"></span><br><span class="line"><span class="comment">@REM 以下各文件版本需要根据当前最新使用的软件包版本来调整</span></span><br><span class="line"><span class="built_in">set</span> CGT_VERSION=<span class="number">8</span>.<span class="number">3</span>.<span class="number">8</span></span><br><span class="line"><span class="built_in">set</span> XDC_VERSION=<span class="number">3</span>.<span class="number">32</span>.<span class="number">2</span>.<span class="number">25</span>_core</span><br><span class="line"><span class="built_in">set</span> BIOS_VERSION=<span class="number">6</span>.<span class="number">33</span>.<span class="number">06</span>.<span class="number">50</span></span><br><span class="line"><span class="built_in">set</span> IPC_VERSION=<span class="number">1</span>.<span class="number">24</span>.<span class="number">03</span>.<span class="number">32</span></span><br><span class="line"><span class="built_in">set</span> EDMA_VERSION=<span class="number">02</span>.<span class="number">11</span>.<span class="number">05</span>.<span class="number">02</span></span><br><span class="line"><span class="built_in">set</span> NDK_VERSION=<span class="number">2</span>.<span class="number">21</span>.<span class="number">02</span>.<span class="number">43</span></span><br><span class="line"><span class="built_in">set</span> PDK_VERSION=<span class="number">1</span>.<span class="number">1</span>.<span class="number">2</span>.<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>在以上文件都设置好以后，还需要进入CCS，点击 <code>WINDOWS</code> -&gt; <code>PREFERENCES</code> -&gt; <code>CODE COMPOSER STUDIO</code> -&gt; <code>PRODUCTS</code> , 在 <code>INSTALLED PRODUCTS</code> 面板下找到已安装的软件包，如果未找到，点击 <code>INSTALL</code> , 选择 <code>/ti</code> 路径进行软件包安装。</p>
<p>如未挂载软件包，可能会出现错误提示如：<code>!ERROR: Unknown product-type ID &#39;com.ti.sdo.edma3&#39;!</code></p>
</blockquote>
<p>找到示例文件，在示例文件的 <code>/src/</code> 文件夹下，按住 <code>shift键</code> 并 点击鼠标右键，选择 <code>在此处打开Powershell窗口</code> ，输入绝对路径和文件名称并按回车运行，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\ti\pdk_C6657_1_1_2_6\packages\ti\drv\pdksetupenv.bat</span><br><span class="line">D:\ti\pdk_C6657_1_1_2_6\packages\ti\drv\pdkProjectCreate.bat</span><br></pre></td></tr></table></figure>

<p>成功时结果如下示：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PDK_SHORT_NAME: <span class="title">I</span>:\03.<span class="title">TexasInstruments_Workspace</span>\<span class="title">tl</span>-<span class="title">led</span>-<span class="title">flash</span>\<span class="title">src</span></span></span><br><span class="line"><span class="function">*****************************************************************************</span></span><br><span class="line"><span class="function"><span class="title">Detecting</span> <span class="title">UnitTest</span> <span class="title">Projects</span> <span class="title">in</span> <span class="title">PDK</span> <span class="title">and</span> <span class="title">importing</span> <span class="title">them</span> <span class="title">in</span> <span class="title">the</span> <span class="title">workspace</span> &quot;<span class="title">I</span>:\03.<span class="title">TexasInstruments_Workspace</span>\<span class="title">tl</span>-<span class="title">led</span>-<span class="title">flash</span>\<span class="title">src</span>\<span class="title">project</span>&quot;</span></span><br><span class="line"><span class="function">找不到文件</span></span><br><span class="line"><span class="function">*****************************************************************************</span></span><br><span class="line"><span class="function"><span class="title">Detecting</span> <span class="title">Example</span> <span class="title">Projects</span> <span class="title">in</span> <span class="title">PDK</span> <span class="title">and</span> <span class="title">importing</span> <span class="title">them</span> <span class="title">in</span> <span class="title">the</span> <span class="title">workspace</span> &quot;<span class="title">I</span>:\03.<span class="title">TexasInstruments_Workspace</span>\<span class="title">tl</span>-<span class="title">led</span>-<span class="title">flash</span>\<span class="title">src</span>\<span class="title">project</span>&quot;</span></span><br><span class="line"><span class="function">找不到文件</span></span><br><span class="line"><span class="function">*****************************************************************************</span></span><br><span class="line"><span class="function"><span class="title">Detecting</span> <span class="title">TL</span> <span class="title">Projects</span> <span class="title">and</span> <span class="title">importing</span> <span class="title">them</span> <span class="title">in</span> <span class="title">the</span> <span class="title">workspace</span> &quot;<span class="title">I</span>:\03.<span class="title">TexasInstruments_Workspace</span>\<span class="title">tl</span>-<span class="title">led</span>-<span class="title">flash</span>\<span class="title">src</span>\<span class="title">project</span>&quot;</span></span><br><span class="line"><span class="function"><span class="title">Detected</span> <span class="title">Example</span> <span class="title">Project</span>: <span class="title">tl</span>-<span class="title">led</span>-<span class="title">flash</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="title">Creating</span> <span class="title">project</span> &#x27;<span class="title">tl</span>-<span class="title">led</span>-<span class="title">flash</span>&#x27;...</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Done</span>!</span></span><br><span class="line"><span class="function"><span class="title">Copying</span> <span class="title">macros.ini</span></span></span><br><span class="line"><span class="function">已复制         1 个文件。</span></span><br></pre></td></tr></table></figure>



<p>遇到关于 的问题</p>
<p><code>D:\ti\ccsv7\tools\compiler\ti-cgt-c6000_8.2.2\lib</code></p>
<h2 id="XDC-STD"><a href="#XDC-STD" class="headerlink" title="XDC/STD"></a>XDC/STD</h2><h3 id="DETAILS"><a href="#DETAILS" class="headerlink" title="DETAILS"></a>DETAILS</h3><p>In addition to the interfaces specified below, this package  also supplies a C/C++ header, <code>std.h</code> that facilitates the creation of  portable sources. This header defines a set of “base” types that enable the  creation of C-code that is portable between any two targets. C source code that  relies exclusively on these types is portable to all targets and platforms.  Where appropriate, the types defined below are related to the types defined in  the library headers prescribed by the C99 standard (ISO/IEC 9899:1999).</p>
<p>Why not simply use the C99 types? Having a unique set of  names provides <strong>a layer of insulation between a portable code base and a  particular compiler</strong>; e.g., even if a compiler does not support the C99 types or  defines them inappropriately for a particular device, it is possible to use the  compiler without changing the code base. Thus, the developer is not forced to  choose the lesser of two evils: waiting for a change to the compiler or forking  the code base for a particular compiler device combination.</p>
<p>There are several situations where a small separate set of  <strong>portable types</strong> can help the maintainability of a code base.</p>
<ul>
<li>not all of the types described in the C99 standard are required to be  defined by conformant implementations nor is it possible for all devices to  implement some of the types specified (e.g., <code>int8_t</code> is not implemented  on C54 devices); so it is difficult to identify non-portable source code. </li>
<li>not all compilers provide C99 type support; if XDC supplies the type  definition and the compiler is updated to include C99 types, a compilation error  will occur if the source includes the C99 headers. </li>
<li>not all compiler and device combinations are conformant; even high quality  compilers may not properly define the types for each device supported by  compiler. </li>
</ul>
<h3 id="USAGE"><a href="#USAGE" class="headerlink" title="USAGE"></a>USAGE</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/std.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>To compile sources that include <code>xdc/std.h</code>, <strong>two  symbols must be defined</strong> before including this header:</p>
<ul>
<li><p><code>xdc_target_types__</code></p>
<p>the package qualified path of the target’s standard types header; e.g.,  <code>ti/targets/std.h</code>. This value is specified in the target’s  <code>stdInclude</code> config parameter; see <code>xdc.bld.ITarget.stdInclude</code> </p>
</li>
<li><p><code>xdc_target_name__</code></p>
<p>the target’s module name without the package prefix; e.g., <code>C64</code>  rather than <code>ti.targets.C64</code>. </p>
</li>
</ul>
<p>For example, to compile sources for the  <code>ti.targets.C64</code> target using TI’s <code>cl6x</code> compiler, the following  command line is sufficient:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl6x -Dxdc_target_types__&#x3D;ti&#x2F;targets&#x2F;std.h -Dxdc_target_name__&#x3D;C64</span><br></pre></td></tr></table></figure>

<p>Each of the type names below has an equivalent “long name”;  i.e., a name that has an “<code>xdc_</code>“ prefix. For example, the type  <code>Bool</code> can also be written as “<code>xdc_Bool</code>“. <strong>Long names exist to  avoid conflicts with names defined or used by existing code bases.</strong></p>
<p>In the event that one of the short type names below  conflicts with another type name (that can not be changed), it is possble to  disable the short names by defining the symbol <code>xdc__nolocalnames</code> before  including <code>xdc/std.h</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define xdc__nolocalnames</span><br><span class="line">#include &lt;xdc&#x2F;std.h&gt;</span><br></pre></td></tr></table></figure>



<h3 id="STANDARD-TYPES"><a href="#STANDARD-TYPES" class="headerlink" title="STANDARD TYPES"></a>STANDARD TYPES</h3><p>This header may be included multiple times and defines the  following target-dependent types:</p>
<ul>
<li><p><code>Bool</code></p>
<blockquote>
<p>this type is large enough to hold the values <code>0</code> or <code>1</code>. The  constants TRUE and FALSE are of this type; see below. </p>
</blockquote>
</li>
<li><p><code>String</code></p>
<blockquote>
<p>this type is defined to be a <code>char *</code> and exists to allow code to  distinguish between pointers to buffers of raw data and ‘\0’ terminated strings. </p>
</blockquote>
</li>
<li><p><code>CString</code></p>
<blockquote>
<p>this type is defined to be a <code>const char *</code> and exists to allow code  to distinguish between pointers to a modifiable ‘\0’ terminated sequence of  characters (i.e., a <code>String</code>) and one that is not modifiable (e.g., a  literal string such as <code>&quot;hello world\n&quot;</code>). </p>
</blockquote>
</li>
<li><p><code>Int</code>n, where n = 8, 16, or 32</p>
<blockquote>
<p>signed integer type that is large enough to hold n bits; the actual target  type may by be larger than n. This type is equivalent to one of the C99 types  <code>int_least</code>n<code>_t</code> or <code>int_fast</code>n<code>_t</code>; see Section  7.18. </p>
</blockquote>
</li>
<li><p><code>UInt</code>n, where n = 8, 16, or 32</p>
<blockquote>
<p>unsigned integer type that is large enough to hold n bits; the actual target  type may by be larger than n. This type is equivalent to one of the C99 types  <code>uint_least</code>n<code>_t</code> or <code>uint_fast</code>n<code>_t</code>; see ISO/IEC  9899:1999 Section 7.18. </p>
</blockquote>
</li>
<li><p><code>Bits</code>n, where n = 8, 16, or 32</p>
<blockquote>
<p>unsigned integer type that is precisely n bits. Not all targets support all  values of n; if the target does not support an exact size the corresponding type  is not defined. This type is equivalent to the corresponding C99 type  <code>uint</code>n<code>_t</code>; see ISO/IEC 9899:1999 Section 7.18. </p>
</blockquote>
</li>
<li><p><code>Fxn</code></p>
<blockquote>
<p>this type is a pointer to code; it can hold a pointer to any function. </p>
</blockquote>
</li>
<li><p><code>Ptr</code></p>
<blockquote>
<p>this type is a pointer to data; it can hold a pointer to any data structure. </p>
</blockquote>
</li>
<li><p><code>IArg</code></p>
<blockquote>
<p>this integer type is large enough to hold a <code>Fxn</code>, <code>Ptr</code>, or  <code>Int</code>. </p>
</blockquote>
</li>
<li><p><code>UArg</code></p>
<blockquote>
<p>this unsigned integer type is large enough to hold a <code>Fxn</code>,  <code>Ptr</code>, or <code>Int</code>. </p>
</blockquote>
</li>
<li><p><code>LLong</code></p>
<blockquote>
<p>this long integer type is large enough to hold a <code>Long</code> and is  defined as a ‘long long’ type on targets that support this type; otherwise, it  is simply a <code>Long</code>. Note that C99 requires the <code>long long</code> type to  be at least 64-bits wide (See ISO/IEC 9899:1999 Section 5.2.4.2.1). But some  compilers do not support 64-bit integral types and some don’t support the  <code>long long</code> even though they do support 64-bit integral types. Since  these variations limit the portability of valid C sources, the LLong type is  always defined, is always at least as wide as the <code>Long</code> type, and is at  least 64-bits wide for targets that support 64-bit integral types. </p>
</blockquote>
</li>
<li><p><code>ULLong</code></p>
<blockquote>
<p>this unsigned long integer type is large enough to hold a <code>ULong</code> and  is defined as a ‘unsigned long long’ type on targets that support this type;  otherwise, it is simply a <code>ULong</code>. </p>
</blockquote>
</li>
</ul>
<p>The <code>xdc/std.h</code> header also defines the following  aliases for the base C types. These aliases exist so that C sources can  consistently follow a naming convention in which all type names are written in  camel-case.</p>
<ul>
<li><p><code>Char</code> and <code>UChar</code></p>
<blockquote>
<p>aliases for <code>char</code> and <code>unsigned char</code>, respectively </p>
</blockquote>
</li>
<li><p><code>Short</code> and <code>UShort</code></p>
<blockquote>
<p>aliases for <code>short</code> and <code>unsigned short</code>, respectively </p>
</blockquote>
</li>
<li><p><code>Int</code> and <code>UInt</code></p>
<blockquote>
<p>aliases for <code>int</code> and <code>unsigned int</code>, respectively </p>
</blockquote>
</li>
<li><p><code>Long</code> and <code>ULong</code></p>
<blockquote>
<p>aliases for <code>long</code> and <code>unsigned long</code>, respectively </p>
</blockquote>
</li>
<li><p><code>Double</code> and <code>LDouble</code></p>
<blockquote>
<p>aliases for <code>double</code> and <code>long double</code>, respectively </p>
</blockquote>
</li>
<li><p><code>SizeT</code></p>
<blockquote>
<p>alias for <code>size_t</code> </p>
</blockquote>
</li>
<li><p><code>VaList</code></p>
<blockquote>
<p>alias for <code>va_list</code> </p>
</blockquote>
</li>
</ul>
<p>The types above are defined for all targets. Some targets  can support the following additional types. Since these types are not always  supported by a target, these types should only be used when no other type  sufficies.</p>
<ul>
<li><p><code>Bits</code>n, where n = 8, 16, or 32</p>
<blockquote>
<p>this unsigned integer type is precisely n-bits wide. This type is equivalent  to the optional C99 type <code>uint</code>n<code>_t</code>; see ISO/IEC 9899:1999  Section 7.18.1.1. This type is defined if and only if the preprocessor macro  <code>xdc__BITS</code>n<code>__</code> is defined. </p>
</blockquote>
</li>
</ul>
<h3 id="64-BIT-TYPES"><a href="#64-BIT-TYPES" class="headerlink" title="64 BIT TYPES"></a>64 BIT TYPES</h3><p>Although the C99 standard requires support for 64-bit types,  not all compiler/device combinations can usefully support them. As a result, the  64-bit types described here may not be defined for all targets. For each type  there is a corresponding pre-processor macro which is defined if and only if the  type is supported.</p>
<ul>
<li><p><code>Int64</code></p>
<blockquote>
<p>signed integer type that is large enough to hold 64 bits; the actual target  type may by be wider than 64 bits. This type is equivalent to one of the C99  types <code>int_least64_t</code> or <code>int_fast64_t</code>; see Section 7.18. This  type is defined if and only if the preprocessor macro <code>xdc__INT64__</code> is  defined. </p>
</blockquote>
</li>
<li><p><code>UInt64</code></p>
<blockquote>
<p>unsigned integer type that is large enough to hold n bits; the actual target  type may by be wider than 64 bits. This type is equivalent to one of the C99  types <code>uint_least64_t</code> or <code>uint_fast64_t</code>; see ISO/IEC 9899:1999  Section 7.18. This type is defined if and only if the preprocessor macro  <code>xdc__INT64__</code> is defined. </p>
</blockquote>
</li>
<li><p><code>Bits64</code></p>
<blockquote>
<p>unsigned integer type that is precisely 64 bits wide. If the target does not  support an exact 64-bit size, this type is not defined. This type is equivalent  to the corresponding C99 type <code>uint64_t</code>; see ISO/IEC 9899:1999 Section  7.18. This type is defined if and only if the preprocessor macro  <code>xdc__BITS64__</code> is defined. </p>
</blockquote>
</li>
</ul>
<p><em>The table below is from <strong>Log_print6()</strong> in the <strong>XDC/RUNTIME/LOG.H</strong>.</em></p>
<p>However, because the declared type of the arguments is <code>IArg</code>, all pointer  arguments must be cast to an <code>IArg</code> type.<code>IArg</code> is an integral type large enough to hold any pointer or an  <code>int</code>. So, casting a pointer to an <code>IArg</code> does not cause any loss  of information and C’s normal integer conversions make the cast unnecessary for  integral arguments.</p>
<p>The format string can use the following conversion  characters. However, it is important to recall that all arguments referenced by  these conversion characters have been converted to an <code>IArg</code> prior to  conversion; so, the use of “length modifiers” should be avoided.</p>
<table>
<thead>
<tr>
<th>Conversion Character</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>%c</td>
<td>Character</td>
</tr>
<tr>
<td>%d</td>
<td>Signed integer</td>
</tr>
<tr>
<td>%u</td>
<td>Unsigned integer</td>
</tr>
<tr>
<td>%x</td>
<td>Unsigned hexadecimal integer</td>
</tr>
<tr>
<td>%o</td>
<td>Unsigned octal integer</td>
</tr>
<tr>
<td>%s</td>
<td>Character string</td>
</tr>
<tr>
<td>%p</td>
<td>Pointer</td>
</tr>
<tr>
<td>%f</td>
<td>Single precision floating point (float)</td>
</tr>
</tbody></table>
<p><code>usertype.h</code> 中的定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>           INT8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">short</span>          INT16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>            INT32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>  UINT8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> UINT16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>   UINT32;</span><br></pre></td></tr></table></figure>



<h2 id="SYS-BIOS-RTOS"><a href="#SYS-BIOS-RTOS" class="headerlink" title="SYS/BIOS RTOS"></a>SYS/BIOS RTOS</h2><p>我们依赖操作系统来提供底层和中间件的服务，如让设备启动，处理基本IO口，允许多个程序并行运行，为多个正在运行的程序分配内存和磁盘空间，以及通过USB和以太网口等通讯堆栈来实现更多复杂的IO口通讯。</p>
<h3 id="RTOS的优点"><a href="#RTOS的优点" class="headerlink" title="RTOS的优点"></a>RTOS的优点</h3><ul>
<li>模块化设计，线程的使用使各任务得到最大化独立；</li>
<li>提供模块及接口以方便地驱动外设；</li>
<li>代码可移植性/脱离于内核处理器；</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li>线程是一组存储在存储器的代码，一旦寄存器被正确初始化，CPU就会执行这些代码。</li>
<li>定义和管理任何需要被操作的内容<ul>
<li>包括程序指针、堆栈和寄存器等值</li>
<li>这些被统称“上下文”【每个线程都会被定义上下文，包括<code>程序计数器</code>、<code>堆栈</code>和<code>关键寄存器</code>的信息】</li>
<li>会有一系列的线程需要在指定时间被执行，RTOS会按一定标准在指定时间选择线程执行。</li>
</ul>
</li>
<li>线程可以使任何类型的，SYS/BIOS定义了四种线程类型（优先级降序排列）：<ul>
<li>硬件中断</li>
<li>软件中断</li>
<li>任务</li>
<li>空闲</li>
</ul>
</li>
<li>各线程有 隐式的(implicity) 和 显示的(explicity)（可能有）优先级<ul>
<li>隐式的优先级由线程类型决定</li>
<li>显式的优先级由软件编程者决定</li>
</ul>
</li>
<li>允许抢占（或者上下文切换）<ul>
<li>基于优先级的调度管理机制保证了最高优先级的线程能够在第一时间被执行</li>
</ul>
</li>
<li>线程之间的交互<ul>
<li>阻断</li>
<li>通信</li>
<li>同步</li>
</ul>
</li>
</ul>
<h3 id="TIMER-and-CLOCK"><a href="#TIMER-and-CLOCK" class="headerlink" title="TIMER and CLOCK"></a>TIMER and CLOCK</h3><ul>
<li><strong>定时器模块 TIMER</strong></li>
<li>管理定时器外设</li>
<li>提供虚拟的目标/设备概念<ul>
<li>【通过操作定时器模块而不是硬件外设，开发人员能够更轻松更直观地管理定时器，且在多个不同TI芯片中移植式，代码更具可移植性】</li>
<li>【对于SYS/BIOS而言，可以产生无限数量的定时器】</li>
</ul>
</li>
<li><strong>时钟模块 CLOCK</strong><ul>
<li>管理BIOS的“心脏节拍“</li>
<li>在指定时间触发功能（单次或周期性）</li>
<li>使用定时器模块或者应用层模块的“节拍”来处理输入事件</li>
<li>【时钟模块所在的层位于定时器之上】</li>
<li>【时钟模块可以通过定时器模块将系统中的外部事件引入作为输入事件，或者使用定时器模块产生的周期性节拍，基于这些输入事件，时钟模块可以产生软件中断，或者时钟模块还能提供一种服务，以便一次性或者周期性地触发任意数量的不同函数】</li>
<li>【时钟实例中包含了对两个时间段的定义，第一个时间段的定义称为<code>超时时间量</code>，它定义了时钟实例的启动和首次触发相关函数的时间量，通常会在应用程序中，通过显示的调用时钟来启动一个时钟实例，如果创建时钟实例时，标志为TRUE，则实例会在创建后立即启动；第二个时间段的定义标志了相关函数首次调用和后续调用之间<code>持续时间量</code>；对于一次性的时钟实例，只需定义超时时间量，持续时间量将为0；相关函数都是由时钟实例的中断来调用的，这意味着必须在同一线程中启动或停止时钟，而不能在其他线程中任意启动或停止时钟】</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动/停止时钟实例，仅能通过时钟SWI调用</span></span><br><span class="line">Clock_start()</span><br><span class="line">Clock_stop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动/停止定时器底层产生时间节拍</span></span><br><span class="line"><span class="comment">// 【`时钟停止启动` 和 `时钟节拍停止`，用来为驱动时钟模块提供底层定时器】</span></span><br><span class="line">Clock_tickStart()</span><br><span class="line">Clock_tickStop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改停止的时钟实例</span></span><br><span class="line"><span class="comment">// 【设置 `时钟周期`、`超时`、`功能` 函数，用于修改时钟实例的参数】</span></span><br><span class="line">Clock_setPeriod()</span><br><span class="line">Clock_setTimeout()</span><br><span class="line">Clock_setfunc()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许修改时钟实例的参数，基于新的定时器频率</span></span><br><span class="line"><span class="comment">// 当CPU的频率发生变化时，可以通过此函数对时钟进行重新配置</span></span><br><span class="line">Clock_tickReconfig()</span><br></pre></td></tr></table></figure>

<ul>
<li>时间戳模块<ul>
<li>为代码的基准测试提供便捷的时间戳服务</li>
<li>允许时间戳记录RTA日志</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*前两个变量的类型由时钟模块定义*/</span></span><br><span class="line">Clock_Params clockParams;               <span class="comment">//用于容纳所有的时钟实例参数</span></span><br><span class="line">Task_Handle myClock;                    <span class="comment">//用于存储将要创建的时钟实例的句柄</span></span><br><span class="line">Error_block eb;                         <span class="comment">//错误块变量，若创建失败可以获取失败原因的信息</span></span><br><span class="line"></span><br><span class="line">Clock_Params_init(&amp;clockParams);        <span class="comment">//时钟实例初始化参数，已默认值填充参数结构</span></span><br><span class="line"><span class="comment">/*下两句分别更新与默认值不同的参数*/</span></span><br><span class="line">clockParams.period = <span class="number">4</span>;                 <span class="comment">//Every 4 Clock ticks</span></span><br><span class="line">ClockParams.startFlag = TRUE;           <span class="comment">//Start immediately</span></span><br><span class="line">Error_init(&amp;eb);                        <span class="comment">//错误块变量，若创建失败可以获取失败原因的信息</span></span><br><span class="line"></span><br><span class="line">myClock = Clock_create((Clock_FuncPtr)clockHandler,<span class="number">4</span>,&amp;clockParams,&amp;eb); <span class="comment">//三参数，时钟实例创建，并返回句柄给myClock</span></span><br></pre></td></tr></table></figure>



<p><strong>在XGCONF中配置时钟参数：</strong></p>
<table>
<thead>
<tr>
<th>NAME</th>
<th>VALUE</th>
</tr>
</thead>
<tbody><tr>
<td>tickSource</td>
<td><code>tickSource_TIMER</code> ：选择定时器（周期性调用Clock_tick)； <code>tickSource_User</code>：选择外部中断触发调用Clock_tick；<code>tickSource_NULL</code>：没有时钟API，没有超时【由信号量写入的调用不能具有超时值】</td>
</tr>
<tr>
<td>timerId</td>
<td>【用于指定芯片实际使用的定时器外设】<code>-1</code>：默认定时器</td>
</tr>
<tr>
<td>swiPiority</td>
<td>【时钟模块是由底层定时器模块触发软件中断来调用的，因此其SWI的优先级可以设置】默认值 <code>15</code></td>
</tr>
<tr>
<td>tickPeriod</td>
<td>【系统节拍的周期】默认值 <code>1000</code> usec</td>
</tr>
</tbody></table>
<p><strong>时钟实例化参数：</strong></p>
<table>
<thead>
<tr>
<th>NAME</th>
<th>VALUE</th>
</tr>
</thead>
<tbody><tr>
<td>clockFxn</td>
<td>[Creat Args]【需要被调用的实例函数在clockfxn字段中】</td>
</tr>
<tr>
<td>timeout</td>
<td>[Creat Args]【从时钟开始运行到相关函数被首次调用的初始时间值】</td>
</tr>
<tr>
<td>startFlag</td>
<td>[Params]【将指定时钟是在BIOS的调度程序开始运行时立即启动，还是由应用程序调用时钟的启动API】<code>true</code>：立即启动；<code>false</code>：调用；<code>Clock_start()</code> ：后启动</td>
</tr>
<tr>
<td>period</td>
<td>[Params]【在首次调用函数后，需要确定后续函数调用的间隔】<code>0</code>：单次调用；</td>
</tr>
<tr>
<td>arg</td>
<td>[Params] argument to clockFxn【用户可以将静态变量传递给相关函数，这样做可以将多个时钟实例共同使用单一函数，由于每个实例都可以向被调用的函数传递一个不同的值，因此在实现函数时可以根据调用到的时钟采取不同的操作】</td>
</tr>
</tbody></table>
<h3 id="HWI-and-Idle"><a href="#HWI-and-Idle" class="headerlink" title="HWI and Idle"></a>HWI and Idle</h3><p>嵌入式硬件中断的原理：前台/后台调度（主要由低优先级任务、无线循环任务和ISR构成，复杂性较低，存在不足）</p>
<ul>
<li>应用程序循环处理由硬件中断服务程序职位的标志位</li>
<li>ISR抢断主循环，执行中断服务【ISR 被称为前台进程】</li>
</ul>
<p>SYS/BIOS在BIOS之上实行 <code>Idle loop</code> + <code>Hwi</code> + <code>main()</code> 的方式：</p>
<ul>
<li>空闲循环是优先级最低的无限循环（并不代表优先级不重要），所执行的是一系列静态配置的后台程序</li>
<li>典型应用：用户界面，内置的系统测试，测量，以及低功耗模式</li>
<li>被最高优先级线程抢断/从被抢断的地方恢复运行</li>
<li><strong>ISR以HWI线程的方式运行，任意HWI都能抢断空闲循环</strong></li>
</ul>
<p><strong>后台空闲循环（线程）</strong></p>
<blockquote>
<p>The <strong>background Idle Loop</strong> is the thread with the lowest priority of all. It runs in a loop when the CPU is not busy running another thread. </p>
</blockquote>
<ul>
<li><p>When tasks are enabled, the Idle Loop is implemented as the only task running at priority 0. </p>
</li>
<li><p>When tasks are disabled, the Idle Loop is fallen into after the application’s “main()” function is called.（空闲循环会在应用程序main()函数被调用后陷入？）</p>
</li>
</ul>
<p><strong>HWI的中断及恢复流程（中断调度流程）：</strong></p>
<ol>
<li>屏蔽任务调度【HWI是被视为隐式的较高优先级线程，因此不希望所有目前最高优先级的线程抢断HWI线程，如果应用程序没有启用任务模块，该段启动任务调度的程序将被优化出中断调度程序，以便确保中断调度程序能够高效执行】</li>
<li>转向ISR堆栈（如果没有指向该堆栈）【如果当前指针指向任务堆栈，则此时会切换到中断堆栈】</li>
<li>保存中断返回地址【中断调度程序将存储该指针，以防用户使用IRP的API来检索该返回地址，如果不需要使用该API则被优化】</li>
<li>屏蔽SWI调度【如任务模块一样未被开启，则自动优化出中断调度程序】</li>
<li>调用HWI挂钩启动函数【<strong>附加</strong>挂钩函数】</li>
<li>如果允许自动嵌套：允许全局中断【有更高优先级的硬件中断来临时，打开中断屏蔽，使能全局中断】</li>
<li>调用ISR服务程序【真正的硬件中断程序开始执行】</li>
<li>屏蔽全局中断</li>
<li>调用HWI挂钩结束函数</li>
<li>运行SWI调度</li>
<li>切换回任务堆栈</li>
<li>运行任务调度</li>
</ol>
<p><strong>SYS/BIOS中断管理的优势：</strong></p>
<ol>
<li>降低代码量</li>
<li>提供中断堆栈，降低任务堆栈大小</li>
<li>管理中断嵌套</li>
<li>在ISR任务中禁止调度中断</li>
<li>运行由ISR程序递交的SWI程序</li>
<li>管理任务抢断</li>
<li>提供监测</li>
<li>灵活性：仍然允许不执行中断调度</li>
</ol>
<p><strong>注意：</strong> <em>HWI不需要使用编译器认可的中断关键字！SYS/BIOS的中断调度会自动保存堆栈相关数据，如果使用会导致灾难性的运行故障发生！</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hwi_Params hwiParams;              <span class="comment">//硬件中断参数结构体实例</span></span><br><span class="line">Hwi_Handle hwi0;                   <span class="comment">//硬件中断句柄</span></span><br><span class="line">Error_block eb;</span><br><span class="line"></span><br><span class="line">Hwi_Params_init(&amp;hwiParams);       <span class="comment">//参数初始化</span></span><br><span class="line">hwiParams.arg = <span class="number">5</span>;                 <span class="comment">//更新参数</span></span><br><span class="line">hwi0 = Hwi_create(id,hwiFunc,&amp;hwiParams,&amp;eb);  <span class="comment">//四参数，前两个未知</span></span><br></pre></td></tr></table></figure>



<h3 id="SWI"><a href="#SWI" class="headerlink" title="SWI"></a>SWI</h3><ul>
<li>一般伴随着硬件中断的发生而发生，以便最灵活地处理中断事务</li>
<li>优先级共16级：0-15</li>
<li>寄存器的保护/恢复由SYS/BIOS系统自动处理</li>
<li>单堆栈模式：增加优先级将增加堆栈的开销</li>
</ul>
<ul>
<li>【与任务的处理方式不同，SWI在单个堆栈上运行，同时兼具优点与局限性，能使SWI以非常低的内存消耗来运行，但也不允许他们被挂起（即SWI必须运行到结束）】</li>
<li>【SWI通常由HWI调用，系统产生了一个外设的中断，从而触发了HWI线程，而HWI处理的都是需要紧急实时响应的事务，HWI线程需要尽可能快速处理完毕，并且处理HWI时会屏蔽其他中断，因此为了让HWI处理尽可能少的操作，一些不太需要紧急实时处理的任务会放到SWI中处理。】</li>
<li>【因此当HWI将中断发布到SWI时，SWI会立即处理】</li>
<li>【HWI通常是突发而紧急的，SWI通常较为灵活、常态而平稳】</li>
<li>【HWI通常以微秒计时，SWI通常以毫秒计时】</li>
<li>【HWI和SWI都只会运行一次，不管该线程在运行前被发布了多少次】</li>
<li>【具有相同优先级的两个SWI线程不会抢占对方，会以FIFO的方式先后运行两个线程，即使第二个线程已经被发布，但直到第一个线程运行完毕，第二个线程都在持续等待】</li>
<li>【如果使用ISR来发布更高优先级的SWI，或者说在使用ISR时发布SWI，则可能使得SWI立即抢占ISR的线程，造成数据丢失，BIOS更推荐使用HWI来发布SWI】</li>
<li>【同一个SWI线程不论在运行前被发布了多少次，都只会运行一次】</li>
</ul>
<table>
<thead>
<tr>
<th>API</th>
<th>Allows you to :</th>
</tr>
</thead>
<tbody><tr>
<td>Swi_inc()</td>
<td>知道SWI在运行前被发布了多少次——N：自加计数</td>
</tr>
<tr>
<td>Swi_dec()</td>
<td>需要发布N次SWI，才能运行SWI——N：自减计数</td>
</tr>
<tr>
<td>Swi_or()</td>
<td>在发布发出一个有用的信号——签名</td>
</tr>
<tr>
<td>Swi_andn()</td>
<td>只有在所需要的发布都已经发布后才会发布</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>Bitmask</th>
<th>Counter</th>
<th>Not Used</th>
</tr>
</thead>
<tbody><tr>
<td>无条件发布</td>
<td>Swi_or()</td>
<td>Swi_inc()</td>
<td>Swi_post()</td>
</tr>
<tr>
<td>仅在触发值为0时发布</td>
<td>Swi_andn()</td>
<td>Swi_dec()</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>If trigger value is needed by the Swi, use <code>Swi_getTrigger()</code> which returns the value of the trigger when the Swi function starts running.</li>
<li>After each posting, the trigger is reset to the initial condition specified in the Swi object.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Swi_Params swiParams;</span><br><span class="line">Swi_Handle mySwi;</span><br><span class="line">Error_Block eb;    <span class="comment">//创建错误块结构体实例</span></span><br><span class="line"></span><br><span class="line">Swi_Params_init(&amp;swiParams);</span><br><span class="line">swiParams.priority = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">Error_init(&amp;eb);   <span class="comment">//初始化错误块结构体</span></span><br><span class="line"></span><br><span class="line">mySwi = Swi_create(swiFunc, &amp;swiParams, &amp;eb);    <span class="comment">//三参数</span></span><br></pre></td></tr></table></figure>



<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><h4 id="SYS-BIOS-TASK"><a href="#SYS-BIOS-TASK" class="headerlink" title="SYS/BIOS-TASK"></a>SYS/BIOS-TASK</h4><p><strong>任务创建函数原型Task_create(Task_FuncPtr, Const*, Error_Block*)</strong></p>
<p><strong>注意：</strong>要与 <code>TaskCreate(void*(), char*, int, uint, UINT32, UINT32, UINT32)</code>; 做区分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Task_create(Task_FuncPtr fxn,</span><br><span class="line">            <span class="keyword">const</span> Task_Params *params, </span><br><span class="line">            Error_Block *eb);</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Task_Params taskParams;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create task with priority 15 </span></span><br><span class="line">Task_Params_init(&amp;taskParams);</span><br><span class="line">taskParams.stackSize = <span class="number">512</span>;</span><br><span class="line">taskParams.priority = <span class="number">15</span>;</span><br><span class="line">Task_create((Task_FuncPtr)myFxn, &amp;taskParams, &amp;eb);</span><br></pre></td></tr></table></figure>

<p><strong>任务特性</strong></p>
<ul>
<li>任务调度使用更先进的调度技术 <ul>
<li>每个任务在创建时都会设立独立堆栈，任务访问共享资源时可能会因为等待而被挂起</li>
<li>任务会被其他更高优先级的线程打断（SWI、HWI），HWI 及 SWI不可挂起（SWI是需要退出和返回）；</li>
</ul>
</li>
<li>任务的数量、状态及优先级都可以在程序执行时动态改变</li>
<li>【两个任务可以调用同一函数（主要该函数是可以重入？的函数），即该函数在执行完毕之前可被安全地二次调用，任务在调用函数时可携带参数，使函数知晓是被哪个实例调用】</li>
</ul>
<p><strong>任务间时间切片。</strong></p>
<blockquote>
<p>任务在正常情况下是个看似 “无限循环” 的进程，只有在整个系统停止后才会结束；但在未被挂起的情况下，任务在被CPU分时间调度的过程中，任务会重新从头开始运行，即不会停留在上一次的位置。任务看似一次被执行就一直被无限调度，实际上是在时间分片中快速切换。</p>
</blockquote>
<p><strong>任务与Semaphore。</strong></p>
<blockquote>
<p>在使用Semaphore作为同步方式的任务调度中，如果一个任务等级较高，且 <code>Semaphore_pend()</code> 时，设置了第二个参数为 <code>BIOS_NO_WAIT</code> ，即该任务会被立即循环执行。如果参数设置为  <code>BIOS_WAIT_FOREVER</code> ，则该程序将会一直等待，直到它的信号量被post出来。</p>
<p style="font-style: italic; color: #ccc;">原文：A timeout value of BIOS_WAIT_FOREVER causes the task to wait indefinitely for its semaphore to be posted. A timeout value of BIOS_NO_WAIT causes Semaphore_pend to return immediately.</p>

<p><strong>注意</strong>：互相形成依赖的任务（如嵌套）不要用同一个信号量，会发生冲突、堆栈溢出或死锁等现象。尽量一个任务关联一个信号量。</p>
</blockquote>
<p><strong>注意：</strong>如果有堆栈溢出，应优先检查task和semaphore的初始化情况。</p>
<table>
<thead>
<tr>
<th>Functions</th>
<th>explaination</th>
</tr>
</thead>
<tbody><tr>
<td><code>Task_construct (Task_Struct *structP, Task_FuncPtr fxn, const Task_Params *params, Error_Block *eb);</code></td>
<td>// <em><strong>Initialize</strong></em> a new instance object inside the provided  structure <br />在提供的结构中<strong>创建</strong>一个新的实体对象</td>
</tr>
<tr>
<td><code>Task_create(Task_FuncPtr fxn, const Task_Params *params, Error_Block *eb);</code></td>
<td>// <em><strong>Allocate and initialize</strong></em> a new instance object and return its handle<br />开辟内存并初始化一个新的实体对象并返回其句柄</td>
</tr>
<tr>
<td><code>Task_delete(Task_Handle *handleP);</code></td>
<td>// <em><strong>Finalize and free</strong></em> this previously allocated instance object, setting the referenced handle to NULL<br />终结一个已存在的实体对象，并释放内存，设置其句柄为空</td>
</tr>
<tr>
<td><code>Task_destruct(Task_Struct *structP);</code></td>
<td>// Finalize the instance object inside the provided structure<br />在提供的结构中<strong>创建</strong>一个新的实体对象</td>
</tr>
<tr>
<td><code>Task_disable();</code></td>
<td>// Disable the task scheduler<br />使任务（列表）功能关闭</td>
</tr>
<tr>
<td><code>Task_exit();</code></td>
<td>// 5Terminate execution of the current task<br />终结现在正在运行的任务</td>
</tr>
<tr>
<td><code>Task_getEnv(Task_Handle handle);</code></td>
<td>// Get task environment pointer<br />获取任务环境指针</td>
</tr>
<tr>
<td><code>Task_getIdleTask();</code></td>
<td>// returns a handle to idle task object<br />返回一个句柄给空闲任务对象</td>
</tr>
<tr>
<td><code>Task_getMode(Task_Handle handle);</code></td>
<td>// Retrieve the Mode of a task<br />获取任务的句柄</td>
</tr>
<tr>
<td><code>Task_getPri(Task_Handle handle);</code></td>
<td>// Get task priority<br />获取任务的优先级</td>
</tr>
<tr>
<td><code>Task_Params_init(Task_Params *params);</code></td>
<td>// Initialize this config-params structure with supplier-specified defaults before instance creation<br />在实例创建前使用指定默认值初始化配置参数结构</td>
</tr>
<tr>
<td><code>Task_restore(UInt key);</code></td>
<td>// Restore Task scheduling state储存任务调度状态</td>
</tr>
<tr>
<td><code>Task_self();</code></td>
<td>// Returns a handle to the currently executing Task object<br />返回一个句柄给当前执行中的任务对象</td>
</tr>
<tr>
<td><code>Task_selfMacro();</code></td>
<td>// Returns a handle to the currently executing Task object<br />返回一个句柄给当前执行中的任务对象</td>
</tr>
<tr>
<td><code>Task_setEnv(Task_Handle handle, Ptr env);</code></td>
<td>// Set task environment<br />设置任务环境</td>
</tr>
<tr>
<td><code>Task_setHookContext(Task_Handle handle, Int id, Ptr hookContext);</code></td>
<td>// Set hook instance’s context for a task<br />为任务设置hook实例的</td>
</tr>
<tr>
<td><code>Task_setPri(Task_Handle handle, Int newpri);</code></td>
<td>// Set a task’s priority<br />设置任务优先级</td>
</tr>
<tr>
<td><code>Task_sleep(UInt nticks);</code></td>
<td>// Delay execution of the current task<br />延迟当前任务的执行时间</td>
</tr>
<tr>
<td><code>Task_stat(Task_Handle handle, Task_Stat *statbuf);</code></td>
<td>// Retrieve the status of a task<br />获取任务状态</td>
</tr>
<tr>
<td><code>Task_yield();</code></td>
<td>// Yield processor to equal priority task<br />在两个相同等级的任务间切换处理器使用权<br />同等级任务切换函数</td>
</tr>
</tbody></table>
<h5 id="任务测试"><a href="#任务测试" class="headerlink" title="任务测试"></a>任务测试</h5><table>
<thead>
<tr>
<th></th>
<th>priority</th>
<th>task_yield()</th>
<th>ISR Post Sem</th>
<th>任务内任务</th>
<th>是否执行</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>更高</td>
<td>存在</td>
<td>存在</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td></td>
<td>相同</td>
<td>存在</td>
<td>存在</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>Table 3-1. Comparison of Thread Characteristics</strong></p>
<table>
<thead>
<tr>
<th><strong>Characteristic</strong></th>
<th><strong>Hwi</strong></th>
<th><strong>Swi</strong></th>
<th><strong>Task</strong></th>
<th><strong>Idle</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Priority</strong></td>
<td>Highest</td>
<td>2nd Highest</td>
<td>2nd lowest</td>
<td>Lowest</td>
</tr>
<tr>
<td><strong>Number of priority levels</strong></td>
<td>family/device-specific</td>
<td>Up to 32; Periodic functions run at the priority of the Clock Swi.</td>
<td>Up to 32; This includes 1 for the Idle Loop.</td>
<td>1</td>
</tr>
<tr>
<td><strong>Can yield and pend</strong></td>
<td>No, runs to completion except for preemption</td>
<td>No, runs to completion except for preemption</td>
<td>Yes</td>
<td>Should not pend. <em><strong>Pending would disable all registered Idle threads.</strong></em></td>
</tr>
<tr>
<td><strong>Execution states</strong></td>
<td>Inactive, ready, running</td>
<td>Inactive, ready, running</td>
<td>Ready, running, blocked, terminated</td>
<td>Ready, running</td>
</tr>
<tr>
<td><strong>Thread scheduler disabled by</strong></td>
<td><code>Hwi_disable()</code></td>
<td><code>Swi_disable()</code></td>
<td><code>Task_disable()</code></td>
<td>Program exit</td>
</tr>
<tr>
<td><strong>Posted or made ready to run by</strong></td>
<td>Interrupt occurs</td>
<td><code>Swi_post()</code> , <code>Swi_andn()</code> , <code>Swi_dec()</code> , <code>Swi_inc()</code> , <code>Swi_or()</code></td>
<td><code>Task_create()</code> and various task synchronization mechanisms <em>(Event, Semaphore, Mailbox)</em></td>
<td><code>main()</code> exits and no other thread is currently running</td>
</tr>
<tr>
<td><strong>Stack used</strong></td>
<td>System stack (1 per program)</td>
<td>System stack (1 per program)</td>
<td>Task stack (1 per program)</td>
<td><strong>Task stack used by default</strong></td>
</tr>
<tr>
<td><strong>Context saved when preempts other thread</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Context saved when blocked</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>share data with thread via</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Synchronize with thread via</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Function hooks</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Static creation</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Dynamic creation</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Dynamically change priority</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Implicit logging</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Implicit statistics</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="OSIF-TASK"><a href="#OSIF-TASK" class="headerlink" title="OSIF-TASK"></a>OSIF-TASK</h4><p><code>&lt;osif.h&gt;</code> 文件提供系统级接口函数，与SYS/BIOS提供的相似任务函数具有不一样的函数定义。所有任务相关函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下功能可能需要被链接或移植</span></span><br><span class="line"><span class="function">_extern <span class="keyword">void</span>   <span class="title">TaskBlock</span><span class="params">(HANDLE h)</span></span>;</span><br><span class="line"><span class="function">_extern HANDLE <span class="title">TaskCreate</span><span class="params">( <span class="keyword">void</span>(*pFun)(), <span class="keyword">char</span> *Name, <span class="keyword">int</span> Priority, uint StackSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          UINT32 Arg1, UINT32 Arg2, UINT32 Arg3 )</span></span>;</span><br><span class="line"><span class="function">_extern <span class="keyword">void</span>   <span class="title">TaskDestroy</span><span class="params">( HANDLE h )</span></span>;</span><br><span class="line"><span class="function">_extern <span class="keyword">void</span>   <span class="title">TaskExit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">_extern HANDLE <span class="title">TaskGetEnv</span><span class="params">( HANDLE h, <span class="keyword">int</span> Slot )</span></span>;</span><br><span class="line"><span class="function">_extern <span class="keyword">int</span>    <span class="title">TaskGetPri</span><span class="params">(HANDLE h)</span></span>;</span><br><span class="line"><span class="function">_extern HANDLE <span class="title">TaskSelf</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">_extern <span class="keyword">void</span>   <span class="title">TaskSetEnv</span><span class="params">( HANDLE h, <span class="keyword">int</span> Slot, HANDLE hEnv )</span></span>;</span><br><span class="line"><span class="function">_extern <span class="keyword">int</span>    <span class="title">TaskSetPri</span><span class="params">(HANDLE h, <span class="keyword">int</span> priority)</span></span>;</span><br><span class="line"><span class="function">_extern <span class="keyword">void</span>   <span class="title">TaskSleep</span><span class="params">(UINT32 delay)</span></span>;</span><br><span class="line"><span class="function">_extern <span class="keyword">void</span>   <span class="title">TaskYield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>**任务创建函数 TaskCreate(void*(), char*, int, uint, UINT32, UINT32, UINT32); **</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_extern HANDLE <span class="title">TaskCreate</span><span class="params">( <span class="keyword">void</span>(*pFun)(), <span class="keyword">char</span> *Name, <span class="keyword">int</span> Priority, uint StackSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          UINT32 Arg1, UINT32 Arg2, UINT32 Arg3 )</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>TaskCreate();</code> 的使用方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( <span class="keyword">void</span> ) TaskCreate ( TCP_Perform_Server , <span class="string">&quot;TCPBenchmarkRX&quot;</span> , OS_TASKPRIHIGH , <span class="number">0x1400</span> , <span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> );</span><br></pre></td></tr></table></figure>

<p>关于任务优先级Priority的定义存在同一头文件中，具体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Equates used in code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBG_PRINT_LEVEL         (_oscfg.DbgPrintLevel)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBG_ABORT_LEVEL         (_oscfg.DbgAbortLevel)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_TASKPRILOW           (_oscfg.TaskPriLow)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_TASKPRINORM          (_oscfg.TaskPriNorm)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_TASKPRIHIGH          (_oscfg.TaskPriHigh)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_TASKPRIKERN          (_oscfg.TaskPriKern)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_TASKSTKLOW           (_oscfg.TaskStkLow)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_TASKSTKNORM          (_oscfg.TaskStkNorm)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_TASKSTKHIGH          (_oscfg.TaskStkHigh)</span></span><br></pre></td></tr></table></figure>





<p>以下出自 <em><strong>&lt;spru523h.pdf&gt;</strong></em>  <em>Chapter 3.3 Creating a Task</em></p>
<blockquote>
<p>The process of creating a sockets application begins with the creation of a SYS/BIOS Task thread. You can use XGCONF to statically configure Tasks or use the standard SYS/BIOS API or the provided Task abstraction to dynamically create Tasks. For example, the following C code creates a basic Task:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Task_Params taskParams;</span><br><span class="line">Task_Handle hMyTask;</span><br><span class="line">Error_Block eb;</span><br><span class="line">Error_init(&amp;eb);</span><br><span class="line"></span><br><span class="line">Task_Params_init(&amp;taskParams);</span><br><span class="line">taskParams.stackSize = <span class="number">4096</span>;</span><br><span class="line">taskParams.priority = <span class="number">5</span>;             <span class="comment">/* Create a Task with priority 5 */</span></span><br><span class="line">hMyTask = Task_create((Task_FuncPtr)entrypoint, &amp;taskParams, &amp;eb);</span><br><span class="line"><span class="keyword">if</span> (hMyTask == <span class="literal">NULL</span>) &#123;</span><br><span class="line">System_abort(<span class="string">&quot;Task create failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The same Task can be created via the <code>TaskCreate()</code>  function in the Task abstraction API. The abstracted function is a little more restrictive. It creates a Task thread with exactly 3 parameters (they do not all have to be used). For example, the following call would create a Task similar to that shown above: </p>
<p><code>hMyTask = TaskCreate( entrypoint, &quot;TaskName&quot;, OS_TASKPRINORM, stacksize, arg1, arg2, arg3 );</code></p>
<p>In both cases, <code>hMyTask</code> is a handle to a SYS/BIOS Task thread.</p>
</blockquote>
<h3 id="Synchronization"><a href="#Synchronization" class="headerlink" title="Synchronization"></a>Synchronization</h3><p>SYS/BIOS内的同步类型分为 <strong>进程同步</strong> 和 <strong>核同步</strong> ；同步方式共5种：<strong>Semaphore</strong>(信号量) / <strong>Event</strong>(事件) / <strong>Gate</strong>(门) / <strong>Mailbox</strong>(邮箱) / <strong>Queue</strong>(队列)</p>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>信号量可分为 <strong>互斥型</strong> 和 <strong>计数型</strong> 两种。</p>
<p><strong>互斥型信号量</strong></p>
<blockquote>
<p>也称为为互斥量、二进制型信号量。可以理解为只能维护资源数量为1的二值计数信号量（值为0或1），但是互斥信号量又不同于计数信号量，因为它还具有 <strong>优先级继承</strong> 的机制。</p>
<p>优先级继承机制是RTOS中为了避免出现 <strong>优先级翻转</strong> 问题而做的处理方式。简单来说就是如果低优先级持有互斥信号量那么高优先级任务想访问互斥量就会失败而挂起等待互斥量被释放，此时反而是低优先级任务在运行，这就出现了优先级翻转。为了避免该情况RTOS处理方式是把正在持有互斥量运行的低优先级任务的优先级提高到与等待访问互斥资源的高优先级任务同等优先级，这就是优先级继承。等互斥量被释放后RTOS会将该任务恢复到之前的低优先级。</p>
</blockquote>
<p><strong>特性：</strong></p>
<ul>
<li><p>信号量是指系统当前可用资源的数值，当资源超过1时，为 <code>计数型信号量</code> ；当资源仅为1和0时，为 <code>二进制型信号量</code>；因为资源总为1及以上，因此不论是计数型还是二进制型，可用的信号量始终≥0。</p>
</li>
<li><p>信号量用于标识和实现任务的 <code>挂起</code> 和 <code>发布</code></p>
<ul>
<li><strong>发布</strong> 指任务正在处于结束状态，<code>Semaphore_post()</code> 将使信号量递增</li>
<li><strong>挂起</strong> 指任务正在处于运行状态，<code>Semaphore_pend()</code> 将使信号量递减</li>
<li>使用 <code>Semaphore_pend()</code> 以使用资源，使用 <code>Semaphore_post()</code> 以离开资源</li>
</ul>
</li>
<li><p>计数型信号量用来进行多任务管理</p>
<ul>
<li><code>多任务信号量</code>的初始值将为可同时进行任务的最大值</li>
<li>当达到最大可运行任务量时，信号量值为0，即信号阻塞</li>
</ul>
</li>
<li><p>当信号量为0时，即系统资源被占满，如果此时出现最高优先级任务，系统将抢断低优先级任务从而使高优先级任务进行工作</p>
</li>
</ul>
<p><strong>任务与调用任务</strong></p>
<blockquote>
<p>在调用任务时，不需要特意调高被调用任务的等级。</p>
<p>在被调用任务的等级等于本任务时，使用<code>Semaphore_post();</code> 并使用 <code>task_yeild();</code> ，即可顺利将任务切换到被调用任务。(如下 <strong>SEM-1</strong> 示)</p>
<p>在被调用任务的等级低于本任务时，使用 <code>Semaphore_post();</code> 并使用 <code>task_sleep();</code> ，即可让低等级任务在本任务休眠期间执行。(如下 <strong>SEM-2</strong> 示)</p>
</blockquote>
<p><strong>SEM-1</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_core0TCPService</span><span class="params">(UArg a0, UArg a1)</span> </span>&#123;                                      <span class="comment">//Core0执行TCP信息接收任务</span></span><br><span class="line">    <span class="keyword">short</span> rx_length = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Semaphore_pend( sem0_TcpReceive, BIOS_WAIT_FOREVER );</span><br><span class="line">        TcpReceive(ReceiveBuffer, RECEIVEBUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span>(rx_length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ReceiveBufferTemp[<span class="number">0</span>]==<span class="number">0xf5</span>)&#123;</span><br><span class="line">                <span class="keyword">switch</span>(ReceiveBufferTemp[<span class="number">2</span>])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x01</span>:</span><br><span class="line">                    <span class="keyword">if</span>(ReceiveBufferTemp[<span class="number">3</span>] == <span class="number">0x01</span>)&#123;                                                     </span><br><span class="line">                        Semaphore_post(sem0_ad);                    <span class="comment">//post同等级任务的信号量</span></span><br><span class="line">                        Task_yield();                               <span class="comment">//调用任务切换函数</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_core0AdcRead</span><span class="params">(UArg a0, UArg a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;                                                                                               </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Semaphore_pend(sem0_ad,BIOS_WAIT_FOREVER);</span><br><span class="line">        <span class="keyword">while</span>(ADC_Cnt &lt;= ADC_MICROSECOND)&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Int <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Task_Handle task;                                              <span class="comment">//创建空任务句柄</span></span><br><span class="line">    Task_Params param;                                             <span class="comment">//创建空任务参数</span></span><br><span class="line">    Error_Block eb;                                                <span class="comment">//创建空错误块</span></span><br><span class="line">	Error_init(&amp;eb);                                               <span class="comment">//初始化错误块参数</span></span><br><span class="line">    Task_Params_init(&amp;param);                                      <span class="comment">//初始化任务参数</span></span><br><span class="line">    uart_init();                                                   <span class="comment">//串口初始化</span></span><br><span class="line">    uart_set_baudrate(<span class="number">115200</span>);                                     <span class="comment">//设置波特率</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(CSL_chipReadDNUM() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	SemInit_Core0();                                            <span class="comment">//配置semaphore，sem0_ad,sem0_da</span></span><br><span class="line">    	FanLed_Init();                                              <span class="comment">//点亮LED3，开启FAN</span></span><br><span class="line">    	Sgmii_Init();                                               <span class="comment">//外设初始化</span></span><br><span class="line">        ADS8568_Init();                   <span class="comment">//INT6</span></span><br><span class="line">        DAC8565_Init();                   <span class="comment">//INT7</span></span><br><span class="line">    	Timer3_Init();                    <span class="comment">//INT4</span></span><br><span class="line"></span><br><span class="line">        task = Task_create(task_core0Init, &amp;param, &amp;eb);</span><br><span class="line">        TaskSuccess(&amp;task,<span class="string">&quot;任务创建失败：task_core0Init\n&quot;</span>); </span><br><span class="line"></span><br><span class="line">        param.priority=<span class="number">10</span>;</span><br><span class="line">        task = Task_create(task_core0TCPService, &amp;param, &amp;eb); </span><br><span class="line">        TaskSuccess(&amp;task,<span class="string">&quot;任务创建失败：task_core0TCPListenAndReceive!\n&quot;</span>); </span><br><span class="line"></span><br><span class="line">        param.priority = <span class="number">10</span>;</span><br><span class="line">        task = Task_create(task_core0AdcRead, &amp;param, &amp;eb);           <span class="comment">//读取AD任务</span></span><br><span class="line">        TaskSuccess(&amp;task,<span class="string">&quot;任务创建失败：task_core0AdcRead\n&quot;</span>);                 </span><br><span class="line">    &#125;</span><br><span class="line">    BIOS_start();</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>SEM-2</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">lowPriTask</span><span class="params">(UArg arg0, UArg arg1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		Semaphore_pend(mySem, BIOS_WAIT_FOREVER); <span class="comment">//挂起任务</span></span><br><span class="line">		resource += <span class="number">1</span>;                  <span class="comment">//do work on locked resource</span></span><br><span class="line">		Semaphore_post(mySem);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Void <span class="title">hiPriTask</span><span class="params">(UArg arg0, UArg arg1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		Semaphore_pend(mySem, BIOS_WAIT_FOREVER);</span><br><span class="line">		resource += <span class="number">1</span>;                  <span class="comment">//do work on locked resource</span></span><br><span class="line">		Semaphore_post(mySem);</span><br><span class="line">		Task_sleep(<span class="number">5</span>);                 <span class="comment">//allow low pri taks to work</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>任务与信号量之间的关系？</strong></p>
<ul>
<li><p>任务的顺利执行，需要经过 <strong>任务新建</strong>、<strong>信号量新建</strong>、<strong>信号量阻塞</strong> 和 <strong>信号量发布</strong> 四个流程。任务不是在被发布后就立即执行的，他需要等待信号量的到来。</p>
</li>
<li><p>先pend后post，即任务执行必须由对应的信号量进行排队（阻塞）和准备（发布），如果其中任何一个步骤缺省都无法执行任务。</p>
</li>
<li><p>pend要在该任务被执行时使用，放置在任务最开始的一句话中；post可以放置在别的任务或 <strong>IRS</strong> 中断里，由别的任务或函数来启动本任务。</p>
</li>
<li><p>信号量使用须统一为计数型或二进制型？</p>
</li>
</ul>
<h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><h2 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h2><h3 id="EMAC"><a href="#EMAC" class="headerlink" title="EMAC"></a>EMAC</h3><p>EMAC驱动程序提供了一个定义良好的API层，允许应用程序使用EMAC外设来控制从处理器到PHY的数据包数据流，并使用MDIO模块来控制PHY配置和状态监控。</p>
<p>EMAC驱动程序的设计要求如下:</p>
<ul>
<li>每个核支持多个EMAC端口(如果设备上可用)。</li>
<li>每个核支持多个通道/MAC地址。</li>
<li>支持多个内核在同一个EMAC端口上使用不同的通道。</li>
<li>驱动程序是独立于操作系统的，通过OSAL操作系统层暴露所有的操作系统callout。</li>
<li>EMAC示例测试应用程序提供了标准配置，并演示了可度量的基准测试。</li>
</ul>
<p>EMAC驱动程序的架构图如下:</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/wps1.png" alt="img" style="zoom:67%;" />

<p><strong>1.EMAC设备驱动程序</strong></p>
<p>设备驱动程序公开了一组定义良好的API，应用层使用它通过EMAC外围设备发送和接收数据包，并通过MDIO外围设备配置和监视PHY。驱动程序还公开了一组定义良好的操作系统抽象API，用于确保驱动程序是操作系统独立的和可移植的。EMAC驱动程序对所有EMAC MMR访问使用CSL EMAC功能层。</p>
<p><strong>2.应用程序代码</strong></p>
<p>这是EMAC驱动程序的用户，它与驱动程序的接口是通过定义良好的API集实现的。应用程序用户使用EMAC驱动程序API通过EMAC外围设备发送和接收数据包。</p>
<p><strong>3.操作系统抽象层</strong></p>
<p>EMAC LLD是独立于操作系统的，并通过这个层公开所有的操作系统调出。</p>
<p><strong>4.CSL功能层</strong></p>
<p>EMAC驱动程序使用CSL EMAC功能层通过访问MMR来对设备IP进行编程。</p>
<p><strong>5.注册层</strong></p>
<p>寄存器层是由IP所有者生成的IP块内存映射寄存器。EMAC驱动程序不直接访问MMR寄存器，而是使用EMAC CSL功能层实现这个目的。</p>
<h3 id="SOCKET"><a href="#SOCKET" class="headerlink" title="SOCKET"></a>SOCKET</h3><p>在C++/MFC中有Window Socket，作为TCP/UDP数据传输的接口工具。</p>
<p>在C#/WPF中也有Socket，作用同上。</p>
<p>在C++/TI.SYSBIOS的NDK套件中也有Socket作为沟通套接的工具。</p>
<p>TI.SYSBIOS的NDK套件中，常用的函数如下：</p>
<p><strong>NDK_accept()</strong> </p>
<blockquote>
<p>Accept a connection on a socket</p>
<p><code>SOCKET NDK_accept(SOCKET s, struct sockaddr *pName, int *plen);</code></p>
</blockquote>
<p><strong>NDK_bind</strong>() </p>
<blockquote>
<p>Bind a name to a socket</p>
<p><code>int NDK_bind(SOCKET s, struct sockaddr *pName, int len);</code></p>
</blockquote>
<p><strong>NDK_connect</strong>() </p>
<blockquote>
<p>Initiate a connection on a socket</p>
<p><code>int NDK_connect(SOCKET s, struct sockaddr *pName, int len);</code></p>
</blockquote>
<p><strong>NDK_getpeername()</strong> </p>
<blockquote>
<p>Return name (address) of connected peer</p>
<p><code>int NDK_getpeername(SOCKET s, struct sockaddr *pName, int *plen);</code></p>
</blockquote>
<p><strong>NDK_getsockname()</strong> </p>
<blockquote>
<p>Return the local name (address) of the socket</p>
<p><code>int NDK_getsockname(SOCKET s, struct sockaddr *pName, int *plen);</code></p>
</blockquote>
<p><em><strong>NDK_getsockopt()</strong></em> </p>
<blockquote>
<p>Get the value of a socket option</p>
<p><code>int NDK_getsockopt(SOCKET s, int level, int op, void *pbuf, int *pbufsize);</code></p>
</blockquote>
<p><strong>NDK_listen</strong>() </p>
<blockquote>
<p>Listen for connection requests on a socket</p>
<p><code>int NDK_listen(SOCKET s, int maxcon);</code></p>
</blockquote>
<p><strong>NDK_recv()</strong> </p>
<blockquote>
<p>Receive data from a socket</p>
<p><code>int NDK_recv(SOCKET s, void *pbuf, int size, int flags);</code></p>
</blockquote>
<p><strong>NDK_recvfrom()</strong> </p>
<blockquote>
<p>Receive data from a socket with the senders name (address)</p>
<p><code>int NDK_recvfrom(SOCKET s, void *pbuf, int size, int flags, struct sockaddr *pName, int *plen);</code></p>
</blockquote>
<p><strong>NDK_send()</strong> </p>
<blockquote>
<p>Send data to a connected socket</p>
<p><code>int NDK_send(SOCKET s, void *pbuf, int size, int flags);</code></p>
</blockquote>
<p><strong>NDK_sendto()</strong> </p>
<blockquote>
<p>Send data to a specified destination on an unconnected socket</p>
<p><code>int NDK_sendto(SOCKET s, void *pbuf, int size, int flags, struct sockaddr *pName, int len);</code></p>
</blockquote>
<p><strong>NDK_setsockopt()</strong> </p>
<blockquote>
<p>Set the value of a socket option</p>
<p><code>int NDK_setsockopt(SOCKET s, int level, int op, void *pbuf, int bufsize);</code></p>
</blockquote>
<p><strong>NDK_shutdown</strong>() </p>
<blockquote>
<p>Close one half of a socket connection</p>
<p><code>int NDK_shutdown(SOCKET s, int how)</code></p>
</blockquote>
<p><strong>NDK_socket</strong>() </p>
<blockquote>
<p>Create a socket</p>
<p><code>SOCKET NDK_socket(int domain, int type, int protocol);</code></p>
</blockquote>
<p><strong>NDK_socketpair()</strong> </p>
<blockquote>
<p>Create socket pair. Redundant; see Section 3.5, <em>Full Duplex Pipes</em> <em>Programming Interface</em>.</p>
</blockquote>
<blockquote>
<p>The domain parameter specifies a communications domain within which communication will take place;<br>域参数指定通信将在其中发生的通信域;</p>
</blockquote>
<h1 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h1><p><strong>EMAC</strong></p>
<blockquote>
<p>Ethernet Media Access Controller</p>
</blockquote>
<p><strong>MDIO</strong></p>
<blockquote>
<p>Management Data Input/Output</p>
</blockquote>
<p><strong>PHY</strong></p>
<blockquote>
<p>Physical Layer</p>
</blockquote>
<p><strong>Purpose of the Peripheral</strong></p>
<blockquote>
<p>The EMAC module is used on the device to move data between the device and another host connected to the same network, in compliance with the Ethernet protocol.</p>
</blockquote>
<p><strong>PLL</strong></p>
<blockquote>
<p><strong>Phase-Locked Loop 锁相环</strong> </p>
<p>**锁相环路 **是一种反馈控制电路，简称锁相环。</p>
<p><strong>锁相环</strong> 的特点是：利用外部输入的参考信号控制环路内部振荡信号的频率和相位。因锁相环可以实现输出信号频率对输入信号频率的自动跟踪，所以锁相环通常用于闭环跟踪电路。</p>
<p>锁相环在工作的过程中，当输出信号的频率与输入信号的频率相等时，输出电压与输入电压保持固定的相位差值，即输出电压与输入电压的相位被锁住，这就是锁相环名称的由来。</p>
<p>锁相环通常由<strong>鉴相器</strong>（PD,Phase Detector）、<strong>环路滤波器</strong>（LF,Loop Filter）和 <strong>压控振荡器</strong>（VCO,Voltage Controlled Oscillator）三部分组成。</p>
</blockquote>
<p><strong>MII</strong></p>
<blockquote>
<p>以太网媒体接口有：MII、RMII、SMII、GMII </p>
<p><strong>Media Independent Interface</strong></p>
<p>称为 <strong>介质无关接口</strong> 或 <strong>媒体独立接口</strong>，它是 <strong>IEEE-802.3</strong> 定义的以太网行业标准。</p>
<ul>
<li>它包括一个 <strong>数据接口</strong> 和一个 <strong>MAC</strong> 和 <strong>PHY</strong> 之间的管理接口。<strong>数据接口</strong> 包括分别用于 <strong>发送器</strong> 和 <strong>接收器</strong> 的两条独立信道，每条信道都有自己的 数据、时钟 和 控制信号 。MII数据接口总共需要16个信号。</li>
<li>管理接口是个双信号接口：一个是时钟信号，另一个是数据信号。通过管理接口，上层能监视和控制PHY。</li>
<li>MII标准接口用于连接 <strong>Fast Ethernet MAC-block</strong> 与 <strong>PHY</strong>。表明在不对MAC硬件重新设计或替换的情况下，任何类型的PHY设备都可以正常工作。</li>
<li>在其他速率下工作的与MII等效的接口有：<strong>AUI</strong>（10M　以太网）、<strong>GMII</strong>（Gigabyte　以太网）和<strong>XAUI</strong>（10-Gigabit　以太网）。</li>
<li>MII支持10兆和100兆的操作，一个接口由14根线组成，它的支持还是比较灵活的，但是有一个<strong>缺点是因为它一个端口用的信号线太多</strong>，如果一个8端口的交换机要用到112根线，16端口就要用到224根线，到32端口的话就要用到448根线，一般按照这个接口做交换机，是不太现实的，所以现代的交换机的制作都会用到由MII简化而来的标准，如 <strong>RMII</strong>、<strong>SMII</strong>、<strong>GMII</strong> 等。<ul>
<li>RMII（Reduced MII）是简化的MII接口，在数据的收发上它比MII接口少了一倍的信号线，所以它一般要求是50兆的总线时钟。RMII一般用在多端口的交换机，它不是每个端口安排收、发两个时钟，而是所有的数据端口公用一个时钟用于所有端口的收发，这里就节省了不少的端口数目。RMII的一个端口要求7个数据线，比MII少了一倍，所以交换机能够接入多一倍数据的端口。和MII一样，RMII支持10兆和100兆的总线接口速度。</li>
<li>SMII（Serial MII）是由思科提出的一种媒体接口，它有比RMII更少的信号线数目，S表示串行的意思。因为它只用一根信号线传送发送数据，一根信号线传输接受数据，所以在时钟上为了满足100的需求，它的时钟频率很高，达到了125兆，为什么用125兆，是因为数据线里面会传送一些控制信息。SMII一个端口仅用4根信号线完成100信号的传输，比起RMII差不多又少了一倍的信号线。SMII在工业界的支持力度是很高的。同理，所有端口的数据收发都公用同一个外部的125M时钟。</li>
<li>GMII（Gigabyte MII）是千兆网的MII接口，这个也有相应的RGMII接口，表示简化了的GMII接口。</li>
</ul>
</li>
</ul>
<p><em>MII （Management interface）只有两条信号线。</em></p>
</blockquote>
<p><strong>SGMII</strong></p>
<blockquote>
<p>Serial Gigabit Media Independent Interface</p>
</blockquote>
<p><strong>SerDes</strong></p>
<blockquote>
</blockquote>
<p><strong>ESD</strong></p>
<blockquote>
<p>Electrostatic discharge</p>
</blockquote>
<p><strong>STATS</strong></p>
<blockquote>
</blockquote>
<p><strong>SOP</strong></p>
<blockquote>
<p>Start of Packet, the first fragment of packet</p>
</blockquote>
<p><strong>EOP</strong></p>
<blockquote>
<p>End of Packet, the last fragment of packet</p>
</blockquote>
<p><strong>EOQ</strong></p>
<blockquote>
<p>end-of-queue</p>
</blockquote>
<p><strong>LSB</strong></p>
<blockquote>
<p>least-significant bit</p>
</blockquote>
<p><strong>HDP</strong></p>
<blockquote>
<p>head descriptor pointer</p>
</blockquote>
<p><strong>DMA</strong></p>
<blockquote>
</blockquote>
<p><strong>TXnHDP</strong></p>
<blockquote>
<p>Transmit Channel <em>n</em> DMA Head Descriptor Pointer Register</p>
</blockquote>
<p><strong>RXnHDP</strong></p>
<blockquote>
<p>Receive Channel <em>n</em> DMA Head Descriptor Pointer Register</p>
</blockquote>
<p><strong>Swi</strong></p>
<blockquote>
<p>Software Interrupt</p>
</blockquote>
<p><strong>Hwi</strong></p>
<blockquote>
<p>Hardware Interrupt</p>
</blockquote>
<p><strong>ISR</strong></p>
<blockquote>
<p>中断服务程序</p>
</blockquote>
<p><strong>C99</strong></p>
<blockquote>
<p><strong>C99</strong> （以前称为<strong>C9X</strong> ）是<strong>ISO / IEC 9899：1999</strong>的非正式名称，在1999年推出，被ANSI于2000年3月采用。它是C编程语言标准的过去版本。 它扩展了以前的版本（ C90 ），增加了语言和标准库的新功能，并帮助实现更好地利用可用的计算机硬件，如IEEE  754-1985浮点运算和编译器技术，最主要的增强在数值处理上。 2011年发布的C编程语言标准的C11版本取代了C99。</p>
<p>C99是在C89/90的基础上发展起来的，增加了基本数据类型、关键字和一些系统函数等。</p>
<p>C99有一部分是对于增加了宽字符集，还加入了一些库函数，是继C89标准之后的第二个C语言官方标准。第一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/C%2B%2B">C++</a>语言官方标准C++98标准，就是基于C89编写的，因此C99标准新增的语法特性在C++的编译器中就或多或少地支持了，而完全或几乎完全支持C99标准的主流编译器有：GCC 、Clang 、Intel C++ Compiler 等。另外，Visual Studio 2013也部分支持了C99语法特征 。</p>
<p>C99标准的<strong>草案</strong>是免费的 [6] </p>
</blockquote>
<p><strong>初始化列表</strong></p>
<blockquote>
<p>初始化列表是用于初始化一组（结构体）内存位置的值列表。</p>
<p>例如，假设已经声明了以下 Date 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span>&#123;</span><span class="keyword">int</span> day, month, year;&#125;;</span><br></pre></td></tr></table></figure>

<p>定义和初始化 Date 变量的方式是：先指定变量名，后接赋值运算符和初始化列表，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date birthday = &#123;<span class="number">23</span>, <span class="number">8</span>, <span class="number">1983</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>该声明定义 birthday 是一个 Date 结构体的变量，大括号内的值按顺序分配给其成员。</p>
<p>也可以仅初始化结构体变量的部分成员。例如，如果仅知道要存储的生日是8月23日， 但不知道年份，则可以按以下方式定义和初始化变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date birthday = &#123;<span class="number">23</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这里只有 day 和 month 成员被初始化，year 成员未初始化。但是，如果某个结构成员未被初始化，则所有跟在它后面的成员都需要保留为未初始化。使用初始化列表时，<a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 不提供跳过成员的方法。以下语句试图跳过 month 成员的初始化。这是不合法的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date birthday &#x3D; &#123;23,1983&#125;; &#x2F;&#x2F;非法</span><br></pre></td></tr></table></figure>

<p>还有一点很重要，不能在结构体声明中初始化结构体成员，因为结构体声明只是创建一个新的数据类型，还不存在这种类型的变量。因为<strong>结构体声明只声明一个结构体“看起来是什么样子的”，所以不会在内存中创建成员变量。</strong>只有通过定义该结构体类型的变量来实例化结构体，才有地方存储初始值。</p>
</blockquote>
<p><strong>构造函数</strong></p>
<blockquote>
<p>虽然初始化列表易于使用，但它有两个缺点：</p>
<ol>
<li>如果有某个成员未被初始化，那么在这种情况下，跟随在该成员后面的成员都不能初始化。</li>
<li>如果结构体包括任何诸如字符串之类的对象，那么在许多编译器上它都将无法运行。</li>
</ol>
<p>在这些情况下，可以使用构造函数来初始化结构体成员变量，这和初始化类成员变量是相同的。与类构造函数一样，结构体的构造函数必须是与结构体名称相同的公共成员函数，并且没有返回类型。因为默认情况下，所有结构体成员都是公开的，所以不需要使用关键字 public。</p>
<p>以下是一个名为 Employee 的结构体的声明语句，它包含一个具有两参数的构造函数，以便在创建一个 Employee 变量而不向其传递任何参数时，提供默认值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;    <span class="comment">// 员工姓名</span></span><br><span class="line">    <span class="keyword">int</span> vacationDays,    <span class="comment">// 允许的年假</span></span><br><span class="line">    daysUsed;    <span class="comment">//已使用的年假天数</span></span><br><span class="line">    Employee (<span class="built_in">string</span> n =<span class="string">&quot;&quot;</span>,<span class="keyword">int</span> d = <span class="number">0</span>)    <span class="comment">// 构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        vacationDays = <span class="number">10</span>;</span><br><span class="line">        daysUsed = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>Const in C++</strong></p>
<blockquote>
<ol>
<li><p><strong>const与#define</strong></p>
<p>两者都可以用来定义常量，但是const定义时，定义了常量的类型，所以更精确一些。</p>
<p>#define只是简单的文本替换，除了可以定义常量外，还可以用来定义一些简单的函数，有点类似内联函数(Inline)。</p>
<p>const和define定义的常量可以放在头文件里面。（小注：可以多次声明，但只能定义一次）</p>
</li>
<li><p><strong>const与指针和引用</strong></p>
<ul>
<li><p>const与指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> me;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p1 = &amp;me;<span class="comment">//p1可变，*p1不可变，此时不能用*p1来修改，但是p1可以转向</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p2 = &amp;me;<span class="comment">//p2不可变，*p2可变，此时允许*p2来修改其值，但是p2不能转向。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p3 = &amp;me;<span class="comment">//p3不可变，*p3也不可变，此时既不能用*p3来修改其值，也不能转向</span></span><br></pre></td></tr></table></figure></li>
<li><p>指针和引用的区别很简单，就是引用更简洁，更安全。因为引用声明时必须初始化。 引用更接近const指针，一旦与某个变量关联，就将一直效忠于他。</p>
</li>
<li><p><strong>const指针可以接受const和非const地址，但是非const指针只能接受非const地址</strong>。所以const指针的能力更强一些，所以尽量多用const指针，这是一种习惯。</p>
</li>
</ul>
</li>
<li><p>const与函数</p>
</li>
</ol>
<ul>
<li><p>由于2.3，所以经常把函数的形参类型设为const，而且多为<strong>const 引用</strong>。但是这里有一个限制，<strong>不能把不是左值的地址传递给引用</strong>。（左值包括变量，数组元素，结构成员，引用，被解除引用的指针等）。 形参是const类型的，说明该函数将不会修改其值，该函数便为const函数。</p>
</li>
<li><p>const与类成员函数。先看看下面这段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Stock land = Stock(<span class="string">&quot;hyd&quot;</span>);</span><br><span class="line">land.show();</span><br></pre></td></tr></table></figure>

<p>land 是常量，但是类成员函数show()无法保证不修改land，所以编译器将拒绝执行该段代码。除非你能保证show像const函数一样，但这需要另外一种语法，即：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::show</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;&#125; <span class="comment">//定义</span></span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<p><strong>内联函数</strong></p>
<blockquote>
<p>Inline Functions</p>
</blockquote>
<p><strong>超级循环</strong></p>
<blockquote>
</blockquote>
<p><strong>ANC</strong></p>
<blockquote>
</blockquote>
<p><strong>IPC</strong></p>
<blockquote>
<p>Inter-Processor Communication</p>
<p>内部处理器通信</p>
</blockquote>
<p><strong>NDK</strong></p>
<blockquote>
<p>Network Development Kit</p>
<p>网络开发套件</p>
</blockquote>
<p><strong>GPIO</strong></p>
<blockquote>
<p>General Purpose Input/Output</p>
<p>通用型之输入输出的简称，功能类似8051的P0—P3，其接脚可以供使用者由程控自由使用，PIN脚依现实考量可作为通用输入（GPI）或通用输出（GPO）或通用输入与输出（GPIO），如当clk generator, chip select等。</p>
<p>既然一个引脚可以用于输入、输出或其他特殊功能，那么一定有寄存器用来选择这些功能。对于输入，一定可以通过读取某个寄存器来确定引脚电位的高低；对于输出，一定可以通过写入某个寄存器来让这个引脚输出高电位或者低电位；对于其他特殊功能，则有另外的寄存器来控制它们。</p>
</blockquote>
<p><strong>EMIFA</strong></p>
<blockquote>
</blockquote>
<p><strong>SRIO</strong></p>
<blockquote>
<p>高速串行IO口</p>
</blockquote>
<p><strong>Hyperlink</strong></p>
<blockquote>
<p>超链接</p>
</blockquote>
<p><strong>JTAG</strong></p>
<blockquote>
</blockquote>
<p><strong>Warm reset</strong> </p>
<blockquote>
<p> 软复位</p>
</blockquote>
<p><strong>LLD</strong></p>
<blockquote>
<p>Low Level Driver</p>
</blockquote>
<p><strong>HAL</strong></p>
<blockquote>
<p>Hardware Adaption Layer硬件适应层</p>
</blockquote>
<p><strong>IGMP</strong></p>
<blockquote>
<p>Internet Group Management Protocol</p>
<p>Internet Group Management Protocol (IGMP) is designed to help routers in routing IP multicast traffic. Each router can have multiple ports, and it is inefficient for the router to replicate every IP multicast packet out of each active port. Using the IGMP protocol, the multicast router is able to keep track of which IP multicast addresses need to be routed to each individual port. This allows the router to limit IP multicast transmission to only those ports that require the multicast traffic.<br>IGMP 是用来帮助路由器路由IP组播流量的。每个路由器可以有多个端口，并且路由器从每个活动端口复制每个IP组播包是低效的。使用IGMP协议，组播路由器能够跟踪哪些IP组播地址需要被路由到每个单独的端口。这允许路由器将IP组播传输限制为仅需要组播流量的端口。</p>
<p>The IGMP protocol assumes a client/server relationship between endpoints. The IGMP server is run by the multicast router to get IP multicast information about all the client on each of its individual ports. The IGMP client is only concerned with communicating its own multicast requirements to the local IGMP server, so that it will get the IP multicast packets that it requires.<br>IGMP协议假定端点之间存在客户端/服务器关系。IGMP服务器由组播路由器运行，以获得关于每个单独端口上的所有客户端的IP组播信息。IGMP客户端只关心把它自己的组播要求传达给本地IGMP服务器，这样它就会得到它所需要的IP组播包。</p>
</blockquote>
<h1 id="Vocabulary"><a href="#Vocabulary" class="headerlink" title="Vocabulary"></a>Vocabulary</h1><ol>
<li><p>granularity n. 间隔尺寸，[岩] 粒度</p>
<blockquote>
<p>the quality of being composed of relatively large particles</p>
</blockquote>
</li>
<li><p>be patched with 用**修补</p>
<blockquote>
<p><strong>patched</strong> <em>/pætʃt/</em>  </p>
<p>adj. 打补丁的  v. 打补丁；遮盖（视力好的眼）促进弱视眼看；（用补丁对程序）改错（patch 的过去式和过去分词）</p>
</blockquote>
</li>
<li><p>an entire contiguous Ethernet packet 一个完整连续的以太网包</p>
</li>
<li><p>byte-aligned memory address 字节内存地址</p>
<blockquote>
<p><strong>aligned</strong> [əˈlaɪnd] </p>
<p>v. 结盟；支持；使成一直线；校准；安放，排列；使一致（align 的过去式和过去分词）</p>
</blockquote>
</li>
<li><p>prior <em>[ˈpraɪər]</em> adj. （时间、顺序等）先前的；优先的</p>
</li>
<li><p>indicate vt. 表明；指出；预示；象征</p>
</li>
<li><p>prologue <em>/prəʊlɒg/</em> n. 开场白</p>
</li>
<li><p>auxiliary definitions 辅助定义</p>
<blockquote>
<p><strong>auxiliary</strong> [ɔːɡˈzɪliəri] </p>
<p>adj. 辅助的；副的；附加的；（发动机、设备等）备用的</p>
</blockquote>
</li>
<li><p>static inline 静态内联</p>
</li>
<li><p>volatile unsigned int</p>
<blockquote>
<p><strong>volatile</strong> [ˈvɒlətaɪl] </p>
<p>adj. [化学] 挥发性的；不稳定的；爆炸性的；反复无常的</p>
<p>n. 挥发物；有翅的动物</p>
</blockquote>
</li>
<li><p>heap n. 信号量</p>
</li>
<li><p>explicity and implicity 显性和隐性</p>
<blockquote>
<p><strong>explicitly</strong>  [ɪkˈsplɪsɪtli]</p>
<p>adv. 明确地；明白地</p>
<p><strong>implicitly</strong>  [ɪmˈplɪsɪtli]</p>
<p>adv. 含蓄地；暗中地</p>
</blockquote>
</li>
<li><p>assertion check 断言检查</p>
<blockquote>
<p><strong>assertion</strong> [əˈsɜːʃn]</p>
<p>n. 断言，声明；主张，要求；坚持；认定</p>
<p>assert</p>
<p>internal asserts</p>
</blockquote>
</li>
<li><p>wrapper function 包装函数</p>
</li>
<li><p>name mangling （函数）命名重整</p>
<blockquote>
<p><strong>mangle</strong> <em>/mæŋgl/</em></p>
<p>vt. 乱砍、损坏</p>
<p> The process of encoding the signature into the link name is referred to as <strong>name mangling</strong>.  对链接名称解码签名的过程被称为命名重整。</p>
<p>Since function overloading is accomplished through <strong>name mangling</strong>, function overloading has limitations for functions that are called from the configuration. 由于函数重载是通过命名重整完成的，因此函数重载对从配置中调用的函数有限制。</p>
</blockquote>
</li>
<li><p>periodic <em>/periɒdik/</em> adj. 周期的</p>
<blockquote>
<p><strong>period</strong> n. 周期</p>
</blockquote>
</li>
<li><p>instantiation of clock 时钟实例化</p>
</li>
<li><p>advancing the connected timer by one second 将连接的时钟向前推进1秒</p>
<blockquote>
<p>advance at different rates 以不同的速率前进</p>
</blockquote>
</li>
<li><p>the attached clock 附带的时钟</p>
</li>
<li><p>results in an accurate clock 产生了（导致、致使）一个精确的时钟</p>
</li>
<li><p>constructor n. 构造函数；构造器；建造者</p>
</li>
<li><p>destructor n. 析构函数</p>
</li>
<li><p>millenium n. 千年；千禧年</p>
</li>
<li><p>leap year 闰年</p>
</li>
<li><p>millisecond [ˈmɪlisekənd] n. 毫秒；千分之一秒</p>
<blockquote>
<p>microsecond 微秒</p>
</blockquote>
</li>
<li><p>semaphore  [ˈseməfɔːr] n. 信号标，旗语；臂板信号装置 v. 打旗语，发信号</p>
</li>
<li><p>diagnostics n. 诊断学（用作单数）</p>
</li>
<li><p>declaration <em>/,deklə’reiʃən/</em> n. （纳税品等的）申报；宣布；公告；申诉书；声明；</p>
</li>
<li><p>prefix n. 前缀 vt. 加前缀；将某事物加在前面</p>
</li>
<li><p>assembly source 汇编源代码</p>
<blockquote>
<p>assembly code 汇编码</p>
</blockquote>
</li>
<li><p>toggle split editor 切换分屏编辑器</p>
<blockquote>
<p><strong>toggle</strong> [ˈtɒɡl]</p>
<p>n. 拴扣；切换键，开关；套索钉</p>
<p>v. 切换；拴牢，系紧</p>
<p><strong>split</strong> [splɪt]</p>
<p>vt. 分离；使分离；劈开；离开；分解<br>vi. 离开；被劈开；断绝关系<br>n. 劈开；裂缝<br>adj. 劈开的</p>
<p>toggle full screen 切换全屏幕</p>
<p>toggle funciton</p>
</blockquote>
</li>
<li><p>perspective n. 观点；远景；透视图 adj. 透视的</p>
<blockquote>
<p>customize perspective </p>
</blockquote>
</li>
<li><p>energia [e’nə:dʒiə] n. (Energia) 能源（火箭名）</p>
<blockquote>
<p>energia sketch 能源草图？</p>
</blockquote>
</li>
<li><p>specifications for benchmark tests 基准测试规范</p>
<blockquote>
<p><strong>specification</strong></p>
<p>​    a detailed description of design criteria for a piece of work</p>
<p>​    n. 规范</p>
<p><strong>benchmark</strong> </p>
<p>​    a standard by which something can be measured or judged</p>
<p>​    n. 参考标准，基准</p>
</blockquote>
</li>
<li><p>target-specific functions 目标特定的功能</p>
<blockquote>
<p>device-specific functions 设备特定的功能</p>
</blockquote>
</li>
<li><p>implementation of the IGateProvider interface     IGateProvider 接口的实现</p>
<blockquote>
<p><strong>implement</strong></p>
<p>​    apply in a manner consistent with its purpose or design</p>
<p>​    v. 实现</p>
</blockquote>
</li>
<li><p>fixed-size buffers 固定大小缓冲</p>
<blockquote>
<p><strong>fixed</strong></p>
<p>​    adj. 固定的</p>
<p>variable-sized buffers 可变大小缓冲</p>
</blockquote>
</li>
<li><p> dynamic memory allocation and deallocation 动态内存分配和回收</p>
</li>
<li><p>reentrant versions 可重入版本</p>
<blockquote>
<p>SYS/BIOS provides reentrant versions of malloc() and free() that internally use the xdc.runtime.</p>
<p>SYS/BIOS为内部使用XDC.RUNTIME的 malloc() 和 free() 提供了可重入版本。</p>
</blockquote>
</li>
<li><p>formal parameter 形式参数</p>
<blockquote>
<p>C++ allows you to specify default values for formal parameters within the function declaration. </p>
<p>C++允许你在函数声明中指定形参的默认值。</p>
</blockquote>
</li>
<li><p>invoke the class member function 调用类成员函数</p>
<blockquote>
<p>By writing a wrapper function which accepts a class instance as a parameter, you can invoke the class member function from within the wrapper. 通过编写以类实例作为参数的包装函数，你可以在包装函数中调用其类成员函数。</p>
</blockquote>
</li>
<li><p>context of a software interrupt 软件中断的上下文</p>
<blockquote>
<p>Memory allocation APIs such as <code>Memory_alloc()</code> and <code>Memory_calloc()</code> cannot be called from within the context of a software interrupt.内存分配接口如A和B不能够在软件中断的上下文中被调用。</p>
</blockquote>
</li>
<li><p>initial commit message 初始提交消息</p>
<blockquote>
<p><strong>commit</strong> [kəˈmɪt]</p>
<p>​    vt. 犯罪；把…交托给；指派…作战；使…承担义务；（公开地）表示意见</p>
<p>​    vi. 忠于（某个人、机构等）；承诺</p>
<p>amend last commit 修改上一次提交（的数据）</p>
</blockquote>
</li>
<li><p>stage changed （确认）暂存（数据）已变化</p>
</li>
<li><p>device endianness  设备字节顺序</p>
</li>
<li><p>preempt 抢占</p>
<blockquote>
<p> All Clock functions run at the same Swi priority, so one Clock function cannot preempt another. 所有的时钟函数都运行在相同的SWI优先级，所以一个时钟函数不能抢占另一个时钟函数。</p>
</blockquote>
</li>
<li><p>terminate <em>/ˈtɜːmɪneɪt/</em>   vi./vt. 使终止；使结束；解雇</p>
</li>
<li><p>Event Combiner 事件组合器</p>
</li>
<li><p>optimal isolation 最佳隔离？？？</p>
<blockquote>
<p>As previously stated, the stack has been designed for optimal isolation, and so that it may seamlessly plug in to varying run-time environments. </p>
</blockquote>
</li>
<li><p>octet /ɔk’tet/ 八重、八位（计算机语境下，基本与byte同意）</p>
</li>
<li><p>configuration entry 配置条目</p>
</li>
<li><p>is independent of 独立于……；相对于……独立</p>
</li>
<li><p>Parsing CGI Form Data 解析CGI结构的数据</p>
<blockquote>
<p>parse <em>/‘pɑːz/</em> v.理解，从语法上分析</p>
</blockquote>
</li>
<li></li>
</ol>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="http://www.digoboy.com/">www.digoboy.com</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/23/Linux/How%20to%20Install%20GCC%20(build-essential)%20on%20Ubuntu%2020.04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/23/Linux/How%20to%20Install%20GCC%20(build-essential)%20on%20Ubuntu%2020.04/" class="post-title-link" itemprop="url">How to Install GCC (build-essential) on Ubuntu 20.04</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-23 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-23T23:58:32+08:00">2021-04-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-29 00:51:49" itemprop="dateModified" datetime="2021-04-29T00:51:49+08:00">2021-04-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[linuxize.com](<a target="_blank" rel="noopener" href="https://linuxize.com/post/how-to-install-gcc-on-ubuntu-20-04/#:~:text=The">https://linuxize.com/post/how-to-install-gcc-on-ubuntu-20-04/#:~:text=The</a> default Ubuntu repositories contain a meta-package named,as root or user with sudo privileges %3A)</p>
<p>The GNU Compiler Collection (GCC) is a collection of compilers and libraries for C, C++, Objective-C, Fortran, Ada, <a target="_blank" rel="noopener" href="https://linuxize.com/post/how-to-install-go-on-ubuntu-20-04/">Go</a> , and D programming languages. A lot of open-source projects, including the Linux kernel and GNU tools, are compiled using GCC.</p>
<p>This article explains how to install GCC on Ubuntu 20.04.</p>
<h1 id="Installing-GCC-on-Ubuntu-20-04"><a href="#Installing-GCC-on-Ubuntu-20-04" class="headerlink" title="Installing GCC on Ubuntu 20.04"></a>Installing GCC on Ubuntu 20.04</h1><p>The default Ubuntu repositories contain a meta-package named  “build-essential” that includes the GNU compiler collection, GNU  debugger, and other development libraries and tools required for  compiling software.</p>
<p>To install the Development Tools packages, run the following command as root or <a target="_blank" rel="noopener" href="https://linuxize.com/post/how-to-create-a-sudo-user-on-ubuntu/">user with sudo privileges</a> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install build-essential</span><br></pre></td></tr></table></figure>

<p>The command installs a lot of packages, including <code>gcc</code>, <code>g++</code> and <code>make</code>.</p>
<p>You may also want to install the manual pages about using GNU/Linux for development:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install manpages-dev</span><br></pre></td></tr></table></figure>

<p>Verify that the GCC compiler is successfully installed by running the following command that prints the GCC version:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure>

<p>Ubuntu 20.04 repositories provide GCC version <code>9.3.0</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc (Ubuntu 9.3.0-10ubuntu2) 9.3.0</span><br><span class="line">Copyright (C) 2019 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure>

<p>That’s it. GCC tools and libraries have been installed on your Ubuntu system.</p>
<h1 id="Compiling-a-Hello-World-Example"><a href="#Compiling-a-Hello-World-Example" class="headerlink" title="Compiling a Hello World Example"></a>Compiling a Hello World Example</h1><p>Compiling a basic C or C++ program using GCC is pretty easy. Open your <a target="_blank" rel="noopener" href="https://linuxize.com/post/how-to-install-visual-studio-code-on-ubuntu-18-04/">text editor</a> and create the following file:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano hello.c</span><br></pre></td></tr></table></figure>

<p>hello.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; hello.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Hello, world!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Save the file and compile it into an executable:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></table></figure>

<p>This creates a binary file named <code>hello</code> in the same directory where you run the command.</p>
<p>Execute the <code>hello</code> program with:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;hello</span><br></pre></td></tr></table></figure>

<p>The program should print:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<h1 id="Installing-Multiple-GCC-Versions"><a href="#Installing-Multiple-GCC-Versions" class="headerlink" title="Installing Multiple GCC Versions"></a>Installing Multiple GCC Versions</h1><p>This section provides instructions about how to install and use multiple  versions of GCC on Ubuntu 20.04. The newer versions of the GCC compiler  include new functions and optimization improvements.</p>
<p>At the time of writing this article, the default Ubuntu repositories include several GCC versions, from <code>7.x.x</code> to <code>10.x.x</code>.</p>
<p>In the following example, we will install the latest three versions of GCC and G++.</p>
<p>Install the desired GCC and G++ versions by typing:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc-8 g++-8 gcc-9 g++-9 gcc-10 g++-10</span><br></pre></td></tr></table></figure>

<p>The commands below configures alternative for each version and associate a  priority with it. The default version is the one with the highest  priority, in our case that is <code>gcc-10</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;gcc gcc &#x2F;usr&#x2F;bin&#x2F;gcc-10 100 --slave &#x2F;usr&#x2F;bin&#x2F;g++ g++ &#x2F;usr&#x2F;bin&#x2F;g++-10 --slave &#x2F;usr&#x2F;bin&#x2F;gcov gcov &#x2F;usr&#x2F;bin&#x2F;gcov-10sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;gcc gcc &#x2F;usr&#x2F;bin&#x2F;gcc-9 90 --slave &#x2F;usr&#x2F;bin&#x2F;g++ g++ &#x2F;usr&#x2F;bin&#x2F;g++-9 --slave &#x2F;usr&#x2F;bin&#x2F;gcov gcov &#x2F;usr&#x2F;bin&#x2F;gcov-9sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;gcc gcc &#x2F;usr&#x2F;bin&#x2F;gcc-8 80 --slave &#x2F;usr&#x2F;bin&#x2F;g++ g++ &#x2F;usr&#x2F;bin&#x2F;g++-8 --slave &#x2F;usr&#x2F;bin&#x2F;gcov gcov &#x2F;usr&#x2F;bin&#x2F;gcov-8</span><br></pre></td></tr></table></figure>

<p>Later if you want to change the default version use the <code>update-alternatives</code> command:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --config gcc</span><br><span class="line">There are 3 choices for the alternative gcc (providing &#x2F;usr&#x2F;bin&#x2F;gcc).</span><br><span class="line"></span><br><span class="line">  Selection    Path            Priority   Status</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">* 0            &#x2F;usr&#x2F;bin&#x2F;gcc-10   100       auto mode</span><br><span class="line">  1            &#x2F;usr&#x2F;bin&#x2F;gcc-10   100       manual mode</span><br><span class="line">  2            &#x2F;usr&#x2F;bin&#x2F;gcc-8    80        manual mode</span><br><span class="line">  3            &#x2F;usr&#x2F;bin&#x2F;gcc-9    90        manual mode</span><br><span class="line"></span><br><span class="line">Press &lt;enter&gt; to keep the current choice[*], or type selection number:</span><br></pre></td></tr></table></figure>

<p>You will be presented with a list of all installed GCC  versions on your Ubuntu system. Enter the number of the version you want to be used as a default and press <code>Enter</code>.</p>
<p>The command will create <a target="_blank" rel="noopener" href="https://linuxize.com/post/how-to-create-symbolic-links-in-linux-using-the-ln-command/">symbolic links</a> to the specific versions of GCC and G++.</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>We’ve shown you how to installed GCC on Ubuntu 20.04. You can now visit the official <a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/">GCC Documentation</a> page and learn how to use GCC and G++ to compile your C and C++ programs.</p>
<p>If you hit a problem or have feedback, leave a comment below.</p>
<p>​          </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/23/Hardware/ADI/AnalogDeviceSignmaStudio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/23/Hardware/ADI/AnalogDeviceSignmaStudio/" class="post-title-link" itemprop="url">ADI开发笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-23 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-23T23:58:32+08:00">2021-04-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-29 00:34:36" itemprop="dateModified" datetime="2021-04-29T00:34:36+08:00">2021-04-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hardware/" itemprop="url" rel="index"><span itemprop="name">Hardware</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[TOC]</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>原理图模块 是指用于构建SigmaStudio设计的模块。每个处理器可用的块显示在“工具箱”和“树形工具箱”窗口中，可以将其拖放到原理图中。</p>
<h3 id="Algorithms-Add-Remove-Grow-Reduce"><a href="#Algorithms-Add-Remove-Grow-Reduce" class="headerlink" title="Algorithms: Add/Remove, Grow/Reduce"></a>Algorithms: Add/Remove, Grow/Reduce</h3><p>每个原理图块代表一种或多种信号处理算法。算法的范围从非常简单的<a target="_blank" rel="noopener" href="https://wiki.analog.com/resources/tools-software/sigmastudio/toolbox/basicdsp/signaladd">信号添加</a>（如<a target="_blank" rel="noopener" href="https://wiki.analog.com/resources/tools-software/sigmastudio/toolbox/basicdsp/signaladd">Signal Add</a>）到高级系统组件（如<a target="_blank" rel="noopener" href="https://wiki.analog.com/resources/tools-software/sigmastudio/toolbox/adialgorithms/dynamicbassboost">Dynamic Bass Boost）</a>。您可以从块中添加或删除算法以满足您的特定要求。如下所述，算法也可以增长。</p>
<hr>
<p><strong>添加算法：</strong></p>
<p>您必须添加一种算法-通常与一组I / O引脚关联-才能使块起作用。要将算法添加到块，请<strong>右键单击</strong>该块，然后选择<strong>添加算法&gt; IC＃</strong>，然后选择<strong>算法</strong>的DSP IC。请注意，如果您的项目中有多个处理器（IC / DSP），则可以选择哪个DSP将运行算法，有关更多信息，请参见下文。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic1.png?id=resources:tools-software:sigmastudio:usingsigmastudio:buildingschematics:algorithms"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic1.png" alt="img"></a></p>
<p>此时，如果需要，右键单击块的边界或标签以添加其他算法。（重要的是右键单击边框或标签；如果右键单击中心，则可能会显示用于输入参数值的弹出窗口。）</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic2.png?id=resources:tools-software:sigmastudio:usingsigmastudio:buildingschematics:algorithms"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic2.png" alt="img"></a></p>
<p>不包含算法的块将没有控件或引脚，并且您只会看到该块的名称（如下图所示）。必须在空块中添加算法，然后才能在原理图设计中使用它们。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic3.png?id=resources:tools-software:sigmastudio:usingsigmastudio:buildingschematics:algorithms"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic3.png" alt="img"></a></p>
<p>注意：使用“<a target="_blank" rel="noopener" href="https://wiki.analog.com/resources/tools-software/sigmastudio/developmentenvironment/toolbox">树形工具箱”窗口时</a>，总是为每个插入的块创建一个算法。但是，如果使用传统的“<a target="_blank" rel="noopener" href="https://wiki.analog.com/resources/tools-software/sigmastudio/developmentenvironment/toolbox">工具箱”</a>窗口插入块，则可能还必须添加算法。</p>
<p>添加算法时，不仅要为模块选择计算方法，还要为算法选择特定的DSP关联。如果要连接多个DSP处理器，这一点很重要：通过将算法添加到模块中，可以共享模块和控件，并同时与多个DSP进行通信。</p>
<p>例如：<a target="_blank" rel="noopener" href="https://wiki.analog.com/resources/tools-software/sigmastudio/volumecontrols/singlevolumecontrol">单个音量控制</a>块具有用于所有算法的单个滑块控件。如果使用2个DSP处理器（IC 1（AD1940）和IC 2（ADAU1701））创建一个项目，然后选择“添加算法”，则系统将提示您要将该算法添加到哪个芯片。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic4.png?id=resources:tools-software:sigmastudio:usingsigmastudio:buildingschematics:algorithms"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic4.png" alt="img"></a></p>
<p>可以将第一种算法分配给IC 1，将第二种算法分配给IC 2，但是它们共享音量块和单个滑块控件。请注意，您不能在不同的处理器之间建立连线，有关更多信息，请参见<a target="_blank" rel="noopener" href="https://wiki.analog.com/resources/tools-software/sigmastudio/usingsigmastudio/wiresandaliases">连线</a>主题。</p>
<hr>
<p><strong>删除算法：</strong></p>
<p>也可以从块中删除算法。要删除算法，请<strong>右键单击</strong>该块，然后选择“<strong>删除算法”</strong>。这将删除最后添加的算法（底部引脚）。如果该块仅包含一种算法，则删除该算法将导致一个空块</p>
<hr>
<p><strong>增长算法：</strong></p>
<p>不断增长的算法意味着在该块的现有算法的基础上，保持相同的算法（在其上进行扩展）和相同的DSP关联（添加算法均不执行）。要增长算法，请<strong>右键单击</strong>该块，然后选择“<strong>增长算法”&gt;“（算法名称）”&gt;“（增长量）”</strong>。请注意，并非所有算法都可以使用增长。</p>
<p>理解添加和增长之间区别的最简单方法是使用混合器块。将交叉混合器（2个输入）拖到工作区中。右键单击并选择“增长算法”，请参见下面的示例。</p>
<ul>
<li>增加混音器会创建更多的混音器输出引脚，实际上，您正在创建共享公共输入的额外混音器输出通道。块中仍然只有一个算法。</li>
<li>添加算法将创建单独的算法，这些算法共享控制窗口，但不共享输入/输出引脚或资源。在混频器示例中，一个附加的输入引脚，输出引脚和一个交叉混频器控件被添加到了该模块中。</li>
</ul>
<hr>
<p><strong>减少算法：</strong></p>
<p>减少与增加相反，减少了由“增加算法”操作创建的多余控件和引脚。像删除算法一样，reduce将删除从底部或最近增长的项目开始的控件/大头针。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic5.png?id=resources:tools-software:sigmastudio:usingsigmastudio:buildingschematics:algorithms"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic5.png" alt="img"></a></p>
<h3 id="Wires-and-Aliases"><a href="#Wires-and-Aliases" class="headerlink" title="Wires and Aliases"></a>Wires and Aliases</h3><p>SigmaStudio原理图设计由与“导线”连接在一起的模块构建。导线定义了系统的信号流。</p>
<p><strong>要创建原理图导线：</strong> 将鼠标光标移到块的<a target="_blank" rel="noopener" href="https://wiki.analog.com/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/schematicblocks">引脚上，</a>以便显示导线图标<a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/icon.png?id=resources:tools-software:sigmastudio:usingsigmastudio:buildingschematics:wiresandaliases"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/icon.png" alt="img"></a>。接下来，左键单击一个块引脚，然后在按住鼠标按钮的同时，将光标拖到另一个块的相应引脚上。输入引脚只能连接到输出引脚，而输出引脚只能连接到输入引脚。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic1.png?id=resources:tools-software:sigmastudio:usingsigmastudio:buildingschematics:wiresandaliases"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic1.png" alt="img"></a></p>
<p><strong>选择：</strong></p>
<p>要选择一条导线，请用鼠标左键单击它。选定的电线用绿色正方形（点）表示，如下所示。<strong>位置：</strong></p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic2.png?id=resources:tools-software:sigmastudio:usingsigmastudio:buildingschematics:wiresandaliases"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic2.png" alt="img"></a></p>
<p>要更改导线的位置，请将鼠标光标放在一个点上。接下来，在导线点上<strong>单击</strong>鼠标左键，并在按住鼠标键的同时拖动光标以重新放置导线。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic3.png?id=resources:tools-software:sigmastudio:usingsigmastudio:buildingschematics:wiresandaliases"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic3.png" alt="img"></a></p>
<p><strong>菜单：</strong></p>
<p>右键单击导线以调出导线菜单。该菜单包括以下命令：</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic4.png?id=resources:tools-software:sigmastudio:usingsigmastudio:buildingschematics:wiresandaliases"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic4.png" alt="img"></a></p>
<p><strong>电线颜色：</strong></p>
<p>电线根据其关联的DSP处理器进行着色。导线的输入和输出引脚必须与同一DSP关联，否则您将无法在引脚之间建立导线。具有多个处理器IC的项目的每个IC将具有不同的颜色。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic5.png?id=resources:tools-software:sigmastudio:usingsigmastudio:buildingschematics:wiresandaliases"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic5.png" alt="img"></a></p>
<hr>
<p><strong>引脚（导线）备注：</strong></p>
<p>为了直观地组织项目，通常有助于创建备注，以在原理图中的信号流中提供清晰的连接参考（“跳转”）。一个<strong>备注</strong>由一对输入的备注和备注输出块组成。使用备注块可以减少长导线连接所造成的原理图窗口中的视觉混乱。</p>
<p>要创建备注，请<strong>右键单击</strong>块的输出引脚（蓝色引脚），然后从菜单中选择“<strong>备注</strong>”。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic6.png?id=resources:tools-software:sigmastudio:usingsigmastudio:buildingschematics:wiresandaliases"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic6.png" alt="img"></a></p>
<p>当您单击<strong>Alias时</strong>，将出现两个块，分别是输入和输出。备注输入自动连接到源模块的输出引脚。接下来，创建一条从备注输出块（在下面的示例中为备注2）到信号目标的导线。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic7.png?id=resources:tools-software:sigmastudio:usingsigmastudio:buildingschematics:wiresandaliases"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic7.png" alt="img"></a></p>
<p><strong>注意：</strong>使用备注在功能上等同于用电线连接两个引脚。以下示例中的信号流与上面的备注示例相同。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic8.png?id=resources:tools-software:sigmastudio:usingsigmastudio:buildingschematics:wiresandaliases"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic8.png" alt="img"></a></p>
<h3 id="Hardware-Configuration-Tab"><a href="#Hardware-Configuration-Tab" class="headerlink" title="Hardware Configuration Tab"></a>Hardware Configuration Tab</h3><p>硬件配置工作区允许您为设计选择一个或多个处理器。它还允许您设置SigmaStudio与硬件之间的通信。</p>
<p>要了解可以在“硬件配置”选项卡中访问的高级操作（包括“输出捕获”，“ Flash / E2Prom下载”，“寄存器控制”窗口和“寄存器读/写”窗口），请参阅“硬件Windows”部分中的主题。</p>
<h4 id="要将处理器（IC-DSP）插入设计中："><a href="#要将处理器（IC-DSP）插入设计中：" class="headerlink" title="要将处理器（IC / DSP）插入设计中："></a>要将处理器（IC / DSP）插入设计中：</h4><ol>
<li><p>用鼠标左键从工具箱中选择一个“处理器”：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic1.png?id=resources:tools-software:sigmastudio:developmentenvironment:hardwareconfigurationtab"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic1.png" alt="img"></a></li>
</ol>
</li>
<li><p>将处理器模块拖放到右侧的“硬件配置”窗口中：</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic2.png?id=resources:tools-software:sigmastudio:developmentenvironment:hardwareconfigurationtab"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic2.png" alt="img"></a></p>
</li>
</ol>
<p><strong>注意：</strong>一旦在“硬件配置”窗口中插入DSP，就会出现“原理图（Schematic）”选项卡。</p>
<h4 id="在DSP处理器和硬件之间建立连接："><a href="#在DSP处理器和硬件之间建立连接：" class="headerlink" title="在DSP处理器和硬件之间建立连接："></a>在DSP处理器和硬件之间建立连接：</h4><ol>
<li>单击“通信渠道（Communication Channel）”类别（在“工具箱”列的底部）。</li>
<li>从列表中选择评估板或USB设备，并将其拖放到工作区中。</li>
<li>通过在通信通道和处理器模块之间画线来连接两个模块，从蓝色菱形到绿色菱形。对于使用AD1940的USB连接，工作空间中的单元格应如下所示：</li>
</ol>
<p><strong>注意</strong>：“通信通道”菜单列出了带有前缀EvalBoard的名称和板号。这些通信通道将在不使用评估板设置的平台上适用于相同的IC类型。还有通用的通信通道，USBSerialConv和USBi。（有关更多信息，请参见USB串行转换器通信通道或USBi。）</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic3.png?id=resources:tools-software:sigmastudio:developmentenvironment:hardwareconfigurationtab"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic3.png" alt="img"></a></p>
<p>通信模块上USB标签 的颜色表示是否已建立USB通信通道。如果您已正确配置USB硬件，则背景色将为浅橙色或白色。如果未初始化通信，则背景将为红色。请注意，这仅表示USB连接处于活动状态，不能保证与SigmaDSP IC的通信或SigmaDSP硬件已正确配置。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic4.png?id=resources:tools-software:sigmastudio:developmentenvironment:hardwareconfigurationtab"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic4.png" alt="img"></a></p>
<p>连接所有板卡IC时，“已连接”背景色为白色，而仅连接部分IC（但不是全部）时为“橙色”。例如，ADAU1701评估板包括ADAU1701 IC和E2Prom IC。仅连接ADAU1701时，背景将为浅橙色，但同时连接ADAU1701和E2Prom IC时，背景将为白色。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic5.png?id=resources:tools-software:sigmastudio:developmentenvironment:hardwareconfigurationtab"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic5.png" alt="img"></a></p>
<h3 id="USB串行转换器"><a href="#USB串行转换器" class="headerlink" title="USB串行转换器"></a>USB串行转换器</h3><p><em><strong>本文介绍了ADI公司不再提供的过时的硬件。包含此信息作为2007年前评估委员会用户的参考。不建议将AD1953用于新设计。此处包含与AD1953相关的信息，仅供参考。</strong></em></p>
<p>ADI公司的USB串行转换器（EVAL-ADUSB1）板是PC的USB端口与评估板控制端口连接之间的接口。对于AD1953，-1954，-1940和-1941板，USB串行转换器直接连接到板上的DB25连接器。</p>
<p>该USB适配器通常从计算机的供电USB端口。要以独立模式使用适配器，请通过将+ 5Vdc和地连接至测试点TP1和TP2为其供电。</p>
<hr>
<h4 id="要安装USB串行转换器："><a href="#要安装USB串行转换器：" class="headerlink" title="要安装USB串行转换器："></a>要安装USB串行转换器：</h4><ol>
<li>将适配器插入评估板的控制端口（DB25连接器）。</li>
<li>将USB电缆连接到PC和USB适配器。</li>
<li>当提示您输入驱动程序时：<ol>
<li><strong>Windows 2000-</strong> 选择“搜索合适的驱动程序”，然后单击“下一步”。<ol>
<li>选中“指定位置”，然后取消选中其他选项。点击下一步。</li>
</ol>
</li>
<li><strong>Windows XP-</strong> 选择“从列表或特定位置安装”。<ol>
<li>选择“在这些位置搜索最佳驱动程序”。</li>
<li>选中“在搜索中包括此位置”框。</li>
</ol>
</li>
</ol>
</li>
<li>单击浏览，然后在SigmaStudio安装目录的USB驱动程序文件夹中找到ftd2xx.inf文件。默认位置是C：\ Program Files \ Analog Devices Inc \ SigmaStudio \ USB驱动程序。</li>
<li>在Windows XP中，如果出现有关该软件未通过Windows徽标测试的对话框，请单击“仍然继续”。</li>
</ol>
<hr>
<h4 id="使用USB串行转换器："><a href="#使用USB串行转换器：" class="headerlink" title="使用USB串行转换器："></a>使用USB串行转换器：</h4><p>为了在SigmaStudio与USB串行转换器板之间进行通信，必须在原理图设计中添加一个通信通道模块。要找到这些块，请选择“硬件配置”选项卡，然后在“工具箱”或“树形工具箱”窗口中选择“通讯通道”类别。 USB串行转换器板 可使用2个通信通道模块：USBSerialConv和USBSerialConvAddress。两个模块都为多个处理器提供连接，从而使您可以在单个设计中使用多个处理器。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/gettingstarted/usbinterfaces/usbpic1.png?id=resources:tools-software:sigmastudio:gettingstarted:usbinterfaces:usbserialconverter"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/gettingstarted/usbinterfaces/usbpic1.png" alt="img"></a></p>
<p>注意：只能连接USBSerialConv / USBSerialConvAddress块输出引脚之一。不必连接或终止所有输出引脚。同样，您将处理器连接到任何引脚，引脚连接的顺序也没有特殊要求。</p>
<h4 id="USB串行转换"><a href="#USB串行转换" class="headerlink" title="USB串行转换"></a>USB串行转换</h4><p>允许连接多个DSP处理器模块和E2Prom模块。从上到下依次分配地址（例如 SPI通信。这些引脚从上到下与clatch0-4关联）。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/gettingstarted/usbinterfaces/usbpic2.png?id=resources:tools-software:sigmastudio:gettingstarted:usbinterfaces:usbserialconverter"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/gettingstarted/usbinterfaces/usbpic2.png" alt="img"></a></p>
<h4 id="USBSerialConvAddress"><a href="#USBSerialConvAddress" class="headerlink" title="USBSerialConvAddress"></a>USBSerialConvAddress</h4><p>该模块使您可以明确指定器件地址，I²C地址或SPI锁扣线（见下文）。请注意，DSP硬件的地址必须与块的所选地址匹配，以使通信起作用。有关寻址的更多信息，请参见器件数据手册（例如ADR_SEL，ADDR0或ADDR1引脚）。 根据SigmaDSP部分的不同，对此模块进行的连接将用于SPI（串行外围接口）数据或I²C数据。对于SPI</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/gettingstarted/usbinterfaces/usbpic3.png?id=resources:tools-software:sigmastudio:gettingstarted:usbinterfaces:usbserialconverter"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/gettingstarted/usbinterfaces/usbpic3.png" alt="img"></a></p>
<p>，此通道可让您一次连接多个板，并可以选择将特定板连接到任何锁线。（唯一的例外是clatch1，它是为转换器EPROM保留的，在USBSerialConv块上用灰色的针脚表示。）针脚从上到下为clatch0-4。下图显示了将板连接到引脚的一种可能配置。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/gettingstarted/usbinterfaces/usbpic4.png?id=resources:tools-software:sigmastudio:gettingstarted:usbinterfaces:usbserialconverter"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/gettingstarted/usbinterfaces/usbpic4.png" alt="img"></a></p>
<hr>
<h4 id="EVAL-ADUSB1板开关和跳线："><a href="#EVAL-ADUSB1板开关和跳线：" class="headerlink" title="EVAL-ADUSB1板开关和跳线："></a>EVAL-ADUSB1板开关和跳线：</h4><ul>
<li>S1-将闪存中保存的程序加载到SigmaDSP。</li>
<li>S2-选择当按下S1时将加载八个SigmaDSP程序中的哪一个。</li>
<li>S3-重置USB适配器板。</li>
<li>TP1-+ 5Vdc连接，用于适配器未通过PC的USB端口供电的情况。</li>
<li>TP2-接地，用于适配器未通过PC的USB端口供电的情况。</li>
<li>J3-当该接头连接器上有跳线时，将启用对闪存的写操作（用于存储SigmaDSP程序）。</li>
<li>D4-此LED指示USB板已通电。</li>
</ul>
<p>可以使用SigmaStudio中的Flash Downloader工具将SigmaDSP程序和参数文件保存到USB板上的闪存中。通过将S2设置为适当的设置，然后按下程序加载按钮S1，可以将每个程序加载到SigmaDSP。请参阅Flash Downloader页面。<br>有关更多信息，请参见EVAL-ADUSB1数据手册，analog.com / sigmadsp。</p>
<h3 id="Digital-Attenuator"><a href="#Digital-Attenuator" class="headerlink" title="Digital Attenuator"></a>Digital Attenuator</h3><p>即数字衰减器， 与可变衰减器不同，数字衰减器在离散和有限衰减状态下切换。该切换通常以二进制步骤实现。数字衰减器采用半导体器件来实现每个衰减步骤。为此目的而使用的一些半导体器件包括：PIN二极管，MOSFET和GaAs MESFET。数字衰减器能够实现与固态开关速度相当的开关速率。数字衰减器使用的最常见逻辑类型 是CMOS逻辑电平和晶体管晶体管逻辑（TTL）。</p>
<p>数字衰减器利用驱动器电路来确定要使用的逻辑类型。驱动器电路的复杂性取决于所使用的位数。复杂度随着位数的增加而增加。通常根据数字衰减器设计提供的衰减状态对其进行分类。使用的位数决定了这些衰减状态。最高有效位提供最大的衰减，而最低有效位提供组件提供的最小衰减。其余位提供中间衰减值。通常，这些产品采用1位，5位，8位和6位数字衰减器。</p>
<p>如果选择了所有位，则数字衰减器旨在提供最大的额定衰减。另一方面，其最小衰减步长仅通过选择最低有效位来实现。数字衰减器在3G和4G蜂窝网络，点对点节点，中继器以及广泛的测试和测量应用中具有广泛的用途。</p>
<p class="italicp" style="font-style: italic; color: #BBB;">Shop Arrow.com选择了数字RF步进衰减器，数字音频衰减器等。 <a hre="https://www.arrow.com/en/categories/attenuators/fixedvariable-attenuators/digital-attenuators#">>>> read more</a></p>

















<h3 id="ASRC"><a href="#ASRC" class="headerlink" title="ASRC"></a>ASRC</h3><p>异步采样速率转换器(ASRC，Asynchronous Sample Rate Converter)是一款可同时用于消费电子和专业应用的音频采样速率转换通用软件模块。 ASRC支持多种不同的采样速率配置。</p>
<p><strong>ASRC软件模块</strong> 可用于以小步长改变采样频率，步长随着时间改变，且在变化过程中不生成任何输出音频干扰。 在许多多媒体系统中，时变采样速率的改变是非常重要的功能，例如能实现多个数据流的精密同步以及服务器和客户端的同步等。</p>
<p>ADI公司的ASRC实施方案经过高度优化，适合在ADI公司的Blackfin系列处理器上运行。它是一个基于ADI专利设计的独立自足软件模块。该模块已经过各种根据音频信号质量分析定义的策略质量测试。</p>
<p>ASRC模块是应用于PCM（脉冲编码调制）上的后处理模块，通过模拟输入、数字输入通道或解码应用的PCM输出接收数据。 ASRC模块能够处理多个通道的输入信息，并能够输出至同样多的通道。 开发的模块支持全面的重入和多实例。 ASRC模块是一个独立的模块，不依赖其他任何模块。 ADRC模块配备一个示例轻型包装器API，将模块插入至整体系统。 这使得该应用的系统集成简单易行。</p>
<h4 id="ASRC-INPUT-OUTPUT"><a href="#ASRC-INPUT-OUTPUT" class="headerlink" title="ASRC INPUT/OUTPUT"></a>ASRC INPUT/OUTPUT</h4><p>ASRC输入和输出模块在原理图设计和硬件ASRC（异步采样率转换器）之间路由信号。</p>
<p>使用输入块的复选框来启用或禁用特定输入。使用输出块的下拉列表控件从可用的ASRC中进行选择。</p>
<ul>
<li>每个ASRC输出必须连接其输入，否则编译时将出错。</li>
<li>可以看到，随着将更多的ASRC输出块拖到原理图中，下拉列表中的可用输出数量会减少，因为一次只能由一个块表示。</li>
<li>要更改ASRC <strong>输入采样率</strong>，请右键单击块名称，然后选择“设置采样率”，这将打开“采样率”窗口（默认值为44.1 kHz）。</li>
</ul>
<p><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/toolbox/io/asrc_input_output_020.jpg" alt="img"></p>
<h4 id="Limiter-限幅器"><a href="#Limiter-限幅器" class="headerlink" title="Limiter 限幅器"></a>Limiter 限幅器</h4><p>限幅器（Limiter）是指能按限定的范围削平信号电压波幅的电路，又称削波器。限幅电路的作用是把输出信号幅度限定在一定的范围内，亦即当输入电压超过或低于某一参考值后，输出电压将被限制在某一电平（称作限幅电平），且再不随输入电压变化。</p>
<h3 id="LSB-aligned"><a href="#LSB-aligned" class="headerlink" title="LSB-aligned"></a>LSB-aligned</h3><p>LSB(Least Significant Bit)是“最低有效位”。MSB(Most Significant Bit)是“最高有效位”。</p>
<p>最高有效位是指二进制中最高值的比特，如：</p>
<blockquote>
<ol>
<li><p>在16比特的数字音频中，其第1个比特便对16bit的字的数值有最大的影响。</p>
</li>
<li><p>在十进制的15，389这一数字中，相当于万数那1行（1）的数字便对数值的影响最大。比较与之相反的“最低有效位”（LSB）。</p>
</li>
<li><p>汇编中，比如8位2进制数10000001，其中第一个1是MSB,第二个1是LSB。<mark>1</mark>（MSB）100 001<mark>1</mark>（LSB）</p>
</li>
<li><p>在计算时，如果是整数，那么小数点（实际上是没有小数点的，但就把那一位和下一位之间看作有）在LSB后面；如果是小数，小数点在MSB后面；其中MSB在有符号数中又是符号位。</p>
</li>
</ol>
</blockquote>
<p>在网络通信方面，大家说的更多的是：“<strong>Big-Endian</strong>”和“<strong>Small-Endian</strong>”的问题。指的都是对于多字节的数据类型（比如4字节的32位整数），其多个字节的顺序问题，是最高字节在前（Big-Endian）还是最低字节在前（Small-Endian）。</p>
<p>比如对于123456789这个整数，其16进制为0x075BCD15，那么按照Big-Endian的方式，它在网络上传输（或者在内存里存储）的4个字节依次是：<code>07 4B CD 15</code>，而Small-Endian的顺序正相反，是：<code>15 CD 4B 07</code>。</p>
<p><strong>MSB</strong> 和 <strong>LSB</strong> 虽然跟这个事情看起来有点相似，但不是一回事。</p>
<p>通常，一个芯片的管脚中，对于一个多比特的信号，比如32根的地址线，从低开始按0到31编个号。MSB就是31，LSB就是0。那么如果标记为：ADDR[31:0]就是MSB first的方式，如果标记为ADDR[0:31]就是LSB first的方式。</p>
<p><strong>MSB LSB</strong>：起始地址为最高位， 最后地址为最低位。</p>
<p><strong>LSB MSB</strong>：起始地址为最低位，最后地址为最高位。</p>
<p>比如AD中，8位，最低有效位指D0</p>
<h3 id="Cofficient-Write"><a href="#Cofficient-Write" class="headerlink" title="Cofficient Write"></a>Cofficient Write</h3><p>即 <strong>参数写入</strong>，是指对参数中两组 <em><strong>寄存器参数集</strong></em> 的系数写入。当然也可以单独写入某个寄存器的数值。</p>
<p>可写入的参数如：filter coefficients、limiter settings、volume<br>control settings等。</p>
<p>每组 <strong>寄存器参数集</strong> 可写入至多 160个参数（32个过滤器*5个系数）。</p>
<h2 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h2><p>在ADAU1772的General(2^nd^ Order) Filter Setting中有几项过滤器，分别是 Parametric 、 Shelving 、 General HP/LP/BP/BS 、 Butterworth/Bessel 、 Tone Control、IIR Coefficient 、First Order Filters 、All Pass 、Peaking 、Notch 、 Chebyshev 共11中过滤器。</p>
<p><img src="http://pic.islet.space/2021/04/image-20210428152357233.png" alt="image-20210428152357233"></p>
<h1 id="SigmaStudio"><a href="#SigmaStudio" class="headerlink" title="SigmaStudio"></a>SigmaStudio</h1><p>以下简称sigma</p>
<h2 id="Capture"><a href="#Capture" class="headerlink" title="Capture"></a>Capture</h2><p>Capture 窗口会捕捉开发者对设置的相关改动记录。</p>
<p><img src="https://pic.islet.space/2021/04/image-20210422165857465.png" alt="image-20210422165857465"></p>
<h2 id="Register-Control"><a href="#Register-Control" class="headerlink" title="Register Control"></a>Register Control</h2><p><img src="https://pic.islet.space/2021/04/image-20210422163633005.png" alt="image-20210422163633005"></p>
<h3 id="Output-Serial-Port"><a href="#Output-Serial-Port" class="headerlink" title="Output/Serial Port"></a>Output/Serial Port</h3><h4 id="下压式音量按键"><a href="#下压式音量按键" class="headerlink" title="下压式音量按键"></a>下压式音量按键</h4><p>使用前需要进行跳线，跳线方法如下：</p>
<img src="https://pic.islet.space/2021/04/image-20210422163804275.png" alt="image-20210422163804275" style="zoom:50%;" />

<p>控制界面如下：</p>
<p><img src="https://pic.islet.space/2021/04/image-20210422163228410.png" alt="image-20210422163228410"></p>
<blockquote>
<p>？？ Time</p>
<p>Initial PB Volume 初始化下压式按键的音量值</p>
<p>Gain Step 增益速度</p>
<p>Ramp Speed 增加速度</p>
<p>Converters Controlled by PushButton Volume 被控制的转换器</p>
</blockquote>
<h2 id="Download-Program"><a href="#Download-Program" class="headerlink" title="Download Program"></a>Download Program</h2><img src="https://pic.islet.space/2021/04/image-20210422170248954.png" alt="image-20210422170248954" style="zoom:67%;" />

<p><img src="https://pic.islet.space/2021/04/image-20210422170328013.png" alt="image-20210422170328013"></p>
<h2 id="Microphone"><a href="#Microphone" class="headerlink" title="Microphone"></a>Microphone</h2><p>TRS 1/8-inch<br>mini-plug stereo headphones</p>
<img src="https://pic.islet.space/2021/04/048f07ee-e357-4c06-a8e4-1724e62765a4_1.e937ba0bd42739fc09e9ef63602645b8.jpeg" alt="查看源图像" style="zoom:50%;" />

<p>standard 0.100”<br>headers</p>
<img src="https://pic.islet.space/2021/04/R68f2db356a43d3653db1298ccd26e835" alt="查看源图像" style="zoom:50%;" />





<h3 id="Bias-Setting"><a href="#Bias-Setting" class="headerlink" title="Bias Setting"></a>Bias Setting</h3><p><img src="https://pic.islet.space/2021/04/image-20210423102647330.png" alt="image-20210423102647330"></p>
<blockquote>
<p>Bias Gain</p>
<p>AVDD</p>
<p>0.9*AVDD</p>
<p>0.65*AVDD</p>
</blockquote>
<p>dataword byte : 在突发模式（burst mode）中使用。 </p>
<p>data byte : 在单字模式（single-word mode）下写入。</p>
<h1 id="ADAU1772"><a href="#ADAU1772" class="headerlink" title="ADAU1772"></a>ADAU1772</h1><ul>
<li>ADAU1772以下简称1772</li>
<li>《Evaluation Board User Guide<br>  UG-477》以下简称UG</li>
</ul>
<h2 id="评估板结构"><a href="#评估板结构" class="headerlink" title="评估板结构"></a>评估板结构</h2><p>以下描述均以评估板为例，DIY板不一定适用。</p>
<h3 id="插口（Jumper）定义"><a href="#插口（Jumper）定义" class="headerlink" title="插口（Jumper）定义"></a>插口（Jumper）定义</h3><img src="https://pic.islet.space/2021/04/image-20210427165847934.png" alt="image-20210427165847934" style="zoom: 67%;" />



<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><ul>
<li>2/3输入通道是复用立体声通道，即1通道和0通道都可以单独接入音源，在物理音频接口上独立，但第2/3通道是在一起的，共用一个物理通道。UG第7页中也有提到。</li>
</ul>
<img src="https://pic.islet.space/2021/04/image-20210427104818097.png" alt="image-20210427104818097" style="zoom:50%;" />



<img src="https://pic.islet.space/2021/04/image-20210427105655639.png" alt="image-20210427105655639" style="zoom:67%;" />

<ul>
<li>有四个单端输入通道可以设置为麦克风信号或线路信号，一个双立体声数字输入信号通道和也可被用于单端输出的两个差分(differential)输出。</li>
</ul>
<h3 id="USBi-仿真器"><a href="#USBi-仿真器" class="headerlink" title="USBi 仿真器"></a>USBi 仿真器</h3><ul>
<li>USBi驱动安装：进入设备管理器，安装驱动在SigmaStudio安装目录 <code>\Analog Devices\SigmaStudio 4.6\USB drivers\</code> 下。</li>
<li>连接到USBi未成功时是红色，设备驱动安装且连接成功时，USBi 在sigma中会由红变绿。</li>
<li>USBi作为中间板对1772进行控制，在USBi右键可以控制1772设备开断，开断时板上D1区的VDD指示灯也会通断（见page10）。</li>
<li>如果需要对设备进行实时控制，请务必记得打开设备，否则无法操作。</li>
</ul>
<img src="http://pic.islet.space/2021/04/image-20210428150645112.png" alt="image-20210428150645112" style="zoom: 67%;" />

<ul>
<li>USBi将例程down到了板子上ADAU1772的SRAM上，断电就没有了。USBi的这种调试是为了快速验证功能，最终需要把这个例程的代码导出，并通过单片机的 <strong>启动工程集成</strong>，烧写到单片机中，实现单片机启动。</li>
</ul>
<img src="https://pic.islet.space/2021/04/image-20210427110916316.png" alt="image-20210427110916316" style="zoom:67%;" />

<h3 id="编译烧录"><a href="#编译烧录" class="headerlink" title="编译烧录"></a>编译烧录</h3><ul>
<li>烧录按键如下：</li>
</ul>
<p><img src="https://pic.islet.space/2021/04/image-20210427162529600.png" alt="image-20210427162529600"></p>
<ul>
<li>编译完毕后，SS会在右边的output窗体里显示编译结果，如有错误会提示错误信息，用户可据此信息去修改设计；</li>
<li>如成功则会显示资源占用信息，用户可根据百分比来增减模块。</li>
</ul>
<img src="https://pic.islet.space/2021/04/image-20210427111013493.png" alt="image-20210427111013493" style="zoom:67%;" />



<h3 id="芯片"><a href="#芯片" class="headerlink" title="芯片"></a>芯片</h3><p>板上共有4颗芯片，分别是 <strong>DSP</strong>、<strong>EEPROM</strong>、<strong>线性整流芯片</strong> 和 <strong>升压芯片</strong></p>
<img src="https://pic.islet.space/2021/04/image-20210427171901213.png" alt="image-20210427171901213" style="zoom:50%;" />



<h4 id="U2-EEPROM"><a href="#U2-EEPROM" class="headerlink" title="U2: EEPROM"></a>U2: EEPROM</h4><p>ST官网对M24C32-F串行E2PROM的描述：</p>
<p>容量：32-Kbit</p>
<p>电压：1.7 ~ 5.5V</p>
<p>温差：-40 ~ +85℃</p>
<img src="https://pic.islet.space/2021/04/Snipaste_2021-04-27_17-18-01.png" alt="Snipaste_2021-04-27_17-18-01" style="zoom: 67%;" />

<img src="https://pic.islet.space/2021/04/Snipaste_2021-04-27_17-18-18.png" alt="Snipaste_2021-04-27_17-18-18" style="zoom:67%;" />







<h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><h3 id="HP输出"><a href="#HP输出" class="headerlink" title="HP输出"></a>HP输出</h3><p>HP即Headphone缩写，HP输出有两个输出端，分别是DAC0 和 DAC1，分别对应为 EVAL板 上的 OUT R(HP Right) 和 OUT L(HP Left)。</p>
<img src="https://pic.islet.space/2021/04/image-20210427152251539.png" alt="image-20210427152251539" style="zoom:50%;" />

<img src="https://pic.islet.space/2021/04/image-20210427143628880.png" alt="image-20210427143628880" style="zoom: 33%;" />

<h4 id="输出静音"><a href="#输出静音" class="headerlink" title="输出静音"></a>输出静音</h4><img src="https://pic.islet.space/2021/04/image-20210427153425633.png" alt="image-20210427153425633" style="zoom:50%;" />

<h4 id="输出断电"><a href="#输出断电" class="headerlink" title="输出断电"></a>输出断电</h4><p>关于HP输出的寄存器 <code>HP_EN_R</code> 及 <code>HP_EN_L</code> 说明：</p>
<img src="https://pic.islet.space/2021/04/image-20210427152528194.png" alt="image-20210427152528194" style="zoom:50%;" />

<p><code>0x31</code> 即 <code>0011 0001</code> ，最后两位 <code>01</code> 即 <code>HP_PDN_L</code> 中的 <code>01</code> 。    </p>
<h4 id="输出音量控制"><a href="#输出音量控制" class="headerlink" title="输出音量控制"></a>输出音量控制</h4><ul>
<li>对输出音量进行控制需要先对S5、S6进行跳针。</li>
</ul>
<img src="https://pic.islet.space/2021/04/image-20210427110159648.png" alt="image-20210427110159648" style="zoom:67%;" />





<h3 id="TALKTHRU-DSP-BYPASS"><a href="#TALKTHRU-DSP-BYPASS" class="headerlink" title="TALKTHRU / DSP BYPASS"></a>TALKTHRU / DSP BYPASS</h3><blockquote>
<p>DSP BYPASS MODE<br>When DSP bypass mode is enabled, a direct path from the ADC<br>outputs to the DACs is set up to enable bypassing the core processing to listen to environmental sounds. </p>
<p>This is useful for<br>listening to someone speaking without having to remove the<br>noise cancelling headphones. The DSP bypass path is <strong>enabled by setting an MPx pin low</strong>. </p>
<p>Figure 92 shows the DSP bypass path<br>disabled, and Figure 93 shows the DSP bypass path enabled by<br>pressing the push-button switch. </p>
<p><img src="https://pic.islet.space/2021/04/image-20210427144110884.png" alt="image-20210427144110884"></p>
<p>The DSP bypass feature works<br>for both analog and digital microphone inputs. </p>
<ul>
<li>Enabled when <em><strong>a switch</strong></em> connected to an MPx pin that is set to DSP bypass mode is closed and the MPx pin signal is pulled low. </li>
</ul>
<p>Pressing and holding the switch closed enables the<br>DSP bypass signal path as defined in the TALKTHRU register<br>(Address 0x002A). </p>
<p>The DAC volume control setting is switched<br>from the default gain setting to the new TALKTHRU_GAINx<br>register setting (Address 0x002B and Address 0x002C). </p>
<ul>
<li>DSP bypass<br>  is enabled only on ADC0 and ADC1. </li>
</ul>
<p>The DSP bypass signal path<br>is from the output of ADCx to the input of the DAC(s).<br>When DSP bypass is enabled, the current DAC volume setting<br>is ramped down to −95.625 dB and the DSP bypass volume<br>setting is ramped up to avoid pops when switching paths.</p>
</blockquote>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="EXP1"><a href="#EXP1" class="headerlink" title="EXP1"></a>EXP1</h2><p>从左侧 <strong>树状工具箱</strong>(TreeToolBox)中拖出1772和USBi，并进行连接。</p>
<img src="C:\Users\431240\AppData\Roaming\Typora\typora-user-images\image-20210428094527305.png" alt="image-20210428094527305" style="zoom: 67%;" />



<p>在 <strong>原理图</strong>(schematic)中需要对输入输出路径进行定义，从左侧拖出组件并连线如下：</p>
<p><img src="C:\Users\431240\AppData\Roaming\Typora\typora-user-images\image-20210428095433721.png" alt="image-20210428095433721"></p>
<p><img src="C:\Users\431240\AppData\Roaming\Typora\typora-user-images\image-20210428093600257.png" alt="image-20210428093600257"></p>
<p>相当于对 <strong>信号通路</strong>(Signal Routing) 选项卡中的各框区所示的信号进行连接，因其中 <strong>核心输入选择</strong>(Core Input Selection)仅针对输入源进行定义和设置，并未对输入和 <strong>音频处理核心</strong>(Audio Processing Core)之间的数据流向进行设置，所以需要在原理图中进行设置。</p>
<img src="C:\Users\431240\AppData\Roaming\Typora\typora-user-images\image-20210428093647783.png" alt="image-20210428093647783" style="zoom:50%;" />

<p>在 <strong>输出/串行接口</strong>(Output/Serial Port)中选择 <strong>按键音量</strong>(Push button vol) 选区进行调整，在 <strong>按键音量控制的转换器</strong>(Converters controlled by pushbutton volume) 中选择 <code>All ADCs</code> , 此处可对输入的ADC信号或输出的DAC信号进行音量加减。</p>
<p><img src="C:\Users\431240\AppData\Roaming\Typora\typora-user-images\image-20210428094927404.png" alt="image-20210428094927404"></p>
<p><strong>可编程增益放大器</strong> (Programable Gain Amplifier) 是模拟信号输入后的可选用部件，选用时应在</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/22/Linux/Linux%E5%88%86%E5%8C%BA%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/22/Linux/Linux%E5%88%86%E5%8C%BA%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">Linux分区及文件系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-22 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-22T23:58:32+08:00">2021-04-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-26 00:14:16" itemprop="dateModified" datetime="2021-04-26T00:14:16+08:00">2021-04-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Linux分区与挂载"><a href="#Linux分区与挂载" class="headerlink" title="Linux分区与挂载"></a>Linux分区与挂载</h1><h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><p><strong>分区表</strong>(partition table)是将大表的数据分成称为分区的许多小的子集，类型有FAT16, FAT32, NTFS, exFAT, Ext2/3/4, HFS+, VMFS。另外，分区表的种类划分主要有：range（范围）、list（列表）和hash（散列）分区。划分依据主要是根据其表内部属性。同时，分区表可以创建其独特的分区索引。倘若硬盘丢失了分区表，数据就无法按顺序读取和写入，导致无法操作。</p>
<p>Kali Linux支持的分区表类型：aix、amiga、bsd、dvh、gpt、mac、msdos、pc98、sun、atari 及 loop。</p>
<h2 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h2><p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/kzq6k9g8x7.png"></p>
<p>磁盘结构</p>
<p>磁盘主要分为以下结构：</p>
<ul>
<li>磁头（head）：对磁盘的数据进行读写</li>
<li>磁道（track）：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道。 磁盘上的磁道是一组记录密度不同的同心圆</li>
<li>扇区（sector）：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区。硬盘的第一个扇区，叫做引导扇区。 一个扇区的大小为512个字节。</li>
<li>柱面（cylinder）：在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面。</li>
</ul>
<p>整个磁盘的存储大小为： <strong>存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数</strong></p>
<h2 id="磁盘的使用"><a href="#磁盘的使用" class="headerlink" title="磁盘的使用"></a>磁盘的使用</h2><p>一块新的硬盘或者U盘等外部设备在插入PC后，需要完成以下事情：</p>
<ul>
<li>在/dev/下创建一个新的目录，用来代表该磁盘。如/dev/hda，/dev/hdb等。</li>
<li>磁盘最开始需要进行格式化，使用<code>mkfs</code>命令为磁盘进行格式化，确定文件系统类型。</li>
<li>对硬盘进行分区后才可以使用。</li>
<li>在Linux中挂载到一个已经存在的目录下才可以访问该磁盘，否则无法访问。使用<code>mount</code>与<code>unmount</code>来进行挂载和卸载。</li>
</ul>
<blockquote>
<p> 一般挂在点都在/mnt/xxx目录下，并且该目录必须是已经存在的，否则无法挂载 </p>
</blockquote>
<h2 id="fdisk的使用"><a href="#fdisk的使用" class="headerlink" title="fdisk的使用"></a>fdisk的使用</h2><p>在Linux中，使用fdisk来查看当前的硬盘以及硬盘的分区、文件系统等信息。并且使用fdisk命令可以为磁盘进行分区。 fdisk的命令有以下这些： Fdisk命令详解：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">m</td>
<td align="left">获取帮助</td>
</tr>
<tr>
<td align="left">n</td>
<td align="left">新建分区</td>
</tr>
<tr>
<td align="left">p</td>
<td align="left">显示分区表</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">删除分区</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">设置卷标</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">写入分区表</td>
</tr>
<tr>
<td align="left">t</td>
<td align="left">改变分区文件系统类型</td>
</tr>
<tr>
<td align="left">v</td>
<td align="left">检验分区</td>
</tr>
<tr>
<td align="left">l</td>
<td align="left">显示fdisk所支持的文件系统代码</td>
</tr>
<tr>
<td align="left">q</td>
<td align="left">退出</td>
</tr>
</tbody></table>
<h5 id="fdisk示例"><a href="#fdisk示例" class="headerlink" title="fdisk示例"></a>fdisk示例</h5><ol>
<li>使用<code>fdisk -l</code>查看当前所有硬盘以及分区的状态。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># fdisk -l</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: <span class="number">10.7</span> GB, <span class="number">10737418240</span> bytes</span><br><span class="line"><span class="number">255</span> heads, <span class="number">63</span> sectors/track, <span class="number">1305</span> cylinders</span><br><span class="line">Units = cylinders <span class="keyword">of</span> <span class="number">16065</span> * <span class="number">512</span> = <span class="number">8225280</span> bytes</span><br><span class="line"></span><br><span class="line">Device Boot   Start     End   Blocks  Id System</span><br><span class="line">/dev/sda1  *      <span class="number">1</span>     <span class="number">13</span>   <span class="number">104391</span>  <span class="number">83</span> Linux</span><br><span class="line">/dev/sda2       <span class="number">14</span>    <span class="number">1305</span>  <span class="number">10377990</span>  8e Linux LVM</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: <span class="number">5368</span> MB, <span class="number">5368709120</span> bytes</span><br><span class="line"><span class="number">255</span> heads, <span class="number">63</span> sectors/track, <span class="number">652</span> cylinders</span><br><span class="line">Units = cylinders <span class="keyword">of</span> <span class="number">16065</span> * <span class="number">512</span> = <span class="number">8225280</span> bytes</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb doesn<span class="string">&#x27;t contain a valid partition table</span></span><br></pre></td></tr></table></figure>

<p>可以看到目前有两个磁盘：</p>
<ul>
<li>sda：10.7G，255个磁头，63个磁道，1305个扇区 <ul>
<li>主分区1：/dev/sda1</li>
<li>主分区2：/dev/sda2</li>
</ul>
</li>
<li>sdb：5G，255个磁头，63个磁道，652个扇区 <ul>
<li>无分区</li>
</ul>
</li>
</ul>
<h2 id="分区的概念"><a href="#分区的概念" class="headerlink" title="分区的概念"></a>分区的概念</h2><p>Linux中，磁盘只有被分区完后，才可以被挂载到目录下。</p>
<p>分区有三种：主分区，扩展分区，逻辑分区，每个磁盘最多只能有四个主分区，而可以有多个扩展分区，在扩展分区中，还可以创建多个逻辑分区。</p>
<ul>
<li>主分区：创建完后即可挂载</li>
<li>扩展分区：扩展分区创建完后，还需要创建逻辑分区才可以被挂载</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>格式化一块硬盘(hdb)，并且对其进行分区，分区后进行挂载</p>
<h5 id="创建主分区"><a href="#创建主分区" class="headerlink" title="创建主分区"></a>创建主分区</h5><ol>
<li>通过<code>fdisk /dev/hdb</code>进入磁盘的命令模式    </li>
</ol>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/s22aqd4o24.png" alt="s22aqd4o24"></p>
<p>  进入格式化命令模式  </p>
<ol>
<li>输入<code>n</code>代表创建分区，<code>e</code>代表扩展分区，<code>p</code>代表主分区    </li>
</ol>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/0u6woej2nq.png" alt="0u6woej2nq"></p>
<p>  新建主分区  </p>
<ol>
<li>输入<code>First Cylinder</code>的值代表分区初始的柱面值，以及分区的大小<code>+3G</code>代表为该分区分3G    </li>
</ol>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/vopy3iwz2v.png" alt="vopy3iwz2v"></p>
<p>  输入初始柱面的值以及分区大小  </p>
<ol>
<li>输入<code>p</code>查看创建的分区<code>/dev/hdb1</code>    </li>
</ol>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/rflbc73wpf.png" alt="rflbc73wpf"></p>
<p>  新建分区  </p>
<h5 id="创建扩展分区"><a href="#创建扩展分区" class="headerlink" title="创建扩展分区"></a>创建扩展分区</h5><ol>
<li>与创建主分区步骤相同，只是在选择<code>command action</code>的时候，选择<code>e</code>，表示创建扩展分区    </li>
</ol>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/ymjwni22fr.png" alt="ymjwni22fr"></p>
<p>  创建后的扩展分区  </p>
<ol>
<li>在创建完扩展分区后，来创建逻辑分区，输入<code>l</code>代表创建逻辑分区    </li>
</ol>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/ra4wa3017d.png" alt="ra4wa3017d"></p>
<p>  创建逻辑分区  </p>
<ol>
<li> 与创建主分区、扩展分区一样，为逻辑分区选择起始的柱面，以及分配的大小     </li>
</ol>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/y0kb4p9z23.png" alt="y0kb4p9z23"></p>
<p>  分配分区大小  </p>
<ol>
<li> 查看扩展分区     </li>
</ol>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/c78q2lt7wi.png" alt="c78q2lt7wi"></p>
<p>  查看分区信息  </p>
<h5 id="分区格式化"><a href="#分区格式化" class="headerlink" title="分区格式化"></a>分区格式化</h5><p>在磁盘分区创建完毕后，需要为分区通过<code>mkfs</code>进行格式化，赋予它文件系统： 如<code>ext2</code>,<code>ext3</code>,<code>vfat</code>等</p>
<p>使用命令 <code>mkfs -t ext3 /dev/hdb1</code>分别对分区<code>hdb1</code>进行格式化处理，格式化为ext3文件类型</p>
<p>其中<code>mkfs –t ext3</code>命令等价于<code>mkfs.ext3</code>，<code>mkfs -t ext2</code>命令等价于<code>mkfs.ext2</code> </p>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/513p7ponts.png" alt="513p7ponts"></p>
<p>mkfs命令</p>
<h5 id="分区挂载"><a href="#分区挂载" class="headerlink" title="分区挂载"></a>分区挂载</h5><p>当分区格式化完成文件系统后，就可以通过<code>mount</code>与<code>unmount</code>进行挂载与卸载了，当分区挂载到具体目录后，即可进行创建文件、删除文件等文件操作了。</p>
<p>如<code>mount /dev/hdb1 /mnt/hdb1</code>就会将<code>/dev/hdb1</code>分区挂载到<code>/mnt/hdb1</code>目录下，也就是该目录下的文件都会被写到<code>/dev/hdb1</code>的磁盘分区中保存。</p>
<p>本文参与<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/support-plan">腾讯云自媒体分享计划</a>，欢迎正在阅读的你也加入，一起分享。</p>
<h1 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h1><h2 id="文件系统类型"><a href="#文件系统类型" class="headerlink" title="文件系统类型"></a>文件系统类型</h2><p>Kali Linux支持：btrfs、exfat、ext2\3\4、f2fs、fat16、fat32、hfs、hfs+、jfs、linux-swap、lvm2 pv、minix、nilfs2、ntfs、reiser4、reiserfs、udf、xfs;</p>
<h3 id="LINUX-SWAP"><a href="#LINUX-SWAP" class="headerlink" title="LINUX-SWAP"></a>LINUX-SWAP</h3><p>Swap分区在系统的物理内存不够用的时候，把硬盘空间中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。 本文将从分区开始讲解如何开启SWAP交换空间</p>
<h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 查看块设备</span><br><span class="line"># 如图可以看出硬盘sda和vdb还有剩余</span><br><span class="line">[root@rainss ~]# lsblk</span><br></pre></td></tr></table></figure>















<h2 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h2><p>主分区、扩展分区、逻辑分区</p>
<h2 id="对齐类型"><a href="#对齐类型" class="headerlink" title="对齐类型"></a>对齐类型</h2><p>对齐到MiB、对齐到柱面</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/22/Programing/C++/Get%20Started%20with%20C++%20and%20Windows%20Subsystem%20for%20Linux%20in%20Visual%20Studio%20Code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/22/Programing/C++/Get%20Started%20with%20C++%20and%20Windows%20Subsystem%20for%20Linux%20in%20Visual%20Studio%20Code/" class="post-title-link" itemprop="url">Get Started with C++ and Windows Subsystem for Linux in Visual Studio Code</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-22 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-22T23:58:32+08:00">2021-04-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-29 00:51:10" itemprop="dateModified" datetime="2021-04-29T00:51:10+08:00">2021-04-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/cpp/config-wsl">code.visualstudio.com</a></p>
<h2 id="Using-C-and-WSL-in-VS-Code"><a href="#Using-C-and-WSL-in-VS-Code" class="headerlink" title="Using C++ and WSL in VS Code"></a>Using C++ and WSL in VS Code</h2><p>In this tutorial, you will configure Visual Studio Code to use the GCC C++ compiler (g++) and GDB debugger on Ubuntu in the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/windows/wsl/install-win10">Windows Subsystem for Linux</a> (WSL). GCC stands for GNU Compiler Collection; GDB is the GNU debugger. WSL is a Linux environment within Windows that runs directly on the  machine hardware, not in a virtual machine.</p>
<blockquote>
<p><strong>Note</strong>: Much of this tutorial is applicable to working with C++ and VS Code directly on a Linux machine.</p>
</blockquote>
<p>Visual Studio Code has support for working directly in WSL with the <a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl">Remote - WSL extension</a>. We recommend this mode of <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/remote/wsl">WSL development</a>, where all your source code files, in addition to the compiler, are hosted on the Linux distro. For more background, see <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/remote/remote-overview">VS Code Remote Development</a>.</p>
<p>After completing this tutorial, you will be ready to create and  configure your own C++ project, and to explore the VS Code documentation for further information about its many features. This tutorial does not teach you about GCC or Linux or the C++ language. For those subjects,  there are many good resources available on the Web.</p>
<p>If you have any problems, feel free to file an issue for this tutorial in the <a target="_blank" rel="noopener" href="https://github.com/microsoft/vscode-docs/issues">VS Code documentation repository</a>.</p>
<h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites#"></a>Prerequisites<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_prerequisites">#</a></h2><p>To successfully complete this tutorial, you must do the following steps:</p>
<ol>
<li>Install <a target="_blank" rel="noopener" href="https://code.visualstudio.com/download">Visual Studio Code</a>.</li>
<li>Install the <a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl">Remote - WSL extension</a>.</li>
<li>Install <a target="_blank" rel="noopener" href="https://docs.microsoft.com/windows/wsl/install-win10">Windows Subsystem for Linux</a> and then use the links on that same page to install your Linux  distribution of choice. This tutorial uses Ubuntu. During installation,  remember your Linux user password because you’ll need it to install  additional software.</li>
</ol>
<h2 id="Set-up-your-Linux-environment"><a href="#Set-up-your-Linux-environment" class="headerlink" title="Set up your Linux environment#"></a>Set up your Linux environment<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_set-up-your-linux-environment">#</a></h2><ol>
<li><p>Open the Bash shell for WSL. If you installed an Ubuntu distro, type  “Ubuntu” in the Windows search box and then click on it in the result  list. For Debian, type “Debian”, and so on.</p>
<p> <img src="https://code.visualstudio.com/assets/docs/cpp/wsl/start-ubuntu.png" alt="Ubuntu in Start Menu"></p>
<p> The shell appears with a command prompt that by default consists of  your user name and computer name, and puts you in your home directory.  For Ubuntu it looks like this:</p>
<p> <img src="https://code.visualstudio.com/assets/docs/cpp/wsl/bash-ubuntu.png" alt="Bash Shell"></p>
</li>
<li><p>Make a directory called <code>projects</code> and then subdirectory under that called <code>helloworld</code>:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir projects</span><br><span class="line">cd projects</span><br><span class="line">mkdir helloworld</span><br></pre></td></tr></table></figure></li>
<li><p>Although you will be using VS Code to edit your source code, you’ll  be <strong>compiling the source code on Linux using the g++ compiler</strong>. You’ll  also <strong>debug on Linux using GDB</strong>. These tools are not installed by default  on Ubuntu, so you have to install them. Fortunately, that task is quite  easy!</p>
</li>
<li><p>From the WSL command prompt, first run <code>apt-get update</code> to update the Ubuntu package lists. An out-of-date distro can sometimes interfere with attempts to install new packages.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p> If you like, you can run <code>sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade</code> to also download the latest versions of the system packages, but this  can take significantly longer depending on your connection speed.</p>
</li>
<li><p>From the command prompt, install the GNU compiler tools and the GDB debugger by typing:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential gdb</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="C:\Users\431240\AppData\Roaming\Typora\typora-user-images\image-20210419161354074.png" alt="image-20210419161354074"></p>
<ol start="6">
<li>Verify that the install succeeded by locating g++ and gdb. If the filenames are not returned from the <code>whereis</code> command, try running the update command again.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whereis g++</span><br><span class="line">whereis gdb</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Note</strong>: The setup steps for installing the g++  compiler and GDB debugger apply if you are working directly on a Linux  machine rather than in WSL. Running VS Code in your helloworld project,  as well as the editing, building, and debugging steps are the same.</p>
</blockquote>
<h2 id="Run-VS-Code-in-WSL"><a href="#Run-VS-Code-in-WSL" class="headerlink" title="Run VS Code in WSL#"></a>Run VS Code in WSL<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_run-vs-code-in-wsl">#</a></h2><p>Navigate to your helloworld project folder and launch VS Code from the WSL terminal with <code>code .</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME&#x2F;projects&#x2F;helloworld</span><br><span class="line">code .</span><br></pre></td></tr></table></figure>

<p>You’ll see a message about “Installing VS Code Server”. <strong>VS Code is  downloading and installing a small server on the Linux side that the  desktop VS Code will then talk to.</strong> </p>
<p><img src="C:\Users\431240\AppData\Roaming\Typora\typora-user-images\image-20210419155740210.png" alt="image-20210419155740210"></p>
<p>VS Code will then start and open the <code>helloWorld</code> folder. The File Explorer shows that VS Code is now running in the context of WSL with the title bar <strong>[WSL: Ubuntu]</strong>.</p>
<p><img src="https://code.visualstudio.com/assets/docs/cpp/wsl/file-explorer-wsl.png" alt="File Explorer in WSL"></p>
<p>You can also tell the remote context from the Status bar.</p>
<p><img src="https://code.visualstudio.com/assets/docs/cpp/wsl/wsl-status-bar.png" alt="Remote context in the Status bar"></p>
<p>If you click on the Remote Status bar item, you will see a dropdown  of Remote commands appropriate for the session. </p>
<p><img src="C:\Users\431240\AppData\Roaming\Typora\typora-user-images\image-20210419155444952.png" alt="image-20210419155444952"></p>
<p>For example, if you want to end your session running in WSL, you can select the <strong>Close Remote Connection</strong> command from the dropdown. </p>
<p>Running <code>code .</code> from your <em>WSL command prompt</em> will restart VS Code running in WSL.</p>
<p>The <strong>code .</strong> command opened VS Code in the current  working folder, which becomes your “workspace”. As you go through the  tutorial, you will see three files created in a <code>.vscode</code> folder in the workspace:</p>
<ul>
<li><code>c_cpp_properties.json</code> (compiler path and IntelliSense settings)</li>
<li><code>tasks.json</code> (build instructions)</li>
<li><code>launch.json</code> (debugger settings)</li>
</ul>
<h2 id="Add-a-source-code-file"><a href="#Add-a-source-code-file" class="headerlink" title="Add a source code file#"></a>Add a source code file<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_add-a-source-code-file">#</a></h2><p>In the File Explorer title bar, select the <strong>New File</strong> button and name the file <code>helloworld.cpp</code>.</p>
<p><img src="https://code.visualstudio.com/assets/docs/cpp/wsl/new-file-button.png" alt="New File title bar button"></p>
<h3 id="Install-the-C-C-extension"><a href="#Install-the-C-C-extension" class="headerlink" title="Install the C/C++ extension#"></a>Install the C/C++ extension<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_install-the-cc-extension">#</a></h3><p>Once you create the file and VS Code detects it is a C++ language file, you may be prompted to install the <a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">Microsoft C/C++ extension</a> if you don’t already have it installed.</p>
<p><img src="https://code.visualstudio.com/assets/docs/cpp/wsl/cpp-extension-notification.png" alt="C++ extension notification"></p>
<p>Choose <strong>Install</strong> and then <strong>Reload Required</strong> when the button is displayed in the Extensions view to complete installing the C/C++ extension.</p>
<p>If you already have C/C++ language extensions installed locally in VS Code, you’ll need to go to the Extensions view (Ctrl+Shift+X) and install those extensions into WSL. Locally installed extensions can be installed into WSL by selecting the <strong>Install in WSL</strong> button and then <strong>Reload Required</strong>.</p>
<p><img src="https://code.visualstudio.com/assets/docs/cpp/wsl/install-in-wsl.png" alt="Install in WSL button"></p>
<h3 id="Add-hello-world-source-code"><a href="#Add-hello-world-source-code" class="headerlink" title="Add hello world source code#"></a>Add hello world source code<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_add-hello-world-source-code">#</a></h3><p>Now paste in this source code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   vector&lt;string&gt; msg &#123;&quot;Hello&quot;, &quot;C++&quot;, &quot;World&quot;, &quot;from&quot;, &quot;VS Code&quot;, &quot;and the C++ extension!&quot;&#125;;</span><br><span class="line"></span><br><span class="line">   for (const string&amp; word : msg)</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; word &lt;&lt; &quot; &quot;;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now press Ctrl+S to save the file. Notice how the file you just added appears in the <strong>File Explorer</strong> view (Ctrl+Shift+E) in the side bar of VS Code:</p>
<p><img src="https://code.visualstudio.com/assets/docs/cpp/wsl/file-explorer-helloworld.png" alt="File Explorer"></p>
<p>You can also enable <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/codebasics#_saveauto-save">Auto Save</a> to automatically save your file changes, by checking <strong>Auto Save</strong> in the main <strong>File</strong> menu.</p>
<p>The Activity Bar on the far left lets you open different views such as <strong>Search</strong>, <strong>Source Control</strong>, and <strong>Run</strong>. You’ll look at the <strong>Run</strong> view later in this tutorial. You can find out more about the other views in the VS Code <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/getstarted/userinterface">User Interface documentation</a>.</p>
<p>若在此处遇到未找到头文件的问题，请参照一下方法。</p>
<img src="C:\Users\431240\AppData\Roaming\Typora\typora-user-images\image-20210419160838596.png" alt="image-20210419160838596"  />







<h2 id="Explore-IntelliSense"><a href="#Explore-IntelliSense" class="headerlink" title="Explore IntelliSense#"></a>Explore IntelliSense<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_explore-intellisense">#</a></h2><p>In your new <code>helloworld.cpp</code> file, hover over <code>vector</code> or <code>string</code> to see type information. After the declaration of the <code>msg</code> variable, start typing <code>msg.</code> as you would when calling a member function. You should immediately see a completion list that shows all the member functions, and a window  that shows the type information for the <code>msg</code> object:</p>
<p><img src="https://code.visualstudio.com/assets/docs/cpp/wsl/msg-intellisense.png" alt="Statement completion IntelliSense"></p>
<p>You can press the Tab key to insert the selected member; then, when you add the opening parenthesis, you will see information about any arguments that the function requires.您可以按Tab键插入所选的成员;然后，当添加左括号时，您将看到关于函数所需的任何参数的信息。</p>
<h2 id="Build-helloworld-cpp"><a href="#Build-helloworld-cpp" class="headerlink" title="Build helloworld.cpp#"></a>Build helloworld.cpp<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_build-helloworldcpp">#</a></h2><p>Next, you will create a <code>tasks.json</code> file to tell VS Code  how to build (compile) the program. This task will invoke the g++  compiler on WSL to create an executable file based on the source code.</p>
<p>From the main menu, choose <strong>Terminal</strong> &gt; <strong>Configure Default Build Task</strong>. In the dropdown, which will display a tasks dropdown listing various predefined build tasks for C++ compilers. Choose <strong>g++ build active file</strong>, which will build the file that is currently displayed (active) in the editor.</p>
<p><img src="https://code.visualstudio.com/assets/docs/cpp/wsl/build-active-file.png" alt="Tasks C++ build dropdown"></p>
<p>This will create a <code>tasks.json</code> file in a <code>.vscode</code> folder and open it in the editor.</p>
<p>Your new <code>tasks.json</code> file should look similar to the JSON below:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">  &quot;tasks&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">      &quot;label&quot;: &quot;g++ build active file&quot;,</span><br><span class="line">      &quot;command&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;g++&quot;,</span><br><span class="line">      &quot;args&quot;: [&quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;&#x2F;$&#123;fileBasenameNoExtension&#125;&quot;],</span><br><span class="line">      &quot;options&quot;: &#123;</span><br><span class="line">        &quot;cwd&quot;: &quot;&#x2F;usr&#x2F;bin&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;problemMatcher&quot;: [&quot;$gcc&quot;],</span><br><span class="line">      &quot;group&quot;: &#123;</span><br><span class="line">        &quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">        &quot;isDefault&quot;: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>command</code> setting specifies the program to run; in this case that is g++. The <code>args</code> array specifies the command-line arguments that will be passed to g++.  These arguments must be specified in the order expected by the compiler. This task tells g++ to take the active file (<code>$&#123;file&#125;</code>), compile it, and create an executable file in the current directory (<code>$&#123;fileDirname&#125;</code>) with the same name as the active file but without an extension (<code>$&#123;fileBasenameNoExtension&#125;</code>), resulting in <code>helloworld</code> for our example.</p>
<blockquote>
<p><strong>Note</strong>: You can learn more about <code>tasks.json</code> variables in the <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/variables-reference">variables reference</a>.</p>
</blockquote>
<p>The <code>label</code> value is what you will see in the tasks list; you can name this whatever you like.</p>
<p>The <code>&quot;isDefault&quot;: true</code> value in the <code>group</code> object specifies that this task will be run when you press Ctrl+Shift+B. This property is for convenience only; if you set it to false, you can still run it from the Terminal menu with <strong>Tasks: Run Build Task</strong>.</p>
<h3 id="Running-the-build"><a href="#Running-the-build" class="headerlink" title="Running the build#"></a>Running the build<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_running-the-build">#</a></h3><ol>
<li><p>Go back to <code>helloworld.cpp</code>. Your task builds the active file and you want to build <code>helloworld.cpp</code>.</p>
</li>
<li><p>To run the build task defined in <code>tasks.json</code>, press Ctrl+Shift+B or from the <strong>Terminal</strong> main menu choose <strong>Tasks: Run Build Task</strong>.</p>
</li>
<li><p>When the task starts, you should see the Integrated Terminal panel  appear below the source code editor. After the task completes, the  terminal shows output from the compiler that indicates whether the build succeeded or failed. For a successful g++ build, the output looks  something like this:</p>
<p> <img src="https://code.visualstudio.com/assets/docs/cpp/wsl/wsl-task-in-terminal.png" alt="G++ build output in terminal"></p>
</li>
<li><p>Create a new terminal using the <strong>+</strong> button and you’ll have a bash terminal running in the context of WSL with the <code>helloworld</code> folder as the working directory. Run <code>ls</code> and you should now see the executable <code>helloworld</code> (no file extension).</p>
<p> <img src="https://code.visualstudio.com/assets/docs/cpp/wsl/wsl-bash-terminal.png" alt="WSL bash terminal"></p>
</li>
<li><p>You can run <code>helloworld</code> in the terminal by typing <code>./helloworld</code>.</p>
</li>
</ol>
<h3 id="Modifying-tasks-json"><a href="#Modifying-tasks-json" class="headerlink" title="Modifying tasks.json#"></a>Modifying tasks.json<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_modifying-tasksjson">#</a></h3><p>You can modify your <code>tasks.json</code> to build multiple C++ files by using an argument like <code>&quot;$&#123;workspaceFolder&#125;/*.cpp&quot;</code> instead of <code>$&#123;file&#125;</code>. You can also modify the output filename by replacing <code>&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</code> with a hard-coded filename (for example ‘helloworld.out’).</p>
<h2 id="Debug-helloworld-cpp"><a href="#Debug-helloworld-cpp" class="headerlink" title="Debug helloworld.cpp#"></a>Debug helloworld.cpp<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_debug-helloworldcpp">#</a></h2><p>Next, you’ll create a <code>launch.json</code> file to configure VS Code to launch the GDB debugger when you press F5 to debug the program. From the main menu, choose <strong>Run</strong> &gt; <strong>Add Configuration…</strong> and then choose <strong>C++ (GDB/LLDB)</strong>.</p>
<p>You’ll then see a dropdown for various predefined debugging configurations. Choose <strong>g++ build and debug active file</strong>.</p>
<p><img src="https://code.visualstudio.com/assets/docs/cpp/wsl/build-and-debug-active-file.png" alt="C++ debug configuration dropdown"></p>
<p>VS Code creates a <code>launch.json</code> file, opens it in the editor, and builds and runs ‘helloworld’.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">  &quot;configurations&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;g++ build and debug active file&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">      &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">      &quot;program&quot;: &quot;$&#123;fileDirname&#125;&#x2F;$&#123;fileBasenameNoExtension&#125;&quot;,</span><br><span class="line">      &quot;args&quot;: [],</span><br><span class="line">      &quot;stopAtEntry&quot;: false,</span><br><span class="line">      &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">      &quot;environment&quot;: [],</span><br><span class="line">      &quot;externalConsole&quot;: false,</span><br><span class="line">      &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class="line">      &quot;setupCommands&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,</span><br><span class="line">          &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">          &quot;ignoreFailures&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;preLaunchTask&quot;: &quot;g++ build active file&quot;,</span><br><span class="line">      &quot;miDebuggerPath&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;gdb&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>program</code> setting specifies the program you want to debug. Here it is set to the active file folder <code>$&#123;fileDirname&#125;</code> and active filename without an extension <code>$&#123;fileBasenameNoExtension&#125;</code>, which if <code>helloworld.cpp</code> is the active file will be <code>helloworld</code>.</p>
<p>By default, the C++ extension won’t add any breakpoints to your source code and the <code>stopAtEntry</code> value is set to <code>false</code>. Change the <code>stopAtEntry</code> value to <code>true</code> to cause the debugger to stop on the <code>main</code> method when you start debugging.</p>
<p>The remaining steps are provided as an optional exercise to help you get familiar with the editing and debugging experience.</p>
<h3 id="Start-a-debugging-session"><a href="#Start-a-debugging-session" class="headerlink" title="Start a debugging session#"></a>Start a debugging session<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_start-a-debugging-session">#</a></h3><ol>
<li>Go back to <code>helloworld.cpp</code> so that it is the active file.</li>
<li>Press F5 or from the main menu choose <strong>Run &gt; Start Debugging</strong>. Before you start stepping through the code, let’s take a moment to notice several changes in the user interface:</li>
</ol>
<ul>
<li><p>The Integrated Terminal appears at the bottom of the source code editor. In the <strong>Debug Output</strong> tab, you see output that indicates the debugger is up and running.</p>
</li>
<li><p>The editor highlights the first statement in the <code>main</code> method. This is a breakpoint that the C++ extension automatically sets for you:</p>
<p>  <img src="https://code.visualstudio.com/assets/docs/cpp/wsl/wsl-breakpoint-default.png" alt="Initial breakpoint"></p>
</li>
<li><p>The Run view on the left shows debugging information. You’ll see an example later in the tutorial.</p>
</li>
<li><p>At the top of the code editor, a debugging control panel appears. You can move this around the screen by grabbing the dots on the left side.</p>
<p>  <img src="https://code.visualstudio.com/assets/docs/cpp/cpp/debug-controls.png" alt="Debugging controls"></p>
</li>
</ul>
<h2 id="Step-through-the-code"><a href="#Step-through-the-code" class="headerlink" title="Step through the code#"></a>Step through the code<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_step-through-the-code">#</a></h2><p>Now you’re ready to start stepping through the code.</p>
<ol>
<li><p>Click or press the <strong>Step over</strong> icon in the debugging control panel.</p>
<p> <img src="https://code.visualstudio.com/assets/docs/cpp/cpp/step-over-button.png" alt="Step over button"></p>
<p> This will advance program execution to the first line of the for loop, and skip over all the internal function calls within the <code>vector</code> and <code>string</code> classes that are invoked when the <code>msg</code> variable is created and initialized. Notice the change in the <strong>Variables</strong> window on the left.</p>
<p> <img src="https://code.visualstudio.com/assets/docs/cpp/wsl/debug-view-variables.png" alt="Debugging windows"></p>
<p> In this case, the errors are expected because, although the variable  names for the loop are now visible to the debugger, the statement has  not executed yet, so there is nothing to read at this point. The  contents of <code>msg</code> are visible, however, because that statement has completed.</p>
</li>
<li><p>Press <strong>Step over</strong> again to advance to the next  statement in this program (skipping over all the internal code that is  executed to initialize the loop). Now, the <strong>Variables</strong> window shows information about the loop variables.</p>
</li>
<li><p>Press <strong>Step over</strong> again to execute the <code>cout</code> statement. (Note that as of the March 2019 release, the C++ extension does not print any output to the <strong>Debug Console</strong> until the loop exits.)</p>
</li>
<li><p>If you like, you can keep pressing <strong>Step over</strong> until all the words in the vector have been printed to the console. But if you are curious, try pressing the <strong>Step Into</strong> button to step through source code in the C++ standard library!</p>
<p> <img src="https://code.visualstudio.com/assets/docs/cpp/cpp/gcc-system-header-stepping.png" alt="Breakpoint in gcc standard library header"></p>
<p> To return to your own code, one way is to keep pressing <strong>Step over</strong>. Another way is to set a breakpoint in your code by switching to the <code>helloworld.cpp</code> tab in the code editor, putting the insertion point somewhere on the <code>cout</code> statement inside the loop, and pressing F9. A red dot appears in the gutter on the left to indicate that a breakpoint has been set on this line.</p>
<p> <img src="https://code.visualstudio.com/assets/docs/cpp/cpp/breakpoint-in-main.png" alt="Breakpoint in main"></p>
<p> Then press F5 to start execution from the current line in the standard library header. Execution will break on <code>cout</code>. If you like, you can press F9 again to toggle off the breakpoint.</p>
<p> When the loop has completed, you can see the output in the <strong>Debug Console</strong> tab of the integrated terminal, along with some other diagnostic information that is output by GDB.</p>
<p> <img src="https://code.visualstudio.com/assets/docs/cpp/wsl/debug-console-output-wsl.png" alt="Debug console display"></p>
</li>
</ol>
<h2 id="Set-a-watch"><a href="#Set-a-watch" class="headerlink" title="Set a watch#"></a>Set a watch<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_set-a-watch">#</a></h2><p>Sometimes you might want to keep track of the value of a variable as your program executes. You can do this by setting a <strong>watch</strong> on the variable.</p>
<ol>
<li><p>Place the insertion point inside the loop. In the <strong>Watch</strong> window, click the plus sign and in the text box, type <code>word</code>, which is the name of the loop variable. Now view the Watch window as you step through the loop.</p>
<p> <img src="https://code.visualstudio.com/assets/docs/cpp/cpp/watch-window.png" alt="Watch window"></p>
</li>
<li><p>Add another watch by adding this statement before the loop: <code>int i = 0;</code>. Then, inside the loop, add this statement: <code>++i;</code>. Now add a watch for <code>i</code> as you did in the previous step.</p>
</li>
<li><p>To quickly view the value of any variable while execution is paused  on a breakpoint, you can hover over it with the mouse pointer.</p>
<p> <img src="https://code.visualstudio.com/assets/docs/cpp/cpp/mouse-hover.png" alt="Mouse hover"></p>
</li>
</ol>
<h2 id="C-C-configurations"><a href="#C-C-configurations" class="headerlink" title="C/C++ configurations#"></a>C/C++ configurations<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_cc-configurations">#</a></h2><p>If you want more control over the C/C++ extension, you can create a <code>c_cpp_properties.json</code> file, which will allow you to change settings such as the path to the  compiler, include paths, C++ standard (default is C++17), and more.</p>
<p>You can view the C/C++ configuration UI by running the command <strong>C/C++: Edit Configurations (UI)</strong> from the Command Palette (Ctrl+Shift+P).</p>
<p><img src="https://code.visualstudio.com/assets/docs/cpp/cpp/command-palette.png" alt="Command Palette"></p>
<p>This opens the <strong>C/C++ Configurations</strong> page. When you make changes here, VS Code writes them to a file called <code>c_cpp_properties.json</code> in the <code>.vscode</code> folder.</p>
<p><img src="https://code.visualstudio.com/assets/docs/cpp/wsl/intellisense-configurations-wsl.png" alt="Command Palette"></p>
<p>You only need to modify the <strong>Include path</strong> setting if your program includes header files that are not in your workspace or in the standard library path.</p>
<p>Visual Studio Code places these settings in <code>.vscode/c_cpp_properties.json</code>. If you open that file directly, it should look something like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;configurations&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Linux&quot;,</span><br><span class="line">      &quot;includePath&quot;: [&quot;$&#123;workspaceFolder&#125;&#x2F;**&quot;],</span><br><span class="line">      &quot;defines&quot;: [],</span><br><span class="line">      &quot;compilerPath&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;gcc&quot;,</span><br><span class="line">      &quot;cStandard&quot;: &quot;c11&quot;,</span><br><span class="line">      &quot;cppStandard&quot;: &quot;c++17&quot;,</span><br><span class="line">      &quot;intelliSenseMode&quot;: &quot;clang-x64&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Closing-the-WSL-session"><a href="#Closing-the-WSL-session" class="headerlink" title="Closing the WSL session#"></a>Closing the WSL session<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_closing-the-wsl-session">#</a></h2><p>When you are done working in WSL, you can close your remote session with the <strong>Close Remote Connection</strong> command available in the main <strong>File</strong> menu and the Command Palette (Ctrl+Shift+P). This will restart VS Code running locally. You can easily reopen your WSL session from the <strong>File</strong> &gt; <strong>Open Recent</strong> list by selecting folders with the <strong>[WSL]</strong> suffix.</p>
<h2 id="Next-steps"><a href="#Next-steps" class="headerlink" title="Next steps#"></a>Next steps<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_next-steps">#</a></h2><ul>
<li>Explore the <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/codebasics">VS Code User Guide</a>.</li>
<li>Review the <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/languages/cpp">Overview of the C++ extension</a>.</li>
<li>Create a new workspace, copy your .json files to it, adjust the  necessary settings for the new workspace path, program name, and so on,  and start coding!</li>
</ul>
<p>11/22/2019</p>
<p>​          </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/21/Signal/What%20is%20a%20Bypass%20Capacitor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/21/Signal/What%20is%20a%20Bypass%20Capacitor/" class="post-title-link" itemprop="url">What is a Bypass Capacitor?</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-21 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-21T23:58:32+08:00">2021-04-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-29 00:50:14" itemprop="dateModified" datetime="2021-04-29T00:50:14+08:00">2021-04-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Signal/" itemprop="url" rel="index"><span itemprop="name">Signal</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="http://www.learningaboutelectronics.com/Articles/What-is-a-bypass-capacitor.html">learningaboutelectronics.com</a></p>
<h1 id="What-is-a-Bypass-Capacitor"><a href="#What-is-a-Bypass-Capacitor" class="headerlink" title="What is a Bypass Capacitor?"></a>What is a Bypass Capacitor?</h1><p><img src="http://www.learningaboutelectronics.com/images/Bypass-capacitor.png" alt="Bypass capacitor"></p>
<p>A bypass capacitor is a capacitor that shorts AC signals to ground, so  that any AC noise that may be  present on a DC signal is removed, producing a much cleaner and pure DC signal.</p>
<p>A bypass capacitor essentially bypasses  AC noise that may be on a DC signal, filtering out the AC, so that a clean, pure DC signal goes through without any AC ripple. </p>
<p>For example, you may want a pure DC signal from a power source. </p>
<p>Below is a transistor circuit. A transistor is an active device, so in order to work, it needs DC power. This power source is  VCC. In this case, VCC equals 15 volts. </p>
<p><img src="http://www.learningaboutelectronics.com/images/DC-power-source-transistor.png" alt="DC Power Source for Transistor"></p>
<p>This 15 volts provides power to the transistor so that the transistor can  amplify signals. We want this signal to be as purely DC as possible. Although we obtain our DC voltage, VCC, from a DC power  source such as a power supply, the voltage isn’t always purely DC. In  fact, many times the  voltage is very noisy and contains a lot of AC ripple on it, especially  at the 60Hz frequency because this is the frequency at which AC signals  run in many countries. </p>
<p>So although we want a pure DC signal, such as below:</p>
<p><img src="http://www.learningaboutelectronics.com/images/Pure-DC-voltage.png" alt="Pure DC Voltage"></p>
<p>Many times, we get a noisy signal that looks like:</p>
<p><img src="http://www.learningaboutelectronics.com/images/Noisy-dc-signal.png" alt="Noisy DC Voltage Signal"></p>
<p>A DC signal such as this is actually very common. This is undesired  because it adds noise to the transistor circuit. Therefore, this  noisy DC signal will be imposed on the AC signal. So the AC signal which may have music or some type of recording will now have much more noise. </p>
<p>This noise which is on the signal is AC ripple. Many  times when using a DC power supply connected to an AC power outlet, it  will  have some of the AC noise transfer to the DC power voltage. AC ripple  can also appear from other sources, so even batteries can produce noise. </p>
<p>To eliminate this AC ripple, we use a bypass  capacitor. So our transistor circuit above will have a bypass capacitor  added to it:</p>
<p><img src="http://www.learningaboutelectronics.com/images/Bypass-capacitor-transistor-circuit.png" alt="Bypass Capacitor for a Transistor Circuit"></p>
<p>A capacitor is a device that offers a tremendously high resistance for  signals of low frequencies. Therefore, signals at low frequencies will  not go through them. This is because  signals (current) always takes the path of least resistance. Therefore,  they will instead go through the resistor, RE. Remember, again, this is for low frequency signals, which is  basically DC signals. </p>
<p>However, capacitors offer much less resistance at higher frequencies (AC signals). So AC signals will go through the  capacitor and then to gorund. Therefore, DC signals will go  through the resistor, RE, while AC signals will go  through the capacitor, getting shunted to ground. So AC signals get  shunted to ground. This is how we have a clean DC signal  across our circuit, while AC noise imposed on it is bypassed to ground. </p>
<p><img src="http://www.learningaboutelectronics.com/images/How-a-bypass-capacitor-works.png" alt="How a Bypass Capacitor Works"></p>
<p>So a bypass capacitor blocks the DC from entering it by the great  resistance it offers to the signal but accepts the AC noise that may be  on the DC line and shunts or bypasses it to ground.  This is how bypass capacitors work.</p>
<h1 id="How-to-Choose-the-Value-of-the-Bypass-Capacitor"><a href="#How-to-Choose-the-Value-of-the-Bypass-Capacitor" class="headerlink" title="How to Choose the Value of the Bypass Capacitor"></a>How to Choose the Value of the Bypass Capacitor</h1><p>Now that you know conceptually what a bypass capacitor is, the next step is to know how to select the value of the  bypass capacitor. </p>
<p>And selecting the value is pretty straightforward. </p>
<p>The value of the bypass capacitor should be at least 1/10th of the resistance across the emitter resistance,  RE at the lowest frequency intended to be bypassed.</p>
<p>Because capacitors are reactive devices, they have different resistances to signals based on the signal’s frequency.  This is referred to as the capacitor’s reactance, which can be seen as the resistance it offers. We want the capacitor to have  1/10th of the resistance to the flow of current than what the resistor offers for the frequency signal that we want to bypass. </p>
<p>If you visualize the current moving through the transistor, it can take one of 2 paths once it passes the collector and  moves through the emitter. Current can either go the resistor, RE or current can flow through the bypass capacitor.  Current always takes the path of least resistance. Therefore, current  will take the path of the lower resistance.  This is why you want  the value of the resistance of the bypass capacitor to be at least  1/10th the value of the emitter resistor or, even better, less than  one-tenth. We want the AC current to flow through the least resistance  path, which is the bypass capacitor if the correct value is  chosen. </p>
<p>However, DC signals do not see it as AC. To DC, the capacitor has infinite resistance.  So DC will automatically go through the RE resistor, which offers lower resistance by far to the infinite resistance  of the capacitor. </p>
<p>AC, however, does not see infinite resistance for the capacitor. If we choose the value correctly for the capacitor,  we can make the capacitor a much lower-resistance path to ground, thus shorting out the AC signal to ground. </p>
<p>So let’s go over a practical example of how we would select the bypass capacitor value.</p>
<p>Let’s say we want to bypass the lowest possible frequency of 50Hz, because the frequency of AC voltages worldwide are 50-60Hz. Therefore, this frequency can be a very problematic because often there is AC ripple at this frequency. </p>
<p>Remember, when we said we bias the value of the bypass capacitor based on the lowest frequency that we want to bypass.  So by selecting the frequency of 50Hz, this blocks frequencies from 50Hz and higher; so it covers 60Hz. As frequency of an AC signal  increases, the resistance of the capacitor decreases and decreases with  each increase. Therefore, all the frequencies above the  frequency value that we choose get bypassed easier and easier. We’ll  demonstrate this all mathematically. </p>
<p>So we decided we want to bypass AC signals 50Hz or higher to ground. </p>
<p>The typical value of an emitter resistor is 400-500‎Ω. The resistance is kept low so that gain on the transistor isn’t  lowered too much. </p>
<p>So let’s say we choose an emitter resistor of 470‎Ω. </p>
<p>This means that we want the reactance of the capacitor to be one-tenth of 470‎Ω or less, which is 47‎Ω or lower.  So this is our target. </p>
<p>The formula for the reactance of a capacitor is, XC= 1/2πfc= 1/2(3.14)(50Hz)(C)=47Ω. Solving for the  capacitance, C, we get the value of approximately 67μF. So we need a  capacitor of at least 67μF to get a resistance of one-tenth  the value of 470Ω resistor. </p>
<p>Since a 67μF capacitor isn’t readily available, we can round up to 100μF, which is readily available and easy to obtain.  This is even better, because with a larger capacitance, the capacitor  offers even less resistance to the AC signal. If we plug a  100μF capacitor into the same capacitor reactance formula, we get XC= 1/2πfc= 1/2(3.14)(50Hz)(100μF)=31.8Ω. This is much  lower than 1/10 of the 470Ω resistor that we have in parallel. So it  will act effectively to short all AC signals 50Hz or higher  to ground to clean up the DC signal. </p>
<p>Even if you wanted, you could increase the  capacitance even more to allow for less AC noise on the signal. But a  lot  of times, this will not be done for cost and size constraints reasons.  The larger the size a capacitor is, the more it costs per unit. Also the larger the size of a capacitor, the larger physically is. Therefore, if a company is designing a product, the size of the capacitor could be a problem if there are size constraint issues. The way things are going in electronics, companies want  products to be as small and concise as possible. So due to reasons such  as these, larger value capacitors won’t always be chosen, but  theoretically, they would increase the purity of the DC signal, by  allowing more AC to ground. </p>
<p>So again, this is a summary of what a bypass capacitor is and how to select the value of them based on the lowest  AC signal desired to be filtered out and the value of the resistance in parallel with the capacitor. </p>
<p>You can check out our <a target="_blank" rel="noopener" href="http://www.learningaboutelectronics.com/Articles/Bypass-capacitor-calculator.php">bypass capacitor calculator</a> to calculate  the value of a bypass capacitor based on the input AC signal frequency and the value of the resistor in parallel. </p>
<p>Related Resources</p>
<p>​          </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/20/Networking/Unix%20domain%20socket%20%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/20/Networking/Unix%20domain%20socket%20%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Unix domain socket 简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-20 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-20T23:58:32+08:00">2021-04-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-29 00:52:30" itemprop="dateModified" datetime="2021-04-29T00:52:30+08:00">2021-04-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Networking/" itemprop="url" rel="index"><span itemprop="name">Networking</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sparkdev/p/8359028.html">cnblogs.com</a></p>
<p><strong>Unix domain socket 又叫 IPC(inter-process communication 进程间通信) socket，用于实现同一主机上的进程间通信。</strong>socket 原本是为网络通讯设计的，但后来在 socket 的框架上发展出一种 IPC 机制，就是 UNIX domain socket。虽然网络  socket 也可用于同一台主机的进程间通讯(通过 loopback 地址 127.0.0.1)，但是 UNIX domain socket  用于 IPC  更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。这是因为，IPC  机制本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。<br>UNIX domain socket 是全双工的，API 接口语义丰富，相比其它 IPC 机制有明显的优越性，目前已成为使用最广泛的 IPC 机制，比如 X Window 服务器和 GUI 程序之间就是通过 UNIX domain socket 通讯的。<br>Unix domain socket 是 POSIX 标准中的一个组件，所以不要被名字迷惑，linux 系统也是支持它的。</p>
<p>下面通过一个简单的 demo 来理解相关概念。程序分为服务器端和客户端两部分，它们之间通过 unix domain socket 进行通信。</p>
<h1 id="服务器端程序"><a href="#服务器端程序" class="headerlink" title="服务器端程序"></a>服务器端程序</h1><p>下面是一个非常简单的服务器端程序，它从客户端读字符，然后将每个字符转换为大写并回送给客户端：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stddef.h&gt;  </span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;  </span><br><span class="line">#include &lt;sys&#x2F;un.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;ctype.h&gt;   </span><br><span class="line"> </span><br><span class="line">#define MAXLINE 80  </span><br><span class="line"> </span><br><span class="line">char *socket_path &#x3D; &quot;server.socket&quot;;  </span><br><span class="line"> </span><br><span class="line">int main(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_un serun, cliun;  </span><br><span class="line">    socklen_t cliun_len;  </span><br><span class="line">    int listenfd, connfd, size;  </span><br><span class="line">    char buf[MAXLINE];  </span><br><span class="line">    int i, n;  </span><br><span class="line"> </span><br><span class="line">    if ((listenfd &#x3D; socket(AF_UNIX, SOCK_STREAM, 0)) &lt; 0) &#123;  </span><br><span class="line">        perror(&quot;socket error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    memset(&amp;serun, 0, sizeof(serun));  </span><br><span class="line">    serun.sun_family &#x3D; AF_UNIX;  </span><br><span class="line">    strcpy(serun.sun_path, socket_path);  </span><br><span class="line">    size &#x3D; offsetof(struct sockaddr_un, sun_path) + strlen(serun.sun_path);  </span><br><span class="line">    unlink(socket_path);  </span><br><span class="line">    if (bind(listenfd, (struct sockaddr *)&amp;serun, size) &lt; 0) &#123;  </span><br><span class="line">        perror(&quot;bind error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">    printf(&quot;UNIX domain socket bound\n&quot;);  </span><br><span class="line">      </span><br><span class="line">    if (listen(listenfd, 20) &lt; 0) &#123;  </span><br><span class="line">        perror(&quot;listen error&quot;);  </span><br><span class="line">        exit(1);          </span><br><span class="line">    &#125;  </span><br><span class="line">    printf(&quot;Accepting connections ...\n&quot;);  </span><br><span class="line"> </span><br><span class="line">    while(1) &#123;  </span><br><span class="line">        cliun_len &#x3D; sizeof(cliun);         </span><br><span class="line">        if ((connfd &#x3D; accept(listenfd, (struct sockaddr *)&amp;cliun, &amp;cliun_len)) &lt; 0)&#123;  </span><br><span class="line">            perror(&quot;accept error&quot;);  </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        while(1) &#123;  </span><br><span class="line">            n &#x3D; read(connfd, buf, sizeof(buf));  </span><br><span class="line">            if (n &lt; 0) &#123;  </span><br><span class="line">                perror(&quot;read error&quot;);  </span><br><span class="line">                break;  </span><br><span class="line">            &#125; else if(n &#x3D;&#x3D; 0) &#123;  </span><br><span class="line">                printf(&quot;EOF\n&quot;);  </span><br><span class="line">                break;  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            printf(&quot;received: %s&quot;, buf);  </span><br><span class="line"> </span><br><span class="line">            for(i &#x3D; 0; i &lt; n; i++) &#123;  </span><br><span class="line">                buf[i] &#x3D; toupper(buf[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">            write(connfd, buf, n);  </span><br><span class="line">        &#125;  </span><br><span class="line">        close(connfd);  </span><br><span class="line">    &#125;  </span><br><span class="line">    close(listenfd);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>简单介绍一下这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int family, int type, int protocol);</span><br></pre></td></tr></table></figure>

<p>使用 UNIX domain socket 的过程和网络 socket 十分相似，也要先调用 socket() 创建一个 socket 文件描述符.<br><strong>family</strong> 指定为 AF_UNIX，使用 AF_UNIX 会在系统上创建一个 socket 文件，不同进程通过读写这个文件来实现通信。<br><strong>type</strong> 可以选择 SOCK_DGRAM 或 SOCK_STREAM。SOCK_STREAM 意味着会提供按顺序的、可靠、双向、面向连接的比特流。SOCK_DGRAM 意味着会提供定长的、不可靠、无连接的通信。<br><strong>protocol</strong> 参数指定为 0 即可。<br>UNIX domain socket 与网络 socket 编程最明显的不同在于地址格式不同，用结构体 sockaddr_un 表示，网络编程的  socket 地址是 IP 地址加端口号，而 UNIX domain socket 的地址是一个 socket  类型的文件在文件系统中的路径，这个 socket 文件由 bind() 调用创建，如果调用 bind() 时该文件已存在，则 bind()  错误返回。因此，一般在调用 bind() 前会检查 socket 文件是否存在，如果存在就删除掉。<br>网络 socket 编程类似，在 bind 之后要 listen，表示通过 bind 的地址（也就是 socket 文件）提供服务。<br>接下来必须用 accept() 函数初始化连接。accept() 为每个连接创立新的套接字并从监听队列中移除这个连接。</p>
<h1 id="客户端程序"><a href="#客户端程序" class="headerlink" title="客户端程序"></a>客户端程序</h1><p>下面是客户端程序，它接受用户的输入，并把字符串发送给服务器，然后接收服务器返回的字符串并打印：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stddef.h&gt;  </span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;  </span><br><span class="line">#include &lt;sys&#x2F;un.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line"> </span><br><span class="line">#define MAXLINE 80  </span><br><span class="line"> </span><br><span class="line">char *client_path &#x3D; &quot;client.socket&quot;;  </span><br><span class="line">char *server_path &#x3D; &quot;server.socket&quot;;  </span><br><span class="line"> </span><br><span class="line">int main() &#123;  </span><br><span class="line">    struct  sockaddr_un cliun, serun;  </span><br><span class="line">    int len;  </span><br><span class="line">    char buf[100];  </span><br><span class="line">    int sockfd, n;  </span><br><span class="line"> </span><br><span class="line">    if ((sockfd &#x3D; socket(AF_UNIX, SOCK_STREAM, 0)) &lt; 0)&#123;  </span><br><span class="line">        perror(&quot;client socket error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F; 一般显式调用bind函数，以便服务器区分不同客户端  </span><br><span class="line">    memset(&amp;cliun, 0, sizeof(cliun));  </span><br><span class="line">    cliun.sun_family &#x3D; AF_UNIX;  </span><br><span class="line">    strcpy(cliun.sun_path, client_path);  </span><br><span class="line">    len &#x3D; offsetof(struct sockaddr_un, sun_path) + strlen(cliun.sun_path);  </span><br><span class="line">    unlink(cliun.sun_path);  </span><br><span class="line">    if (bind(sockfd, (struct sockaddr *)&amp;cliun, len) &lt; 0) &#123;  </span><br><span class="line">        perror(&quot;bind error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    memset(&amp;serun, 0, sizeof(serun));  </span><br><span class="line">    serun.sun_family &#x3D; AF_UNIX;  </span><br><span class="line">    strcpy(serun.sun_path, server_path);  </span><br><span class="line">    len &#x3D; offsetof(struct sockaddr_un, sun_path) + strlen(serun.sun_path);  </span><br><span class="line">    if (connect(sockfd, (struct sockaddr *)&amp;serun, len) &lt; 0)&#123;  </span><br><span class="line">        perror(&quot;connect error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    while(fgets(buf, MAXLINE, stdin) !&#x3D; NULL) &#123;    </span><br><span class="line">         write(sockfd, buf, strlen(buf));    </span><br><span class="line">         n &#x3D; read(sockfd, buf, MAXLINE);    </span><br><span class="line">         if ( n &lt; 0 ) &#123;    </span><br><span class="line">            printf(&quot;the other side has been closed.\n&quot;);    </span><br><span class="line">         &#125;else &#123;    </span><br><span class="line">            write(STDOUT_FILENO, buf, n);    </span><br><span class="line">         &#125;    </span><br><span class="line">    &#125;   </span><br><span class="line">    close(sockfd);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>与网络 socket 编程不同的是，UNIX domain socket 客户端一般要显式调用 bind  函数，而不依赖系统自动分配的地址。客户端 bind 一个自己指定的 socket 文件名的好处是，该文件名可以包含客户端的 pid  等信息以便服务器区分不同的客户端。</p>
<h1 id="运行上面的程序"><a href="#运行上面的程序" class="headerlink" title="运行上面的程序"></a>运行上面的程序</h1><p>分别把服务器端程序和客户端程序保存为 server.c 和 client.c 文件，并编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc server.c -o server</span><br><span class="line">$ gcc client.c -o client</span><br></pre></td></tr></table></figure>

<p>先启动服务器端程序，然后启动客户端程序输入字符串并回车：</p>
<p><img src="https://images2017.cnblogs.com/blog/952033/201801/952033-20180126125928506-239880118.png" alt="img"></p>
<p>还不错，客户端得到了服务器端返回的大写字符串。接下来看看当前目录下的文件：</p>
<p><img src="https://images2017.cnblogs.com/blog/952033/201801/952033-20180126125951834-1641586991.png" alt="img"></p>
<p>哈哈，多了两个 socket 文件。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Unix domain socket 主要用于同一主机上的进程间通信。与主机间的进程通信不同，它不是通过 “IP地址 + TCP或UDP端口号” 的方式进程通信，而是使用 socket 类型的文件来完成通信，因此在稳定性、可靠性以及效率方面的表现都很不错。</p>
<p><strong>参考：</strong><br><a target="_blank" rel="noopener" href="http://docs.linuxtone.org/ebooks/C&CPP/c/ch37s04.html">UNIX Domain Socket IPC</a><br>[<a target="_blank" rel="noopener" href="http://blog.csdn.net/tzshlyt/article/details/53391655">linux] unix domain socket 例子</a></p>
<p>​          </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/20/Networking/Networking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/20/Networking/Networking/" class="post-title-link" itemprop="url">Networking</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-20 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-20T23:58:32+08:00">2021-04-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-26 00:14:57" itemprop="dateModified" datetime="2021-04-26T00:14:57+08:00">2021-04-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Networking/" itemprop="url" rel="index"><span itemprop="name">Networking</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><blockquote>
<p><em>内容分发网络（Content Delivery Network，CDN）是建立并覆盖在承载网上，由不同区域的服务器组成的分布式网络。将源站资源缓存到全国各地的边缘服务器，供用户就近获取，降低源站压力。</em></p>
<p>——阿里云</p>
<p>*CDN是构建在现有网络基础之上的智能虚拟网络，依靠 <strong>部署在各地的边缘服务器</strong>，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。*</p>
<p>——百度百科</p>
</blockquote>
<p>个人理解，实际部署CDN中最重要的概念即 <strong>节点</strong>、<strong>缓存服务器</strong> 和 <strong>中心平台</strong>。</p>
<ul>
<li>节点是指在足够广的范围内识别出合适数量的网络拓扑节点，这些节点往往处在网络所及最远之处的各地，能够有效分摊用户访问对主干网络的压力；</li>
<li>而缓存服务器即“部署在各地的边缘服务器”，是指能够 <strong>制定规则</strong> <strong>自动识别并缓存数据</strong> 以供用户快速访问，分担主干网络压力的实体。</li>
<li>中心平台可以对缓存服务器实现负载均衡、内容分发和调度等功能。</li>
</ul>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><blockquote>
<p>假设您的加速域名为<code>www.a.com</code>，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下图所示。</p>
<ol>
<li>当终端用户（北京）向<code>www.a.com</code>下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。                  </li>
<li>LDNS检查缓存中是否有<code>www.a.com</code>的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。                  </li>
<li>当授权DNS解析<code>www.a.com</code>时，返回域名CNAME <code>www.a.tbcdn.com</code>对应IP地址。                  </li>
<li>域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。</li>
<li>LDNS获取DNS返回的解析IP地址。</li>
<li>用户获取解析IP地址。</li>
<li>用户向获取的IP地址发起对该资源的访问请求。                                                           <ul>
<li>如果该IP地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤7和8，请求结束。</li>
<li>如果该IP地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。配置缓存策略的操作方法，请参见<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/27136.htm?spm=a2c4g.11186623.2.3.694925b3RabzbR#concept-f24-32d-xdb">缓存配置</a>。                        </li>
</ul>
</li>
</ol>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/p4886.png" alt="img" style="zoom: 67%;" />

<p>——阿里云</p>
</blockquote>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="场景概述"><a href="#场景概述" class="headerlink" title="场景概述"></a>场景概述</h5><p>CDN的业务使用场景分为 <strong>静态内容加速</strong>、<strong>动态内容加速</strong> 和 <strong>安全加速</strong> 。</p>
<blockquote>
<p><strong>静态内容（静态资源）</strong></p>
<p>静态内容是指在不同请求中访问到的数据都相同的静态文件。例如：图片、视频、网站中的文件（html、css、js）、软件安装包、apk文件、压缩包文件等。</p>
<p>CDN加速的本质是 <strong>缓存加速</strong>。将您服务器上存储的静态内容缓存在阿里云CDN节点上，当您访问这些静态内容时，无需访问服务器源站，就近访问阿里云CDN节点即可获取相同内容。从而达到加速的效果，同时减轻服务器源站的压力。</p>
<p><strong>动态内容（动态资源）</strong></p>
<p>动态内容是指在不同请求中访问到的数据不相同的动态内容。例如：网站中的文件（asp、jsp、php、perl、cgi）、API接口、数据库交互请求等。</p>
<p><strong>当您访问这些动态内容时，每次都需要访问您的服务器，由服务器动态生成实时的数据并返回给您。</strong>因此CDN的缓存加速不适用于加速动态内容，CDN无法缓存实时变化的动态内容。对于动态内容请求，CDN节点只能转发回您的服务器源站，没有加速效果。</p>
<p>如果您的网站或App应用有较多动态内容，例如需要对各种API接口进行加速，则需要使用 <a target="_blank" rel="noopener" href="https://www.alibabacloud.com/zh/product/dcdn">阿里云全站加速</a> 产品。全站加速能同时加速动态和静态内容，加速方式如下：                                                                     </p>
<ul>
<li>静态内容使用CDN加速。</li>
<li>动态内容通过阿里云的 <strong>路由优化</strong>、<strong>传输优化</strong> 等动态加速技术以最快的速度访问您的服务器源站获取数据。从而达到全站加速的效果。</li>
</ul>
<p>——阿里云</p>
</blockquote>
<h5 id="全站加速"><a href="#全站加速" class="headerlink" title="全站加速"></a>全站加速</h5><blockquote>
<p>全站加速（Dynamic Route for Content Delivery  Network）是阿里云自主研发的融合了动态加速和静态加速技术的CDN产品。该产品一站式解决了页面动静态资源混杂、跨运营商、网络不稳定、单线源站、突发流量、网络拥塞等诸多因素导致的响应慢、丢包、服务不稳定的问题，提升全站性能和用户体验。</p>
<p><strong>工作原理</strong></p>
<p>阿里云全站加速通过智能路由区分客户请求内容，实现动静态加速。通过架构图，您可以了解全站加速的工作原理。</p>
<img src="https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/5931788951/p6063.png" style="zoom: 40%;" />

<ul>
<li>智能区分动静态内容：域名接入阿里云全站加速后，通过域名访问的动静态内容将被智能识别并区分。</li>
<li>动静态内容同时加速：静态内容使用阿里云CDN加速，缓存在CDN节点上，供您就近访问。动态内容通过 <strong>智能路由优化</strong>、<strong>协议优化</strong> 等动态加速技术快速回源获取。</li>
</ul>
<p><strong>全站加速与CDN对比</strong></p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210414100053078.png" alt="image-20210414100053078" style="zoom: 80%;" />


</blockquote>
<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>SSH is a program for logging into a remote machine and for excuting commands on a remote machine.</p>
<p>It’s intended to provide secure encrypted communications between two untrusted hosts over and insecure network.</p>
<p>X11 connections, arbitrary TCP ports and UNIX-domain sockets can also be forwarded over the secure channel.</p>
<h4 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h4><p>The OpenSSH SSH client supports SSH protocol 2.</p>
<p>Five available authentication methods: GSSAPI-based / host-based / public key / challenge-response and password.</p>
<h5 id="Host-based"><a href="#Host-based" class="headerlink" title="Host-based"></a>Host-based</h5><p>If the machine the user logs in from is listed in <code>/etc/hosts.equiv</code> or <code>/etc/ssh/shosts.equiv</code> on the remote machine, the user is non-root and the user names are the same on both sides, or if the files <code>~/.rhosts</code> or <code>~/.shosts</code> exist in the user’s home directory on the remote machine and contain a line containing the name of the client machine and the name of the user on that machine, the user is considered for login.  Additionally, the server must be able to verify the client’s host key (see the description of <code>/etc/ssh/ssh_known_hosts</code> and <code>~/.ssh/known_hosts</code>, below) for login to be permitted.  This authentication method closes security holes due to IP spoofing, DNS spoofing, and routing spoofing.  </p>
<p>[<strong>Note to the administrator</strong>: <code>/etc/hosts.equiv</code>, <code>~/.rhosts</code>, and the rlogin/rsh protocol in general, are inherently insecure and should be disabled if security is desired.]</p>
<h5 id="Public-key"><a href="#Public-key" class="headerlink" title="Public key"></a>Public key</h5><p>The scheme is based on public-key cryptography, using cryptosystems where encryption and decryption are done using separate keys, and it is unfeasible to derive the decryption key from the encryption key.  The idea is that each user creates a public/private key pair for authentication purposes. </p>
<p><em><strong>The server knows the public key, and only the user knows the private key.</strong></em>  ssh implements public key authentication protocol automatically, using one of the <strong>DSA</strong>, <strong>ECDSA</strong>, <strong>Ed25519</strong> or <strong>RSA</strong> algorithms.  The HISTORY section of ssl(8) <a target="_blank" rel="noopener" href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&sektion=8#HISTORY">[i]</a> on non-OpenBSD systems contains a brief discussion of the DSA and RSA algorithms.</p>
<p>The file <code>~/.ssh/authorized_keys</code> lists the public keys that are permitted for logging in.  When the user logs in, the ssh program tells the server which key pair it would like to use for authentication.  The client proves that it has access to the private key and the server checks that the corresponding public key is authorized to accept the account.</p>
<p>The user should then <mark>copy the public key to <code>~/.ssh/authorized_keys</code> in his/her home directory on the remote machine.</mark>  The authorized_keys file corresponds to the conventional <code>~/.rhosts</code> file, and has one key per line, though the lines can be very long. After this, the user can log in without giving the password.</p>
<h6 id="ssh-keygen"><a href="#ssh-keygen" class="headerlink" title="ssh-keygen"></a>ssh-keygen</h6><p>To generate a public key for ssh, we need to use:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-kegen -t rsa</span><br></pre></td></tr></table></figure>

<p>The terminal will ask if <code>/root/.ssh/id_rsa</code> the file you save the key:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;root&#x2F;.ssh&#x2F;id_rsa):</span><br></pre></td></tr></table></figure>

<p>The terminal will require you to enter the <em>passphrase</em> twice.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure>

<p><em><strong>Identification</strong></em> is the private key used by the server(the remote machine). And the <em><strong>public key</strong></em> is generated for the client to authenticate while logging in the server.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Your identification has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">Your public key has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256: *******</span><br><span class="line">The key&#39;s randomart imge is:</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The user creates his/her key pair by running ssh-keygen(1).  </p>
<p>This stores the <em><strong>private key</strong></em> in <code>~/.ssh/id_dsa</code> (DSA), <code>~/.ssh/id_ecdsa</code> (ECDSA), <code>~/.ssh/id_ecdsa_sk</code> (authenticator-hosted ECDSA), <code>~/.ssh/id_ed25519</code> (Ed25519), <code>~/.ssh/id_ed25519_sk</code> (authenticator-hosted Ed25519), or <code>~/.ssh/id_rsa</code> (RSA) .</p>
<p>The the <em><strong>public key</strong></em> stores in <code>~/.ssh/id_dsa.pub</code> (DSA), <code>~/.ssh/id_ecdsa.pub</code> (ECDSA), <code>~/.ssh/id_ecdsa_sk.pub</code> (authenticator-hosted ECDSA), <code>~/.ssh/id_ed25519.pub</code> (Ed25519), <code>~/.ssh/id_ed25519_sk.pub</code> (authenticator-hosted Ed25519), or <code>~/.ssh/id_rsa.pub</code> (RSA) in the <strong>user’s home directory</strong>.</p>
</blockquote>
<p>Check and copy your <code>.pub</code> file to the local computer.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh/</span><br><span class="line">vim id_rsa.pub</span><br></pre></td></tr></table></figure>



<h6 id="Permissions-0644"><a href="#Permissions-0644" class="headerlink" title="Permissions 0644"></a>Permissions 0644</h6><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210423135807684.png" alt="image-20210423135807684" style="zoom: 80%;" />

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 0600 ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>













<h4 id="Login-Format"><a href="#Login-Format" class="headerlink" title="Login Format"></a>Login Format</h4><p><code>user@hostname</code> : <code>root@qq.com</code></p>
<p><code>ssh://root@hostname:port</code> : <code>ssh://root@qq.com:666</code></p>
<h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p>基于 SSL 证书，可将站点由 HTTP（Hypertext Transfer Protocol）切换到 HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer），即基于安全套接字层（SSL）进行安全数据传输的加密版 HTTP 协议。</p>
<h4 id="SSL优势"><a href="#SSL优势" class="headerlink" title="SSL优势"></a>SSL优势</h4><ul>
<li><p><strong>防流量劫持：</strong>全站 HTTPS 是根治运营商、中间人流量劫持的解决方案，不仅可以杜绝网页中显示的小广告，更可以保护用户隐私安全。</p>
</li>
<li><p><strong>提升搜索排名：</strong>采用 HTTPS 可以帮忙搜索排名的提升，提高站点的可信度和品牌形象。</p>
</li>
<li><p><strong>杜绝钓鱼网站：</strong>HTTPS 地址栏绿色图标可以帮助用户识别出钓鱼网站，保障用户和企业的利益不受损害，增强用户信任。</p>
</li>
</ul>
<h4 id="SSL证书签发"><a href="#SSL证书签发" class="headerlink" title="SSL证书签发"></a>SSL证书签发</h4><p>域名型证书由以下品牌提供自动审核认证，快速签发。</p>
<ul>
<li><strong>SecureSite</strong>：全球最大的信息安全厂商和服务商，最权威的数字证书颁发机构，为企业、个人用户和服务供应商提供广泛的内容和网络安全解决方案，全球500强中有93%选择了 VeriSign SSL 数字证书，目前均由 SecureSite 提供服务。</li>
<li><strong>TrustAsia®（亚洲诚信）</strong>：亚数信息科技（上海）有限公司应用于信息安全领域的品牌，是 SecureSite 的白金合作伙伴，专业为企业提供包含数字证书在内的所有网络安全服务。</li>
<li><strong>GeoTrust</strong>：GeoTrust  是全球第二大数字证书颁发机构（CA），也是身份认证和信任认证领域的领导者，该公司各种先进的技术使得任何大小的机构和公司都能安全地低成本地部署  SSL 数字证书和实现各种身份认证。从2001年成立到2006年占领全球市场25%的市场份额，VeriSign 于2006年5月 -  2006年9月以1.25亿美元收购 GeoTrust，目前也同为 SecureSite 旗下 SSL 证书的<strong>性价比高</strong>的品牌。</li>
<li><strong>GlobalSign</strong>： GlobalSign 成立于1996年，是一家声誉卓著，备受信赖的 CA  中s心和 SSL 数字证书提供商，在全球总计颁发超过2000万张数字证书。GlobalSign  的专业实力获得中国网络市场众多服务器、域名注册商、系统服务供应商的青睐，成为其数字证书服务的合作伙伴。</li>
<li><strong>WoTrus（沃通）</strong>：沃通电子认证服务有限公司（WoTrus CA Limited）是同时获得国内电子认证服务许可证（由工信部颁发）和通过国际认证的证书颁发机构（CA）。专业为企业提供权威第三方数字身份认证服务，颁发全球信任的各种数字证书产品。</li>
<li><strong>DNSPod 品牌国密标准（SM2）证书</strong>：DNSPod 为腾讯云自有品牌，采用国密标准，并且是纯国产数字证书，由国内知名 CA 机构提供基础设置支撑，敏捷高效，同时满足国家监管需求。</li>
</ul>
<h4 id="SSL证书品牌差异"><a href="#SSL证书品牌差异" class="headerlink" title="SSL证书品牌差异"></a>SSL证书品牌差异</h4><p>不同品牌的证书在浏览器地址栏、加密强度、赔付保障上均存在差异，最重要的差异点在于根证书。</p>
<p>例如，GeoTrust 通配符是 GeoTrust 根证书签发的，而 SecureSite 通配符是 SecureSite 根证书签发的。<mark>Digicert  根证书可以兼容市面上所有的浏览器，对移动端的支持也是最好的</mark>，而 Trustasia 通配符也是 Digicert  根证书签发的，GlobalSign 通配符是 GlobalSign 的根证书签发的，DNSPod 是由 Wotrus  的根证书签发的，Wotrus 通配符是 Sectigo 的根证书签发的。</p>
<blockquote>
<p><strong>通配符：</strong></p>
<p><strong>根证书：</strong></p>
</blockquote>
<p>单纯从技术角度，SecureSite（原 Verisign）和 GeoTrust 的区别如下：</p>
<ul>
<li>算法支持上 SecureSite（支持 RSA、DSA、ECC 三种算法）优于 GeoTrust（支持 RSA、DSA 两种算法）。</li>
<li>兼容性 SecureSite 优于 GeoTrust，SecureSite 可兼容市面上所有的浏览器，对移动端的支持也是极好的。</li>
<li>OCSP 响应速度上 SecureSite 优于 GeoTrust。</li>
<li>CA 安全性方面 SecureSite 优于 GeoTrust，SecureSite 是国际知名安全厂商，CA 的安全级别也是国际第一的安全系数。</li>
<li>SecureSite 证书除实现加密传输以外，还另外有恶意软件扫描和漏洞评估的附加功能。</li>
<li>SecureSite 对证书有商业保险赔付保障，金额最高为175万美金，GeoTrust 最高为150万美金。</li>
</ul>
<h4 id="SSL证书格式"><a href="#SSL证书格式" class="headerlink" title="SSL证书格式"></a>SSL证书格式</h4><p>SSL证书分为 <code>pem</code> 和 <code>key</code>  这两种格式，分别存储的是 <strong>证书base64加密</strong> 和 <strong>私钥base64加密</strong> 还有 格式分割符，也就是说pem存的是证书，key 存的是私钥。</p>
<p>如pem中的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">略</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure>

<p> <code>-----BEGIN CERTIFICATE-----</code>  和 <code>-----END CERTIFICATE-----</code> 为分割分，表示在这两个中间存的是证书的base64编码</p>
<p>备注：</p>
<p>如key中的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">略</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>

<p><code>-----BEGIN RSA PRIVATE KEY-----</code> 和 <code>-----END RSA PRIVATE KEY-----</code> 为分割符号，表示在这两个中间存的是私钥的base64编码</p>
<p>备注：CERTIFICATE 单词代表证书的意思；PRIVATE KEY 单词代表 私钥、秘钥的意思。</p>
<h4 id="SSL证书配置"><a href="#SSL证书配置" class="headerlink" title="SSL证书配置"></a>SSL证书配置</h4><p>以下以“阿里云OSS”及“腾讯云COS”的对象存储（bucket）与域名（name）绑定过程中，对SSL证书的配置为例，进行解释和说明，不对详细步骤进行描述，仅解释原理。</p>
<h5 id="域名及Bucket绑定"><a href="#域名及Bucket绑定" class="headerlink" title="域名及Bucket绑定"></a>域名及Bucket绑定</h5><p>阿里云及腾讯云都可以申请对象存储和域名，所申请的域名按正规流程均需要经过挂载至某个服务器进行备案（国内公安要求）后才可以与对象存储绑定，进而颁发证书给挂载至对象存储的域名。</p>
<h5 id="SSL证书申请及配置"><a href="#SSL证书申请及配置" class="headerlink" title="SSL证书申请及配置"></a>SSL证书申请及配置</h5><p>若域名互相绑定后未配置SSL则会导致https访问失败，配置SSL需要给自己的域名申请免费SSL证书，阿里云及腾讯云都可以免费申请为期一年的证书，按流程填写信息并等待审核下发即可；获得证书后需要选择“其他”类型的证书进行下载。证书中需要的 <strong>公钥</strong> 即 <code>.pem</code> 格式文件，而 <strong>私钥</strong> 即 <code>.key</code> 格式文件，分别填写到Bucket的域名管理页面内下的 <strong>证书上传</strong> 中。</p>
<p>流程大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	开始 --&gt; Bucket申请--可选CDN加速开启--&gt; 获得Bucket域名或CDN加速域名 --CNAME解析--&gt;域名绑定--&gt;结束</span><br><span class="line">	开始 --&gt; 域名申请 --&gt; 域名备案 --CNAME解析--&gt; 域名绑定</span><br><span class="line">	域名申请 --&gt; SSL证书申请 --&gt; 下载证书 --复制粘贴至Bucket的域名管理页面--&gt; 证书上传--&gt; 结束</span><br></pre></td></tr></table></figure>

<h3 id="DDos"><a href="#DDos" class="headerlink" title="DDos"></a>DDos</h3><h4 id="常见流量攻击"><a href="#常见流量攻击" class="headerlink" title="常见流量攻击"></a>常见流量攻击</h4><h5 id="SYN-Flood"><a href="#SYN-Flood" class="headerlink" title="SYN Flood"></a>SYN Flood</h5><p>Flood即洪水之意，SYN是指TCP通信中用于建立连接时标志位之一。</p>
<p>此时需要用到 TCP Three-way Handshake的知识点，当需要建立连接时：</p>
<ul>
<li>Client向Server <mark>发去SYN标志</mark></li>
<li>Server收到后向Client <mark>回复SYN和ACK标志</mark></li>
<li>Client收到由Server发过来的SYN和ACK后 <mark>回复一个ACK标志</mark></li>
</ul>
<p>以上即为三次握手协议的主要流程，其实只有Server收到该ACK时，才标志着双方建立连接。以下介绍几种”意外“情况。</p>
<p><strong>情况一：</strong>当Client第一次收到SYN和ACK时，Client就单方面“认为”自己已经和Server建立连接了。但网络通信时并不能百分百保证可靠，假如Client发了ACK，但Server并未收到，则Server就并不”认为“自己与Client建立了连接。Server和Client都有自己的定时器，在发送数据之后就开始计时，不管如何，此时Client都已经发了ACK了，“觉得”自己已经建立了连接，而Server不然，Server就会再次发送SYN和ACK以请求Client的确认。</p>
<p><strong>情况二：</strong>多个Client向Server同时发送SYN请求，Server收到信息后立即回复SYN和ACK，并且需要为每一个Client设立一个计时器以等待他们的ACK信息。假如此刻Client的数量非常多且每一个都发送了一次SYN请求，则Server的计时器则会立刻被用光，导致任何正常请求都无法连接。（针对此种攻击方式，提出了二次SYN当成一次SYN的防攻击手段，即Client需要连续发两次SYN在标明自己是真的“有意”连接，不是恶意发送攻击的，但此类二次验证方式比较简单，仍然容易被模仿）</p>
<h5 id="ICMP-Flood"><a href="#ICMP-Flood" class="headerlink" title="ICMP Flood"></a>ICMP Flood</h5><p>ICMP也算是网络层协议的一员，封装在IP协议中，是IP协议的附属协议，可以直接被用户进程直接使用。</p>
<p>此处的ICMP Flood指的是利用集群设备在同一时间使用 ping 功能对目标主机发起请求，强制主机进行回复，致使目标主机瘫痪。</p>
<p>以下为ping的英文解释</p>
<blockquote>
<p><em>PING - Send ICMP ECHO_REQUEST to network hosts</em></p>
<p><em>Ping uses the ICMP protocol’s mandatory ECHO_REQUEST datagram to elicit  an ICMP ECHO_RESPONSE from a host or gateway.</em></p>
<p>—— from ‘manual of ping’ in linux</p>
</blockquote>
<h3 id="选择数据库服务器的五个原则"><a href="#选择数据库服务器的五个原则" class="headerlink" title="选择数据库服务器的五个原则"></a>选择数据库服务器的五个原则</h3><h4 id="1-高性能原则"><a href="#1-高性能原则" class="headerlink" title="1)高性能原则"></a>1)高性能原则</h4><p>保证所选购的服务器，不仅能够满足运营系统的运行和业务处理的需要，而且能够满足一定时期业务量的增长。一般可以根据经验公式计算出所需的服务器TpmC值(Tpmc是衡量计算机系统的事务处理能力的程序)，然后比较各服务器厂商和TPC组织公布的TpmC值，选择相应的机型。同时，用服务器的市场价/报价除去计算出来的TpmC值得出单位TpmC值的价格，进而选择高性能价格比的服务器。</p>
<p><strong>结论：</strong>服务器处理器性能很关键，CPU的主频要高，要有较大的缓存</p>
<h4 id="2-可靠性原则"><a href="#2-可靠性原则" class="headerlink" title="2)可靠性原则"></a>2)可靠性原则</h4><p>可靠性原则是所有选择设备和系统中首要考虑的，尤其是在大型的、有大量处理要求的、需要长期运行的系统上。考虑服务器系统的可靠性，不仅要考虑服务器单个节点的可靠性或稳定性，而且要考虑服务器与相关辅助系统之间连接的整体可靠性，如：网络系统、安全系统、远程打印系统等。在必要时，还应考虑对关键服务器采用集群技术，如：双机热备份或集群并行访问技术，甚至采用可能的完全容错机。</p>
<p><strong>结论：</strong>服务器要具备冗余技术，同时像硬盘、网卡、内存、电源此类设备要以稳定耐用为主，性能其次。</p>
<h4 id="3-可扩展性原则"><a href="#3-可扩展性原则" class="headerlink" title="3)可扩展性原则"></a>3)可扩展性原则</h4><p>保证所选购的服务器具有优秀的可扩展性原则。因为服务器是所有系统处理的核心，要求具有大数据吞吐速率，包括：I/O速率和网络通讯速率，而且服务器需要能够处理一定时期的业务发展所带来的数据量，需要服务器能够在相应时间对其自身根据业务发展的需要进行相应的升级，如：CPU型号升级、内存扩大、硬盘扩大、更换网卡、增加终端数目、挂接磁盘阵列或与其他服务器组成对集中数据的并发访问的集群系统等。这都需要所选购的服务器在整体上具有一个良好的可扩充余地。一般数据库和计费应用服务器在大型计费系统的设计中就会采用集群方式来增加可靠性，其中挂接的磁盘存储系统，根据数据量和投资考虑，可以采用DAS、NAS或SAN等实现技术。</p>
<p><strong>结论：</strong>服务器的IO要高，否则在CPU和内存都是高性能的情况下，会出现瓶颈。除此之外，服务器的扩展性要好，为的是满足企业在日后发展的需要。</p>
<h4 id="4-安全性原则"><a href="#4-安全性原则" class="headerlink" title="4)安全性原则"></a>4)安全性原则</h4><p>服务器处理的大都是相关系统的核心数据，其上存放和运行着关键的交易和重要的数据。这些交易和数据对于拥有者来说是一笔重要的资产，他们的安全性就非常敏感。服务器的安全性与系统的整体安全性密不可分，如：网络系统的安全、数据加密、密码体制等。服务器需要在其自身，包括软硬件，都应该从安全的角度上设计考虑，在借助于外界的安全设施保障下，更要保证本身的高安全性。</p>
<p><strong>结论：</strong>首先从服务器的材料上来说要具备高硬度高防护性等条件，其次服务器的冷却系统和对环境的适应能力要强，这样才能够在硬件上满足服务器安全的要求。</p>
<h4 id="5-可管理性原则"><a href="#5-可管理性原则" class="headerlink" title="5)可管理性原则"></a>5)可管理性原则</h4><p>服务器既是核心又是系统整体中的一个节点部分，就像网络系统需要进行管理维护一样，也需要对服务器进行有效的管理。这需要服务器的软硬件对标准的管理系统支持，尤其是其上的操作系统，也包括一些重要的系统部件。</p>
<p><strong>结论：</strong>尽量选择支持系统多的服务器，因为服务器兼容的系统越多，你就可以拥有更大选择空间。</p>
<p><strong>总结：</strong>首先数据库服务器的性能要求很高，所以在CPU，内存，以及硬盘等方面都有很高的要求，其次是存储，存储要具备良好的稳定性，来满足长期运作的服务器随时读取写入等操作不会出现错误。最后希望通过总结的以上五点，帮助你挑选你所需要的数据库服务器。</p>
<h3 id="服务器产品结构"><a href="#服务器产品结构" class="headerlink" title="服务器产品结构"></a>服务器产品结构</h3><p>U是厚度要求，是一种表示服务器外部尺寸的单位，是unit的缩略语，详细的尺寸由作为业界团体的美国电子工业协会（EIA）所决定。 <code>1U=4.445cm</code> ， 1U至7U的产品结构是指外形满足EIA规格、厚度为4.445cm-31.115cm的服务器。</p>
<p>多少U是指服务器的尺寸大小。在专业机房，托管的服务器一般是放在机柜里面的，机柜从上到下有很多单位格，我们叫一格为1U(U是unit的意思)。如果一个机柜是42U高，如果每2个服务器中间留1U空间，那么可以放21个1U的主机。同样情况放2U主机就只能放14台了。</p>
<p>很多机房托管费用会按所占U的多少来收费的。</p>
<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>NAT（Network Address Translation，网络地址转换）是1994年提出的。</p>
<p>当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。<br>这种方法需要在专用网（私网IP）连接到因特网（公网IP）的路由器上 <mark>安装NAT软件</mark> 。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址（公网IP地址）。</p>
<p>这样，所有使用本地地址（私网IP地址）的主机在和外界通信时，都要在 <strong>NAT路由器</strong> 上将其本地地址转换成全球IP地址，才能和因特网连接。<br>另外，这种通过使用少量的全球IP地址（公网IP地址）代表较多的私有IP地址的方式，将有助于减缓可用的IP地址空间的枯竭。在RFC 2663中有对NAT的说明。</p>
<p><strong>举例</strong>：</p>
<blockquote>
<p>在内网下 <code>192.168.0.100</code> 这台电脑上开了一个http网站服务，那么端口默认是 <code>80</code>，在内网下你直接通过浏览器输入 <code>http://192.168.0.100</code> 直接打开网站，这个内网链接地址在外是打不开的。<br>通过内网穿透后平台 <strong>分配</strong> 一个公网地址（给内网的设备）,比如 <code>http://test123k.nat.nsloop.com</code> 用户在外时就可以通过这个公网地址打开网站。</p>
</blockquote>
<p>要使用内网穿透服务，需要先确定好 <mark>内网要映射的IP和端口</mark> ，穿透成功后内网的IP+端口，映射成为公网的域名+端口（如需要IP，可以在CMD命令下PING 服务器的IP地址）<br>穿透前: 访问IP地址 <code>192.168.0.100</code> 端口 <code>3389</code> 穿透后：访问地址 <code>s0.nsloop.com</code> 端口 <code>12843</code> 。</p>
<p>内网穿透是通过服务器中继转发数据来实现的将内网端口映射到公网，速度上没有P2P直连的快。</p>
<h3 id="异地组网"><a href="#异地组网" class="headerlink" title="异地组网"></a>异地组网</h3><h3 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h3><p>内网穿透（Intranet penetration），也即 NAT 穿透，进行 NAT 穿透是为了使具有某一个特定源 IP 地址和源端口号的数据包 <mark>不被 NAT 设备屏蔽而正确路由到内网主机</mark> 。</p>
<p>UDP 内网穿透的实质是利用路由器上的NAT 系统。NAT 是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型 Internet 接入方式和各种类型的网络中。<mark>NAT可以完成重用地址，并且对于内部的网络结构可以实现对外隐蔽</mark>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/19/Signal/MIC%20LEVEL%20vs%20LINE%20LEVEL%20Audio%20Levels%20Explained/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/19/Signal/MIC%20LEVEL%20vs%20LINE%20LEVEL%20Audio%20Levels%20Explained/" class="post-title-link" itemprop="url">MIC LEVEL vs LINE LEVEL--Audio Levels Explained</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-19 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-19T23:58:32+08:00">2021-04-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-29 00:54:07" itemprop="dateModified" datetime="2021-04-29T00:54:07+08:00">2021-04-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Signal/" itemprop="url" rel="index"><span itemprop="name">Signal</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://audiouniversityonline.com/mic-level-vs-line-level-audio-levels-explained/">audiouniversityonline.com</a></p>
<p>In this post, you’ll learn the difference between microphone level  and line level, as well as other levels commonly used in professional  audio such as instrument level and speaker level.</p>
<p>What is the difference between microphone level and line level?</p>
<p><strong>Microphones and instruments output very low signal voltages,  while +4dBu is the line level is the standard voltage level for  professional audio equipment.</strong></p>
<p><strong>In pro audio, you’ll generally be dealing with four types of  audio signals: Mic Level, Instrument Level, Line Level, and Speaker  Level</strong></p>
<h1 id="Microphone-Level"><a href="#Microphone-Level" class="headerlink" title="Microphone Level"></a>Microphone Level</h1><p>A microphone captures sound by converting pressure changes in the air into electrical currents in a wire. The electrical currents created by  these pressure changes are very subtle. That’s why we use a microphone  preamp – to amplify the signal to a more usable level.</p>
<p>A microphone preamp takes in a mic level signal, amplifies it, and  outputs a line level signal. This is controlled by the gain knob on your mixing console, audio interface, or outboard mic pre.</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Mic-Level-Chart-900.jpg" alt="img" style="zoom:50%;" />

<h1 id="Instrument-Level"><a href="#Instrument-Level" class="headerlink" title="Instrument Level"></a>Instrument Level</h1><p>The pickups of an electric guitar convert the vibrations of the  strings into electrical currents. Similar to those from a microphone,  the electrical currents from a guitar pickup are very weak.</p>
<p>A preamp can also be used to boost instrument level signals to line level.</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Instrument-Level-Chart-900.jpg" alt="img" style="zoom: 50%;" />

<p>Once an input signal is brought up to line level, it is optimized for use with professional audio equipment, such as mixing consoles,  outboard effects, and amplifiers.</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Line-Level-Chart-900.jpg" alt="img" style="zoom:50%;" />

<h1 id="Professional-vs-Consumer-Line-Level"><a href="#Professional-vs-Consumer-Line-Level" class="headerlink" title="Professional vs Consumer Line Level"></a>Professional vs Consumer Line Level</h1><p>There are two standards for line level: +4 dBu (professional) and -10 dBV (consumer).</p>
<p>Watch this video to learn the difference between professional and consumer line level. I also wrote a post on <a target="_blank" rel="noopener" href="https://audiouniversityonline.com/consumer-vs-professional-audio-levels-what-is-the-difference/">professional vs consumer audio levels</a> that will help you understand the difference.</p>
<h1 id="Speaker-Level"><a href="#Speaker-Level" class="headerlink" title="Speaker Level"></a>Speaker Level</h1><p>Line level is adequate for sending signals between devices, but not  strong enough to power a speaker.In order to power a speaker, the line  level signal needs to be amplified again. </p>
<p>This can be done with a power amplifier. A power amp takes in a line  level signal, amplifies it, and outputs a speaker level signal that is  strong enough to power a speaker.</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Speaker-Level-Chart-900.jpg" alt="img" style="zoom:50%;" />

<h1 id="A-Complete-Audio-System"><a href="#A-Complete-Audio-System" class="headerlink" title="A Complete Audio System"></a>A Complete Audio System</h1><p>In a complete system, you might run a microphone through a preamp and an electric guitar through another preamp.</p>
<p>Once those signals are at line level, you can send them through  outboard effects and eventually to an amplifier, which will add enough  gain to the signal to power a speaker.</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Complete-Chart-900.jpg" alt="img" style="zoom:50%;" />




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/11/Web/JavaScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/11/Web/JavaScript/" class="post-title-link" itemprop="url">Javascript</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-11 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-11T23:58:32+08:00">2021-04-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-26 00:13:21" itemprop="dateModified" datetime="2021-04-26T00:13:21+08:00">2021-04-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Networking/" itemprop="url" rel="index"><span itemprop="name">Networking</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="对象的抽象"><a href="#对象的抽象" class="headerlink" title="对象的抽象"></a>对象的抽象</h2><p><strong>抽象</strong> 是指一种归纳或总结，<strong>对象</strong> 是现实世界物体特征的实体。万事万物不论大小皆可看做对象， <strong>类</strong> 则是对各种不同对象的 <em>归纳总结</em>，类是对象的 <em>抽象表示形式</em>。</p>
<blockquote>
<p>例如，男演员Jack可以看做是一个对象，女演员Rose也可以看过是一个对象，而两者会被统一归纳为Person或者Human的类（或抽象）。每一个对象都有其独特的属性（Property）或功能（Function），而归纳总结出来的类则具有不同对象的相同属性或功能。</p>
</blockquote>
<p>基于类的面向对象语言是面向对象世界里的主流。虽然大多数面向对象开发语言都使用类来完成面向对象编程，但类不是面向对象编程的实质内涵。面向对象的实质内涵是将所有业务逻辑单元都视为一个对象（即，对象是目的或结果），且类不是唯一用来完成面向对象编程的方法。</p>
<p>面向对象不能被当做面向类，否则会进入误区。对象和类的关系相当于一般程序设计语言中的 <strong>变量</strong> 和 <strong>变量类型</strong> 的关系。所以，有时类也被称为是一种数据类型，可以看做抽象数据类型的具体实现。此时的数据类型则是 **数据 **和 <strong>操作</strong> 的集合。</p>
<h2 id="面向对象与面向过程的区别"><a href="#面向对象与面向过程的区别" class="headerlink" title="面向对象与面向过程的区别"></a>面向对象与面向过程的区别</h2><p>面向过程程序设计，即结构化程序设计，诸如Pascal、C。</p>
<p>面向对象程序设计解决了结构化程序设计代码复用的难题，如C++、C#、Java、JavaScript、Python等都是。</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210413144641711.png" alt="image-20210413144641711" style="zoom: 67%;" />

<p>面向过程也是把程序定义为“数据+作用于数据的操作算法”，但最重要的区别是：面向过程编程 <mark>使用过程操作数据结构</mark>， 而面向对象编程将过程和数据结构捆绑，使对象 <mark>操作自己的数据结构</mark>。</p>
<h1 id="JavaScript的类"><a href="#JavaScript的类" class="headerlink" title="JavaScript的类"></a>JavaScript的类</h1><h2 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h2><p>JavaScript可以用关键字 <code>class</code> 进行赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一：参数赋值法，间接调用构造器赋值</span></span><br><span class="line"><span class="keyword">var</span> oRectangle = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：生成对象后单独调用赋值</span></span><br><span class="line"><span class="comment">// var oRectangle = new Rectangle();</span></span><br><span class="line"><span class="comment">// oRectangle.height = 10;</span></span><br><span class="line"><span class="comment">// oRectangle.width = 30;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(oRectangle.height, oRectangle.width)</span><br></pre></td></tr></table></figure>



<p>在MDN Web Docs中，对JavaScript类的定义如下：</p>
<blockquote>
<p>实际上，类是“特殊的函数”，就像你能够定义的函数表达式和函数声明一样，类语法有两个组成部分：**类表达式 **和 <strong>类声明</strong>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloWrold</span>(<span class="params"></span>)</span>&#123;    <span class="comment">//To use keyword `function` instead of `class` to define a class</span></span><br><span class="line">    <span class="built_in">this</span>.printInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hi! JavaScript!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> oHelloWorld = <span class="keyword">new</span> HelloWorld();    <span class="comment">// Make a new object of the class named `HelloWorld`</span></span><br><span class="line"><span class="keyword">var</span> result = oHelloWorld.printInfo();    <span class="comment">//Call the method of the object to assign</span></span><br><span class="line"><span class="built_in">document</span>.write(result);</span><br></pre></td></tr></table></figure>



<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p><strong>构造器（Constructor）</strong>，或称 <strong>构造方法</strong>，一种用于创建和初始化<code>class</code>创建的对象的特殊 <strong>方法（Methods）</strong>。<code>constructor([arguments]) &#123; ... &#125;</code>， 其中 <code>arguments</code> 看情况而定，可以省略。</p>
<p><strong>注意</strong>：</p>
<ol>
<li>在一个类中只能有一个名为 <code>constructor</code> 的特殊方法。 一个类中出现多次构造函数 (constructor)方法将会抛出一个 <code>SyntaxError</code> 错误。</li>
<li>在一个构造方法中可以使用 <code>super</code> 关键字来 <mark>调用一个父类的构造方法</mark>。</li>
<li>如果没有显式指定构造方法，则会添加默认的 constructor 方法。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">arg0, arg1</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Polygon&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.body = arg0 + arg1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> poly1 = <span class="keyword">new</span> Polygon(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(poly1.name, poly1.body);</span><br><span class="line"><span class="comment">// expected output: &quot;Polygon&quot; 30</span></span><br></pre></td></tr></table></figure>










      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备19004822号 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liewzheng</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
