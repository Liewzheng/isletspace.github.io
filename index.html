<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;islet.space&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script>
<meta name="description" content="笔记分享的旮旯孤岛而已">
<meta property="og:type" content="website">
<meta property="og:title" content="Coder的孤岛">
<meta property="og:url" content="http://islet.space/index.html">
<meta property="og:site_name" content="Coder的孤岛">
<meta property="og:description" content="笔记分享的旮旯孤岛而已">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liewzheng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://islet.space/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;en&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Coder的孤岛</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Coder的孤岛</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">islet of the coder</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-首页"><a href="https://islet.space/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-文章"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>文章</a></li>
        <li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-目录"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-zplusplus"><a href="https://zplusplus.cn/" rel="noopener" target="_blank"><i class="fa fa-user fa-fw"></i>ZPLUSPLUS</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liewzheng</p>
  <div class="site-description" itemprop="description">笔记分享的旮旯孤岛而已</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">82</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">155</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="mailto:liewzheng@qq.com" title="E-Mail → mailto:liewzheng@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/08/06/Blog/2021-08-06-%E8%A7%A3%E5%86%B3%E6%96%B0%E7%89%88hexo%E6%B2%A1%E6%9C%89%E7%9B%AE%E5%BD%95%E5%92%8C%E6%A0%87%E7%AD%BE%E9%A1%B5%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/06/Blog/2021-08-06-%E8%A7%A3%E5%86%B3%E6%96%B0%E7%89%88hexo%E6%B2%A1%E6%9C%89%E7%9B%AE%E5%BD%95%E5%92%8C%E6%A0%87%E7%AD%BE%E9%A1%B5%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">解决新版hexo没有目录和标签页的问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-08-06 23:40:00 / Modified: 23:59:25" itemprop="dateCreated datePublished" datetime="2021-08-06T23:40:00+08:00">2021-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>新版hexo安装之后没有标签页，解决方法大致三步：</p>
<ol>
<li><p>需要自行在 <code>/source/</code> 文件夹下添加一个 <code>categories</code> 和 <code>tags</code> 文件夹，然后往文件夹中分别写入一个 <code>index.md</code> 文件。</p>
</li>
<li><p>然后在对应的 <code>index.md</code> 中写入 <em>YAML</em> 信息。</p>
</li>
<li><p>在对应的主题配置文件，例如 <code>_config.yml</code> 中填写好配置。</p>
</li>
</ol>
<h1 id="新建目录和页面"><a href="#新建目录和页面" class="headerlink" title="新建目录和页面"></a>新建目录和页面</h1><p>可以通过两句语句来运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line">hexo new page tags</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加type属性</span></span><br><span class="line"></span><br><span class="line">编辑 `index.md`，修改信息如下，日期随意：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">---</span><br><span class="line">title: 目录</span><br><span class="line"><span class="built_in">type</span>: categories</span><br><span class="line">date: 2020-08-06 23:32:00</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>注意上面写的一个属性 <code>type</code>，千万不能写错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line"><span class="built_in">type</span>: tags</span><br><span class="line">date: 2020-08-06 23:32:00</span><br><span class="line">---</span><br></pre></td></tr></table></figure>



<h1 id="设置配置文件"><a href="#设置配置文件" class="headerlink" title="设置配置文件"></a>设置配置文件</h1><p>如下图所示修改即可：</p>
<p><img src="https://pic.islet.space/2021/08/image-20210806235851123.png" alt="image-20210806235851123"></p>
<p>最后重新清空、运行和预览即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo site</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/17/Hardware/Circuit/2021-07-17-%E7%94%B5%E9%9A%94%E7%A6%BB%E5%92%8C%E9%9D%9E%E7%94%B5%E9%9A%94%E7%A6%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/17/Hardware/Circuit/2021-07-17-%E7%94%B5%E9%9A%94%E7%A6%BB%E5%92%8C%E9%9D%9E%E7%94%B5%E9%9A%94%E7%A6%BB/" class="post-title-link" itemprop="url">电隔离和非电隔离</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-07-17 10:40:00 / Modified: 11:42:40" itemprop="dateCreated datePublished" datetime="2021-07-17T10:40:00+08:00">2021-07-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hardware/" itemprop="url" rel="index"><span itemprop="name">Hardware</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在产品设计时，倘若没有考虑应用环境对电源隔离的要求，产品到了应用时就会出现因设计方案的不当导致的系统不稳定，甚至出现高压损坏后级负载的情况，以及出现危害人身财产安全的情况。因此产品设计是否需要隔离至关重要。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>隔离电源</strong>：电源的输入回路和输出回路之间没有直接的电气连接，输入和输出之间是绝缘的高阻态，没有电流回路。</p>
<img src="https://pic.islet.space/2021/07/60935d50373e5-thumb.png" alt="img" style="zoom:67%;" />

<div style="text-align: center; font-weight: 900;">图1 采用变压器的隔离电源</div>



<p><strong>非隔离电源</strong>：输入和输出之间有直接的电流回路，例如，输入和输出之间是共地的。以隔离的反激电路和非隔离的BUCK电路为例。</p>
<img src="https://pic.islet.space/2021/07/60935d4fef66f-thumb.png" alt="img" style="zoom:67%;" />

<div style="text-align: center; font-weight: 900;">图2 非隔离电源</div>



<img src="https://pic.islet.space/2021/07/60935d5048313-thumb.png" alt="img" style="zoom:50%;" />



<h1 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h1><p>由上述概念可知，对于常用的电源拓扑而言，非隔离电源主要有：<em><strong>Buck</strong></em>、<em><strong>Boost</strong></em>、<em><strong>Buck-Boost</strong></em>等。而隔离电源主要有各种带隔离变压器的 <em><strong>反激</strong></em>、<em><strong>正激</strong></em>、<em><strong>半桥</strong></em>、<em><strong>LLC</strong></em> 等拓扑。</p>
<p>结合常用的隔离与非隔离电源，我们从直观上就可得出它们的一些优缺点，两者的优缺点几乎是相反的。使用隔离或非隔离的电源，需了解实际项目对电源的需求是怎样的。</p>
<p>隔离和非隔离电源的主要差别在于 隔离模块的可靠性高，但成本高，效率差点。非隔离模块的结构很简单，成本低，效率高，安全性能差。因此，在如下几个场合，建议用隔离电源：</p>
<ol>
<li></li>
</ol>
<p>总结的表如表1所示，两者的优缺点几乎是相反的。</p>
<div style="text-align: center; font-weight: 900;">表1 隔离电源和非隔离电源的优缺点</div>

<img src="https://pic.islet.space/2021/07/60935d504e874-thumb.png" alt="img" style="zoom:80%;" />



<h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>一般场合使用对模块电源隔离电压要求不是很高，但是 <mark> 更高的隔离电压可以保证模块电源具有更小的漏电流，更高的安全性和可靠性，并且 <em><strong>EMC特性</strong></em> 也更好一些</mark>，因此目前业界普遍的隔离电压水平为1500VDC以上。</p>
<p>了解了隔离与非隔离电源的优缺点，对于一些常用的嵌入式供电，其对应的场景及推荐隔离方案如下：</p>
<ol>
<li>系统前级的电源，为提高抗干扰性能，保证可靠性，一般用隔离电源。</li>
<li>对安全有要求的场合，如需接市电的AC-DC，或医疗用的电源和白色家电，为保证人身的安全，必须用隔离电源，有些场合还必须用加强隔离的电源。</li>
<li>对于远程工业通信的供电，为有效降低地电势差和导线耦合干扰的影响，为每个通信节点单独供电一般都用隔离电源。</li>
<li>内部IC或部分电路供电，从性价比和体积出发，优先选用非隔离电源。</li>
<li>对于采用电池供电，<mark>对续航力要求严苛的场合，采用非隔离供电</mark>。</li>
</ol>
<h3 id="隔离电源"><a href="#隔离电源" class="headerlink" title="隔离电源"></a>隔离电源</h3><ol>
<li><p>涉及可能触电的场合，如从电网取电，转成低压直流的场合，需用隔离的AC-DC电源；</p>
</li>
<li><p>串行通信总线通过RS-232、RS-485和控制器局域网(CAN)等物理网络传送数据，这些相互连接的系统每个都配备有自己的电源，而且各系统之间往往间隔较远，因此，我们通常需要隔离电源进行电气隔离来确保系统的物理安全，且通过隔离 <mark style="font-style: Italic; font-weight: 900;">切断接地回路</mark>，来保护系统免受瞬态高电压冲击，同时减少信号失真；</p>
</li>
<li><p>对外的I/O端口，为保证系统的可靠运行，也建议对I/O端口做电源隔离。</p>
</li>
</ol>
<h3 id="非隔离电源"><a href="#非隔离电源" class="headerlink" title="非隔离电源"></a>非隔离电源</h3><p>电路板内的IC或部分电路供电，从性价比和体积出发，优先选用非隔离的方案；如MPS的MP150/157/MP174系列buck型非隔离AC-DC，适合于1~5W应用；</p>
<p>对于工作电压低于36V，采用电池供电，对续航力要求严苛的场合，优先采用非隔离供电，如MPS的MP2451/MPQ2451。</p>
<h1 id="隔离电源模块选型的注意事项"><a href="#隔离电源模块选型的注意事项" class="headerlink" title="隔离电源模块选型的注意事项"></a>隔离电源模块选型的注意事项</h1><p>电源的隔离耐压在GB-4943国标中又叫抗电强度，这个GB-4943标准就是我们常说的信息类设备的安全标准，就是为了防止人员受到物理和电气伤害的国家标准，其中包括避免人受到电击伤害、物理伤害、爆炸等伤害。如下图为隔离电源结构图。</p>
<img src="https://pic.islet.space/2021/07/60935d4fe8f0d-thumb.png" alt="img" style="zoom:120%;" />

<div style="text-align: center; font-weight: 900;">图 隔离电源结构</div>

<p>作为模块电源的重要指标，标准中也规定了隔离耐压相关测试方法，简单的测试时一般采用等电位连接测试，连接示意图如下：</p>
<p><img src="https://pic.islet.space/2021/07/60935d4fc9c96-thumb.png" alt="img"></p>
<div style="text-align: center; font-weight: 900;">图 隔离耐压测试示意</div>



<h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><ol>
<li><p>将耐压计的电压设为规定的耐压值，电流设为规定的漏电流值，时间设为规定的测试时间值；</p>
</li>
<li><p>操作耐压计开始测试，开始加压，在规定的测试时间内，模块应无击穿，无飞弧现象。</p>
</li>
<li><p>注意在测试时焊接电源模块要选取合适的温度，避免反复焊接，损坏电源模块。</p>
</li>
<li><p>除此之外还要注意：</p>
<ol>
<li>要注意是AC-DC还是DC-DC。</li>
<li>隔离电源模块的隔离耐压。例如隔离1000V DC 是否满足绝缘要求。</li>
<li>隔离电源模块是否有进行全面的可靠性测试。电源模块要经过性能测试、容差测试、瞬态条件测试、可靠性测试、EMC电磁兼容测试、高低温测试、极限测试、寿命测试、安规测试等。</li>
<li>隔离电源模块的生产工厂产线是否规范。电源模块生产线需要通过ISO9001, ISO14001，OHSAS18001等多项国际认证，如下图3所示。</li>
<li>隔离电源模块是否有应用在工业、汽车等恶劣环境。电源模块不仅仅大量应用与恶劣的工业环境，同时在新能源汽车的BMS管理系统中也游刃有余。</li>
</ol>
</li>
</ol>
<p><img src="https://pic.islet.space/2021/07/60935d503580c-thumb.png" alt="img"></p>
<div style="text-align: center; font-weight: 900;">图 ISO认证</div>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>很多人认为非隔离电源不如隔离电源好，因为隔离电源贵，所以肯定贵的就好。前几年非隔离的稳定性确实没有隔离稳定，但随着研发技术的更新，现如今非隔离已经非常成熟，日渐稳定。说到安全性，其实现在非隔离电源也是很安全的，只要在结构稍微做下改动，对人体还是很安全的，同样的道理，非隔离电源也是可以过很多安规标准，例如:ULTUVSAACE等。</p>
<p>实际上非隔离电源损坏的根源就是电源AC线两端的浪涌电压所致，也可以这么说，雷击浪涌吧，这种电压是加在电压AC线两端的瞬间高压，有时高达三千伏，但时间很短，能量却极强，在打雷时会发生，或是在同一条AC线上，当一个大的负载断开瞬间，因为电流惯性的原因也会发生，这个电压进入电源，对于非隔离BUCK电路，会瞬间传达到输出，击坏恒流检测环，或是进一步击坏芯片，造成300v直通，而烧掉整条灯管。对于隔离反激电源，会击坏MOS,现象就是保管，芯片，MOS管全烧坏。现在LED驱动电源，在使用过程中坏的，80%以上都是这两种类似现象。而且，小型开关电源，就算是电源适配器，也经常损坏的是这个现象，均是浪涌电压所致，而在LED电源里，表现的更加普遍，这是因为LED的负载特性是特别的怕浪涌电压的。</p>
<p>如果按照一般的理论来讲，电子电路里，元器件越少，可靠性越高，相应越多的元件的电路板可靠性则越低。实际上非隔离电路的元件是比隔离电路要少的，为什么隔离电路可靠性高。其实说白了，不是什么可靠性，而是 <mark>非隔离电路对于浪涌太敏感，抑制能力差</mark>，隔离电路，因为能量是先进入变压器，然后从变压器再输送到LED负载的。BUCK电路是输入电源一部分直接加在了LED负载上，故前者对浪涌抑制和衰减能力强，所以浪涌来时损坏的机率小而已。实际上，非隔离电源的问题主要是在于浪涌问题，目前这个问题，因为只有LED灯具在大批量应用时，从概率上才能看出其解决的程度，所以很多人没有提出好的防治办法，更多的人则是不知道浪涌电压为何物。LED灯具坏了，很多人也找不到原因，最后只能一句，什么此电源不稳定就了结了，具体哪里不稳定，他不知道。</p>
<p>非隔离电源的优势一是效率，二是成本。</p>
<p>非隔离电源适合的场合：首先，是室内的灯具，这种室内用电环境较好，浪涌影响小。第二，使用的场合是高压小电流，低压大电流用非隔离没有意义，因为低压大电流非隔离的效率并不比隔离的高，成本也低不到多少去。第三，电压相对较稳定的环境中使用非隔离电源。当然，如果有办法解决掉抑制浪涌的问题，那么非隔离电源的应用范围将大大拓宽！</p>
<p>隔离电源因为浪涌的问题，损坏率也不可小觑，一般那种返修回来，击坏保险，芯片，MOS的第一个应该想到是浪涌问题。为了减少损坏率，在设计时就行要考虑到浪涌的因素进去，或是在使用时要告戒用户，尽量避免浪涌发生。（如室内灯具，打雷时暂时先关掉）</p>
<p>综合所述，使用隔离与非隔离很多时候都是因为浪涌这个问题，而浪涌问题和用电环境是息息相关的，所以很多时候使用隔离电源和非隔离电源不能一刀切，非隔离电源在节能，成本上都是很有优势的，所以要科学的选用非隔离还是隔离作为LED驱动电源。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/15/Hardware/Circuit/2021-07-15-IGBT%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8%E8%8A%AF%E7%89%87%E8%A7%84%E6%A0%BC%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/15/Hardware/Circuit/2021-07-15-IGBT%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8%E8%8A%AF%E7%89%87%E8%A7%84%E6%A0%BC%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">IGBT及其驱动芯片规格学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-15 08:50:00" itemprop="dateCreated datePublished" datetime="2021-07-15T08:50:00+08:00">2021-07-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-07-17 14:13:02" itemprop="dateModified" datetime="2021-07-17T14:13:02+08:00">2021-07-17</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hardware/" itemprop="url" rel="index"><span itemprop="name">Hardware</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[TOC]</p>
<p>IGBT和其驱动芯片的电气特性、引脚等参数的开发记录。</p>
<h1 id="IGBT"><a href="#IGBT" class="headerlink" title="IGBT"></a>IGBT</h1><p>IGBT芯片选型为 IKW50N65WR5。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210715090401339.png" alt="image-20210715090401339"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210715093221500.png" alt="image-20210715093221500"></p>
<p>IGBT有三个极，发射极、集电极 和 栅极。</p>
<p>从其电气性能表格中，可以看出：</p>
<ul>
<li>集电极到发射极的击穿电压 <em>最小</em> 为650V</li>
<li>在 V<span style="font-size: 0.8rem; font-weight: 500;">GE</span> 完全导通（最高15V）时，集电极到发射极的饱和电压为1.8V以下，此时 IGBT 处于截止状态</li>
<li>在 V<span style="font-size: 0.8rem; font-weight: 500;">GE</span> 完全截止（0V）时，二极管的正向电压为1.9V以下。<mark> 此时，V<span style="font-size: 0.8rem; font-weight: 500;">CE</span> 处于导通状态。</mark></li>
</ul>
<p><img src="https://pic.islet.space/2021/07/image-20210715094151439.png" alt="image-20210715094151439"></p>
<p>从上方表中可以看出，在官方的《开关特性测试情况》下，V<span style="font-size: 0.8rem; font-weight: 500;">GE</span> 的通电情况是 0V 或者 15V，故此推断给此IGBT的栅极电源输入信号应该是0V ~ 15V的方波。</p>
<p>因此，下图中IGBT器件的电路连接方式为：G 接0/15V方波信号，C 接最高650V电源，E 接地。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210715095656309.png" alt="image-20210715095656309"></p>
<h1 id="DRIVER-IC"><a href="#DRIVER-IC" class="headerlink" title="DRIVER IC"></a>DRIVER IC</h1><p>选用芯片型号为 2EDL05I06PF。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210715102359830.png" alt="image-20210715102359830"></p>
<p>根据表1索引可得，芯片封装类型为DSO-8，目标驱动芯片是 IGBT，而非 MOSFET。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210715102251417.png" alt="image-20210715102251417"></p>
<p>再根据图3可得芯片引脚分布，根据表2可得所有引脚描述。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210715095931941.png" alt="image-20210715095931941"></p>
<p>结合表2和图3，再根据图1的典型应用电路，可以大致知道芯片的连接方法。</p>
<table>
<thead>
<tr>
<th>针脚</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>VDD</td>
<td>芯片供电接口</td>
</tr>
<tr>
<td>GND</td>
<td>芯片接地接口</td>
</tr>
<tr>
<td>HIN</td>
<td>调制波形输入接口——高位</td>
</tr>
<tr>
<td>LIN</td>
<td>调制波形输入接口——低位</td>
</tr>
<tr>
<td>VB</td>
<td>高位正电</td>
</tr>
<tr>
<td>HO</td>
<td>控制高位IGBT栅极的信号输出接口</td>
</tr>
<tr>
<td>VS</td>
<td>高位负电</td>
</tr>
<tr>
<td>LO</td>
<td>控制低位IGBT栅极的信号输出接口</td>
</tr>
</tbody></table>
<blockquote>
<p>还是不太明白VB和VS的作用</p>
</blockquote>
<p>表4给出了 V<span style="font-size: 0.8rem; font-weight: 500;">DD</span> 和 V<span style="font-size: 0.8rem; font-weight: 500;">B</span> 的供电范围：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210715105358524.png" alt="image-20210715105358524"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210715105816397.png" alt="image-20210715105816397"></p>
<p>表6 给出了输入 V<span style="font-size: 0.8rem; font-weight: 500;">IN</span> 的逻辑电平高低的电压范围，高电平为1.7 ~ 2.4 V， 低电平为0.7 ~ 1.1V。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210715103507327.png" alt="image-20210715103507327"></p>
<p>图2 提供了驱动芯片内部结构示意图</p>
<p>概括地说，IGBT栅极驱动器是一个放大器，其通过提高电压和电流来放大控制信号。</p>
<p>栅极驱动器的主要作用是对 <mark>IGBT的输入和反向输出电容放电</mark>。因此栅极驱动器（初其他影响因素外）与IGBT的开关性能密切相关，也与通态损耗与开关损耗有关。</p>
<p>绝大多数IGBT驱动器都是基于电压源的，与电流源驱动器相比，电压源的优势是其功率损耗在栅极电阻上，而非驱动中的电流源内。通过栅极电阻，可以调整最大的栅极电流。另一优势是，电压源相对简单的电路和控制方法。</p>
<h2 id="驱动功能"><a href="#驱动功能" class="headerlink" title="驱动功能"></a>驱动功能</h2><p>IGBT驱动电路为系统提供的功能：</p>
<ol>
<li>在IGBT开通过程中，栅极处的电容充电直到IGBT的开通阈值电压，反向传输电容（密勒电容）也如此。</li>
<li>在IGBT关断过程中，输入电容放电直到栅极电压达到关断阈值电压以下，反向传输电容（密勒电容）也如此。</li>
<li>IGBT驱动可以具有保护IGBT免受损坏的功能，如 <strong>避免IGBT短路</strong> 和 <strong>过电压保护</strong>。</li>
</ol>
<h2 id="驱动供电"><a href="#驱动供电" class="headerlink" title="驱动供电"></a>驱动供电</h2><p>大部分情况下，IGBT驱动需要用隔离的供电电源。隔离电源可以看做是IGBT驱动的一部分。这些电源一般由 <strong>DC-DC变换器</strong> 或 <strong>自举电路</strong> 构成。</p>
<p>同时，驱动会影响IGBT和续流二极管的动态特性，此外仍须确保IGBT输入电路电压（低压侧）和输出电路（高压侧）的电压隔离。<mark>低压侧与控制电路连接，高压侧与IGBT电路连接。</mark></p>
<h2 id="信号传输"><a href="#信号传输" class="headerlink" title="信号传输"></a>信号传输</h2><p>阿博说的电路PCB布局要点：强弱隔离，数模隔离，信号沿地。</p>
<p>IGBT需要隔离的控制信号 包括： <strong>开通信号</strong>、<strong>关断信号</strong>、<strong>反馈信号</strong>。</p>
<p>这些控制信号的传输路径的隔离是通过 <strong>电隔离</strong> 或 <strong>非电隔离</strong> 的方式形成的，这种电隔离被进一步划分为基于磁感应的、光学的隔离，极少情况下是电容性的隔离。需要通过 <em><strong>IGBT阻断电压</strong></em> 或 <em><strong>应用电压的高低</strong></em> 来判断组个方式，在 高压应用 或 IGBT阻隔电压 U<span style="font-size: 0.6rem;">CES</span> 高至 <code>1.2kV</code> 时，采用磁感应式 或 光学式信号传送器；在 低压 或 中压 应用中 或 低于 <code>1.2kV</code> 时，采用光电耦合驱动芯片。</p>
<img src="https://pic.islet.space/2021/07/image-20210717130119184.png" alt="image-20210717130119184" style="zoom:50%;" />

<div style="text-align: center; font-weight: 900;">图 Infineon对电气隔离的定义</div>

<p><img src="https://pic.islet.space/2021/07/image-20210717115141036.png" alt="image-20210717115141036"></p>
<h3 id="光电耦合器"><a href="#光电耦合器" class="headerlink" title="光电耦合器"></a>光电耦合器</h3><p>光电耦合器就是一种可以实现IGBT驱动的同时实现强弱电隔离的器件。由于光电耦合器的结构设计，集成光电耦合器的IGBT只能实现信息传递，不能为任何设备提供充足的能量支撑，需要一个隔离电源为驱动核心和光电耦合器的二次侧（高压侧）提供电能。</p>
<img src="https://pic.islet.space/2021/07/image-20210717113118307.png" alt="image-20210717113118307" style="zoom:80%;" />

<p>另外有个相当重要的参数需要考虑——<em><strong>传输延迟时间</strong></em>，即 信号从光电耦合器IGBT输入到控制电流输出的时间。常规而言，传播延迟时间 <em>t</em><span style="font-size: 0.6rem;">PLH</span> 和 <em>t</em><span style="font-size: 0.6rem;">PHL</span> 在几百个纳秒时间，但通常大于200ns。这种延时本身不会构成真正的问题，因为微控制器的控制算法可以考虑这一点，最大的问题在于 延时的公差（传输延迟时间不匹配），即最小和最大延时的不一致性。一旦该公差越大，上下桥臂的IGBT死区时间 <em>t</em><span style="font-size: 0.6rem;">DT</span> 就越大，加重了逆变器输出电流的失真影响。光电耦合器里信号延迟的误差因为操作使用会发生巨大变化，最终可导致高达1us的偏差。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210717114405335.png" alt="image-20210717114405335"></p>
<h3 id="脉冲变压器"><a href="#脉冲变压器" class="headerlink" title="脉冲变压器"></a>脉冲变压器</h3><p>利用脉冲变压器为信号传输的IGBT，可以达到较低的延时水平，但与光电耦合器一样，只能传输信号，提供所需能量仍需由隔离电源提供。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210717115333071.png" alt="image-20210717115333071"></p>
<h3 id="单片电平转换器"><a href="#单片电平转换器" class="headerlink" title="单片电平转换器"></a>单片电平转换器</h3><p><strong>单片电平转换器</strong>，即 仅通过一个集成电路来实现 输入信号 和 输出信号 之间的隔离。需要注意的是，并不想光耦、变压器、脉冲等技术的完全绝缘的电气隔离，如果出现差错（如输出侧寄生电感产生的负电压瞬变），电路高压侧和地压侧将会直接连在一起（导致内部集成芯片的损坏）。将 <em><strong>SOI（绝缘硅）技术</strong></em> 应用于电平转换器可以解决这一缺陷，Infineon的产品大多都应用这项技术。这样的SOI装置不是由PN结反向偏置来提供内部电路隔离的，而是通过一层绝缘层（通常是二氧化硅 SiO2）来为不同的内部电路提供隔离，其反向电压耐压高达较高（因产品而不同）。</p>
<p>单片电平转换器主要应用于 U<span style="font-size: 0.6rem;">CES</span> 低于 600V 的IGBT，通常一个驱动器有六路输出。但是在驱动 1.2kV 以上时，其驱动芯片和其他驱动方式相比成本劣势较少采用。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210717122123709.png" alt="image-20210717122123709"></p>
<div style="text-align: center; font-weight: 900;">图 带电平转换器的IGBT工作原理</div>



<h1 id="产品概念"><a href="#产品概念" class="headerlink" title="产品概念"></a>产品概念</h1><p>栅极驱动芯片 又可以称作 门极驱动芯片。按照门极驱动结构类型可以分为 <strong>单通道</strong>、<strong>双通道</strong>、<strong>四通道</strong> 和 <strong>六通道</strong>，又进一步划分 <strong>高边</strong>、<strong>地边</strong>、<strong>高低边</strong>、<strong>半桥</strong>、<strong>全桥</strong>、<strong>三相</strong>。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210717125203004.png" alt="image-20210717125203004"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210717125219691.png" alt="image-20210717125219691"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210717125337142.png" alt="image-20210717125337142"></p>
<h2 id="EiceDriver"><a href="#EiceDriver" class="headerlink" title="EiceDriver"></a>EiceDriver</h2><p>下图为Infineon提供的栅极驱动芯片品类示意：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210717120650887.png" alt="image-20210717120650887"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://storage.islet.space/01_Learning/12_Hardwares/03_Semiconductor/IGBT%E6%A8%A1%E5%9D%97%EF%BC%9A%E6%8A%80%E6%9C%AF%E9%A9%B1%E5%8A%A8%E5%92%8C%E5%BA%94%E7%94%A8.pdf">《IGBT模块：技术驱动和应用》</a></li>
<li><a target="_blank" rel="noopener" href="https://toshiba.semicon-storage.com/content/dam/toshiba-ss/shared/docs/design-support/document/Reference-design/application-note/MOSFET-Gate-Drive-Circuit-Application-Notes_EN_36267-CN.pdf">《MOSFET 栅极驱动电路》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infineon.com/dgdl/Infineon-Power_and_Sensing-ProductSelectionGuide-v00_01-EN.pdf?fileId=5546d4625607bd13015621522aa012cb&da=t">《Infineon-Power_and_Sensing-ProductSelectionGuide-v00_01-EN》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infineon.com/dgdl/Infineon-EiceDRIVER_Gate_Driver_ICs-ProductSelectionGuide-v01_01-CN.pdf?fileId=5546d46269e1c019016ab0ec653015cc">《Infineon-EiceDRIVER_Gate_Driver_ICs-ProductSelectionGuide-v01_01-CN》</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/14/Hardware/2021-07-14-Semiconductor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/14/Hardware/2021-07-14-Semiconductor/" class="post-title-link" itemprop="url">Semiconductor</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-14 20:30:00" itemprop="dateCreated datePublished" datetime="2021-07-14T20:30:00+08:00">2021-07-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-07-17 12:13:36" itemprop="dateModified" datetime="2021-07-17T12:13:36+08:00">2021-07-17</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Semiconductor/" itemprop="url" rel="index"><span itemprop="name">Semiconductor</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文章用于记录半导体（晶体管的工作原理等blablabla的知识）。</p>
<h1 id="半导体的定义"><a href="#半导体的定义" class="headerlink" title="半导体的定义"></a>半导体的定义</h1><p><strong>半导体</strong> 是指常温下导电性能介于导体与绝缘体之间的材料。 按照国际通行的半导体产品标准方式进行分类，半导体可以分为四类：<strong>集成电路</strong>（Integer Circuit），<strong>分立器件</strong>（Discrete Device），<strong>传感器</strong>（Sensor） 和 <strong>光电子器件</strong>（Optoelectronic Devices） ，统称为半导体元件。</p>
<p>分立器件按照功率转换进行分类，可以分为 <strong>功率器件</strong> 和 <strong>非功率器件</strong>，其中，<strong>传感器</strong> 和 <strong>光电器件</strong> 属于 分立器件下的 <strong>非功率器件</strong>，剩下的均是 <strong>功率器件</strong>，包含大部分晶体管，如 Zener Diode、BJT、IGFET、IGBT、Thyristor等。</p>
<p><strong>注意</strong>：功率器件的概念很大，不仅在分立器件中存在功率半导体，在IC中也存在功率半导体的产品。</p>
<h2 id="本征半导体"><a href="#本征半导体" class="headerlink" title="本征半导体"></a>本征半导体</h2><p><mark>导电性介于导体与绝缘体之间的物质</mark>称为 <strong>半导体</strong>。</p>
<p><strong>导体</strong>：如铁、铝、铜等金属元素等低价元素，其最外层电子在外电场作用下很容易产生定向移动，形成电流。</p>
<p><strong>绝缘体</strong>：如惰性气体、橡胶等，其原子的最外层电子受原子核的束缚力很强，只有在外电场强到一定程度时才可能导电。</p>
<p><strong>半导体</strong>：如硅（Si）、锗（Ge），均为四价元素，它们原子的最外层电子受原子核的束缚力介于导体与绝缘体之间。</p>
<p><strong>本征半导体</strong>：intrinsic semiconductor， 是 <strong>纯净</strong>（Purity）的 <strong>晶体结构</strong>（Crystal Texture）的 半导体；intrinsic 具有 “本质，固有” 之意。<strong>纯净</strong>，即无杂质之意；<strong>晶体结构</strong>，即稳定的结构。</p>
<h2 id="P-N型半导体"><a href="#P-N型半导体" class="headerlink" title="P/N型半导体"></a>P/N型半导体</h2><p>纯净的硅晶体不带电荷，不显示出任何导电特性。</p>
<p><strong>自由电子</strong>（Electron）：由于热运动，具有足够能量的价电子挣脱共价键的束缚而成为自由电子</p>
<p><strong>空穴</strong>（Hole）：自由电子的产生使共价键中留有一个空位置</p>
<p><strong>复合</strong>：自由电子与空穴相碰同时消失</p>
<p><strong>电荷</strong>：电子和空穴都是电荷，电子呈现负电荷，空穴呈现正电荷</p>
<p><strong>载流子</strong>（Carrier）：运载电荷的粒子称为载流子</p>
<p><strong>导电性</strong>：物体呈现出的传导电流的能力</p>
<p><strong>多数载流子</strong>：在纯净硅晶体中掺杂数量较多的电荷称为多数载流子。</p>
<p><strong>少数载流子</strong>：在纯净硅晶体中掺杂数量较少的电荷称为少数载流子。</p>
<p>外加电场时，带负电的自由电子和带正电的空穴均参与导电，且运动方向相反。由于载流子数目很少，故导电性很差。温度升高，热运动加剧，载流子浓度增大，导电性增强。热力学温度0K时不导电。</p>
<img src="https://pic.islet.space/2021/07/image-20210714204623205.png" alt="image-20210714204623205" style="zoom: 33%;" />

<div style="text-align: center; font-weight:900;">图 N型半导体结构</div>



<img src="https://pic.islet.space/2021/07/image-20210714204653816.png" alt="image-20210714204653816" style="zoom: 33%;" />

<div style="text-align: center; font-weight:900;">图 P型半导体结构</div>



<p>往纯净的硅晶体中掺杂一定浓度的 <strong>磷</strong>（P）或 <strong>硼</strong>（B）即可获得 使得硅晶半导体带上电子或空穴，即获得了 <strong>N型半导体</strong> 和 <strong>P型半导体</strong>。</p>
<p><strong>杂质半导体</strong>：在本征的基础上掺杂其他元素。</p>
<p><strong>P型半导体</strong>：掺杂了硼元素的硅晶体，空穴为多数载流子。</p>
<p><strong>N型半导体</strong>：掺杂了磷元素的硅晶体。自由电子为多数载流子。</p>
<h2 id="PN结"><a href="#PN结" class="headerlink" title="PN结"></a>PN结</h2><p><strong>结</strong>：即 Junction，在纯净硅晶体中掺杂两种不同电荷所形成的杂质接触截面。</p>
<p><strong>扩散运动</strong>：物质 <mark>因浓度差而产生</mark> 的运动。气体、液体、固体均有之。扩散运动使靠近接触面P区的空穴浓度降低、靠近接触面N区的自由电子浓度降低，产生内电场。</p>
<p><strong>漂移运动</strong>：因 <mark>电场作用</mark> 所产生的运动。</p>
<p><strong>动态平衡</strong>：结处因空穴和电子一刻不停地复合和分离（官方：参与扩散运动和漂移运动的载流子数目相同）而形成 “无多数载流子” 的状态。</p>
<blockquote>
<p><strong>注意</strong>：扩散运动和漂移运动是相反的， </p>
</blockquote>
<img src="https://pic.islet.space/2021/07/image-20210714210922380.png" alt="image-20210714210922380" style="zoom:50%;" />

<div style="text-align: center; font-weight:900;">图 扩散运动</div>



<img src="https://pic.islet.space/2021/07/image-20210714210942004.png" alt="image-20210714210942004" style="zoom:67%;" />

<div style="text-align: center; font-weight:900;">图 漂移运动</div>

<p><strong>耗尽层</strong>：PN结处，因动态平衡而达到的“无多数载流子”的状态，该结的大小称为耗尽层。</p>
<p>如果此时让P区的多数载流子，即空穴尽量往N区移动，让N区的多数载流子，即自由电子尽量往P区移动，则两种电荷进行复合，形成更宽的耗尽层，此时因为耗尽层因为没有多数载流子而呈现不导电特性。</p>
<p>反之，让P区的多数载流子尽量往P区靠拢，让N区的多数载流子尽量往N区靠拢（注意，这里用的是“靠拢”，因为中间已经有耗尽层的形成，此时的“靠拢”是让耗尽层中已经复合消失的电子和空穴重新拆开，分别往各自原来的反向回归。），耗尽层的宽度会逐渐缩小，显现出导电特性。</p>
<p><strong>正向</strong>：电源的正、负极分别对准半导体的P、N极进行连接。</p>
<p><strong>反向</strong>：电源的正、负极分别对准半导体的N、P极进行连接。</p>
<p><strong>正向导通</strong>：耗尽层变窄，扩散运动加剧，由于外电源的作用，形成扩散电流，PN结处于导通状态。</p>
<p><strong>反向截止</strong>：耗尽层变宽，阻止扩散运动，有利于漂移运动，形成漂移电流。由于电流很小，故可近似认为其截止。</p>
<img src="https://pic.islet.space/2021/07/image-20210714212136379.png" alt="image-20210714212136379" style="zoom:33%;" />

<div style="text-align: center; font-weight:900;">图 正向导通</div>



<img src="https://pic.islet.space/2021/07/image-20210714212143706.png" alt="image-20210714212143706" style="zoom:33%;" />

<div style="text-align: center; font-weight:900;">图 反向截止</div>



<h3 id="电容效应"><a href="#电容效应" class="headerlink" title="电容效应"></a>电容效应</h3><p><strong>势垒电容</strong>：PN结外加电压变化时，空间电荷区的宽度将发生变化，有电荷的积累和释放的过程，与电容的充放电相同，其等效电容称为势垒电容Cb。</p>
<p><strong>扩散电容</strong>：PN结外加的正向电压变化时，在扩散路程中载流子的浓度及其梯度均有变化，也有电荷的积累和释放的过程，其等效电容称为扩散电容Cd。</p>
<p><strong>结电容</strong>：等于 势垒电容 与 扩散电容 之和。但 <mark>结电容不是常量！</mark> 若PN结外加电压频率高到一定程度，则失去单向导电性！</p>
<h1 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h1><p>The diode is the most used semiconductor device in electronics circuits. <em><strong>It is a two-terminal electrical check valve that allows the flow of current in one direction.</strong></em> They are mostly made up of <em><strong>silicon</strong></em> but <em><strong>germanium</strong></em> is also used. Usually, they are used for <em><strong>rectification</strong></em>. But there are different properties &amp; characteristics of diodes which can be used for different application. These characteristics are modified to form different types of diodes. </p>
<p><img src="https://pic.islet.space/2021/07/image-20210713102126884.png" alt="image-20210713102126884"></p>
<img src="https://pic.islet.space/2021/07/Types-of-Diodes-and-Their-Applications.jpg" alt="Types of Diodes and Their Applications" style="zoom:67%;" />

<div style="text-align: center; font-weight: 900;">图 二极管的几种外形</div>



<p><img src="https://pic.islet.space/2021/07/image-20210713102141393.png" alt="image-20210713102141393"></p>
<div style="text-align: center; font-weight: 900;">图 二极管的几种常见结构和符号</div>

<h2 id="主要特征参数"><a href="#主要特征参数" class="headerlink" title="主要特征参数"></a>主要特征参数</h2><ol>
<li>最大整流电流（Maximum Rectification Current）</li>
<li>最高反向工作电压（Maximum Reverse Voltage）</li>
<li>反向电流（Reverse Current）</li>
<li>最高工作频率（Maximum Frequency）</li>
</ol>
<h2 id="自举二极管"><a href="#自举二极管" class="headerlink" title="自举二极管"></a>自举二极管</h2><h1 id="晶体管"><a href="#晶体管" class="headerlink" title="晶体管"></a>晶体管</h1><p>晶体管主要分为两种类型，BJT 和 FET。</p>
<p><strong>工作区域</strong>：晶体管的导通状态，分为三种，分别是饱和、截止和放大，分别是指</p>
<h2 id="BJT"><a href="#BJT" class="headerlink" title="BJT"></a>BJT</h2><p>BJT，即 Bioplar Junction Transistor，双极性结型晶体管。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210714213248733.png" alt="image-20210714213248733"></p>
<div style="text-align: center; font-weight:900;">图 晶体管内部结构和符号示意</div>

<p><strong>注意</strong>：晶体管的符号示意中，箭头的方向永远是从P指向N的，此时先不用管c、b、e是怎么接，确定好。</p>
<blockquote>
<p>BJT结构特点：三极三区两PN结，发射区多子浓度高，基区多子浓度低且薄，集电区 面积大。</p>
</blockquote>
<p><strong>发射区</strong>：多数载流子较高的区域，自由电子流出的方向。</p>
<p><strong>基区</strong>：多数载流子浓度较低且薄的区域。</p>
<p><strong>集电区</strong>：面积大的区域，空穴流出的反向。</p>
<blockquote>
<p>某极 是根导线，与BJT中的物理区不同。</p>
</blockquote>
<p><strong>发射结</strong>：发射区和基区之间的PN结。</p>
<p><strong>集电结</strong>：集电区和基区之间的PN结。</p>
<blockquote>
<p><strong>注意</strong>：以上多数载流子可以是 空穴 或 自由电子，因此 BJT 可以有 NPN 和 PNP 两种类型的BJT。</p>
</blockquote>
<p>联系到实际电路连接中，一般情况下，<strong>集电区</strong> 都是接 <strong>供电电源</strong> ， <strong>基区</strong> 都是接 <strong>控制电源</strong>， <strong>发射区</strong> 都是接 <strong>负端/地</strong>。控制电源的电压会低于供电电源的电压，但会大于发射区的电压。</p>
<p>基区所连接的控制电源 为BJT提供 高电平或低电平 予以控制半导体的导通或截止，<mark>半导体所控制的负载的最大电压取决于发射极的供电电源电压 和 基区的控制电源电压</mark>。</p>
<img src="https://pic.islet.space/2021/07/image-20210713104805683.png" alt="image-20210713104805683" style="zoom:67%;" />

<div style="text-align: center; font-weight: 900;">图 BJT的几种常见外形</div>



<img src="https://pic.islet.space/2021/07/image-20210713105054978.png" alt="image-20210713105054978" style="zoom:67%;" />

<div style="text-align: center; font-weight: 900;">图 BJT的结构和符号</div>



<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>从下图可以看出，下图 BJT 为 NPN 型半导体，集电区接正电，发射区接地，基区接地。集电区与基区为反向截止状态，集电结的耗尽层增大，进一步阻止集电区和发射区之间的电流导通。</p>
<p>若此时向基区施加正向电流，基区电压高于发射区电压，发射结正偏导通，发射区多子（电子）往基区流动，。发射区的电子能够顺利往集电区流动，集电区的电流往发射区流动，从而导通 该BJT。</p>
<img src="https://pic.islet.space/2021/07/image-20210714215347959.png" alt="image-20210714215347959" style="zoom:33%;" />

<div style="text-align: center; font-weight:900;">图 BJT导通时的内部电荷流向示意</div>



<p>集电极电流是漂移形成的，发射极电流是扩散形成的。</p>
<p><strong>发射区电流</strong> I<span style="font-size: 0.8rem;">E</span> 是由 扩散运动形成的。</p>
<p><strong>基区电流</strong> I<span style="font-size: 0.8rem;">B</span> 是由 复合运动形成的。</p>
<p><strong>集电区电流</strong> I<span style="font-size: 0.8rem;">C</span> 是由 漂移运动形成的。</p>
<img src="https://pic.islet.space/2021/07/image-20210714222731446.png" alt="image-20210714222731446" style="zoom:33%;" />

<div style="text-align: center; font-weight:900;">图 BJT输入特性曲线</div>



<img src="https://pic.islet.space/2021/07/image-20210714222645318.png" alt="image-20210714222645318" style="zoom: 33%;" />

<div style="text-align: center; font-weight:900;">图 BJT输出特性曲线</div>



<h3 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h3><img src="https://pic.islet.space/2021/07/image-20210714223024773.png" alt="image-20210714223024773" style="zoom:67%;" />

<div style="text-align: center; font-weight:900;">图 BJT工作区域</div>



<h2 id="FET"><a href="#FET" class="headerlink" title="FET"></a>FET</h2><p><strong>场效应晶体管</strong> 简称 <strong>场效应管</strong>。主要有 <strong>结型场效应管</strong>（JFET）和 <strong>金属氧化物半导体场效应管</strong>（MOSFET）两种类型。</p>
<h3 id="JFET"><a href="#JFET" class="headerlink" title="JFET"></a>JFET</h3><img src="https://pic.islet.space/2021/07/image-20210713105852012.png" alt="image-20210713105852012" style="zoom:67%;" />

<div style="text-align: center; font-weight: 900;">图 JFET的结构和符号</div>



<h3 id="MOSFET"><a href="#MOSFET" class="headerlink" title="MOSFET"></a>MOSFET</h3><p>在MOS管工作原理图上可以看到，漏极和源极之间有一个寄生二极管。这个叫体二极管，在驱动感性负载(如马达)，这个二极管很重要。顺便说一句，体二极管只在单个的MOS管中存在，在集成电路芯片内部通常是没有的。</p>
<p>下图a中，为增强型P衬底N沟道MOS，其栅极接 <u>高电平</u> 即导通。</p>
<img src="https://pic.islet.space/2021/07/image-20210713110023509.png" alt="image-20210713110023509" style="zoom:67%;" />

<div style="text-align: center; font-weight: 900;">图 N沟道增强型MOS管结构示意图 及 增强型MOS管的符号</div>



<img src="https://pic.islet.space/2021/07/image-20210713110146838.png" alt="image-20210713110146838" style="zoom:67%;" />

<div style="text-align: center; font-weight: 900;">图 N沟道耗尽型MOS管结构示意图 及 耗尽型MOS管的符号</div>

<h4 id="NMOS工作原理"><a href="#NMOS工作原理" class="headerlink" title="NMOS工作原理"></a>NMOS工作原理</h4><iframe src="//player.bilibili.com/player.html?aid=931455726&bvid=BV1DM4y1T7Yx&cid=363622918&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>MOS管有4个端子，其符号也是四个端子组成的，以下用NMOS举例：</p>
<p>NMOS底部端子连接到基板/主体（Substrate/Body），称为基板、衬底端子 或 <em><strong>主体端子</strong></em>。上方各有两个N沟道，各自连接 <em><strong>源极端子</strong></em> 和 <em><strong>漏极端子</strong></em>。两个端子中间添加了一层 薄绝缘体或电介质，在此层绝缘体上加了一个 <em><strong>栅极端子</strong></em>。</p>
<img src="https://pic.islet.space/2021/07/image-20210716001316182.png" alt="image-20210716001316182" style="zoom:50%;" />

<p>在NMOS内部构造中，源极端子 和 衬底端子 在内部连接，因此外露出来的端子只有三个。此时因 源极 和 衬底 的电位相同，阻止了任何电流从衬底流向源极。</p>
<img src="https://pic.islet.space/2021/07/image-20210716001716986.png" alt="image-20210716001716986" style="zoom:50%;" />

<p>在MOS中，希望电子从漏极流向源极，在两个极连接一个电源，其电压称为 V<span style="font-size: 0.6rem;">DS</span> ，此时加大电压，电流却不会增大，因为漏极沟道附近的耗尽层不断增大。</p>
<img src="https://pic.islet.space/2021/07/image-20210716002453710.png" alt="image-20210716002453710" style="zoom:50%;" />

<p>栅极端子 和 主体端子 都有绝缘材料，当给栅极端子接电压较小的电压 V<span style="font-size: 0.6rem;">GS</span> 时，两个绝缘材料形成电容效应，栅极处的多子不断吸引自由电子往栅极移动，暂时形成带自由电子较多的N区，从而导通了 源极 和 漏极，暂时形成了回路。因为 栅极处的N区是暂时连接 源极和漏极的通道，因此也被称为 N沟道。随着电压的增大或减小，沟道的大小也会随着变化。足以形成沟道的最低栅极电压被称为 <strong>阈值电压</strong>。</p>
<img src="https://pic.islet.space/2021/07/image-20210716002900372.png" alt="image-20210716002900372" style="zoom:50%;" />

<p>当不断增加栅极电压，漏极 和 衬底之间的耗尽层将因为 反向偏置 而不断增加。靠近漏极一侧的N沟道宽度将不断减小，直到某个电压点时，称为夹断效应。夹断下映实际上是说，沟道并未完全关闭，许多电子将保留通道，并不是停止了电流流动，而是出现了恒定的饱和电流，其电压被称为 饱和电压。</p>
<img src="https://pic.islet.space/2021/07/image-20210716004255087.png" alt="image-20210716004255087" style="zoom:50%;" />



<div style="text-align: center; font-weight: 900;">表 FET的符号和特性</div>

<p><img src="https://pic.islet.space/2021/07/image-20210713105437061.png" alt="image-20210713105437061"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210713105533255.png" alt="image-20210713105533255"></p>
<h2 id="FET-and-BJT"><a href="#FET-and-BJT" class="headerlink" title="FET and BJT"></a>FET and BJT</h2><p>FET 的 <strong>栅极</strong>、<strong>源极</strong> 和 <strong>漏极</strong> 对应 BJT的 <strong>基极</strong>、<strong>发射极</strong> 和 <strong>集电极</strong>，其作用类似。</p>
<table>
<thead>
<tr>
<th></th>
<th>FET</th>
<th>BJT</th>
</tr>
</thead>
<tbody><tr>
<td>电流索取</td>
<td>用“栅-源”电压控制漏极电流，栅极基本不取电流<br>【输入电阻高的电路选用】</td>
<td>工作时基极总要索取一定的电流<br>【信号源若提供电流的选用】</td>
</tr>
<tr>
<td>导电情况</td>
<td>仅多子参与导电</td>
<td>多子少子均参与导电</td>
</tr>
<tr>
<td>稳定性</td>
<td>较好</td>
<td>较差<br>【因少子数目受温度、辐射等因素影响较大，温度稳定性和抗辐射的能力较差些。】</td>
</tr>
<tr>
<td>噪声系数</td>
<td>小<br>【低噪声放大器的输入级和信噪比要求高的电路选用】</td>
<td>大</td>
</tr>
<tr>
<td>源-漏互换</td>
<td>可以互换，互换后特性变化不大</td>
<td>互换后特性差异很大，特殊需求时互换</td>
</tr>
<tr>
<td>电压范围</td>
<td>宽</td>
<td>窄</td>
</tr>
<tr>
<td>工艺</td>
<td>简单</td>
<td>复杂</td>
</tr>
<tr>
<td>耗电</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<blockquote>
<p>IGFET / MOS / MOSFET 是同一个东西，还有个词叫 MISFET（Metal-Insulated-Semiconductor Field Effect Transistor，金属绝缘半导体场效应管）</p>
</blockquote>
<h1 id="功率半导体"><a href="#功率半导体" class="headerlink" title="功率半导体"></a>功率半导体</h1><p><strong>功率半导体</strong> 器件大致分为两类： <strong>可控功率半导体</strong> 和 <strong>不可控功率半导体</strong>。<strong>可控功率半导体</strong> 如 Thyristor（晶闸管）、BJT（双极型晶体管）、功率MOSFET 和 IGBT 。不可控功率半导体 包括各种类型的功率二极管。</p>
<img src="https://pic.islet.space/2021/07/image-20210713112224602.png" alt="image-20210713112224602" style="zoom:67%;" />

<div style="text-align: center; font-weight: 900;">图 常见功率半导体器件及其典型的功率范围、阻断电压和开关频率</div>



<h1 id="IGBT"><a href="#IGBT" class="headerlink" title="IGBT"></a>IGBT</h1><p><strong>绝缘栅型双极晶体管</strong>，即 <strong>IGBT</strong>（Insulated Gate Bipolar Transistor），是由 <em><strong>BJT</strong></em>（双极型三极管)）和 <em><strong>MOS</strong></em>（绝缘栅型场效应管）组成的 <strong>复合全控型电压驱动式功率半导体</strong> 器件, 兼有 <strong>MOSFET</strong>的 <u>高输入阻抗</u> 和 <strong>GTR</strong>的 <u>低导通压降</u> 两方面的优点。IGBT综合了以上两种器件的优点，驱动功率小而饱和压降低。非常适合应用于直流电压为600V及以上的变流系统如交流电机、变频器、开关电源、照明电路、牵引传动等领域。</p>
<blockquote>
<p>GTR 具有饱和压降低，载流密度大，但驱动电流较大的优点；</p>
<p>MOSFET 具有驱动功率很小，开关速度快，但导通压降大，载流密度小的优点。</p>
</blockquote>
<p><strong>IGBT模块</strong> 是由 IGBT（绝缘栅双极型晶体管芯片）与FWD（续流二极管芯片）通过特定的电路桥接封装而成的模块化半导体产品；封装后的IGBT模块直接应用于变频器、UPS不间断电源等设备上；IGBT模块 具有节能、安装维修方便、散热稳定等特点；当前市场上销售的多为此类模块化产品，一般所说的IGBT也指IGBT模块；随着节能环保等理念的推进，此类产品在市场上将越来越多见；</p>
<img src="https://pic.islet.space/2021/07/image-20210713142410853.png" alt="image-20210713142410853" style="zoom: 80%;" />

<div style="text-align: center; font-weight: 900;">图 IGBT内部结构和等效电路</div>

<p>因为IGBT的构造所致，最好还是不要让IGBT长期工作在放大区，会让其降低使用寿命，因开关开断时而进入放大区无可避免，仅工作在 饱和区 和 截止区 即可。</p>
<img src="https://pic.islet.space/2021/07/image-20210715221251088.png" alt="image-20210715221251088" style="zoom:80%;" />



<p>三个英文符号分别表示为 <strong>栅极</strong>（Gate）、<strong>集电极</strong>（Collector）、<strong>发射极</strong>（Emitter）。</p>
<p>在漏极侧增加了高掺杂的P+层，称之为 <strong>集电极</strong>。</p>
<ul>
<li><p>当栅极接近 <u>负电压</u> 或 <u>零电压</u> 时，PN结 J2 阻断，发射极电压远低于集电极电压，IGBT 关断 （正向阻断）；但是此刻 结J1 和 结J3 <strong>正偏导通</strong>。</p>
</li>
<li><p>当栅极接到 <u>正电压</u>（通常是15V）时，氧化层下方的 P区 建立 <strong>反型导电沟道</strong>，为 N-区 提供导电通路，电子从发射极到 N-区 降低了 N-区 的电位，PN结 J1导通，IGBT导通。 </p>
</li>
</ul>
<p>如果栅极电压不够大，形成的反型层较弱，流入漂移区的电子数相对较少，IGBT压降增大，即进入特性曲线的 <strong>线性放大区</strong>。工作在线性放大区会加剧损耗或损坏 IGBT，因而除了开关瞬间，应避免进入线性放大区。</p>
<img src="https://pic.islet.space/2021/07/image-20210713144038325.png" alt="image-20210713144038325" style="zoom:67%;" />

<div style="text-align: center; font-weight: 900;">图 IGBT的输出特性</div>

<p>IGBT 的关断电流分为 <strong>MOSFET关断阶段</strong> 和 <strong>BJT关断阶段</strong>。第一个阶段时，关断反型沟道，电流迅速下降；第二个阶段时，会产生持续时间较长的拖尾电流。</p>
<p>拖尾电流使得 IGBT 的关断损耗 高于 MOSFET 的关断损耗。</p>
<img src="https://pic.islet.space/2021/07/image-20210713144838981.png" alt="image-20210713144838981" style="zoom: 67%;" />

<div style="text-align: center; font-weight: 900;">图 MOSFET和IGBT的主要开通和关断特性比较</div>



<p>截止电压：</p>
<p>饱和电压：</p>
<p>击穿电压：</p>
<p><strong>阈值电压</strong>：描述的是 <strong>栅极</strong> 和 <strong>发射极</strong> 之间刚好足以打开导流通道的电压。</p>
<p><strong>漏电流</strong>：泄露电流，leakage current。主要是指栅极和发射极的在反向偏置状态的泄露电流，此处特性与二极管相近。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>IGBT可以分为 <strong>穿通型</strong>（PT）IGBT、<strong>非穿通型</strong>（NPT）IGBT、<strong>场终止型</strong>（FS）IGBT、<strong>沟槽栅</strong>（Trench）IGBT、<strong>载流子存储沟槽栅双极晶体管</strong>（CSTBT）、<strong>注入增强晶体管</strong>（IEGT）、<strong>沟槽栅终止</strong>（Trench-FS）IGBT、<strong>逆导型</strong>（RC）IGBT。</p>
<p><strong>平面栅极结构</strong> 的IGBT设计，形成了JFET结构，以及发射极区软弱的电导调制效应，载流子的浓度从集电极到发射极之间逐步降低。</p>
<p><strong>沟槽型栅极结构</strong> 的IGBT设计，在平面型的基础上保持载流子浓度平均分布或逐步增加载流子浓度，进一步降低通态损耗，而不影响拖尾电流和关断损耗。</p>
<p>载流子越少越有助于降低关断损耗。</p>
<table>
<thead>
<tr>
<th>TYPE</th>
<th>内部构造（原理）</th>
<th>温度系数</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>PT-IGBT<BR>穿通型IGBT</td>
<td><img src="https://pic.islet.space/2021/07/image-20210713112637086.png" alt="image-20210713112637086" style="zoom:67%;" /></td>
<td>正温度系数<br>负温度系数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>NPT-IGBT<BR>非穿通型IGBT</td>
<td><img src="https://pic.islet.space/2021/07/image-20210713112654444.png" alt="image-20210713112654444" style="zoom:67%;" /></td>
<td>正温度系数</td>
<td>1. 有利于IGBT并联</td>
<td>1. 随着温度上升，损耗增大</td>
</tr>
<tr>
<td>FS-IGBT<BR>场终止型IGBT</td>
<td><img src="https://pic.islet.space/2021/07/image-20210713112712678.png" alt="image-20210713112712678" style="zoom:67%;" /></td>
<td>正温度系数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Trench-IGBT<br>沟槽栅IGBT</td>
<td><img src="https://pic.islet.space/2021/07/image-20210713112728045.png" alt="image-20210713112728045" style="zoom:67%;" /></td>
<td></td>
<td></td>
<td>1. 更宽的导电沟道会增加IGBT短路时的电流</td>
</tr>
<tr>
<td>CSTBT<br>载流子存储沟槽双极晶体管</td>
<td><img src="https://pic.islet.space/2021/07/image-20210713122039519.png" alt="image-20210713122039519" style="zoom:67%;" /></td>
<td></td>
<td>1. 降低了IGBT的饱和压降</td>
<td></td>
</tr>
<tr>
<td>IEGT<BR>注入增强栅晶体管</td>
<td><img src="https://pic.islet.space/2021/07/image-20210713112841613.png" alt="image-20210713112841613" style="zoom:67%;" /></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Trench-FS IGBT<br>沟槽栅终止IGBT</td>
<td><img src="https://pic.islet.space/2021/07/image-20210713112933604.png" alt="image-20210713112933604" style="zoom:67%;" /></td>
<td></td>
<td></td>
<td>1. 保持鲁棒性，通态损耗和开关损耗降低<br>2. 功率密度提升，即电流密度增大<br>3. 单位IGBT所需硅材料降低</td>
</tr>
<tr>
<td>RC-IGBT<BR>逆导型IGBT</td>
<td><img src="https://pic.islet.space/2021/07/image-20210713122011473.png" alt="image-20210713122011473" style="zoom:67%;" /></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="术语总结"><a href="#术语总结" class="headerlink" title="术语总结"></a>术语总结</h1><p><strong>FET</strong>： Filed Effect Transistor，即 <strong>场效应管</strong>，是 <mark>利用输入回路的电场效应来控制输出回路电流</mark> 的一种半导体器件，故此得名。由于其仅靠半导体中的多数载流子导电，因此也称为 <strong>单极型晶体管</strong>。</p>
<p><strong>JFET</strong>： Junction Filed Effect Transistor，即 <strong>结型场效应管</strong>，有 P沟道 和 N沟道 两种类型。</p>
<p><strong>IGFET</strong>： Insulated Gate Field Effect Transistor，即 <strong>绝缘栅型场效应管</strong>。因栅极与源极、栅极与漏极之间均采用二氧化硅绝缘层进行阻隔而得名如此。又因栅极为金属铝，故又称为MOS管。具有 高输入阻抗、高开关频率 和 低驱动功率 的优点。</p>
<p><strong>MOS</strong>： Metal-Oxide-Semiconductor，即 <strong>金属氧化物半导体</strong>。同上。</p>
<p><strong>MOSFET</strong>： Metal-Oxide-Semiconductor Field Effect Transistor，即 <strong>金属氧化物半导体场效应管</strong>。同上。</p>
<p><strong>BJT</strong>： Bipolar Junction Transistor， 即 <strong>双极结型晶体管</strong>。因带有两种不同极性电荷的载流子参与导电，故得名如此，或称 <strong>半导体三极管</strong>，简称 <strong>双极晶体管</strong> 或 <strong>晶体管</strong>。</p>
<p><strong>UJT</strong>： Unijunction Transistor，即 <strong>单结晶体管</strong>。因有两个基极，也称为 <strong>双基极晶体管</strong>。</p>
<p><strong>GTR</strong>： Giant Transistor，即 <strong>巨型晶体管</strong>。BJT的一种，亦称为 Power BJT（<strong>电力晶体管</strong>）。具有自关断、无须辅助关断电路、 高电流密度、低保和电压 和 耐高压 的优点。</p>
<p><strong>IGBT</strong>： Insulated Gate Bipolar Transistor，即 <strong>绝缘栅双极型晶体管</strong>。</p>
<p><strong>Thyristor</strong>：即 <strong>半导体闸流管</strong> 、<strong>晶闸管</strong>，又称为 <strong>硅可控元件</strong>（Silicon Controlled Rectifier）， 由按顺序排列的PNPN四层半导体组成。最外层的P区和N区构成了正负极，中间的P区构成了控制极（栅极），可以控制导通。具有耐压高、电流大、耐浪涌能力强 且 价格便宜 等优点。</p>
<p><strong>GTO</strong>： Gate Turn-Off Thyristor，即 <strong>可关断晶闸管</strong>。是一种通过门极来控制器件导通和关断的电力半导体器件。具有 普通晶闸管 和 GTR的优点，是应用于高压大容量场合中的一种大功率开关器件。</p>
<p><strong>PT</strong>： Power Transistor， 即 <strong>功率晶体管</strong> / <strong>功率管</strong>。</p>
<p><strong>IPM</strong>： Intelligent Power Module，即 <strong>智能功率模块</strong>。具有GTR 和 MOSFET 的优点。而且IPM内部集成了逻辑、控制、检测和保护电路，使用起来方便,不仅减小了系统的体积以及开发时间，也大大增强了系统的可靠性。</p>
<img src="https://pic.islet.space/2021/07/d4628535e5dde711c5d042b5a7efce1b9d166176" alt="img" style="zoom: 25%;" />

<div style="text-align: center; font-weight: 900;">图 IPM器件示意</div>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《模拟电子技术基础》高等教育出版社，童师白</li>
<li>《IGBT模块：技术、驱动和应用》机械工业出版社，Andreas Volke and Michael Hornkamp</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/366981878">逆变器的分类方式有哪些</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/IGBT/2078902?fromtitle=%E7%BB%9D%E7%BC%98%E6%A0%85%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1&fromid=12731336">IGBT</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1">场效应管</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%99%B6%E4%BD%93%E4%BA%8C%E6%9E%81%E7%AE%A1">晶体二极管</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%99%B6%E4%BD%93%E7%AE%A1/569042#:~:text=%E6%99%B6%E4%BD%93%E7%AE%A1%E6%9C%89%E6%97%B6%E5%A4%9A%E6%8C%87%E6%99%B6%E4%BD%93%E4%B8%89%E6%9E%81%E7%AE%A1%E3%80%82%20%E4%B8%89%E7%AB%AF%E5%AD%90%E6%99%B6%E4%BD%93%E7%AE%A1%E4%B8%BB%E8%A6%81%E5%88%86%E4%B8%BA%E4%B8%A4%E5%A4%A7%E7%B1%BB%EF%BC%9A%20%E5%8F%8C%E6%9E%81%E6%80%A7%E6%99%B6%E4%BD%93%E7%AE%A1,%EF%BC%88BJT%EF%BC%89%E5%92%8C%20%E5%9C%BA%E6%95%88%E5%BA%94%E6%99%B6%E4%BD%93%E7%AE%A1%20%EF%BC%88FET%EF%BC%8C%E5%8D%95%E6%9E%81%E6%80%A7%EF%BC%89%E3%80%82">晶体管</a></li>
<li><a target="_blank" rel="noopener" href="https://circuitglobe.com/difference-between-diode-and-transistor.html">Difference Between Diode &amp; Transistor</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/150177944">半导体分类知识大全</a></li>
<li><a target="_blank" rel="noopener" href="https://xueqiu.com/3593206238/153075165">IGBT—功率半导体皇冠上的明珠</a></li>
<li><a target="_blank" rel="noopener" href="https://www.electricaltechnology.org/2018/12/types-of-diodes-their-applications.html">Types of Diodes and Their Applications - 24 Types of Diodes</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/11/Hardware/DSP/2021-07-11-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%8A%AF%E7%89%87%E5%A4%96%E8%AE%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/11/Hardware/DSP/2021-07-11-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%8A%AF%E7%89%87%E5%A4%96%E8%AE%BE/" class="post-title-link" itemprop="url">嵌入式芯片外设</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-11 13:50:00" itemprop="dateCreated datePublished" datetime="2021-07-11T13:50:00+08:00">2021-07-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-07-15 21:11:03" itemprop="dateModified" datetime="2021-07-15T21:11:03+08:00">2021-07-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hardware/" itemprop="url" rel="index"><span itemprop="name">Hardware</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>嵌入式芯片（如MCU、DSP等）内部包含众多的模块化外设，如 串口控制模块，SPI模块，I2C模块，A/D模块，PWM模块，CAN模块，EEPROM，比较器模块，等等，它们都集成在芯片内部，有相对应的内部控制寄存器，可通过指令直接控制。</p>
<p>按照控制信号类别对外设进行分类，可以分为 <strong>模拟外设</strong>（Analog Peripherals）、<strong>控制外设</strong>（Control Peripherals） 和 <strong>通信外设</strong>（Communication Peripherals）。</p>
<p><strong>模拟外设</strong> 的常见外设如 <strong>模数转换器</strong>（Analog-to-Digital Convertor, ADC）、<strong>可编程增益放大器</strong>（Programmable Gain Amplifier, PGA）、<strong>温度传感器</strong>（Temperature Sensor）、<strong>缓冲数模转换器</strong>（Buffered Digital-to-Analog Convertor, DAC）和 <strong>比较器</strong>（Comparator Subsystem）。</p>
<p><strong>控制外设</strong> 的常见设备如 <strong>捕获器</strong>（Capture, CAP）、<strong>脉冲幅频调制器</strong>（Pulse Width Modulator, PWM）、<strong>正交编码器脉冲</strong>（ Quadrature Encoder Pulse, QEP）和 **西格玛-德尔塔滤波器模块 **（Sigma-Delta Filter Module, SDFM）。</p>
<p><strong>通信外设</strong> 的常见设备如 （Controller Area Network, CAN）、<strong>双线通信</strong>（Inter-Integrated Circuit, I2C）、<strong>电源管理总线接口</strong>（Power Management Bus Interface, PMBus）、<strong>串行通信接口</strong>（Serial Communications Interface, SCI）、<strong>串行外设接口</strong>（Serial Peripheral Interface, SPI）、<strong>局域互联网络</strong>（Local Interconnect Network, LIN） 和 <strong>高速串行接口</strong>（Fast Serial Interface, FSI）。</p>
<h1 id="CLA"><a href="#CLA" class="headerlink" title="CLA"></a>CLA</h1><p>为了解决DSP在对实时控制要求比较高的场合中CPU计算速度不足以及计算负担过重，TI很早之前就已经推出了具有CLA功能的DSP。</p>
<p>CLA，即Control Law  Accelerator，是一个32位浮点数计算加速器，可以理解为一个专门为浮点数运算而优化的CPU。其可以 <strong>独立</strong> 于CPU进行运算操作，并 <mark>可以同时访问</mark> 到ePWM，eCAP，eQEP，ADC result以及Comparator <mark>寄存器</mark>。相当于两个CPU并行工作，从而减少了主CPU的运算负担。</p>
<p>也就是说 CLA可以同时访问所有模拟外设的寄存器。</p>
<p>可以将CLA看作是辅助CPU进行计算的浮点运算协处理器（co-processor）。</p>
<p>一个典型的应用场景如下：</p>
<p><img src="https://pic.islet.space/2021/07/v2-9fdd0b85b26f7ff8074a8c58b1aba945_720w.jpg" alt="img">闭环控制电路</p>
<p>CPU通过ADC采集主电路的电压、电流信息，计算得到控制逻辑（包括频率以及占空比等），从而控制电路工作。因此如果CPU的计算负担很大，比如说需要计算傅里叶分解，比如说需要计算反三角函数等，那么就造成了极大的控制时延。而CLA应运而生，专门为计算浮点数进行优化，且不会造成CPU阻塞于计算而对异常情况无法响应的情况。</p>
<p><img src="https://pic.islet.space/2021/07/v2-2d0d2214e132b1a9982d3ab50db429ff_720w.jpg" alt="img"></p>
<div style="text-align: center; font-weight: 900;">图 28069和28027对比</div>

<p>上图则对比了具有CLA功能的28069和不具有CLA功能的28027的控制延时。对于没有CLA功能的28027，其CPU在ADC采样结束之后触发SOC中断，随后进行闭环计算，最后再结束一个周期的控制，开始下一个周期。而具有<mark>CLA</mark>功能的28069则<mark>可以在采样结束之后立即自主触发CLA计算</mark>（由于没有菊花链，所以触发迅速），并且由于<mark>CLA针对浮点数计算进行优化，因此计算时间更短</mark>。更重要的是，<mark>CPU不需要进行任何操作，因此CPU可以有空闲完成其他任务，比如异常检测，比如故障上报等等</mark>。</p>
<p>简单来说，采用CLA的系统具有<strong>更小的计算时延</strong>，<strong>CPU负担更小，</strong>因此其系统更加迅速稳定。</p>
<h1 id="CLB"><a href="#CLB" class="headerlink" title="CLB"></a>CLB</h1><p>The C2000 configurable logic block (CLB) is a collection of configurable blocks that interconnect through software to implement custom digital logic functions.</p>
<p>The CLB subsystem contains a number of identical tiles.</p>
<h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><p>GPIO，即General-purpose input/output，通用型之输入输出（接口）。功能类似8051的P0—P3，其接脚可以供使用者由程控自由使用，PIN脚依现实考量可作为通用输入（GPI）或通用输出（GPO）或通用输入与输出（GPIO），如当clk generator, chip select等。<br>既然一个引脚可以用于输入、输出或其他特殊功能，那么一定有寄存器用来选择这些功能。对于输入，一定可以通过读取某个寄存器来确定引脚电位的高低；对于输出，一定可以通过写入某个寄存器来让这个引脚输出高电位或者低电位；对于其他特殊功能，则有另外的寄存器来控制它们。</p>
<h1 id="CMPSS"><a href="#CMPSS" class="headerlink" title="CMPSS"></a>CMPSS</h1><p>CMPSS，即Comparator Subsystem，比较器子系统。由模拟比较器和支持电路组成，可用于峰值电流模式控制、开关电源、功率因数校正、电压跳闸监测等应用。</p>
<p>每个CMPSS包含两个比较器、两个12位DAC参考、两个数字滤波器和一个斜坡发生器。比较器在每个模块中表示为“H”或“L”，其中“H”和“L”分别表示高和低。每个比较器产生一个数字输出，指示正输入端的电压是否大于负输入端的电压。比较器的正输入由外部引脚或PGA驱动，负输入可由外部引脚或可编程参考12位DAC驱动。每个比较器输出通过一个可编程的数字滤波器，可以消除假跳闸信号。如果不需要滤波，也可以使用未滤波的输出。一个可选的斜坡发生器电路可用于控制高比较器的12位参考DAC值。</p>
<p><img src="https://pic.islet.space/2021/07/20200416154658460.png"></p>
<h1 id="CAN"><a href="#CAN" class="headerlink" title="CAN"></a>CAN</h1><p>A controller area network(CAN) is ideally suited to the many high-level industrial protocols embracing CAN and <em><strong>ISO-11898:2003</strong></em> as their physical layer.</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li><p>The CAN bus was developed by BOSCH as a <em><strong>multi-master</strong></em>, <em><strong>message broadcast</strong></em> system that specifies a maximum signaling rate of <em><strong>1 megabit per second</strong></em>(bps).</p>
</li>
<li><p>CAN is an International Standardization Organization (ISO) defined serial communications bus originally developed for the automotive industry to replace the complex wiring harness with a two-wire bus.</p>
</li>
<li><p>CAN <em>does not</em> send large blocks of data point-to-point from node A to Node B under the supervision of the central bus master.</p>
</li>
<li><p>In a CAN network, <mark>many short messages</mark> like temperature or RPM <mark>are broadcast to the entire network</mark>, which provides for <mark>data consistency in every node of the system</mark>. 保证系统中各节点的数据一致性。</p>
</li>
<li><p>CAN’s specification calls for high immunity to electrical interface and the ability to self-diagnose and repair data errors.</p>
</li>
</ul>
<p>以下为ISO 11898 对 CAN 标准架构层级解释框图：</p>
<p><img src="C:\Users\431240.IT2004\AppData\Roaming\Typora\typora-user-images\image-20210711162150611.png" alt="image-20210711162150611"></p>
<p>The CAN communication protocol is a <em><strong>carrier-sense</strong></em>, <em><strong>multiple-access</strong></em> protocol with <em><strong>collision detection</strong></em> and <em><strong>arbitration on message priority</strong></em> (<em><strong>CSMA</strong></em> / <em><strong>CD+AMP</strong></em>). <em><strong>CSMA</strong></em> means that each node on a bus must wait for a prescribed period of inactivity before attempting to send a message. <em><strong>CD+AMP</strong></em> means that collisions are resolved through a bit-wise arbitration, based on a preprogrammed priority of each message in the identifier field of a message. The higher priority identifier always wins bus access.</p>
<p>CAN 包含 standard CAN 和 Extended CAN。</p>
<p><img src="C:\Users\431240.IT2004\AppData\Roaming\Typora\typora-user-images\image-20210711163535822.png" alt="image-20210711163535822"></p>
<p><img src="C:\Users\431240.IT2004\AppData\Roaming\Typora\typora-user-images\image-20210711163548817.png" alt="image-20210711163548817"></p>
<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p><strong>菊花链</strong>：在电子电气工程中菊花链代表一种配线方案，例如设备A和设备B用电缆相连，设备B再用电缆和设备C相连，设备C用电缆和设备D相连，在这种连接方法中不会形成网状的拓扑结构，只有相邻的设备之间才能直接通信，例如在上例中设备A是不能和设备C直接通信的，它们必须通过设备B来中转，这种方法同样不会形成环路。因为最后一个设备不会连向第一个设备。这种连线方法能够用来传输电力，数字信号和模拟信号。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/72232829">CLA介绍及使用指南</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/gpio">GPIO</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/whyorwhnt/article/details/105547472">TMS320F280049C 学习笔记16 比较器子系统(CMPSS)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ti.com/lit/an/sloa101b/sloa101b.pdf">《Introduction to the Controller Area Network(CAN)》</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/10/Communication/2021-07-10-JTAG%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/10/Communication/2021-07-10-JTAG%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">JTAG通信</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-07-10 21:00:00 / Modified: 21:28:00" itemprop="dateCreated datePublished" datetime="2021-07-10T21:00:00+08:00">2021-07-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Communication/" itemprop="url" rel="index"><span itemprop="name">Communication</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>以下为 B站up主——“蛋饼的爹地” 制作上传的JTAG科普视频。</p>
<iframe src="//player.bilibili.com/player.html?aid=503270942&bvid=BV1iN411Z7jk&cid=346887915&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>





<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://xploreqa.ieee.org/stampPDF/getPDF.jsp?tp=&arnumber=6515989&ref=aHR0cHM6Ly94cGxvcmVxYS5pZWVlLm9yZy9kb2N1bWVudC82NTE1OTg5">《IEEE 1149.1-2013 Test Access Port and Boundary Scan Architecture》</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/10/Hardware/Circuit/2021-07-10-VCC%E3%80%81VDD%E3%80%81VEE%E3%80%81VSS%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/10/Hardware/Circuit/2021-07-10-VCC%E3%80%81VDD%E3%80%81VEE%E3%80%81VSS%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">VCC、VDD、VEE、VSS的区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-10 15:00:00" itemprop="dateCreated datePublished" datetime="2021-07-10T15:00:00+08:00">2021-07-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-07-15 21:10:58" itemprop="dateModified" datetime="2021-07-15T21:10:58+08:00">2021-07-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hardware/" itemprop="url" rel="index"><span itemprop="name">Hardware</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="对于晶体管"><a href="#对于晶体管" class="headerlink" title="对于晶体管"></a>对于晶体管</h2><p><em><strong>Vcc</strong></em>：来源于集电极电源电压， <em>Collector Voltage</em>， 一般用于双极型晶体管， PNP 管时为负电源电压， 有时也标成 -Vcc， NPN 管时为正电压</p>
<p><em><strong>Vdd</strong></em>：来源于漏极电源电压， <em>Drain Voltage</em>， 用于 MOS 晶体管电路， 一般指正电源。 因为很少单独用 PMOS 晶体管， 所以在 CMOS 电路中 Vdd 经常接在 PMOS 管的源极上。</p>
<p><em><strong>Vss</strong></em>：源极电源电压， 在 CMOS 电路中指负电源， 在单电源时指零伏或接地。</p>
<p><em><strong>Vee</strong></em>：发射极电源电压， <em>Emitter Voltage</em>， 一般用于 ECL 电路的负电源电压。</p>
<p><em><strong>Vbb</strong></em>：基极电源电压， 用于双极晶体管的共基电路。</p>
<h2 id="对于电路及芯片"><a href="#对于电路及芯片" class="headerlink" title="对于电路及芯片"></a>对于电路及芯片</h2><p><em><strong>VDD</strong></em>：电源电压(单极器件)；芯片电源电压。（Device）</p>
<p><em><strong>VCC</strong></em>：电源电压(双极器件)；电路电源电压。（Circuit）</p>
<p><em><strong>VSS</strong></em>：接地端、负极。（Series）</p>
<p><em><strong>VEE</strong></em>：负电压供电；</p>
<p><em><strong>VPP</strong></em>：编程/擦除电压。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/10/Hardware/DSP/2021-07-10-F280041PM%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/10/Hardware/DSP/2021-07-10-F280041PM%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">F280041PM开发笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-10 11:10:00" itemprop="dateCreated datePublished" datetime="2021-07-10T11:10:00+08:00">2021-07-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-08-06 22:49:13" itemprop="dateModified" datetime="2021-08-06T22:49:13+08:00">2021-08-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hardware/" itemprop="url" rel="index"><span itemprop="name">Hardware</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[TOC]</p>
<p>TMS320F28004x 下称 本系列芯片，本系列设备型号命名方法：</p>
<img src="https://pic.islet.space/2021/07/image-20210719092842059.png" alt="image-20210719092842059" style="zoom:67%;" />

<p>开发本系列芯片可能需要使用到的文件如下：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210724112707176.png" alt="image-20210724112707176"></p>
<p><strong>注意</strong>：下文中《TRM》 与《SPRUI33D》为同一份文件。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>C28004x 共有2种芯片封装形式： LQFP 和 VQFN 。VQFN 仅有56针，LQFP 有 100针和 64针的区别。分别用 PZ 、PM 和 RSH 三种型号尾缀与 100-pin 、64-pin 和 56-pin 相关联。根据section4.3，可以知道还有个64PMQ的尾缀。</p>
<p>如型号TMS320F280041PM，仅有64针脚，引脚分布如下图所示：</p>
<img src="https://pic.islet.space/2021/07/image-20210710144933414.png" alt="image-20210710144933414" style="zoom:100%;" />



<h1 id="Specification"><a href="#Specification" class="headerlink" title="Specification"></a>Specification</h1><p>下图应该是F280049的系统功能框图，与F280041PM仍有些出入。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210710141413564.png" alt="image-20210710141413564"></p>
<p><strong>注意</strong>：<span style="text-decoration: line-through">F280041PM不支持 CLA（控制律加速器，Control Law Accelerator）</span>，Flash为128KB（64KW），GPIO数量为26，AIO数量为14，ADC通道为14，同时280041支持5个PGA</p>
<p><strong>更正</strong>： F28004x系列均支持 CLA（控制律加速器，Control Law Accelerator），如《spru566n》中的下表示，支持type2型CLA。</p>
<p>TMS320F28004x 所支持外设如下：</p>
<img src="https://pic.islet.space/2021/07/image-20210710142641475.png" alt="image-20210710142641475" style="zoom:110%;" />



<blockquote>
<p><strong>Q</strong>: 为什么要区分type？</p>
<p><strong>A</strong>: 就同一类功能而言，在C2000系列上，都会有许多不同的增强/阉割版本，就出现了支持全部基础功能的、出现支持部分扩展功能的 和 支持全部扩展功能的等各种版本，那么就需要从功能范围的本质上去描述这些区别，再用相应的 “功能+type x” 的方式来表示其支持的类别。如下图所示，为《spru556n》page 24 所描述的关于CLA的功能类别。</p>
<p><code>CLA type 0</code>，表示的是支持原始CLA功能的模块类型。</p>
<p><code>CLA type 2</code> ，表示在原始功能的基础上，增加了后台代码模式，可以在后台运行通信和清理程序等任务；后台任务持续运行，直到禁用或设备/软复位；后台任务可以由外设或软件触发；其他前台任务可以按照定义的优先顺序中断后台任务；增加了使后台代码部分不被中断的规定；增加了调试功能，具有真正的软件断点支持，在调试停止期间，CLA从同一地址重新获取数据会被停止。</p>
<img src="https://pic.islet.space/2021/07/image-20210712141632913.png" alt="image-20210712141632913" style="zoom: 67%;" />
</blockquote>
<p>贴一张 <em><strong>系统控制基础地址</strong></em> 的总表：<img src="https://pic.islet.space/2021/07/image-20210802135651683.png" alt="image-20210802135651683"></p>
<h2 id="引脚"><a href="#引脚" class="headerlink" title="引脚"></a>引脚</h2><h3 id="引脚分配"><a href="#引脚分配" class="headerlink" title="引脚分配"></a>引脚分配</h3><p>Page17 4.2 <em><strong>Pin Attributes</strong></em> 下可以查看各封装芯片引脚的名称、编号 及 功能。（共有10页左右，不粘贴了）</p>
<h3 id="引脚路由"><a href="#引脚路由" class="headerlink" title="引脚路由"></a>引脚路由</h3><p>Page30 4.3 <em><strong>Signal Routing</strong></em> 下可以查看引脚的路由信息。包括模拟引脚和数字引脚的复用信息。</p>
<h3 id="引脚复用"><a href="#引脚复用" class="headerlink" title="引脚复用"></a>引脚复用</h3><p>Page41 4.4 <em><strong>Pin Multiplexing</strong></em> 下可以查看引脚的复用信息，GPIO口的默认功能就是GPIO，除了GPIO35 和 GPIO37（默认情况下是TDI 和 TDO）。GPIO口的次级功能可以通过设置 <code>GPyGMUXn.GPIOz</code> 和 <code>GPyMUXn.GPIOz</code> 寄存器位来进行。</p>
<p><strong>注意</strong>： </p>
<ul>
<li><code>GPyGMUXn</code> 寄存器应在 <code>GPyMUXn</code> 之前配置，以避免交替复用选择对GPIO产生瞬时脉冲。</li>
<li>GPIO20 , GPIO21 和 GPIO41 至 GPIO55在任何封装上都不可复用。</li>
</ul>
<p>表6 为GPIO的针脚复用说明，表中未列明项为GPIO复用设置保留位。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210712094430159.png" alt="image-20210712094430159"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210712094455163.png" alt="image-20210712094455163"></p>
<h3 id="引脚置高-低"><a href="#引脚置高-低" class="headerlink" title="引脚置高/低"></a>引脚置高/低</h3><p>部分引脚可以被置高/低，下表展示了各引脚的设置类型。默认情况下，GPIO不可置高，但是可以通过软件进行使能。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210712093251720.png" alt="image-20210712093251720"></p>
<h3 id="X-BAR"><a href="#X-BAR" class="headerlink" title="X-BAR"></a>X-BAR</h3><p>X-BAR 即 Crossbar。</p>
<h4 id="输入X-BAR"><a href="#输入X-BAR" class="headerlink" title="输入X-BAR"></a>输入X-BAR</h4><p>输入X-BAR被用于从GPIO口引导信号至许多不同的IP块，如ADC、eCAP、ePWM 和 外部中断。图5 展示了X-BAR的架构，表8 展示了各X-BAR输入可能的路由目的地。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210712095049189.png" alt="image-20210712095049189"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210712095346292.png" alt="image-20210712095346292"></p>
<h4 id="输出X-BAR-和-ePWM-X-BAR"><a href="#输出X-BAR-和-ePWM-X-BAR" class="headerlink" title="输出X-BAR 和 ePWM X-BAR"></a>输出X-BAR 和 ePWM X-BAR</h4><p>输出X-BAR有8个可以路由至各GPIO模块的输出口。ePWM X-BAR 有8个可以路由至各ePWM模块的输出口。</p>
<p>图6 展示了 两个X-BAR的 信号源。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210712095838640.png" alt="image-20210712095838640"></p>
<h2 id="电压"><a href="#电压" class="headerlink" title="电压"></a>电压</h2><p>本系列芯片支持以下三种之一的电源供应（在要求核心电压VDD = 1.2V 的情况下）：</p>
<ul>
<li>外接电源（不支持56针RSH封装）</li>
<li>内部 1.2V LDO电压整流器</li>
<li>内部 1.2V 开关整流器</li>
</ul>
<p><strong>注意</strong>：必须使用同一个系统电压调节器来驱动VDDIO和VDDIO_SW。</p>
<p>下方是有关两个电压调节器的详细描述：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210710154834139.png" alt="image-20210710154834139"></p>
<h2 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h2><h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p>设备时钟域为设备上的不同模块提供时钟输入支持，这些设备与派生时钟（derived clock）直接相连， 或通过额外的分频器连接。</p>
<p>F28004x 支持 <strong>内源</strong> 和 <strong>外源</strong> 两种类型时钟。<strong>内源</strong> 即芯片自带的，上电即起振的内源性时钟。<strong>外源</strong> 即需要通过引脚外接配置的。</p>
<p>下图展示了 本系列芯片支持的时钟系统框图，可以看到时钟源 有 <em><strong>INTOSC1</strong></em> / <em><strong>INTOSC2</strong></em> / <em><strong>X1(XTAL)</strong></em> 三个，由时钟源配置产生的时钟最终会产生 <em><strong>看门狗时钟</strong></em>、<em><strong>PLL系统时钟</strong></em>、<em><strong>芯片时钟</strong></em>  主要是这三种。其中 <em><strong>芯片时钟</strong></em> 又会 <em><u>进一步</u></em> 配置到给各种外设。</p>
<p>外设的时钟使用也是有区别的，其中  <em><strong>SYSCLK</strong></em> 被 ePIE、RAMs、GPIOs 和 DCSM 所使用；<em><strong>PERx.LSPCLK</strong></em> 被 SCIs 和 SPIs 所使用；<em><strong>CAN-Bit-Clock</strong></em> 被 CAN总线使用（注意，此时必须使用外源时钟进行配置）；<em><strong>PERx.SYSCLK</strong></em> 被 剩余其他外设所使用。</p>
<img src="https://pic.islet.space/2021/07/image-20210710155206953.png" alt="image-20210710155206953"  />

<p>下表 3-40 所示为《SPRUI33D》第173页 关于时钟配置相关的寄存器。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210726121525047.png" alt="image-20210726121525047"></p>
<h3 id="内源时钟"><a href="#内源时钟" class="headerlink" title="内源时钟"></a>内源时钟</h3><blockquote>
<p>At power-up, the device is clocked from an on-chip 10 MHz oscillator (INTOSC2). INTOSC2 is the primary internal clock source, and is the default system clock at reset. It is used to run the boot ROM and can be used as the system clock source for the application.</p>
</blockquote>
<p>下图展示了本系列芯片的时钟系统，本系列芯片支持两个独立的 <strong>内源时钟</strong>，直接映射为 <em><strong>INTOSC1</strong></em> 和 <em><strong>INTOSC2</strong></em> 。默认情况下，都会在芯片启动时开启，且 <em><strong>INTOSC2</strong></em> 才是 内源时钟的主时钟源，<strong>INTOSC1</strong> 是备用时钟源。<u>这一点可以手动修改</u>。</p>
<p>芯片启动时，<em><strong>INTOSC2</strong></em> 以10MHz速率起振，为 ROM的启动做准备，且可以被配置为 系统时钟。</p>
<p>即系统内部自带的内源时钟，<em><strong>INTOSCx</strong></em>  ，可以在不外接晶振的情况下，仅用内源时钟即可驱动工作，且《sprui33》3.7.11中就以内源时钟 <em><strong>INTOSC2</strong></em> 为主时钟（仅有10MHz），讲述了系统运行时钟 <em><strong>SYSCLK</strong></em> （100MHz）的配置方法。</p>
<p>注意：</p>
<ul>
<li><p>如果需要使用 CAN 外设，那么仅使用 <em><strong>INTOSCx</strong></em> 的频率是不足以达到CAN的频率要求的，必须使用外部时钟 <em><strong>XTAL</strong></em> 。</p>
</li>
<li><p><mark style="font-weight: 900;">在使用内源时钟时，用于接外源时钟的X1引脚必须通过一个 1KΩ的电阻接地。</mark></p>
</li>
<li><p>与其他GPIO相比，<mark>GPIO18拥有不一样的电气特性</mark>，因为是可以被当做X2来使用的。</p>
</li>
</ul>
<p><img src="https://pic.islet.space/2021/07/image-20210730085027137.png" alt="image-20210730085027137"></p>
<h4 id="看门狗"><a href="#看门狗" class="headerlink" title="看门狗"></a>看门狗</h4><p>如图5-10所示，如果要启用看门狗，其速率最高与 <em><strong>INTOSC1</strong></em> 一致。</p>
<h3 id="外源时钟"><a href="#外源时钟" class="headerlink" title="外源时钟"></a>外源时钟</h3><p><span style="text-decoration-line: line-through;">系统还可以使用 <em><strong>X1</strong></em> 或 <em><strong>X2</strong></em> 两个接口其中之一来连接 至 <strong>外部时钟</strong> 。</span></p>
<p>外源时钟有两个接口，分别是 <em><strong>第41</strong></em>（<em>GPIO18_X2</em>） 和 <em><strong>第42</strong></em>（<em>X1</em>）。按照连接方式分类，可以分为 <strong>外源时钟模式</strong> 和 <strong>单端外源时钟模式</strong>：</p>
<ul>
<li>外源时钟模式时，<em>X1</em> 和 <em>X2</em> 都进行连接。进一步区分为 <strong>EC</strong>（外部晶振器，External Crystal）和 <strong>ER</strong>（外部谐振器，External Resonator）。</li>
<li>单端外源时钟模式时，仅 <em>X1</em> 连接，<em>X2</em> 留空，VSS需要接地。</li>
</ul>
<p>图 5-12 至 5-14 展示了三种不同的外部时钟源电路：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210711172426297.png" alt="image-20210711172426297"></p>
<p><strong>注意</strong>：<mark>当 <em><strong>X1</strong></em> 接口被当作外源时钟接口使用时，X2接口不能被当做GPIO使用。仅当使用内源时钟时， <em><strong>X2</strong></em> 可以配置成 GPIO。</mark></p>
<p>如下方所示，为 LaunchPad 硬件的时钟电路，其中 Boosterpack 是指 ？？？</p>
<p><img src="https://pic.islet.space/2021/07/image-20210730134835054.png" alt="image-20210730134835054"></p>
<p>需要使用到Boosterpack时，需要移除R35，在R31和R38上焊上0Ω的跨电阻连接器，下图为LaunchPad背面的镜像示意。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210730141929361.png" alt="image-20210730141929361"></p>
<p>从C2000WARE套件里的《MCU025A(001)_BOM.xls》可以找到launchpads板上的板载时钟一共有2个，分别是Y1和Y2。其中，与F280049只接相连的是Y2，为Crystal。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210730145344856.png" alt="image-20210730145344856"></p>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>表13 展示了（外部）输入时钟频率的范围要求</p>
<p>表14 展示了（外部）晶体振荡器的电气特性</p>
<p>表15 展示了X1的计时要求</p>
<p>表16 展示了PLL锁定的时间</p>
<p>表17 展示了内部时钟频率</p>
<p>表18 展示了输出时钟XCLKOUT的开断性能</p>
<p>表19 展示了（外部）晶体振荡器参数</p>
<p>表20 展示了（外部）晶体振荡器的等效电阻要求</p>
<p>表21 展示了（外部）晶体振荡器的电气特性</p>
<p>表22 展示了（内部）晶体振荡器的电气特性</p>
<p><img src="https://pic.islet.space/2021/07/image-20210710155540889.png" alt="image-20210710155540889"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210710160134644.png" alt="image-20210710160134644"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210710160150517.png" alt="image-20210710160150517"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210711172100592.png" alt="image-20210711172100592"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210711173148615.png" alt="image-20210711173148615"></p>
<h3 id="PLL计算方法"><a href="#PLL计算方法" class="headerlink" title="PLL计算方法"></a>PLL计算方法</h3><p>下图展示了系统PLL的设置框图。</p>
<img src="https://pic.islet.space/2021/07/image-20210710155140640.png" alt="image-20210710155140640"  />

<p>系统PLL（PLLSYSCLK）的计算方法：<code>PLLSYSCLK = OSCCLK * IMULT * FMULT / PLLSYSCLKDIV</code> </p>
<blockquote>
<p>PLLSYSCLK : 输出时钟频率</p>
<p>OSCCLK : 输入时钟频率</p>
<p>IMULT : 整数倍频，取值范围为 [0, 127]</p>
<p>FMULT : 分数倍频，取值范围为 [0 , 3]</p>
<p>PLLSYSCLKDIV : 分频， 取值范围为 {0, 1, 2, 4, 6, 8, …, 124, 126}</p>
</blockquote>
<h3 id="内源时钟配置方法"><a href="#内源时钟配置方法" class="headerlink" title="内源时钟配置方法"></a>内源时钟配置方法</h3><p>需要注意的是，内源时钟配置时，X1需要通过一个1KΩ的电阻接地。</p>
<img src="https://pic.islet.space/2021/07/image-20210730085027137.png" alt="image-20210730085027137" style="zoom:67%;" />

<p>Once the application requirements are understood, a specific clock configuration can be determined. The default configuration is for <em><strong>INTOSC2</strong></em> to be used as the system clock (<em><strong>PLLSYSCLK</strong></em>) with a divider of 1. </p>
<p>The following procedure can be used to set up the desired application configuration:</p>
<ol>
<li><p>Select the reference clock source (<em><strong>OSCCLK</strong></em>) by writing to <em><strong>CLKSRCCTL1.OSCCLKSRCSEL</strong></em>. To enable XTAL, follow the instructions in the previous sections.</p>
</li>
<li><p>Select the reference clock source (<em><strong>OSCCLK</strong></em>) by writing to <em><strong>CLKSRCCTL1.OSCCLKSRCSEL</strong></em>. Allow at least 300 <em><u>NOP instructions</u></em> for this to take effect.</p>
</li>
<li><p>Set up the system PLL if desired. TI recommends using the C2000Ware <code>SysCtl:setClock()</code> function for proper configuration of the PLL clock.</p>
</li>
<li><p>Select the <em><strong>LSPCLK</strong></em> divider by writing to <em><strong>LOSPCP</strong></em>.</p>
</li>
<li><p>If an alternate CAN bit clock is needed, select it by writing to <em><strong>CLKSRCCTL2.CANABCLKSEL</strong></em> and <em><strong>CLKSRCCTL2.CANBBCLKSEL</strong></em>.</p>
</li>
<li><p>Enable the desired peripheral clocks by writing to the <em><strong>PCLKCRx</strong></em> registers.</p>
</li>
</ol>
<p>The system clock configuration can be changed at run time. Changing the <em><strong>OSCCLK</strong></em> source will automatically bypass the PLL and set the multiplier to zero. Changing the multiplier from one non-zero value to another will temporarily bypass the PLL until it re-locks.</p>
<p><mark style="font-weight: 900;">注意： At least a 300 CPU clock cycles delay is needed after OSSCLK source is changed. </mark></p>
<h4 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h4><p>以下为工作频率设置的样例，利用内源时钟 <code>10MHz</code> ，产生芯片满负工作频率 <code>100MHz</code> ：</p>
<img src="https://pic.islet.space/2021/07/image-20210715170724177.png" alt="image-20210715170724177"  />



<h4 id="配置代码"><a href="#配置代码" class="headerlink" title="配置代码"></a>配置代码</h4><p><code>f28004x_examples.h</code> 文件中，包含了对 <code>IMULT</code> 、<code>FMULT</code> 、 <code>PLLSYSCLKDIV</code> 的变量宏定义。</p>
<p>官方提供的PLL配置函数原型为：<code>void InitSysPll(Uint16 clock_source, Uint16 imult, Uint16 fmult, Uint16 divsel)</code> 。根据配置实例中的参数，函数调用时代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InitSysPll(INT_OSC2, IMULT_19, FMULT_0pt25, PLLCLK_BY_1);</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InitSysPll(<span class="number">0x00</span>, <span class="number">0x13</span>, <span class="number">0x01</span>, <span class="number">0x01</span>);</span><br></pre></td></tr></table></figure>

<p>即 <code>10MHz * ( 19 + 1/4 ) / (2^1) = 96.25MHz</code>，最后的CPU工作频率为 96.25MHz，但由于内源时钟振荡器可能存在变化，CPU的工作时钟也存在 ±3% 的公差。</p>
<h3 id="外部时钟配置方法"><a href="#外部时钟配置方法" class="headerlink" title="外部时钟配置方法"></a>外部时钟配置方法</h3><p>下面配置步骤由《TRM》第104页提供，按照连接方式，将连接模式分为：<strong>外源时钟模式</strong> 和 <strong>单端外源时钟模式</strong></p>
<p>两个模式仅在第2和第7个步骤有所区别，其余均相同。</p>
<table>
<thead>
<tr>
<th>外源时钟模式：<em>CRYSTAL</em> or <em>RESONATOR</em></th>
<th>单端外源时钟模式：<em>OSCILLATOR</em></th>
</tr>
</thead>
<tbody><tr>
<td>1. Clear the <code>XTALCR.OSCOFF</code> bit.</td>
<td>1. Clear the <code>XTALCR.OSCOFF</code> bit.</td>
</tr>
<tr>
<td>2. Wait for the crystal to power up. 1ms is the typical wait time but this depends on the crystal that is being used.</td>
<td>2. Set the <code>XTALCR.SE</code> bit to enable <em>single-ended mode</em>.</td>
</tr>
<tr>
<td>3. Clear the X1 counter by writing a 1 to <code>X1CNT.CLR</code> and keep clearing until the X1 counter value in the <code>X1CNT</code> register is no longer saturated <code>1023 (0x3ff)</code>.</td>
<td>3. Clear the X1 counter by writing a 1 to <code>X1CNT.CLR</code> and keep clearing until the X1 counter value in the <code>X1CNT</code> register is no longer saturated <code>1023 (0x3ff)</code>.</td>
</tr>
<tr>
<td>4. Wait for the X1 counter value in the <code>X1CNT</code> register to reach <code>1023 (0x3ff)</code>.</td>
<td>4. Wait for the X1 counter value in the <code>X1CNT</code> register to reach <code>1023 (0x3ff)</code>.</td>
</tr>
<tr>
<td>5. Repeat steps 3-4 three additional times.</td>
<td>5. Repeat steps 3-4 three additional times.</td>
</tr>
<tr>
<td>6. Select XTAL as the OSCCLK source by writing a <code>1</code> to <code>CLKSRCCTL1.OSCCLKSRCSEL</code>.</td>
<td>6. Select XTAL as the OSCCLK source by writing a <code>1</code> to <code>CLKSRCCTL1.OSCCLKSRCSEL</code>.</td>
</tr>
<tr>
<td>7. Check the <code>MCLKSTS</code> bit in the <code>MCDCR</code> register. If it’s set, the oscillator has not finished powering up, and more time is required:<br><em><strong>a.</strong></em> Clear the missing clock status by writing a <code>1</code> to <code>MCDCR.MCLKCLR</code>.<br><em><strong>b.</strong></em> Repeat steps 2-7. Do not reset the device. Doing so will power down the oscillator, which requires the procedure to be restarted from step 1.<br><em><strong>c.</strong></em> <mark style="font-style: italic;">If the oscillator has not finished powering up in 10 milliseconds, there is a real clock failure.</mark></td>
<td>7. Check the <code>MCLKSTS</code> bit in the <code>MCDCR</code> register. <mark style="font-style: italic;">If it’s set, either the external oscillator or the device has failed.</mark></td>
</tr>
<tr>
<td>8. If <code>MCDCR.MCLKSTS</code> is clear, the oscillator startup is a success. The system clock is now derived from XTAL.</td>
<td>8. If <code>MCLKSTS</code> is clear, the switch to the external clock is a success. The system clock is now derived from XTAL.</td>
</tr>
</tbody></table>
<p><img src="https://pic.islet.space/2021/08/image-20210730164642361.png" alt="image-20210730164642361"></p>
<h3 id="子系统时钟（SYSCLK-PERx-SYSCLK）"><a href="#子系统时钟（SYSCLK-PERx-SYSCLK）" class="headerlink" title="子系统时钟（SYSCLK / PERx.SYSCLK）"></a>子系统时钟（SYSCLK / PERx.SYSCLK）</h3><p>CPU 为 CLA / DMA 和 绝大多数（片上）外设直接提供时钟信号，该时钟就是 <em><strong>PLLSYSCLK</strong></em> ， 但会在CPU进入 HALT模式时被栅断（gate off）。</p>
<p>每一个外设都拥有使用 <em><strong>PCLKCRx</strong></em> 寄存器进行独立控制的时钟。</p>
<p><strong>注意</strong>：当使用 PCLKCRx 时，应用需要在时钟接入外设后，等待5个 <em><strong>SYSCLK</strong></em> 周期。</p>
<p>如《SPRUI33D》中，表3-55所示，从第195页起可查看 <em><strong>PCLKCRx</strong></em> 相关寄存器的所有说明。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210726095356897.png" alt="image-20210726095356897"></p>
<h2 id="闪存"><a href="#闪存" class="headerlink" title="闪存"></a>闪存</h2><p>表23 展示了不同时钟源和频率下所需的最小闪存等待状态</p>
<p>表24 展示了闪存的性能参数</p>
<p><img src="https://pic.islet.space/2021/07/image-20210711173614732.png" alt="image-20210711173614732"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210711173721809.png" alt="image-20210711173721809"></p>
<h2 id="JTAG"><a href="#JTAG" class="headerlink" title="JTAG"></a>JTAG</h2><img src="https://pic.islet.space/2021/07/image-20210730135537700.png" alt="image-20210730135537700" style="zoom: 80%;" />





<h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><p><mark>在复位时，GPIO会被配置为输入。</mark></p>
<p>对于特定的输入，用户还可以选择 <strong>输入鉴定周期</strong>（input qualification cycles）的数量来过滤不需要的 <strong>噪声突变</strong>（unwanted noise glitches）。</p>
<p><em><strong>表 29</strong></em> 展示了GPIO的特性参数，<mark style="text-decoration-line: line-through;">需要注意的是，GPIO的频率只有25MHz最高。</mark></p>
<p><em><strong>表 30</strong></em> 展示了GPIO的输入时间要求</p>
<p><img src="https://pic.islet.space/2021/07/image-20210711174357812.png" alt="image-20210711174357812"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210711174530164.png" alt="image-20210711174530164"></p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>《SPRUI33D》第857页起讲述GPIO特性，第870页起讲述相关寄存器信息。</p>
<p>如 <em><strong>表 8-8</strong></em> 所示，GPIO拥有两类寄存器，分别是 <em><strong>GPIO控制寄存器</strong></em> 和 <em><strong>GPIO数据寄存器</strong></em> 。另，控制/数据寄存器 下都有 <em>GPIO A</em> / <em>GPIO B</em> / <em>GPIO H</em> 三种区别。<em><strong>表 8-9</strong></em> 是GPIO控制寄存器的详细介绍，<em><strong>表 8-54</strong></em> 是GPIO数据寄存器的详细介绍。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210728104527100.png" alt="image-20210728104527100"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210728105035255.png" alt="image-20210728105035255"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210728105057621.png" alt="image-20210728105057621"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210728105118549.png" alt="image-20210728105118549"></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>如 <a target="_blank" rel="noopener" href="http://code.islet.space/TI/f28004x/group__gpio__api.html">GPIO配置手册</a> 所示，<code>GPIO_SetupPinMux();</code> 和 <code>GPIO_SetupPinOption();</code> 并不存在，这两个是存在于 <code>f28004x_gpio.h</code> 中的自定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// AFE_InitGpio - Initialize the GPIOs on launchpad and boosterpack</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AFE_InitGpio</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EALLOW; <span class="comment">// below registers are &quot;protected&quot;, allow access.</span></span><br><span class="line">    <span class="comment">//GPIO-23 - LaunchPad RED LED</span></span><br><span class="line">    GPIO_SetupPinMux(<span class="number">23</span>, GPIO_MUX_CPU1, <span class="number">0</span>);</span><br><span class="line">    GPIO_SetupPinOptions(<span class="number">23</span>, GPIO_OUTPUT, GPIO_PUSHPULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GPIO-34 - LaunchPad GREEN LED</span></span><br><span class="line">    GPIO_SetupPinMux(<span class="number">34</span>, GPIO_MUX_CPU1, <span class="number">0</span>);</span><br><span class="line">    GPIO_SetupPinOptions(<span class="number">34</span>, GPIO_OUTPUT, GPIO_PUSHPULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GPIO AFE BoosterPack LED</span></span><br><span class="line">    GPIO_SetupPinMux(<span class="number">4</span>, GPIO_MUX_CPU1, <span class="number">0</span>);</span><br><span class="line">    GPIO_SetupPinOptions(<span class="number">4</span>, GPIO_OUTPUT, GPIO_PUSHPULL);</span><br><span class="line"></span><br><span class="line">    GPIO_SetupPinMux(<span class="number">5</span>, GPIO_MUX_CPU1, <span class="number">0</span>);</span><br><span class="line">    GPIO_SetupPinOptions(<span class="number">5</span>, GPIO_OUTPUT, GPIO_PUSHPULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    GPIO_WritePin(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">    GPIO_WritePin(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">    EDIS;</span><br><span class="line">    <span class="comment">// Disable register access</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h4><h5 id="引脚复用设置函数"><a href="#引脚复用设置函数" class="headerlink" title="引脚复用设置函数"></a>引脚复用设置函数</h5><p>本函数用于将指定引脚与函数进行绑定，绑定前会自动检查对应的CPU和外设是否可用。</p>
<p>然后，创建指向相应寄存器的指针，这是对GPIO寄存器定义方式的一种变通。</p>
<p>头文件中的标准定义使得对一个寄存器或位进行命名访问非常容易，但很难进行任意的数字访问。有一个具有相同寄存器的GPIO模块阵列，包括像 <code>GPyCSEL1-4</code> 这样的多寄存器组的阵列，会更容易。但是头文件没有定义任何我们可以变成数组的东西，所以就用手动指针运算来代替。</p>
<p>要改变多路复用，首先将外设多路复用设置为0/GPIO，以避免出现故障，然后改变组复用，再将外设多路复用设置为目标值。最后，设置CPU选择。这个过程在《TRM》中有所描述。不幸的是，由于我们事先不知道引脚，我们不能硬编码一个位域参考，所以这里有一些棘手的位操作。</p>
<p><strong>警告</strong>：该代码不涉及模拟模式选择寄存器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// GPIO_SetupPinMux - Set the peripheral muxing for the specified pin.</span></span><br><span class="line"><span class="comment">// The appropriate parameters can be found in the pinout spreadsheet.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_SetupPinMux</span><span class="params">(Uint16 gpioNumber, Uint16 cpu, Uint16 muxPosition)</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Uint32 *gpioBaseAddr;</span><br><span class="line">    <span class="keyword">volatile</span> Uint32 *mux, *gmux, *csel;</span><br><span class="line">    Uint16 pin32, pin16, pin8;</span><br><span class="line"></span><br><span class="line">    pin32 = gpioNumber % <span class="number">32</span>;</span><br><span class="line">    pin16 = gpioNumber % <span class="number">16</span>;</span><br><span class="line">    pin8 = gpioNumber % <span class="number">8</span>;</span><br><span class="line">    gpioBaseAddr = (Uint32 *)&amp;GpioCtrlRegs + (gpioNumber/<span class="number">32</span>)*GPY_CTRL_OFFSET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Sanity check for valid cpu and peripheral values</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (cpu &gt; GPIO_MUX_CPU1CLA || muxPosition &gt; <span class="number">0xF</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Create pointers to the appropriate registers. This is a workaround</span></span><br><span class="line">    <span class="comment">// for the way GPIO registers are defined. The standard definition</span></span><br><span class="line">    <span class="comment">// in the header file makes it very easy to do named accesses of one</span></span><br><span class="line">    <span class="comment">// register or bit, but hard to do arbitrary numerical accesses. It&#x27;s</span></span><br><span class="line">    <span class="comment">// easier to have an array of GPIO modules with identical registers,</span></span><br><span class="line">    <span class="comment">// including arrays for multi-register groups like GPyCSEL1-4. But</span></span><br><span class="line">    <span class="comment">// the header file doesn&#x27;t define anything we can turn into an array,</span></span><br><span class="line">    <span class="comment">// so manual pointer arithmetic is used instead.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    mux = gpioBaseAddr + GPYMUX + pin32/<span class="number">16</span>;</span><br><span class="line">    gmux = gpioBaseAddr + GPYGMUX + pin32/<span class="number">16</span>;</span><br><span class="line">    csel = gpioBaseAddr + GPYCSEL + pin32/<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Now for the actual function</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EALLOW;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// To change the muxing, set the peripheral mux to 0/GPIO first to avoid</span></span><br><span class="line">    <span class="comment">// glitches, then change the group mux, then set the peripheral mux to</span></span><br><span class="line">    <span class="comment">// its target value. Finally, set the CPU select. This procedure is</span></span><br><span class="line">    <span class="comment">// described in the TRM. Unfortunately, since we don&#x27;t know the pin in</span></span><br><span class="line">    <span class="comment">// advance we can&#x27;t hardcode a bitfield reference, so there&#x27;s some tricky</span></span><br><span class="line">    <span class="comment">// bit twiddling here.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    *mux &amp;= ~(<span class="number">0x3</span>UL &lt;&lt; (<span class="number">2</span>*pin16));</span><br><span class="line">    *gmux &amp;= ~(<span class="number">0x3</span>UL &lt;&lt; (<span class="number">2</span>*pin16));</span><br><span class="line">    *gmux |= (Uint32)((muxPosition &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3</span>UL) &lt;&lt; (<span class="number">2</span>*pin16);</span><br><span class="line">    *mux |= (Uint32)(muxPosition &amp; <span class="number">0x3</span>UL) &lt;&lt; (<span class="number">2</span>*pin16);</span><br><span class="line"></span><br><span class="line">    *csel &amp;= ~(<span class="number">0x3</span>L &lt;&lt; (<span class="number">4</span>*pin8));</span><br><span class="line">    *csel |= (Uint32)(cpu &amp; <span class="number">0x3</span>L) &lt;&lt; (<span class="number">4</span>*pin8);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// WARNING: This code does not touch the analog mode select registers.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="引脚属性设置函数"><a href="#引脚属性设置函数" class="headerlink" title="引脚属性设置函数"></a>引脚属性设置函数</h5><p>为指定的引脚设置输入/出，可以通过已定义的标志（flags）来设置，这些标志都是16位的掩码。</p>
<p>输入引脚可用的标志如：</p>
<blockquote>
<p><code>GPIO_PULLUP</code> 使能拉高</p>
<p><code>GPIO_INVERT</code> 输入极性翻转</p>
<p><code>GPIO_SYNC</code> 与PLLSYSCLK同步输入阀（这条是默认的，可以不单独设置）</p>
<p><code>GPIO_QUAL3</code> 使用3采样质量</p>
<p><code>GPIO_QUAL6</code> 使用6采样质量</p>
<p><code>GPIO_ASYNC</code> 不使用同步或质量</p>
</blockquote>
<p>输出引脚可用标志如下：</p>
<blockquote>
<p><code>GPIO_OPENDRAIN</code> 工作在输出开漏模式</p>
<p><code>GPIO_PULLUP</code> 输出置高，</p>
</blockquote>
<p>注意：如果输出开漏模式打开，也就自动打开了置高。输入配置里的 SYNC / QUAL3 / QUAL6 / ASYNC 只允许启用一个。</p>
<p><strong>默认输入状态</strong>：<strong>未同步</strong>（ASYNC）且无 <strong>置高</strong>（PULL-UP）和 <strong>极性翻转</strong>（INVERT）。</p>
<p><strong>默认输出状态</strong>：标准数字输出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_SetupPinOptions</span><span class="params">(Uint16 gpioNumber, Uint16 output, Uint16 flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Uint32 *gpioBaseAddr;</span><br><span class="line">    <span class="keyword">volatile</span> Uint32 *dir, *pud, *inv, *odr, *qsel;</span><br><span class="line">    Uint32 pin32, pin16, pinMask, qual;</span><br><span class="line"></span><br><span class="line">    pin32 = gpioNumber % <span class="number">32</span>;</span><br><span class="line">    pin16 = gpioNumber % <span class="number">16</span>;</span><br><span class="line">    pinMask = <span class="number">1UL</span> &lt;&lt; pin32;</span><br><span class="line">    gpioBaseAddr = (Uint32 *)&amp;GpioCtrlRegs + (gpioNumber/<span class="number">32</span>)*GPY_CTRL_OFFSET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Create pointers to the appropriate registers. This is a workaround</span></span><br><span class="line">    <span class="comment">// for the way GPIO registers are defined. The standard definition</span></span><br><span class="line">    <span class="comment">// in the header file makes it very easy to do named accesses of one</span></span><br><span class="line">    <span class="comment">// register or bit, but hard to do arbitrary numerical accesses. It&#x27;s</span></span><br><span class="line">    <span class="comment">// easier to have an array of GPIO modules with identical registers,</span></span><br><span class="line">    <span class="comment">// including arrays for multi-register groups like GPyQSEL1-2. But</span></span><br><span class="line">    <span class="comment">// the header file doesn&#x27;t define anything we can turn into an array,</span></span><br><span class="line">    <span class="comment">// so manual pointer arithmetic is used instead.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    dir = gpioBaseAddr + GPYDIR;</span><br><span class="line">    pud = gpioBaseAddr + GPYPUD;</span><br><span class="line">    inv = gpioBaseAddr + GPYINV;</span><br><span class="line">    odr = gpioBaseAddr + GPYODR;</span><br><span class="line">    qsel = gpioBaseAddr + GPYQSEL + pin32/<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    EALLOW;</span><br><span class="line"></span><br><span class="line">    *dir &amp;= ~pinMask;      <span class="comment">// Set the data direction</span></span><br><span class="line">    <span class="keyword">if</span> (output == <span class="number">1</span>)&#123;</span><br><span class="line">        *dir |= pinMask;   <span class="comment">// Output, with optional open drain mode and pull-up</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; GPIO_OPENDRAIN) *odr |= pinMask;  <span class="comment">// Enable open drain if necessary</span></span><br><span class="line">        <span class="keyword">else</span> *odr &amp;= ~pinMask;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; (GPIO_OPENDRAIN | GPIO_PULLUP)) *pud &amp;= ~pinMask;  <span class="comment">// Enable pull-up if necessary. Open drain mode must be active.</span></span><br><span class="line">        <span class="keyword">else</span> *pud |= pinMask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *dir &amp;= ~pinMask;        <span class="comment">// Input, with optional pull-up, qualification, and polarity inversion</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; GPIO_PULLUP) *pud &amp;= ~pinMask;     <span class="comment">// Enable pull-up if necessary</span></span><br><span class="line">        <span class="keyword">else</span> *pud |= pinMask;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; GPIO_INVERT) *inv |= pinMask;   <span class="comment">// Invert polarity if necessary</span></span><br><span class="line">        <span class="keyword">else</span> *inv &amp;= ~pinMask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Extract the qualification parameter and load it into the register.</span></span><br><span class="line">    <span class="comment">// This is also needed for open drain outputs, so we might as well do it</span></span><br><span class="line">    <span class="comment">// all the time.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    qual = (flags &amp; GPIO_ASYNC) / GPIO_QUAL3;</span><br><span class="line">    *qsel &amp;= ~(<span class="number">0x3</span>L &lt;&lt; (<span class="number">2</span> * pin16));</span><br><span class="line">    <span class="keyword">if</span> (qual != <span class="number">0x0</span>) *qsel |= qual &lt;&lt; (<span class="number">2</span> * pin16);</span><br><span class="line"></span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>C28x系列芯片有14条外设中断可用，其中13和14中断被直接关联至CPU定时器1和定时器2。剩余12条中断可以通过 <strong>增强型外围中断扩展</strong>（enhanced Peripheral Interrupt Expansion，ePIE)模块进行信号引导。本模块将最多16个外设中断复用到每个CPU中断线中，并扩展了向量表，允许每个中断有自己的ISR。允许芯片支持数量众多的外围设备。</p>
<p>中断路径一共有三个阶段—— <em><strong>外设中断阶段</strong></em>、<em><strong>PIE模块阶段</strong></em> 和 <em><strong>CPU阶段</strong></em>。每个阶段都有其使能和标志寄存器。本系统允许CPU在其他中断等待时处理一个中断，在软件中实现并优先处理嵌套中断，并在某些关键任务中禁用中断。</p>
<p>下图展示了本系列芯片的中断架构。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210728111202805.png" alt="image-20210728111202805"></p>
<p>外部中断（external interrupt, XINT）电气特性数据和时序特性：</p>
<p>表31 列出了外部中断的时间要求</p>
<p>表32 列出了外部中断开断特性</p>
<p>图25 展示了外部中断的时序</p>
<p><img src="https://pic.islet.space/2021/07/image-20210712083326344.png" alt="image-20210712083326344"></p>
<h3 id="STAGE0-外设中断阶段"><a href="#STAGE0-外设中断阶段" class="headerlink" title="STAGE0 - 外设中断阶段"></a>STAGE0 - 外设中断阶段</h3><h3 id="STAGE1-PIE阶段"><a href="#STAGE1-PIE阶段" class="headerlink" title="STAGE1 - PIE阶段"></a>STAGE1 - PIE阶段</h3><p>PIE控制器是指用于外围设备中断控制（Peripheral Interrupt Control）的寄存器。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210728110450590.png" alt="image-20210728110450590"></p>
<h3 id="STAGE2-CPU阶段"><a href="#STAGE2-CPU阶段" class="headerlink" title="STAGE2 - CPU阶段"></a>STAGE2 - CPU阶段</h3><h2 id="低电量模式"><a href="#低电量模式" class="headerlink" title="低电量模式"></a>低电量模式</h2><p>本系列芯片拥有两种 时钟门（clock-gating） 低电量模式，分别是 HALT 和 IDLE，STANDARD 模式不支持进入低电量。</p>
<p>低电量模式的进入和退出代码，以及更多关于低电量模式的描述信息，需要参考《TRM》手册。</p>
<p>表33 描述了系统进入任何 时钟门 低电量模式后的影响</p>
<p>表34 列明了IDLE模式下的时序要求</p>
<p>表35 列明了IDLE模式下的开断特性</p>
<p>表36 列明了HALT模式下的时序要求</p>
<p>表37 列明了HALT模式下的开断特性</p>
<p>图26 展示了IDLE模式的时序框图</p>
<p>图27 展示了HALT模式的时序框图</p>
<p><img src="https://pic.islet.space/2021/07/image-20210712100908714.png" alt="image-20210712100908714"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210712101034377.png" alt="image-20210712101034377"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210712101211183.png" alt="image-20210712101211183"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210712101225955.png" alt="image-20210712101225955"></p>
<h1 id="模拟外设"><a href="#模拟外设" class="headerlink" title="模拟外设"></a>模拟外设</h1><p>本系列芯片的模拟外设包含 <strong>ADC</strong> 、 <strong>PGA</strong> 、 <strong>DAC</strong> 和 <strong>CMPSS</strong>。</p>
<p>所有的模拟引脚一共有16个，包括ADC三个模块（module，A、B、C）、PGA、DAC等都是复用的。</p>
<p><img src="https://pic.islet.space/2021/08/image-20210805172817997.png" alt="image-20210805172817997"></p>
<h2 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h2><p>本系列芯片的ADC外设是 <strong>第5类</strong>（TYPE 5）ADC，只支持12位单端模式。以下讨论中可能会看到 ADCA / ADCB / ADCC 三种不同的描述，其实是ADC三个大的模块，模块下面又有很多个通道。</p>
<img src="https://pic.islet.space/2021/08/image-20210804113737347.png" alt="image-20210804113737347" style="zoom:67%;" />



<p>单个ADC模块的简化示意图如下：</p>
<img src="https://pic.islet.space/2021/07/image-20210730103920701.png" alt="image-20210730103920701" style="zoom:67%;" />

<p>ADC模拟外设的内部架构如下：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210730092532193.png" alt="image-20210730092532193"></p>
<p>SOC和EOC的内部架构如下：</p>
<img src="https://pic.islet.space/2021/07/image-20210730105429591.png" alt="image-20210730105429591" style="zoom:67%;" />



<h3 id="ADC特点"><a href="#ADC特点" class="headerlink" title="ADC特点"></a>ADC特点</h3><ul>
<li>12bit 分辨率</li>
<li>VREFHI VREFLO</li>
<li>可选内部参考电压为 2.5V 或 3.3V</li>
<li>单端信号转换器</li>
<li>最多16个ADC通道</li>
<li>16个配置SOC（<code>ADCSOC0</code> ~ <code>ADCSOC15</code>）</li>
<li>16个独立的可寻址结果寄存器</li>
<li>四个高级的（flexible）外设中断</li>
<li>可配置的中断（interrupt placement）</li>
<li>爆发模式</li>
<li>多触发源<ul>
<li>S/W ，软件立即启动</li>
<li>所有的ePWMs（ADC SOC A 或 B）</li>
<li>GPIO XINT2</li>
<li>CPU定时器 0/1/2</li>
<li>ADCINT1/2</li>
</ul>
</li>
<li>四个PPB（post-processing blocks），每一个都有：<ul>
<li>Saturating offset calibration</li>
<li>Error from setpoint calculation</li>
<li>High, low and zero-crossing compare, with interrupt and ePWM trip capability</li>
<li>Trigger-to-sample delay capture</li>
</ul>
</li>
</ul>
<h3 id="ADC输入模型"><a href="#ADC输入模型" class="headerlink" title="ADC输入模型"></a>ADC输入模型</h3><p><img src="https://pic.islet.space/2021/07/image-20210730091825651.png" alt="image-20210730091825651"></p>
<p>每个通道的寄生电容</p>
<p><img src="https://pic.islet.space/2021/07/image-20210730093537064.png" alt="image-20210730093537064"></p>
<h3 id="ADC配置项"><a href="#ADC配置项" class="headerlink" title="ADC配置项"></a>ADC配置项</h3><p>ADC模块的 配置项 分为 <strong>可配置</strong>（Configurable）、<strong>不可配置</strong>（Unconfigurable） 两种。可配置项又分为 <strong>可按模块独立配置</strong> 和 <strong>全局配置</strong>（Globally configurable） 两种。</p>
<table>
<thead>
<tr>
<th>Options</th>
<th>Configurability</th>
</tr>
</thead>
<tbody><tr>
<td><strong>时钟</strong> Clock</td>
<td>每个模块（A/B/C）</td>
</tr>
<tr>
<td><strong>分辨率</strong> Resolution</td>
<td>不可配置（仅12bit）</td>
</tr>
<tr>
<td><strong>信号模式</strong> Signal mode</td>
<td>不可配置（仅单端（Single-ended））</td>
</tr>
<tr>
<td><strong>参考电压源</strong> Reference voltage source</td>
<td>每个模块（外部或内部）</td>
</tr>
<tr>
<td><strong>触发源</strong> Trigger source</td>
<td>每个SOC</td>
</tr>
<tr>
<td><strong>转换通道</strong> Converted Channel</td>
<td>每个SOC</td>
</tr>
<tr>
<td><strong>获取窗口期</strong> Acquisition window duration</td>
<td>每个SOC</td>
</tr>
<tr>
<td><strong>EOC定位</strong> EOC location</td>
<td>每个模块</td>
</tr>
<tr>
<td><strong>爆发模式</strong> Burst mode</td>
<td>每个模块</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：这里的 <strong>SOC</strong> 是指 <strong>ADCSOC</strong>，start of conversion。</p>
<h4 id="时钟-1"><a href="#时钟-1" class="headerlink" title="时钟"></a>时钟</h4><p>ADC基础时钟由系统时钟 <em><strong>SYSCLK</strong></em> 提供，用以生成ADC <strong>获取窗口</strong>（acquisition window）。寄存器 <em><strong>ADCCTL2</strong></em> 有一个决定ADC时钟 <em><strong>ADCCLK</strong></em> 的预分频（prescale）区域。<em><strong>ADCCLK</strong></em> 直接为转换器（converter）提供时钟信号。</p>
<p>转换核心需要约10.5个 <em><strong>ADCCLK</strong></em> 时钟周期来将 输入电压转换成 数字信号，因此需要自行决定和配置获取窗口所需要的周期大小。</p>
<img src="https://pic.islet.space/2021/08/image-20210805153739063.png" alt="image-20210805153739063" style="zoom: 67%;" />



<h4 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h4><p>ADC分辨率决定着最终模拟信号能够转换成的数值大小。本系列芯片支持12bit分辨率。</p>
<h4 id="参考电压源"><a href="#参考电压源" class="headerlink" title="参考电压源"></a>参考电压源</h4><p>本系列芯片的第16、17引脚是ADC的参考电压：</p>
<ul>
<li>第16pin 是ADC A/B/C的高参考电压（Voltage Reference High） <em><strong>VREFHIx</strong></em> </li>
<li>第17pin 是ADC A/B/C的低参考电压（Voltage Reference Low） <em><strong>VREFLOx</strong></em></li>
</ul>
<p>根据《TRM》P1442可知，每个ADC模块都可以配置一个单独的参考电压（包括 <strong>VREFHI</strong>和 <strong>VREFLO</strong>），参考电压源可以是内部或外部。需要注意的是，引脚数较少的封装可能在多个ADC之间共享一个VREFHI引脚。在这种情况下，共享一个参考引脚的ADC必须将它们的参考模式配置得完全一样。</p>
<h5 id="外部参考电源"><a href="#外部参考电源" class="headerlink" title="外部参考电源"></a>外部参考电源</h5><p>在外部参考电压模式下，参考电压源的针脚被当做比率测量参考，以测定ADC转换的输入范围。</p>
<p>以下几点需要注意：</p>
<ul>
<li>如果没有连接到具体的外部 <em><strong>VREFLO</strong></em> 信号，需将 <em><strong>VREFLO</strong></em> 连接至 设备模拟地 <em><strong>VSSA</strong></em>。</li>
<li>外部参考电源（高/低）的输入范围：</li>
<li><em><strong>VREFHI</strong></em> 针脚要求外接电容。</li>
</ul>
<img src="https://pic.islet.space/2021/08/image-20210805090011967.png" alt="image-20210805090011967" style="zoom:50%;" />

<img src="https://pic.islet.space/2021/08/image-20210805090028640.png" alt="image-20210805090028640" style="zoom:50%;" />



<h5 id="内部参考电源"><a href="#内部参考电源" class="headerlink" title="内部参考电源"></a>内部参考电源</h5><p>选择内部参考电源时，将由芯片设备来为 <em><strong>VREFHI</strong></em> 提供参考电源。 此电源电压可以被配置为 <code>2.5V</code> 或 <code>1.65V</code>，当配置 <code>1.65V</code> 时，模拟输入的范围最大为 <code>3.3V</code> 。</p>
<p><strong>注意</strong>：内部参考模式同样要求给 VREFHI针脚外接一个电容（具体电容值视具体情况而定）。</p>
<h5 id="Ganged参考电源"><a href="#Ganged参考电源" class="headerlink" title="Ganged参考电源"></a>Ganged参考电源</h5><p>某些封装中，多个ADC电压参考针脚可能被捆绑在了一起。这种情况下，当选择外部或内部参考模式，以及选择 <code>3.3V</code> 或 <code>2.5V</code> 内部参考电压范围时，有必要对ganged参考进行相同的配置。</p>
<p>例如，如果 ADC B 和 ADC C参考电源针脚被捆绑在一起，并且需要一个2.5V的内部参考电源时，以下配置代码可供参考：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ADCB VREFHI and ADCC VREFHI share a pin</span></span><br><span class="line"><span class="comment">//ADCB VREFLO and ADCC VREFLO share a pin</span></span><br><span class="line"><span class="comment">//Both references must be explicitly configured</span></span><br><span class="line"><span class="comment">//Both references must be configured identically</span></span><br><span class="line">SetVREF(ADC_ADCB, ADC_INTERNAL, ADC_VREF2P5);</span><br><span class="line">SetVREF(ADC_ADCC, ADC_INTERNAL, ADC_VREF2P5);</span><br></pre></td></tr></table></figure>

<p>内部硬件设备将确保相同针脚上的多个参考电源不会冲突。（ensure multiple references don’t drive conflicting voltages onto the same pin）正因如此，参考电源可以被配置于任意顺序及任意时间。</p>
<h5 id="选择参考模式"><a href="#选择参考模式" class="headerlink" title="选择参考模式"></a>选择参考模式</h5><p>电压参考模式可以用C2000套件提供的 <code>SetVREF()</code> 或 <code>ADC_setVREF()</code> 函数进行配置。使用这些函数时需确保 <strong>修正值</strong>（correct trim）已被载入 ADC trim 寄存器，需要确保设备复位后这些函数至少被调用一次，同时不要通过直接写入 <em><strong>ANAREFCTL</strong></em> 寄存器来配置电压参考模式。</p>
<h4 id="信号模式"><a href="#信号模式" class="headerlink" title="信号模式"></a>信号模式</h4><p>本系列芯片支持单端模式，通过单根针脚 <code>ADCINx</code> 采样转换器的输入电压，参考点为 <code>VREFLO</code>。</p>
<h5 id="预期（Expected）转换结果"><a href="#预期（Expected）转换结果" class="headerlink" title="预期（Expected）转换结果"></a>预期（Expected）转换结果</h5><p>基于给定的模拟输入电压，预期情况下的数字转换结果如下表所示。小数部分省略。</p>
<table>
<thead>
<tr>
<th>模拟输入</th>
<th>数字输出</th>
</tr>
</thead>
<tbody><tr>
<td>当输入电压低于参考低电压<br><em><strong>ADCINy</strong></em> ≤ <em><strong>VREFLO</strong></em></td>
<td><strong>最小量程</strong> <code>0x00</code></td>
</tr>
<tr>
<td>当输入电压在高低参考电压之间<br><em><strong>VREFLO</strong></em> &lt; <em><strong>ADCINy</strong></em> &lt; <em><strong>VREFHI</strong></em></td>
<td><strong>最大量程</strong> <code>0xFFF</code> 和 <strong>输入电压差</strong> / <strong>参考电压差</strong> 之积<br>即 <code>0xFFF * (ADCINy - VREFLO) / (VREFHI - VREFLO)</code></td>
</tr>
<tr>
<td>当输入电压超过参考高电压<br><em><strong>ADCINy</strong></em> ≥ <em><strong>VREFHI</strong></em></td>
<td><strong>最大量程</strong> <code>0xFFF</code>（即 <code>2^(12)-1</code>）</td>
</tr>
</tbody></table>
<h5 id="解释（Interpreting）转换结果"><a href="#解释（Interpreting）转换结果" class="headerlink" title="解释（Interpreting）转换结果"></a>解释（Interpreting）转换结果</h5><p>基于给定的ADC数字转换结果，来反推理想的对应模拟输入的结果。公式就用上面的表格来反推就好了。</p>
<h3 id="ADC寄存器"><a href="#ADC寄存器" class="headerlink" title="ADC寄存器"></a>ADC寄存器</h3><p>寄存器这边除了描述最基本的 <strong>基地址</strong> （Base Address）以外，还有两类寄存器：<strong>结果寄存器</strong>（Result Register）和 <strong>控制寄存器</strong>（Control Register）。</p>
<img src="https://pic.islet.space/2021/08/image-20210805085945157.png" alt="image-20210805085945157" style="zoom: 85%;" />



<p><img src="https://pic.islet.space/2021/08/image-20210805090938982.png" alt="image-20210805090938982"></p>
<p><img src="https://pic.islet.space/2021/08/image-20210805090858805.png" alt="image-20210805090858805"></p>
<h3 id="ADC启动顺序"><a href="#ADC启动顺序" class="headerlink" title="ADC启动顺序"></a>ADC启动顺序</h3><p>设备开启或系统级复位时，ADC会被断电禁用。为ADC上电启用时，请遵循以下顺序：</p>
<ol>
<li>设置 <code>PCLKCR13</code> 寄存器中的指定位来启用所需 ADC 时钟</li>
<li>设置 <code>ADCCTL2</code> 寄存器中的 预分频 <code>PRESCALE</code> 位来设置 ADC的时钟分频</li>
<li>设置 <code>ADCCTL1</code> 寄存器中的 <code>ADCPWDNZ</code> 位来启用 ADC</li>
<li>采样前启用一个延迟（需要查询具体需要多长）</li>
</ol>
<p><strong>注意</strong>：如果多路ADC需要同步开启，第一步和第三步可以通过 <em>同一条写入指令</em>（in one write instruction）来进行配置。因此，也就可以用同一条延迟指令来等待ADC上电启动。</p>
<h3 id="SOC操作原则"><a href="#SOC操作原则" class="headerlink" title="SOC操作原则"></a>SOC操作原则</h3><blockquote>
<p>Each SOC is a configuration set defining the single conversion of a single channel.</p>
</blockquote>
<p>注意上面这句话，<mark>每一个SOC都是一个定义着单通道转换器的配置集</mark>（Configuration Set）。</p>
<p>如果有需要，多个SOC可以配置于使用相同的触发器、通道 或 采样周期。使用相同的触发器来配置多个SOC的话，触发器可以生成一个转换序列（generate a sequence of conversions），同时相同的触发器和通道可以过采样（oversampling）。</p>
<img src="https://pic.islet.space/2021/07/image-20210730094148462.png" alt="image-20210730094148462"  />

<p>在SOC配置集中有三个可配置项：</p>
<ul>
<li><code>ADCSOCFLG1</code> 启动转换的触发源（the trigger source that starts the conversion），操作某个bit可以启动某个SOC，详见《TRM》P1519</li>
<li><code>CHSEL</code> 转换通道（the channel to convert），可取值范围为 <code>0h</code> ~ <code>Fh</code>，代表 ADC0 ~ ADC15</li>
<li><code>ACQPS</code> 捕获窗口/采样周期（the acquisition window duration），可取值范围为 <code>000h</code> ~ <code>1FFh</code> </li>
</ul>
<blockquote>
<p>Upon receiving the trigger configured for a soc, the wrapper will ensure that the specified channel is captured using the specified acquisition window duration.</p>
</blockquote>
<h4 id="ACQPS的计算"><a href="#ACQPS的计算" class="headerlink" title="ACQPS的计算"></a>ACQPS的计算</h4><p><strong>注意</strong>：Acquisition Window 和 ACQPS 不是同一个概念，Acquisition Window 就是下方所述的 <strong><em>S</em> 和 <em>H</em> 的持续时间</strong>。</p>
<p>参考ADC输入模型简图：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210730091825651.png" alt="image-20210730091825651"></p>
<p>采样周期和 ACQPS的关系如下：</p>
<div style="text-align: center; font-weight: 900; font-style: italic;">Acquisition window = (ACQPS + 1)∙(System Clock (SYSCLK) cycle time)</div>

<p>以下案例在求解采样周期的基础上，倒推 ACQPS 的设置：</p>
<p>为了能够正确读取ADC数据，ADC输入信号必须有足够的时间为 <strong>采样和保持电容</strong> <code>Ch</code>（the sample and hold capacitor）充电。通常来说，<em>S</em> 和 <em>H</em> 的持续时间的选择是为了使采样电容被充电到最终值的 ½ LSB 或者 ¼ LSB ，具体取决于可容忍的 settling 误差（tolerable settling error）。</p>
<p>可以用 RC settling 模块来确定所需的 settling 时间近似值。具体时间常数模型如下方公式：</p>
<div style="text-align: center;"><img src="https://pic.islet.space/2021/08/image-20210805180321634.png" alt="image-20210805180321634" style="zoom:100%;" /></div>

<p>所需时间常数的数量也由下面等式给出：</p>
<div style="text-align: center;"><img src="https://pic.islet.space/2021/08/image-20210805180508541.png" alt="image-20210805180508541" style="zoom:100%;" /></div>

<p>最终<em>S</em> 和 <em>H</em> 的持续时间如下方公式所示：</p>
<div style="text-align: center;"><img src="https://pic.islet.space/2021/08/image-20210805180522951.png" alt="image-20210805180522951" style="zoom:100%;" /></div>

<blockquote>
<p>ADC输入模块需要提供以下参数：</p>
<ul>
<li><code>n</code> = ADC 分辨率 (in bits)</li>
<li><code>RON</code> = ADC 采样开关电阻 (in Ohms)</li>
<li><code>CH</code> = ADC 采样电容 (in pF)</li>
<li><code>Cp</code> = ADC 通道寄生输入电容 (in pF)</li>
</ul>
<p>以下参数则取决于应用（硬件/软件）设计：</p>
<ul>
<li>settling error = tolerable settling error (in LSBs)</li>
<li>Rs = ADC 驱动电流源电阻值 (in Ohms)</li>
<li>CS = ADC 输入引脚上的 <em><strong>寄生电容值</strong></em> (in pF)</li>
</ul>
</blockquote>
<p>通过以下参数来说明计算方式：</p>
<ul>
<li>n = 12-bits</li>
<li>RON = 500Ω</li>
<li>CH = 12.5pF</li>
<li>Cp = 12.7pF</li>
<li>settling error = ¼ LSB</li>
<li>Rs = 180Ω</li>
<li>Cs = 150pF</li>
</ul>
<p>时间常数计算如下：</p>
<div style="text-align: center;"><img src="https://pic.islet.space/2021/08/image-20210805180544244.png" alt="image-20210805180544244" style="zoom:100%;" /></div>



<p>所需时间常数的数量如下：</p>
<div style="text-align: center;"><img src="https://pic.islet.space/2021/08/image-20210805180556088.png" alt="image-20210805180556088" style="zoom:100%;" /></div>

<p>最终结果：</p>
<div style="text-align: center; font-weight: 900;">37.8ns · 7.13 = 270ns</div>

<p>如果系统时间 <em><strong>SYSCLK</strong></em> 为 <code>100 MHz</code> ，周期为 <code>10ns</code> ，则 S和H的持续时间应该是  <code>270 ns/10 ns = 27.0 SYSCLKs</code>，即27个系统时钟周期，为ADC输入信号所要提供的充足的ACQPS应该至少是  <code>CEILING(27.0) – 1 = 26</code></p>
<p>While this gives a rough estimate of the required acquisition window, a better method would be to setup a circuit with the ADC input model, a model of the source impedance/capacitance, and any board parasitics in SPICE (or similar software) and simulate to verify that the sampling capacitor settles to the desired accuracy.</p>
<p>参数计算代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * HEADER FILES</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * DATA TYPE DEFINITION</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> ADCPARAM;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * MACRO DEFINITION</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADC_RESOLUTION 12  <span class="comment">//定义分辨率为12位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSB 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * GLOBAL PARAMETERS</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">// r for Resistance , c for Capacitance </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">adc_parameters</span>&#123;</span></span><br><span class="line">    <span class="keyword">short</span> resolution;  <span class="comment">//分辨率</span></span><br><span class="line">    ADCPARAM r_on;  <span class="comment">// ADC采样开关电阻</span></span><br><span class="line">    ADCPARAM c_hold;   <span class="comment">// ADC采样和保持电容</span></span><br><span class="line">    ADCPARAM c_parasitic;   <span class="comment">// ADC通道寄生输入电容</span></span><br><span class="line"></span><br><span class="line">    ADCPARAM settling_error;  <span class="comment">//可容忍的沉降误差</span></span><br><span class="line">    ADCPARAM r_source;  <span class="comment">//ADC驱动电流源上的电阻值</span></span><br><span class="line">    ADCPARAM c_source;  <span class="comment">//ADC输入引脚上的寄生电容值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * FUNCTION DECLARATION</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function">ADCPARAM <span class="title">timeConstanceCalc</span><span class="params">(ADCPARAM, ADCPARAM, ADCPARAM, ADCPARAM, ADCPARAM)</span></span>;</span><br><span class="line"><span class="function">ADCPARAM <span class="title">numberCalc</span><span class="params">(ADCPARAM, ADCPARAM, ADCPARAM, ADCPARAM, ADCPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * MAIN FUNCTIONS</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注意： 所有电容值单位为 pF， 所有电阻值单位为 Ω</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adc_parameters</span> <span class="title">ADC1</span>;</span></span><br><span class="line">    ADC1.resolution = ADC_RESOLUTION;  <span class="comment">// 不可修改</span></span><br><span class="line">    ADC1.r_on = <span class="number">500</span>;  <span class="comment">//不变</span></span><br><span class="line">    ADC1.c_hold = <span class="number">12.5</span>;  <span class="comment">//不变</span></span><br><span class="line">    ADC1.c_parasitic = <span class="number">12.7</span>;  <span class="comment">//不变</span></span><br><span class="line"></span><br><span class="line">    ADC1.settling_error = <span class="number">1</span>/<span class="number">4.0</span> *LSB;  <span class="comment">//不要写1/4 *LSB，会得出无限大的数据（inf）</span></span><br><span class="line">    ADC1.r_source = <span class="number">1000</span>;   <span class="comment">//实际使用1kΩ，原180</span></span><br><span class="line">    ADC1.c_source = <span class="number">10000</span>;     <span class="comment">//带入0.1uF计算，原150</span></span><br><span class="line"></span><br><span class="line">    ADCPARAM result = <span class="number">0</span>;</span><br><span class="line">    result = <span class="built_in">timeConstanceCalc</span>(ADC1.r_source, ADC1.r_on, ADC1.c_hold, ADC1.c_source, ADC1.c_parasitic) * <span class="built_in">numberCalc</span>(ADC1.resolution, ADC1.settling_error, ADC1.c_source, ADC1.c_parasitic, ADC1.c_hold);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ADC采样和保持的时间为&quot;</span>  &lt;&lt; result &lt;&lt; <span class="string">&quot;ns&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * FUNCTION DEFINITIONS</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function">ADCPARAM <span class="title">timeConstanceCalc</span><span class="params">(ADCPARAM Rs, ADCPARAM Ron, ADCPARAM Ch, ADCPARAM Cs, ADCPARAM Cp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( ( Rs + Ron ) * Ch + Rs * ( Cs + Cp ) ) /<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ADCPARAM <span class="title">numberCalc</span><span class="params">(ADCPARAM n, ADCPARAM se, ADCPARAM Cs, ADCPARAM Cp, ADCPARAM Ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">log</span>( <span class="built_in">exp2</span>(n) / se ) - <span class="built_in">log</span>( (Cs + Cp) / Ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h1 id="控制外设"><a href="#控制外设" class="headerlink" title="控制外设"></a>控制外设</h1><p>本系列芯片的控制外设包含 <strong>eCAP</strong>、<strong>HRCAP</strong>、<strong>ePWM</strong>、<strong>HRPWM</strong>、<strong>eQEP</strong> 和 <strong>SDFM</strong>。</p>
<p>根据《SPRU566N》表11 可知，ePWM 和 HRPWM 都是4型增强外设，具体功能可以参见《SPRUI33D》。</p>
<h2 id="ePWM"><a href="#ePWM" class="headerlink" title="ePWM"></a>ePWM</h2><p>ePWM是商业和工业控制电力系统的关键组成部分。这些系统包括 <u>数字电机控制</u>、<u>开关电源控制</u>、<u>不间断电源供应</u> 或 其他形式的电源转换。</p>
<p>ePWM这个大的外设模块（Module）组成，是由8个子模块（Submodule）构成的。所有的ePWM模块用数字尾缀来表示第几个ePWM模块，如 <code>ePWM1</code>、<code>ePWM3</code> 。每个ePWM模块又有两个输出，分别是 A 和 B，例如 <code>ePWM1A</code> 和 <code>ePWM1B</code> 。</p>
<p>ePWM模块通过一条时钟同步表（clock synchronization scheme）同步和串联在一起，形成可以统一操作的整体。此外，这个时钟同步表能够被扩展至 eCAP 外设使用。子模块的数量是由设备（设计）和实际使用需求决定的，每个子模块都能够支持单独操作。</p>
<p>ePWM 模块通过两个PWM输出（<code>EPWMxA</code> 和 <code>EPWMxB</code>）来组成一条完整的PWM通道。多路 ePWM被在一个设备内实现，几乎每一个ePWM通道实例都是相同的，只有一个例外。有些实例包括一个硬件扩展，可以更精确地控制PWM输出。这种扩展是高分辨率脉宽调制器（HRPWM），在第18.15节中有描述。每个ePWM模块都用一个以1开头的数值表示，例如，<code>ePWM1</code> 是系统中的第一个实例，<code>ePWM3</code> 是第三个实例，<code>ePWMx</code> 表示任何实例。</p>
<p>每一个ePWM模块都被连接至输入和输出信号。每一个ePWM模块都包含着8个子系统，并通过图18-2的方式连接至系统内部。</p>
<h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><p><em><strong>表 5-57</strong></em> 展示了PWM的时间要求，主要是 同步（Sync）/非同步（Async）/带输入验证（With input qualifier）的 <em><strong>同步输入脉冲宽度</strong></em>（Sync Input Pulse Width）的三种时间</p>
<p><em><strong>表 5-58</strong></em> 展示了PWM的开关特性，包括最小脉冲周期，同步输出脉冲宽度 和 t<span style="font-size: 0.6rem;">d(TZ-PWM)</span></p>
<p><em><strong>表 5-59</strong></em> </p>
<p><em><strong>表 18-21</strong></em> 展示了ePWM外设下的各寄存器（自《SPRUI33D》Page 1885）,<mark>约有81个寄存器</mark>。</p>
<p><em><strong>图 18-1</strong></em> 描述的是外围总线上的多个PWM模块，及输入信号和输出信号通路示例</p>
<p><em><strong>图 18-2</strong></em> 描述的是PWM模块下各子模块和信号连接方式（简图）</p>
<p><em><strong>图 5-58</strong></em> 描述的是ePWM内部的子模块和信号连接方式（结构图）</p>
<p><em><strong>图 5-59</strong></em></p>
<p><em><strong>图 5-60</strong></em> 为TB计数器同步链。</p>
<p><em><strong>图 5-61</strong></em> PWM高阻态时序特性</p>
<img src="https://pic.islet.space/2021/07/image-20210715140249937.png" alt="image-20210715140249937" style="zoom:80%;" />





<img src="https://pic.islet.space/2021/07/image-20210715141719524.png" alt="image-20210715141719524" style="zoom:80%;" />



<p><img src="https://pic.islet.space/2021/07/image-20210712104641579.png" alt="image-20210712104641579"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210712104655718.png" alt="image-20210712104655718"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210712104857729.png" alt="image-20210712104857729"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210712104928659.png" alt="image-20210712104928659"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210723095251220.png" alt="image-20210723095251220"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210723095318306.png" alt="image-20210723095318306"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210723095334783.png" alt="image-20210723095334783"></p>
<p>《TRM》P1841，简化过的ePWM模型：</p>
<p><img src="https://pic.islet.space/2021/08/image-20210802142302371.png" alt="image-20210802142302371"></p>
<p><img src="https://pic.islet.space/2021/08/image-20210802142447715.png" alt="image-20210802142447715"></p>
<h3 id="【-】Time-Base-Submodule"><a href="#【-】Time-Base-Submodule" class="headerlink" title="【#】Time-Base Submodule"></a>【#】Time-Base Submodule</h3><p><img src="https://pic.islet.space/2021/07/image-20210723083549303.png" alt="TB子模块的信号和寄存器"></p>
<p>PWM事件的周期被 <em><strong>TBPRD寄存器</strong></em> 和 <em><strong>TB计数器的模式</strong></em> 控制着。TB计数器的三种工作模式由 <em><strong>TB控制寄存器</strong></em> （<em>TBCTL</em>）控制，分别为 <strong>增计数</strong>（Up-Count）、<strong>减计数</strong>（Down-Count）和 <strong>增减计数</strong>（Up-Down-Count）。</p>
<p>影子周期寄存器（shadow period register）的内存地址（memory address）与活跃寄存器相同。<em><strong>TB控制寄存器</strong></em> （<em>TBCTL</em>）下的 <em><strong>PRDLD位</strong></em> 控制着要读写哪个寄存器，同时控制着是否使能影子寄存器，此时可分为 <em><strong>TB周期影子模式</strong></em>（Time-Base Period Shadow Mode） 或 <em><strong>TB周期即刻载入模式</strong></em>（Time-Base Period Immediate Load Mode）。</p>
<p>在TB计数器同步链中，<em><strong>EXTSYNC1</strong></em> 由 <em><strong>INPUTXBAR5</strong></em> 输入而得，<em><strong>EXTSYNC2</strong></em> 由 <em><strong>INPUTXBAR6</strong></em> 输入而得。而这些输入信号可以通过配置选择任意GPIO作为同步输入源。<mark>在使用 SYNCSEL 寄存器配置同步链传播路径时，应确保最长的路径不超过四个 ePWM/eCAP 模块。</mark></p>
<p>每个ePWM模块配置时都可以选择使用或者无视同步输入。如果 TBCTL[PHSEN] 位被设置了，且发生 <strong>同步输入脉冲</strong>（Synchronization Input Pulse）、 <strong>软件强制同步脉冲</strong>（Software Forced Synchronization Pulse） 或 <strong>数字比较事件同步脉冲</strong>（Digital Compare Event Synchronization Pulse） 三者之一的情况时，<strong>TB计数器</strong>（<strong>TBCTR</strong>）会自动加载 <strong>相位寄存器</strong>（<strong>TBPHS</strong>） 的内容。</p>
<h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p><em>Up-Down-Count Mode</em>: <strong>增减计数</strong>，TB计数器从0开始自增计数直到等于周期值（TBPRD值）。当与该值相等时，TB计数器会 <mark>逐步自减至0</mark>。接着周而复始，重新开始自增。</p>
<p><em>Up-Count Mode</em>: <strong>增计数</strong>，TB计数器从0开始自增计数直到等于周期值（TBPRD值）。当与该值相等时，TB计数器 <mark>直接归零</mark>，接着周而复始，重新开始自增。</p>
<p><em>Down-Count Mode</em>: <strong>减计数</strong>，TB计数器从周期值（TBPRD值）开始自减至0。当到达0值时，TB计数器直接重置TBPR值，接着周而复始，重新开始自减。</p>
<p><em>Active Register</em>: <strong>活跃寄存器</strong>，控制着硬件，并对硬件触发或调用（ causes or invokes）的事件进行响应。</p>
<p><em>Shadow Register</em>: <strong>影子寄存器</strong>，为活跃寄存器提供缓存，即临时存储空间（ temporary holding location）。不对任何控制硬件造成直接影响。 在关键时刻（at a strategic point in time ），影子寄存器的内容将会传递给活跃寄存器。可以避免因软件异步修改造成的崩溃或假操作（corruption or spurious operation）。</p>
<p><em>Time-Base Period Shadow Mode</em>: <strong>TB周期影子模式</strong>，当 <code>TBCTL[PRDLD]=0</code> 时，影子寄存器打开。对<em><strong>TBPRD</strong></em>内存地址的读写操作将会影响到影子寄存器。当TB计数器为零（<code>TBCTR=0x00</code>）时，影子寄存器的内容会被传输到活跃寄存器。<em><strong>TBCTL2</strong></em>[PRDLDSYNC] 位决定着同步时间。当且仅当 <em><strong>TBCTL</strong></em>[PRDLD] 值为0时，PRDLDSYNC位的值有效。默认情况下，影子寄存器开启。 通过配置 <strong>全局负载配置寄存器</strong>（<em><strong>GLDCFG</strong></em>）中对应的位，全局负载控制机制就能够和TB周期寄存器被一起使用。当全局复杂模式选通时，从影子寄存器到活跃寄存器的内容传输</p>
<p><em>Time-Base Period Immediate Load Mode</em>: <strong>TB周期即刻载入模式</strong>，当 <code>TBCTL[PRDLD]=1</code> 时，即刻载入模式开启。对TBPRD内存地址的读写操作将会直接载入到活跃寄存器。</p>
<p><em>Time-Base Clock Synchronization</em>: <strong>TB时钟同步</strong>，外设时钟使能寄存器（peripheral clock enable registers）里的 <em><strong>TBCLKSYNC</strong></em> 位 允许所有用户将所有已开启的ePWM模块同步至TB时钟（TBCLK）。开启时，所有已开启的模块时钟会与TBCLK的第一个上升沿对齐。为了完美地同步TBCLK，所有ePWM模块的预分频都要明确设置。 </p>
<p><em>Time-Base Counter Synchronization</em>: <strong>TB计数同步</strong>，每个ePWM模块都有一个 <strong>同步输入</strong>（SYNCI）、一个 <strong>同步输出</strong>（SYNCO） 和 一个 <strong>外设同步输出</strong>（SYNCPER）。</p>
<p><em>Synchronization Input Pulse</em>:  <strong>同步输入脉冲</strong>，当检测到输入同步脉冲时，相位寄存器的值被载入至计数器中。这个载入操作会在下一个有效的TB时钟（TBCLK）边沿发生。</p>
<p><em>Software Forced Synchronization Pulse</em>: <strong>软件强制同步脉冲</strong>，</p>
<p><em>Digital Compare Event Synchronization Pulse</em>: <strong>数字比较事件同步脉冲</strong>，</p>
<p>开启ePWM时钟的步骤如下：</p>
<ol>
<li>在 PCLKCRx 寄存器里，使能ePWM模块时钟</li>
<li>设置 <code>TBCLKSYNC = 0</code> </li>
<li>配置模块</li>
<li>设置 <code>TBCLKSYNC = 1</code> </li>
</ol>
<blockquote>
<p>CTR，Counter的缩写。</p>
</blockquote>
<h4 id="图表-1"><a href="#图表-1" class="headerlink" title="图表"></a>图表</h4><p><em><strong>图 18-6</strong></em> 展示了当TB计数器周期设置为4时，增计数、减计数 和 增减计数 三种模式下的PWM周期和频率的关系。时间自增的步长由从ePWM时钟分频而来的时基时钟（TBCLK）定义。</p>
<p><em><strong>表 18-2</strong></em> 是对关键TB信号的详细描述。</p>
<img src="https://pic.islet.space/2021/07/image-20210723090439017.png" alt="image-20210723090439017"  />



<div style="text-align: center;"><img src="https://pic.islet.space/2021/07/image-20210723104144586.png" alt="image-20210723104144586" style="zoom:60%;" /><img src="https://pic.islet.space/2021/07/image-20210723104124781.png" alt="image-20210723104124781" style="zoom:66.6%;" /></div>

<div style="text-align: center;"><img src="https://pic.islet.space/2021/07/image-20210723104110747.png" alt="image-20210723104110747" style="zoom:63%;" /><img src="https://pic.islet.space/2021/07/image-20210723104533742.png" alt="image-20210723104533742" style="zoom:55%;" /></div>



<img src="https://pic.islet.space/2021/07/image-20210723083704637.png" alt="image-20210723083704637" style="zoom:80%;" />



<h3 id="【-】Counter-Compare-Submodule"><a href="#【-】Counter-Compare-Submodule" class="headerlink" title="【#】Counter Compare Submodule"></a>【#】Counter Compare Submodule</h3><p>CC子模块， 以TB计数值为输入源。这个值被不断地拿来与CMPA/CMPB/CMPC/CMPD进行比较，当TB计数器的值与其中一个寄存器的值相等时CC子模块就会生成一个适当的事件。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210724100317179.png" alt="image-20210724100317179"></p>
<p>CC子模块的作用：</p>
<ul>
<li>通过CMPA/CMPB/CMPC/CMPD寄存器，基于可编程时间戳生成时间<ul>
<li>当 <code>CTR=CMPA</code> 时， TB计数器的值等于计数比较器A的值（TBCTR=CMPA）</li>
<li>当 <code>CTR=CMPB</code> 时， TB计数器的值等于计数比较器B的值（TBCTR=CMPB）</li>
<li>当 <code>CTR=CMPC</code> 时， TB计数器的值等于计数比较器C的值（TBCTR=CMPC）</li>
<li>当 <code>CTR=CMPD</code> 时， TB计数器的值等于计数比较器D的值（TBCTR=CMPD）</li>
</ul>
</li>
<li>如果用CMPA和CMPB对AQ子模块正确地配置，可以控制PWM的占空比</li>
<li>可以在PWM周期活跃时备份（shadows）新的比较值以防崩坏或错误</li>
</ul>
<p>CC子模块的内部信号通路结构示意如下图18-15。可以看出，CC子模块前一级是TB子模块，接收其时间信号。CC子模块不间断地对比 CMPx 和 TBCTR 的值，一旦符合要求，则输出结果给AQ子模块。所有CMPx的输出结果均会导向ET（事件触发器和中断），但是导向AQ子模块的只有 CMPA / CMPB。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210724102101254.png" alt="image-20210724102101254"></p>
<h3 id="【-】Action-Qualifier-Submodule"><a href="#【-】Action-Qualifier-Submodule" class="headerlink" title="【#】Action Qualifier Submodule"></a>【#】Action Qualifier Submodule</h3><p>AQ子模块在 <strong>波形结构</strong> 和 <strong>PWM生成</strong> 上扮演着重要的角色。它决定了哪个事件可以被转换为不同的动作类型（converted into various action types），进而产生 <em><strong>EPWMxA</strong></em> 和 <em><strong>EPWMxB</strong></em> 输出需要的开关波形（producing the required switched waveforms）。</p>
<p>AQ子模块控制着当特定事件发生时，ePWM外设的两条输出线（EPWMxA / EPWMxB）该如何进行输出。输入至AQ子模块的事件 会由 计数器方向（自增或自减）进一步限定。这允许在计数上升和计数下降阶段对输出进行独立操作。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210724082155433.png" alt="image-20210724082155433"></p>
<p><strong>AQ子模块的作用</strong>：</p>
<ul>
<li>根据以下（特定）事件 <em>限定并生成</em>（qualifying and generating）动作（包括 <strong>设置</strong>、<strong>清除</strong> 和 <strong>标记</strong>）:<ul>
<li>当 <code>CTR = PRD</code> ，TB计数器等于周期（TBCTR = TBPRD）</li>
<li>当 <code>CTR = ZERO</code> ，TB计数器等于0（TBCTR = 0x00）</li>
<li>当 <code>CTR = CMPA</code> ，TB计数器等于 计数比较器A （TBCTR = CMPA）</li>
<li>当 <code>CTR = CMPB</code> ，TB计数器等于 计数比较器B（TBCTR = CMPB）</li>
</ul>
</li>
<li>T1、T2事件：基于比较器（comparator）、跳闸（trip） 或 同步器（syncin）的触发事件</li>
<li>当这些事件同时发生时管理好它们的优先级</li>
<li>当TB计数器自增或自减时提供对事件的独立控制</li>
</ul>
<p>从下图18-21 或 表 18-3 中可以看出，AQ子模块的输入信号源除了TB时钟意外，剩下的触发事件有7种，分别是 PRD / ZERO / CMPA / CMPB / DIR / T1 / T2。只有前四种需要使用到TB计数器。软件强制动作（software forced action）是个非常有用的异步事件，由 <em><strong>AQSFRC</strong></em> 和 <em><strong>AQCSFRC</strong></em> 寄存器控制。</p>
<p><strong>注意</strong>：如果在影子模式下 <em><strong>CSFA</strong></em> 未被使用，必须配置 <em><strong>RLDCSF</strong></em> 位以关闭影子模式。</p>
<img src="https://pic.islet.space/2021/07/image-20210724083434622.png" alt="image-20210724083434622" style="zoom: 80%;" />

<img src="https://pic.islet.space/2021/07/image-20210724083824488.png" alt="image-20210724083824488" style="zoom:80%;" />



<p>对输出（EPWMxA / EPWMxB）可能施加（imposed）的动作如下：</p>
<ul>
<li><strong>置高</strong>（Set High）：将输出置高。</li>
<li><strong>置低</strong>（Clear Low）：将输出置低。</li>
<li><strong>切换</strong>（Toggle）：如果任一输出（EPWMxA / EPWMxB）被同时置高，则将它们置低。如果任一输出被同时置低，则将它们置高。</li>
<li><strong>无视</strong>（Do Nothing）：让输出保持与当前相同的电平，不做处理。虽然“无视”选项阻止了事件对输出的可能动作，但是这些事件仍然可以去触发中断和ADC的开启。</li>
</ul>
<p>输出（EPWMxA / EPWMxB）的动作需要分别单独指定（specified independently）。在特定输出上，所有或任一事件都可以被配置以生成动作。</p>
<p>比如说，<code>CTR=CMPA</code> 和 <code>CTR=CMPB</code> 都可以被配置到 <em><strong>EPWMxA</strong></em> 上。所有限定动作都可以通过控制寄存器被配置。</p>
<p>每一个符号代表着一个动作，就像是时间上的标记。某些动作在时间上是固定的（如，0和周期），而CMPA和CMPB动作是非固定的（moveable）且其时间位置可以通过CMPA/B寄存器来编程。</p>
<p>使用 <strong>无视</strong> 操作可以关闭或无效某个动作，无视动作是复位后的默认值。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210724090622329.png" alt="image-20210724090622329"></p>
<p>AQ触发事件源选择寄存器（AQTSRCSEL, Action Qualifier Trigger Event Source Selection register）被用于为T1/T2事件选择源。在AQ子模块中，一个trip/数字比较事件的T1/T2的选择和配置 与 Trip-zone子模块事件的配置 是相互独立的。特定的trip事件是不确定能否在TZ子模块里通过配置来触发trip动作的，但是相同事件是能够确定可以被配置于AQ子模块中，以生成T1/T2来控制PWM生成的。</p>
<p>PWM动作限定器（AQ）是可以在相同时间内接受一个以上事件的，此时，硬件会为事件排好优先级。优先级规则是，事件生成越晚，优先级越高，而且 <strong>软件强制事件</strong>（software forced event）拥有最高优先级。</p>
<p>增减计数模式下的动作限定事件优先级如下表18-4所示，优先级按数字从小到大依次递减，共分10级。</p>
<p><mark>优先级会因TB计数器的计数模式改变而改变。</mark> 但是从下表18-5和 18-6中可以看到，自增模式和自减模式下，只有7个优先级，在任一模式下，其相反动作的触发都不会被考虑，如在自减模式下，自增事件不会被考虑，自增模式下，自减事件不会被考虑。</p>
<p><strong>注意</strong>：CMPA或者CMPB是可以设置得比PRD还大的，此时需要考虑依据所处模式进行考虑，如表18-7所示。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210724092138218.png" alt="image-20210724092138218"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210724092919402.png" alt="image-20210724092919402"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210724092932350.png" alt="image-20210724092932350"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210724094334396.png" alt="image-20210724094334396"></p>
<p>图18-25 展示了如何使用TBCTR的增减计数模式来生成一个symmetric PWM波形。</p>
<img src="https://pic.islet.space/2021/07/image-20210724172530959.png" alt="image-20210724172530959" style="zoom:80%;" />





<h3 id="Dead-Band-Generator-Submodule"><a href="#Dead-Band-Generator-Submodule" class="headerlink" title="Dead-Band Generator Submodule"></a>Dead-Band Generator Submodule</h3><p>暂略</p>
<h3 id="PWM-Chopper-Submodule"><a href="#PWM-Chopper-Submodule" class="headerlink" title="PWM Chopper Submodule"></a>PWM Chopper Submodule</h3><p>暂略</p>
<h3 id="【-】Trip-Zone-Submodule"><a href="#【-】Trip-Zone-Submodule" class="headerlink" title="【#】Trip Zone Submodule"></a>【#】Trip Zone Submodule</h3><p>TZ子模块，每个ePWM模块都连接了6个 TZ<em>n</em>（TZ1 ~ TZ6） 信号 ， 其中：</p>
<ul>
<li>前三个信号来自于GPIO 复用</li>
<li>TZ4 来自于 带有 EQEP 模块设备的 反转（inverted）的 <em><strong>EQEPxERR</strong></em> 信号</li>
<li>TZ5 连接至了系统时钟故障（fail）逻辑</li>
<li>TZ6 来自于 CPU 的 EMUSTOP 输出</li>
</ul>
<p>这些信号指示了外部的故障或跳闸情况，并且可以对ePWM的输出进行编程，以便在故障发生时作出相应的反应。</p>
<img src="https://pic.islet.space/2021/07/image-20210724104412883.png" alt="image-20210724104412883" style="zoom:80%;" />



<p>TZ子模块的特点：</p>
<ul>
<li>错误输入TZ1 ~ TZ6 能够被高级地（flexibly）路由至（mapped to）任何ePWM模块</li>
<li>在出现错误时，输出（EPWMxA / EPWMxB）状态可以被强制指定为其中之一：<ul>
<li>置高</li>
<li>置低</li>
<li>高阻抗（High-impedance）</li>
<li>无动作（no action taken）</li>
</ul>
</li>
<li>为主要的 <strong>短路</strong> 或 <strong>过流</strong>（short circuits or over-current）提供 <strong>一次性错误</strong>（one-shot trip, OSHT）</li>
<li>为 <strong>限流操作</strong>（current limiting operation）提供 <strong>循环错误</strong>（cycle-by-cycle tripping）</li>
<li>基于 片上模拟比较模块输出 和/或 TZ1 至 TZ3 提供 数字比较错误（digital compare tripping）</li>
<li>每一个TZ输入和DC子模块 DCAEVT1/2 或 DCBEVT1/2 强制事件能够被定位于 一次性错误 或 循环错误上。</li>
<li>中断生成可用于任何一个TZ输入</li>
<li>软件强制错误也可用</li>
<li>如果不需要使用，TZ子模块也能够被完全屏蔽。</li>
</ul>
<h3 id="Event-Trigger-Submodule"><a href="#Event-Trigger-Submodule" class="headerlink" title="Event Trigger Submodule"></a>Event Trigger Submodule</h3><p>暂略</p>
<h3 id="Digital-Compare-Submodule"><a href="#Digital-Compare-Submodule" class="headerlink" title="Digital Compare Submodule"></a>Digital Compare Submodule</h3><p>暂略</p>
<h1 id="通信外设"><a href="#通信外设" class="headerlink" title="通信外设"></a>通信外设</h1><p>暂略</p>
<h1 id="新建项目（Step-by-step"><a href="#新建项目（Step-by-step" class="headerlink" title="新建项目（Step by step)"></a>新建项目（Step by step)</h1><h2 id="新建C28xx项目"><a href="#新建C28xx项目" class="headerlink" title="新建C28xx项目"></a>新建C28xx项目</h2><ol>
<li>选择新建 CCS 项目</li>
</ol>
<p><img src="https://pic.islet.space/2021/07/image-20210719094604082.png" alt="image-20210719094604082"></p>
<ol start="2">
<li>可暂时不选择具体芯片，选择 F28xx 系列即可，也可以选择 <code>28004x Piccolo</code>，在选择具体芯片。</li>
</ol>
<p><img src="https://pic.islet.space/2021/07/image-20210719094942412.png" alt="image-20210719094942412"></p>
<ol start="3">
<li>设置项目名称并保存。</li>
</ol>
<img src="https://pic.islet.space/2021/07/image-20210719094813670.png" alt="image-20210719094813670" style="zoom: 80%;" />

<h2 id="设置处理器选项"><a href="#设置处理器选项" class="headerlink" title="设置处理器选项"></a>设置处理器选项</h2><p>C2000系列编译器中，关于处理器选项，需要设置 <code>CLA</code>、 <code>FPU</code>、 <code>TMU</code>、 <code>IDIV</code> 和 <code>VCU</code> 这几个参数，其中《spru566n》全文关于 <code>IDIV</code> 的描述仅有 F28002x 和 2838x 支持，此处就默认 28004x 不支持（暂时先留空），其余支持项均可以在《spru566n》表11中查找到。</p>
<ul>
<li><code>IDIV</code> 是指 <em><strong>增强型整数除法</strong></em> ，enhanced integer division，也是快速整数除法，fast integer division。</li>
<li><code>FPU</code> 有 FPU32 / FPU64 / SOFTLIB 三种选项，其中如果设置了 <code>TMU</code> 和 <code>VCU</code>，则默认设置为 FPU32。</li>
</ul>
<p><img src="https://pic.islet.space/2021/07/image-20210719091534852.png" alt="image-20210719091534852"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210719090718448.png" alt="image-20210719090718448"></p>
<p>各选项设置如下：</p>
<img src="https://pic.islet.space/2021/07/image-20210719094501999.png" alt="image-20210719094501999" style="zoom:67%;" />



<h2 id="设置头文件选项"><a href="#设置头文件选项" class="headerlink" title="设置头文件选项"></a>设置头文件选项</h2><p>向头文件包含设置中，添加几条 c2000Ware 套件安装包提供的支持库信息：</p>
<p><code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\driverlib\f28004x\driverlib</code></p>
<p><code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\device_support\f28004x\common\include</code></p>
<p><code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\device_support\f28004x\headers\include</code></p>
<p><strong>注意</strong>：以上路径信息仅供参考，具体路径仍需依据套件安装地址来修改。</p>
<img src="https://pic.islet.space/2021/07/image-20210719095520123.png" alt="image-20210719095520123" style="zoom:80%;" />



<img src="https://pic.islet.space/2021/07/image-20210719095713314.png" alt="image-20210719095713314" style="zoom:80%;" />



<p>最后一共有4条信息：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210719095934052.png" alt="image-20210719095934052"></p>
<h2 id="设置文件搜索路径"><a href="#设置文件搜索路径" class="headerlink" title="设置文件搜索路径"></a>设置文件搜索路径</h2><p>先在 <span style="font-style: italic; color: #aaa; font-weight: 900;">Add &lt;dir&gt; to library search path (–search_path, -i)</span> 中添加可以处理链接器的（.cmd）文件路径 <code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\device_support\f28004x\common\cmd</code>，然后将 <span style="font-style: italic; color: #aaa; font-weight: 900;">Include library file or command files as input (–input, -I)</span> 中的 <code>libc.a</code> 删除，添加具体的链接器全名 <code>28004x_generic_ram_lnk.cmd</code>  和 <code>rts2800_fpu32.lib</code> 。</p>
<img src="https://pic.islet.space/2021/07/image-20210719100817504.png" alt="image-20210719100817504" style="zoom:80%;" />



<h2 id="设置代码启动点"><a href="#设置代码启动点" class="headerlink" title="设置代码启动点"></a>设置代码启动点</h2><p>此步骤为 <em><strong>可选</strong></em> 步骤，在 <span style="font-style: italic; color: #aaa; font-weight: 900;">Advance Options</span> 下的 <span style="font-style: italic; color: #aaa; font-weight: 900;">Symbol Management</span> 中设置 <em>程序入口点</em>  <code>code_start</code> 。</p>
<p><strong>注意</strong>：本步骤是用于设置编译参数的，可以在完全新建项目的时候不操作本步骤，此时进行编译 <code>Build Project</code> 的话也是可以编译成功的。</p>
<img src="https://pic.islet.space/2021/07/image-20210719101229117.png" alt="image-20210719101229117" style="zoom:80%;" />



<blockquote>
<p><em>code_start</em>  is  the  first  code  that  is  executed  after  exiting  the  boot  ROM  code  for  the example f28004x projects.  The projects are setup such that the codegen entry point is also set to the code start label using linker options.  The code start code will automatically re-direct the execution to <code>_c_init00</code>.</p>
</blockquote>
<h2 id="设置字体集"><a href="#设置字体集" class="headerlink" title="设置字体集"></a>设置字体集</h2><p>此步骤为 <em><strong>可选</strong></em> 步骤，在 <span style="font-style: italic; color: #aaa; font-weight: 900;">Resource</span> 下可以设置 <em>字体编码</em> 和 <em>回行</em> 格式。</p>
<img src="https://pic.islet.space/2021/07/image-20210719101527907.png" alt="image-20210719101527907" style="zoom:80%;" />



<h2 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h2><p>添加文件有两种形式，一种是以链接形式添加，编译时不会修改到源文件。另一种是直接添加至项目中（复制副本 或 新建文件）。</p>
<ol>
<li>先用官方提供的文件进行预试添加和调试。在项目上右击选择 <code>Add Files</code> ，以 <em><strong>链接形式</strong></em> 添加文件：</li>
</ol>
<ul>
<li><code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\driverlib\f28004x\driverlib\ccs\Debug\driverlib.lib</code></li>
<li><code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\device_support\f28004x\common\source\device.c</code></li>
<li><code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\device_support\f28004x\common\source\f28004x_codestartbranch.asm</code></li>
</ul>
<ol start="2">
<li>在项目名上右键点击 Add Files。</li>
</ol>
<p><img src="https://pic.islet.space/2021/07/image-20210719102326890.png" alt="image-20210719102326890"></p>
<ol start="3">
<li>选择对应路径文件。</li>
</ol>
<img src="https://pic.islet.space/2021/07/image-20210719102359274.png" alt="image-20210719102359274" style="zoom:80%;" />

<ol start="4">
<li>选择添加方式 Link to files ，可以看到项目中已经添加了一个文件。</li>
</ol>
<div style="text-align: center;"><img src="https://pic.islet.space/2021/07/image-20210719102420155.png" alt="image-20210719102420155" style="zoom:80%;" /> <img src="https://pic.islet.space/2021/07/image-20210719102438745.png" alt="image-20210719102438745" style="zoom:80%;" /></div>

<ol start="5">
<li>到此处后仍不能进行 <code>Build Project</code> ，会报错 <code>error #10234-D: unresolved symbols remain c28</code>，需要执行下一步，将 <code>main.c</code> 以 <em><strong>新文件形式</strong></em> 添加进去。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;device.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize device clock and peripherals</span></span><br><span class="line">    Device_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize GPIO and configure the GPIO pin as a push-pull output</span></span><br><span class="line">    Device_initGPIO();</span><br><span class="line">    GPIO_setPadConfig(DEVICE_GPIO_PIN_LED1, GPIO_PIN_TYPE_STD);</span><br><span class="line">    GPIO_setDirectionMode(DEVICE_GPIO_PIN_LED1, GPIO_DIR_MODE_OUT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize PIE and clear PIE registers. Disables CPU interrupts.</span></span><br><span class="line">    Interrupt_initModule();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the PIE vector table with pointers to the shell Interrupt</span></span><br><span class="line">    <span class="comment">// Service Routines (ISR).</span></span><br><span class="line">    Interrupt_initVectorTable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable Global Interrupt (INTM) and realtime interrupt (DBGM)</span></span><br><span class="line">    EINT;</span><br><span class="line">    ERTM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop Forever</span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="comment">// Turn on LED</span></span><br><span class="line">        GPIO_writePin(DEVICE_GPIO_PIN_LED1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Delay for a bit.</span></span><br><span class="line">        DEVICE_DELAY_US(<span class="number">500000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Turn off LED</span></span><br><span class="line">        GPIO_writePin(DEVICE_GPIO_PIN_LED1, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Delay for a bit.</span></span><br><span class="line">        DEVICE_DELAY_US(<span class="number">500000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="项目编译"><a href="#项目编译" class="headerlink" title="项目编译"></a>项目编译</h2><p>修改完之后进行编译 Build Project ，会报错 <em><strong>内存不足</strong></em>，信息如下：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:/ti/c2000Ware/C2000Ware_2_01_00_00/device_support/f28004x/common/<span class="built_in">cmd</span>/<span class="number">28004</span>x_generic_ram_lnk.<span class="built_in">cmd</span>&quot;, line <span class="number">81</span>: error #<span class="number">10099</span>-D: program will <span class="keyword">not</span> fit into available memory.  run placement with alignment/blocking fails <span class="keyword">for</span> section &quot;.stack&quot; size <span class="number">0</span>x400 page <span class="number">1</span>.  Available memory ranges:</span><br><span class="line">   RAMM1        size: <span class="number">0</span>x3f8        unused: <span class="number">0</span>x3f8        max hole: <span class="number">0</span>x3f8     </span><br></pre></td></tr></table></figure>

<p>以上错误信息的大意是，软件需要使用到的 <strong>堆</strong> <code>.stack</code> 的大小是 <code>0x400</code> 而 <code>RAMM1</code> 的大小只有 <code>0x3f8</code> 。</p>
<p>从错误提示中看到报错的文件名，打开在 <strong>设置文件搜索路径</strong> 中添加的 <code>28004x_generic_ram_lnk.cmd</code> 文件，已知TI公司利用 <code>.cmd</code> 文件来描述芯片内部地址，打开该文件并搜索可以看到 <code>RAMM1</code> 的确大小不足 <code>0x40</code>，且此时 <code>RAMM1_RSVD</code> 并未被使用，适当修改 <code>RAMM1</code> 的地址长度，注意不要和其他地址长度重叠即可。</p>
<img src="https://pic.islet.space/2021/07/image-20210719110002751.png" alt="image-20210719110002751" style="zoom:80%;" />

<p>重新编译即可成功。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210719111024816.png" alt="image-20210719111024816"></p>
<h1 id="评估板硬件连接"><a href="#评估板硬件连接" class="headerlink" title="评估板硬件连接"></a>评估板硬件连接</h1><p>TI官方的评估板型号为 LAUNCHXL-F280049C （如下示），支持使用JTAG连接与PC进行通信，关于评估板的手册文档如<a target="_blank" rel="noopener" href="https://www.ti.com/lit/spruii7">《SPRUII7》</a>所示。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210726152918902.png" alt="image-20210726152918902"></p>
<p>连接完毕之后，设备管理器 会出现如下图所示硬件：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210726154218244.png" alt="image-20210726154218244"></p>
<div style="text-align: center; font-weight: 900;">图 设备管理器界面</div>



<p>本评估板自带了XDS110接口，只需要使用USB mini 线和PC进行，并在项目文件路径 <code>targetConfigs\TMS320F280049C_LaunchPad.ccxml</code> 文件下确保连接器和设备正确即可。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210726153612834.png" alt="image-20210726153612834"></p>
<div style="text-align: center; font-weight: 900;">图 Project Explorer窗口下的文件路径</div>



<p><img src="https://pic.islet.space/2021/07/image-20210726153524140.png" alt="image-20210726153524140"></p>
<div style="text-align: center; font-weight: 900;">图 配置文件下的连接器配置</div>



<p>在<code>.ccxml</code> 文件中进行修改，点击下方的 <em>Advanced</em>，然后选择 <code>cJTAG(1149.7)2-pin advance mode</code>，然后 <em>save</em> 保存即可。具体操作如下图：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210726155434636.png" alt="image-20210726155434636"></p>
<div style="text-align: center; font-weight: 900;">图 选择cJTAG连接方式</div>



<p><img src="https://pic.islet.space/2021/07/image-20210726160136365.png" alt="image-20210726160136365"></p>
<div style="text-align: center; font-weight: 900;">图 点击测试按钮进行连接测试</div>



<h1 id="F28004x-API指南"><a href="#F28004x-API指南" class="headerlink" title="F28004x API指南"></a>F28004x API指南</h1><p>截止2020年7月21日，最新版 <a target="_blank" rel="noopener" href="https://code.islet.space/TI/f28004x/3_04/intro.html">F28004x API指南 3.04版</a> 已上传。可以直接在联网电脑上打开，使用Google chrome浏览器可以右键翻译查阅。</p>
<h2 id="文件组织概述"><a href="#文件组织概述" class="headerlink" title="文件组织概述"></a>文件组织概述</h2><p>以下是外围驱动库源代码的组织概览。</p>
<ul>
<li>{driverlib} - 此目录包含驱动程序的源代码。</li>
<li>{driverlib/inc/} - 此目录包含用于直接寄存器访问编程模型的外设、中断和寄存器访问头文件。</li>
<li>{hw_*.h} - 头文件，每个外设一个，描述每个外设的所有寄存器和这些寄存器中的位域。驱动程序使用这些头文件直接访问外设，应用程序代码可以使用这些头文件绕过外设驱动程序库 API。</li>
</ul>
<h2 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h2><p>外设驱动程序库支持两种编程模型：<em><strong>直接寄存器访问模型</strong></em> 和 <em><strong>软件驱动程序模型</strong></em>。根据应用程序的需要或开发人员所需的编程环境，每个模型都可以单独使用或组合使用。</p>
<p>每种编程模型都有优点和缺点。与使用软件驱动程序模型相比，<mark>使用直接寄存器访问模型通常会产生更小、更高效的代码</mark>。然而，直接寄存器访问模型<mark>需要详细了解每个寄存器和位域的操作，以及它们的相互作用和外围设备正常操作所需的任何顺序</mark>；<mark>软件驱动程序模型</mark>使开发人员与这些细节更加隔绝，<mark>通常需要更少的时间来开发应用程序</mark>。软件驱动程序模型还产生了<mark>更具可读性的代码</mark>。</p>
<h1 id="F28004x-伪操作"><a href="#F28004x-伪操作" class="headerlink" title="F28004x 伪操作"></a>F28004x 伪操作</h1><p>在 <code>F28004x_device.h</code> 文件中包含一部分伪操作，参考《SPRU430F》做出解释</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  EINT   __asm(<span class="meta-string">&quot; clrc INTM&quot;</span>)   <span class="comment">//INTM置0，打开（enable）中断</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  DINT   __asm(<span class="meta-string">&quot; setc INTM&quot;</span>)   <span class="comment">//INTM置1，关闭（disable）中断</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ERTM   __asm(<span class="meta-string">&quot; clrc DBGM&quot;</span>)   <span class="comment">//打开调试模式（Debug Mode）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  DRTM   __asm(<span class="meta-string">&quot; setc DBGM&quot;</span>)   <span class="comment">//关闭调试模式（Debug Mode）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  EALLOW __asm(<span class="meta-string">&quot; EALLOW&quot;</span>)   <span class="comment">//打开保护区域写入权限（Enable Write Access to Protected Space）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  EDIS   __asm(<span class="meta-string">&quot; EDIS&quot;</span>)   <span class="comment">//关闭保护区域写入权限（Disable Write Access to Protected Space）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ESTOP0 __asm(<span class="meta-string">&quot; ESTOP0&quot;</span>)   <span class="comment">//Emulation Stop 0</span></span></span><br></pre></td></tr></table></figure>



<p>以下为《SPRU430F》第107 ~ 113页提供的伪操作指令合集。</p>
<DIV style="text-align: center;"><img src="https://pic.islet.space/2021/07/image-20210721145040598.png" alt="image-20210721145040598" style="zoom: 67%;" /><img src="https://pic.islet.space/2021/07/image-20210721145100629.png" alt="image-20210721145100629" style="zoom:67%;" /></DIV>

<DIV style="text-align: center;"><img src="https://pic.islet.space/2021/07/image-20210721145123473.png" alt="image-20210721145123473" style="zoom:67%;" /><img src="https://pic.islet.space/2021/07/image-20210721145138283.png" alt="image-20210721145138283" style="zoom:67%;" /></DIV>

<DIV style="text-align: center;"><img src="https://pic.islet.space/2021/07/image-20210721145157425.png" alt="image-20210721145157425" style="zoom:67%;" /><img src="https://pic.islet.space/2021/07/image-20210721145226082.png" alt="image-20210721145226082" style="zoom:67%;" /></DIV>

<DIV style="text-align: center;"><img src="https://pic.islet.space/2021/07/image-20210721145242594.png" alt="image-20210721145242594" style="zoom:67%;" /></DIV>



<h1 id="C2000Ware"><a href="#C2000Ware" class="headerlink" title="C2000Ware"></a>C2000Ware</h1><p>C2000Ware是C28系列芯片的IDE组成部分，开发过程一共安装了两个版本，2.01版与3.04版，<marK>两者的文件结构基本一致</mark>，包括 <u>样例应用</u>、<u>头文件存放路径</u> 等基本一致，不一致的地方是文件内容，包括 <u>例程的增删</u> 和 <u>说明文档的更新</u>。始终不变的是C2000Ware的例程类别，总共有两种，分别在两个路径下：</p>
<ul>
<li><code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\driverlib\f28004x\examples</code>，存放的是 <em><strong>驱动库样例应用</strong></em>（Driver Library Example Applications），是以驱动及其案例来进行代码编写的，每个project都可能会涉及许多外设，因此使用前需要先阅读相关文档去了解该案例的开发目标，再结合实际进行修改。</li>
<li><code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\device_support\f28004x\examples</code>， 存放的是 <em><strong>位域样例应用</strong></em>（Bit-Field Example Applications），是以最小外设功能为目标的代码编写过程，并不是以project作为分类单元的，而是以外设为分类方法，每个外设的某个细节功能作为代码间的区别。</li>
</ul>
<p><strong>例如</strong>：同样是了解PWM外设的使用案例，从 <em><strong>驱动库样例应用</strong></em>（3.04版） 中能找到的案例只有3个：<code>boostxl_afe031_f28004x_pwmmode</code>、<code>hrpwm</code> 和 <code>adc_ex1_soc_epwm</code>，具体如何使用，使用到PWM里的何种功能并不能从项目案例中直接看出来。但是从 <em><strong>位域样例应用</strong></em>（3.04版） 中，可以找到13个PWM下的应用：<code>trip_zone</code> / <code>updown_aq</code> / <code>synchronization</code> / <code>digital_compare</code> / <code>digital_compare_event_filter</code> / <code>valley_switching</code> / <code>edge_filter</code> / <code>deadband</code> / <code>dma</code> / <code>chopper</code> / <code>configure_signal</code> / <code>monoshot_mode</code> / <code>up_aq</code> 。</p>
<blockquote>
<p><em>PS</em>：以上信息因C2000Ware版本不同而不同。</p>
</blockquote>
<p>以上信息，从《F28004x_DEV_USER_GUIDE》中也可以查看到，理清套件下的文件结构需要阅读的文件有两个，但在3.04版本的C2000Ware中未提供：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://code.islet.space/TI/f28004x/docs/F28004x_DriverLib_Users_Guide.pdf">《F28004x_DriverLib_Users_Guide》</a></li>
<li><a target="_blank" rel="noopener" href="https://code.islet.space/TI/f28004x/docs/F28004x_DEV_USER_GUIDE.pdf">《F28004x_DEV_USER_GUIDE》</a></li>
</ol>
<p>2.01与3.04版本都提供了网页版的手册，可以在对应 <code>\docs\</code> 文件夹下查阅。推荐使用网页版 <a target="_blank" rel="noopener" href="https://code.islet.space/TI/f28004x/3_04/index.html">API指南</a> 进行函数原型速查。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210721154709745.png" alt="image-20210721154709745"></p>
<div style="text-align: center; font-weight: 900;">图 3.04版本函数的搜索查阅</div>



<h1 id="高频逆变器开发"><a href="#高频逆变器开发" class="headerlink" title="高频逆变器开发"></a>高频逆变器开发</h1><p><strong>逆变器</strong>，即将直流DC变换为交流AC的过程。利用 DSP输出波形，控制接入高压直流电的（高位 和 地位）两个IGBT输出正向和反向两种电压，形成交流AC。</p>
<p>逆变电路根据直流侧电源的性质不同（电压源/电流源）分为两种类别： <strong>电压型逆变电路</strong> 和 <strong>电流型逆变电路</strong>。</p>
<blockquote>
<p>电压源逆变电路的特点：</p>
<ol>
<li>直流侧为电压源，或并联有大电容，相当于电压源。直流侧电压基本无脉动，直流回路呈现低阻抗。</li>
<li>由于直流电压源的钳位作用，交流侧输出电压波形为矩形波，且与负载阻抗角无关。而交流侧输出电流波形与相位因负载阻抗情况的不同而不同。</li>
<li>当交流侧为阻感负载时需要提供无功功率，直流侧电容起缓冲无功能能量的作用。为了给交流侧向直流侧反馈的无功能量提供通道，逆变桥各臂都并联了 反馈二极管。</li>
</ol>
</blockquote>
<p><strong>单相电压型逆变电路</strong> 可以根据变换出来的波形分为 <strong>半桥</strong> 或 <strong>全桥</strong>，即 <strong>单相半桥变压型逆变电路</strong> 和 <strong>单相全桥变压型逆变电路</strong>。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210719162954288.png" alt="image-20210719162954288"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210719162958021.png" alt="image-20210719162958021"></p>
<p><strong>具体为</strong>：利用型号为 <code>TMS320F280041</code> 芯片的GPIO（最高输出频率为25MHz）输出一个30KHz的PWM波形，需要使用到 ePWM外设。使用官方C2000套件示例中提供的 <code>ePWM6</code> 案例进行开发，输出高位和低位两个幅频合适的波形后，接到型号为 <code>2EDL05I06PF</code> 的驱动上，由驱动控制型号为 <code>IKW50N65WR5</code> 的IGBT 高频开断。</p>
<h2 id="工作目标"><a href="#工作目标" class="headerlink" title="工作目标"></a>工作目标</h2><ol>
<li>使用内源时钟，使芯片工作在100Mhz</li>
<li>输出占空比为50%的PWM波形，频率在30KHz</li>
<li>采集输出的波形和IGBT输出的波形（可能需要检测相位和波纹）</li>
<li>完成过零饱和电压检测</li>
</ol>
<p><img src="https://pic.islet.space/2021/07/image-20210719160255497.png" alt="image-20210719160255497"></p>
<div style="text-align: center; font-weight: 900;">图 占空比为20%的测试波形</div>





<h2 id="PLL设置"><a href="#PLL设置" class="headerlink" title="PLL设置"></a>PLL设置</h2><ul>
<li> <code>TMS320F280041</code> 的外部晶振输入频率 f<span style="font-size: 0.8rem;">XTAL</span> 在 10 ~ 20 MHz 之间，自身工作频率f<span style="font-size: 0.8rem;">SYSCLK</span> 在 2 ~ 100MHz之间。</li>
</ul>
<p>以下为工作频率设置的样例，利用内源时钟 <code>10MHz</code> ，产生芯片满负工作频率 <code>100MHz</code> ：</p>
<img src="https://pic.islet.space/2021/07/image-20210715170724177.png" alt="image-20210715170724177" style="zoom:67%;" />

<p>本系统采用10MHz的内源时钟 <em><strong>INTOSC2</strong></em> 作为 <em><strong>OSCCLK</strong></em>，其配置方法（包括设置公式和函数原型）都已在前文详细描述和记录，请参考该代码。</p>
<h2 id="ePWM-1"><a href="#ePWM-1" class="headerlink" title="ePWM"></a>ePWM</h2><p>以下为两个版本下案例所给的 <code>main()</code>函数的流程对比。</p>
<p>左侧用的是Bitfield模式，右边用的是driver-lib模式。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210722084618101.png" alt="image-20210722084618101"></p>
<div style="text-align: center; font-weight: 900;">图 新旧版本main()函数流程对比</div>

<p>同样是将中断重新映射至ISR函数里，下图左侧是2.01版本下的driver-lib模式，右侧是3.04bit-field模式。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210721154450124.png" alt="image-20210721154450124"></p>
<div style="text-align: center; font-weight: 900;">图 不同的调用配置方法</div>







<h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><h4 id="ePWM外设定义"><a href="#ePWM外设定义" class="headerlink" title="ePWM外设定义"></a>ePWM外设定义</h4><p>在Driver-Lib的 <code>&lt;f28004x_globalVariabledefs.c&gt;</code> 中，提供了ePWM下各模块的定义，如下面代码所示，定义了 外设 ePWM1所有的寄存器（结构体）<code>EPwm1Regs</code> ，是EPWM_REGS的结构体实例。</p>
<p><strong>使用方法</strong>：使用该外设下的寄存器时直接按照结构体变量的方法使用即可，如 <code>EPwm1Regs.TBPRD = EPWM1_TIMER_TBPRD</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> DATA_SECTION(<span class="meta-string">&quot;EPwm1RegsFile&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> DATA_SECTION(EPwm1Regs,<span class="meta-string">&quot;EPwm1RegsFile&quot;</span>);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">EPWM_REGS</span> <span class="title">EPwm1Regs</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> DATA_SECTION(<span class="meta-string">&quot;EPwm2RegsFile&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> DATA_SECTION(EPwm2Regs,<span class="meta-string">&quot;EPwm2RegsFile&quot;</span>);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">EPWM_REGS</span> <span class="title">EPwm2Regs</span>;</span></span><br></pre></td></tr></table></figure>









<h4 id="设置上下桥"><a href="#设置上下桥" class="headerlink" title="设置上下桥"></a>设置上下桥</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPWM1_TIMER_TBPRD  400  <span class="comment">//设置总周期为400，CMPA和CMPB占比一致时，占空比为50%</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPWM1_CMPA         200  <span class="comment">//高边占比</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPWM1_CMPB         200  <span class="comment">//低编占比</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPWM_CMP_UP        0x1  <span class="comment">//置高</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPWM_CMP_DOWN      0x0  <span class="comment">//置低</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPWM1B_SPACE_COMPARE 229</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPWM1A_SPACE_COMPARE 118</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPWM1B_MARK_COMPARE  252</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPWM1A_MARK_COMPARE  128</span></span><br></pre></td></tr></table></figure>



<h4 id="初始化外设"><a href="#初始化外设" class="headerlink" title="初始化外设"></a>初始化外设</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EPWM6_Init</span><span class="params">()</span></span>&#123;  <span class="comment">//使用高分辨率PWM</span></span><br><span class="line">    EALLOW; <span class="comment">//打开保护区域写入权限</span></span><br><span class="line">    EPwm6Regs.HRMSTEP.bit.HRMSTEP = <span class="number">55</span>;   <span class="comment">//设置步长为55</span></span><br><span class="line">    CpuSysRegs.PCLKCR0.bit.HRPWM = <span class="number">1</span>;   <span class="comment">//打开HRPWM的时钟</span></span><br><span class="line">    EDIS;  <span class="comment">//关闭保护区域写入权限</span></span><br><span class="line"></span><br><span class="line">    EPwm6Regs.TBPRD = EPWM1_TIMER_TBPRD;       <span class="comment">// 设置TBCLK的总周期为380，前面已宏定义过</span></span><br><span class="line">    EPwm6Regs.TBPHS.bit.TBPHS = <span class="number">0x0000</span>;        <span class="comment">// 初始化相位为0</span></span><br><span class="line">    EPwm6Regs.TBCTR = <span class="number">0x0000</span>;                  <span class="comment">// 清空TB计数器</span></span><br><span class="line"></span><br><span class="line">    EPwm6Regs.CMPA.bit.CMPA = EPWM1_CMPA;    <span class="comment">// 设置A比较值</span></span><br><span class="line">    EPwm6Regs.CMPB.bit.CMPB = EPWM1_CMPB;    <span class="comment">// 设置B比较值</span></span><br><span class="line"></span><br><span class="line">    EPwm6Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; <span class="comment">// 设置TB计数模式为增减计数模式</span></span><br><span class="line">    EPwm6Regs.TBCTL.bit.PHSEN = TB_DISABLE;        <span class="comment">// 关闭相位载入</span></span><br><span class="line">    EPwm6Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_DISABLE;<span class="comment">// 关闭TBCLK的时钟同步</span></span><br><span class="line">    EPwm6Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1;       <span class="comment">// Clock ratio to SYSCLKOUT</span></span><br><span class="line">    EPwm6Regs.TBCTL.bit.CLKDIV = TB_DIV1;</span><br><span class="line">    EPwm6Regs.TBCTL.bit.FREE_SOFT = <span class="number">0x03</span>;</span><br><span class="line"></span><br><span class="line">    EPwm6Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW;   <span class="comment">//安装影子寄存器给高边</span></span><br><span class="line">    EPwm6Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW;   <span class="comment">//安装影子寄存器给低边</span></span><br><span class="line">    EPwm6Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO_PRD; <span class="comment">// 初始化为0</span></span><br><span class="line">    EPwm6Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO_PRD; <span class="comment">// 初始化为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//TZCTL[TZA] = 2: 错误事件发生时，EPWM1A会被强制置低</span></span><br><span class="line">    EPwm6Regs.TZCTL.bit.TZA = <span class="number">2</span>;</span><br><span class="line">    EPwm6Regs.TZCTL.bit.DCAEVT1 = <span class="number">3</span>;</span><br><span class="line">    EPwm6Regs.TZCTL.bit.DCAEVT2 = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// TZCTL[TZB] = 2:错误事件发生时，EPWM1B会被强制置低</span></span><br><span class="line">    EPwm6Regs.TZCTL.bit.TZB = <span class="number">2</span>;</span><br><span class="line">    EPwm6Regs.TZCTL.bit.DCBEVT1 = <span class="number">3</span>;</span><br><span class="line">    EPwm6Regs.TZCTL.bit.DCBEVT2 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    EPwm6Regs.AQCTLA.bit.CAU = AQ_SET;            <span class="comment">// 设置PWM1A给事件A，增计数</span></span><br><span class="line">    EPwm6Regs.AQCTLA.bit.CAD = AQ_CLEAR;          <span class="comment">// 清除PWM1A给事件A，减计数</span></span><br><span class="line">    EPwm6Regs.AQCTLB.bit.CBU = AQ_SET;            <span class="comment">// 设置PWM1B给事件B，增计数</span></span><br><span class="line">    EPwm6Regs.AQCTLB.bit.CBD = AQ_CLEAR;          <span class="comment">// 清除PWM1B给事件B，减计数</span></span><br><span class="line"></span><br><span class="line">    EPwm6Regs.ETSEL.bit.INTEN = <span class="number">0</span>;                <span class="comment">// 关闭中断</span></span><br><span class="line"></span><br><span class="line">    EALLOW;</span><br><span class="line">    EPwm6Regs.HRCNFG.bit.HRLOAD = <span class="number">2</span>;   <span class="comment">//安装HRPWM</span></span><br><span class="line">    EPwm6Regs.HRCNFG.bit.AUTOCONV = <span class="number">1</span>;</span><br><span class="line">    EPwm6Regs.HRCNFG.bit.EDGMODE = <span class="number">3</span>;</span><br><span class="line">    EPwm6Regs.HRPCTL.bit.HRPE = <span class="number">1</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码里总结出下面配置步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">配置开始 --&gt; 配置TBCLK --&gt; 配置影子寄存器ShadowRegister --&gt; 配置CMP --&gt; 配置TripZone --&gt; 配置AactionQualifier --&gt; 配置ePWM中断 --&gt; 配置结束</span><br></pre></td></tr></table></figure>



<p>理解完配置思路和子模块后，简化该配置步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">配置开始 --&gt; 配置TB子模块 --&gt; 配置CC子模块 --&gt; 配置TZ子模块 --&gt; 配置AQ子模块 --&gt; 配置ePWM中断 --&gt; 配置结束</span><br></pre></td></tr></table></figure>











<p>初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initEPWM1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    EPWM_setTimeBaseCounterMode(myEPWM1_BASE, EPWM_COUNTER_MODE_UP);</span><br><span class="line">    EPWM_setTimeBasePeriod(myEPWM1_BASE, EPWM1_TIMER_TBPRD);</span><br><span class="line">    EPWM_disablePhaseShiftLoad(myEPWM1_BASE);</span><br><span class="line">    EPWM_setPhaseShift(myEPWM1_BASE, <span class="number">0U</span>);</span><br><span class="line">    EPWM_setTimeBaseCounter(myEPWM1_BASE, <span class="number">0U</span>);</span><br><span class="line"></span><br><span class="line">    EPWM_setClockPrescaler(myEPWM1_BASE, EPWM_CLOCK_DIVIDER_2, EPWM_HSCLOCK_DIVIDER_2); <span class="comment">// Set ePWM clock pre-scaler</span></span><br><span class="line"></span><br><span class="line">    EPWM_setCounterCompareShadowLoadMode(myEPWM1_BASE, EPWM_COUNTER_COMPARE_A, EPWM_COMP_LOAD_ON_CNTR_ZERO);</span><br><span class="line">    EPWM_setCounterCompareShadowLoadMode(myEPWM1_BASE, EPWM_COUNTER_COMPARE_B, EPWM_COMP_LOAD_ON_CNTR_ZERO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Set Compare values</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EPWM_setCounterCompareValue(myEPWM1_BASE, EPWM_COUNTER_COMPARE_A, EPWM1_MIN_CMPA);</span><br><span class="line">    EPWM_setCounterCompareValue(myEPWM1_BASE, EPWM_COUNTER_COMPARE_B, EPWM1_MIN_CMPB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Set actions for ePWM1A &amp; ePWM1B</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Set PWM1A on Zero</span></span><br><span class="line">    EPWM_setActionQualifierAction(myEPWM1_BASE, EPWM_AQ_OUTPUT_A, EPWM_AQ_OUTPUT_HIGH, EPWM_AQ_OUTPUT_ON_TIMEBASE_ZERO);</span><br><span class="line">    <span class="comment">// Clear PWM1A on event A, up count</span></span><br><span class="line">    EPWM_setActionQualifierAction(myEPWM1_BASE, EPWM_AQ_OUTPUT_A, EPWM_AQ_OUTPUT_LOW, EPWM_AQ_OUTPUT_ON_TIMEBASE_UP_CMPA);</span><br><span class="line">    <span class="comment">// Set PWM1B on Zero</span></span><br><span class="line">    EPWM_setActionQualifierAction(myEPWM1_BASE, EPWM_AQ_OUTPUT_B, EPWM_AQ_OUTPUT_HIGH, EPWM_AQ_OUTPUT_ON_TIMEBASE_ZERO);</span><br><span class="line">    <span class="comment">// Clear PWM1B on event B, up count</span></span><br><span class="line">    EPWM_setActionQualifierAction(myEPWM1_BASE, EPWM_AQ_OUTPUT_B, EPWM_AQ_OUTPUT_LOW, EPWM_AQ_OUTPUT_ON_TIMEBASE_UP_CMPB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Interrupt where we will change the Compare Values</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EPWM_setInterruptSource(myEPWM1_BASE, EPWM_INT_TBCTR_ZERO);</span><br><span class="line">    EPWM_enableInterrupt(myEPWM1_BASE);</span><br><span class="line">    EPWM_setInterruptEventCount(myEPWM1_BASE, <span class="number">3U</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// Information this example uses to keep track</span></span><br><span class="line">   <span class="comment">// of the direction the CMPA/CMPB values are</span></span><br><span class="line">   <span class="comment">// moving, the min and max allowed values and</span></span><br><span class="line">   <span class="comment">// a pointer to the correct ePWM registers</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start by increasing CMPA &amp; CMPB</span></span><br><span class="line">    epwm1Info.epwmCompADirection = EPWM_CMP_UP;</span><br><span class="line">    epwm1Info.epwmCompBDirection = EPWM_CMP_UP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear interrupt counter</span></span><br><span class="line">    epwm1Info.epwmTimerIntCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set base as ePWM1</span></span><br><span class="line">    epwm1Info.epwmModule = myEPWM1_BASE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup min/max CMPA/CMP values</span></span><br><span class="line">    epwm1Info.epwmMaxCompA = EPWM1_MAX_CMPA;</span><br><span class="line">    epwm1Info.epwmMinCompA = EPWM1_MIN_CMPA;</span><br><span class="line">    epwm1Info.epwmMaxCompB = EPWM1_MAX_CMPB;</span><br><span class="line">    epwm1Info.epwmMinCompB = EPWM1_MIN_CMPB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">配置开始 --&gt; 配置TBCLK --&gt; 配置时钟分频 --&gt; 配置影子寄存器ShadowRegister --&gt; 配置CMP --&gt; 配置AactionQualifier --&gt; 配置ePWM中断 --&gt; 配置结束</span><br></pre></td></tr></table></figure>

<h3 id="EPWMCLK"><a href="#EPWMCLK" class="headerlink" title="EPWMCLK"></a>EPWMCLK</h3><p><img src="https://pic.islet.space/2021/07/image-20210726110116356.png" alt="image-20210726110116356"></p>
<p><img src="https://pic.islet.space/2021/08/image-20210802172012594.png" alt="image-20210802172012594"></p>
<p><img src="https://pic.islet.space/2021/08/image-20210802171937172.png" alt="image-20210802171937172"></p>
<p>通过配置下方代码中 <code>main()</code> 函数的参数，来对CPU 、ePWM的相关寄存器参数进行调节，可以实现目标PWM周期为30.8Khz的设置。</p>
<p>参数计算代码就不贴了，可以直接下载：<a target="_blank" rel="noopener" href="http://code.islet.space/VisualStudioStudio/F28004x_ParamsCalculate/main.cpp">main.cpp</a></p>
<p>从系统时钟设置到外设时钟设置过程中，需要设置的寄存器、位及其数值具体如下（仅供参考）：</p>
<ol>
<li>设置时钟源。选择时钟源为 <em><strong>内源时钟2</strong></em>（INTOSC2），修改 <code>CLKSRCCTL1</code> 寄存器下的 <code>OSCCLKSRCSEL</code> 值为 <code>0x00</code> 。</li>
<li>设置系统PLL频率。需要分别设置整数分频、分数分频 和 系统分频，对应修改 <code>SYSPLLMULT</code> 寄存器下的 <code>IMULT</code> / <code>FMULT</code> / <code>ODIV</code> 值为 <code>0x13</code> / <code>0x3</code> / <code>0x1</code> （或使用十进制赋值 <code>19</code> / <code>3</code> / <code>1</code>）。</li>
<li>设置需要使用的PWM设备序号。打开对应控制的 <code>PCLKCRx</code> 寄存器下的对应位，参考《SPRUI33D》第195页相关寄存器说明。</li>
<li>设定PWMCLK频率。修改 <code>TBCTL</code> 寄存器下的 <code>HSPCLKDIV</code> 及 <code>CLKDIV</code> 为 <code>0x00</code> 及 <code>0x01</code> （默认情况下也是这个值），以获得 <strong>CPU时钟速率一半值的外设时钟</strong>。</li>
<li>设定TB计数器模式。修改 <code>TBCTL</code> 寄存器下的 <code>CTRMODE</code> 为 <code>0x2</code> ，打开 TB counter 的增减计数模式。</li>
<li>设定TB周期。修改 <code>TBPRD</code> 寄存器的值为十进制的 <code>1600</code> 。</li>
</ol>
<h1 id="常见错误处理"><a href="#常见错误处理" class="headerlink" title="常见错误处理"></a>常见错误处理</h1><h2 id="10263-MEMORY-RANGE-HAS-ALREADY-BEEN-SPECIFIED"><a href="#10263-MEMORY-RANGE-HAS-ALREADY-BEEN-SPECIFIED" class="headerlink" title="#10263 MEMORY RANGE HAS ALREADY BEEN SPECIFIED"></a>#10263 MEMORY RANGE HAS ALREADY BEEN SPECIFIED</h2><p><strong>错误提示</strong>：存储区域范围（Memory Range）重复声明。</p>
<p><strong>解释</strong>：在两个 <code>.cmd</code> 文件中，对 memory 的 page0 下的存储范围重复声明。</p>
<div style="text-align: center;"><img src="https://pic.islet.space/2021/07/image-20210720171745641.png" alt="image-20210720171745641" style="zoom:80%;" /> <img src="https://pic.islet.space/2021/07/image-20210720171759718.png" alt="image-20210720171759718" style="zoom:80%;" /></div>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;..&#x2F;28004x_RAM_afe031_lnk.cmd&quot;, line 7: error #10263: BEGIN memory range has already been specified</span><br><span class="line">&quot;..&#x2F;28004x_RAM_afe031_lnk.cmd&quot;, line 7: error #10264: BEGIN memory range overlaps existing memory range BEGIN</span><br><span class="line">&quot;..&#x2F;28004x_RAM_afe031_lnk.cmd&quot;, line 8: error #10263: RAMM0 memory range has already been specified</span><br><span class="line">&quot;..&#x2F;28004x_RAM_afe031_lnk.cmd&quot;, line 8: error #10264: RAMM0 memory range overlaps existing memory range RAMM0</span><br><span class="line">&quot;..&#x2F;28004x_RAM_afe031_lnk.cmd&quot;, line 9: error #10263: RAMLS0 memory range has already been specified</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p><strong>解决办法</strong>：删除、移动 <code>28004x_RAM_afe031_lnk.cmd</code> ，或更改其后缀名；确保在 <em>项目属性</em>（Properties）中的 <strong>连接器命令文件</strong>（Linker Command File）为正确的 <code>280041_RAM_lnk.cmd</code> 。</p>
<img src="https://pic.islet.space/2021/07/image-20210720172450100.png" alt="image-20210720172450100" style="zoom:80%;" />



<img src="https://pic.islet.space/2021/07/image-20210720172242634.png" alt="image-20210720172242634" style="zoom:80%;" />





<h2 id="1965-CANNOT-OPEN-SOURCE-FILE"><a href="#1965-CANNOT-OPEN-SOURCE-FILE" class="headerlink" title="#1965 CANNOT OPEN SOURCE FILE"></a>#1965 CANNOT OPEN SOURCE FILE</h2><p>无法找到指定头文件，报错如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:&#x2F;ti&#x2F;c2000Ware&#x2F;C2000Ware_2_01_00_00&#x2F;device_support&#x2F;f28004x&#x2F;common&#x2F;include&#x2F;F28x_Project.h&quot;, line 47: fatal error #1965: cannot open source file &quot;f28004x_device.h&quot;</span><br></pre></td></tr></table></figure>

<p>可以借助本地搜索工具everything进行文件搜索，将缺失的头文件的绝对路径复制，并粘贴至 头文件设置 下的搜索路径中。上方的错误缺失 <code>f28004x_device.h</code> ，添加 <code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\device_support\f28004x\headers\include</code> 绝对路径以供搜索，即可解决。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210721104533304.png" alt="image-20210721104533304"></p>
<h2 id="10234-D-UNRESOLVED-SYMBOLS-REMAIN"><a href="#10234-D-UNRESOLVED-SYMBOLS-REMAIN" class="headerlink" title="#10234-D UNRESOLVED SYMBOLS REMAIN"></a>#10234-D UNRESOLVED SYMBOLS REMAIN</h2><p>在将函数需要的头文件添加到项目后，进行 <em>build project</em> ，出现 “未能解决的标志存留” ，有2种可能原因：</p>
<ol>
<li>输出格式（Output Format）不正确。</li>
<li>头文件缺少对应的 <code>.c</code> 文件。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> undefined        first referenced   </span><br><span class="line">  symbol              <span class="keyword">in</span> file        </span><br><span class="line"> ---------        ----------------   </span><br><span class="line"> _ClkCfgRegs      ./SystemControl.obj</span><br><span class="line"> _CpuSysRegs      ./SystemControl.obj</span><br><span class="line"> _Dcc0Regs        ./SystemControl.obj</span><br><span class="line"> _DcsmBank0Z1Regs ./SystemControl.obj</span><br><span class="line"> _DcsmBank0Z2Regs ./SystemControl.obj</span><br><span class="line"> _F28x_usDelay    ./SystemControl.obj</span><br><span class="line"> _Flash0CtrlRegs  ./SystemControl.obj</span><br><span class="line"> _Flash0EccRegs   ./SystemControl.obj</span><br><span class="line"> _WdRegs          ./SystemControl.obj</span><br><span class="line"> </span><br><span class="line">error <span class="comment">#10234-D: unresolved symbols remain</span></span><br><span class="line">error <span class="comment">#10010: errors encountered during linking; &quot;F28004x_WPT.out&quot; not built</span></span><br><span class="line"> </span><br><span class="line">&gt;&gt; Compilation failure</span><br><span class="line">makefile:143: recipe <span class="keyword">for</span> target <span class="string">&#x27;F28004x_WPT.out&#x27;</span> failed</span><br><span class="line">makefile:139: recipe <span class="keyword">for</span> target <span class="string">&#x27;all&#x27;</span> failed</span><br><span class="line">gmake[1]: *** [F28004x_WPT.out] Error 1</span><br><span class="line">gmake: *** [all] Error 2</span><br><span class="line"></span><br><span class="line">**** Build Finished ****</span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong>：</p>
<p>排除第一种情况后，找到 未定义符号（undefined symbol）对应的头文件 <code>f28004x_device.h</code> 和 <code>f28004x_sysctrl.h</code> 所在的文件路径 <code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\device_support\f28004x\headers\include</code> ，注意到该头文件上一级有个 <code>source</code> 文件夹，存储着头文件对应的 <code>.c</code> 文件： <code>f28004x_globalvariabledefs.c</code> ，将该头文件以链接或复制的形式添加到项目文件中即可。</p>
<p><strong>注意</strong>：大部分情况下，header files 都会有其对应的 <code>.c</code> 或 <code>.asm</code> 文件，需要去相同的目录下方寻找即可。</p>
<div style="text-align: center;"><img src="https://pic.islet.space/2021/07/image-20210727092820296.png" alt="image-20210727092820296" style="zoom:100%;" /><img src="https://pic.islet.space/2021/07/image-20210727094440528.png" alt="image-20210727094440528" style="zoom:100%;" /></div>



<h2 id="SC-ERR-PATH-BROKEN"><a href="#SC-ERR-PATH-BROKEN" class="headerlink" title="SC_ERR_PATH_BROKEN"></a>SC_ERR_PATH_BROKEN</h2><p>在将评估板接到PC过程中，进行连接测试（Test Connection），报错如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">-----[Print the reset-command software log-file]-----------------------------</span><br><span class="line"></span><br><span class="line">This utility has selected a 100- or 510-class product.</span><br><span class="line">This utility will load the adapter <span class="string">&#x27;jioxds110.dll&#x27;</span>.</span><br><span class="line">The library build date was <span class="string">&#x27;Nov 25 2019&#x27;</span>.</span><br><span class="line">The library build time was <span class="string">&#x27;16:55:29&#x27;</span>.</span><br><span class="line">The library package version is <span class="string">&#x27;8.4.0.00006&#x27;</span>.</span><br><span class="line">The library component version is <span class="string">&#x27;35.35.0.0&#x27;</span>.</span><br><span class="line">The controller does not use a programmable FPGA.</span><br><span class="line">The controller has a version number of <span class="string">&#x27;5&#x27;</span> (0x00000005).</span><br><span class="line">The controller has an insertion length of <span class="string">&#x27;0&#x27;</span> (0x00000000).</span><br><span class="line">This utility will attempt to reset the controller.</span><br><span class="line">This utility has successfully reset the controller.</span><br><span class="line"></span><br><span class="line">-----[Print the reset-command hardware log-file]-----------------------------</span><br><span class="line"></span><br><span class="line">The scan-path will be reset by toggling the JTAG TRST signal.</span><br><span class="line">The controller is the XDS110 with USB interface.</span><br><span class="line">The link from controller to target is direct (without cable).</span><br><span class="line">The software is configured <span class="keyword">for</span> XDS110 features.</span><br><span class="line">The controller cannot monitor the value on the EMU[0] pin.</span><br><span class="line">The controller cannot monitor the value on the EMU[1] pin.</span><br><span class="line">The controller cannot control the timing on output pins.</span><br><span class="line">The controller cannot control the timing on input pins.</span><br><span class="line">The scan-path link-delay has been <span class="built_in">set</span> to exactly <span class="string">&#x27;0&#x27;</span> (0x0000).</span><br><span class="line"></span><br><span class="line">-----[An error has occurred and this utility has aborted]--------------------</span><br><span class="line"></span><br><span class="line">This error is generated by TI<span class="string">&#x27;s USCIF driver or utilities.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The value is &#x27;</span>-233<span class="string">&#x27; (0xffffff17).</span></span><br><span class="line"><span class="string">The title is &#x27;</span>SC_ERR_PATH_BROKEN<span class="string">&#x27;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The explanation is:</span></span><br><span class="line"><span class="string">The JTAG IR and DR scan-paths cannot circulate bits, they may be broken.</span></span><br><span class="line"><span class="string">An attempt to scan the JTAG scan-path has failed.</span></span><br><span class="line"><span class="string">The target&#x27;</span>s JTAG scan-path appears to be broken</span><br><span class="line">with a stuck-at-ones or stuck-at-zero fault.</span><br><span class="line"></span><br><span class="line">[End: Texas Instruments XDS110 USB Debug Probe_0]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>因为本开发板设计上使用两线制，为 <em>cJTAG</em>，而默认情况下是标准的 JTAG，只需要 TCK 和 TMS 两个信号（官方文档的常见问答部分有说明）。</p>
<p>在<code>.ccxml</code> 文件中进行修改，点击下方的 <em>Advanced</em>，然后选择 <code>cJTAG(1149.7)2-pin advance mode</code>，然后 <em>save</em> 保存即可。具体操作如下图：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210726155434636.png" alt="image-20210726155434636"></p>
<p>再次运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">-----[Print the reset-command software log-file]-----------------------------</span><br><span class="line"></span><br><span class="line">This utility has selected a 100- or 510-class product.</span><br><span class="line">This utility will load the adapter <span class="string">&#x27;jioxds110.dll&#x27;</span>.</span><br><span class="line">The library build date was <span class="string">&#x27;Nov 25 2019&#x27;</span>.</span><br><span class="line">The library build time was <span class="string">&#x27;16:55:29&#x27;</span>.</span><br><span class="line">The library package version is <span class="string">&#x27;8.4.0.00006&#x27;</span>.</span><br><span class="line">The library component version is <span class="string">&#x27;35.35.0.0&#x27;</span>.</span><br><span class="line">The controller does not use a programmable FPGA.</span><br><span class="line">The controller has a version number of <span class="string">&#x27;5&#x27;</span> (0x00000005).</span><br><span class="line">The controller has an insertion length of <span class="string">&#x27;0&#x27;</span> (0x00000000).</span><br><span class="line">This utility will attempt to reset the controller.</span><br><span class="line">This utility has successfully reset the controller.</span><br><span class="line"></span><br><span class="line">-----[Print the reset-command hardware log-file]-----------------------------</span><br><span class="line"></span><br><span class="line">The scan-path will be reset by toggling the JTAG TRST signal.</span><br><span class="line">The controller is the XDS110 with USB interface.</span><br><span class="line">The link from controller to target is direct (without cable).</span><br><span class="line">The software is configured <span class="keyword">for</span> XDS110 features.</span><br><span class="line">The controller cannot monitor the value on the EMU[0] pin.</span><br><span class="line">The controller cannot monitor the value on the EMU[1] pin.</span><br><span class="line">The controller cannot control the timing on output pins.</span><br><span class="line">The controller cannot control the timing on input pins.</span><br><span class="line">The scan-path link-delay has been <span class="built_in">set</span> to exactly <span class="string">&#x27;0&#x27;</span> (0x0000).</span><br><span class="line"></span><br><span class="line">-----[Perform the Integrity scan-test on the JTAG IR]------------------------</span><br><span class="line"></span><br><span class="line">This <span class="built_in">test</span> will use blocks of 64 32-bit words.</span><br><span class="line">This <span class="built_in">test</span> will be applied just once.</span><br><span class="line"></span><br><span class="line">Do a <span class="built_in">test</span> using 0xFFFFFFFF.</span><br><span class="line">Scan tests: 1, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0x00000000.</span><br><span class="line">Scan tests: 2, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0xFE03E0E2.</span><br><span class="line">Scan tests: 3, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0x01FC1F1D.</span><br><span class="line">Scan tests: 4, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0x5533CCAA.</span><br><span class="line">Scan tests: 5, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0xAACC3355.</span><br><span class="line">Scan tests: 6, skipped: 0, failed: 0</span><br><span class="line">All of the values were scanned correctly.</span><br><span class="line"></span><br><span class="line">The JTAG IR Integrity scan-test has succeeded.</span><br><span class="line"></span><br><span class="line">-----[Perform the Integrity scan-test on the JTAG DR]------------------------</span><br><span class="line"></span><br><span class="line">This <span class="built_in">test</span> will use blocks of 64 32-bit words.</span><br><span class="line">This <span class="built_in">test</span> will be applied just once.</span><br><span class="line"></span><br><span class="line">Do a <span class="built_in">test</span> using 0xFFFFFFFF.</span><br><span class="line">Scan tests: 1, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0x00000000.</span><br><span class="line">Scan tests: 2, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0xFE03E0E2.</span><br><span class="line">Scan tests: 3, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0x01FC1F1D.</span><br><span class="line">Scan tests: 4, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0x5533CCAA.</span><br><span class="line">Scan tests: 5, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0xAACC3355.</span><br><span class="line">Scan tests: 6, skipped: 0, failed: 0</span><br><span class="line">All of the values were scanned correctly.</span><br><span class="line"></span><br><span class="line">The JTAG DR Integrity scan-test has succeeded.</span><br><span class="line"></span><br><span class="line">[End: Texas Instruments XDS110 USB Debug Probe_0]</span><br></pre></td></tr></table></figure>



<h2 id="时钟初始化错误"><a href="#时钟初始化错误" class="headerlink" title="时钟初始化错误"></a>时钟初始化错误</h2><p>时钟初始化错误是可能新建文件后可能会出现的隐形错误，因为程序编译的时候不报错，只报 WARNING ，因此很难察觉。</p>
<p>但是，能通过 Expression 界面输入寄存器名称，用以观察其是否被初始化，如下图示，为自建项目后初始化的寄存器数值，只运行第一步PLL初始化，可以观察到 <code>ClkCfgRegs</code> 并未被初始化。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210730170342194.png" alt="image-20210730170342194"></p>
<p>同样使用官方样例代码进行仅一步的PLL初始化操作，可以发现初始化成功。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210730170350083.png" alt="image-20210730170350083"></p>
<p>仔细对比和检查后发现，自建项目中缺少了几个，通过link方式或copy方式添加进来，再到项目属性下的 Symbol Management中，为输出模块添加代码入口点 <code>code_start</code> 即可。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210730171218213.png" alt="image-20210730171218213"></p>
<p><img src="https://pic.islet.space/2021/07/image-20210730171409142.png" alt="image-20210730171409142"></p>
<h2 id="TARGET-MUST-BE-CONNECTED"><a href="#TARGET-MUST-BE-CONNECTED" class="headerlink" title="TARGET MUST BE CONNECTED"></a>TARGET MUST BE CONNECTED</h2><p>使用JTAG调试器XDS100 V2连接至目标设备上时，如果出现下图所示的 “Disconnected: Unknown”，说明目标MCU/DSP没有正确识别。</p>
<p><img src="https://pic.islet.space/2021/08/image-20210802160213827.png" alt="image-20210802160213827"></p>
<p>首先应检查JTAG是否链接正常，打开“设备管理器”进行查看，如果设备连接器中出现了该JTAG设备，则进一步查看项目文件下的<code>.cxxm</code>l文件，该文件用于配置设备连接信息，包括芯片信号、JTAG调试器信号、通信方式、通信速率等。确保所有设置都正确以后进行全面断电、断开连接、重启CCS并重新尝试Debug，如果仍旧出现问题，请按以下步骤进行操作。</p>
<p>在Debug界面，点击目标CPU，点击 <code>Connect Target</code> 进行手动连接。</p>
<p><img src="https://pic.islet.space/2021/08/image-20210802160242203.png" alt="image-20210802160242203"></p>
<p>连接正确后，手动导入 <code>Build</code> 完之后的 <code>.out</code> 文件，将该程序手动烧写至CPU的RAM/Flash中</p>
<p><img src="https://pic.islet.space/2021/08/image-20210802160456548.png" alt="image-20210802160456548"></p>
<p>选择对应项目下生成的 <code>.out</code> 文件：</p>
<p><img src="https://pic.islet.space/2021/08/image-20210802160358841.png" alt="image-20210802160358841"></p>
<p>可以在Console台（界面）观察到已经写入和初始化成功：</p>
<p><img src="https://pic.islet.space/2021/08/image-20210802154136487.png" alt="image-20210802154136487"></p>
<h1 id="术语-1"><a href="#术语-1" class="headerlink" title="术语"></a>术语</h1><p><strong>LDO</strong>: Low dropout, A DC linear voltage regulator which can operate with a very small input/output differential voltage.</p>
<p><strong>V<span style="font-size: 0.8rem;">REG</span></strong>: Voltage Regulator. 稳压器。</p>
<p><strong>V<span style="font-size: 0.8rem;">REF</span></strong>: Voltage Reference. 参考电压</p>
<p><strong>ESD</strong>: Electrostatic Discharge, 静电放电。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.ti.com.cn/cn/lit/gpn/tms320f280049">《TMS320F28004x 微控制器》</a></li>
<li><a href="">《F28004x_DEV_USER_GUIDE.pdf》</a></li>
<li><a href="">《SPRU566N C2000 <em><strong>Real-Time Control MCU Peripherals</strong></em> Reference Guide》</a></li>
<li><a href="">《SPRUI33D TMS320F28004x <em><strong>Real-Time Microcontrollers</strong></em> Technical Reference Manual》</a></li>
<li><a href="">《SPRUHS1C TMS320C28x <em><strong>Extended Instruction Sets</strong></em> Technical Reference Manual》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docin.com/p-505058292.html">基于IGBT的DC-AC变换器设计</a></li>
<li><a target="_blank" rel="noopener" href="http://www.henlito.com/chinese/news/10/12717.html">IGBT模块单相半桥逆变电路设计与应用</a></li>
<li><a target="_blank" rel="noopener" href="https://code.islet.space/TI/f28004x/index.html">Texas Instruments F28004x Peripheral Driver Library </a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Simon_cici/article/details/84951920">280049LaunchPad仿真器连接不上的问题解决办法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/dog_second/article/details/108382419">DSP 28335 编译过程中的#10234-D、#10010报错</a></li>
<li>《MCU025A(001)_BOM.xls》</li>
<li>《MCU025A(001)_Sch.pdf》</li>
<li>《MCU025A_PCB_LayerPlots.pdf》</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/06/Programming/C++/2021-07-06-Linux%E4%B8%8AC++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/06/Programming/C++/2021-07-06-Linux%E4%B8%8AC++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" class="post-title-link" itemprop="url">Linux上C++多线程报错解决办法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-07-06 01:01:51 / Modified: 01:16:47" itemprop="dateCreated datePublished" datetime="2021-07-06T01:01:51+08:00">2021-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="pthread报错"><a href="#pthread报错" class="headerlink" title="pthread报错"></a>pthread报错</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namespce std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello concurent world!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(hello)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个小例子直接用make编译是无法通过的。报错如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/tmp/ccYB66pt.o：在函数‘std::thread::thread&lt;void (&amp;)()&gt;(void (&amp;)())’中：</span><br><span class="line">1-1.cpp:(.text._ZNSt6threadC2IRFvvEJEEEOT_DpOT0_[_ZNSt6threadC5IRFvvEJEEEOT_DpOT0_]+0x21)：对‘pthread_create’未定义的引用</span><br><span class="line">collect2: 错误：ld 返回 1</span><br><span class="line">&lt;<span class="built_in">builtin</span>&gt;: recipe <span class="keyword">for</span> target <span class="string">&#x27;1-1&#x27;</span> failed</span><br><span class="line">make: *** [1-1] Error 1</span><br></pre></td></tr></table></figure>

<p>解决方法是在编译的时候加上 <code>-lpthread</code> 参数。这个类用到posix实现的线程了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -o <span class="built_in">test</span> test.cpp -lpthread</span><br><span class="line">./<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello concurent world!</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wuhui20091515/article/details/52531202">c++使用thread类时编译出错，对‘pthread_create’未定义的引用</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/05/Programming/C++/2021-07-05-%E5%9C%A8linux%E4%B8%8A%E7%BC%96%E5%86%99%E6%B1%82%E8%A7%A3ADAU1772%E7%9A%84PLL%E7%B3%BB%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/05/Programming/C++/2021-07-05-%E5%9C%A8linux%E4%B8%8A%E7%BC%96%E5%86%99%E6%B1%82%E8%A7%A3ADAU1772%E7%9A%84PLL%E7%B3%BB%E6%95%B0/" class="post-title-link" itemprop="url">在linux上编写求解ADAU1772的PLL系数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-05 20:00:00" itemprop="dateCreated datePublished" datetime="2021-07-05T20:00:00+08:00">2021-07-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-07-06 01:01:05" itemprop="dateModified" datetime="2021-07-06T01:01:05+08:00">2021-07-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>通过在Linux上编写代码，计算求解ADAU1772在 <strong>输入时钟</strong>（MCLK Input）为16.6MHz时，如何设置内部的4个参数，以达到符合输出时钟要求的目的。</p>
<p>据《ADAU1772》和SigmaStudio，1772 Codec 内部可修改的参数有 <strong>输入时钟分频</strong>（Input Clock Divider）、<strong>整数设置</strong>（Integer Setting）、<strong>分子</strong>（Numerator） 和 <strong>分母</strong>（Denominator）四个。</p>
<p><strong>目标输出时钟</strong>（VCO Output） 是 24.576MHz。</p>
<h1 id="原公式"><a href="#原公式" class="headerlink" title="原公式"></a>原公式</h1><p>以下为《ADAU1772》第30页中，关于PLL计算的公式描述：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210706002255187.png" alt="image-20210706002255187"></p>
<p>以下为SigmaStudio中的PLL设定界面参数设定：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210706002412136.png" alt="image-20210706002412136"></p>
<h1 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h1><p>注意：本代码在Linux上，以C++17的版本进行编译运行。</p>
<p>编译代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -std=c++17 -lpthread</span><br></pre></td></tr></table></figure>

<p>在编写代码时，考虑到SigmaStudio和数据手册之间可能存在表述差异，因此计算PLL的源代码中，也包含了开启 <code>1/2</code> 系数的宏定义 <code>#define HALFCOFF 1</code> ，具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * HEADER FILES</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * MACRO DEFINITION</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACCURACY 1000000000   <span class="comment">//输出时钟精度，小数点后9个0</span></span></span><br><span class="line"><span class="comment">// #define HALFCOFF 1            //打开1/2系数进行计算，SigmaStudio图示中有该系数，但《ADAU1772》数据手册中没有该系数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * MACRO DEFINITION FOR DEBUG</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">// #define DEBUG_MODE         //Debug模式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * DATA TYPES</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> CLK;           <span class="comment">//数据类型_时钟</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> COFF;  <span class="comment">//数据类型_系数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * FILE DOMAIN DATA DECLARATION</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line">CLK CLK_IN = <span class="number">16.6</span>;            <span class="comment">//输入时钟</span></span><br><span class="line">CLK CLK_OUT = <span class="number">24.576</span>;         <span class="comment">//输出时钟</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TargetCofficient</span> &#123;</span></span><br><span class="line">    COFF Numerator;</span><br><span class="line">    COFF Denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">COFF Maxiator = <span class="number">65535</span>;</span><br><span class="line">COFF InputClockDivider = <span class="number">4</span>;</span><br><span class="line">COFF IntegerSetting = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * FUNCTIONS DECLARATION</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isSafe</span><span class="params">(COFF, COFF)</span></span>;      <span class="comment">//判断系数的分子和分母相除是否满足要求</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isOK</span><span class="params">(CLK)</span></span>;               <span class="comment">//判断输出结果是否符合输出时钟的精度要求</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CofficientCalculate</span><span class="params">(CLK, COFF, COFF)</span></span>;         <span class="comment">//计算</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD1</span><span class="params">(<span class="keyword">void</span>)</span></span>;             <span class="comment">//子线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD2</span><span class="params">(<span class="keyword">void</span>)</span></span>;             <span class="comment">//子线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD3</span><span class="params">(<span class="keyword">void</span>)</span></span>;             <span class="comment">//子线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD4</span><span class="params">(<span class="keyword">void</span>)</span></span>;             <span class="comment">//子线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysPrintf</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * MAIN FUNCTIONS</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;SYSTEM: Procedure starts.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">thread1</span><span class="params">(ICD1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread2</span><span class="params">(ICD2)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread3</span><span class="params">(ICD3)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread4</span><span class="params">(ICD4)</span></span>;</span><br><span class="line"></span><br><span class="line">    thread1.<span class="built_in">join</span>();</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">    thread3.<span class="built_in">join</span>();</span><br><span class="line">    thread4.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;SYSTEM: Procedure ends up.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * FUNCTIONS DEFINITION</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isSafe</span><span class="params">(COFF N, COFF D)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = (<span class="keyword">double</span>)N / (<span class="keyword">double</span>)D;</span><br><span class="line">    <span class="keyword">if</span>( (result &gt;= <span class="number">0.1</span>) &amp;&amp; (result &lt;= <span class="number">0.9</span>) ) <span class="keyword">return</span> <span class="number">1</span>;       <span class="comment">//判断系数是否满足要求，满足则返回1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isOK</span><span class="params">(CLK clock)</span></span>&#123;</span><br><span class="line">    CLK integerClock , fractClock;</span><br><span class="line">    fractClock = <span class="built_in">modf</span>(clock , &amp;integerClock);                <span class="comment">//分别取出整数和小数部分</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( ((<span class="keyword">int</span>)(fractClock * ACCURACY) == (<span class="keyword">int</span>)(<span class="number">576</span>/(<span class="keyword">double</span>)<span class="number">1000</span> * ACCURACY)) &amp;&amp; ((<span class="keyword">int</span>)integerClock == (<span class="keyword">int</span>)CLK_OUT) ) &#123;  <span class="comment">//如果小数点精度满足要求，且整数部分相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                                           <span class="comment">//则返回1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CofficientCalculate</span><span class="params">(CLK ClockInput, COFF ICD, COFF IS)</span></span>&#123;</span><br><span class="line">    CLK tempCLK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(COFF i = <span class="number">0</span>; i &lt; Maxiator; i++)&#123;                     <span class="comment">//分母</span></span><br><span class="line">        <span class="keyword">for</span>(COFF j = <span class="number">0</span>; j &lt; Maxiator; j++)&#123;                 <span class="comment">//分子</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isSafe</span>(j, i))&#123;</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">ifdef</span> HALFCOFF</span></span><br><span class="line">                tempCLK = ClockInput /(<span class="keyword">double</span>)ICD * ((<span class="keyword">double</span>)IS + ((<span class="keyword">double</span>)j/(<span class="keyword">double</span>)i)) *<span class="number">1</span>/<span class="number">2</span>;   <span class="comment">//有系数时</span></span><br><span class="line">                <span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line">                tempCLK = ClockInput /(<span class="keyword">double</span>)ICD * ((<span class="keyword">double</span>)IS + ((<span class="keyword">double</span>)j/(<span class="keyword">double</span>)i)) ;       <span class="comment">//无系数时</span></span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                <span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_MODE</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;SYSTEM:IDC = &quot;</span> &lt;&lt; ICD &lt;&lt; <span class="string">&quot;, IS = &quot;</span> &lt;&lt; IS &lt;&lt; hex &lt;&lt;<span class="string">&quot;, Numerator = 0x&quot;</span>&lt;&lt; j &lt;&lt; <span class="string">&quot;, Denominator = 0x&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, OutputClock = &quot;</span> &lt;&lt; tempCLK &lt;&lt; endl;</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">isOK</span>(tempCLK)) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;SYSTEM:IDC = &quot;</span> &lt;&lt; ICD &lt;&lt; <span class="string">&quot;, IS = &quot;</span> &lt;&lt; IS &lt;&lt; hex &lt;&lt;<span class="string">&quot;, Numerator = 0x&quot;</span>&lt;&lt; j &lt;&lt; <span class="string">&quot;, Denominator = 0x&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, OutputClock = &quot;</span> &lt;&lt; tempCLK &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * THREAD _ CALCULATOR</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD1</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(COFF enumIS = <span class="number">2</span>; enumIS &lt;= IntegerSetting; enumIS++) <span class="built_in">CofficientCalculate</span>(CLK_IN , <span class="number">1</span>, enumIS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD2</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(COFF enumIS = <span class="number">2</span>; enumIS &lt;= IntegerSetting; enumIS++) <span class="built_in">CofficientCalculate</span>(CLK_IN , <span class="number">2</span>, enumIS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD3</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(COFF enumIS = <span class="number">2</span>; enumIS &lt;= IntegerSetting; enumIS++) <span class="built_in">CofficientCalculate</span>(CLK_IN , <span class="number">3</span>, enumIS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD4</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(COFF enumIS = <span class="number">2</span>; enumIS &lt;= IntegerSetting; enumIS++) <span class="built_in">CofficientCalculate</span>(CLK_IN , <span class="number">4</span>, enumIS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysPrintf</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// while(1) cout &lt;&lt; &quot;Calculating...&quot;;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r\003&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>通过自行编写的代码，遍历所有可更改的系数进行计算求解，取得小数点后9位精度，并且符合要求的系数如下（含1/2系数）：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210706001243698.png" alt="image-20210706001243698"></p>
<p>以下为不含1/2系数的结果：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210706001350802.png" alt="image-20210706001350802"></p>
<p>经过手工计算，结果（小数点后9位）确实满足要求。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备19004822号 </a>
  </div>

<div class="copyright">
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liewzheng</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
