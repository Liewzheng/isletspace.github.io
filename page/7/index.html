<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"islet.space","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta name="description" content="笔记分享的旮旯孤岛而已">
<meta property="og:type" content="website">
<meta property="og:title" content="Coder的孤岛">
<meta property="og:url" content="http://islet.space/page/7/index.html">
<meta property="og:site_name" content="Coder的孤岛">
<meta property="og:description" content="笔记分享的旮旯孤岛而已">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liewzheng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://islet.space/page/7/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/7/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Coder的孤岛</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Coder的孤岛</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">islet of the coder</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-文章"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>文章</a></li>
        <li class="menu-item menu-item-目录"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-简历"><a href="/resume/" rel="section"><i class="fa fa-address-card fa-fw"></i>简历</a></li>
        <li class="menu-item menu-item-友链"><a href="/friends/" rel="section"><i class="fa fa-group fa-fw"></i>友链</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liewzheng</p>
  <div class="site-description" itemprop="description">笔记分享的旮旯孤岛而已</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">99</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">183</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="mailto:liewzheng@foxmail.com" title="E-Mail → mailto:liewzheng@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/23/Hardware/DSP/2021-04-23-ADI%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/23/Hardware/DSP/2021-04-23-ADI%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">ADI开发笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-23 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-23T23:58:32+08:00">2021-04-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-07-08 22:41:04" itemprop="dateModified" datetime="2021-07-08T22:41:04+08:00">2021-07-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hardware/" itemprop="url" rel="index"><span itemprop="name">Hardware</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[TOC]</p>
<h1 id="terminology">TERMINOLOGY</h1>
<h2 id="processors-microcontrollers-dsp">Processors / Microcontrollers / DSP</h2>
<p>以下是ADI官方对Processors、Microcontrollers、DSP 等词的解释：</p>
<p><img src="https://pic.islet.space/2021/05/image-20210501094933998.png" alt="image-20210501094933998" style="zoom: 80%;" /></p>
<p><img src="https://pic.islet.space/2021/05/image-20210501094947031.png" alt="image-20210501094947031" style="zoom: 80%;" /></p>
<p><img src="https://pic.islet.space/2021/05/image-20210501094923111.png" alt="image-20210501094923111" style="zoom: 80%;" /></p>
<p><img src="https://pic.islet.space/2021/05/image-20210501095225573.png" alt="image-20210501095225573" style="zoom: 80%;" /></p>
<p><strong>Harvard Architecture</strong>，即哈佛结构，是一种将程序指令存储和数据存储分开的存储器结构。哈佛结构是一种并行体系结构，它的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问。</p>
<p><strong>Super Harvard Architecture</strong>（超级哈佛架构，SHARC），由ADI开发，具体解释见下方 BLACKFIN / SHARC。</p>
<h3 id="why-floating-point-dsp">Why Floating-Point DSP?</h3>
<blockquote>
<p>A digital signal processor’s data format determines its ability to handle signals of <em>differing precision</em>, <em>dynamic range</em>, and <em>signal-to-noise ratios</em>. Because floating-point DSP math reduces the need for scaling and probability of overflow, <mark>using a floating-point DSP can ease algorithm and software development</mark>. The extent to which this is true depends on the floating-point processor’s architecture.</p>
<p><u>Consistency with IEEE workstation simulations and the elimination of scaling are two clear ease-of-use advantages.</u> High-level language programmability, large address spaces, and wide dynamic range allow system development time to be spent on algorithms and signal processing concerns, rather than assembly language coding, code paging, and error handling.</p>
<p><em>--&lt;ADSP-21160 SHARC® DSP Hardware Reference&gt;</em></p>
</blockquote>
<p>总结一下就是：</p>
<ul>
<li>(The data format is) <strong>Suitable to handle various kind of task</strong> (like <em>differing precision</em>, <em>dynamic range</em>, and <em>signal-to-noise ratios</em>).</li>
<li>(F-P DSP math) <strong>Reduces the need of scaling and probability of overflow.</strong></li>
<li><strong>High-level language programmability, large address spaces, wide dynamic range</strong>.</li>
</ul>
<h2 id="blackfin-sharc">BLACKFIN / SHARC</h2>
<p>以下是ADI官网对BLACKFIN 和 SHARC的描述</p>
<p><strong>BLACKFIN</strong></p>
<blockquote>
<p>Blackfin® 16/32位嵌入式处理器提供软件灵活性和扩展能力，适合融合应用：多格式音频、视频、语音和图像处理、多模式基带和分组处理、控制处理以及实时安全。</p>
</blockquote>
<p><strong>SHARC</strong></p>
<blockquote>
<p>SHARC音频处理器产品系列采用ADI公司的SHARC®和SHARC+®数字信号处理(DSP)内核技术，提供确定性和极低处理延迟以及出色的MIPS/mW性能。SHARC处理器系列在浮点DSP市场占据主导地位，拥有出色的内核和存储器性能以及优异的I/O吞吐能力。SHARC具有多个产品版本和价位，能够为动态范围至关重要的许多应用提供实时浮点处理性能。</p>
<p>许多处理器集成了FIR/IIR硬件加速器，可分流内核的通用数字信号处理算法任务，从而使内核能够并行执行后处理算法，因而非常适合实时音频应用。广泛的SHARC+ SoC产品组合提供高达1GHz的性能可扩展性以及各种片内存储器配置和混合外设。对于以太网和USB等复杂的外设，一些SoC集成了ARM内核以便处理运行堆栈软件和其他微控制器任务。</p>
</blockquote>
<p>以下文字是《ADSP-21479 EZ-Board Evaluation System Manual》全篇唯一出现blackfin关键字（Page28）的地方，但是21479不属于Blackfin系列，应该是错误来的。</p>
<p><img src="https://pic.islet.space/2021/05/20210520135658.png" alt="image-20210520135616863" style="zoom:50%;" /></p>
<figure>
<img src="https://pic.islet.space/2021/05/20210520135659.png" alt="image-20210520135407091" /><figcaption aria-hidden="true">image-20210520135407091</figcaption>
</figure>
<h1 id="basic-knowledge">BASIC KNOWLEDGE</h1>
<p>原理图模块 是指用于构建SigmaStudio设计的模块。每个处理器可用的块显示在“工具箱”和“树形工具箱”窗口中，可以将其拖放到原理图中。</p>
<h2 id="usbi">USBi</h2>
<ul>
<li><p>USBi features a standard Aardvark-compatible programming header.</p></li>
<li><p>USBi can be used for real-time tuning of Sigma-DSP with SigmaStudio</p></li>
</ul>
<p>下图为USBi的功能框架：</p>
<p><img src="https://pic.islet.space/2021/05/image-20210518114358905.png" alt="image-20210518114358905" style="zoom:80%;" /></p>
<blockquote>
<p>USBi在I2C总线上有一个EEPROM，地址为0x50。它用来向PC显示其供应商ID和产品ID，以及启动其内部程序。应该避免在你的系统设计中在这个地址上有任何其他的EEPROMs。</p>
<p>这个EEPROM没有写保护；因此，如果你试图写到地址0x50，你将覆盖USBi的板载EEPROM，USBi将停止工作。如果不把板子还给Analog Devices，就不能对USBi进行重新编程。大多数EEPROM被设置为地址0x50的方法是将其引脚A0 = 1 和A1 = A2 = 0。</p>
</blockquote>
<h2 id="algorithms-addremove-growreduce">Algorithms: Add/Remove, Grow/Reduce</h2>
<p>每个原理图块代表一种或多种信号处理算法。算法的范围从非常简单的<a target="_blank" rel="noopener" href="https://wiki.analog.com/resources/tools-software/sigmastudio/toolbox/basicdsp/signaladd">信号添加</a>（如<a target="_blank" rel="noopener" href="https://wiki.analog.com/resources/tools-software/sigmastudio/toolbox/basicdsp/signaladd">Signal Add</a>）到高级系统组件（如<a target="_blank" rel="noopener" href="https://wiki.analog.com/resources/tools-software/sigmastudio/toolbox/adialgorithms/dynamicbassboost">Dynamic Bass Boost）</a>。您可以从块中添加或删除算法以满足您的特定要求。如下所述，算法也可以增长。</p>
<hr />
<p><strong>添加算法：</strong></p>
<p>您必须添加一种算法-通常与一组I / O引脚关联-才能使块起作用。要将算法添加到块，请<strong>右键单击</strong>该块，然后选择<strong>添加算法&gt; IC＃</strong>，然后选择<strong>算法</strong>的DSP IC。请注意，如果您的项目中有多个处理器（IC / DSP），则可以选择哪个DSP将运行算法，有关更多信息，请参见下文。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic1.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Aalgorithms"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic1.png" alt="img" /></a></p>
<p>此时，如果需要，右键单击块的边界或标签以添加其他算法。（重要的是右键单击边框或标签；如果右键单击中心，则可能会显示用于输入参数值的弹出窗口。）</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic2.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Aalgorithms"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic2.png" alt="img" /></a></p>
<p>不包含算法的块将没有控件或引脚，并且您只会看到该块的名称（如下图所示）。必须在空块中添加算法，然后才能在原理图设计中使用它们。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic3.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Aalgorithms"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic3.png" alt="img" /></a></p>
<p><strong>注意</strong>：使用“<a target="_blank" rel="noopener" href="https://wiki.analog.com/resources/tools-software/sigmastudio/developmentenvironment/toolbox">树形工具箱”窗口时</a>，总是为每个插入的块创建一个算法。但是，如果使用传统的“<a target="_blank" rel="noopener" href="https://wiki.analog.com/resources/tools-software/sigmastudio/developmentenvironment/toolbox">工具箱”</a>窗口插入块，则可能还必须添加算法。</p>
<p>添加算法时，不仅要为模块选择计算方法，还要为算法选择特定的DSP关联。如果要连接多个DSP处理器，这一点很重要：通过将算法添加到模块中，可以共享模块和控件，并同时与多个DSP进行通信。</p>
<p><strong>例如</strong>：<a target="_blank" rel="noopener" href="https://wiki.analog.com/resources/tools-software/sigmastudio/volumecontrols/singlevolumecontrol">单个音量控制</a>块具有用于所有算法的单个滑块控件。如果使用2个DSP处理器（IC 1（AD1940）和IC 2（ADAU1701））创建一个项目，然后选择“添加算法”，则系统将提示您要将该算法添加到哪个芯片。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic4.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Aalgorithms"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic4.png" alt="img" /></a></p>
<p>可以将第一种算法分配给IC 1，将第二种算法分配给IC 2，但是它们共享音量块和单个滑块控件。请注意，您不能在不同的处理器之间建立连线，有关更多信息，请参见<a target="_blank" rel="noopener" href="https://wiki.analog.com/resources/tools-software/sigmastudio/usingsigmastudio/wiresandaliases">连线</a>主题。</p>
<hr />
<p><strong>删除算法：</strong></p>
<p>也可以从块中删除算法。要删除算法，请<strong>右键单击</strong>该块，然后选择“<strong>删除算法”</strong>。这将删除最后添加的算法（底部引脚）。如果该块仅包含一种算法，则删除该算法将导致一个空块</p>
<hr />
<p><strong>增长算法：</strong></p>
<p>不断增长的算法意味着在该块的现有算法的基础上，保持相同的算法（在其上进行扩展）和相同的DSP关联（添加算法均不执行）。要增长算法，请<strong>右键单击</strong>该块，然后选择“<strong>增长算法”&gt;“（算法名称）”&gt;“（增长量）”</strong>。请注意，并非所有算法都可以使用增长。</p>
<p>理解添加和增长之间区别的最简单方法是使用混合器块。将交叉混合器（2个输入）拖到工作区中。右键单击并选择“增长算法”，请参见下面的示例。</p>
<ul>
<li>增加混音器会创建更多的混音器输出引脚，实际上，您正在创建共享公共输入的额外混音器输出通道。块中仍然只有一个算法。</li>
<li>添加算法将创建单独的算法，这些算法共享控制窗口，但不共享输入/输出引脚或资源。在混频器示例中，一个附加的输入引脚，输出引脚和一个交叉混频器控件被添加到了该模块中。</li>
</ul>
<hr />
<p><strong>减少算法：</strong></p>
<p>减少与增加相反，减少了由“增加算法”操作创建的多余控件和引脚。像删除算法一样，reduce将删除从底部或最近增长的项目开始的控件/大头针。</p>
<figure>
<img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/algorithmpic5.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="wires-and-aliases">Wires and Aliases</h3>
<p>SigmaStudio原理图设计由与“导线”连接在一起的模块构建。导线定义了系统的信号流。</p>
<p><strong>要创建原理图导线：</strong> 将鼠标光标移到块的<a target="_blank" rel="noopener" href="https://wiki.analog.com/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/schematicblocks">引脚上，</a>以便显示导线图标<a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/icon.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Awiresandaliases"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/icon.png" alt="img" /></a>。接下来，左键单击一个块引脚，然后在按住鼠标按钮的同时，将光标拖到另一个块的相应引脚上。输入引脚只能连接到输出引脚，而输出引脚只能连接到输入引脚。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic1.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Awiresandaliases"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic1.png" alt="img" /></a></p>
<p><strong>选择：</strong></p>
<p>要选择一条导线，请用鼠标左键单击它。选定的电线用绿色正方形（点）表示，如下所示。<strong>位置：</strong></p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic2.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Awiresandaliases"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic2.png" alt="img" /></a></p>
<p>要更改导线的位置，请将鼠标光标放在一个点上。接下来，在导线点上<strong>单击</strong>鼠标左键，并在按住鼠标键的同时拖动光标以重新放置导线。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic3.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Awiresandaliases"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic3.png" alt="img" /></a></p>
<p><strong>菜单：</strong></p>
<p>右键单击导线以调出导线菜单。该菜单包括以下命令：</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic4.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Awiresandaliases"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic4.png" alt="img" /></a></p>
<p><strong>电线颜色：</strong></p>
<p>电线根据其关联的DSP处理器进行着色。导线的输入和输出引脚必须与同一DSP关联，否则您将无法在引脚之间建立导线。具有多个处理器IC的项目的每个IC将具有不同的颜色。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic5.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Awiresandaliases"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic5.png" alt="img" /></a></p>
<hr />
<p><strong>引脚（导线）备注：</strong></p>
<p>为了直观地组织项目，通常有助于创建备注，以在原理图中的信号流中提供清晰的连接参考（“跳转”）。一个<strong>备注</strong>由一对输入的备注和备注输出块组成。使用备注块可以减少长导线连接所造成的原理图窗口中的视觉混乱。</p>
<p>要创建备注，请<strong>右键单击</strong>块的输出引脚（蓝色引脚），然后从菜单中选择“<strong>备注</strong>”。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic6.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Awiresandaliases"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic6.png" alt="img" /></a></p>
<p>当您单击<strong>Alias时</strong>，将出现两个块，分别是输入和输出。备注输入自动连接到源模块的输出引脚。接下来，创建一条从备注输出块（在下面的示例中为备注2）到信号目标的导线。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic7.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Awiresandaliases"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic7.png" alt="img" /></a></p>
<p><strong>注意：</strong>使用备注在功能上等同于用电线连接两个引脚。以下示例中的信号流与上面的备注示例相同。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic8.png?id=resources%3Atools-software%3Asigmastudio%3Ausingsigmastudio%3Abuildingschematics%3Awiresandaliases"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/usingsigmastudio/buildingschematics/wirespic8.png" alt="img" /></a></p>
<h3 id="hardware-configuration-tab">Hardware Configuration Tab</h3>
<p>硬件配置工作区允许您为设计选择一个或多个处理器。它还允许您设置SigmaStudio与硬件之间的通信。</p>
<p>要了解可以在“硬件配置”选项卡中访问的高级操作（包括“输出捕获”，“ Flash / E2Prom下载”，“寄存器控制”窗口和“寄存器读/写”窗口），请参阅“硬件Windows”部分中的主题。</p>
<p><strong>要将处理器（IC / DSP）插入设计中：</strong></p>
<ol type="1">
<li><p>用鼠标左键从工具箱中选择一个“处理器”：</p>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic1.png?id=resources%3Atools-software%3Asigmastudio%3Adevelopmentenvironment%3Ahardwareconfigurationtab"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic1.png" alt="img" /></a></li>
</ol></li>
<li><p>将处理器模块拖放到右侧的“硬件配置”窗口中：</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic2.png?id=resources%3Atools-software%3Asigmastudio%3Adevelopmentenvironment%3Ahardwareconfigurationtab"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic2.png" alt="img" /></a></p></li>
</ol>
<p><strong>注意：</strong>一旦在“硬件配置”窗口中插入DSP，就会出现“原理图（Schematic）”选项卡。</p>
<p><strong>在DSP处理器和硬件之间建立连接：</strong></p>
<ol type="1">
<li>单击“通信渠道（Communication Channel）”类别（在“工具箱”列的底部）。</li>
<li>从列表中选择评估板或USB设备，并将其拖放到工作区中。</li>
<li>通过在通信通道和处理器模块之间画线来连接两个模块，从蓝色菱形到绿色菱形。对于使用AD1940的USB连接，工作空间中的单元格应如下所示：</li>
</ol>
<p><strong>注意</strong>：“通信通道”菜单列出了带有前缀EvalBoard的名称和板号。这些通信通道将在不使用评估板设置的平台上适用于相同的IC类型。还有通用的通信通道，USBSerialConv和USBi。（有关更多信息，请参见USB串行转换器通信通道或USBi。）</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic3.png?id=resources%3Atools-software%3Asigmastudio%3Adevelopmentenvironment%3Ahardwareconfigurationtab"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic3.png" alt="img" /></a></p>
<p>通信模块上USB标签 的颜色表示是否已建立USB通信通道。如果您已正确配置USB硬件，则背景色将为浅橙色或白色。如果未初始化通信，则背景将为红色。请注意，这仅表示USB连接处于活动状态，不能保证与SigmaDSP IC的通信或SigmaDSP硬件已正确配置。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic4.png?id=resources%3Atools-software%3Asigmastudio%3Adevelopmentenvironment%3Ahardwareconfigurationtab"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic4.png" alt="img" /></a></p>
<p>连接所有板卡IC时，“已连接”背景色为白色，而仅连接部分IC（但不是全部）时为“橙色”。例如，ADAU1701评估板包括ADAU1701 IC和E2Prom IC。仅连接ADAU1701时，背景将为浅橙色，但同时连接ADAU1701和E2Prom IC时，背景将为白色。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic5.png?id=resources%3Atools-software%3Asigmastudio%3Adevelopmentenvironment%3Ahardwareconfigurationtab"><img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/developmentenvironment/hardwareconfpic5.png" alt="img" /></a></p>
<p>https://wiki.analog.com/_detail/resources/tools-software/sigmastudio/gettingstarted/usbinterfaces/usbpic4.png?id=resources%3Atools-software%3Asigmastudio%3Agettingstarted%3Ausbinterfaces%3Ausbserialconverter)</p>
<hr />
<p><strong>EVAL-ADUSB1板开关和跳线：</strong></p>
<ul>
<li>S1-将闪存中保存的程序加载到SigmaDSP。</li>
<li>S2-选择当按下S1时将加载八个SigmaDSP程序中的哪一个。</li>
<li>S3-重置USB适配器板。</li>
<li>TP1-+ 5Vdc连接，用于适配器未通过PC的USB端口供电的情况。</li>
<li>TP2-接地，用于适配器未通过PC的USB端口供电的情况。</li>
<li>J3-当该接头连接器上有跳线时，将启用对闪存的写操作（用于存储SigmaDSP程序）。</li>
<li>D4-此LED指示USB板已通电。</li>
</ul>
<p>可以使用SigmaStudio中的Flash Downloader工具将SigmaDSP程序和参数文件保存到USB板上的闪存中。通过将S2设置为适当的设置，然后按下程序加载按钮S1，可以将每个程序加载到SigmaDSP。请参阅Flash Downloader页面。 有关更多信息，请参见EVAL-ADUSB1数据手册，analog.com / sigmadsp。</p>
<h2 id="digital-attenuator">Digital Attenuator</h2>
<p>即数字衰减器， 与可变衰减器不同，数字衰减器在离散和有限衰减状态下切换。该切换通常以二进制步骤实现。数字衰减器采用半导体器件来实现每个衰减步骤。为此目的而使用的一些半导体器件包括：PIN二极管，MOSFET和GaAs MESFET。数字衰减器能够实现与固态开关速度相当的开关速率。数字衰减器使用的最常见逻辑类型 是CMOS逻辑电平和晶体管晶体管逻辑（TTL）。</p>
<p>数字衰减器利用驱动器电路来确定要使用的逻辑类型。驱动器电路的复杂性取决于所使用的位数。复杂度随着位数的增加而增加。通常根据数字衰减器设计提供的衰减状态对其进行分类。使用的位数决定了这些衰减状态。最高有效位提供最大的衰减，而最低有效位提供组件提供的最小衰减。其余位提供中间衰减值。通常，这些产品采用1位，5位，8位和6位数字衰减器。</p>
<p>如果选择了所有位，则数字衰减器旨在提供最大的额定衰减。另一方面，其最小衰减步长仅通过选择最低有效位来实现。数字衰减器在3G和4G蜂窝网络，点对点节点，中继器以及广泛的测试和测量应用中具有广泛的用途。</p>
<p class="italicp" style="font-style: italic; color: #BBB;">
Shop Arrow.com选择了数字RF步进衰减器，数字音频衰减器等。 <a hre="https://www.arrow.com/en/categories/attenuators/fixedvariable-attenuators/digital-attenuators#">&gt;&gt;&gt; read more</a>
</p>
<h2 id="asrc">ASRC</h2>
<p>异步采样速率转换器(ASRC，Asynchronous Sample Rate Converter)是一款可同时用于消费电子和专业应用的音频采样速率转换通用软件模块。 ASRC支持多种不同的采样速率配置。</p>
<p><strong>ASRC软件模块</strong> 可用于以小步长改变采样频率，步长随着时间改变，且在变化过程中不生成任何输出音频干扰。 在许多多媒体系统中，时变采样速率的改变是非常重要的功能，例如能实现多个数据流的精密同步以及服务器和客户端的同步等。</p>
<p>ADI公司的ASRC实施方案经过高度优化，适合在ADI公司的Blackfin系列处理器上运行。它是一个基于ADI专利设计的独立自足软件模块。该模块已经过各种根据音频信号质量分析定义的策略质量测试。</p>
<p>ASRC模块是应用于PCM（脉冲编码调制）上的后处理模块，通过模拟输入、数字输入通道或解码应用的PCM输出接收数据。 ASRC模块能够处理多个通道的输入信息，并能够输出至同样多的通道。 开发的模块支持全面的重入和多实例。 ASRC模块是一个独立的模块，不依赖其他任何模块。 ADRC模块配备一个示例轻型包装器API，将模块插入至整体系统。 这使得该应用的系统集成简单易行。</p>
<h3 id="asrc-inputoutput">ASRC INPUT/OUTPUT</h3>
<p>ASRC输入和输出模块在原理图设计和硬件ASRC（异步采样率转换器）之间路由信号。</p>
<p>使用输入块的复选框来启用或禁用特定输入。使用输出块的下拉列表控件从可用的ASRC中进行选择。</p>
<ul>
<li>每个ASRC输出必须连接其输入，否则编译时将出错。</li>
<li>可以看到，随着将更多的ASRC输出块拖到原理图中，下拉列表中的可用输出数量会减少，因为一次只能由一个块表示。</li>
<li>要更改ASRC <strong>输入采样率</strong>，请右键单击块名称，然后选择“设置采样率”，这将打开“采样率”窗口（默认值为44.1 kHz）。</li>
</ul>
<figure>
<img src="https://wiki.analog.com/_media/resources/tools-software/sigmastudio/toolbox/io/asrc_input_output_020.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="limiter-限幅器">Limiter 限幅器</h2>
<p>限幅器（Limiter）是指能按限定的范围削平信号电压波幅的电路，又称削波器。限幅电路的作用是把输出信号幅度限定在一定的范围内，亦即当输入电压超过或低于某一参考值后，输出电压将被限制在某一电平（称作限幅电平），且再不随输入电压变化。</p>
<h2 id="lsb-aligned">LSB-aligned</h2>
<p>LSB(Least Significant Bit)是“最低有效位”。MSB(Most Significant Bit)是“最高有效位”。</p>
<p>最高有效位是指二进制中最高值的比特，如：</p>
<blockquote>
<ol type="1">
<li><p>在16比特的数字音频中，其第1个比特便对16bit的字的数值有最大的影响。</p></li>
<li><p>在十进制的15，389这一数字中，相当于万数那1行（1）的数字便对数值的影响最大。比较与之相反的“最低有效位”（LSB）。</p></li>
<li><p>汇编中，比如8位2进制数10000001，其中第一个1是MSB,第二个1是LSB。<mark>1</mark>（MSB）100 001<mark>1</mark>（LSB）</p></li>
<li><p>在计算时，如果是整数，那么小数点（实际上是没有小数点的，但就把那一位和下一位之间看作有）在LSB后面；如果是小数，小数点在MSB后面；其中MSB在有符号数中又是符号位。</p></li>
</ol>
</blockquote>
<p>在网络通信方面，大家说的更多的是：“<strong>Big-Endian</strong>”和“<strong>Small-Endian</strong>”的问题。指的都是对于多字节的数据类型（比如4字节的32位整数），其多个字节的顺序问题，是最高字节在前（Big-Endian）还是最低字节在前（Small-Endian）。</p>
<p>比如对于123456789这个整数，其16进制为0x075BCD15，那么按照Big-Endian的方式，它在网络上传输（或者在内存里存储）的4个字节依次是：<code>07 4B CD 15</code>，而Small-Endian的顺序正相反，是：<code>15 CD 4B 07</code>。</p>
<p><strong>MSB</strong> 和 <strong>LSB</strong> 虽然跟这个事情看起来有点相似，但不是一回事。</p>
<p>通常，一个芯片的管脚中，对于一个多比特的信号，比如32根的地址线，从低开始按0到31编个号。MSB就是31，LSB就是0。那么如果标记为：ADDR[31:0]就是MSB first的方式，如果标记为ADDR[0:31]就是LSB first的方式。</p>
<p><strong>MSB LSB</strong>：起始地址为最高位， 最后地址为最低位。</p>
<p><strong>LSB MSB</strong>：起始地址为最低位，最后地址为最高位。</p>
<p>比如AD中，8位，最低有效位指D0</p>
<h2 id="cofficient-write">Cofficient Write</h2>
<p>即 <strong>参数写入</strong>，是指对参数中两组 <strong><em>寄存器参数集</em></strong> 的系数写入。当然也可以单独写入某个寄存器的数值。</p>
<p>可写入的参数如：filter coefficients、limiter settings、volume control settings等。</p>
<p>每组 <strong>寄存器参数集</strong> 可写入至多 160个参数（32个过滤器*5个系数）。</p>
<h2 id="filters">Filters</h2>
<p>在ADAU1772的General(2<sup>nd</sup> Order) Filter Setting中有几项过滤器，分别是 Parametric 、 Shelving 、 General HP/LP/BP/BS 、 Butterworth/Bessel 、 Tone Control、IIR Coefficient 、First Order Filters 、All Pass 、Peaking 、Notch 、 Chebyshev 共11中过滤器。</p>
<figure>
<img src="https://pic.islet.space/2021/04/image-20210428152357233.png" alt="image-20210428152357233" /><figcaption aria-hidden="true">image-20210428152357233</figcaption>
</figure>
<h1 id="sigmastudio">SigmaStudio</h1>
<p>以下简称sigma</p>
<h2 id="capture">Capture</h2>
<p>Capture 窗口会捕捉开发者对设置的相关改动记录。</p>
<figure>
<img src="https://pic.islet.space/2021/04/image-20210422165857465.png" alt="image-20210422165857465" /><figcaption aria-hidden="true">image-20210422165857465</figcaption>
</figure>
<h2 id="register-control">Register Control</h2>
<figure>
<img src="https://pic.islet.space/2021/04/image-20210422163633005.png" alt="image-20210422163633005" /><figcaption aria-hidden="true">image-20210422163633005</figcaption>
</figure>
<h3 id="outputserial-port">Output/Serial Port</h3>
<h4 id="下压式音量按键">下压式音量按键</h4>
<p>使用前需要进行跳线，跳线方法如下：</p>
<p><img src="https://pic.islet.space/2021/04/image-20210422163804275.png" alt="image-20210422163804275" style="zoom:50%;" /></p>
<p>控制界面如下：</p>
<figure>
<img src="https://pic.islet.space/2021/04/image-20210422163228410.png" alt="image-20210422163228410" /><figcaption aria-hidden="true">image-20210422163228410</figcaption>
</figure>
<blockquote>
<p>？？ Time</p>
<p>Initial PB Volume 初始化下压式按键的音量值</p>
<p>Gain Step 增益速度</p>
<p>Ramp Speed 增加速度</p>
<p>Converters Controlled by PushButton Volume 被控制的转换器</p>
</blockquote>
<h2 id="download-program">Download Program</h2>
<p><img src="https://pic.islet.space/2021/04/image-20210422170248954.png" alt="image-20210422170248954" style="zoom:67%;" /></p>
<figure>
<img src="https://pic.islet.space/2021/04/image-20210422170328013.png" alt="image-20210422170328013" /><figcaption aria-hidden="true">image-20210422170328013</figcaption>
</figure>
<h2 id="microphone">Microphone</h2>
<p>TRS 1/8-inch mini-plug stereo headphones</p>
<p><img src="https://pic.islet.space/2021/04/048f07ee-e357-4c06-a8e4-1724e62765a4_1.e937ba0bd42739fc09e9ef63602645b8.jpeg" alt="查看源图像" style="zoom:50%;" /></p>
<p>standard 0.100” headers</p>
<p><img src="https://pic.islet.space/2021/04/R68f2db356a43d3653db1298ccd26e835" alt="查看源图像" style="zoom:50%;" /></p>
<h3 id="bias-setting">Bias Setting</h3>
<figure>
<img src="https://pic.islet.space/2021/04/image-20210423102647330.png" alt="image-20210423102647330" /><figcaption aria-hidden="true">image-20210423102647330</figcaption>
</figure>
<p>ADAU1772包括两个麦克风偏置输出：MICBIAS0和MICBIAS1。这些引脚为驻极体模拟麦克风提供电压参考。</p>
<ol type="1">
<li>MICBIASx引脚也可用于为具有独立电源引脚的数字或模拟MEMS麦克风干净地提供电压。</li>
<li>MICBIASx电压在麦克风偏置控制寄存器（地址0x002D）中设置。可以利用这个寄存器对MICBIAS0或MICBIAS1的输出进行启用或禁用。</li>
<li>增益选项提供了两种可能的电压：0.65 × AVDD或0.90 × AVDD。许多应用要求只启用两个偏置输出中的一个。当系统中使用许多传声器时，或者当传声器在PCB上的位置不允许一个引脚对所有传声器进行偏置时，两个偏置输出都应该被启用。</li>
</ol>
<p>dataword byte : 在突发模式（burst mode）中使用。</p>
<p>data byte : 在单字模式（single-word mode）下写入。</p>
<h2 id="由dsp启动1772">由DSP启动1772</h2>
<p>1772启动可以通过以下两种方式执行：</p>
<ol type="1">
<li>通过SPI或I2C协议，将执行代码写入到SRAM的方式来执行</li>
<li>通过将代码写入EEPROM，并设置自启动的方式来读取和执行代码。</li>
</ol>
<p>由DSP启动1772，其实是通过上述第一种方式来进行，其中又可以再分为两种方法：</p>
<ol type="1">
<li>通过在SigmaStudio中导出项目系统文件，并加载至DSP项目工程的方式来执行，具体方法后述。</li>
<li>通过SPI协议，由DSP片选1772后逐各写入寄存器的方式来执行（注意：使用本方法时，单次写入量不可超过128个字节）。</li>
</ol>
<h3 id="通过导出系统文件的方式">通过导出系统文件的方式</h3>
<p>在SigmaStudio中，执行过 <code>Link Compile Downloa</code> 后，可以点击 <code>Export System Files</code> 导出项目工程文件（C格式）</p>
<p><img src="https://pic.islet.space/2021/05/image-20210510084234044.png" alt="image-20210510084234044" style="zoom:80%;" />，并将 <code>.h</code> 、<code>_PARAM.h</code> 及<code>_REG.h</code> 三个类型文件插入到DSP的项目文件中。</p>
<p><strong>注意</strong>：如图所示，所选的三个文件为主IC（1772）的工程文件，另外三个同后缀名的IC_2是另一个芯片（EEPROM）的文件，看情况决定是否使用。</p>
<p><img src="https://pic.islet.space/2021/05/image-20210510091831286.png" alt="image-20210510091831286" style="zoom:67%;" /></p>
<p>其中，<code>_PARAM.h</code> 及<code>_REG.h</code> 提供了对寄存器的定义，<code>.h</code> 文件中提供了唯一的执行方法 <code>default_download_IC_1()</code>，在DSP项目工程文件中执行即可。</p>
<p><img src="https://pic.islet.space/2021/06/20210601105542.png" alt="image-20210510092602442" style="zoom: 50%;" /></p>
<p><strong>注意：</strong>本文件依赖于 <code>SigmaStudioFW.h</code> 头文件，<img src="https://pic.islet.space/2021/05/image-20210510093228165.png" alt="image-20210510093228165" />，可以复制粘贴以下原代码，也可以在SigmaStudio的安装目录下查找。</p>
<p><mark>需要注意的是，以下所有宏定义内容都为空，需要开发者自行编写。</mark></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * File:			SigmaStudioFW.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description:  	SigmaStudio System Framwork macro definitions. These </span></span><br><span class="line"><span class="comment"> *				macros should be implemented for your system&#x27;s software.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This software is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment"> * but is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR </span></span><br><span class="line"><span class="comment"> * CONDITIONS OF ANY KIND, without even the implied warranty of</span></span><br><span class="line"><span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * This software may only be used to program products purchased from</span></span><br><span class="line"><span class="comment"> * Analog Devices for incorporation by you into audio products that </span></span><br><span class="line"><span class="comment"> * are intended for resale to audio product end users. This software</span></span><br><span class="line"><span class="comment"> * may not be distributed whole or in any part to third parties.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright � 2008 Analog Devices, Inc. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span>	</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SIGMASTUDIOFW_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SIGMASTUDIOFW_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> Update for your system&#x27;s data type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> ADI_DATA_U16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>  ADI_REG_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Parameter data format</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGMASTUDIOTYPE_FIXPOINT 	0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGMASTUDIOTYPE_INTEGER 	1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Write to a single Device register</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGMA_WRITE_REGISTER( devAddress, address, dataLength, data ) &#123;<span class="comment">/*<span class="doctag">TODO:</span> implement macro or define as function*/</span>&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> CUSTOM MACRO IMPLEMENTATION</span></span><br><span class="line"><span class="comment"> * Write to multiple Device registers </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGMA_WRITE_REGISTER_BLOCK( devAddress, address, length, pData ) &#123;<span class="comment">/*<span class="doctag">TODO:</span> implement macro or define as function*/</span>&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> CUSTOM MACRO IMPLEMENTATION</span></span><br><span class="line"><span class="comment"> * Writes delay (in ms) </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGMA_WRITE_DELAY( devAddress, length, pData ) &#123;<span class="comment">/*<span class="doctag">TODO:</span> implement macro or define as function*/</span>&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read device registers </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGMA_READ_REGISTER( devAddress, address, length, pData ) &#123;<span class="comment">/*<span class="doctag">TODO:</span> implement macro or define as function*/</span>&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set a register field&#x27;s value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGMA_SET_REGSITER_FIELD( regVal, fieldVal, fieldMask, fieldShift )  \</span></span><br><span class="line">		&#123; (regVal) = (((regVal) &amp; (~(fieldMask))) | (((fieldVal) &lt;&lt; (fieldShift)) &amp;&amp; (fieldMask))) &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the value of a register field</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGMA_GET_REGSITER_FIELD( regVal, fieldMask, fieldShift )  \</span></span><br><span class="line">		&#123; ((regVal) &amp; (fieldMask)) &gt;&gt; (fieldShift) &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Convert a floating-point value to SigmaDSP (5.23) fixed point format </span></span><br><span class="line"><span class="comment"> *    This optional macro is intended for systems having special implementation</span></span><br><span class="line"><span class="comment"> *    requirements (for example: limited memory size or endianness)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGMASTUDIOTYPE_FIXPOINT_CONVERT( _value ) &#123;<span class="comment">/*<span class="doctag">TODO:</span> IMPLEMENT MACRO*/</span>&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Convert integer data to system compatible format</span></span><br><span class="line"><span class="comment"> *    This optional macro is intended for systems having special implementation</span></span><br><span class="line"><span class="comment"> *    requirements (for example: limited memory size or endianness)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGMASTUDIOTYPE_INTEGER_CONVERT( _value ) &#123;<span class="comment">/*<span class="doctag">TODO:</span> IMPLEMENT MACRO*/</span>&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="通过写入寄存器的方式">通过写入寄存器的方式</h3>
<p>在 Capture 面板中，对寄存器的所有操作都会以 <strong>参数名</strong>、<strong>地址</strong> 和 <strong>数据</strong> 的方式展现，几乎所有参数名都可以在《ADAU1772》中查询。</p>
<p><img src="https://pic.islet.space/2021/05/image-20210510091150821.png" alt="image-20210510091150821" style="zoom: 67%;" /></p>
<ol type="1">
<li>全选面板中所有的值，可以点选第一个值，按 <code>SHIFT</code> + <code>END</code> 来全选，然后右键选择 <code>Save as Raw Data</code> 下的 <code>Address+Data(Text)...</code> ，会以文本格式 (.txt) 保存。</li>
</ol>
<p><img src="https://pic.islet.space/2021/05/image-20210510085052186.png" alt="image-20210510085052186" style="zoom:67%;" /></p>
<p>保存结果：</p>
<p><img src="https://pic.islet.space/2021/05/image-20210510085331956.png" alt="image-20210510085331956" style="zoom:67%;" /></p>
<ol start="2" type="1">
<li>将地址和值整理到DSP项目文件中进行写入，这种方式不太好操作，需要开发人员自行编写对应的代码，较为不友好。</li>
</ol>
<h1 id="chip-adau1772">CHIP-ADAU1772</h1>
<ul>
<li>ADAU1772以下简称1772</li>
<li>《Evaluation Board User Guide UG-477》以下简称UG</li>
</ul>
<h2 id="i2s及i2c接口">I2S及I2C接口</h2>
<p><img src="https://pic.islet.space/2021/06/20210601105550.png" alt="image-20210513171416187" style="zoom:67%;" /></p>
<p><img src="https://pic.islet.space/2021/06/20210601105615.png" alt="image-20210513171524562" style="zoom:67%;" /></p>
<h2 id="usbi-仿真器">USBi 仿真器</h2>
<ul>
<li>USBi驱动安装：进入设备管理器，安装驱动在SigmaStudio安装目录 <code>\Analog Devices\SigmaStudio 4.6\USB drivers\</code> 下。</li>
<li>连接到USBi未成功时是红色，设备驱动安装且连接成功时，USBi 在sigma中会由红变绿。</li>
<li>USBi作为中间板对1772进行控制，在USBi右键可以控制1772设备开断，开断时板上D1区的VDD指示灯也会通断（见page10）。</li>
<li>如果需要对设备进行实时控制，请务必记得打开设备，否则无法操作。</li>
</ul>
<p><img src="https://pic.islet.space/2021/04/image-20210428150645112.png" alt="image-20210428150645112" style="zoom: 67%;" /></p>
<ul>
<li>USBi将例程down到了板子上ADAU1772的SRAM上，断电就没有了。USBi的这种调试是为了快速验证功能，最终需要把这个例程的代码导出，并通过单片机的 <strong>启动工程集成</strong>，烧写到单片机中，实现单片机启动。</li>
</ul>
<p><img src="https://pic.islet.space/2021/04/image-20210427110916316.png" alt="image-20210427110916316" style="zoom:67%;" /></p>
<h3 id="编译烧录">编译烧录</h3>
<ul>
<li>烧录按键如下：</li>
</ul>
<figure>
<img src="https://pic.islet.space/2021/04/image-20210427162529600.png" alt="image-20210427162529600" /><figcaption aria-hidden="true">image-20210427162529600</figcaption>
</figure>
<ul>
<li>编译完毕后，SS会在右边的output窗体里显示编译结果，如有错误会提示错误信息，用户可据此信息去修改设计；</li>
<li>如成功则会显示资源占用信息，用户可根据百分比来增减模块。</li>
</ul>
<p><img src="https://pic.islet.space/2021/04/image-20210427111013493.png" alt="image-20210427111013493" style="zoom:67%;" /></p>
<h3 id="芯片">芯片</h3>
<p>板上共有4颗芯片，分别是 <strong>DSP</strong>、<strong>EEPROM</strong>、<strong>线性整流芯片</strong> 和 <strong>升压芯片</strong></p>
<p><img src="https://pic.islet.space/2021/04/image-20210427171901213.png" alt="image-20210427171901213" style="zoom:50%;" /></p>
<h4 id="u2-eeprom">U2: EEPROM</h4>
<p>ST官网对M24C32-F串行E2PROM的描述：</p>
<p>容量：32-Kbit</p>
<p>电压：1.7 ~ 5.5V</p>
<p>温差：-40 ~ +85℃</p>
<p><img src="https://pic.islet.space/2021/04/Snipaste_2021-04-27_17-18-01.png" alt="Snipaste_2021-04-27_17-18-01" style="zoom: 67%;" /></p>
<p><img src="https://pic.islet.space/2021/04/Snipaste_2021-04-27_17-18-18.png" alt="Snipaste_2021-04-27_17-18-18" style="zoom:67%;" /></p>
<h2 id="输入输出控制">输入输出控制</h2>
<h3 id="供电电压">供电电压</h3>
<p>以下为实际测量数值</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>USB_5V</th>
<th>SCL/SDA(H)</th>
<th></th>
<th>VDD</th>
<th>IOVDD</th>
<th>AVDD</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>接USBi实测电压(V)-3.3V档</td>
<td>3.471</td>
<td>1.961</td>
<td></td>
<td>1.997</td>
<td>1.997</td>
<td>1.988</td>
</tr>
<tr class="even">
<td>接21479实测电压(V)-3.3V档</td>
<td>4.463</td>
<td>3.518</td>
<td></td>
<td>3.518</td>
<td>3.518</td>
<td>3.518</td>
</tr>
<tr class="odd">
<td>接21479实测电压(V)-1.8V档</td>
<td>4.468</td>
<td>2.260</td>
<td></td>
<td>1.934</td>
<td>1.934</td>
<td>1.933</td>
</tr>
<tr class="even">
<td>接21479实测电压(V)-3.3V档</td>
<td>3.3</td>
<td>3.3088</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="hp输出">HP输出</h2>
<p>HP即Headphone缩写，HP输出有两个输出端，分别是DAC0 和 DAC1，分别对应为 EVAL板 上的 OUT R(HP Right) 和 OUT L(HP Left)。</p>
<p><img src="https://pic.islet.space/2021/04/image-20210427152251539.png" alt="image-20210427152251539" style="zoom:50%;" /></p>
<p><img src="https://pic.islet.space/2021/04/image-20210427143628880.png" alt="image-20210427143628880" style="zoom: 33%;" /></p>
<h3 id="输出静音">输出静音</h3>
<p><img src="https://pic.islet.space/2021/04/image-20210427153425633.png" alt="image-20210427153425633" style="zoom:50%;" /></p>
<h3 id="输出断电">输出断电</h3>
<p>关于HP输出的寄存器 <code>HP_EN_R</code> 及 <code>HP_EN_L</code> 说明：</p>
<p><img src="https://pic.islet.space/2021/04/image-20210427152528194.png" alt="image-20210427152528194" style="zoom:50%;" /></p>
<p><code>0x31</code> 即 <code>0011 0001</code> ，最后两位 <code>01</code> 即 <code>HP_PDN_L</code> 中的 <code>01</code> 。</p>
<h3 id="输出音量控制">输出音量控制</h3>
<ul>
<li>对输出音量进行控制需要先对S5、S6进行跳针。</li>
</ul>
<p><img src="https://pic.islet.space/2021/04/image-20210427110159648.png" alt="image-20210427110159648" style="zoom:67%;" /></p>
<h3 id="talkthru-dsp-bypass">TALKTHRU / DSP BYPASS</h3>
<blockquote>
<p>DSP BYPASS MODE When DSP bypass mode is enabled, a direct path from the ADC outputs to the DACs is set up to enable bypassing the core processing to listen to environmental sounds.</p>
<p>This is useful for listening to someone speaking without having to remove the noise cancelling headphones. The DSP bypass path is <strong>enabled by setting an MPx pin low</strong>.</p>
<p>Figure 92 shows the DSP bypass path disabled, and Figure 93 shows the DSP bypass path enabled by pressing the push-button switch.</p>
<figure>
<img src="https://pic.islet.space/2021/04/image-20210427144110884.png" alt="image-20210427144110884" /><figcaption aria-hidden="true">image-20210427144110884</figcaption>
</figure>
<p>The DSP bypass feature works for both analog and digital microphone inputs.</p>
<ul>
<li>Enabled when <strong><em>a switch</em></strong> connected to an MPx pin that is set to DSP bypass mode is closed and the MPx pin signal is pulled low.</li>
</ul>
<p>Pressing and holding the switch closed enables the DSP bypass signal path as defined in the TALKTHRU register (Address 0x002A).</p>
<p>The DAC volume control setting is switched from the default gain setting to the new TALKTHRU_GAINx register setting (Address 0x002B and Address 0x002C).</p>
<ul>
<li>DSP bypass is enabled only on ADC0 and ADC1.</li>
</ul>
<p>The DSP bypass signal path is from the output of ADCx to the input of the DAC(s). When DSP bypass is enabled, the current DAC volume setting is ramped down to −95.625 dB and the DSP bypass volume setting is ramped up to avoid pops when switching paths.</p>
</blockquote>
<h1 id="chip-adsp21479">CHIP-ADSP21479</h1>
<h2 id="芯片及评估板资料">芯片及评估板资料</h2>
<p><strong>关于芯片特性</strong>：《ADSP-21477 / ADSP-21478 / ADSP-21479》</p>
<p><strong>关于评估板</strong>：《ADSP-21479 EZ-Board® Evaluation System Manual》</p>
<h2 id="仿真器配置">仿真器配置</h2>
<p>与《HPUSB, USB, and HPPCI Emulators User’s Guide》所描述的并不完全一致。</p>
<p><img src="https://pic.islet.space/2021/05/image-20210519104127472.png" alt="image-20210519104127472" style="zoom: 50%;" /></p>
<p>下图为实际安装后，查看官方对21479提供的相关仿真器的信息和从设备管理器中可查看到的设备信息。</p>
<figure>
<img src="https://pic.islet.space/2021/05/20210519110546.png" alt="image-20210519104034539" /><figcaption aria-hidden="true">image-20210519104034539</figcaption>
</figure>
<p><img src="https://pic.islet.space/2021/05/20210519110551.png" alt="image-20210519104001549" style="zoom:67%;" /></p>
<p>本评估板提供的仿真器使用的是14针脚的HPPCI JTAG，PCI仿真器支持的<mark>操作模式取决于目标机上</mark>14针JTAG接头<mark>的连接方式</mark>。表1-2显示了目标机JTAG头在传统和自动检测模式下的连接方式。</p>
<p><img src="https://pic.islet.space/2021/05/image-20210519105525684.png" alt="image-20210519105525684" style="zoom:67%;" /></p>
<p><strong>注意</strong>：其中3口是无针脚的防呆设计。</p>
<h3 id="hpusb-jtag模式">HPUSB JTAG模式</h3>
<p>在实际开发中，使用的是HPUSB传统模式。</p>
<p>传统模式用于不提供目标VDDIO输入的旧目标，供仿真器自动检测电压。 在这种模式下，JTAG信号运行的电压是通过配置器工具手动设置的。在配置目标时，配置器工具提供了一个电压选择设置。</p>
<blockquote>
<p>Legacy mode is used for older targets that do not provide a target VDDIO input for automatic voltage detection by the emulator.</p>
<p>In this mode, the voltage at which the JTAG signals run is set manually through the Configurator utility.</p>
<p>The configurator utility provides a voltage selection setting when configuring the target.</p>
</blockquote>
<p><strong>注意</strong>：HPUSB-ICE 和 USB-ICE 仿真器都不支持自动电压检测模式。</p>
<p>以下为JTAG的电路示意：</p>
<p><img src="https://pic.islet.space/2021/05/20210519111130.png" alt="image-20210519111126670" style="zoom:80%;" /></p>
<h2 id="i2ctwi串行通信">I2C/TWI串行通信</h2>
<p>根据文件《ADSP-21477_21478_21479_cn》的描述，可知21479支持TWI接口，进而支持I2C。</p>
<p><img src="https://pic.islet.space/2021/05/20210519112440.png" alt="image-20210519112357298" style="zoom:67%;" /></p>
<p>21479没有针对TWI做专门的驱动，Blackfin系列大部分产品都提供了。</p>
<h2 id="dai接口">DAI接口</h2>
<p><strong>Digital Application Interface</strong>，即数字应用接口。所有数字应用接口都以SRU的方式连接至处理器。</p>
<p><strong>SRU</strong>（Signal Routing Unit），即信号路由单元。SRU是处理器内部的一个提供超大系统信号流的复杂路由系统。通过SRU可以将DAI针脚利用不同组合路由至不同的内部设备。DAI所能连接的设备在每块评估板上都不同。下图展示了DAI接口的针脚、所连接的设备及其网络、所连接的开关和默认设置。</p>
<p><mark>要在扩展II接口上使用DAI，请先用相关开关禁用驱动DAI引脚上的任何信号。</mark></p>
<p><img src="https://pic.islet.space/2021/05/20210520110351.png" alt="image-20210520110207578" style="zoom:67%;" /></p>
<p><img src="https://pic.islet.space/2021/05/20210520110355.png" alt="image-20210520110221920" style="zoom:67%;" /></p>
<h2 id="dpi接口">DPI接口</h2>
<p>Digital Peripheral Interface，即数字外围（设备）接口 或 数字设备接口。DPI连接至第二块信号路由单元（SRU2）。</p>
<p>与SRU相似，SRU2也是一块能将大型系统信号流路由至处理器的复杂路由系统。</p>
<p>同样，每块评估板的DPI所连接的设备也不同。下图同：</p>
<p><img src="https://pic.islet.space/2021/06/20210601105459.png" alt="image-20210520111001486" style="zoom:67%;" /></p>
<p><img src="https://pic.islet.space/2021/06/20210612111612.png" alt="image-20210612111607855" style="zoom:67%;" /></p>
<p><img src="https://pic.islet.space/2021/06/20210612111852.png" alt="image-20210612111848897" style="zoom:67%;" /></p>
<h2 id="sru.h">SRU.H</h2>
<h3 id="sru">SRU()</h3>
<p>以下是 <code>&lt;sru21479.h&gt;</code> 中对 <code>SRU()</code> 的宏定义，<code>SRU2()</code> 与其相同 ：<code>#define SRU2(out,in)   SRU(out,in)</code>。</p>
<p>读取、修改和写回一个特定的SRU寄存器，以改变一个SRU的分配（即选择一个输入到一个输出）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Macro: SRU</span></span><br><span class="line"><span class="comment">** Reads, modifies and writes back a particular SRU register to change a single</span></span><br><span class="line"><span class="comment">** SRU assignment (i.e. selects an input to an output).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> _LANGUAGE_C</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> SRU(out,in)                        \</span></span><br><span class="line">     <span class="keyword">do</span> &#123;                                    \</span><br><span class="line">       *(<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *) in##_REG = \</span><br><span class="line">         ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)sru_field(out,in) |  \</span><br><span class="line">         (* (<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *) in##_REG &amp; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sru_mask(out,in))); \</span><br><span class="line">     &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> SRU(out,in)        \</span></span><br><span class="line">     r0=dm(in##_REG);        \</span><br><span class="line">     r1=sru_mask(out,in);    \</span><br><span class="line">     r0=r0 <span class="keyword">and</span> r1;           \</span><br><span class="line">     r1=sru_field(out,in);   \</span><br><span class="line">     r0=r0 <span class="keyword">or</span> r1;            \</span><br><span class="line">     dm(in##_REG)=r0;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="sru_field">sru_field()</h3>
<p>为一个给定的输入和输出信号创建位域（bit field）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">**   Macro: sru_field</span></span><br><span class="line"><span class="comment">**   Creates the bit field for a given input and output signal.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sru_field(out,in) \</span></span><br><span class="line">    (((in##_GROUP &amp; GROUP_A) &gt;&gt; LOG_GROUP_A) * A_#<span class="meta">#out \</span></span><br><span class="line">    |((in##_GROUP &amp; GROUP_B) &gt;&gt; LOG_GROUP_B) * B_#<span class="meta">#out \</span></span><br><span class="line">    |((in##_GROUP &amp; GROUP_C) &gt;&gt; LOG_GROUP_C) * C_#<span class="meta">#out \</span></span><br><span class="line">    |((in##_GROUP &amp; GROUP_D) &gt;&gt; LOG_GROUP_D) * D_#<span class="meta">#out \</span></span><br><span class="line">    |((in##_GROUP &amp; GROUP_E) &gt;&gt; LOG_GROUP_E) * E_#<span class="meta">#out \</span></span><br><span class="line">    |((in##_GROUP &amp; GROUP_F) &gt;&gt; LOG_GROUP_F) * F_#<span class="meta">#out \</span></span><br><span class="line">    |((in##_GROUP &amp; GROUP_G) &gt;&gt; LOG_GROUP_G) * G_#<span class="meta">#out \</span></span><br><span class="line">    |((in##_GROUP &amp; GROUP_H) &gt;&gt; LOG_GROUP_H) * H_#<span class="meta">#out \</span></span><br><span class="line">    |((in##_GROUP &amp; GROUP_I) &gt;&gt; LOG_GROUP_I) * I_#<span class="meta">#out \</span></span><br><span class="line">    |((in##_GROUP &amp; GROUP_A2)&gt;&gt; LOG_GROUP_A2)* A2_#<span class="meta">#out \</span></span><br><span class="line">    |((in##_GROUP &amp; GROUP_B2)&gt;&gt; LOG_GROUP_B2)* B2_#<span class="meta">#out \</span></span><br><span class="line">    |((in##_GROUP &amp; GROUP_C2)&gt;&gt; LOG_GROUP_C2)* C2_#<span class="meta">#out ) &lt;&lt; in##_SHIFT</span></span><br></pre></td></tr></table></figure>
<h3 id="sru_mask">sru_mask()</h3>
<p>创建一个掩码，可用于清除属于给定输入和输出信号的位域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">**   Macro: sru_mask </span></span><br><span class="line"><span class="comment">**   Creates a mask which can be used for clearing the bitfield belonging </span></span><br><span class="line"><span class="comment">**   to the given input and output signal.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sru_mask(out,in) \</span></span><br><span class="line">     ~((((in##_GROUP &amp; GROUP_A) &gt;&gt; LOG_GROUP_A) * MASK_A \</span><br><span class="line">       |((in##_GROUP &amp; GROUP_B) &gt;&gt; LOG_GROUP_B) * MASK_B \</span><br><span class="line">       |((in##_GROUP &amp; GROUP_C) &gt;&gt; LOG_GROUP_C) * MASK_C \</span><br><span class="line">       |((in##_GROUP &amp; GROUP_D) &gt;&gt; LOG_GROUP_D) * MASK_D \</span><br><span class="line">       |((in##_GROUP &amp; GROUP_E) &gt;&gt; LOG_GROUP_E) * MASK_E \</span><br><span class="line">       |((in##_GROUP &amp; GROUP_F) &gt;&gt; LOG_GROUP_F) * MASK_F \</span><br><span class="line">       |((in##_GROUP &amp; GROUP_G) &gt;&gt; LOG_GROUP_G) * MASK_G \</span><br><span class="line">       |((in##_GROUP &amp; GROUP_H) &gt;&gt; LOG_GROUP_H) * MASK_H \</span><br><span class="line">       |((in##_GROUP &amp; GROUP_I) &gt;&gt; LOG_GROUP_I) * MASK_I \</span><br><span class="line">       |((in##_GROUP &amp; GROUP_A2)&gt;&gt; LOG_GROUP_A2)* MASK_A2\</span><br><span class="line">       |((in##_GROUP &amp; GROUP_B2)&gt;&gt; LOG_GROUP_B2)* MASK_B2\</span><br><span class="line">       |((in##_GROUP &amp; GROUP_C2)&gt;&gt; LOG_GROUP_C2)* MASK_C2) &lt;&lt; in##_SHIFT)</span><br></pre></td></tr></table></figure>
<h3 id="示例">示例</h3>
<p>如下图所示，1~8的LED灯珠都与一个处理器针脚相连。DPI和DAI在此处并没有严格划分界限，但是用法上仍有些差异，如前三个LED连接的是DPI针脚，其函数<code>SRU()</code>的第一个参数写的是 <code>FLAG</code>，而其他 DAI 的第一个参数是 <code>LOW</code> 。</p>
<p><img src="https://pic.islet.space/2021/05/20210520113348.png" alt="image-20210520113025876" style="zoom:50%;" /></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void Init_LEDs(void)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* 设置SRU和路由，使标志引脚连接到DPI引脚缓冲区 *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;* 只使用标志4至15，标志0至3在DPI上不可用。 *&#x2F;</span><br><span class="line"></span><br><span class="line">	SRU(FLAG4_O,DPI_PB06_I);	&#x2F;* 将 Flag4 输出 连接到 DPI_PB06 输入（用于LED1） *&#x2F;</span><br><span class="line">	SRU(FLAG5_O,DPI_PB13_I);	&#x2F;* 将 Flag5 输出 连接到 DPI_PB13 输入（用于LED2） *&#x2F;</span><br><span class="line">	SRU(FLAG6_O,DPI_PB14_I);	&#x2F;* 将 Flag6 输出 连接到 DPI_PB14 输入（用于LED3） *&#x2F;</span><br><span class="line"></span><br><span class="line">	SRU(LOW,DAI_PB03_I);	    &#x2F;* connect Input LOW to LED4 *&#x2F;</span><br><span class="line">	SRU(LOW,DAI_PB04_I);    	&#x2F;* connect Input LOW to LED5 *&#x2F;</span><br><span class="line">	SRU(LOW,DAI_PB15_I);		&#x2F;* connect Input LOW to LED6 *&#x2F;</span><br><span class="line">	SRU(LOW,DAI_PB16_I);		&#x2F;* connect Input LOW to LED7 *&#x2F;</span><br><span class="line">	SRU(LOW,DAI_PB17_I);		&#x2F;* connect Input LOW to LED8 *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;* 使用以下顺序启用缓冲器：高电平-&gt;输出，低电平-&gt;输入 *&#x2F;</span><br><span class="line"></span><br><span class="line">	SRU(HIGH,DPI_PBEN06_I);		&#x2F;* LED1 *&#x2F;</span><br><span class="line">	SRU(HIGH,DPI_PBEN13_I);		&#x2F;* LED2 *&#x2F;</span><br><span class="line">	SRU(HIGH,DPI_PBEN14_I);		&#x2F;* LED3 *&#x2F;</span><br><span class="line">	SRU(HIGH,PBEN03_I);			&#x2F;* LED4 *&#x2F;</span><br><span class="line">	SRU(HIGH,PBEN04_I);			&#x2F;* LED5 *&#x2F;</span><br><span class="line">	SRU(HIGH,PBEN15_I);			&#x2F;* LED6 *&#x2F;</span><br><span class="line">	SRU(HIGH,PBEN16_I);			&#x2F;* LED7 *&#x2F;</span><br><span class="line">	SRU(HIGH,PBEN17_I);			&#x2F;* LED8 *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;* 将标志引脚设置为输出 *&#x2F;</span><br><span class="line">	sysreg_bit_set( sysreg_FLAGS, (FLG4O|FLG5O|FLG6O) );</span><br><span class="line"></span><br><span class="line">	&#x2F;* 清除标志引脚 *&#x2F;</span><br><span class="line">	sysreg_bit_clr( sysreg_FLAGS, (FLG4|FLG5|FLG6) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定时器">定时器</h2>
<p>《ADSP-21477_21478_21479_cn》</p>
<figure>
<img src="https://pic.islet.space/2021/06/20210611170206.png" alt="image-20210611170204474" /><figcaption aria-hidden="true">image-20210611170204474</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/06/20210611170307.png" alt="image-20210611170253655" /><figcaption aria-hidden="true">image-20210611170253655</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/06/20210611170344.png" alt="image-20210611170342735" /><figcaption aria-hidden="true">image-20210611170342735</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/06/20210611170357.png" alt="image-20210611170355842" /><figcaption aria-hidden="true">image-20210611170355842</figcaption>
</figure>
<h3 id="创建定时器">创建定时器</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Install and enable a handler for the high priority core timer interrupt.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">adi_int_InstallHandler(ADI_CID_TMZHI, <span class="comment">/*iid - high priority core timer */</span></span><br><span class="line">		               timer_isr,     <span class="comment">/*handler*/</span></span><br><span class="line">		               (<span class="keyword">void</span> *)&amp;timer_isr_count1, <span class="comment">/*handler parameter*/</span></span><br><span class="line">		                <span class="literal">true</span>           <span class="comment">/*do enable*/</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="定时器中断句柄">定时器中断句柄</h3>
<p>来自实例《core_timer》:</p>
<ul>
<li>在定时器中断句柄 <code>timer_isr</code> 里面，不能调用标准IO函数，或者更新非volatile全局变量</li>
<li>可以使用处理程序参数来识别被处理的中断 <code>iid</code>，并通过中断特定的回调指针参数 <code>handlerArg</code> 来访问数据。</li>
</ul>
<figure>
<img src="https://pic.islet.space/2021/06/20210621154021.png" alt="image-20210612151008408" /><figcaption aria-hidden="true">image-20210612151008408</figcaption>
</figure>
<h1 id="examples">EXAMPLES</h1>
<h2 id="exp1">EXP1</h2>
<p>本案例使用麦克风采集信号并从前两个通道输入，经过信号增益放大器调整后经过立体声通道输出。</p>
<p>具体步骤如下：</p>
<ol type="1">
<li>从左侧 <strong>树状工具箱</strong>(TreeToolBox)中拖出1772和USBi，并进行连接。</li>
</ol>
<p><img src="https://pic.islet.space/2021/05/image-20210428094527305.png" alt="image-20210428094527305" style="zoom: 67%;" /></p>
<ol start="2" type="1">
<li>在 <strong>原理图（SCHEMATIC)</strong> <img src="https://pic.islet.space/2021/05/image-20210506150111553.png" alt="image-20210506150111553" style="zoom:80%;" />中需要对输入输出路径进行定义，在此处定义的所有图形编程内容都是对 <strong>可编程增益放大器（PGA）</strong>的使用，即此处的输入到输出所有内容都不经过 <strong>信号通路（SIGNAL ROUTING）</strong> 选项卡中的 <strong>音频处理核心（AUDIO PROCESSING CORE）</strong>，是由 <strong>核心输入选择器（CORE INPUT SELECTION）</strong>完成的，<mark>也可以理解为PGA就是在其中，且PGA的设置在原理图中进行。</mark></li>
</ol>
<p><img src="https://pic.islet.space/2021/05/image-20210506145903478.png" alt="image-20210506145903478" style="zoom:67%;" /></p>
<ol start="3" type="1">
<li>在原理图中，从左侧 <img src="https://pic.islet.space/2021/05/image-20210506150230833.png" alt="image-20210506150230833" style="zoom:80%;" /> 拖出组件并连线如下，其中需要用到四个通道中的第1及第2通道，每个通告分别连接到一个 <strong>线性增益器（LINEAR GAIN）</strong>，增益50分贝，将原本的麦克风信号从-60分贝左右提升一下。然后经过 <strong>全通角过滤器（ALL POLE FILTER）</strong>,对1500Hz以下的声音增益10分贝。再经过 <strong>分线器（T CONNECTION）</strong>，将信号分别传输给 <strong>分贝显示器（DISPLAY DBREG）</strong>及 <strong>输出通道（OUTPUT）</strong>。</li>
</ol>
<p><img src="https://pic.islet.space/2021/05/image-20210428095433721.png" alt="image-20210428095433721" style="zoom:80%;" /></p>
<p><img src="https://pic.islet.space/2021/05/image-20210506144919655.png" alt="image-20210506144919655" style="zoom: 80%;" /></p>
<ol start="4" type="1">
<li>另，PGA的设置还需要在 <strong>PGA/ADC</strong> 选项卡中进行设置：</li>
</ol>
<ul>
<li>启用<strong>PGA<sub>x</sub></strong> 及 <strong>PGA<sub>x</sub> Boost</strong></li>
<li>启用 <strong>Mic<sub>x</sub> Bias</strong></li>
<li>调整 各通道的增益大小等</li>
</ul>
<p><img src="https://pic.islet.space/2021/05/image-20210506145534521.png" alt="image-20210506145534521" style="zoom:80%;" /></p>
<ol start="5" type="1">
<li>对 <strong>信号通路</strong> 选项卡进行设置，使信号不经过 <strong>音频处理核心</strong> ，启用 <strong>输出ASRC源选择器（OUTPUT ASRC SOURCE SELECT）</strong> ，信号经流如图示：</li>
</ol>
<p><img src="https://pic.islet.space/2021/05/image-20210506150516695.png" alt="image-20210506150516695" style="zoom: 80%;" /></p>
<ol start="6" type="1">
<li>​ 如果设置芯片使用，可以在 <strong>芯片控制（CHIP CONTROL）</strong>选项卡中设置性能增强模式</li>
</ol>
<p><img src="https://pic.islet.space/2021/05/image-20210506151533990.png" alt="image-20210506151533990" style="zoom:80%;" /></p>
<ol start="7" type="1">
<li>接入正常的TS接口麦克风即可输入正常波形。</li>
</ol>
<h2 id="exp2">EXP2</h2>
<p>本案例为PLL及时钟案例，首先需要明确以下几点：</p>
<ol type="1">
<li>1772的工作频率为12.288兆赫，PLL的输出频率被要求一定是24.576兆赫。</li>
<li>且从MCLKIN输入的频率范围为8至27兆赫，可以通过整数或分数分频来获得1772所需的工作频率（最终必须是12.288兆赫）。</li>
<li>通过设置4个参数 <code>x</code> 、<code>R</code>、<code>N</code> 及 <code>M</code> 对PLL进行参数调整，其中整数倍分频时只有在 <code>MCLKIN = 12.288MHz</code> 或 <code>MCLKIN = 24.576MHz</code> 时可用。</li>
</ol>
<p>已知，MCLK的输入频率16.625MHz，符合输入范围要求，以及最终目标输出频率24.576MHz。</p>
<p>首先启用PLL，点击<img src="https://pic.islet.space/2021/05/image-20210513100438475.png" alt="image-20210513100438475" style="zoom: 67%;" />，然后通过对 <code>PLL M and N Calculator</code> 进行设置，并点击 <code>Load Parameters</code> 进行自动计算和加载即可。</p>
<p>在主时钟源选项（Main Clock Source）中选择经过PLL处理的时钟源，并设置主时钟和核心时钟的分频率为 1/2即可。</p>
<p>从旁边也可以看到自动计算出来的分频系数：<img src="https://pic.islet.space/2021/05/image-20210513100800163.png" alt="image-20210513100800163" /></p>
<figure>
<img src="https://pic.islet.space/2021/05/image-20210513100908671.png" alt="image-20210513100908671" /><figcaption aria-hidden="true">image-20210513100908671</figcaption>
</figure>
<p>除了可以直接应用 SigmaStudio 的 <code>load parameters</code> 直接进行参数计算外，可以参考《在linux上编写求解ADAU1772的PLL系数》文章，自行系数计算。</p>
<h2 id="exp3">EXP3</h2>
<p>本例中主要完成TWI代码的编写，具体可以参见《I2C通信》笔记。以下是一开始的开发思路：</p>
<p>利用ADI官方提供（导出）的C代码，通过I2C协议向ADAU1772 codec芯片写入寄存器值，在ADAU寄存器写入的C代码中，依赖头文件<code>&lt;SigmaStudioFW.h&gt;</code>，其所有宏定义类型的函数都需要用户自行定义。</p>
<figure>
<img src="https://pic.islet.space/2021/05/20210520095649.png" alt="image-20210520095648245" /><figcaption aria-hidden="true">image-20210520095648245</figcaption>
</figure>
<h3 id="arduino示例">Arduino示例</h3>
<p>在Github上的 <strong><a target="_blank" rel="noopener" href="https://github.com/ColeMahlowitz/ADAU1761-Self-Boot-With-Arduino">ADAU1761-Self-Boot-With-Arduino</a></strong> 中，适用于 Arduino 和 ADAU1761 的寄存器块（WRITE_REGISTER_BLOCK）定义实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void SIGMA_WRITE_REGISTER_BLOCK(byte IC_address, word subAddress, int dataLength, byte pdata[]) &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; start I2C transfer</span><br><span class="line">  if (!i2c_start((IC_address)|I2C_WRITE)) &#123; </span><br><span class="line">    Serial.println(&quot;I2C device busy for WRITE REGISTER BLOCK&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; write subAddresses. (ADAU1761 needs the 16 bit subAddress written as two 8 bit bytes with an &quot;ACK&quot; inbetween</span><br><span class="line">  uint8_t addressLowByte &#x3D; subAddress &amp; 0xff;</span><br><span class="line">  uint8_t addressHighByte &#x3D; (subAddress &gt;&gt; 8);</span><br><span class="line"></span><br><span class="line">  i2c_write(addressHighByte); </span><br><span class="line">  i2c_write(addressLowByte); </span><br><span class="line"></span><br><span class="line">  if (dataLength &lt; 50 ) &#123;</span><br><span class="line">    for (int i&#x3D;0; i&lt;dataLength; i++) &#123; </span><br><span class="line">      i2c_write(pdata[i]); &#x2F;&#x2F;write data bytes</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123; </span><br><span class="line">    for (int i&#x3D;0; i&lt;dataLength; i++) &#123;</span><br><span class="line">      i2c_write(pgm_read_byte_near(pdata + i)); &#x2F;&#x2F;write data bytes from PROGMEM (for param and program data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  i2c_stop(); &#x2F;&#x2F; stop the I2C communication</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在MBED网站中，大量往右对ADAU1701的 <code>&lt;SigmaStudioFW.h&gt;</code> 提供了支持，原网页如：<a target="_blank" rel="noopener" href="https://os.mbed.com/forum/electronics/topic/4784/">ADAU1701</a></p>
<p>将宏定义改为函数形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SIGMA_WRITE_REGISTER_BLOCK</span><span class="params">(<span class="keyword">int</span> devAddress, <span class="keyword">int</span> address, <span class="keyword">int</span> length, ADI_REG_TYPE *pData )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ii = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> zz = <span class="number">0</span>;</span><br><span class="line">    Tx_Idx = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*----- Transmission Phase -----*/</span></span><br><span class="line">    ThisBufferSize = Address_Length + length; </span><br><span class="line"> </span><br><span class="line">    I2C1_Buffer_Tx[<span class="number">0</span>] =   (address &amp; <span class="number">0xFF00</span>)&gt;&gt;<span class="number">8</span>;</span><br><span class="line">    I2C1_Buffer_Tx[<span class="number">1</span>] =   address &amp; <span class="number">0x00FF</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(zz=<span class="number">0</span>;zz&lt;length;zz++)&#123;</span><br><span class="line">    	I2C1_Buffer_Tx [zz + Address_Length] =   pData[zz];</span><br><span class="line">    &#125; </span><br><span class="line">    Tx_Idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ii =<span class="number">0</span>;ii &lt; ThisBufferSize;ii++)&#123;    </span><br><span class="line">        NextBufferEnd =  ThisBufferSize;<span class="comment">//I2C1_numbytes[ii];    </span></span><br><span class="line">        <span class="keyword">if</span>(ii == <span class="number">0</span>)&#123;</span><br><span class="line">            I2C_GenerateSTART(I2C1, ENABLE);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">/* Send data */</span></span><br><span class="line">        <span class="keyword">while</span>(Tx_Idx &lt; NextBufferEnd)   </span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SIGMA_WRITE_DELAY</span><span class="params">(<span class="keyword">int</span> devAddress, <span class="keyword">int</span> length, ADI_REG_TYPE *pData )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nCount=<span class="number">0</span>;</span><br><span class="line">    nCount=<span class="number">0xFFFFF</span>;</span><br><span class="line">    <span class="keyword">for</span>(; nCount != <span class="number">0</span>; nCount--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的代码已经贴在《I2C通信》了，21478和21479支持TWI的寄存器控制，但是更为复杂，官方没有给示例，因此使用了引脚高低高低电平的控制来实现通信。</p>
<h3 id="数字逻辑分析仪">数字逻辑分析仪</h3>
<p>在EXP3中会频繁采集I2C、I2S、SPI等通信协议发过来的数据，因此需要使用数字逻辑分析仪进行数据采集和分析，在本次开发过程中使用了两种数字逻辑分析仪，分别是 <strong><em>USBee Suite</em></strong> 和 <strong><em>Saleae Logic</em></strong> ，推荐使用后者，软件更夹稳定、成熟和易使用。如果采用前者，那么软件经常崩溃。后者在采集I2S等高速通信协议中的电平信号时，需要将采样速率提升一下，24MS/s 的速度仍然能会采样变形。</p>
<figure>
<img src="https://pic.islet.space/2021/06/20210623161904.png" alt="image-20210623134058687" /><figcaption aria-hidden="true">image-20210623134058687</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/06/20210623161909.png" alt="image-20210623134114244" /><figcaption aria-hidden="true">image-20210623134114244</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/06/20210623161911.png" alt="image-20210623133953887" /><figcaption aria-hidden="true">image-20210623133953887</figcaption>
</figure>
<p>​</p>
<figure>
<img src="https://pic.islet.space/2021/06/20210623161914.png" alt="image-20210623134006076" /><figcaption aria-hidden="true">image-20210623134006076</figcaption>
</figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/22/Linux/System/2021-04-22-Linux%E5%88%86%E5%8C%BA%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/22/Linux/System/2021-04-22-Linux%E5%88%86%E5%8C%BA%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">Linux分区及文件系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-22 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-22T23:58:32+08:00">2021-04-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-26 00:14:16" itemprop="dateModified" datetime="2021-04-26T00:14:16+08:00">2021-04-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="linux分区与挂载">Linux分区与挂载</h1>
<h2 id="分区表">分区表</h2>
<p><strong>分区表</strong>(partition table)是将大表的数据分成称为分区的许多小的子集，类型有FAT16, FAT32, NTFS, exFAT, Ext2/3/4, HFS+, VMFS。另外，分区表的种类划分主要有：range（范围）、list（列表）和hash（散列）分区。划分依据主要是根据其表内部属性。同时，分区表可以创建其独特的分区索引。倘若硬盘丢失了分区表，数据就无法按顺序读取和写入，导致无法操作。</p>
<p>Kali Linux支持的分区表类型：aix、amiga、bsd、dvh、gpt、mac、msdos、pc98、sun、atari 及 loop。</p>
<h2 id="磁盘结构">磁盘结构</h2>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/kzq6k9g8x7.png" /></p>
<p>磁盘结构</p>
<p>磁盘主要分为以下结构：</p>
<ul>
<li>磁头（head）：对磁盘的数据进行读写</li>
<li>磁道（track）：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道。 磁盘上的磁道是一组记录密度不同的同心圆</li>
<li>扇区（sector）：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区。硬盘的第一个扇区，叫做引导扇区。 一个扇区的大小为512个字节。</li>
<li>柱面（cylinder）：在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面。</li>
</ul>
<p>整个磁盘的存储大小为： <strong>存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数</strong></p>
<h2 id="磁盘的使用">磁盘的使用</h2>
<p>一块新的硬盘或者U盘等外部设备在插入PC后，需要完成以下事情：</p>
<ul>
<li>在/dev/下创建一个新的目录，用来代表该磁盘。如/dev/hda，/dev/hdb等。</li>
<li>磁盘最开始需要进行格式化，使用<code>mkfs</code>命令为磁盘进行格式化，确定文件系统类型。</li>
<li>对硬盘进行分区后才可以使用。</li>
<li>在Linux中挂载到一个已经存在的目录下才可以访问该磁盘，否则无法访问。使用<code>mount</code>与<code>unmount</code>来进行挂载和卸载。</li>
</ul>
<blockquote>
<p>一般挂在点都在/mnt/xxx目录下，并且该目录必须是已经存在的，否则无法挂载</p>
</blockquote>
<h2 id="fdisk的使用">fdisk的使用</h2>
<p>在Linux中，使用fdisk来查看当前的硬盘以及硬盘的分区、文件系统等信息。并且使用fdisk命令可以为磁盘进行分区。 fdisk的命令有以下这些： Fdisk命令详解：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">命令</th>
<th style="text-align: left;">备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">m</td>
<td style="text-align: left;">获取帮助</td>
</tr>
<tr class="even">
<td style="text-align: left;">n</td>
<td style="text-align: left;">新建分区</td>
</tr>
<tr class="odd">
<td style="text-align: left;">p</td>
<td style="text-align: left;">显示分区表</td>
</tr>
<tr class="even">
<td style="text-align: left;">d</td>
<td style="text-align: left;">删除分区</td>
</tr>
<tr class="odd">
<td style="text-align: left;">b</td>
<td style="text-align: left;">设置卷标</td>
</tr>
<tr class="even">
<td style="text-align: left;">w</td>
<td style="text-align: left;">写入分区表</td>
</tr>
<tr class="odd">
<td style="text-align: left;">t</td>
<td style="text-align: left;">改变分区文件系统类型</td>
</tr>
<tr class="even">
<td style="text-align: left;">v</td>
<td style="text-align: left;">检验分区</td>
</tr>
<tr class="odd">
<td style="text-align: left;">l</td>
<td style="text-align: left;">显示fdisk所支持的文件系统代码</td>
</tr>
<tr class="even">
<td style="text-align: left;">q</td>
<td style="text-align: left;">退出</td>
</tr>
</tbody>
</table>
<h5 id="fdisk示例">fdisk示例</h5>
<ol type="1">
<li>使用<code>fdisk -l</code>查看当前所有硬盘以及分区的状态。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># fdisk -l</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: <span class="number">10.7</span> GB, <span class="number">10737418240</span> bytes</span><br><span class="line"><span class="number">255</span> heads, <span class="number">63</span> sectors/track, <span class="number">1305</span> cylinders</span><br><span class="line">Units = cylinders <span class="keyword">of</span> <span class="number">16065</span> * <span class="number">512</span> = <span class="number">8225280</span> bytes</span><br><span class="line"></span><br><span class="line">Device Boot   Start     End   Blocks  Id System</span><br><span class="line">/dev/sda1  *      <span class="number">1</span>     <span class="number">13</span>   <span class="number">104391</span>  <span class="number">83</span> Linux</span><br><span class="line">/dev/sda2       <span class="number">14</span>    <span class="number">1305</span>  <span class="number">10377990</span>  8e Linux LVM</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: <span class="number">5368</span> MB, <span class="number">5368709120</span> bytes</span><br><span class="line"><span class="number">255</span> heads, <span class="number">63</span> sectors/track, <span class="number">652</span> cylinders</span><br><span class="line">Units = cylinders <span class="keyword">of</span> <span class="number">16065</span> * <span class="number">512</span> = <span class="number">8225280</span> bytes</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb doesn<span class="string">&#x27;t contain a valid partition table</span></span><br></pre></td></tr></table></figure>
<p>可以看到目前有两个磁盘：</p>
<ul>
<li>sda：10.7G，255个磁头，63个磁道，1305个扇区
<ul>
<li>主分区1：/dev/sda1</li>
<li>主分区2：/dev/sda2</li>
</ul></li>
<li>sdb：5G，255个磁头，63个磁道，652个扇区
<ul>
<li>无分区</li>
</ul></li>
</ul>
<h2 id="分区的概念">分区的概念</h2>
<p>Linux中，磁盘只有被分区完后，才可以被挂载到目录下。</p>
<p>分区有三种：主分区，扩展分区，逻辑分区，每个磁盘最多只能有四个主分区，而可以有多个扩展分区，在扩展分区中，还可以创建多个逻辑分区。</p>
<ul>
<li>主分区：创建完后即可挂载</li>
<li>扩展分区：扩展分区创建完后，还需要创建逻辑分区才可以被挂载</li>
</ul>
<h2 id="示例">示例</h2>
<p>格式化一块硬盘(hdb)，并且对其进行分区，分区后进行挂载</p>
<h5 id="创建主分区">创建主分区</h5>
<ol type="1">
<li>通过<code>fdisk /dev/hdb</code>进入磁盘的命令模式</li>
</ol>
<figure>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/s22aqd4o24.png" alt="s22aqd4o24" /><figcaption aria-hidden="true">s22aqd4o24</figcaption>
</figure>
<p>进入格式化命令模式</p>
<ol type="1">
<li>输入<code>n</code>代表创建分区，<code>e</code>代表扩展分区，<code>p</code>代表主分区</li>
</ol>
<figure>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/0u6woej2nq.png" alt="0u6woej2nq" /><figcaption aria-hidden="true">0u6woej2nq</figcaption>
</figure>
<p>新建主分区</p>
<ol type="1">
<li>输入<code>First Cylinder</code>的值代表分区初始的柱面值，以及分区的大小<code>+3G</code>代表为该分区分3G</li>
</ol>
<figure>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/vopy3iwz2v.png" alt="vopy3iwz2v" /><figcaption aria-hidden="true">vopy3iwz2v</figcaption>
</figure>
<p>输入初始柱面的值以及分区大小</p>
<ol type="1">
<li>输入<code>p</code>查看创建的分区<code>/dev/hdb1</code></li>
</ol>
<figure>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/rflbc73wpf.png" alt="rflbc73wpf" /><figcaption aria-hidden="true">rflbc73wpf</figcaption>
</figure>
<p>新建分区</p>
<h5 id="创建扩展分区">创建扩展分区</h5>
<ol type="1">
<li>与创建主分区步骤相同，只是在选择<code>command action</code>的时候，选择<code>e</code>，表示创建扩展分区</li>
</ol>
<figure>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/ymjwni22fr.png" alt="ymjwni22fr" /><figcaption aria-hidden="true">ymjwni22fr</figcaption>
</figure>
<p>创建后的扩展分区</p>
<ol type="1">
<li>在创建完扩展分区后，来创建逻辑分区，输入<code>l</code>代表创建逻辑分区</li>
</ol>
<figure>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/ra4wa3017d.png" alt="ra4wa3017d" /><figcaption aria-hidden="true">ra4wa3017d</figcaption>
</figure>
<p>创建逻辑分区</p>
<ol type="1">
<li>与创建主分区、扩展分区一样，为逻辑分区选择起始的柱面，以及分配的大小</li>
</ol>
<figure>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/y0kb4p9z23.png" alt="y0kb4p9z23" /><figcaption aria-hidden="true">y0kb4p9z23</figcaption>
</figure>
<p>分配分区大小</p>
<ol type="1">
<li>查看扩展分区</li>
</ol>
<figure>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/c78q2lt7wi.png" alt="c78q2lt7wi" /><figcaption aria-hidden="true">c78q2lt7wi</figcaption>
</figure>
<p>查看分区信息</p>
<h5 id="分区格式化">分区格式化</h5>
<p>在磁盘分区创建完毕后，需要为分区通过<code>mkfs</code>进行格式化，赋予它文件系统： 如<code>ext2</code>,<code>ext3</code>,<code>vfat</code>等</p>
<p>使用命令 <code>mkfs -t ext3 /dev/hdb1</code>分别对分区<code>hdb1</code>进行格式化处理，格式化为ext3文件类型</p>
<p>其中<code>mkfs –t ext3</code>命令等价于<code>mkfs.ext3</code>，<code>mkfs -t ext2</code>命令等价于<code>mkfs.ext2</code></p>
<figure>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/513p7ponts.png" alt="513p7ponts" /><figcaption aria-hidden="true">513p7ponts</figcaption>
</figure>
<p>mkfs命令</p>
<h5 id="分区挂载">分区挂载</h5>
<p>当分区格式化完成文件系统后，就可以通过<code>mount</code>与<code>unmount</code>进行挂载与卸载了，当分区挂载到具体目录后，即可进行创建文件、删除文件等文件操作了。</p>
<p>如<code>mount /dev/hdb1 /mnt/hdb1</code>就会将<code>/dev/hdb1</code>分区挂载到<code>/mnt/hdb1</code>目录下，也就是该目录下的文件都会被写到<code>/dev/hdb1</code>的磁盘分区中保存。</p>
<p>本文参与<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/support-plan">腾讯云自媒体分享计划</a>，欢迎正在阅读的你也加入，一起分享。</p>
<h1 id="linux-文件系统">Linux 文件系统</h1>
<h2 id="文件系统类型">文件系统类型</h2>
<p>Kali Linux支持：btrfs、exfat、ext2\3\4、f2fs、fat16、fat32、hfs、hfs+、jfs、linux-swap、lvm2 pv、minix、nilfs2、ntfs、reiser4、reiserfs、udf、xfs;</p>
<h3 id="linux-swap">LINUX-SWAP</h3>
<p>Swap分区在系统的物理内存不够用的时候，把硬盘空间中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。 本文将从分区开始讲解如何开启SWAP交换空间</p>
<h4 id="分区">分区</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 查看块设备</span><br><span class="line"># 如图可以看出硬盘sda和vdb还有剩余</span><br><span class="line">[root@rainss ~]# lsblk</span><br></pre></td></tr></table></figure>
<h2 id="分区类型">分区类型</h2>
<p>主分区、扩展分区、逻辑分区</p>
<h2 id="对齐类型">对齐类型</h2>
<p>对齐到MiB、对齐到柱面</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/22/Programming/C++/2021-04-22-Get%20Started%20with%20C++%20and%20Windows%20Subsystem%20for%20Linux%20in%20Visual%20Studio%20Code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/22/Programming/C++/2021-04-22-Get%20Started%20with%20C++%20and%20Windows%20Subsystem%20for%20Linux%20in%20Visual%20Studio%20Code/" class="post-title-link" itemprop="url">Get Started with C++ and Windows Subsystem for Linux in Visual Studio Code</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-22 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-22T23:58:32+08:00">2021-04-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-23 20:06:39" itemprop="dateModified" datetime="2021-05-23T20:06:39+08:00">2021-05-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/cpp/config-wsl">code.visualstudio.com</a></p>
<h2 id="using-c-and-wsl-in-vs-code">Using C++ and WSL in VS Code</h2>
<p>In this tutorial, you will configure Visual Studio Code to use the GCC C++ compiler (g++) and GDB debugger on Ubuntu in the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/windows/wsl/install-win10">Windows Subsystem for Linux</a> (WSL). GCC stands for GNU Compiler Collection; GDB is the GNU debugger. WSL is a Linux environment within Windows that runs directly on the machine hardware, not in a virtual machine.</p>
<blockquote>
<p><strong>Note</strong>: Much of this tutorial is applicable to working with C++ and VS Code directly on a Linux machine.</p>
</blockquote>
<p>Visual Studio Code has support for working directly in WSL with the <a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl">Remote - WSL extension</a>. We recommend this mode of <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/remote/wsl">WSL development</a>, where all your source code files, in addition to the compiler, are hosted on the Linux distro. For more background, see <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/remote/remote-overview">VS Code Remote Development</a>.</p>
<p>After completing this tutorial, you will be ready to create and configure your own C++ project, and to explore the VS Code documentation for further information about its many features. This tutorial does not teach you about GCC or Linux or the C++ language. For those subjects, there are many good resources available on the Web.</p>
<p>If you have any problems, feel free to file an issue for this tutorial in the <a target="_blank" rel="noopener" href="https://github.com/microsoft/vscode-docs/issues">VS Code documentation repository</a>.</p>
<h2 id="prerequisites">Prerequisites<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_prerequisites">#</a></h2>
<p>To successfully complete this tutorial, you must do the following steps:</p>
<ol type="1">
<li>Install <a target="_blank" rel="noopener" href="https://code.visualstudio.com/download">Visual Studio Code</a>.</li>
<li>Install the <a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl">Remote - WSL extension</a>.</li>
<li>Install <a target="_blank" rel="noopener" href="https://docs.microsoft.com/windows/wsl/install-win10">Windows Subsystem for Linux</a> and then use the links on that same page to install your Linux distribution of choice. This tutorial uses Ubuntu. During installation, remember your Linux user password because you'll need it to install additional software.</li>
</ol>
<h2 id="set-up-your-linux-environment">Set up your Linux environment<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_set-up-your-linux-environment">#</a></h2>
<ol type="1">
<li><p>Open the Bash shell for WSL. If you installed an Ubuntu distro, type "Ubuntu" in the Windows search box and then click on it in the result list. For Debian, type "Debian", and so on.</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/wsl/start-ubuntu.png" alt="Ubuntu in Start Menu" /><figcaption aria-hidden="true">Ubuntu in Start Menu</figcaption>
</figure>
<p>The shell appears with a command prompt that by default consists of your user name and computer name, and puts you in your home directory. For Ubuntu it looks like this:</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/wsl/bash-ubuntu.png" alt="Bash Shell" /><figcaption aria-hidden="true">Bash Shell</figcaption>
</figure></li>
<li><p>Make a directory called <code>projects</code> and then subdirectory under that called <code>helloworld</code>:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir projects</span><br><span class="line">cd projects</span><br><span class="line">mkdir helloworld</span><br></pre></td></tr></table></figure></p></li>
<li><p>Although you will be using VS Code to edit your source code, you'll be <strong>compiling the source code on Linux using the g++ compiler</strong>. You'll also <strong>debug on Linux using GDB</strong>. These tools are not installed by default on Ubuntu, so you have to install them. Fortunately, that task is quite easy!</p></li>
<li><p>From the WSL command prompt, first run <code>apt-get update</code> to update the Ubuntu package lists. An out-of-date distro can sometimes interfere with attempts to install new packages.</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></p>
<p>If you like, you can run <code>sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade</code> to also download the latest versions of the system packages, but this can take significantly longer depending on your connection speed.</p></li>
<li><p>From the command prompt, install the GNU compiler tools and the GDB debugger by typing:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential gdb</span><br></pre></td></tr></table></figure></p></li>
</ol>
<figure>
<img src="C:\Users\431240\AppData\Roaming\Typora\typora-user-images\image-20210419161354074.png" alt="image-20210419161354074" /><figcaption aria-hidden="true">image-20210419161354074</figcaption>
</figure>
<ol start="6" type="1">
<li>Verify that the install succeeded by locating g++ and gdb. If the filenames are not returned from the <code>whereis</code> command, try running the update command again.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whereis g++</span><br><span class="line">whereis gdb</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note</strong>: The setup steps for installing the g++ compiler and GDB debugger apply if you are working directly on a Linux machine rather than in WSL. Running VS Code in your helloworld project, as well as the editing, building, and debugging steps are the same.</p>
</blockquote>
<h2 id="run-vs-code-in-wsl">Run VS Code in WSL<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_run-vs-code-in-wsl">#</a></h2>
<p>Navigate to your helloworld project folder and launch VS Code from the WSL terminal with <code>code .</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME&#x2F;projects&#x2F;helloworld</span><br><span class="line">code .</span><br></pre></td></tr></table></figure>
<p>You'll see a message about "Installing VS Code Server". <strong>VS Code is downloading and installing a small server on the Linux side that the desktop VS Code will then talk to.</strong></p>
<figure>
<img src="C:\Users\431240\AppData\Roaming\Typora\typora-user-images\image-20210419155740210.png" alt="image-20210419155740210" /><figcaption aria-hidden="true">image-20210419155740210</figcaption>
</figure>
<p>VS Code will then start and open the <code>helloWorld</code> folder. The File Explorer shows that VS Code is now running in the context of WSL with the title bar <strong>[WSL: Ubuntu]</strong>.</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/wsl/file-explorer-wsl.png" alt="File Explorer in WSL" /><figcaption aria-hidden="true">File Explorer in WSL</figcaption>
</figure>
<p>You can also tell the remote context from the Status bar.</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/wsl/wsl-status-bar.png" alt="Remote context in the Status bar" /><figcaption aria-hidden="true">Remote context in the Status bar</figcaption>
</figure>
<p>If you click on the Remote Status bar item, you will see a dropdown of Remote commands appropriate for the session.</p>
<figure>
<img src="C:\Users\431240\AppData\Roaming\Typora\typora-user-images\image-20210419155444952.png" alt="image-20210419155444952" /><figcaption aria-hidden="true">image-20210419155444952</figcaption>
</figure>
<p>For example, if you want to end your session running in WSL, you can select the <strong>Close Remote Connection</strong> command from the dropdown.</p>
<p>Running <code>code .</code> from your <em>WSL command prompt</em> will restart VS Code running in WSL.</p>
<p>The <strong>code .</strong> command opened VS Code in the current working folder, which becomes your "workspace". As you go through the tutorial, you will see three files created in a <code>.vscode</code> folder in the workspace:</p>
<ul>
<li><code>c_cpp_properties.json</code> (compiler path and IntelliSense settings)</li>
<li><code>tasks.json</code> (build instructions)</li>
<li><code>launch.json</code> (debugger settings)</li>
</ul>
<h2 id="add-a-source-code-file">Add a source code file<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_add-a-source-code-file">#</a></h2>
<p>In the File Explorer title bar, select the <strong>New File</strong> button and name the file <code>helloworld.cpp</code>.</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/wsl/new-file-button.png" alt="New File title bar button" /><figcaption aria-hidden="true">New File title bar button</figcaption>
</figure>
<h3 id="install-the-cc-extension">Install the C/C++ extension<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_install-the-cc-extension">#</a></h3>
<p>Once you create the file and VS Code detects it is a C++ language file, you may be prompted to install the <a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">Microsoft C/C++ extension</a> if you don't already have it installed.</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/wsl/cpp-extension-notification.png" alt="C++ extension notification" /><figcaption aria-hidden="true">C++ extension notification</figcaption>
</figure>
<p>Choose <strong>Install</strong> and then <strong>Reload Required</strong> when the button is displayed in the Extensions view to complete installing the C/C++ extension.</p>
<p>If you already have C/C++ language extensions installed locally in VS Code, you'll need to go to the Extensions view (Ctrl+Shift+X) and install those extensions into WSL. Locally installed extensions can be installed into WSL by selecting the <strong>Install in WSL</strong> button and then <strong>Reload Required</strong>.</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/wsl/install-in-wsl.png" alt="Install in WSL button" /><figcaption aria-hidden="true">Install in WSL button</figcaption>
</figure>
<h3 id="add-hello-world-source-code">Add hello world source code<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_add-hello-world-source-code">#</a></h3>
<p>Now paste in this source code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   vector&lt;string&gt; msg &#123;&quot;Hello&quot;, &quot;C++&quot;, &quot;World&quot;, &quot;from&quot;, &quot;VS Code&quot;, &quot;and the C++ extension!&quot;&#125;;</span><br><span class="line"></span><br><span class="line">   for (const string&amp; word : msg)</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; word &lt;&lt; &quot; &quot;;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now press Ctrl+S to save the file. Notice how the file you just added appears in the <strong>File Explorer</strong> view (Ctrl+Shift+E) in the side bar of VS Code:</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/wsl/file-explorer-helloworld.png" alt="File Explorer" /><figcaption aria-hidden="true">File Explorer</figcaption>
</figure>
<p>You can also enable <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/codebasics#_saveauto-save">Auto Save</a> to automatically save your file changes, by checking <strong>Auto Save</strong> in the main <strong>File</strong> menu.</p>
<p>The Activity Bar on the far left lets you open different views such as <strong>Search</strong>, <strong>Source Control</strong>, and <strong>Run</strong>. You'll look at the <strong>Run</strong> view later in this tutorial. You can find out more about the other views in the VS Code <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/getstarted/userinterface">User Interface documentation</a>.</p>
<p>若在此处遇到未找到头文件的问题，请参照一下方法。</p>
<p><img src="C:\Users\431240\AppData\Roaming\Typora\typora-user-images\image-20210419160838596.png" alt="image-20210419160838596"  /></p>
<h2 id="explore-intellisense">Explore IntelliSense<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_explore-intellisense">#</a></h2>
<p>In your new <code>helloworld.cpp</code> file, hover over <code>vector</code> or <code>string</code> to see type information. After the declaration of the <code>msg</code> variable, start typing <code>msg.</code> as you would when calling a member function. You should immediately see a completion list that shows all the member functions, and a window that shows the type information for the <code>msg</code> object:</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/wsl/msg-intellisense.png" alt="Statement completion IntelliSense" /><figcaption aria-hidden="true">Statement completion IntelliSense</figcaption>
</figure>
<p>You can press the Tab key to insert the selected member; then, when you add the opening parenthesis, you will see information about any arguments that the function requires.您可以按Tab键插入所选的成员;然后，当添加左括号时，您将看到关于函数所需的任何参数的信息。</p>
<h2 id="build-helloworld.cpp">Build helloworld.cpp<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_build-helloworldcpp">#</a></h2>
<p>Next, you will create a <code>tasks.json</code> file to tell VS Code how to build (compile) the program. This task will invoke the g++ compiler on WSL to create an executable file based on the source code.</p>
<p>From the main menu, choose <strong>Terminal</strong> &gt; <strong>Configure Default Build Task</strong>. In the dropdown, which will display a tasks dropdown listing various predefined build tasks for C++ compilers. Choose <strong>g++ build active file</strong>, which will build the file that is currently displayed (active) in the editor.</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/wsl/build-active-file.png" alt="Tasks C++ build dropdown" /><figcaption aria-hidden="true">Tasks C++ build dropdown</figcaption>
</figure>
<p>This will create a <code>tasks.json</code> file in a <code>.vscode</code> folder and open it in the editor.</p>
<p>Your new <code>tasks.json</code> file should look similar to the JSON below:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">  &quot;tasks&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">      &quot;label&quot;: &quot;g++ build active file&quot;,</span><br><span class="line">      &quot;command&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;g++&quot;,</span><br><span class="line">      &quot;args&quot;: [&quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;&#x2F;$&#123;fileBasenameNoExtension&#125;&quot;],</span><br><span class="line">      &quot;options&quot;: &#123;</span><br><span class="line">        &quot;cwd&quot;: &quot;&#x2F;usr&#x2F;bin&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;problemMatcher&quot;: [&quot;$gcc&quot;],</span><br><span class="line">      &quot;group&quot;: &#123;</span><br><span class="line">        &quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">        &quot;isDefault&quot;: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>command</code> setting specifies the program to run; in this case that is g++. The <code>args</code> array specifies the command-line arguments that will be passed to g++. These arguments must be specified in the order expected by the compiler. This task tells g++ to take the active file (<code>$&#123;file&#125;</code>), compile it, and create an executable file in the current directory (<code>$&#123;fileDirname&#125;</code>) with the same name as the active file but without an extension (<code>$&#123;fileBasenameNoExtension&#125;</code>), resulting in <code>helloworld</code> for our example.</p>
<blockquote>
<p><strong>Note</strong>: You can learn more about <code>tasks.json</code> variables in the <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/variables-reference">variables reference</a>.</p>
</blockquote>
<p>The <code>label</code> value is what you will see in the tasks list; you can name this whatever you like.</p>
<p>The <code>"isDefault": true</code> value in the <code>group</code> object specifies that this task will be run when you press Ctrl+Shift+B. This property is for convenience only; if you set it to false, you can still run it from the Terminal menu with <strong>Tasks: Run Build Task</strong>.</p>
<h3 id="running-the-build">Running the build<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_running-the-build">#</a></h3>
<ol type="1">
<li><p>Go back to <code>helloworld.cpp</code>. Your task builds the active file and you want to build <code>helloworld.cpp</code>.</p></li>
<li><p>To run the build task defined in <code>tasks.json</code>, press Ctrl+Shift+B or from the <strong>Terminal</strong> main menu choose <strong>Tasks: Run Build Task</strong>.</p></li>
<li><p>When the task starts, you should see the Integrated Terminal panel appear below the source code editor. After the task completes, the terminal shows output from the compiler that indicates whether the build succeeded or failed. For a successful g++ build, the output looks something like this:</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/wsl/wsl-task-in-terminal.png" alt="G++ build output in terminal" /><figcaption aria-hidden="true">G++ build output in terminal</figcaption>
</figure></li>
<li><p>Create a new terminal using the <strong>+</strong> button and you'll have a bash terminal running in the context of WSL with the <code>helloworld</code> folder as the working directory. Run <code>ls</code> and you should now see the executable <code>helloworld</code> (no file extension).</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/wsl/wsl-bash-terminal.png" alt="WSL bash terminal" /><figcaption aria-hidden="true">WSL bash terminal</figcaption>
</figure></li>
<li><p>You can run <code>helloworld</code> in the terminal by typing <code>./helloworld</code>.</p></li>
</ol>
<h3 id="modifying-tasks.json">Modifying tasks.json<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_modifying-tasksjson">#</a></h3>
<p>You can modify your <code>tasks.json</code> to build multiple C++ files by using an argument like <code>"$&#123;workspaceFolder&#125;/*.cpp"</code> instead of <code>$&#123;file&#125;</code>. You can also modify the output filename by replacing <code>"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;"</code> with a hard-coded filename (for example 'helloworld.out').</p>
<h2 id="debug-helloworld.cpp">Debug helloworld.cpp<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_debug-helloworldcpp">#</a></h2>
<p>Next, you'll create a <code>launch.json</code> file to configure VS Code to launch the GDB debugger when you press F5 to debug the program. From the main menu, choose <strong>Run</strong> &gt; <strong>Add Configuration...</strong> and then choose <strong>C++ (GDB/LLDB)</strong>.</p>
<p>You'll then see a dropdown for various predefined debugging configurations. Choose <strong>g++ build and debug active file</strong>.</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/wsl/build-and-debug-active-file.png" alt="C++ debug configuration dropdown" /><figcaption aria-hidden="true">C++ debug configuration dropdown</figcaption>
</figure>
<p>VS Code creates a <code>launch.json</code> file, opens it in the editor, and builds and runs 'helloworld'.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">  &quot;configurations&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;g++ build and debug active file&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">      &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">      &quot;program&quot;: &quot;$&#123;fileDirname&#125;&#x2F;$&#123;fileBasenameNoExtension&#125;&quot;,</span><br><span class="line">      &quot;args&quot;: [],</span><br><span class="line">      &quot;stopAtEntry&quot;: false,</span><br><span class="line">      &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">      &quot;environment&quot;: [],</span><br><span class="line">      &quot;externalConsole&quot;: false,</span><br><span class="line">      &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class="line">      &quot;setupCommands&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,</span><br><span class="line">          &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">          &quot;ignoreFailures&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;preLaunchTask&quot;: &quot;g++ build active file&quot;,</span><br><span class="line">      &quot;miDebuggerPath&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;gdb&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>program</code> setting specifies the program you want to debug. Here it is set to the active file folder <code>$&#123;fileDirname&#125;</code> and active filename without an extension <code>$&#123;fileBasenameNoExtension&#125;</code>, which if <code>helloworld.cpp</code> is the active file will be <code>helloworld</code>.</p>
<p>By default, the C++ extension won't add any breakpoints to your source code and the <code>stopAtEntry</code> value is set to <code>false</code>. Change the <code>stopAtEntry</code> value to <code>true</code> to cause the debugger to stop on the <code>main</code> method when you start debugging.</p>
<p>The remaining steps are provided as an optional exercise to help you get familiar with the editing and debugging experience.</p>
<h3 id="start-a-debugging-session">Start a debugging session<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_start-a-debugging-session">#</a></h3>
<ol type="1">
<li>Go back to <code>helloworld.cpp</code> so that it is the active file.</li>
<li>Press F5 or from the main menu choose <strong>Run &gt; Start Debugging</strong>. Before you start stepping through the code, let's take a moment to notice several changes in the user interface:</li>
</ol>
<ul>
<li><p>The Integrated Terminal appears at the bottom of the source code editor. In the <strong>Debug Output</strong> tab, you see output that indicates the debugger is up and running.</p></li>
<li><p>The editor highlights the first statement in the <code>main</code> method. This is a breakpoint that the C++ extension automatically sets for you:</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/wsl/wsl-breakpoint-default.png" alt="Initial breakpoint" /><figcaption aria-hidden="true">Initial breakpoint</figcaption>
</figure></li>
<li><p>The Run view on the left shows debugging information. You'll see an example later in the tutorial.</p></li>
<li><p>At the top of the code editor, a debugging control panel appears. You can move this around the screen by grabbing the dots on the left side.</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/cpp/debug-controls.png" alt="Debugging controls" /><figcaption aria-hidden="true">Debugging controls</figcaption>
</figure></li>
</ul>
<h2 id="step-through-the-code">Step through the code<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_step-through-the-code">#</a></h2>
<p>Now you're ready to start stepping through the code.</p>
<ol type="1">
<li><p>Click or press the <strong>Step over</strong> icon in the debugging control panel.</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/cpp/step-over-button.png" alt="Step over button" /><figcaption aria-hidden="true">Step over button</figcaption>
</figure>
<p>This will advance program execution to the first line of the for loop, and skip over all the internal function calls within the <code>vector</code> and <code>string</code> classes that are invoked when the <code>msg</code> variable is created and initialized. Notice the change in the <strong>Variables</strong> window on the left.</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/wsl/debug-view-variables.png" alt="Debugging windows" /><figcaption aria-hidden="true">Debugging windows</figcaption>
</figure>
<p>In this case, the errors are expected because, although the variable names for the loop are now visible to the debugger, the statement has not executed yet, so there is nothing to read at this point. The contents of <code>msg</code> are visible, however, because that statement has completed.</p></li>
<li><p>Press <strong>Step over</strong> again to advance to the next statement in this program (skipping over all the internal code that is executed to initialize the loop). Now, the <strong>Variables</strong> window shows information about the loop variables.</p></li>
<li><p>Press <strong>Step over</strong> again to execute the <code>cout</code> statement. (Note that as of the March 2019 release, the C++ extension does not print any output to the <strong>Debug Console</strong> until the loop exits.)</p></li>
<li><p>If you like, you can keep pressing <strong>Step over</strong> until all the words in the vector have been printed to the console. But if you are curious, try pressing the <strong>Step Into</strong> button to step through source code in the C++ standard library!</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/cpp/gcc-system-header-stepping.png" alt="Breakpoint in gcc standard library header" /><figcaption aria-hidden="true">Breakpoint in gcc standard library header</figcaption>
</figure>
<p>To return to your own code, one way is to keep pressing <strong>Step over</strong>. Another way is to set a breakpoint in your code by switching to the <code>helloworld.cpp</code> tab in the code editor, putting the insertion point somewhere on the <code>cout</code> statement inside the loop, and pressing F9. A red dot appears in the gutter on the left to indicate that a breakpoint has been set on this line.</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/cpp/breakpoint-in-main.png" alt="Breakpoint in main" /><figcaption aria-hidden="true">Breakpoint in main</figcaption>
</figure>
<p>Then press F5 to start execution from the current line in the standard library header. Execution will break on <code>cout</code>. If you like, you can press F9 again to toggle off the breakpoint.</p>
<p>When the loop has completed, you can see the output in the <strong>Debug Console</strong> tab of the integrated terminal, along with some other diagnostic information that is output by GDB.</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/wsl/debug-console-output-wsl.png" alt="Debug console display" /><figcaption aria-hidden="true">Debug console display</figcaption>
</figure></li>
</ol>
<h2 id="set-a-watch">Set a watch<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_set-a-watch">#</a></h2>
<p>Sometimes you might want to keep track of the value of a variable as your program executes. You can do this by setting a <strong>watch</strong> on the variable.</p>
<ol type="1">
<li><p>Place the insertion point inside the loop. In the <strong>Watch</strong> window, click the plus sign and in the text box, type <code>word</code>, which is the name of the loop variable. Now view the Watch window as you step through the loop.</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/cpp/watch-window.png" alt="Watch window" /><figcaption aria-hidden="true">Watch window</figcaption>
</figure></li>
<li><p>Add another watch by adding this statement before the loop: <code>int i = 0;</code>. Then, inside the loop, add this statement: <code>++i;</code>. Now add a watch for <code>i</code> as you did in the previous step.</p></li>
<li><p>To quickly view the value of any variable while execution is paused on a breakpoint, you can hover over it with the mouse pointer.</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/cpp/mouse-hover.png" alt="Mouse hover" /><figcaption aria-hidden="true">Mouse hover</figcaption>
</figure></li>
</ol>
<h2 id="cc-configurations">C/C++ configurations<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_cc-configurations">#</a></h2>
<p>If you want more control over the C/C++ extension, you can create a <code>c_cpp_properties.json</code> file, which will allow you to change settings such as the path to the compiler, include paths, C++ standard (default is C++17), and more.</p>
<p>You can view the C/C++ configuration UI by running the command <strong>C/C++: Edit Configurations (UI)</strong> from the Command Palette (Ctrl+Shift+P).</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/cpp/command-palette.png" alt="Command Palette" /><figcaption aria-hidden="true">Command Palette</figcaption>
</figure>
<p>This opens the <strong>C/C++ Configurations</strong> page. When you make changes here, VS Code writes them to a file called <code>c_cpp_properties.json</code> in the <code>.vscode</code> folder.</p>
<figure>
<img src="https://code.visualstudio.com/assets/docs/cpp/wsl/intellisense-configurations-wsl.png" alt="Command Palette" /><figcaption aria-hidden="true">Command Palette</figcaption>
</figure>
<p>You only need to modify the <strong>Include path</strong> setting if your program includes header files that are not in your workspace or in the standard library path.</p>
<p>Visual Studio Code places these settings in <code>.vscode/c_cpp_properties.json</code>. If you open that file directly, it should look something like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;configurations&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Linux&quot;,</span><br><span class="line">      &quot;includePath&quot;: [&quot;$&#123;workspaceFolder&#125;&#x2F;**&quot;],</span><br><span class="line">      &quot;defines&quot;: [],</span><br><span class="line">      &quot;compilerPath&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;gcc&quot;,</span><br><span class="line">      &quot;cStandard&quot;: &quot;c11&quot;,</span><br><span class="line">      &quot;cppStandard&quot;: &quot;c++17&quot;,</span><br><span class="line">      &quot;intelliSenseMode&quot;: &quot;clang-x64&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="closing-the-wsl-session">Closing the WSL session<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_closing-the-wsl-session">#</a></h2>
<p>When you are done working in WSL, you can close your remote session with the <strong>Close Remote Connection</strong> command available in the main <strong>File</strong> menu and the Command Palette (Ctrl+Shift+P). This will restart VS Code running locally. You can easily reopen your WSL session from the <strong>File</strong> &gt; <strong>Open Recent</strong> list by selecting folders with the <strong>[WSL]</strong> suffix.</p>
<h2 id="next-steps">Next steps<a href="about:reader?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcpp%2Fconfig-wsl#_next-steps">#</a></h2>
<ul>
<li>Explore the <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/codebasics">VS Code User Guide</a>.</li>
<li>Review the <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/languages/cpp">Overview of the C++ extension</a>.</li>
<li>Create a new workspace, copy your .json files to it, adjust the necessary settings for the new workspace path, program name, and so on, and start coding!</li>
</ul>
<p>11/22/2019</p>
<p>​</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/21/Signal/2021-04-21-What%20is%20a%20Bypass%20Capacitor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/21/Signal/2021-04-21-What%20is%20a%20Bypass%20Capacitor/" class="post-title-link" itemprop="url">What is a Bypass Capacitor?</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-21 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-21T23:58:32+08:00">2021-04-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-29 00:50:14" itemprop="dateModified" datetime="2021-04-29T00:50:14+08:00">2021-04-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Signal/" itemprop="url" rel="index"><span itemprop="name">Signal</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="http://www.learningaboutelectronics.com/Articles/What-is-a-bypass-capacitor.html">learningaboutelectronics.com</a></p>
<h1 id="what-is-a-bypass-capacitor">What is a Bypass Capacitor?</h1>
<figure>
<img src="http://www.learningaboutelectronics.com/images/Bypass-capacitor.png" alt="Bypass capacitor" /><figcaption aria-hidden="true">Bypass capacitor</figcaption>
</figure>
<p>A bypass capacitor is a capacitor that shorts AC signals to ground, so that any AC noise that may be present on a DC signal is removed, producing a much cleaner and pure DC signal.</p>
<p>A bypass capacitor essentially bypasses AC noise that may be on a DC signal, filtering out the AC, so that a clean, pure DC signal goes through without any AC ripple.</p>
<p>For example, you may want a pure DC signal from a power source.</p>
<p>Below is a transistor circuit. A transistor is an active device, so in order to work, it needs DC power. This power source is VCC. In this case, VCC equals 15 volts.</p>
<figure>
<img src="http://www.learningaboutelectronics.com/images/DC-power-source-transistor.png" alt="DC Power Source for Transistor" /><figcaption aria-hidden="true">DC Power Source for Transistor</figcaption>
</figure>
<p>This 15 volts provides power to the transistor so that the transistor can amplify signals. We want this signal to be as purely DC as possible. Although we obtain our DC voltage, VCC, from a DC power source such as a power supply, the voltage isn't always purely DC. In fact, many times the voltage is very noisy and contains a lot of AC ripple on it, especially at the 60Hz frequency because this is the frequency at which AC signals run in many countries.</p>
<p>So although we want a pure DC signal, such as below:</p>
<figure>
<img src="http://www.learningaboutelectronics.com/images/Pure-DC-voltage.png" alt="Pure DC Voltage" /><figcaption aria-hidden="true">Pure DC Voltage</figcaption>
</figure>
<p>Many times, we get a noisy signal that looks like:</p>
<figure>
<img src="http://www.learningaboutelectronics.com/images/Noisy-dc-signal.png" alt="Noisy DC Voltage Signal" /><figcaption aria-hidden="true">Noisy DC Voltage Signal</figcaption>
</figure>
<p>A DC signal such as this is actually very common. This is undesired because it adds noise to the transistor circuit. Therefore, this noisy DC signal will be imposed on the AC signal. So the AC signal which may have music or some type of recording will now have much more noise.</p>
<p>This noise which is on the signal is AC ripple. Many times when using a DC power supply connected to an AC power outlet, it will have some of the AC noise transfer to the DC power voltage. AC ripple can also appear from other sources, so even batteries can produce noise.</p>
<p>To eliminate this AC ripple, we use a bypass capacitor. So our transistor circuit above will have a bypass capacitor added to it:</p>
<figure>
<img src="http://www.learningaboutelectronics.com/images/Bypass-capacitor-transistor-circuit.png" alt="Bypass Capacitor for a Transistor Circuit" /><figcaption aria-hidden="true">Bypass Capacitor for a Transistor Circuit</figcaption>
</figure>
<p>A capacitor is a device that offers a tremendously high resistance for signals of low frequencies. Therefore, signals at low frequencies will not go through them. This is because signals (current) always takes the path of least resistance. Therefore, they will instead go through the resistor, RE. Remember, again, this is for low frequency signals, which is basically DC signals.</p>
<p>However, capacitors offer much less resistance at higher frequencies (AC signals). So AC signals will go through the capacitor and then to gorund. Therefore, DC signals will go through the resistor, RE, while AC signals will go through the capacitor, getting shunted to ground. So AC signals get shunted to ground. This is how we have a clean DC signal across our circuit, while AC noise imposed on it is bypassed to ground.</p>
<figure>
<img src="http://www.learningaboutelectronics.com/images/How-a-bypass-capacitor-works.png" alt="How a Bypass Capacitor Works" /><figcaption aria-hidden="true">How a Bypass Capacitor Works</figcaption>
</figure>
<p>So a bypass capacitor blocks the DC from entering it by the great resistance it offers to the signal but accepts the AC noise that may be on the DC line and shunts or bypasses it to ground. This is how bypass capacitors work.</p>
<h1 id="how-to-choose-the-value-of-the-bypass-capacitor">How to Choose the Value of the Bypass Capacitor</h1>
<p>Now that you know conceptually what a bypass capacitor is, the next step is to know how to select the value of the bypass capacitor.</p>
<p>And selecting the value is pretty straightforward.</p>
<p>The value of the bypass capacitor should be at least 1/10th of the resistance across the emitter resistance, RE at the lowest frequency intended to be bypassed.</p>
<p>Because capacitors are reactive devices, they have different resistances to signals based on the signal's frequency. This is referred to as the capacitor's reactance, which can be seen as the resistance it offers. We want the capacitor to have 1/10th of the resistance to the flow of current than what the resistor offers for the frequency signal that we want to bypass.</p>
<p>If you visualize the current moving through the transistor, it can take one of 2 paths once it passes the collector and moves through the emitter. Current can either go the resistor, RE or current can flow through the bypass capacitor. Current always takes the path of least resistance. Therefore, current will take the path of the lower resistance. This is why you want the value of the resistance of the bypass capacitor to be at least 1/10th the value of the emitter resistor or, even better, less than one-tenth. We want the AC current to flow through the least resistance path, which is the bypass capacitor if the correct value is chosen.</p>
<p>However, DC signals do not see it as AC. To DC, the capacitor has infinite resistance. So DC will automatically go through the RE resistor, which offers lower resistance by far to the infinite resistance of the capacitor.</p>
<p>AC, however, does not see infinite resistance for the capacitor. If we choose the value correctly for the capacitor, we can make the capacitor a much lower-resistance path to ground, thus shorting out the AC signal to ground.</p>
<p>So let's go over a practical example of how we would select the bypass capacitor value.</p>
<p>Let's say we want to bypass the lowest possible frequency of 50Hz, because the frequency of AC voltages worldwide are 50-60Hz. Therefore, this frequency can be a very problematic because often there is AC ripple at this frequency.</p>
<p>Remember, when we said we bias the value of the bypass capacitor based on the lowest frequency that we want to bypass. So by selecting the frequency of 50Hz, this blocks frequencies from 50Hz and higher; so it covers 60Hz. As frequency of an AC signal increases, the resistance of the capacitor decreases and decreases with each increase. Therefore, all the frequencies above the frequency value that we choose get bypassed easier and easier. We'll demonstrate this all mathematically.</p>
<p>So we decided we want to bypass AC signals 50Hz or higher to ground.</p>
<p>The typical value of an emitter resistor is 400-500‎Ω. The resistance is kept low so that gain on the transistor isn't lowered too much.</p>
<p>So let's say we choose an emitter resistor of 470‎Ω.</p>
<p>This means that we want the reactance of the capacitor to be one-tenth of 470‎Ω or less, which is 47‎Ω or lower. So this is our target.</p>
<p>The formula for the reactance of a capacitor is, XC= 1/2πfc= 1/2(3.14)(50Hz)(C)=47Ω. Solving for the capacitance, C, we get the value of approximately 67μF. So we need a capacitor of at least 67μF to get a resistance of one-tenth the value of 470Ω resistor.</p>
<p>Since a 67μF capacitor isn't readily available, we can round up to 100μF, which is readily available and easy to obtain. This is even better, because with a larger capacitance, the capacitor offers even less resistance to the AC signal. If we plug a 100μF capacitor into the same capacitor reactance formula, we get XC= 1/2πfc= 1/2(3.14)(50Hz)(100μF)=31.8Ω. This is much lower than 1/10 of the 470Ω resistor that we have in parallel. So it will act effectively to short all AC signals 50Hz or higher to ground to clean up the DC signal.</p>
<p>Even if you wanted, you could increase the capacitance even more to allow for less AC noise on the signal. But a lot of times, this will not be done for cost and size constraints reasons. The larger the size a capacitor is, the more it costs per unit. Also the larger the size of a capacitor, the larger physically is. Therefore, if a company is designing a product, the size of the capacitor could be a problem if there are size constraint issues. The way things are going in electronics, companies want products to be as small and concise as possible. So due to reasons such as these, larger value capacitors won't always be chosen, but theoretically, they would increase the purity of the DC signal, by allowing more AC to ground.</p>
<p>So again, this is a summary of what a bypass capacitor is and how to select the value of them based on the lowest AC signal desired to be filtered out and the value of the resistance in parallel with the capacitor.</p>
<p>You can check out our <a target="_blank" rel="noopener" href="http://www.learningaboutelectronics.com/Articles/Bypass-capacitor-calculator.php">bypass capacitor calculator</a> to calculate the value of a bypass capacitor based on the input AC signal frequency and the value of the resistor in parallel.</p>
<p>Related Resources</p>
<p>​</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/20/Networking/2021-04-20-Unix%20domain%20socket%20%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/20/Networking/2021-04-20-Unix%20domain%20socket%20%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Unix domain socket 简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-20 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-20T23:58:32+08:00">2021-04-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-29 00:52:30" itemprop="dateModified" datetime="2021-04-29T00:52:30+08:00">2021-04-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Networking/" itemprop="url" rel="index"><span itemprop="name">Networking</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sparkdev/p/8359028.html">cnblogs.com</a></p>
<p><strong>Unix domain socket 又叫 IPC(inter-process communication 进程间通信) socket，用于实现同一主机上的进程间通信。</strong>socket 原本是为网络通讯设计的，但后来在 socket 的框架上发展出一种 IPC 机制，就是 UNIX domain socket。虽然网络 socket 也可用于同一台主机的进程间通讯(通过 loopback 地址 127.0.0.1)，但是 UNIX domain socket 用于 IPC 更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。这是因为，IPC 机制本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。 UNIX domain socket 是全双工的，API 接口语义丰富，相比其它 IPC 机制有明显的优越性，目前已成为使用最广泛的 IPC 机制，比如 X Window 服务器和 GUI 程序之间就是通过 UNIX domain socket 通讯的。 Unix domain socket 是 POSIX 标准中的一个组件，所以不要被名字迷惑，linux 系统也是支持它的。</p>
<p>下面通过一个简单的 demo 来理解相关概念。程序分为服务器端和客户端两部分，它们之间通过 unix domain socket 进行通信。</p>
<h1 id="服务器端程序">服务器端程序</h1>
<p>下面是一个非常简单的服务器端程序，它从客户端读字符，然后将每个字符转换为大写并回送给客户端：</p>
<figure>
<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /><figcaption aria-hidden="true">复制代码</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stddef.h&gt;  </span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;  </span><br><span class="line">#include &lt;sys&#x2F;un.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;ctype.h&gt;   </span><br><span class="line"> </span><br><span class="line">#define MAXLINE 80  </span><br><span class="line"> </span><br><span class="line">char *socket_path &#x3D; &quot;server.socket&quot;;  </span><br><span class="line"> </span><br><span class="line">int main(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_un serun, cliun;  </span><br><span class="line">    socklen_t cliun_len;  </span><br><span class="line">    int listenfd, connfd, size;  </span><br><span class="line">    char buf[MAXLINE];  </span><br><span class="line">    int i, n;  </span><br><span class="line"> </span><br><span class="line">    if ((listenfd &#x3D; socket(AF_UNIX, SOCK_STREAM, 0)) &lt; 0) &#123;  </span><br><span class="line">        perror(&quot;socket error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    memset(&amp;serun, 0, sizeof(serun));  </span><br><span class="line">    serun.sun_family &#x3D; AF_UNIX;  </span><br><span class="line">    strcpy(serun.sun_path, socket_path);  </span><br><span class="line">    size &#x3D; offsetof(struct sockaddr_un, sun_path) + strlen(serun.sun_path);  </span><br><span class="line">    unlink(socket_path);  </span><br><span class="line">    if (bind(listenfd, (struct sockaddr *)&amp;serun, size) &lt; 0) &#123;  </span><br><span class="line">        perror(&quot;bind error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">    printf(&quot;UNIX domain socket bound\n&quot;);  </span><br><span class="line">      </span><br><span class="line">    if (listen(listenfd, 20) &lt; 0) &#123;  </span><br><span class="line">        perror(&quot;listen error&quot;);  </span><br><span class="line">        exit(1);          </span><br><span class="line">    &#125;  </span><br><span class="line">    printf(&quot;Accepting connections ...\n&quot;);  </span><br><span class="line"> </span><br><span class="line">    while(1) &#123;  </span><br><span class="line">        cliun_len &#x3D; sizeof(cliun);         </span><br><span class="line">        if ((connfd &#x3D; accept(listenfd, (struct sockaddr *)&amp;cliun, &amp;cliun_len)) &lt; 0)&#123;  </span><br><span class="line">            perror(&quot;accept error&quot;);  </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        while(1) &#123;  </span><br><span class="line">            n &#x3D; read(connfd, buf, sizeof(buf));  </span><br><span class="line">            if (n &lt; 0) &#123;  </span><br><span class="line">                perror(&quot;read error&quot;);  </span><br><span class="line">                break;  </span><br><span class="line">            &#125; else if(n &#x3D;&#x3D; 0) &#123;  </span><br><span class="line">                printf(&quot;EOF\n&quot;);  </span><br><span class="line">                break;  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            printf(&quot;received: %s&quot;, buf);  </span><br><span class="line"> </span><br><span class="line">            for(i &#x3D; 0; i &lt; n; i++) &#123;  </span><br><span class="line">                buf[i] &#x3D; toupper(buf[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">            write(connfd, buf, n);  </span><br><span class="line">        &#125;  </span><br><span class="line">        close(connfd);  </span><br><span class="line">    &#125;  </span><br><span class="line">    close(listenfd);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure>
<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /><figcaption aria-hidden="true">复制代码</figcaption>
</figure>
<p>简单介绍一下这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int family, int type, int protocol);</span><br></pre></td></tr></table></figure>
<p>使用 UNIX domain socket 的过程和网络 socket 十分相似，也要先调用 socket() 创建一个 socket 文件描述符. <strong>family</strong> 指定为 AF_UNIX，使用 AF_UNIX 会在系统上创建一个 socket 文件，不同进程通过读写这个文件来实现通信。 <strong>type</strong> 可以选择 SOCK_DGRAM 或 SOCK_STREAM。SOCK_STREAM 意味着会提供按顺序的、可靠、双向、面向连接的比特流。SOCK_DGRAM 意味着会提供定长的、不可靠、无连接的通信。 <strong>protocol</strong> 参数指定为 0 即可。 UNIX domain socket 与网络 socket 编程最明显的不同在于地址格式不同，用结构体 sockaddr_un 表示，网络编程的 socket 地址是 IP 地址加端口号，而 UNIX domain socket 的地址是一个 socket 类型的文件在文件系统中的路径，这个 socket 文件由 bind() 调用创建，如果调用 bind() 时该文件已存在，则 bind() 错误返回。因此，一般在调用 bind() 前会检查 socket 文件是否存在，如果存在就删除掉。 网络 socket 编程类似，在 bind 之后要 listen，表示通过 bind 的地址（也就是 socket 文件）提供服务。 接下来必须用 accept() 函数初始化连接。accept() 为每个连接创立新的套接字并从监听队列中移除这个连接。</p>
<h1 id="客户端程序">客户端程序</h1>
<p>下面是客户端程序，它接受用户的输入，并把字符串发送给服务器，然后接收服务器返回的字符串并打印：</p>
<figure>
<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /><figcaption aria-hidden="true">复制代码</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stddef.h&gt;  </span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;  </span><br><span class="line">#include &lt;sys&#x2F;un.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line"> </span><br><span class="line">#define MAXLINE 80  </span><br><span class="line"> </span><br><span class="line">char *client_path &#x3D; &quot;client.socket&quot;;  </span><br><span class="line">char *server_path &#x3D; &quot;server.socket&quot;;  </span><br><span class="line"> </span><br><span class="line">int main() &#123;  </span><br><span class="line">    struct  sockaddr_un cliun, serun;  </span><br><span class="line">    int len;  </span><br><span class="line">    char buf[100];  </span><br><span class="line">    int sockfd, n;  </span><br><span class="line"> </span><br><span class="line">    if ((sockfd &#x3D; socket(AF_UNIX, SOCK_STREAM, 0)) &lt; 0)&#123;  </span><br><span class="line">        perror(&quot;client socket error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F; 一般显式调用bind函数，以便服务器区分不同客户端  </span><br><span class="line">    memset(&amp;cliun, 0, sizeof(cliun));  </span><br><span class="line">    cliun.sun_family &#x3D; AF_UNIX;  </span><br><span class="line">    strcpy(cliun.sun_path, client_path);  </span><br><span class="line">    len &#x3D; offsetof(struct sockaddr_un, sun_path) + strlen(cliun.sun_path);  </span><br><span class="line">    unlink(cliun.sun_path);  </span><br><span class="line">    if (bind(sockfd, (struct sockaddr *)&amp;cliun, len) &lt; 0) &#123;  </span><br><span class="line">        perror(&quot;bind error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    memset(&amp;serun, 0, sizeof(serun));  </span><br><span class="line">    serun.sun_family &#x3D; AF_UNIX;  </span><br><span class="line">    strcpy(serun.sun_path, server_path);  </span><br><span class="line">    len &#x3D; offsetof(struct sockaddr_un, sun_path) + strlen(serun.sun_path);  </span><br><span class="line">    if (connect(sockfd, (struct sockaddr *)&amp;serun, len) &lt; 0)&#123;  </span><br><span class="line">        perror(&quot;connect error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    while(fgets(buf, MAXLINE, stdin) !&#x3D; NULL) &#123;    </span><br><span class="line">         write(sockfd, buf, strlen(buf));    </span><br><span class="line">         n &#x3D; read(sockfd, buf, MAXLINE);    </span><br><span class="line">         if ( n &lt; 0 ) &#123;    </span><br><span class="line">            printf(&quot;the other side has been closed.\n&quot;);    </span><br><span class="line">         &#125;else &#123;    </span><br><span class="line">            write(STDOUT_FILENO, buf, n);    </span><br><span class="line">         &#125;    </span><br><span class="line">    &#125;   </span><br><span class="line">    close(sockfd);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<figure>
<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /><figcaption aria-hidden="true">复制代码</figcaption>
</figure>
<p>与网络 socket 编程不同的是，UNIX domain socket 客户端一般要显式调用 bind 函数，而不依赖系统自动分配的地址。客户端 bind 一个自己指定的 socket 文件名的好处是，该文件名可以包含客户端的 pid 等信息以便服务器区分不同的客户端。</p>
<h1 id="运行上面的程序">运行上面的程序</h1>
<p>分别把服务器端程序和客户端程序保存为 server.c 和 client.c 文件，并编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc server.c -o server</span><br><span class="line">$ gcc client.c -o client</span><br></pre></td></tr></table></figure>
<p>先启动服务器端程序，然后启动客户端程序输入字符串并回车：</p>
<figure>
<img src="https://images2017.cnblogs.com/blog/952033/201801/952033-20180126125928506-239880118.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>还不错，客户端得到了服务器端返回的大写字符串。接下来看看当前目录下的文件：</p>
<figure>
<img src="https://images2017.cnblogs.com/blog/952033/201801/952033-20180126125951834-1641586991.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>哈哈，多了两个 socket 文件。</p>
<h1 id="总结">总结</h1>
<p>Unix domain socket 主要用于同一主机上的进程间通信。与主机间的进程通信不同，它不是通过 "IP地址 + TCP或UDP端口号" 的方式进程通信，而是使用 socket 类型的文件来完成通信，因此在稳定性、可靠性以及效率方面的表现都很不错。</p>
<p><strong>参考：</strong> <a target="_blank" rel="noopener" href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/ch37s04.html">UNIX Domain Socket IPC</a> [<a target="_blank" rel="noopener" href="http://blog.csdn.net/tzshlyt/article/details/53391655">linux] unix domain socket 例子</a></p>
<p>​</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/20/Networking/2021-04-20-Networking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/20/Networking/2021-04-20-Networking/" class="post-title-link" itemprop="url">Networking</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-20 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-20T23:58:32+08:00">2021-04-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-26 00:14:57" itemprop="dateModified" datetime="2021-04-26T00:14:57+08:00">2021-04-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Networking/" itemprop="url" rel="index"><span itemprop="name">Networking</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="cdn">CDN</h3>
<blockquote>
<p><em>内容分发网络（Content Delivery Network，CDN）是建立并覆盖在承载网上，由不同区域的服务器组成的分布式网络。将源站资源缓存到全国各地的边缘服务器，供用户就近获取，降低源站压力。</em></p>
<p>——阿里云</p>
<p><em>CDN是构建在现有网络基础之上的智能虚拟网络，依靠 <strong>部署在各地的边缘服务器</strong>，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</em></p>
<p>——百度百科</p>
</blockquote>
<p>个人理解，实际部署CDN中最重要的概念即 <strong>节点</strong>、<strong>缓存服务器</strong> 和 <strong>中心平台</strong>。</p>
<ul>
<li>节点是指在足够广的范围内识别出合适数量的网络拓扑节点，这些节点往往处在网络所及最远之处的各地，能够有效分摊用户访问对主干网络的压力；</li>
<li>而缓存服务器即“部署在各地的边缘服务器”，是指能够 <strong>制定规则</strong> <strong>自动识别并缓存数据</strong> 以供用户快速访问，分担主干网络压力的实体。</li>
<li>中心平台可以对缓存服务器实现负载均衡、内容分发和调度等功能。</li>
</ul>
<h4 id="工作原理">工作原理</h4>
<blockquote>
<p>假设您的加速域名为<code>www.a.com</code>，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下图所示。</p>
<ol type="1">
<li>当终端用户（北京）向<code>www.a.com</code>下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。<br />
</li>
<li>LDNS检查缓存中是否有<code>www.a.com</code>的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。<br />
</li>
<li>当授权DNS解析<code>www.a.com</code>时，返回域名CNAME <code>www.a.tbcdn.com</code>对应IP地址。<br />
</li>
<li>域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。</li>
<li>LDNS获取DNS返回的解析IP地址。</li>
<li>用户获取解析IP地址。</li>
<li>用户向获取的IP地址发起对该资源的访问请求。
<ul>
<li>如果该IP地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤7和8，请求结束。</li>
<li>如果该IP地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。配置缓存策略的操作方法，请参见<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/27136.htm?spm=a2c4g.11186623.2.3.694925b3RabzbR#concept-f24-32d-xdb">缓存配置</a>。</li>
</ul></li>
</ol>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/p4886.png" alt="img" style="zoom: 67%;" /></p>
<p>——阿里云</p>
</blockquote>
<h4 id="应用场景">应用场景</h4>
<h5 id="场景概述">场景概述</h5>
<p>CDN的业务使用场景分为 <strong>静态内容加速</strong>、<strong>动态内容加速</strong> 和 <strong>安全加速</strong> 。</p>
<blockquote>
<p><strong>静态内容（静态资源）</strong></p>
<p>静态内容是指在不同请求中访问到的数据都相同的静态文件。例如：图片、视频、网站中的文件（html、css、js）、软件安装包、apk文件、压缩包文件等。</p>
<p>CDN加速的本质是 <strong>缓存加速</strong>。将您服务器上存储的静态内容缓存在阿里云CDN节点上，当您访问这些静态内容时，无需访问服务器源站，就近访问阿里云CDN节点即可获取相同内容。从而达到加速的效果，同时减轻服务器源站的压力。</p>
<p><strong>动态内容（动态资源）</strong></p>
<p>动态内容是指在不同请求中访问到的数据不相同的动态内容。例如：网站中的文件（asp、jsp、php、perl、cgi）、API接口、数据库交互请求等。</p>
<p><strong>当您访问这些动态内容时，每次都需要访问您的服务器，由服务器动态生成实时的数据并返回给您。</strong>因此CDN的缓存加速不适用于加速动态内容，CDN无法缓存实时变化的动态内容。对于动态内容请求，CDN节点只能转发回您的服务器源站，没有加速效果。</p>
<p>如果您的网站或App应用有较多动态内容，例如需要对各种API接口进行加速，则需要使用 <a target="_blank" rel="noopener" href="https://www.alibabacloud.com/zh/product/dcdn">阿里云全站加速</a> 产品。全站加速能同时加速动态和静态内容，加速方式如下：</p>
<ul>
<li>静态内容使用CDN加速。</li>
<li>动态内容通过阿里云的 <strong>路由优化</strong>、<strong>传输优化</strong> 等动态加速技术以最快的速度访问您的服务器源站获取数据。从而达到全站加速的效果。</li>
</ul>
<p>——阿里云</p>
</blockquote>
<h5 id="全站加速">全站加速</h5>
<blockquote>
<p>全站加速（Dynamic Route for Content Delivery Network）是阿里云自主研发的融合了动态加速和静态加速技术的CDN产品。该产品一站式解决了页面动静态资源混杂、跨运营商、网络不稳定、单线源站、突发流量、网络拥塞等诸多因素导致的响应慢、丢包、服务不稳定的问题，提升全站性能和用户体验。</p>
<p><strong>工作原理</strong></p>
<p>阿里云全站加速通过智能路由区分客户请求内容，实现动静态加速。通过架构图，您可以了解全站加速的工作原理。</p>
<p><img src="https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/5931788951/p6063.png" style="zoom: 40%;" /></p>
<ul>
<li>智能区分动静态内容：域名接入阿里云全站加速后，通过域名访问的动静态内容将被智能识别并区分。</li>
<li>动静态内容同时加速：静态内容使用阿里云CDN加速，缓存在CDN节点上，供您就近访问。动态内容通过 <strong>智能路由优化</strong>、<strong>协议优化</strong> 等动态加速技术快速回源获取。</li>
</ul>
<p><strong>全站加速与CDN对比</strong></p>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210414100053078.png" alt="image-20210414100053078" style="zoom: 80%;" /></p>
</blockquote>
<h3 id="ssh">SSH</h3>
<p>SSH is a program for logging into a remote machine and for excuting commands on a remote machine.</p>
<p>It's intended to provide secure encrypted communications between two untrusted hosts over and insecure network.</p>
<p>X11 connections, arbitrary TCP ports and UNIX-domain sockets can also be forwarded over the secure channel.</p>
<h4 id="authentication">Authentication</h4>
<p>The OpenSSH SSH client supports SSH protocol 2.</p>
<p>Five available authentication methods: GSSAPI-based / host-based / public key / challenge-response and password.</p>
<h5 id="host-based">Host-based</h5>
<p>If the machine the user logs in from is listed in <code>/etc/hosts.equiv</code> or <code>/etc/ssh/shosts.equiv</code> on the remote machine, the user is non-root and the user names are the same on both sides, or if the files <code>~/.rhosts</code> or <code>~/.shosts</code> exist in the user's home directory on the remote machine and contain a line containing the name of the client machine and the name of the user on that machine, the user is considered for login. Additionally, the server must be able to verify the client's host key (see the description of <code>/etc/ssh/ssh_known_hosts</code> and <code>~/.ssh/known_hosts</code>, below) for login to be permitted. This authentication method closes security holes due to IP spoofing, DNS spoofing, and routing spoofing.</p>
<p>[<strong>Note to the administrator</strong>: <code>/etc/hosts.equiv</code>, <code>~/.rhosts</code>, and the rlogin/rsh protocol in general, are inherently insecure and should be disabled if security is desired.]</p>
<h5 id="public-key">Public key</h5>
<p>The scheme is based on public-key cryptography, using cryptosystems where encryption and decryption are done using separate keys, and it is unfeasible to derive the decryption key from the encryption key. The idea is that each user creates a public/private key pair for authentication purposes.</p>
<p><strong><em>The server knows the public key, and only the user knows the private key.</em></strong> ssh implements public key authentication protocol automatically, using one of the <strong>DSA</strong>, <strong>ECDSA</strong>, <strong>Ed25519</strong> or <strong>RSA</strong> algorithms. The HISTORY section of ssl(8) <a target="_blank" rel="noopener" href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8#HISTORY">[i]</a> on non-OpenBSD systems contains a brief discussion of the DSA and RSA algorithms.</p>
<p>The file <code>~/.ssh/authorized_keys</code> lists the public keys that are permitted for logging in. When the user logs in, the ssh program tells the server which key pair it would like to use for authentication. The client proves that it has access to the private key and the server checks that the corresponding public key is authorized to accept the account.</p>
<p>The user should then <mark>copy the public key to <code>~/.ssh/authorized_keys</code> in his/her home directory on the remote machine.</mark> The authorized_keys file corresponds to the conventional <code>~/.rhosts</code> file, and has one key per line, though the lines can be very long. After this, the user can log in without giving the password.</p>
<h6 id="ssh-keygen">ssh-keygen</h6>
<p>To generate a public key for ssh, we need to use:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-kegen -t rsa</span><br></pre></td></tr></table></figure>
<p>The terminal will ask if <code>/root/.ssh/id_rsa</code> the file you save the key:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;root&#x2F;.ssh&#x2F;id_rsa):</span><br></pre></td></tr></table></figure>
<p>The terminal will require you to enter the <em>passphrase</em> twice.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure>
<p><strong><em>Identification</em></strong> is the private key used by the server(the remote machine). And the <strong><em>public key</em></strong> is generated for the client to authenticate while logging in the server.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Your identification has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">Your public key has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256: *******</span><br><span class="line">The key&#39;s randomart imge is:</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The user creates his/her key pair by running ssh-keygen(1).</p>
<p>This stores the <strong><em>private key</em></strong> in <code>~/.ssh/id_dsa</code> (DSA), <code>~/.ssh/id_ecdsa</code> (ECDSA), <code>~/.ssh/id_ecdsa_sk</code> (authenticator-hosted ECDSA), <code>~/.ssh/id_ed25519</code> (Ed25519), <code>~/.ssh/id_ed25519_sk</code> (authenticator-hosted Ed25519), or <code>~/.ssh/id_rsa</code> (RSA) .</p>
<p>The the <strong><em>public key</em></strong> stores in <code>~/.ssh/id_dsa.pub</code> (DSA), <code>~/.ssh/id_ecdsa.pub</code> (ECDSA), <code>~/.ssh/id_ecdsa_sk.pub</code> (authenticator-hosted ECDSA), <code>~/.ssh/id_ed25519.pub</code> (Ed25519), <code>~/.ssh/id_ed25519_sk.pub</code> (authenticator-hosted Ed25519), or <code>~/.ssh/id_rsa.pub</code> (RSA) in the <strong>user's home directory</strong>.</p>
</blockquote>
<p>Check and copy your <code>.pub</code> file to the local computer.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh/</span><br><span class="line">vim id_rsa.pub</span><br></pre></td></tr></table></figure>
<h6 id="permissions-0644">Permissions 0644</h6>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210423135807684.png" alt="image-20210423135807684" style="zoom: 80%;" /></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 0600 ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<h4 id="login-format">Login Format</h4>
<p><code>user@hostname</code> : <code>root@qq.com</code></p>
<p><code>ssh://root@hostname:port</code> : <code>ssh://root@qq.com:666</code></p>
<h3 id="ssl">SSL</h3>
<p>基于 SSL 证书，可将站点由 HTTP（Hypertext Transfer Protocol）切换到 HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer），即基于安全套接字层（SSL）进行安全数据传输的加密版 HTTP 协议。</p>
<h4 id="ssl优势">SSL优势</h4>
<ul>
<li><p><strong>防流量劫持：</strong>全站 HTTPS 是根治运营商、中间人流量劫持的解决方案，不仅可以杜绝网页中显示的小广告，更可以保护用户隐私安全。</p></li>
<li><p><strong>提升搜索排名：</strong>采用 HTTPS 可以帮忙搜索排名的提升，提高站点的可信度和品牌形象。</p></li>
<li><p><strong>杜绝钓鱼网站：</strong>HTTPS 地址栏绿色图标可以帮助用户识别出钓鱼网站，保障用户和企业的利益不受损害，增强用户信任。</p></li>
</ul>
<h4 id="ssl证书签发">SSL证书签发</h4>
<p>域名型证书由以下品牌提供自动审核认证，快速签发。</p>
<ul>
<li><strong>SecureSite</strong>：全球最大的信息安全厂商和服务商，最权威的数字证书颁发机构，为企业、个人用户和服务供应商提供广泛的内容和网络安全解决方案，全球500强中有93%选择了 VeriSign SSL 数字证书，目前均由 SecureSite 提供服务。</li>
<li><strong>TrustAsia®（亚洲诚信）</strong>：亚数信息科技（上海）有限公司应用于信息安全领域的品牌，是 SecureSite 的白金合作伙伴，专业为企业提供包含数字证书在内的所有网络安全服务。</li>
<li><strong>GeoTrust</strong>：GeoTrust 是全球第二大数字证书颁发机构（CA），也是身份认证和信任认证领域的领导者，该公司各种先进的技术使得任何大小的机构和公司都能安全地低成本地部署 SSL 数字证书和实现各种身份认证。从2001年成立到2006年占领全球市场25%的市场份额，VeriSign 于2006年5月 - 2006年9月以1.25亿美元收购 GeoTrust，目前也同为 SecureSite 旗下 SSL 证书的<strong>性价比高</strong>的品牌。</li>
<li><strong>GlobalSign</strong>： GlobalSign 成立于1996年，是一家声誉卓著，备受信赖的 CA 中s心和 SSL 数字证书提供商，在全球总计颁发超过2000万张数字证书。GlobalSign 的专业实力获得中国网络市场众多服务器、域名注册商、系统服务供应商的青睐，成为其数字证书服务的合作伙伴。</li>
<li><strong>WoTrus（沃通）</strong>：沃通电子认证服务有限公司（WoTrus CA Limited）是同时获得国内电子认证服务许可证（由工信部颁发）和通过国际认证的证书颁发机构（CA）。专业为企业提供权威第三方数字身份认证服务，颁发全球信任的各种数字证书产品。</li>
<li><strong>DNSPod 品牌国密标准（SM2）证书</strong>：DNSPod 为腾讯云自有品牌，采用国密标准，并且是纯国产数字证书，由国内知名 CA 机构提供基础设置支撑，敏捷高效，同时满足国家监管需求。</li>
</ul>
<h4 id="ssl证书品牌差异">SSL证书品牌差异</h4>
<p>不同品牌的证书在浏览器地址栏、加密强度、赔付保障上均存在差异，最重要的差异点在于根证书。</p>
<p>例如，GeoTrust 通配符是 GeoTrust 根证书签发的，而 SecureSite 通配符是 SecureSite 根证书签发的。<mark>Digicert 根证书可以兼容市面上所有的浏览器，对移动端的支持也是最好的</mark>，而 Trustasia 通配符也是 Digicert 根证书签发的，GlobalSign 通配符是 GlobalSign 的根证书签发的，DNSPod 是由 Wotrus 的根证书签发的，Wotrus 通配符是 Sectigo 的根证书签发的。</p>
<blockquote>
<p><strong>通配符：</strong></p>
<p><strong>根证书：</strong></p>
</blockquote>
<p>单纯从技术角度，SecureSite（原 Verisign）和 GeoTrust 的区别如下：</p>
<ul>
<li>算法支持上 SecureSite（支持 RSA、DSA、ECC 三种算法）优于 GeoTrust（支持 RSA、DSA 两种算法）。</li>
<li>兼容性 SecureSite 优于 GeoTrust，SecureSite 可兼容市面上所有的浏览器，对移动端的支持也是极好的。</li>
<li>OCSP 响应速度上 SecureSite 优于 GeoTrust。</li>
<li>CA 安全性方面 SecureSite 优于 GeoTrust，SecureSite 是国际知名安全厂商，CA 的安全级别也是国际第一的安全系数。</li>
<li>SecureSite 证书除实现加密传输以外，还另外有恶意软件扫描和漏洞评估的附加功能。</li>
<li>SecureSite 对证书有商业保险赔付保障，金额最高为175万美金，GeoTrust 最高为150万美金。</li>
</ul>
<h4 id="ssl证书格式">SSL证书格式</h4>
<p>SSL证书分为 <code>pem</code> 和 <code>key</code> 这两种格式，分别存储的是 <strong>证书base64加密</strong> 和 <strong>私钥base64加密</strong> 还有 格式分割符，也就是说pem存的是证书，key 存的是私钥。</p>
<p>如pem中的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">略</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure>
<p><code>-----BEGIN CERTIFICATE-----</code> 和 <code>-----END CERTIFICATE-----</code> 为分割分，表示在这两个中间存的是证书的base64编码</p>
<p>备注：</p>
<p>如key中的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">略</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>
<p><code>-----BEGIN RSA PRIVATE KEY-----</code> 和 <code>-----END RSA PRIVATE KEY-----</code> 为分割符号，表示在这两个中间存的是私钥的base64编码</p>
<p>备注：CERTIFICATE 单词代表证书的意思；PRIVATE KEY 单词代表 私钥、秘钥的意思。</p>
<h4 id="ssl证书配置">SSL证书配置</h4>
<p>以下以“阿里云OSS"及“腾讯云COS”的对象存储（bucket）与域名（name）绑定过程中，对SSL证书的配置为例，进行解释和说明，不对详细步骤进行描述，仅解释原理。</p>
<h5 id="域名及bucket绑定">域名及Bucket绑定</h5>
<p>阿里云及腾讯云都可以申请对象存储和域名，所申请的域名按正规流程均需要经过挂载至某个服务器进行备案（国内公安要求）后才可以与对象存储绑定，进而颁发证书给挂载至对象存储的域名。</p>
<h5 id="ssl证书申请及配置">SSL证书申请及配置</h5>
<p>若域名互相绑定后未配置SSL则会导致https访问失败，配置SSL需要给自己的域名申请免费SSL证书，阿里云及腾讯云都可以免费申请为期一年的证书，按流程填写信息并等待审核下发即可；获得证书后需要选择“其他”类型的证书进行下载。证书中需要的 <strong>公钥</strong> 即 <code>.pem</code> 格式文件，而 <strong>私钥</strong> 即 <code>.key</code> 格式文件，分别填写到Bucket的域名管理页面内下的 <strong>证书上传</strong> 中。</p>
<p>流程大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	开始 --&gt; Bucket申请--可选CDN加速开启--&gt; 获得Bucket域名或CDN加速域名 --CNAME解析--&gt;域名绑定--&gt;结束</span><br><span class="line">	开始 --&gt; 域名申请 --&gt; 域名备案 --CNAME解析--&gt; 域名绑定</span><br><span class="line">	域名申请 --&gt; SSL证书申请 --&gt; 下载证书 --复制粘贴至Bucket的域名管理页面--&gt; 证书上传--&gt; 结束</span><br></pre></td></tr></table></figure>
<h3 id="ddos">DDos</h3>
<h4 id="常见流量攻击">常见流量攻击</h4>
<h5 id="syn-flood">SYN Flood</h5>
<p>Flood即洪水之意，SYN是指TCP通信中用于建立连接时标志位之一。</p>
<p>此时需要用到 TCP Three-way Handshake的知识点，当需要建立连接时：</p>
<ul>
<li>Client向Server <mark>发去SYN标志</mark></li>
<li>Server收到后向Client <mark>回复SYN和ACK标志</mark></li>
<li>Client收到由Server发过来的SYN和ACK后 <mark>回复一个ACK标志</mark></li>
</ul>
<p>以上即为三次握手协议的主要流程，其实只有Server收到该ACK时，才标志着双方建立连接。以下介绍几种”意外“情况。</p>
<p><strong>情况一：</strong>当Client第一次收到SYN和ACK时，Client就单方面“认为”自己已经和Server建立连接了。但网络通信时并不能百分百保证可靠，假如Client发了ACK，但Server并未收到，则Server就并不”认为“自己与Client建立了连接。Server和Client都有自己的定时器，在发送数据之后就开始计时，不管如何，此时Client都已经发了ACK了，“觉得”自己已经建立了连接，而Server不然，Server就会再次发送SYN和ACK以请求Client的确认。</p>
<p><strong>情况二：</strong>多个Client向Server同时发送SYN请求，Server收到信息后立即回复SYN和ACK，并且需要为每一个Client设立一个计时器以等待他们的ACK信息。假如此刻Client的数量非常多且每一个都发送了一次SYN请求，则Server的计时器则会立刻被用光，导致任何正常请求都无法连接。（针对此种攻击方式，提出了二次SYN当成一次SYN的防攻击手段，即Client需要连续发两次SYN在标明自己是真的“有意”连接，不是恶意发送攻击的，但此类二次验证方式比较简单，仍然容易被模仿）</p>
<h5 id="icmp-flood">ICMP Flood</h5>
<p>ICMP也算是网络层协议的一员，封装在IP协议中，是IP协议的附属协议，可以直接被用户进程直接使用。</p>
<p>此处的ICMP Flood指的是利用集群设备在同一时间使用 ping 功能对目标主机发起请求，强制主机进行回复，致使目标主机瘫痪。</p>
<p>以下为ping的英文解释</p>
<blockquote>
<p><em>PING - Send ICMP ECHO_REQUEST to network hosts</em></p>
<p><em>Ping uses the ICMP protocol's mandatory ECHO_REQUEST datagram to elicit an ICMP ECHO_RESPONSE from a host or gateway.</em></p>
<p>—— from 'manual of ping' in linux</p>
</blockquote>
<h3 id="选择数据库服务器的五个原则">选择数据库服务器的五个原则</h3>
<h4 id="高性能原则">　　1)高性能原则</h4>
<p>保证所选购的服务器，不仅能够满足运营系统的运行和业务处理的需要，而且能够满足一定时期业务量的增长。一般可以根据经验公式计算出所需的服务器TpmC值(Tpmc是衡量计算机系统的事务处理能力的程序)，然后比较各服务器厂商和TPC组织公布的TpmC值，选择相应的机型。同时，用服务器的市场价/报价除去计算出来的TpmC值得出单位TpmC值的价格，进而选择高性能价格比的服务器。</p>
<p><strong>结论：</strong>服务器处理器性能很关键，CPU的主频要高，要有较大的缓存</p>
<h4 id="可靠性原则">　　2)可靠性原则</h4>
<p>可靠性原则是所有选择设备和系统中首要考虑的，尤其是在大型的、有大量处理要求的、需要长期运行的系统上。考虑服务器系统的可靠性，不仅要考虑服务器单个节点的可靠性或稳定性，而且要考虑服务器与相关辅助系统之间连接的整体可靠性，如：网络系统、安全系统、远程打印系统等。在必要时，还应考虑对关键服务器采用集群技术，如：双机热备份或集群并行访问技术，甚至采用可能的完全容错机。</p>
<p><strong>结论：</strong>服务器要具备冗余技术，同时像硬盘、网卡、内存、电源此类设备要以稳定耐用为主，性能其次。</p>
<h4 id="可扩展性原则">　　3)可扩展性原则</h4>
<p>保证所选购的服务器具有优秀的可扩展性原则。因为服务器是所有系统处理的核心，要求具有大数据吞吐速率，包括：I/O速率和网络通讯速率，而且服务器需要能够处理一定时期的业务发展所带来的数据量，需要服务器能够在相应时间对其自身根据业务发展的需要进行相应的升级，如：CPU型号升级、内存扩大、硬盘扩大、更换网卡、增加终端数目、挂接磁盘阵列或与其他服务器组成对集中数据的并发访问的集群系统等。这都需要所选购的服务器在整体上具有一个良好的可扩充余地。一般数据库和计费应用服务器在大型计费系统的设计中就会采用集群方式来增加可靠性，其中挂接的磁盘存储系统，根据数据量和投资考虑，可以采用DAS、NAS或SAN等实现技术。</p>
<p><strong>结论：</strong>服务器的IO要高，否则在CPU和内存都是高性能的情况下，会出现瓶颈。除此之外，服务器的扩展性要好，为的是满足企业在日后发展的需要。</p>
<h4 id="安全性原则">　　4)安全性原则</h4>
<p>服务器处理的大都是相关系统的核心数据，其上存放和运行着关键的交易和重要的数据。这些交易和数据对于拥有者来说是一笔重要的资产，他们的安全性就非常敏感。服务器的安全性与系统的整体安全性密不可分，如：网络系统的安全、数据加密、密码体制等。服务器需要在其自身，包括软硬件，都应该从安全的角度上设计考虑，在借助于外界的安全设施保障下，更要保证本身的高安全性。</p>
<p><strong>结论：</strong>首先从服务器的材料上来说要具备高硬度高防护性等条件，其次服务器的冷却系统和对环境的适应能力要强，这样才能够在硬件上满足服务器安全的要求。</p>
<h4 id="可管理性原则">　　5)可管理性原则</h4>
<p>服务器既是核心又是系统整体中的一个节点部分，就像网络系统需要进行管理维护一样，也需要对服务器进行有效的管理。这需要服务器的软硬件对标准的管理系统支持，尤其是其上的操作系统，也包括一些重要的系统部件。</p>
<p><strong>结论：</strong>尽量选择支持系统多的服务器，因为服务器兼容的系统越多，你就可以拥有更大选择空间。</p>
<p><strong>总结：</strong>首先数据库服务器的性能要求很高，所以在CPU，内存，以及硬盘等方面都有很高的要求，其次是存储，存储要具备良好的稳定性，来满足长期运作的服务器随时读取写入等操作不会出现错误。最后希望通过总结的以上五点，帮助你挑选你所需要的数据库服务器。</p>
<h3 id="服务器产品结构">服务器产品结构</h3>
<p>U是厚度要求，是一种表示服务器外部尺寸的单位，是unit的缩略语，详细的尺寸由作为业界团体的美国电子工业协会（EIA）所决定。 <code>1U=4.445cm</code> ， 1U至7U的产品结构是指外形满足EIA规格、厚度为4.445cm-31.115cm的服务器。</p>
<p>多少U是指服务器的尺寸大小。在专业机房，托管的服务器一般是放在机柜里面的，机柜从上到下有很多单位格，我们叫一格为1U(U是unit的意思)。如果一个机柜是42U高，如果每2个服务器中间留1U空间，那么可以放21个1U的主机。同样情况放2U主机就只能放14台了。</p>
<p>很多机房托管费用会按所占U的多少来收费的。</p>
<h3 id="nat">NAT</h3>
<p>NAT（Network Address Translation，网络地址转换）是1994年提出的。</p>
<p>当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。 这种方法需要在专用网（私网IP）连接到因特网（公网IP）的路由器上 <mark>安装NAT软件</mark> 。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址（公网IP地址）。</p>
<p>这样，所有使用本地地址（私网IP地址）的主机在和外界通信时，都要在 <strong>NAT路由器</strong> 上将其本地地址转换成全球IP地址，才能和因特网连接。 另外，这种通过使用少量的全球IP地址（公网IP地址）代表较多的私有IP地址的方式，将有助于减缓可用的IP地址空间的枯竭。在RFC 2663中有对NAT的说明。</p>
<p><strong>举例</strong>：</p>
<blockquote>
<p>在内网下 <code>192.168.0.100</code> 这台电脑上开了一个http网站服务，那么端口默认是 <code>80</code>，在内网下你直接通过浏览器输入 <code>http://192.168.0.100</code> 直接打开网站，这个内网链接地址在外是打不开的。 通过内网穿透后平台 <strong>分配</strong> 一个公网地址（给内网的设备）,比如 <code>http://test123k.nat.nsloop.com</code> 用户在外时就可以通过这个公网地址打开网站。</p>
</blockquote>
<p>要使用内网穿透服务，需要先确定好 <mark>内网要映射的IP和端口</mark> ，穿透成功后内网的IP+端口，映射成为公网的域名+端口（如需要IP，可以在CMD命令下PING 服务器的IP地址） 穿透前: 访问IP地址 <code>192.168.0.100</code> 端口 <code>3389</code> 穿透后：访问地址 <code>s0.nsloop.com</code> 端口 <code>12843</code> 。</p>
<p>内网穿透是通过服务器中继转发数据来实现的将内网端口映射到公网，速度上没有P2P直连的快。</p>
<h3 id="异地组网">异地组网</h3>
<h3 id="内网穿透">内网穿透</h3>
<p>内网穿透（Intranet penetration），也即 NAT 穿透，进行 NAT 穿透是为了使具有某一个特定源 IP 地址和源端口号的数据包 <mark>不被 NAT 设备屏蔽而正确路由到内网主机</mark> 。</p>
<p>UDP 内网穿透的实质是利用路由器上的NAT 系统。NAT 是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型 Internet 接入方式和各种类型的网络中。<mark>NAT可以完成重用地址，并且对于内部的网络结构可以实现对外隐蔽</mark>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/19/Signal/MIC%20LEVEL%20vs%20LINE%20LEVEL%20Audio%20Levels%20Explained/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/19/Signal/MIC%20LEVEL%20vs%20LINE%20LEVEL%20Audio%20Levels%20Explained/" class="post-title-link" itemprop="url">MIC LEVEL vs LINE LEVEL--Audio Levels Explained</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-19 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-19T23:58:32+08:00">2021-04-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-29 00:54:07" itemprop="dateModified" datetime="2021-04-29T00:54:07+08:00">2021-04-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Signal/" itemprop="url" rel="index"><span itemprop="name">Signal</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://audiouniversityonline.com/mic-level-vs-line-level-audio-levels-explained/">audiouniversityonline.com</a></p>
<p>In this post, you’ll learn the difference between microphone level and line level, as well as other levels commonly used in professional audio such as instrument level and speaker level.</p>
<p>What is the difference between microphone level and line level?</p>
<p><strong>Microphones and instruments output very low signal voltages, while +4dBu is the line level is the standard voltage level for professional audio equipment.</strong></p>
<p><strong>In pro audio, you’ll generally be dealing with four types of audio signals: Mic Level, Instrument Level, Line Level, and Speaker Level</strong></p>
<h1 id="microphone-level">Microphone Level</h1>
<p>A microphone captures sound by converting pressure changes in the air into electrical currents in a wire. The electrical currents created by these pressure changes are very subtle. That’s why we use a microphone preamp – to amplify the signal to a more usable level.</p>
<p>A microphone preamp takes in a mic level signal, amplifies it, and outputs a line level signal. This is controlled by the gain knob on your mixing console, audio interface, or outboard mic pre.</p>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Mic-Level-Chart-900.jpg" alt="img" style="zoom:50%;" /></p>
<h1 id="instrument-level">Instrument Level</h1>
<p>The pickups of an electric guitar convert the vibrations of the strings into electrical currents. Similar to those from a microphone, the electrical currents from a guitar pickup are very weak.</p>
<p>A preamp can also be used to boost instrument level signals to line level.</p>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Instrument-Level-Chart-900.jpg" alt="img" style="zoom: 50%;" /></p>
<p>Once an input signal is brought up to line level, it is optimized for use with professional audio equipment, such as mixing consoles, outboard effects, and amplifiers.</p>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Line-Level-Chart-900.jpg" alt="img" style="zoom:50%;" /></p>
<h1 id="professional-vs-consumer-line-level">Professional vs Consumer Line Level</h1>
<p>There are two standards for line level: +4 dBu (professional) and -10 dBV (consumer).</p>
<p>Watch this video to learn the difference between professional and consumer line level. I also wrote a post on <a target="_blank" rel="noopener" href="https://audiouniversityonline.com/consumer-vs-professional-audio-levels-what-is-the-difference/">professional vs consumer audio levels</a> that will help you understand the difference.</p>
<h1 id="speaker-level">Speaker Level</h1>
<p>Line level is adequate for sending signals between devices, but not strong enough to power a speaker.In order to power a speaker, the line level signal needs to be amplified again.</p>
<p>This can be done with a power amplifier. A power amp takes in a line level signal, amplifies it, and outputs a speaker level signal that is strong enough to power a speaker.</p>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Speaker-Level-Chart-900.jpg" alt="img" style="zoom:50%;" /></p>
<h1 id="a-complete-audio-system">A Complete Audio System</h1>
<p>In a complete system, you might run a microphone through a preamp and an electric guitar through another preamp.</p>
<p>Once those signals are at line level, you can send them through outboard effects and eventually to an amplifier, which will add enough gain to the signal to power a speaker.</p>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Complete-Chart-900.jpg" alt="img" style="zoom:50%;" /></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/11/Web/2021-04-11-JavaScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/11/Web/2021-04-11-JavaScript/" class="post-title-link" itemprop="url">Javascript</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-11 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-11T23:58:32+08:00">2021-04-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-26 00:13:21" itemprop="dateModified" datetime="2021-04-26T00:13:21+08:00">2021-04-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Networking/" itemprop="url" rel="index"><span itemprop="name">Networking</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="面向对象编程">面向对象编程</h1>
<h2 id="对象的抽象">对象的抽象</h2>
<p><strong>抽象</strong> 是指一种归纳或总结，<strong>对象</strong> 是现实世界物体特征的实体。万事万物不论大小皆可看做对象， <strong>类</strong> 则是对各种不同对象的 <em>归纳总结</em>，类是对象的 <em>抽象表示形式</em>。</p>
<blockquote>
<p>例如，男演员Jack可以看做是一个对象，女演员Rose也可以看过是一个对象，而两者会被统一归纳为Person或者Human的类（或抽象）。每一个对象都有其独特的属性（Property）或功能（Function），而归纳总结出来的类则具有不同对象的相同属性或功能。</p>
</blockquote>
<p>基于类的面向对象语言是面向对象世界里的主流。虽然大多数面向对象开发语言都使用类来完成面向对象编程，但类不是面向对象编程的实质内涵。面向对象的实质内涵是将所有业务逻辑单元都视为一个对象（即，对象是目的或结果），且类不是唯一用来完成面向对象编程的方法。</p>
<p>面向对象不能被当做面向类，否则会进入误区。对象和类的关系相当于一般程序设计语言中的 <strong>变量</strong> 和 <strong>变量类型</strong> 的关系。所以，有时类也被称为是一种数据类型，可以看做抽象数据类型的具体实现。此时的数据类型则是 <strong>数据 </strong>和 <strong>操作</strong> 的集合。</p>
<h2 id="面向对象与面向过程的区别">面向对象与面向过程的区别</h2>
<p>面向过程程序设计，即结构化程序设计，诸如Pascal、C。</p>
<p>面向对象程序设计解决了结构化程序设计代码复用的难题，如C++、C#、Java、JavaScript、Python等都是。</p>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210413144641711.png" alt="image-20210413144641711" style="zoom: 67%;" /></p>
<p>面向过程也是把程序定义为“数据+作用于数据的操作算法”，但最重要的区别是：面向过程编程 <mark>使用过程操作数据结构</mark>， 而面向对象编程将过程和数据结构捆绑，使对象 <mark>操作自己的数据结构</mark>。</p>
<h1 id="javascript的类">JavaScript的类</h1>
<h2 id="类的创建">类的创建</h2>
<p>JavaScript可以用关键字 <code>class</code> 进行赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一：参数赋值法，间接调用构造器赋值</span></span><br><span class="line"><span class="keyword">var</span> oRectangle = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：生成对象后单独调用赋值</span></span><br><span class="line"><span class="comment">// var oRectangle = new Rectangle();</span></span><br><span class="line"><span class="comment">// oRectangle.height = 10;</span></span><br><span class="line"><span class="comment">// oRectangle.width = 30;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(oRectangle.height, oRectangle.width)</span><br></pre></td></tr></table></figure>
<p>在MDN Web Docs中，对JavaScript类的定义如下：</p>
<blockquote>
<p>实际上，类是“特殊的函数”，就像你能够定义的函数表达式和函数声明一样，类语法有两个组成部分：<strong>类表达式 </strong>和 <strong>类声明</strong>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloWrold</span>(<span class="params"></span>)</span>&#123;    <span class="comment">//To use keyword `function` instead of `class` to define a class</span></span><br><span class="line">    <span class="built_in">this</span>.printInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hi! JavaScript!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> oHelloWorld = <span class="keyword">new</span> HelloWorld();    <span class="comment">// Make a new object of the class named `HelloWorld`</span></span><br><span class="line"><span class="keyword">var</span> result = oHelloWorld.printInfo();    <span class="comment">//Call the method of the object to assign</span></span><br><span class="line"><span class="built_in">document</span>.write(result);</span><br></pre></td></tr></table></figure>
<h2 id="构造器">构造器</h2>
<p><strong>构造器（Constructor）</strong>，或称 <strong>构造方法</strong>，一种用于创建和初始化<code>class</code>创建的对象的特殊 <strong>方法（Methods）</strong>。<code>constructor([arguments]) &#123; ... &#125;</code>， 其中 <code>arguments</code> 看情况而定，可以省略。</p>
<p><strong>注意</strong>：</p>
<ol type="1">
<li>在一个类中只能有一个名为 <code>constructor</code> 的特殊方法。 一个类中出现多次构造函数 (constructor)方法将会抛出一个 <code>SyntaxError</code> 错误。</li>
<li>在一个构造方法中可以使用 <code>super</code> 关键字来 <mark>调用一个父类的构造方法</mark>。</li>
<li>如果没有显式指定构造方法，则会添加默认的 constructor 方法。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">arg0, arg1</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Polygon&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.body = arg0 + arg1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> poly1 = <span class="keyword">new</span> Polygon(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(poly1.name, poly1.body);</span><br><span class="line"><span class="comment">// expected output: &quot;Polygon&quot; 30</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/02/Hardware/DSP/2021-04-02-TI%E5%A4%9A%E6%A0%B8%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/02/Hardware/DSP/2021-04-02-TI%E5%A4%9A%E6%A0%B8%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">TI多核开发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-02 08:30:00" itemprop="dateCreated datePublished" datetime="2021-04-02T08:30:00+08:00">2021-04-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-07-08 22:41:03" itemprop="dateModified" datetime="2021-07-08T22:41:03+08:00">2021-07-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Communication/" itemprop="url" rel="index"><span itemprop="name">Communication</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>多核开发涉及多核通信及任务分配管理的问题，任何多核通信都需要针对具体芯片的型号及系统特性去设计。多核通信包括资源共享、竞争、同步、异步等问题；多核任务分配则关系着各核心任务均衡和RTOS系统能否及时响应的问题。</p>
<h1 id="基础知识">1. 基础知识</h1>
<h2 id="并发并行异步同步共享互斥进程线程">并发、并行、异步、同步、共享、互斥、进程、线程</h2>
<h3 id="concurrency-并发">Concurrency 并发</h3>
<p>仅表示计算机可以同时执行多项任务，以至于如何实现“同时”执行，则有许多不同形式。</p>
<p>如，单核处理器可以通过分配时间片，轮询任务来达到多任务并发。系统让一个任务运行一段时间，在切换到另一个任务运行，如此循环往复，此过程也被称为 线程的<strong>上下文切换（Context Switching）</strong>。</p>
<h3 id="parallelism-并行">Parallelism 并行</h3>
<p>多个任务于同一时刻在不同的和核心上进行处理，称为并行</p>
<h3 id="synchronization-同步">Synchronization 同步</h3>
<p>指程序任务间的先后关系，后面一个程序必须等前一个任务执行完毕方可启动。因此，在同步中，并无并发或并行概念</p>
<h3 id="asynchronization-异步">Asynchronization 异步</h3>
<p>指不同的任务之间不会相互等待</p>
<p>对于I/O资源访问频繁的系统，宜使用异步编程，</p>
<h3 id="mutual-exclusion-互斥">Mutual Exclusion 互斥</h3>
<p>程序内存开销 及 线程切换开销</p>
<h2 id="堆栈">堆、栈</h2>
<p>题目所指的 heap 和 stack 在 C++ 标准中相对的术语分别是<strong>自由存储</strong>（free store，即用<code>new</code>创建对象时所分配的空间）和<strong>自动变量</strong>（automatic variable，或称为局部变量，不要与 C++11 的<code>auto</code>混淆）。</p>
<p>编程角度，要分开两者，是因为两者的生命周期不一样。</p>
<p>如果只需要在作用域内维持变量的生命周期，最好就用自动变量，这样是最简单方便高效的。其他情况可考虑用自由存储、静态局部／全局变量，或类的（静态）成员变量。它们各有不同特点，不在此答案详述。另外，由于 C++ 不支持可变长数组（VLA），不可以定义动态长度的自动变量（成员变量也不行），这个情况下也需要用 new[] 来创建动态长度的数组。</p>
<p>自动变量会在作用域（如函数作用域、块作用域等）结束后析构、释放内存。因为分配和释放的次序是刚好完全相反的，所以可用到堆栈先进后出（first-in-last-out, FILO）的特性，而 C++ 语言的实现一般也会使用到调用堆栈（call stack）来分配自动变量（但非标准的要求）。 自由存储可以在函数结束后继续生存，所以也需要配合 delete 来手动析构、释放内存（也可使用智能指针避免手动 delete）。由于分配和释放次序没有限制，不能使用堆栈这种数据结构做分配，实现上可能采用自由链表（free list）或其他动态内存分配机制。</p>
<p><strong>堆</strong>，英文是 heap，在内存管理的语境下，指的是动态分配内存的区域。这个堆跟数据结构里的堆不是一回事。这里的内存，被分配之后需要手工释放，否则，就会造成内存泄漏。</p>
<p>C++ 标准里一个相关概念是自由存储区(free store)，特指使用 <code>new</code> 和 <code>delete</code> 来分配和释放内存的区域。一般而言，free store是堆(heap)的一个子集，原因如下：</p>
<ul>
<li><code>new</code> 和 <code>delete</code> 操作的区域是 free store；<code>malloc</code> 和 <code>free</code> 操作的区域是 heap</li>
<li><code>new</code> 和 <code>delete</code> 通常底层使用 <code>malloc</code> 和 <code>free</code> 来实现</li>
</ul>
<p><strong>栈</strong>，英文是 stack，在内存管理的语境下，指的是函数调用过程中产生的本地变量和调用数据的区域。这个栈和数据结构里的栈高度相似，都满足“后进先出”（last-in-first-out 或 LIFO）。</p>
<p><strong>RAII</strong>，完整的英文是 Resource Acquisition Is Initialization，是 C++ 所特有的资源管理方式。有少量其他语言，如 D、Ada 和 Rust 也采纳了 RAII，但主流的编程语言中， C++ 是唯一一个依赖 RAII 来做资源管理的。</p>
<p>RAII 依托栈和析构函数，来对所有的资源——包括堆内存在内——进行管理。对 RAII 的使用，使得 C++ 不需要类似于 Java 那样的垃圾收集方法，也能有效地对内存进行管理。RAII 的存在，也是垃圾收集虽然理论上可以在 C++ 使用，但从来没有真正流行过的主要原因。</p>
<p>嵌入式的设备如DSP上的栈空间是Kb级别，在函数内定义数组或申请空间都不能像linux下那样直接定义和申请，要么定义成全局的，要么指向一块划分好的空间，否则就会造成覆盖代码段等的问题。</p>
<p>DSP的所有变量，函数，以及程序员定义的地址都保存在这三片空间上，程序员在定义变量时，若没有特殊规定，则编译器自动把变量分配到可读写空间上的任意位置，所以当程序员使用 <code>int *p = 0x00810000</code> ；这种语法的时候，很有可能会覆盖掉程序保存变量和函数的空间，导致程序运行异常，因此需要一个 <code>.cmd</code> 文件来约束，哪些地方用来给程序员自己定义变量地址用，哪些地方用来给程序为变量和函数申请内存来用。</p>
<h1 id="多核通信模块">2. 多核通信模块</h1>
<blockquote>
<p><em>IPC Modules can be used in a variety of combinations.</em></p>
</blockquote>
<p>以上即是说，各类IPC模块可以根据需要进行组合混用。</p>
<p>IPC以独立插件的形式进行安装与使用，使用时可能需要手动挂载至项目属性中。</p>
<p>Here are some introductions about heap in the &lt;SPRUEX3K.pdf&gt; as follows:</p>
<blockquote>
<p>SYS/BIOS provides the following Heap implementations: - <strong>HeapMem.</strong> Allocate variable-size blocks. Section 6.8.1 - <strong>HeapBuf.</strong> Allocate fixed-size blocks. Section 6.8.2 - <strong>HeapMultiBuf.</strong> Specify variable-size allocation, but internally allocate from a variety of fixed-size blocks. Section 6.8.3</p>
</blockquote>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 32%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th>Module</th>
<th>Module Path</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GateMP（门）</td>
<td><code>GateMP</code></td>
<td>Manages gates for mutual exclusion of shared resources by multiple processors and threads. <br/><em>See Section 2.6.</em></td>
</tr>
<tr class="even">
<td>HeapBufMP（堆缓存）</td>
<td><code>ti.sdo.ipc.heaps.HeapBufMP</code></td>
<td>Fixed-sized shared memory Heaps. Similar to SYS/BIOS’s <code>ti.sysbios.heaps.HeapBuf</code> module, but with some configuration differences. <br/><em>See Section 2.5.</em></td>
</tr>
<tr class="odd">
<td>HeapMemMP（堆储存）</td>
<td><code>ti.sdo.ipc.heaps.HeapMemMP</code></td>
<td>Variable-sized shared memory Heaps. <br/><em>See Section 2.5.</em></td>
</tr>
<tr class="even">
<td>HeapMultiBufMP（堆混合缓存）</td>
<td><code>ti.sdo.ipc.heaps.HeapMultiBufMP</code></td>
<td>Multiple fixed-sized shared memory Heaps. <br/><em>See Section 2.5.</em></td>
</tr>
<tr class="odd">
<td>Ipc（核间通信）</td>
<td><code>ti.sdo.ipc.Ipc</code></td>
<td>Provides <code>Ipc_start()</code> function and allows startup sequence configuration. <br/><em>See Section 2.2.</em></td>
</tr>
<tr class="even">
<td>ListMP（列表）</td>
<td><code>ti.sdo.ipc.ListMP</code></td>
<td>Doubly-linked list for shared-memory, multi-processor applications. Very similar to the ti.sdo.utils.List module. <br/><em>See Section 2.4.</em></td>
</tr>
<tr class="odd">
<td>MessageQ （Q报文）</td>
<td><code>ti.sdo.ipc.MessageQ</code></td>
<td>Variable size messaging module. 可拥有不同大小的信息模块。<br/><em>See Section 2.3.</em></td>
</tr>
<tr class="even">
<td>TransportShm（运输表）</td>
<td><code>ti.sdo.ipc.transports.TransportShm</code></td>
<td>Transport used by MessageQ for remote communication with other processors via shared memory. <br/><em>See Section 2.3.11.</em></td>
</tr>
<tr class="odd">
<td>Notify （通知）</td>
<td><code>ti.sdo.ipc.Notify</code></td>
<td>Low-level interrupt mux/demuxer module. <br/><em>See Section 2.7.</em></td>
</tr>
<tr class="even">
<td>NotifyDriverShm（通知驱动表）</td>
<td><code>ti.sdo.ipc.notifyDrivers.NotifyDriverShm</code></td>
<td>Shared memory notification driver used by the Notify module to communicate between a pair of processors. <br/><em>See Section 2.7.</em></td>
</tr>
<tr class="odd">
<td>SharedRegion （共享区域）</td>
<td><code>ti.sdo.ipc.SharedRegion</code></td>
<td>Maintains shared memory for multiple shared regions. <br/><em>See Section 2.8.</em></td>
</tr>
</tbody>
</table>
<h2 id="header-files-included">Header Files included</h2>
<p>除了<code>&lt;ipc_install_dir&gt;/packages/ti/ipc/</code> 路径下可以找到IPC必须的头文件外， <code>&lt;ipc_install_dir&gt;/packages/ti/sdo/ipc/</code> 路径下同样有IPC的头文件，但是请勿直接引用至 <code>.c</code>文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/std.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/* ---- XDC.RUNTIME module Headers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/runtime/Memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/runtime/System.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/runtime/IHeap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/runtime/Timestamp.h&gt;</span>    <span class="comment">//not officially included</span></span></span><br><span class="line"><span class="comment">/* ----- IPC module Headers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/ipc/GateMP.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/ipc/Ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/ipc/MessageQ.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/ipc/HeapBufMP.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/ipc/MultiProc.h&gt;</span></span></span><br><span class="line"><span class="comment">/* ---- BIOS6 module Headers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/sysbios/BIOS.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/sysbios/knl/Task.h&gt;</span></span></span><br><span class="line"><span class="comment">/* ---- Get globals from .cfg Header */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/cfg/global.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="standard-ipc-function-call-sequence">Standard IPC Function Call Sequence</h2>
<p>Standard IPC Function Call Sequence，即标准IPC函数的调用顺序。</p>
<blockquote>
<p><strong><em>MODULE</em></strong> 在本处指任一类型的IPC调用（如，GateMP、IPC、MessageQ等），如 <code>MODULE_Open()</code> 即可替换成 <code>MessageQ_Open()</code> ，具体实参见对应的头文件。</p>
</blockquote>
<p>An application that uses IPC APIs—such as <code>MessageQ</code>, <code>GateMP</code>, and <code>ListMP</code>—<strong>must include the Ipc module header file and call <code>Ipc_start()</code> in the <code>main()</code> function. </strong> <code>Ipc_start()</code> does the following:</p>
<ul>
<li>初始化：Initializes a number of objects and modules used by IPC.</li>
<li>同步：Synchronizes multiple processors so they can boot in any order.</li>
</ul>
<p><strong>NOTES:</strong> If the <code>main()</code> function calls any IPC APIs, the call to <code>Ipc_start()</code> must be placed before any calls to IPC modules.</p>
<h3 id="调用顺序">调用顺序</h3>
<ul>
<li>Firstly, initialize a <code>MODULE_Params</code> structure to its default values via a <code>MODULE_Params_init()</code> function. The creator thread can then set individual parameter fields in this structure as needed.</li>
<li>Secondly, calls the <code>MODULE_create()</code> function to creates the instance and initializes any shared memory used by the instance. <em>If the instance is to be opened remotely, a unique name must be supplied in the parameters.</em></li>
<li>Other threads can access this instance via the <code>MODULE_open()</code> function, which <strong>returns a handle with access to the instance.</strong> The name that was used for instance creation must be used in the <code>MODULE_open()</code> function.</li>
<li>Finally, the thread that called <code>MODULE_create()</code> can call <code>MODULE_delete()</code> to free the memory used by the instance.</li>
</ul>
<blockquote>
<ul>
<li>首先，使用 <code>MODULE_Params_init()</code> 来初始化 <code>MODULE_Params</code> 结构。（创建它的线程）可以根据需要单独调整结构体内的个别参数。</li>
<li>然后，调用 <code>MODULE_create()</code> 函数来创建对象实例，并初始化其内存。如果该对象在别处被打开，需要给被调用的参数取好名字防止重复。</li>
<li>接着， 其他线程可以通过 <code>MODULE_open()</code> 函数接入该对象，并返回一个对应的句柄。该对象的创建名称必须与打开名称保持一致。</li>
<li>最后，调用 <code>MODULE_create()</code> 来创建对象实例的线程就可以调用 <code>MODULE_delete()</code> 来释放被对象占用的内存。</li>
</ul>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<p><em>All threads that opened an instance must close that instance before the thread that created it can delete it.</em> <em>Also, a thread that calls <code>MODULE_create()</code> cannot call <code>MODULE_close()</code>.</em> <em>Likewise, a thread that calls <code>MODULE_open()</code> cannot call <code>MODULE_delete()</code>.</em></p>
<p>在由创建者删除（delete）某IPC对象时，由谁使用（open）就由谁关闭（close）。且决不能由创建者来调用关闭函数，否则创建者无法删除该对象。（顺序如下图所示）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stateDiagram-v2</span><br><span class="line">	[*] --&gt; Core0</span><br><span class="line">	[*] --&gt; Core1</span><br><span class="line">	Core0 --&gt; IPC_Start()</span><br><span class="line">	IPC_Start() --&gt; Module_Create()</span><br><span class="line">	IPC_Start() --&gt; Core1 : Wait for Sychronization</span><br><span class="line">	Core1 --&gt; UsersProgram()</span><br><span class="line">	UsersProgram() --&gt; Module_Open()</span><br><span class="line">	Module_Open() --&gt; Module_Close()</span><br><span class="line">	Module_Create() --&gt; Module_Delete()</span><br><span class="line">	Module_Close() --&gt; Module_Delete() : Closed by who opens</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<h3 id="代码示例">代码示例</h3>
<h4 id="ipc_start-使用示例">Ipc_Start() 使用示例</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/ipc/Ipc.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="function">Int <span class="title">main</span><span class="params">(Int argc, Char* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     Int status;</span><br><span class="line">     <span class="comment">/* Call Ipc_start() */</span></span><br><span class="line">     status = Ipc_start();</span><br><span class="line">     <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         System_abort(<span class="string">&quot;Ipc_start failed\n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     BIOS_start();</span><br><span class="line">     <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="messageq_create-使用示例">MessageQ_Create() 使用示例</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">messageQ = MessageQ_create(DSP_MESSAGEQNAME, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (messageQ == <span class="literal">NULL</span>) &#123;   <span class="comment">//an error occurred when creating the object</span></span><br><span class="line">	System_abort(<span class="string">&quot;MessageQ_create failed\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="error-handling-in-ipc">Error Handling in IPC</h2>
<p>Success codes always have values greater or equal to zero. The Failure codes are always negative.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MessageQ_Msg msg; </span><br><span class="line">MessageQ_Handle messageQ;</span><br><span class="line">Int status;</span><br><span class="line">...</span><br><span class="line">status = MessageQ_get(messageQ, &amp;msg, MessageQ_FOREVER);</span><br><span class="line"><span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	System_abort(<span class="string">&quot;Should not happen\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ipc-module-configuration">IPC Module Configuration</h2>
<p>Configure how the IPC module synchronizes processors by configuring the <code>Ipc.procSync</code> property. For example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CONFIGURATION ABOUT INTER-PROCESS COMMUNICATION */</span></span><br><span class="line">var Ipc = xdc.useModule(&#x27;ti.sdo.ipc.Ipc&#x27;);</span><br><span class="line">Ipc.procSync = Ipc.ProcSync_ALL;</span><br></pre></td></tr></table></figure>
<p>Here are three options: <code>Ipc.ProcSync_ALL</code> | <code>Ipc.ProcSync_PAIR</code> | <code>Ipc.ProcSync_NONE</code></p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 37%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="header">
<th>Options</th>
<th>Conditions</th>
<th>Specialties</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Ipc.ProcSync_ALL</strong></td>
<td>- IPC processors on a device start up at the same time<br/>- Connections should be established between every possible pair of processors</td>
<td>- <code>Ipc_start() API</code> automatically attaches to and synchronizes all remote processors. <br/>- Application <strong><em>should never call</em></strong> <code>Ipc_attach()</code>.</td>
</tr>
<tr class="even">
<td><strong>Ipc.ProcSync_PAIR</strong> <em>(Default Mode)</em></td>
<td><em>One of the following is true:</em><br>- You need to control when synchronization with each remote processor occurs.<br/>- Useful work can be done while trying to synchronize with a remote processor by yielding a thread after each attempt to Ipc_attach() to the processor. <br/> - Connections to some remote processors are unnecessary and should be made selectively to save memory.</td>
<td>- Must explicitly call <code>Ipc_attach()</code> to attach to a specific remote processor. <br/>- <code>Ipc_start()</code> performs system-wide IPC initialization, but does not <strong>make connections to remote processors</strong>.</td>
</tr>
<tr class="odd">
<td><strong>Ipc.ProcSync_NONE</strong></td>
<td><em>Use this option with caution.</em> <br/>It is intended for use in cases where the application performs its own synchronization and you want to avoid a potential deadlock situation with the IPC synchronization.</td>
<td><code>Ipc_start()</code> doesn’t synchronize any processors before setting up the objects needed by other modules.</td>
</tr>
</tbody>
</table>
<h4 id="attach-and-detach-依附与分离">Attach and Detach （依附与分离）</h4>
<p>In addition to the default actions performed when attaching to or detaching from a remote processor, You can configure a function to perform custom actions.</p>
<p>Attach and Detach are provided for the processor synchronization:</p>
<ul>
<li><p><code>Ipc_attach()</code> Creates a connection to the specified remote processor.</p></li>
<li><p><code>Ipc_detach()</code> Deletes the connection to the specified remote processor.</p></li>
</ul>
<p>在 <code>.cfg</code> 文件中以下为两个互相依赖和两个互相分离的函数配置，每一组函数都会传递一个不同的参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Ipc = xdc.useModule(&#x27;ti.sdo.ipc.Ipc&#x27;);</span><br><span class="line"></span><br><span class="line">var fxn = <span class="keyword">new</span> Ipc.UserFxn;</span><br><span class="line">fxn.attach = &#x27;&amp;userAttachFxn1&#x27;;</span><br><span class="line">fxn.detach = &#x27;&amp;userDetachFxn1&#x27;;</span><br><span class="line">Ipc.addUserFxn(fxn, <span class="number">0x1</span>);</span><br><span class="line"></span><br><span class="line">fxn.attach = &#x27;&amp;userAttachFxn2&#x27;;</span><br><span class="line">fxn.detach = &#x27;&amp;userDetachFxn2&#x27;;</span><br><span class="line">Ipc.addUserFxn(fxn, <span class="number">0x2</span>);</span><br></pre></td></tr></table></figure>
<p><strong><em>These functions run near the end of <code>Ipc_attach()</code> and near the beginning of <code>Ipc_detach()</code> , respectively.</em></strong></p>
<p><strong><em>Such functions must be non-blocking and must run to completion. 这些被定义的函数必须为非阻塞且（一旦开始就）运行到底。</em></strong></p>
<p><strong>注意：</strong> Call <code>Ipc_attach()</code> to the processor that owns shared memory region 0 (usually the processor with id = 0) before making a connection to any other remote processor. For example, if there are three processors configured with <strong><em>MultiProc</em></strong>, #1 should attach to #0 before it can attach to #2.</p>
<h1 id="多核任务分配">3. 多核任务分配</h1>
<blockquote>
<p>如果多个核共享一个工程及相同的bios 配置文件，是不能指定某一个任务到特定的core上，如果某个任务只有某个core才会运行，可以在任务中区分core运行。如果多个core分别有不同的工程，则没有“多核任务分配”的问题，每个工程可以根据各自core的应用创建各自的任务，不需要软件区分core。</p>
</blockquote>
<blockquote>
<p>单核可以是一个out生成最终的bin文件烧写在flash，多核如果存在多个out文件，可以把out文件合并成一个bin烧写，或者多个bin分开烧写均可。bin文件中都有程序的地址及长度信息，在多个bin时，也是一样可以由core0负责对flash的程序文件解析，将程序搬移到相应的地址上，最后core0再向其他core magic address写入入口地址，并发送ipc触发即可。</p>
</blockquote>
<blockquote>
<p>这个并非由SYS/BIOS分配，需要开发者指定。</p>
<p>可以根据core number来做判断，然后确认该任务是否运行在该核上。</p>
</blockquote>
<h1 id="chip-support-library">4. Chip Support Library</h1>
<p>CSL，即芯片支持库( Chip Support Library)。在程序设计过程中利用CSL库函数可以方便地访问 <strong>DSP的寄存器和硬件资源</strong>，提高DSP软件的开发效率和速度。</p>
<p>CSL库包含了对INTC、Boot Configuration、BWMNGMT、CACHE、CHIP、CPINTC、EDMA3、EMAC、EMIF4F、GPIO、IDMA、IPC、MDIO、MEMPROT、MPU、MSMC、PLLC、PSC、Semaphore、SGMII、SRIO、TIMER、TSC、VCP2、XMC、CGEM、CPPI、QMSS、CPPI_LLD_SYMBOL 及 CPPI_LLD_ENUM共30种模块的支持。</p>
<h2 id="cache-module">Cache Module</h2>
<p>位于 <code>ti\pdk_C6657_1_1_2_6\packages\ti\csl\</code> 下的头文件 <code>&lt;csl_cacheAux.h&gt;</code> 提供了缓存（Cache）配置相关的CSL功能层API。</p>
<blockquote>
<p>This is the CACHE Auxilary Header File which exposes the <strong><em>various CSL Functional Layer API</em></strong>'s to <strong><em>configure the CACHE Module</em></strong>.</p>
</blockquote>
<blockquote>
<p>Cache API包含了对L1D（L1 Data Cache）、L1P 及 L2的各种操作。关于L1D、L1P及L2 的详细文件参考《SPRS814D》第193页。</p>
</blockquote>
<p>该头文件中对三种缓存的可操作方式如下示：</p>
<table>
<colgroup>
<col style="width: 83%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="header">
<th>OPERATION</th>
<th>L1D</th>
<th>L1P</th>
<th>L2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>setSize</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="even">
<td>getSize</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="odd">
<td>freeze</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="even">
<td>unfreeze</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="odd">
<td>getPrevMode<br/><em>-- get the previous operating state</em></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr class="even">
<td>invAllWait<br/><em>-- wait for the cache global invalidate operation to complete</em></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr class="odd">
<td>invAll<br/><em>-- globally invalidate cache</em></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr class="even">
<td>wbAllWait<br/><em>-- wait for the cache writeback operation to complete</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>wbAll<br/><em>-- writeback the dirty lines of the cache</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>wbInvAllWait<br/><em>-- wait for the cache writeback invalidate operation to complete</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>wbInvAll<br/><em>-- invalidate and writeback the dirty lines of the cache</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>invWait<br/><em>-- wait for the cache invalidate block operation to complete</em></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr class="odd">
<td>inv<br/><em>-- to invalidate a block in cache</em></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr class="even">
<td>wbWait<br/><em>-- wait for the cache writeback block operation to complete</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>wb<br/><em>-- writeback the dirty lines of the block address</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>wbInvWait<br/><em>-- wait for the cache invalidate/writeback block operation to complete</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>wbInv<br/><em>-- invalidate and writeback the dirty lines of the block address</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="ipc-module">IPC Module</h2>
<p>IPC，即进程间通信（Inter-process communication）。</p>
<p>位于 <code>ti\pdk_C6657_1_1_2_6\packages\ti\csl\</code> 下的头文件 <code>&lt;csl_ipcAux.h&gt;</code> 提供了<strong>查询定义</strong> 和 <strong>控制函数</strong>。IPC API包含了对 NMI、GEM、Host的各种操作。其中 <strong>GEM</strong> 对 IPCGRx 及 IPCARx 进行操作；而 <strong>Host</strong> 对 IPCGRH 及 IPCARH 进行操作。</p>
<p><strong>注意：</strong> 下文中， <code>index</code> 和 <code>srcId</code> 均是函数形参，如在<code>CSL_IPC_isGEMInterruptAckSet（uint32 index, uint32 srcId)</code>中：<code>index</code> 指需要检查IPCARx寄存器的GEM编号。<code>srcId</code> 指示在指定的索引对应的IPCARx寄存器中需要读取0-27 SRCCx位中的哪一个。</p>
<blockquote>
<p><strong>NMI</strong>，即 <strong>不可屏蔽中断</strong>（Non Maskable Interrupt）。<strong>NMIG</strong>，即 <strong>不可屏蔽中断产生寄存器</strong>（NMI Generation Register <em>(NMIGRx)</em>）。NMIGRx registers are used for generating NMI events to the corresponding CorePac. The C6657 has two NMIGRx registers (NMIGR0 and NMIGR1). The NMIGR0 register generates an NMI event to CorePac0, and the NMIGR1 register generates an NMI event to CorePac1.Writing 1 to the NMIG field generates an NMI pulse. Writing 0 has no effect and reads return 0 and have no other effect.</p>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_09-00-03.png" style="zoom:50%;" /></p>
<p><strong>IPCGRx</strong>，即 <strong>进程间通信产生寄存器</strong>（IPC interrupt generation register）。IPCGRx are to facilitate inter CorePac interrupts. The C6657 has two IPCGRx registers (IPCGR0 and IPCGR1). These registers can be used by external hosts or CorePacs to generate interrupts to other CorePacs. A write of 1to the IPCG field of the IPCGRx register will generate an interrupt pulse to CorePacx (0 &lt;= x &lt;= 1).</p>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_08-54-09.png" style="zoom:50%;" /></p>
<p><strong>IPCARx</strong>，即 <strong>IPC中断确认寄存器</strong>（IPC interrupt-acknowledgement registers）。IPCARx are to facilitate inter-CorePac core interrupts. The C6657 has two IPCARx registers (IPCAR0 and IPCAR1). These registers also provide a <em>Source ID facility</em> by which up to 28 different sources of interrupts can be identified. Allocation of source bits to source processor and meaning is entirely based on software convention. The register field descriptions are shown in the following tables. Virtually anything can be a source for these registers as this is completely controlled by software. Any master that has access to BOOTCFG module space can write to these registers.</p>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_08-57-22.png" style="zoom:50%;" /></p>
<p><strong>IPCGRH</strong>，即 <strong>主机IPC产生寄存器</strong>（IPC Generation Host）。The IPCGRH register facilitates interrupts to external hosts. Operation and use of the IPCGRH register is the same as for other IPCGR registers. The interrupt output pulse created by the IPCGRH register appears on device pin HOUT. <mark><i>The host interrupt output pulse should be stretched. It should be asserted for 4 bootcfg clock cycles (CPU/6) followed by a deassertion of 4 bootcfg clock cycles. Generating the pulse will result in 8 CPU/6 cycle pulse blocking window. </i></mark>Write to IPCGRH with IPCG bit (bit 0) set will only generate a pulse if they are beyond 8 CPU/6 cycle period.</p>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_09-33-14.png" style="zoom:50%;" /></p>
<p><strong>IPCARH</strong>，即 <strong>主机IPC确认寄存器</strong>（Host IPC Acknowledgment Register）。</p>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_14-57-07.png" style="zoom: 67%;" /></p>
</blockquote>
<p>该头文件中的可操作方式如下示：</p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 2%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>NMI</th>
<th>GEM</th>
<th>Host</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>genEvent</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>genInterrupt<br><em>-- generate an interrupt pulse</em></td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
<tr class="odd">
<td>isInterruptSourceSet</td>
<td></td>
<td>√<br><em>-- checks if the SRCSx bit of the <strong>IPCGRx</strong> register is set</em></td>
<td>√<br><em>-- checks if the SRCSx bit of the <strong>IPCGRH</strong> register is set</em></td>
</tr>
<tr class="even">
<td>isInterruptAckSet</td>
<td></td>
<td>√<br><em>-- checks if the SRCCx bit of the <strong>IPCARx</strong> register is set.</em></td>
<td>√<br><em>-- checks if the SRCCx bit of the <strong>IPCARH</strong> register is set.</em></td>
</tr>
<tr class="odd">
<td>clearInterruptSource</td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<p><code>isGEMInterruptSourceSet()</code> returns 1 if the <u>SRCCx bit corresponding to the <strong>srcId</strong> is set</u> in the IPCARx register corresponding to the index specified. 如果与srcId对应的SRCCx位在与指定索引对应的IPCARx寄存器中被设置，则返回1。</p>
<blockquote>
<p><code>CSL_IPC_clearGEMInterruptSource()</code> clears the interrupt source IDs by setting the <strong>SRCCx bit of IPCARx</strong> and <strong>SRCSx bit of IPCGRx</strong> corresponding to the GEM index and Source ID specified.</p>
<p><code>CSL_IPC_clearGEMInterruptSource()</code> 通过设置 <strong><em>GEM 索引</em></strong> 和 <strong><em>指定源 ID</em></strong> 对应的 <strong>IPCARx寄存器上的SRCCx位</strong> 和 <strong>IPCGRx寄存器上的SRCSx位</strong> 来清除 中断源ID 。</p>
</blockquote>
<blockquote>
<p><code>CSL_IPC_clearHostInterruptSource()</code> function clears the interrupt source IDs by setting the <strong>SRCCx bit of IPCARH</strong> and <strong>SRCSx bit of IPCGRH</strong> corresponding to the Source ID specified.</p>
<p><code>CSL_IPC_clearHostInterruptSource()</code> 通过设置 <strong><em>指定源ID</em></strong> 对应的 <strong>IPCARH上的SRCCx位</strong> 和 <strong>IPCGRH上的SRCSx位</strong> 来清楚中断源ID。</p>
</blockquote>
<h3 id="cache_wbinvl1d">CACHE_wbInvL1d()</h3>
<p>This function is used to <mark><strong>invalidate and writeback</strong> the <em>dirty lines</em> of the block address</mark>.</p>
<p>Although the block size can be specified in the number of bytes, the cache controller operates on whole cache lines.</p>
<p>To prevent unintended behavior "blockPtr" should be aligned on the cache line size and "byteCnt" should be a multiple of the cache line size.</p>
<h3 id="cache_invl1d">CACHE_invL1d ()</h3>
<p>This function is used to <mark><strong>invalidate</strong> a <em>block</em> in the L1D Cache</mark>.</p>
<p>Although the block size can be specified in the number of bytes, the cache controller operates on whole cache lines.</p>
<p>To prevent unintended behavior "blockPtr" should be aligned on the cache line size and "byteCnt" should be a multiple of the cache line size.</p>
<h2 id="chip-module">Chip Module</h2>
<p><code>#include &lt;csl_chipAux.h&gt;</code></p>
<p>本头文件是以C( <code>extern "C"</code> )的方式来书写的，包含芯片读取与写入相关操作的API，名称以 <code>CSL_chipRead</code> 或 <code>CSL_chipWrite</code> 开头，所有函数均以静态内联（static inline，重定义成 <code>CSL_IDEF_INLINE</code> ）32位非负整数（Uint32）的方式定义，如 <code>CSL_IDEF_INLINE Uint32 CSL_chipRead***();</code> 。</p>
<p><code>&lt;csl_chipAux.h&gt;</code> 提供了26个读取寄存器相关的函数，函数定义均是对寄存器的读取并返回数值，某些读取函数需要注意 <em>前置条件</em>（Pre-condition）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CSL_chipReadAMR();    <span class="comment">//Addressing Mode control register 寻址模式控制寄存器</span></span><br><span class="line">CSL_chipReadCSR();    <span class="comment">//Control Status register 控制状态寄存器</span></span><br><span class="line">CSL_chipReadIFR();    <span class="comment">//Interrupt Flag register 中断标志寄存器</span></span><br><span class="line">CSL_chipReadIER();    <span class="comment">//Interrupt Enable register 中断使能寄存器</span></span><br><span class="line">CSL_chipReadISTP();    <span class="comment">//Interrupt Service Table Pointer register 中断服务表指针寄存器</span></span><br><span class="line">CSL_chipReadIRP();    <span class="comment">//Interrupt Return Pointer register 中断返回指针寄存器</span></span><br><span class="line">CSL_chipReadNRP();    <span class="comment">//Nonmaskable Interrupt Return Pointer register </span></span><br><span class="line">CSL_chipReadERP();    <span class="comment">//Exception Return Pointer register 异常返回指针寄存器</span></span><br><span class="line">CSL_chipReadTSCL();    <span class="comment">//Time Stamp Counter Lower Order 32-bits register 时间戳计数器低32位</span></span><br><span class="line">CSL_chipReadTSCH();    <span class="comment">//Time Stamp Counter Higer Order 32-bits register 时间戳计数器高32位</span></span><br><span class="line">CSL_chipReadARP();    <span class="comment">//Analysis Return Pointer register </span></span><br><span class="line">CSL_chipReadILC();    <span class="comment">//Inner Loop SPL buffer Counter(ILC) register</span></span><br><span class="line">CSL_chipReadRILC();    <span class="comment">//Reload Inner Loop SPL buffer Counter(RILC) register</span></span><br><span class="line">CSL_chipReadREP();    <span class="comment">//Restricted Entry Point Address register</span></span><br><span class="line">CSL_chipReadPCE1();    <span class="comment">//Program Counter, E1 Phase register E1字段程序计数器</span></span><br><span class="line">CSL_chipReadDNUM();    <span class="comment">//DSP Core Number register 核心数寄存器</span></span><br><span class="line">CSL_chipReadSSR();    <span class="comment">//Saturation Status Register 饱和状态寄存器</span></span><br><span class="line">CSL_chipReadGPLYA();    <span class="comment">//GMPY A-side polynomial register </span></span><br><span class="line">CSL_chipReadGPLYB();    <span class="comment">//GMPY B-side polynomial register</span></span><br><span class="line">CSL_chipReadGFPGFR();    <span class="comment">//Golios Field Multiply Control Register</span></span><br><span class="line">CSL_chipReadDIER();    <span class="comment">//Debug Interrupt Enable Register 调试中断使能寄存器</span></span><br><span class="line">CSL_chipReadTSR();    <span class="comment">//Task State Register 任务状态寄存器</span></span><br><span class="line">CSL_chipReadITSR();    <span class="comment">//Interrupt Task State Register 中断任务状态寄存器</span></span><br><span class="line">CSL_chipReadNTSR();    <span class="comment">//NMI/Exception Task State Register 异常任务状态寄存器</span></span><br><span class="line">CSL_chipReadEFR();    <span class="comment">//Exception Flag Register 异常标志寄存器</span></span><br><span class="line">CSL_chipReadIERR();    <span class="comment">//Internal Exception Report Register 内部异常报告寄存器</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;csl_chipAux.h&gt;</code> 提供了24个写入寄存器相关的函数，且与读取寄存器相关函数并不呈现一一对应关系。函数定义均是将一个Uint32类型（重定义为 <code>CSL_Reg32</code> ）的新值赋值给寄存器，并将旧值返回，写入寄存器均不需要注意 前置条件，部分需要注意后置条件（Post-condition）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CSL_chipWriteAMR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteCSR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteISR(CSL_Reg32  val);    <span class="comment">//Interrupt Set Register 中断设置寄存器</span></span><br><span class="line">CSL_chipWriteICR(CSL_Reg32  val);    <span class="comment">//Interrupt Clear Register 中断清除寄存器</span></span><br><span class="line">CSL_chipWriteIER(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteISTP(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteIRP(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteNRP(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteERP(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteTSCL(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteARP(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteILC(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteRILC(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteREP(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteSSR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteGPLYA(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteGPLYB(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteGFPGFR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteDIER(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteTSR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteITSR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteNTSR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteECR(CSL_Reg32  val);    <span class="comment">//Exception Clear Register 异常清除寄存器</span></span><br><span class="line">CSL_chipWriteIERR(CSL_Reg32  val);</span><br></pre></td></tr></table></figure>
<p>共30个寄存器涉及是否可读写：</p>
<table>
<thead>
<tr class="header">
<th>Register</th>
<th>Read</th>
<th>Write</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AMR</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="even">
<td>CSR</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="odd">
<td>IFR</td>
<td>√</td>
<td>×</td>
</tr>
<tr class="even">
<td>ISR</td>
<td>×</td>
<td>√</td>
</tr>
<tr class="odd">
<td>ICR</td>
<td>×</td>
<td>√</td>
</tr>
<tr class="even">
<td>IER</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="odd">
<td>ISTP</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="even">
<td>IRP</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="odd">
<td>NRP</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="even">
<td>ERP</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="odd">
<td>TSCL</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="even">
<td>TSCH</td>
<td>√</td>
<td>×</td>
</tr>
<tr class="odd">
<td>ARP</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="even">
<td>ILC</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="odd">
<td>RILC</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="even">
<td>REP</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="odd">
<td>PCE1</td>
<td>√</td>
<td>×</td>
</tr>
<tr class="even">
<td>DNUM</td>
<td>√</td>
<td>×</td>
</tr>
<tr class="odd">
<td>SSR</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="even">
<td>GPLYA</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="odd">
<td>GPLYB</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="even">
<td>GFPGFR</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="odd">
<td>DIER</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="even">
<td>TSR</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="odd">
<td>ITSR</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="even">
<td>NTSR</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="odd">
<td>ECR</td>
<td>×</td>
<td>√</td>
</tr>
<tr class="even">
<td>EFR</td>
<td>√</td>
<td>×</td>
</tr>
<tr class="odd">
<td>IERR</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<h2 id="ipc_hw-example-in-anc">IPC_HW Example in ANC</h2>
<p><strong>硬件（中断）层核间通信</strong>（不需要修改）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ipc_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Hwi_Params params;    <span class="comment">//创建HWI对象</span></span><br><span class="line">	Error_Block eb;    <span class="comment">//创建错误块处理对象</span></span><br><span class="line"></span><br><span class="line">	Error_init(&amp;eb);    <span class="comment">//初始化错误块</span></span><br><span class="line">	Hwi_Params_init(&amp;params);    <span class="comment">//初始化HWI对象</span></span><br><span class="line">	params.eventId = <span class="number">90</span>;    <span class="comment">//IPC INT	/* Set the event ID of the associated host interrupt */</span></span><br><span class="line">	params.enableInt = TRUE;    <span class="comment">//打开中断</span></span><br><span class="line"></span><br><span class="line">	Hwi_create(<span class="number">5</span>, &amp;IpcIsr, &amp;params, &amp;eb);    <span class="comment">//INT5	/* Create Hwi thread Hwi function is CpIntc_dispatch */</span></span><br><span class="line">	Hwi_enable();    <span class="comment">//打开中断</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(CSL_chipReadDNUM() == <span class="number">0</span>)&#123;     <span class="comment">//core0	//检测运行前触发的ipc，因为运行前写入的ipc无法触发中断</span></span><br><span class="line">		<span class="keyword">if</span>(CSL_IPC_isGEMInterruptAckSet(<span class="number">0</span>,<span class="number">2</span>))&#123;    <span class="comment">//判断索引为0对应的IPCARx中的第2位是否为中断确认位</span></span><br><span class="line">			CSL_IPC_clearGEMInterruptSource(<span class="number">0</span>,<span class="number">2</span>);    <span class="comment">//是则清除</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;    <span class="comment">//core1</span></span><br><span class="line">		<span class="keyword">if</span>(CSL_IPC_isGEMInterruptAckSet(<span class="number">1</span>,<span class="number">2</span>))&#123;    <span class="comment">//判断索引为1对应的IPCARx中的第2位是否为中断确认位</span></span><br><span class="line">			CSL_IPC_clearGEMInterruptSource(<span class="number">1</span>,<span class="number">2</span>);   <span class="comment">//是则清除</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>核心同步</strong>（不需要修改）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ipc_CoreSync</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(CSL_chipReadDNUM() == <span class="number">0</span>)&#123;    <span class="comment">//core0</span></span><br><span class="line">                CSL_IPC_genGEMInterrupt(<span class="number">1</span>,<span class="number">1</span>);    <span class="comment">//IPC_IPCGR_SRCS1 = 1;</span></span><br><span class="line">                <span class="keyword">while</span>(!CSL_IPC_isGEMInterruptAckSet(<span class="number">0</span>,<span class="number">1</span>));    <span class="comment">//等待core1启动</span></span><br><span class="line">                CSL_IPC_clearGEMInterruptSource(<span class="number">0</span>,<span class="number">1</span>);    <span class="comment">//core1启动成功，清除标志</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;    <span class="comment">//core1</span></span><br><span class="line">		CSL_IPC_genGEMInterrupt(<span class="number">0</span>,<span class="number">1</span>);    <span class="comment">//IPC_IPCGR_SRCS1 = 1;</span></span><br><span class="line">		<span class="keyword">while</span>(!CSL_IPC_isGEMInterruptAckSet(<span class="number">1</span>,<span class="number">1</span>));    <span class="comment">//等待core0启动</span></span><br><span class="line">		CSL_IPC_clearGEMInterruptSource(<span class="number">1</span>,<span class="number">1</span>);    <span class="comment">//core0启动成功，清除标志</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>核间IPC信号发送</strong>（可根据需要进行修改）</p>
<p>可定义多个IPC核间通信函数，但是要区分得清各函数在何时何处被调用到，否则将会引起混乱。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ipc_Core0ToCore1</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 可自定义区域 */</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line">		ptr0[i] = adData[i];</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* 可自定义区域 */</span></span><br><span class="line">	CACHE_wbInvL1d(ptr0,<span class="number">64</span>,CACHE_WAIT);<span class="comment">//L1D line size 64bytes</span></span><br><span class="line">	CSL_IPC_genGEMInterrupt(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">////ipcgr1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ipc_Core1ToCore0</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 可自定义区域 */</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		ptr1[i] = daData[i];</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* 可自定义区域 */</span></span><br><span class="line">	CACHE_wbInvL1d(ptr1,<span class="number">64</span>,CACHE_WAIT);                 <span class="comment">//L1D line size 64bytes</span></span><br><span class="line">	CSL_IPC_genGEMInterrupt(<span class="number">0</span>,<span class="number">2</span>);                               <span class="comment">//ipcgr0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>核间通信中断函数</strong>（可根据需要进行修改）</p>
<p><strong>注意：</strong>实际使用时，并不需要在某处调用 <code>IpcIsr()</code> 函数，即实际上是被硬件中断进行控制的，在 <code>HWI_Create()</code> 函数中被使用到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IpcIsr</span><span class="params">(UArg arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(CSL_chipReadDNUM() == <span class="number">0</span>) &#123;                      <span class="comment">// core0</span></span><br><span class="line">		<span class="keyword">if</span>(CSL_IPC_isGEMInterruptAckSet(<span class="number">0</span>,<span class="number">2</span>))&#123;                      <span class="comment">//ipcgr0</span></span><br><span class="line">			CSL_IPC_clearGEMInterruptSource(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">			CACHE_invL1d(ptr1,<span class="number">64</span>,CACHE_WAIT);</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">				daData[i] = ptr1[i];</span><br><span class="line">			&#125;</span><br><span class="line">			Semaphore_post(sem0_da);    <span class="comment">//执行发送程序，将数据通过SPI发送到DA：通过semaphore切换task</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;	<span class="comment">// core1</span></span><br><span class="line">		<span class="keyword">if</span>(CSL_IPC_isGEMInterruptAckSet(<span class="number">1</span>,<span class="number">2</span>))&#123;                          <span class="comment">//ipcgr1</span></span><br><span class="line">			CSL_IPC_clearGEMInterruptSource(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">			CACHE_invL1d(ptr0,<span class="number">64</span>,CACHE_WAIT);</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line">				adData[i] = ptr0[i];</span><br><span class="line">			&#125;</span><br><span class="line">			Semaphore_post(sem1_anc);    <span class="comment">//执行core1的计算步骤，计算完后应该通知core0的ipc启动结果发送程序：通过semaphore切换task</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="c6657特性">5. C6657特性</h1>
<h2 id="l2缓存">L2缓存</h2>
<p>Debug模式下，程序文件都写在L2缓存中。而C6657总共有 <code>2048KB</code> 大小的L2 缓存，其中每个核心分配到 <code>1024KB</code> ，缓存起始地址为 <code>0x00800000</code> 。</p>
<p>在仿真器中分配内存大小一致，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">    L2SRAM (RWX) : org = <span class="number">0x800000</span>, len = <span class="number">0x100000</span></span><br><span class="line">    MSMCSRAM (RWX) : org = <span class="number">0xc000000</span>, len = <span class="number">0x100000</span></span><br><span class="line">    DDR3 (RWX) : org = <span class="number">0x80000000</span>, len = <span class="number">0x20000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Written in &lt;<em>TMS320C6655/57 DataManual</em>&gt;:</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/02/10/Programming/CSS/2021-02-10-CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/10/Programming/CSS/2021-02-10-CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">CSS学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-10 09:07:00" itemprop="dateCreated datePublished" datetime="2021-02-10T09:07:00+08:00">2021-02-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-08-07 00:04:20" itemprop="dateModified" datetime="2021-08-07T00:04:20+08:00">2021-08-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="css基础">CSS基础</h1>
<p><strong>书写方式：</strong> <code>CSS属性:</code> <code>属性值;</code></p>
<h2 id="css-类命名规则">1. CSS 类命名规则</h2>
<h3 id="公共命名规则">公共命名规则</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">CSS样式命名</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">wrapper</td>
<td style="text-align: left;">页面外围控制整体布局宽度</td>
</tr>
<tr class="even">
<td style="text-align: left;">container或content</td>
<td style="text-align: left;">容器,用于最外层</td>
</tr>
<tr class="odd">
<td style="text-align: left;">layout</td>
<td style="text-align: left;">布局</td>
</tr>
<tr class="even">
<td style="text-align: left;">head, header</td>
<td style="text-align: left;">页头部分</td>
</tr>
<tr class="odd">
<td style="text-align: left;">foot, footer</td>
<td style="text-align: left;">页脚部分</td>
</tr>
<tr class="even">
<td style="text-align: left;">nav</td>
<td style="text-align: left;">主导航</td>
</tr>
<tr class="odd">
<td style="text-align: left;">subnav</td>
<td style="text-align: left;">二级导航</td>
</tr>
<tr class="even">
<td style="text-align: left;">menu</td>
<td style="text-align: left;">菜单</td>
</tr>
<tr class="odd">
<td style="text-align: left;">submenu</td>
<td style="text-align: left;">子菜单</td>
</tr>
<tr class="even">
<td style="text-align: left;">sideBar</td>
<td style="text-align: left;">侧栏</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sidebar_a, sidebar_b</td>
<td style="text-align: left;">左边栏或右边栏</td>
</tr>
<tr class="even">
<td style="text-align: left;">main</td>
<td style="text-align: left;">页面主体</td>
</tr>
<tr class="odd">
<td style="text-align: left;">tag</td>
<td style="text-align: left;">标签</td>
</tr>
<tr class="even">
<td style="text-align: left;">msg message</td>
<td style="text-align: left;">提示信息</td>
</tr>
<tr class="odd">
<td style="text-align: left;">tips</td>
<td style="text-align: left;">小技巧</td>
</tr>
<tr class="even">
<td style="text-align: left;">vote</td>
<td style="text-align: left;">投票</td>
</tr>
<tr class="odd">
<td style="text-align: left;">friendlink</td>
<td style="text-align: left;">友情连接</td>
</tr>
<tr class="even">
<td style="text-align: left;">title</td>
<td style="text-align: left;">标题</td>
</tr>
<tr class="odd">
<td style="text-align: left;">summary</td>
<td style="text-align: left;">摘要</td>
</tr>
<tr class="even">
<td style="text-align: left;">loginbar</td>
<td style="text-align: left;">登录条</td>
</tr>
<tr class="odd">
<td style="text-align: left;">searchInput</td>
<td style="text-align: left;">搜索输入框</td>
</tr>
<tr class="even">
<td style="text-align: left;">hot</td>
<td style="text-align: left;">热门热点</td>
</tr>
<tr class="odd">
<td style="text-align: left;">search</td>
<td style="text-align: left;">搜索</td>
</tr>
<tr class="even">
<td style="text-align: left;">search_output</td>
<td style="text-align: left;">搜索输出和搜索结果相似</td>
</tr>
<tr class="odd">
<td style="text-align: left;">searchBar</td>
<td style="text-align: left;">搜索条</td>
</tr>
<tr class="even">
<td style="text-align: left;">search_results</td>
<td style="text-align: left;">搜索结果</td>
</tr>
<tr class="odd">
<td style="text-align: left;">copyright</td>
<td style="text-align: left;">版权信息</td>
</tr>
<tr class="even">
<td style="text-align: left;">branding</td>
<td style="text-align: left;">商标</td>
</tr>
<tr class="odd">
<td style="text-align: left;">logo</td>
<td style="text-align: left;">网站LOGO标志</td>
</tr>
<tr class="even">
<td style="text-align: left;">siteinfo</td>
<td style="text-align: left;">网站信息</td>
</tr>
<tr class="odd">
<td style="text-align: left;">siteinfoLegal</td>
<td style="text-align: left;">法律声明</td>
</tr>
<tr class="even">
<td style="text-align: left;">siteinfoCredits</td>
<td style="text-align: left;">信誉</td>
</tr>
<tr class="odd">
<td style="text-align: left;">joinus</td>
<td style="text-align: left;">加入我们</td>
</tr>
<tr class="even">
<td style="text-align: left;">partner</td>
<td style="text-align: left;">合作伙伴</td>
</tr>
<tr class="odd">
<td style="text-align: left;">service</td>
<td style="text-align: left;">服务</td>
</tr>
<tr class="even">
<td style="text-align: left;">regsiter</td>
<td style="text-align: left;">注册</td>
</tr>
<tr class="odd">
<td style="text-align: left;">arr/arrow</td>
<td style="text-align: left;">箭头</td>
</tr>
<tr class="even">
<td style="text-align: left;">guild</td>
<td style="text-align: left;">指南</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sitemap</td>
<td style="text-align: left;">网站地图</td>
</tr>
<tr class="even">
<td style="text-align: left;">list</td>
<td style="text-align: left;">列表</td>
</tr>
<tr class="odd">
<td style="text-align: left;">homepage</td>
<td style="text-align: left;">首页</td>
</tr>
<tr class="even">
<td style="text-align: left;">subpage</td>
<td style="text-align: left;">二级页面子页面</td>
</tr>
<tr class="odd">
<td style="text-align: left;">tool, toolbar</td>
<td style="text-align: left;">工具条</td>
</tr>
<tr class="even">
<td style="text-align: left;">drop</td>
<td style="text-align: left;">下拉</td>
</tr>
<tr class="odd">
<td style="text-align: left;">dorpmenu</td>
<td style="text-align: left;">下拉菜单</td>
</tr>
<tr class="even">
<td style="text-align: left;">status</td>
<td style="text-align: left;">状态</td>
</tr>
<tr class="odd">
<td style="text-align: left;">scroll</td>
<td style="text-align: left;">滚动</td>
</tr>
<tr class="even">
<td style="text-align: left;">.tab</td>
<td style="text-align: left;">标签页</td>
</tr>
<tr class="odd">
<td style="text-align: left;">.left .right .center</td>
<td style="text-align: left;">居左、中、右</td>
</tr>
<tr class="even">
<td style="text-align: left;">.news</td>
<td style="text-align: left;">新闻</td>
</tr>
<tr class="odd">
<td style="text-align: left;">.download</td>
<td style="text-align: left;">下载</td>
</tr>
<tr class="even">
<td style="text-align: left;">.banner</td>
<td style="text-align: left;">广告条(顶部广告条)</td>
</tr>
</tbody>
</table>
<h3 id="其他div命名规则">其他DIV命名规则</h3>
<p>　　登录条:loginBar</p>
<p>　　标志:logo</p>
<p>　　侧栏:sideBar</p>
<p>　　广告:banner</p>
<p>　　导航:nav</p>
<p>　　子导航:subNav</p>
<p>　　菜单:menu</p>
<p>　　子菜单:subMenu</p>
<p>　　搜索:search</p>
<p>　　滚动:scroll</p>
<p>　　页面主体:main</p>
<p>　　内容:content</p>
<p>　　标签页:tab</p>
<p>　　文章列表:list</p>
<p>　　提示信息:msg</p>
<p>　　小技巧:tips</p>
<p>　　栏目标题:title</p>
<p>　　友情链接:friendLink</p>
<p>　　页脚:footer</p>
<p>　　加入:joinus</p>
<p>　　指南:guild</p>
<p>　　服务:service</p>
<p>　　热点:hot</p>
<p>　　新闻:news</p>
<p>　　下载:download</p>
<p>　　注册:regsiter</p>
<p>　　状态:status</p>
<p>　　按钮:btn</p>
<p>　　投票:vote</p>
<p>　　合作伙伴:partner</p>
<p>　　版权:copyRight</p>
<h2 id="选择器">2. 选择器</h2>
<h3 id="基础选择器">基础选择器</h3>
<p>选择器按作用大小（从小到大）分为 <code>ID选择器(使用井字符做特殊标注：#)</code> 、<code>类选择器（使用英文点号做特殊标注：.）</code> 、 <code>标签选择器</code> 及 <code>通配符选择器（使用英文星号做特殊标注：*）</code>。</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 48%" />
<col style="width: 22%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr class="header">
<th>选择器类型</th>
<th>选择器特性</th>
<th>style书写方式</th>
<th>style应用方式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ID选择器</td>
<td>1. 与其他选择器类型一致，特殊之处是大部分情况作JavaScript调用<br/>2. 需要编写唯一id不可重复使用</td>
<td>#DivStyle { color: red; }</td>
<td>id="DivStyle"</td>
</tr>
<tr class="even">
<td>类选择器</td>
<td>1. 作用于使用class属性的一类标签，同面向对象的其他语言特性一致<br/>2. 单个标签可以使用多个类，中间以空格隔开</td>
<td>.ClassStyle { color: black;}</td>
<td>Class="ClassStyle ....."</td>
</tr>
<tr class="odd">
<td>标签选择器</td>
<td>作用于所有使用本标签的标签</td>
<td>div { color: blue; }</td>
<td>/</td>
</tr>
<tr class="even">
<td>通配符选择器</td>
<td>作用于所有标签</td>
<td>* { clolor: pink; }</td>
<td>/</td>
</tr>
</tbody>
</table>
<h3 id="复合选择器">复合选择器</h3>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 44%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th>复合选择器类型</th>
<th>选择器特性</th>
<th>style书写方式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>后代选择器</td>
<td>1. 可以选择<strong>某个</strong>父标签下的<strong>某个</strong>全部子标签，不管其是否在同一个层级<br/>2. 当标签发生嵌套时，内层标签就称为外层标签的后代<br/>3. 浏览器按照标签层级的关系进行查找，并<u>对最内层标签进行修改</u>，因此可以定义多重标签选择，如可以使用基础选择器（类选择器及ID选择器）进行组合使用<br/>4. 内外层选择器之间 <mark>以空格隔开</mark></td>
<td>外层标签 内层标签 {属性}<br/>ol li { color: #000; }<br/>ol li a { color: #777; }<br/>.nav li a { color: pruple;}</td>
</tr>
<tr class="even">
<td>子代选择器</td>
<td>1. 即与后代选择器不同，仅对父级标签下的某一类选择器进行操作，不会作用于其他子代的同类标签<br/>2. 使用符号 <code>&gt;</code> 进行操作</td>
<td>.nav&gt;a {color: pink;}</td>
</tr>
<tr class="odd">
<td>集选择器（相邻选择器）</td>
<td>1. 在两个没有从属关系（子代或后代）和相同特点（如同类标签）的同级不同类标签中，定义一个相同的样式<br/>2. 多个标签进行选择时使用英文逗号 <code>,</code> 进行并列选择<br/>3. 并集选择器内可使用 <strong>简单选择器</strong> 和 <strong>复合选择器</strong>（如 后代选择器 和 子代选择器），竖向书写选择器</td>
<td>div, p {color: pink; }</td>
</tr>
<tr class="even">
<td>伪类选择器</td>
<td>1. 用于给某些选择器添加特殊效果（如给链接添加特殊效果），或者选择某个元素<br/>2. 结构伪类、链接伪类、表单伪类<br/>3. 伪类选择器其实更像是一个行为选择器（或状态选择器），它定义了一个/类标签在不同状态下的样式，书写形式如：<code>标签</code>: <code>状态/行为</code> <code>&#123;属性&#125;</code></td>
<td>.OnlineTitle:link {<br/> color: #222222;<br/> text-decoration: none;<br/>}</td>
</tr>
</tbody>
</table>
<p><strong>并集选择器</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">如要求将下方熊大、熊二及佩奇一家都改为粉色，则按照&lt;style&gt;中的方式进行书写</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">            //在两个没有从属关系（子代或后代）和相同特点（如同类标签）的同级不同类标签中，定义一个相同的样式</span><br><span class="line"><span class="css">            <span class="selector-tag">div</span>,</span></span><br><span class="line"><span class="css">            <span class="selector-tag">p</span>,</span></span><br><span class="line"><span class="css">            <span class="selector-class">.pig</span> <span class="selector-tag">li</span> &#123;                //类选择器</span></span><br><span class="line"><span class="css">                <span class="attribute">color</span>: pink;</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>熊大<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>熊二<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>关头强<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;pig&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>PIG 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>PIG 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>PIG 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>链接伪类选择器</strong></p>
<p>四个使用方式: link / visited / hover / active</p>
<ol type="1">
<li>为了确保生效，应按照LVHA的顺序进行声明。</li>
<li><code>&lt;a&gt;</code> 链接在浏览器中具有默认样式，不会因为在<code>&lt;body&gt;</code>中而随之改变，实际工作中需要给链接单独指定样式。</li>
<li>使用时，加上冒号 <code>:</code> 与 四种<code>状态</code>之一 即可</li>
</ol>
<p>举例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="attribute">background-color</span>:yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当鼠标经过父级元素时，显示子元素的遮罩层：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tudou</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.mask</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: block;      <span class="comment">/* 显示遮罩层 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最小盒子：</strong>即只能存放文字了，不能再存放其他标签/元素，如 <code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code>等文字块级标签；</p>
<h3 id="元素显示模式">元素显示模式</h3>
<p>是指在页面上的元素以 <strong>块状模式</strong> 、 <strong>行内模式</strong> 或 <strong>行内块模式</strong> 进行显示。元素按显示模式可以分为 <strong>块状（级）元素</strong> 及 <strong>行内元素（内联元素）</strong> 及 <strong>行内块元素</strong> 三种类型。</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 30%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>元素类型</th>
<th>典型标签</th>
<th>特点</th>
<th>注意点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>块状元素</td>
<td><code>&lt;h1&gt;</code>~<code>&lt;h6&gt;</code> 、 <code>&lt;p&gt;</code>、 <code>&lt;div&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>......</td>
<td>1. 即使设置标签宽度，也是独占一行<br/>2. 高、宽、外边距及内边距可调节<br/>3. 默认宽度是父级宽度的100%<br/>4. 是一个容器及盒子，可以放任何标签</td>
<td>文字类的标签内不可以存放块元素</td>
</tr>
<tr class="even">
<td>行内元素（内联元素）</td>
<td><code>&lt;a&gt;</code>、 <code>&lt;strong&gt;</code>、<code>&lt;b&gt;</code>、 <code>&lt;em&gt;</code>、<code>&lt;i&gt;</code> ......</td>
<td>1. 相邻行内元素在一行上，一行可以显示多个<br/>2. 直接设置宽高无效，可以间接设置<br/>3. 默认宽度就是其内容宽度<br/>4. 行内元素只能容纳文本及其他行内元素</td>
<td>1. 链接中不允许再放其他链接<br/>2. <code>&lt;a&gt;</code>中可以放置块元素，但是转换成块级元素最安全</td>
</tr>
<tr class="odd">
<td>行内块元素</td>
<td><code>&lt;input&gt;</code>、 <code>&lt;image&gt;</code>、<code>&lt;td&gt;</code>......</td>
<td>1. 同时具有块元素及行内元素的特定<br/>2. 和相邻行内元素（行内块）在一行上，但是有空白缝隙，可以一行显示多个<br/>3. 默认宽度即内容宽度<br/>4. 高度、行高、外边距及内边距可控制</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>元素显示模式的转换</strong></p>
<p>即一个模式的元素需要另一个模式的特性，可以通过在CSS的标签样式属性中添加display语句进行转换。</p>
<p>转换为块级元素： <em><code>display: block;</code></em></p>
<p>转换为行内元素： <em><code>display: inline;</code></em></p>
<p>转换为行内块元素： <em><code>display: inline-block;</code></em></p>
<h3 id="权重">权重</h3>
<table>
<thead>
<tr class="header">
<th>选择器类型</th>
<th>权重</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>继承</td>
<td>无</td>
</tr>
<tr class="even">
<td>通配符选择器、子代选择器、相邻选择器（并集选择器）</td>
<td>0,0,0,0</td>
</tr>
<tr class="odd">
<td>元素选择器、伪元素选择器</td>
<td>0,0,0,1</td>
</tr>
<tr class="even">
<td>类选择器、伪类选择器、属性选择器</td>
<td>0,0,1,0</td>
</tr>
<tr class="odd">
<td>ID选择器</td>
<td>0,1,0,0</td>
</tr>
<tr class="even">
<td>内联选择器</td>
<td>1,0,0,0</td>
</tr>
<tr class="odd">
<td>!IMPORTANT</td>
<td>无限</td>
</tr>
</tbody>
</table>
<p>选择器的加权结果并非二进制，而是在各个数位上进行单独相加，例如元素选择器与类选择器的加权结果为 <code>0,0,1,1</code>，左侧数位的数值越大，权重越高。</p>
<h2 id="list">3. List</h2>
<p><code>list-style</code> CSS 属性是一个简写对属性集合，包括<code>list-style-type</code>, <code>list-style-image,</code> 和 <code>list-style-position</code>。</p>
<p><code>list-style: none | circle | square inside ;</code>表示<code>&lt;ul&gt;</code> 下 <code>&lt;li&gt;</code> 前的小点样式，如“无、圆圈、实心方形”。</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>List Item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>List Item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>List Item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">List 2</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>List Item A<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>List Item B<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>List Item C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>及</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: circle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: square inside;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="background">4. Background</h2>
<p><code>background-color</code> 可以设置为 <code>transparent</code>，即透明的，不可视的。</p>
<p><code>background-image</code> 可以设置为 <code>none</code>，也可以跟上一个 <code>url()</code> 链接。如：<code>background-image: url(http://xxxxxx.com/123.jpg)</code></p>
<p><code>background-repeat: repeat | no-repea | repeat-x | repeat-y</code> ，分别是指 重复（平铺）、不平铺、在x轴上平铺 及 在y轴上平铺 。</p>
<p><code>background-position: top | bottom | left | right | center;</code> 除了可以使用类似于左侧的方位词定位，还可以使用坐标轴数值定位。</p>
<h2 id="font">5. Font</h2>
<p><strong>FONT-FAMILY 字体族</strong></p>
<p>通用属性之一，用于设置网页显示字体，font-family的使用方式为 <code>font-family=" "</code> ，双引号内可以书写多个字体，引擎会按顺序搜索本地字体并使用，如果都没有则使用本地字体。</p>
<p><strong>注意：</strong>建议使用字体的全英文进行书写，如 <strong>微软雅黑</strong> 全英文为 <strong>Microsoft YaHei</strong>，英文书写时有空格的应用单引号<code>‘’</code> 进行包裹。</p>
<p><strong>FONT-SIZE 字体大小</strong></p>
<p>通常用于对body标签内所有正文字体大小的设置，对标题（如<code>h3</code>）大小的设置仍需另起样式。</p>
<p><strong>复合写法</strong></p>
<p><code>font: font-style font-weight font-size/line-height font-family;</code></p>
<p><code>font-size</code> 和 <code>font-family</code> 不可缺省</p>
<h2 id="text">6. Text</h2>
<p><strong>文本属性</strong></p>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 47%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>属性</th>
<th>书写方式</th>
<th>注意</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>color<br/>颜色</td>
<td>1. 常见英文表示法，直接书写该颜色英文即可，如 pink  red  blue  purple<br/>2. 16进制表示法，用#号进行书写，如#FF00FF<br/>3. RGB表示法，如rgb(0,0,255)</td>
<td>16进制简写为#fff<br/>实际开发中用16进制</td>
</tr>
<tr class="even">
<td>text-align<br/>文本对齐</td>
<td>仅有左、中、右三种表示方式，用英文 left  center  right 进行书写</td>
<td></td>
</tr>
<tr class="odd">
<td>text-indent<br/>文本缩进</td>
<td>缩进可以用2种方式表示：<br/>1. 精准缩进：即直接使用 <code>px</code> 单位进行书写，表示缩进多少像素点，缺点是容易出现问题<br/>2. 字符单位缩进：即按照字符大小，自适应缩进字符距离，单位是em，如 <code>2em</code>，可以缩进2个字符</td>
<td></td>
</tr>
<tr class="even">
<td>text-decoration<br/>文本修饰</td>
<td>常见的修饰类型有四种：无（none）、上划线（overline）、下划线（underline）、删除线（line-through）</td>
<td></td>
</tr>
<tr class="odd">
<td>line-height</td>
<td>行高=上行距+下行距+字高，且上行距=下行距</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="box-module">7. Box Module</h2>
<p>盒子模型主要分三部分：<strong>border</strong>（边框）、<strong>padding</strong>（内边距）及 <strong>margin</strong>（外边距）。</p>
<h3 id="border">Border</h3>
<p>边框主要有一下三种参数：粗细、颜色及样式</p>
<ul>
<li>粗细(border-width: 5px;)</li>
<li>颜色(boder-color: #555) （<em>注意：如果这个值没有设置，它的默认值是元素的 color属性值（是文字颜色而非背景色）</em>），可以定义为transparent（透明的）</li>
<li>样式(boder-style: none | hidden | dotted | dashed | solid | double(双层线) | groove(内雕刻) | ridge(外浮雕) | inset(内凹陷) | outset(外凹陷) )</li>
</ul>
<p>border属性之可以在中间添加上、下、左、右四个方位词和三参数之一，如 border-top-color | border-bottom-style ....</p>
<p>边框使用时会影响盒子大小，需要注意调整。</p>
<p><strong>复合写法</strong></p>
<p><code>border: [border-width ||border-style ||border-color |inherit] ;</code></p>
<h3 id="padding">Padding</h3>
<p>内边距涉及到的参数包括 上下左右四边的边距。</p>
<p>在未设置内盒子的width时，设置padding对内盒子实际显示大小不起影响，一旦设置width，则会让盒子的width在显示时超过设置参数的大小。</p>
<h3 id="margin">Margin</h3>
<p>外边距同内边距。</p>
<p>在标准流下，设置块级盒子width参数后，设置margin左右为auto，可以让盒子实现居中效果。（以下三种写法，推荐第一个，第一个参数表示上下，第二个参数表示左右）</p>
<p><code>margin: 0 auto;</code></p>
<p><code>margin: auto;</code></p>
<p><code>margin-left: auto; margin-right: auto;</code></p>
<h3 id="qa">Q/A</h3>
<p><strong>盒子塌陷的解决方案</strong></p>
<p>以下为两个盒子嵌套，同时设置上边距导致塌陷问题的解决方案：</p>
<ul>
<li>可以为父元素定义上边框/上内边距</li>
<li>可以为父元素添加 <code>overflow: hidden;</code></li>
<li>利用浮动、固定、绝对定位解决</li>
</ul>
<h2 id="float">8. Float</h2>
<p>浮动最初的开发目的是让图片和文字产生环绕效果的，浮动可以让多个块级元素在一行内显示。</p>
<p><code>float: none | left | right;</code></p>
<p><strong>注意：</strong>两个行内块元素中间会有空白间隙存在，如果父级元素设定了宽度，会让元素存放不下。需要给此类行内块元素设定浮动</p>
<p><strong>浮动特性：</strong></p>
<ul>
<li><p>脱标</p></li>
<li><p>顶端对齐</p></li>
<li><p>具有行内块元素特性</p></li>
</ul>
<p><strong>外边距合并</strong></p>
<blockquote>
<p>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p>
</blockquote>
<p><strong>注释：</strong>只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。</p>
<p>在标准流中嵌套一个带有外边距的浮动框，不会让他们产生外边距合并。</p>
<h2 id="clean-float">9. Clean Float</h2>
<p>清除浮动也叫闭合浮动，是指在未指定父级元素高度而子级元素为浮动时，会对父级元素同级的标准流造成影响，因而需要清除该类浮动造成的弊端的情况。</p>
<p>清除浮动的四种方式：</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 35%" />
<col style="width: 20%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="header">
<th>方法</th>
<th>说明</th>
<th>写法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>额外标签</td>
<td>[w3c推荐]也称隔墙法，指在浮动的块（行内块）级元素后面新增一个带有<code>clear: both;</code>属性的额外标签（要求是块级元素）来屏蔽浮动的影响。</td>
<td><code>clear: both;</code></td>
<td>弊端是增加了额外标签，对H5结构造成负担；<br/>要求新增的标签不能是行内元素</td>
</tr>
<tr class="even">
<td>父级添加overflow</td>
<td>仅给父级元素添加overflow，添加hidden、auto、scroll皆可。</td>
<td><code>overflow: hidden | auto | scroll</code></td>
<td>优点是代码简洁，缺点是无法显示溢出的部分</td>
</tr>
<tr class="odd">
<td>:after伪元素</td>
<td>额外标签法的升级版，利用CSS样式添加额外标签<br/>仅给父级元素添加</td>
<td>见下方</td>
<td>没有增加额外标签，样式写法较为复杂；</td>
</tr>
<tr class="even">
<td>双伪元素</td>
<td>在子级前后各添加一个伪元素</td>
<td>见下方</td>
<td>代码简洁，照顾低版本。</td>
</tr>
</tbody>
</table>
<p><strong>:after伪元素代码示例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:after &#123;</span><br><span class="line">	content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="attribute">display</span>: block;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">clear</span>: both;</span><br><span class="line">	<span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;       <span class="comment">/* IE6、7专有 */</span></span><br><span class="line">	*zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>双伪元素代码示例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:before, .clearfix:after&#123;</span><br><span class="line">	content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span>:after&#123;</span><br><span class="line">	clear: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">	*zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="position">10. Position</h2>
<h3 id="定位的意义">定位的意义</h3>
<p>让盒子自由地在某个盒子中移动或固定在屏幕中的某个位置，并且可以压住其他盒子。</p>
<p><strong>注意：</strong>对于标准流和浮动，不可以使用定位。</p>
<h3 id="定位模式">定位模式</h3>
<p><code>position: static | relative | absolute | fixed ;</code></p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 14%" />
<col style="width: 5%" />
<col style="width: 27%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr class="header">
<th>定位分类</th>
<th>脱标</th>
<th>使用情况</th>
<th>参考系</th>
<th>其他特点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>静态定位 <code>static</code></td>
<td>否，不能使用边偏移</td>
<td>很少</td>
<td>无，不设置边偏移</td>
<td>按照标准流特性摆放位置</td>
</tr>
<tr class="even">
<td>相对定位 <code>relative</code></td>
<td>否，占用标准流的位置</td>
<td>常用</td>
<td>自身原来的位置</td>
<td>相对于自身原来的位置来移动<br/>设置相对定位后，后面的标准流<strong>不会脱标</strong>，不会让身后的标准流往前挤或往后挤；<br/>通常是给绝对定位当父级元素的属性</td>
</tr>
<tr class="odd">
<td>绝对定位 <code>absolute</code></td>
<td>是，不占用标准流的位置</td>
<td>常用</td>
<td>最近一级父级以上带有定位的盒子（子绝父相）</td>
<td>如果没有已定位的父级元素，则以浏览器进行绝对定位</td>
</tr>
<tr class="even">
<td>固定定位 <code>fixed</code></td>
<td>是，不占用标准流的位置</td>
<td>常用</td>
<td>浏览器的可视窗口</td>
<td>与父级元素无关，不随窗口滚动条滚动<br/></td>
</tr>
<tr class="odd">
<td>粘性定位 <code>sticky</code></td>
<td>否，占用标准流的位置</td>
<td>很少</td>
<td>浏览器的可视窗口</td>
<td>相对定位和固定定位的混合体，具有两者的某些特点<br/>必须添加至少一个边偏移参数<br/>需与滚动搭配使用，对IE兼容性差，类似粘性定位的做法通常用JavaScript来做</td>
</tr>
</tbody>
</table>
<h3 id="边偏移">边偏移</h3>
<p>相对于父级盒子（或者有定位的祖辈盒子）的边线偏移量（偏移量可以为负值）。</p>
<p>需要在设置好定位模式后边偏移才能生效。</p>
<p><strong>四种偏移：</strong>top、bottom、right、left；</p>
<p><strong>例：</strong><code>top: 10px; right: 20px;</code></p>
<p><strong>如何将内容固定到版心右侧？</strong></p>
<p>使用固定定位至左侧的50%，在调整<code>margin-left</code>值至版心宽度的一般（直接书写数值px）。</p>
<p><strong>如何让内容固定到屏幕正中心？</strong></p>
<p>使用固定定位至左侧和顶部的50%，再使用<code>margin-left</code>和<code>margin-right</code>的负值来抵消自身宽高的一半。</p>
<h3 id="定位显示优先级">定位显示优先级</h3>
<p>定位显示优先级，即定位叠放顺序，是指 <strong>具有定位属性的盒子</strong>（类似于PS图层）在Z轴上的显示优先级，数值越大则优先级越高。</p>
<p>如果设置为<code>auto</code>，则按照H5结构书写顺序以“后来居上”的原则显示。</p>
<p>如果设置为数值，则比auto优先级更高，但是不能写单位。</p>
<p><code>z-index: (number) | auto;</code></p>
<h3 id="定位的特殊性质">定位的特殊性质</h3>
<ul>
<li>给行内元素添加绝对或者固定定位后，可以设置宽度和高度（不等同于与块级元素互换特性？）</li>
<li>给块级元素添加绝对或者固定宽度后，不设置宽高也可以则应用内容的大小</li>
</ul>
<h2 id="显示与隐藏">11. 显示与隐藏</h2>
<p>显示与隐藏的三种方式：display（显示隐藏）、visibility（显示隐藏）、overflow （溢出显示隐藏）</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 41%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th>方式</th>
<th>用法</th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>display（显示隐藏）</td>
<td>该属性本来是设置元素如何显示的；<br /><code>display: none;</code> 用于隐藏对象；<br /><code>display: block;</code> 除了用于转换成块级元素，还可以用于显示元素；</td>
<td>隐藏元素后，不再占有其原位置；<br />应用广泛，搭配js做网页特效用；</td>
</tr>
<tr class="even">
<td>visibility（显示隐藏）</td>
<td>用于设置元素的可见性；<br /><code>visibility: visible | hidden | inherit | collapse ;</code></td>
<td>隐藏元素后，仍占有其原位置；<br /></td>
</tr>
<tr class="odd">
<td>overflow （溢出显示隐藏）</td>
<td>仅针对溢出元素框的部分进行显示或隐藏；<br /><code>overflow: visible;</code> 设置时<code>clip</code>属性设置将失效；<br /><code>overflow: hidden;</code> 不显示超过对象尺寸的内容；<br /><code>overflow: scroll;</code> 以滚动条形式显示，不管是否内容是否溢出；<br /><code>overflow: auto;</code> 自动判断内容长度，按需添加滚动条；</td>
<td>如果带有定位属性，应慎用 <code>overflow: hidden;</code> ，会隐藏多余的部分</td>
</tr>
</tbody>
</table>
<h2 id="布局">12. 布局</h2>
<h3 id="常见的布局形式">常见的布局形式</h3>
<p><strong>传统布局方式：</strong>普通流（文档流、标准流）、浮动、定位。</p>
<p><strong>通栏：</strong>是指和浏览器一样宽。</p>
<p><strong>布局设计准则：</strong></p>
<ul>
<li><p>纵向块级元素用标准流，横向块级元素用浮动。</p></li>
<li><p>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置，复合网页布局第一准则。</p></li>
<li><p>浮动的盒子只会影响浮动盒子后方的标准流，不影响前方的标准流。</p></li>
<li><p>应首先采用“一浮全浮”设计原则。</p></li>
<li><p>在产品列表数量众多、文字数量众多等不能明确盒子高度的情况下不应指定父级盒子的高度， 否则会出现父级盒子因高度限制而出现子元素无法显示的情况，应让子元素撑开父元素。</p></li>
<li><p>当给父元素设置标准流却未设置高度，而子元素为浮动时，父元素会高度塌陷。因浮动的子元素不占有高度，因此子元素浮动会会导致无高度的标准流父级元素高度塌陷，影响后续布局。</p></li>
</ul>
<h3 id="css属性书写建议">CSS属性书写建议</h3>
<ol type="1">
<li>布局定位属性：display / position / float / clear / visibility / overflow (建议display第一个写)</li>
<li>自身属性：width / height / margin / padding / border / background</li>
<li>文本属性：color / font / text-decoration / text-align / vertical-align / white-space / break-word</li>
<li>其他属性：content / cursor / border-radius / box-shadow / text-shadow / background:liner-gradient ....</li>
</ol>
<h3 id="页面布局的整体思路">页面布局的整体思路</h3>
<ol type="1">
<li>确定版心，即可视区</li>
<li>分析行、块 以及 块中的列模块</li>
<li>列模块经常浮动布局，确定列大小后确定列的位置</li>
<li>先结构，后样式</li>
</ol>
<h3 id="关于导航栏">关于导航栏</h3>
<p>实际开发中，不会直接只用<code>&lt;a&gt;</code>来制作导航栏，而是用<code>&lt;li&gt;</code>包含链接的<code>&lt;li&gt;</code>+<code>&lt;a&gt;</code>来制作。</p>
<p><code>&lt;li&gt;</code>+<code>&lt;a&gt;</code>语义更加清晰，更为有条理的列表型内容。如果直接用<code>&lt;a&gt;</code>，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字存在被搜索引擎降权的风险），从而影响网站排名。</p>
<h2 id="特殊符号">13. 特殊符号</h2>
<p>小于号 &lt; <code>&amp;lt;</code></p>
<p>大于号 &gt; <code>&amp;gt;</code></p>
<h1 id="高级技巧">高级技巧</h1>
<p>目标：</p>
<ul>
<li><p>能够使用精灵图</p></li>
<li><p>能够使用字体图标</p></li>
<li><p>能够写出CSS三角</p></li>
<li><p>能够写出常见的CSS用户界面样式</p></li>
<li><p>能够说出常见的布局技巧</p></li>
</ul>
<h2 id="css-sprites">CSS Sprites</h2>
<p>CSS精灵技术的目的：减少客户端向服务器的请求次数，减小服务器的压力，提高网页的加载速度。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备19004822号 </a>
  </div>

<div class="copyright">
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liewzheng</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":"enable","tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
