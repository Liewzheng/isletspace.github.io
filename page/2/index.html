<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;islet.space&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script>
<meta name="description" content="笔记分享的旮旯孤岛而已">
<meta property="og:type" content="website">
<meta property="og:title" content="Coder的孤岛">
<meta property="og:url" content="http://islet.space/page/2/index.html">
<meta property="og:site_name" content="Coder的孤岛">
<meta property="og:description" content="笔记分享的旮旯孤岛而已">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liewzheng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://islet.space/page/2/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;en&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;2&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Coder的孤岛</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Coder的孤岛</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">islet of the coder</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-文章"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>文章</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liewzheng</p>
  <div class="site-description" itemprop="description">笔记分享的旮旯孤岛而已</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">143</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="mailto:liewzheng@qq.com" title="E-Mail → mailto:liewzheng@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/27/Linux/Shell/2021-05-27-UnixShell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/27/Linux/Shell/2021-05-27-UnixShell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">UnixShell常用命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-27 23:55:00" itemprop="dateCreated datePublished" datetime="2021-05-27T23:55:00+08:00">2021-05-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-28 00:33:04" itemprop="dateModified" datetime="2021-05-28T00:33:04+08:00">2021-05-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Core-Shell"><a href="#Core-Shell" class="headerlink" title="Core/Shell"></a>Core/Shell</h1><p>首先，要理解Core / shell的概念，系统内核一般被称之为core，而unix及类unix（即与unix类似）系统（如linux）都继承了这一概念，都有其内核。</p>
<p>古早时期，都是一台电脑就是一台服务器，为了提高服务器的利用率，大家都在用很多客户端登录系统，系统分时（电脑高效处理任务，看起来像是同时进行，其实还是存在先后顺序的）为许多客户端提供服务，即“一点对多点”式的服务模式，客户端都通过小黑窗进行操作。</p>
<p>如今，独立PC都已经没了服务器这一概念，一台设备就只为一个客户服务（单点对单点），但是这个小黑窗的高效操作的理念却被保留了下来。</p>
<p>因为所有的客户端对主机的使用都没有进入到内核层面，仅仅停留在表面，所以这种小黑窗的操作层被称为shell层，即外壳。</p>
<p>逐渐衍生了终端的概念，即客户端即用户终端，即terminal；现在shell、terminal、command-line（命令行）这几个概念都可以被视为同一个概念。</p>
<p>但shell的流行，逐渐衍生除了很多个人制作的版本，流行的有bash shell、zsh等。</p>
<h1 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h1><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd zplusplus</span><br></pre></td></tr></table></figure>

<p>即Change directory，改变目录</p>
<p>类unix中没有路径这个概念，只有目录。</p>
<blockquote>
<ul>
<li><p><code>~</code> 主目录，个人目录</p>
</li>
<li><p><code>/</code> 根目录，硬盘目录</p>
</li>
</ul>
</blockquote>
<p>TIPS:</p>
<ul>
<li>按<code>tabs</code>键可以快速补全相符的目录名称</li>
</ul>
<p><code>cd ../</code>可以返回上一层文件目录</p>
<p><img src="https://pic.islet.space/2021/05/image-20210528002003445.png" alt="image-20210528002003445"></p>
<h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir zplusplus</span><br></pre></td></tr></table></figure>

<p>即make directory，创建目录</p>
<p><img src="https://pic.islet.space/2021/05/image-20210528001730316.png" alt="image-20210528001730316"></p>
<h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv zplusplus</span><br></pre></td></tr></table></figure>

<p>即move，移动或删除</p>
<blockquote>
<ul>
<li><code>-f</code> force 强制</li>
</ul>
</blockquote>
<p>也可以用来改名，用法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv main.c test.c</span><br></pre></td></tr></table></figure>



<p>其他类似的语句如 <code>rm</code>，可以参考手册</p>
<h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>即List，（展现）列表</p>
<p>这个命令非常好用，学会了就基本忘不了，各别shell能够提供不同的色彩显示，对于文档类型识别来说非常高效。</p>
<p><img src="https://pic.islet.space/2021/05/image-20210528001701289.png" alt="image-20210528001701289"></p>
<h1 id="文件编辑"><a href="#文件编辑" class="headerlink" title="文件编辑"></a>文件编辑</h1><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim main.c</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：如果已经存在了<code>main.c</code> 他就不会新生成一个，否则就会新建。</p>
<p><strong>操作方法</strong>：</p>
<ol>
<li>刚进去的时候需要按 <code>i</code> 进行插入（insert）操作</li>
<li>编辑完毕之后需要先按 <code>ESC</code> 键，在依次输入 <code>:</code> 及其他指令进行退出，具体参考下方，可以看手册。</li>
</ol>
<blockquote>
<p><code>:</code> instructor 指令输入</p>
<p><code>w</code> wirte</p>
<p><code>q</code> quit</p>
<p><code>!</code> 强制</p>
</blockquote>
<p><strong>编辑界面如下</strong>：</p>
<p><img src="https://pic.islet.space/2021/05/image-20210528002252175.png" alt="image-20210528002252175"></p>
<p><strong>科普视频</strong>：</p>
<iframe src="//player.bilibili.com/player.html?aid=55498503&bvid=BV164411P7tw&cid=97032762&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<p><strong>自行科普</strong>：GUI，Graphic User Interface 图形用户界面</p>
<h1 id="代码运行"><a href="#代码运行" class="headerlink" title="代码运行"></a>代码运行</h1><h2 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c </span><br></pre></td></tr></table></figure>

<p>是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/gnu/671972">GNU</a>下的GCC编译器之一，c的编译器是<code>gcc</code>，c++的编译器是<code>g++</code></p>
<blockquote>
<ul>
<li><code>-o main</code> 参数</li>
</ul>
</blockquote>
<p><img src="https://pic.islet.space/2021/05/image-20210528002708689.png" alt="image-20210528002708689"></p>
<p>编译完成之后使用 <code>ls</code> 可以查看已生成的文件 <code>a.out</code>（默认命名）。</p>
<p><img src="https://pic.islet.space/2021/05/image-20210528002757152.png" alt="image-20210528002757152"></p>
<p>这个 <code>a.out</code> 文件是CPU能够直接识别和运行的文件，因此直接使用以下代码运行即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out</span><br></pre></td></tr></table></figure>

<p>运行效果如下：</p>
<p><img src="https://pic.islet.space/2021/05/image-20210528002900901.png" alt="image-20210528002900901"></p>
<p>遇到问题可以再进行调试。</p>
<p>对GNU和开源的概念可以参考下方视频：</p>
<iframe src="//player.bilibili.com/player.html?aid=413061830&bvid=BV1zV411d7La&cid=186095567&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/25/Hardware/2021-05-25-Type-C-%E6%89%A9%E5%B1%95%E5%99%A8-%E6%96%B9%E6%A1%88%E6%8C%87%E5%8D%97%EF%BC%88DP-Alternative-Mode-%E7%AF%87%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/25/Hardware/2021-05-25-Type-C-%E6%89%A9%E5%B1%95%E5%99%A8-%E6%96%B9%E6%A1%88%E6%8C%87%E5%8D%97%EF%BC%88DP-Alternative-Mode-%E7%AF%87%EF%BC%89/" class="post-title-link" itemprop="url">Type-C 扩展器 方案指南（DP Alternative Mode 篇）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-25 23:30:00" itemprop="dateCreated datePublished" datetime="2021-05-25T23:30:00+08:00">2021-05-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-26 00:08:05" itemprop="dateModified" datetime="2021-05-26T00:08:05+08:00">2021-05-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hardware/" itemprop="url" rel="index"><span itemprop="name">Hardware</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>收藏转载自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/342165494">zhuanlan.zhihu.com</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇还是USB-C 转接器指南贴，由于硬件上的不同，后续还会有一篇雷电专用的指南作为区分</p>
<p>这篇内容其实在2016年的时候就有写的意向了（笑），当时12寸 Macbook 刚推出，Macbook Pro 也刚更新为全Type-C模具。</p>
<p>当时对先进转接器需求最强烈的其实还是12英寸的用户，由于12英寸Macbook  只搭载了一个Type-C，还不是雷电（是的，Mac全系列唯一有Type-C却不是雷电的机型），导致接口丰富兼顾充电的雷电Dock产品无法正常使用，造成了外设和充电你死我活的尴尬境地</p>
<p>所幸戴尔WD15的推出缓解了这个尴尬局面，然而17年之后Macbook 产品线再次被放弃，于此同时市面上类似的单Type-C 模具笔记本极为稀少，后继的Macbook Pro和 Macbook Air 都可以通过  PD充电+DA300的方式满足便携扩展需求，因此 放弃了在便携扩展器领域的进一步探索</p>
<p>然而有趣的是从17年到20年，居然没有一个便携转接器能够在功能参数上全面追赶DA300，甚至有某品牌转接器烧毁Macbook 接口的负面新闻广为流传，抽了闲暇时间做了一定程度的调查，借此机会把目光重新放回了转接器领域</p>
<p>这篇文章依然会是按照我先前的风格，从IC层面对市面上绝大部分的产品进行分类和归纳，从IC层面做出指南</p>
<p><strong>不会对具体的产品进行推荐，适合自己的才是最好的，没空一一了解消费能力和理念，请见谅</strong></p>
<p><strong>本文长达近 一万七千字，由于转接器硬件需求复杂，建议还是通读</strong></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><img src="https://pic.islet.space/2021/05/v2-2cfa4f5dd53c8f74f80203245dca1435_b.jpg" alt="img"></p>
<h1 id="总结与指南"><a href="#总结与指南" class="headerlink" title="总结与指南"></a>总结与指南</h1><p>总的来说转接器产品有两大特点不同于 朴素认知</p>
<ul>
<li>作为转接器的核心部件PD控制器并不影响转接器的主要功能（视频转换和USB、扩展）</li>
<li>转接器接口多寡并不和其 成本 呈正相关 （原本可以给的接口会被阉割，市场内的常见手段），将多种接口整合变少才是本事（就像你用来扩展的Type C口）</li>
</ul>
<p>因此通过接口多寡来计算性价比（价格/接口）基本只能陷入坑货泥潭</p>
<p>下图是目前常见的 支持 DP Alt Mode的控制器总结，由于PD控制器门槛不高，陆续会有MCU厂家涉足该领域，但和主流硬件选用相比不足为提。</p>
<p><img src="https://pic.islet.space/2021/05/v2-b6b31e69d199a7bfcfc997f6c5d87cb6_b.jpg" alt="img"></p>
<p>此外 新款芯片一般至少需要一年的周期才能真正被采用到新产品里面，因此盲目追新 方案大可不必</p>
<hr>
<ul>
<li><strong>推荐</strong></li>
</ul>
<p>尽管各头部厂商 由于历史原因或者其他的一些因素多少都有一些坑货，而下面的白莲花制造商也少之又少，即使是 Belkin 也能找出一些 智商税产品</p>
<p>但是原则上依然推荐 HP，Dell，苹果，微软的新品转接器，这些厂子的转接器不分高端低端，出手即是代表性产品，但也导致开发成本以及最终价格极高</p>
<p>这些头部厂商的产品也会有一个共性的缺点就是不会在自己的产品上集成读卡器功能</p>
<p>其余的，功能和做工就拉不开多少差距了，很难说有完美的，各方面都做的很优秀的产品</p>
<p>总结一下本文提到的带有拆解文章的产品，转接器功能需求复杂，产品或多或少存有不足，仅作参考，长期更新</p>
<p>依然不建议依赖该表，建议通读</p>
<p><img src="https://pic.islet.space/2021/05/v2-8660a99fbe26365d9a3d7488288971f6_b.jpg" alt="img"></p>
<hr>
<ul>
<li><strong>排雷</strong></li>
</ul>
<p>这个市场内显著的坑货有两大类</p>
<p>一类是长得像 Belkin 的 非Belkin 产品</p>
<p><img src="https://pic.islet.space/2021/05/v2-ed0fcb1bc9f15717df5a0549ff865e81_b.jpg" alt="img"></p>
<p><img src="https://pic.islet.space/2021/05/v2-395b6b257e5b4bfba528ae61084b04d9_b.jpg" alt="img"></p>
<p>这类产品一般都是VIA 的VL100系公模产品， 本来做的像样的也有，比如在我的专栏中拆过的Satechi</p>
<p> 但由于对压缩成本的追求，VIA的公版设计被无限压缩，导致市面上一大批的公模VIA产品坑点奇多，下面的雷至少踩两个：</p>
<ul>
<li>质劣价高（物料成本20块左右，直接抄公版设计无需研发成本，防护全无的扩展坞可以卖到150以上，200，300 也是常见）</li>
<li>供电稀烂，带不动一块移动机械硬盘的读写耗电</li>
<li>屏蔽基本无，是一个巨大的2.4Ghz污染源，干扰附近的蓝牙，WIFI设备的正常工作</li>
<li>工厂品控稀烂</li>
</ul>
<p>涉及品牌包括 绿联，Orico，飞利浦（转接器业务已经被别家收购），Unitek，倍思</p>
<p>国内能叫的上名字的配件厂几乎全部中枪，同样是 VL100系主控，没一家的做工和防护能比得上Satechi（苹果合作款）</p>
<p><img src="https://pic.islet.space/2021/05/v2-3dfff693a1575ca58b5c3b089f8c59c5_b.jpg" alt="img"></p>
<p><img src="https://pic.islet.space/2021/05/v2-fd6a19341d4d279adceae25faa1f4837_b.jpg" alt="img"></p>
<p>另一类是长得像苹果的非苹果产品</p>
<p><img src="https://pic.islet.space/2021/05/v2-222af6d53c029fc372a794c438375936_b.jpg" alt="img"></p>
<p>这类产品同样有VIA 阵营的VL100系产品牵涉其中</p>
<p>但在低端攻城掠地的 龙讯LT8711H ，安格 AG9321 同样也籍由这样的外型活得滋润（物料成本估计 10块左右，售价一般在30，40元水平）</p>
<p>此外 Fresco 的 FL5002 公版设计也是籍由这种 外形活得滋润，例如  小米ZJQ01TM[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_1">1]</a> ，联想也是[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_2">2]</a>，尽管TVS防护尚可，但是绝对不会装配 屏蔽罩，另外FL5002 发热较大</p>
<p>还有一类较隐蔽坑货就是自己做标致的外壳，内藏稀烂的硬件</p>
<p>外形就请自行想象了，以下三款图内PCBA的售价都在10元内</p>
<p><img src="https://pic.islet.space/2021/05/v2-59012a67ebb1e0efd1eb6c053219cb6d_b.jpg" alt="img"></p>
<p><img src="https://pic.islet.space/2021/05/v2-17fd6a55704998d450f3a29924a272f2_b.jpg" alt="img"></p>
<p><img src="https://pic.islet.space/2021/05/v2-ceb7df6aa2250a6a365ee70f3d83296d_b.jpg" alt="img"></p>
<h1 id="Q-amp-A扫盲"><a href="#Q-amp-A扫盲" class="headerlink" title="Q&amp;A扫盲"></a>Q&amp;A扫盲</h1><p>Q：为什么转接器标明的可以支持4K 60Hz显示输出，我买了以后不管怎么鼓捣都只能4K 30Hz？</p>
<p>A：这类问题基本是由于转接器  在DP1.4下支持4K 60Hz，在DP1.2 下支持到4K 30Hz，你的Type-C接口只支持到DP1.2 造成了跟描述不同的问题，下文会有详细的原理说明和计算来解释原理和区别</p>
<p>Q：为什么我的转接器插上东西之后，WIFI/蓝牙/无线接收器就卡的不行？</p>
<p>A：老生常谈的问题，由于转接器的电磁屏蔽差劲，导致USB3.0工作时辐射出来的2.4GHz 射频信号[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_3">3]</a>干扰了处于相近频段的无线设备，2.4GHz WIFI，蓝牙，无线接收器都处于这一频道；总之建议更换配件一劳永逸；凑合的办法是用金属箔包住转接器可以减少干扰</p>
<p>Q：这些USB转接器不是都从USB转接而来的吗？据我所知USB3.0只有5Gbps速度，怎么做到输出4K@60Hz的？</p>
<p>A：那种纯靠USB转接视频输出的应用叫做Display Link，已经是比较有年岁的技术了。本篇涉及的主要技术是所谓的 Display Alt Mode，是将DP 信号直接跟USB一起塞到了  Type-C接口里，二者井水不犯河水。DP Alt Mode 借助 Power Delivery 报文[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_4">4]</a>来对Type-C 接口进行具体的配置，平常时Type-C只是一个普通的USB接口，链接特殊的配件可以把 ”可选模式“唤醒， 即 ”Alternative Mode“ ，从而在Type-C中直接引入DP信号输出视频，而不是通过USB转接</p>
<p>Q：为什么要将USB-C 和雷电的转接器做区分呢，二者有什么区别？</p>
<p>A：雷电转接器仅能配合雷电接口正常工作，设备会印有雷电logo，而多功能 USB-C 适配范围要广泛的多，除了雷电接口以外，常规计算机搭载的 多功能Type-C 不仅在Windows或者Mac OS，在Chrome  OS, Ubuntu, RHEL 8都能使用，甚至 苹果 安卓阵营的移动平台（比如iPad Pro 以及 一加7 Pro，三星S7手机等）以及  Switch（注意兼容稀烂），都可以使用相同的硬件设计来完成转接任务</p>
<p>目前最先进的单口Type-C 方案可以支持 单 8K@30Hz或者双4K@60Hz 输出，尽管比 JHL7440雷电方案 的40Gbps  输出能力还是逊色，但是满足日常的使用需求已经完全不成问题，因此这里先从 USB-C转接器进行归类介绍</p>
<p>Q：是否能传输视频信号能充电的Type-C接口就是多功能Type-C？</p>
<p>A：本文的多功能Type-C指狭义的，支持DP Alt Mode 的Type-C 接口（下文会有进阶介绍），包括雷电3雷电4接口也支持这个技术，本文介绍的所有配件都可以在雷电接口上使用。</p>
<p>然而这里有几个盲区，1.除了DP Alt Mode，HDMI Alt Mode[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_5">5]</a>在技术层面上也是存在的，然而没有厂商支持该模式 。 2. 如上文提到过的Display Link  技术可以在通过常规的USB接口（无论Type-A，Type-B，Type-C）传输视频信号，但是需要额外的驱动，在Windows，Mac  OS，Linux，Chrome OS，以及Android 都有广泛的支持，比如目前比较热门的VR头显 Oculus Quest2  用的串流技术即是 Display Link而非高端设备采用的 Alt Mode USB。</p>
<p>此外还有MHL技术以及支持MHL技术的 Alt Mode也可以通过USB 物理接口直接传输视频信号，但基本限于手机应用，而 MHL Alt Mode 同样也没厂商做，所以不提了</p>
<p>Q：那么DP Alt Mode 的 Type-C配件一般是什么样的呢？</p>
<p>A：本次的分类几乎涵盖了所有类别的 非雷电非DisplayLink产品（Display Link 有空也许会在后期也更新进来），Alt Mode 配件和 Display  Link配件的区别在于，Display Link的配件可以在 Type-A接口上正常工作，在系统中需要安装Display Link  驱动（Chrome OS已集成） 才能输出视频信号，而 DP Alt Mode配件不需要驱动就可以外接显示器，但只能在支持的 Type-C  主机接口上运行正常。（咋一看Display Link 确实适用范围更广，但是性能缺陷是绕不开的问题）</p>
<p>涉及的产品主要形态如下：</p>
<p>1.Type C 转换为任意视频接口的单转单线缆</p>
<p><img src="https://pic.islet.space/2021/05/v2-90fca4eddcbd18bb79b5168133732cc6_b.jpg" alt="img"></p>
<p>2.便携型适配器，无论有或没有PD Pass Through 功能，都可以无需外接电源使用</p>
<p><img src="https://pic.islet.space/2021/05/v2-10d2580b3567724941d4a97daacaa186_b.jpg" alt="img"></p>
<ol start="3">
<li>坞站，通常需要大型的外置DC电源支持才能使用</li>
</ol>
<p><img src="https://pic.islet.space/2021/05/v2-430f652dde5f98949f553f875a9dd2f8_b.jpg" alt="img"></p>
<h1 id="前置进阶科普"><a href="#前置进阶科普" class="headerlink" title="前置进阶科普"></a>前置进阶科普</h1><p>这里就不啰嗦接口和协议的区分问题了，直接进入正题</p>
<p>要先了解 全功能Type-C的大致机理，才能了解其配件的运作模式</p>
<p>更进一步地，了解配件功能上限/功能潜力，也能把握未来配件的发展方向</p>
<ul>
<li><strong>DP Alt Mode Type-C性能维度</strong></li>
</ul>
<p>Type-C 的DP Alt Mode 模式被激活后可以维持三大功能同时正常运作，分别是供电、DP传输以及USB 传输，因此本文中Type-C的的性能按照 供电能力、DP输出能力、USB传输能力 这三条作为三维来衡量性能，以下为三维分别的分级：</p>
<p><strong>供电能力</strong>：</p>
<p>由于桌面平台的 多功能Type-C/雷电 不支持电源输入，因此无法与移动平台比较，本文只会罗列参数而不会具体比较</p>
<p><strong>USB 带宽</strong>：</p>
<p>在先前的移动硬盘指南中提及过目前先进的USB协议类型，Type-C Alt Mode 中常见的USB 带宽模式有以下几种</p>
<p>USB3.2 Gen1 （5Gbps）  比如15~17年的12英寸 Macbook，比如华为Matebook 13，14 包括一加 7 Pro 等手机应用</p>
<p>USB3.2 Gen2 （10Gbps） 比如所有计算机搭载的雷电3及雷电4接口，桌面PC 可以使用的UPD2018 DP alt mode Type C扩展卡，Surface Laptop 3 等应用</p>
<p>理论上目前的技术是可以使Alt Mode支持 仅USB2.0 以及USB3.2 Gen2x2 模式的，但并没有实际产品可以参考</p>
<p><strong>视频带宽</strong>：</p>
<p>既然名为DP Alt Mode，那么在激活状态下输出的视频信号则为DP 信号</p>
<p>类似于USB协议，DP协议的迭代也可以提高相同接口下的传输速率</p>
<p>HBR2（DP1.2） 每Lane 5.4Gbps的理论传输速率，由于8b/10b编码，有效带宽为4.32Gbps </p>
<p>HBR3（DP1.3&amp;DP1.4） 每Lane 8.1Gbps [<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_6">6]</a>的理论传输速率，由于8b/10b编码，有效带宽为6.48Gbps</p>
<p>常见显示分辨率所需带宽如下[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_7">7]</a>：</p>
<table>
<thead>
<tr>
<th>分辨率</th>
<th>所需的最小带宽</th>
</tr>
</thead>
<tbody><tr>
<td>1 x FHD (1920 x 1080) 显示屏 @60 Hz</td>
<td>3.2 Gbps</td>
</tr>
<tr>
<td>1 x QHD (2560 x 1440) 显示屏 @60 Hz</td>
<td>5.6 Gbps</td>
</tr>
<tr>
<td>1 x 4K (3840 x 2160) 显示屏 @30 Hz</td>
<td>6.2 Gbps</td>
</tr>
<tr>
<td>1 x 4K (3840 x 2160) 显示屏 @60 Hz</td>
<td>12.5 Gbps</td>
</tr>
</tbody></table>
<p>可以看到，4K@60Hz所需带宽仅需2 Lane 的 HBR3 DP 通道即可满足，而HBR2 则不行。这是买了 支持 4k@60Hz实际却只能30Hz 这个问题的核心所在</p>
<ul>
<li><strong>DP Alt mode 主机口构成</strong></li>
</ul>
<p>多功能Type-C 主机接口本质上只要把USB和DP的线路塞在一个Type-C插头里就可以。但是为了灵活调用和防止Type-C正反插酿成悲剧，在接口屁股上又加了multiplexer（多路复用器，以下简称MUX）[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_8">8]</a>将USB和DP信号的物理线路随心所欲地排布在Type-C接口中，另外也增加了PD控制器用来控制MUX；同时这个控制器可以跟下游的PD控制器沟通，一旦对上暗号，那么两端就可以按照商量好的 DP Alt Mode 来控制MUX拍好输出线路的顺序，这样就可以USB 归USB，DP归DP了。</p>
<p>可以从下图的功能框图看到，MUX和PD控制器的上游，则是主机的USB Host（USB主控）以及 DP Source（DP信号源）， Type-C的性能三维就是由这些上游的应用以及MUX本身的性能所决定的了（MUX走USB和DP信号，会影响这二维的性能）</p>
<p><img src="https://pic.islet.space/2021/05/v2-322b8700e520c9d7f46d2c077d9c675e_b.jpg" alt="img"></p>
<p>举具体的例子</p>
<p>例如USB 带宽方面，12英寸Macbook 之所以只能支持到 5Gbps的USB 3.2 Gen1 传输，是因为上游的USB Host只支持到  5Gbps。而UPD2018 的上游USB Host采用的是 ASM1142，一颗 USB3.2  Gen2主控，因此可以支持到10Gbps，但是Host上游的PCIe带宽只给了PCIe 3.0 X1，因此实际上也是不满10Gbps的</p>
<p><img src="https://pic.islet.space/2021/05/v2-4b2043b71e05f2e51ab65dded0cf3516_b.jpg" alt="img"></p>
<p>DP （视频）带宽方面，很简单粗暴，直接看主机GPU的DP支持就可以了</p>
<p>例如英特尔10代之前的移动端处理器核显仅支持DP1.2（HBR2）输出，因此导致18年19年款的13英寸 Macbook Pro 即使装备了支持DP1.4（HBR3）的Titan Ridge 雷电控制器，由于核显的拖累，依旧只能DP1.2 输出（笑）</p>
<p>MUX支持方面，缺少比较直观的例子，拿雷电设备举例：早期的雷电3设备（Alpine Ridge时期的JHL/DSL6x40 系列）由于只支持 DP1.2 的信号源，在触发为DP Alt Mode之后也是只支持DP 1.2  输出；USB 也会受制于MUX ，比如 普瑞科技 的 PS8743 和 PS8750 作为母口端的MUX只支持USB3.2 Gen1 以及  HBR2 [<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_9">9]</a></p>
<ul>
<li><strong>DP Alt mode 设备口构成</strong></li>
</ul>
<p>如下图所示[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_8">8]</a>总体来说跟主机口没什么区别，也还是 PD 控制器加上 MUX的形式，区别只在于这里的MUX是解复用功能</p>
<p><img src="https://pic.islet.space/2021/05/v2-9ced86eb508a76eefd11c9ffaeec4aa4_b.jpg" alt="img"></p>
<p>但是，但是啊，我们已经拆过不少 Type-C转接器了，这些转接器里面 除了 DockCase DPR01S （DeMUX为PS8822）以外，<strong>为什么只有PD控制器而没有MUX？！</strong>这不是跟指导文档背道而驰吗</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1326635507015319552">先进型 Type-C 扩展设备拆解存档</a></p>
<p><img src="https://pic.islet.space/2021/05/v2-b6546a28845e426a25b971ce7fcab919_ipico.jpg" alt="图标"></p>
<p>但其实文档介绍的是基于完整的 Type-C 接口所设计的结构，即设备端是具有完整的Type-C接口，需要独立的线缆进行连接的情况</p>
<p><img src="https://pic.islet.space/2021/05/v2-88b4440cae89d86b165ebdf938fee0ca_b.jpg" alt="img"></p>
<p>在常规情况下，如果采用的是尿袋式的设计,比如下面这种Type-C 定义直接焊死而不是给一个Type-C 口随意插，那么在设计时就不需要 MUX来应对Type-C正反插情况了，在Cypress的指导中也有提及[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_10">10]</a></p>
<blockquote>
<p> If you are using type-C receptacle and plug combination you will not  need a switch. If you have both USB-C connectors as receptacles,  connected via a type-C cable (EMCA) then you will require a switch.<br>DP source (FPGA) &lt;—-&gt;Switch&lt;——&gt; USB-C receptacle  &lt;———————&gt; USB-C plug &lt;——&gt; DP sink (FPGA)<br>otherwise,<br>DP source (FPGA) &lt;—–&gt; Switch &lt;—–&gt; USB-C receptacle  &lt;———- USB-C cable ———-&gt; USB-C receptacle &lt;—–&gt; Switch &lt;—–&gt; DP sink (FPGA)</p>
</blockquote>
<p><img src="https://pic.islet.space/2021/05/v2-26ab46bc6d083bd1a166199a4080a03e_b.jpg" alt="img"></p>
<p>当然，设备端的MUX也会影响最终性能，就如水路一样，最后的出水速度是受到整条链路上所有环节的影响的</p>
<p>经过了设备端的解复用之后，留给下游的又是简单纯粹的 USB 协议口和 DP 协议口（USB2.0 和 DP的 Configuration 通道仍需要  PD控制器转发来保证正常功能），在原先开发的各种USB 玩法 以及 DP玩法 可以直接捡起来套上去，不得不说这样的Type-C  开发出来对原先的硬件环境十分友好，和先前仅有的区别是，原本井水不犯河水的 USB 和DP 配件，如今由于 DP Alt  Mode的存在被整合到一块电路板上了。</p>
<p>当然，遗憾也是有的，由于对广大的兼容性（免驱）考虑，很多应用难以得到推广</p>
<p>比如转 4G无线网卡的应用</p>
<p><img src="https://pic.islet.space/2021/05/v2-8f57bae7c539aade5bd5e273dce8664d_b.jpg" alt="img"></p>
<p>另外也是出于成本的考虑以及对 苹果模式的一味模仿，尿袋式的转接器设计依然大行其道。好好设计一个线缆收纳很难吗？</p>
<ul>
<li><strong>USB与DP 进阶硬件认识</strong></li>
</ul>
<p>在硬件上将 PD 控制器和 MUX 融入 Type-C以后，事实上 Type-C就可以被凹成各种形状了，但主流 的模式其实就两种（按性能分为两种，实际VESA对应定义了6种[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_4">4]</a>）</p>
<p>首先我们需要对 USB 和 DP 有 基本的硬件认知</p>
<p>目前的信号传输依然主要依靠铜线缆，差分对则是经典的用于铜缆系统的抗干扰硬件设计[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_11">11]</a></p>
<p>简单的来说，我们使用两根线来传输一个信号，即一个差分对一个传输通道</p>
<p>在USB3.2 Gen1和Gen2 中，他们使用一组两个差分对四根线分别实现 5Gbps 和 10Gbps 的收发活动即SSTX 差分对和SSRX 差分对</p>
<p>R→Receive 收</p>
<p>T→Transmit 发</p>
<p>因此在USB中 一组收发 可以实现 10Gbps的 双向传输，USB3.2 Gen2x2可以启用两组共四对信号，因此可以实现 20Gbps  双向传输（是的，Gen2不需要D+D-来传输，Gen2 跟 Gen2x2 只是量变，Gen1 到 Gen2 才是质变，而只使用D+D-  的USB2.0则跟USB3.0可以算是两个物种了）</p>
<p><img src="https://pic.islet.space/2021/05/v2-393f880610f4e5cd987f606c436ae1ee_b.jpg" alt="img"></p>
<p>一个完整的DP接口同样含有4对主要连接差分对，Mian Link Lane 0~3 (以下简称ML）</p>
<p>在HBR2下可以完成 每Lane 5.4Gbps的单向传输，HBR3下则是8.1Gbps</p>
<p>除此之外，DP接口还内置了Configuration 1&amp;2 用于协议配置，Auxiliary Channel +&amp;- （以下简称Aux对）用于音频传输，有趣的是，DP同样可以在仅 ML0，ML1 两条Lane的模式下工作</p>
<p><img src="https://pic.islet.space/2021/05/v2-c339e6274c4434320a960af7ddb4e3e9_b.jpg" alt="img"></p>
<p>那么，把USB 限制在 2对差分模式，DP也限制在2对差分模式，可以拼在一起吗？</p>
<ul>
<li><strong>DP Alt Mode 主要模式</strong></li>
</ul>
<p>答案是肯定的</p>
<p>用于通讯握手的PD协议必须占用一条 Configuration Channel（以下简称CC），电源线和接地定义也不能动，不过剩下的也足够其他协议分的了</p>
<p>常规情况 USB 模式时 Type-C 的针脚分布如下</p>
<p><img src="https://pic.islet.space/2021/05/v2-bb880cb32b70197fb69aa5e48e7c759a_b.jpg" alt="img"></p>
<p>当激活 DP Alt Mode 2Lane （Multi-Function DisplayPort,MFDP) 时，针脚功能如下</p>
<p><img src="https://pic.islet.space/2021/05/v2-9d8fe2b6caf88d296c112dd79dbfcb7f_b.jpg" alt="img"></p>
<p>当激活成 DP Alt Mode 4Lane 时：</p>
<p><img src="https://pic.islet.space/2021/05/v2-bffd5ba676c6ec65ec536294f20c4311_b.jpg" alt="img"></p>
<p>有没有觉得USB2.0 由于正反插支持占用了4个针脚，只有两个有效，而且480Mbps这么孱弱的速度塞进Type-C实在是丢人？</p>
<p>如果把USB2.0的针脚设定为USB3.2 Gen1或者Gen2 就好了，这样的模式也是有的，被称为Virtual Link，是为VR应用所开发的，Nvidia 的2000系 和AMD 的6000系显卡所搭载的Type-C 就支持该模式[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_12">12]</a></p>
<p><img src="https://pic.islet.space/2021/05/v2-18ecc3a36f700f8677e5990b3aa7fa8e_b.jpg" alt="img"></p>
<p>注意了，此模式不在 DP Alt Mode的范畴，常规设备是不支持也触发不了这个模式的。这个模式抛弃了USB2.0 链路导致该状态下是无法正常支持键鼠之类的应用。当然，作为专机专用模式也不用在意这种问题了</p>
<p>在Virtual Link 模式下，Type-C和常规 Type-C线缆可以达到非雷电模式下的最高速度，高达4*8.1+10=<strong>42.4Gbps的输出带宽外加10Gbps的数据接收带宽</strong>，尽管相比标称<strong>双向40Gbps</strong>的雷电3和雷电4仍然有显著差距，但是满足绝大部分应用是完全不成问题的了。</p>
<ul>
<li><strong>如何触发 DP Alt Mode</strong></li>
</ul>
<p>如上文提到的， 不管是DP Alt Mode 还是上面提到的 Virtual Link，抑或是雷电，都是作为Alt Mode 触发的，而触发方式，都是通过Power Delivery 的通信功能</p>
<p><img src="https://pic.islet.space/2021/05/v2-4945c8109a8ac189e840096ceec01824_b.jpg" alt="img"></p>
<p>Type-C Alt Mode 大致配置流程如下：</p>
<ol>
<li>USB 连接 通过CC侦测到</li>
<li>VBUS 引脚 提供默认电源配置 5V@500mA</li>
<li>VBUS 所需的额外USB电力传输可以进行协商，Battery Charge 1.2（BC 1.2）或USB PD 都可以选择</li>
<li>使用 结构化 供应商定义报文（VDM） 需要USB PD 来发送来协商 Alt Mode 握手</li>
<li>USB 枚举</li>
<li>如果 DP Alt Mode 协商已经完成，继续进行DP link training来建立DP连接</li>
<li>USB和DP频道准备就绪进行Type-C 数据和视频信号传输。</li>
</ol>
<p>更具体的 PD 报文内容和触发逻辑不是本篇重点，想具体了解的推荐TI的文档或者去VESA翻更具体的资料</p>
<p><a href="https://link.zhihu.com/?target=https://www.ti.com/lit/an/slva844b/slva844b.pdf?ts=1614791986776&ref_url=https%253A%252F%252Fwww.ti.com%252Fsitesearch%252Fdocs%252Funiversalsearch.tsp%253FsearchTerm%253DAlternate+Mode+Support">PD Alternate Mode: DisplayPort</a></p>
<p><a href="https://link.zhihu.com/?target=https://www.ti.com/lit/an/slva844b/slva844b.pdf?ts=1614791986776&ref_url=https%253A%252F%252Fwww.ti.com%252Fsitesearch%252Fdocs%252Funiversalsearch.tsp%253FsearchTerm%253DAlternate+Mode+Support">www.ti.com</a></p>
<h1 id="产品实现"><a href="#产品实现" class="headerlink" title="产品实现"></a>产品实现</h1><p>了解了 DP Alt Mode Type-C 的原理那么就可以观察他是怎么在产品上实现的了</p>
<ul>
<li><strong>典型 2Lane DP Alt Mode + DP1.2 产品拓补</strong></li>
</ul>
<p>直接用在国内销量极大的Type-C 转接器方案 VL100 系列所为案例了</p>
<p>这是一个典型的VL103 转接器拓补，黄色 USB-C 为链接主机的上游接口，兰绿色为充放电专用的下游Type-C，典型应用可以参照Satechi 的多口Type-C转接器[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_13">13]</a></p>
<p><img src="https://pic.islet.space/2021/05/v2-60d85aec0bf111a1b96a72244a2f5400_b.jpg" alt="img"></p>
<p><img src="https://pic.islet.space/2021/05/v2-cfaeb19dc5eb541b350a0c6fa38a0926_b.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/v2-0941dac75faafcaddc4997a371b05f25_b.jpg" alt="img"></p>
<p>在这个应用中，VL103就是作为PD 控制器，负责下游Type-C 的PD和QC等协议的调度（因此充电Type-C口会有USB2.0定义用于握手，但其实不能挂载USB设备）</p>
<p>同时VL103作为PD控制器也负责DP Alt Mode的调度，但VL103完全不干预USB3.0 和DP 链路的走线，直接连接USB Hub芯片VL817 和 DP to HDMI芯片PS176，而读卡器芯片则是挂在VL817下游，提供了两个读卡器口。</p>
<p>此外，作为固定尿袋外形的转接器，这个拓补方案不需要MUX芯片</p>
<p>需要注意的是，这类典型应用需要兼顾USB3.0接口，因此只能选择 2 Lane DP Alt Mode 模式，，再加上PS176只能支持DP1.2的问题，导致转出的HDMI接口同样只能支持到 2Lane DP1.2的支持上限 4K 30Hz</p>
<p>相似类型的还有采用 Fresco FL7102 PD控制器为主控的绿联功能扩展坞（带SD卡槽版）[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_14">14]</a></p>
<p><img src="https://pic.islet.space/2021/05/v2-ef2d0e97afef9b1a26d267dd741d1faf_b.jpg" alt="img"></p>
<p>硬件拓补和上面的Satechi 基本相同，但又有略微的区别</p>
<p>阳联 IT6564 对应 上个产品中的PS176，但 IT6564 可以将DP1.2 转换为 VGA和 HDMI两个输出（又是只支持 2Lane 的 DP1.2 输入，导致HDMI只能4k 30Hz输出。在绿联 CM260中 IT6564 可以获得 满血 4Lane DP1.2 输入  因此可以支持 4K 60Hz HDMI输出）</p>
<p>在本应用中有 3<em>Type-A+ 一套转接器+网口共5个数据口，而常规USB3.0  hub 只能将一个USB扩展为 4个下游 USB，因此本应用中  套了两层GL3510（一个GL3510套在另一个下游，提供了共2</em>4-1=7个有效USB3.0接口）  一个被RTL8153B转为千兆网口，还有一个被GL224 转换为一套读卡器，有5个剩余USB下游口但只有3个被做出来，有两个被浪费了（笑）</p>
<p>本应用中同样为了确保下游USB3.0 功能只能选择 2 Lane DP Alt Mode 触发，再由于IT6564只能支持DP1.2，因此HDMI还是只能支持到4k 30Hz</p>
<p>使用该类型拓补的转接器是过去几年中的销售主力，兼顾USB3.x应用与4K 30Hz输出的转接器或者坞站基本都是这类结构，举几个常见的</p>
<ol>
<li>华为MateDock 2[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_15">15]</a></li>
<li>米物 Type-C 七合一多功能转接器 MWCMA01[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_16">16]</a> </li>
<li>惠普HP USB-C to Multi-Port Hub USB-C多端口集线器[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_17">17]</a></li>
<li>ROG Phone (ZS600KL) ASUS Professional Dock[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_18">18]</a></li>
<li>小米 ZJQ01TM  USB-C至HDMI多功能转接器[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_1">1]</a></li>
</ol>
<ul>
<li><strong>典型 2Lane DP Alt Mode + DP1.4（HBR3）产品拓补</strong></li>
</ul>
<p>DP1.2这么菜，导致 2 Lane DP模式只能支持输出4K 30Hz，那么我们引进DP1.4就能支持更高的带宽和分辨率了</p>
<p>比如说DockCase DPR01S 支持到4K 60Hz 和 USB3.0应用共存[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_19">19]</a></p>
<p><img src="https://pic.islet.space/2021/05/v2-c14f66052bca51b903261fa9ca68be02_b.jpg" alt="img"></p>
<p>这里采用的PD控制器FL7112是绿联系列采用的FL7102的后继型号，此外由于搭载了完整的正反插Type-C，使用了 PS882 MUX芯片进行支持； 总体结构和上文的 FL7102 转接器差别不大，但是从MUX到 DP转换器都 选用了支持  DP1.4（HBR3）的型号，PS176 换成了 PS186 用以支持将  2Lane  DP1.4 转换为 HDMI 1.4，从而支持4K  60 Hz 输出，当然，前提是主机的Type-C也支持 DP1.4 输出</p>
<p>该类型的转接器同样已经很比较普遍了，目前市面上既支持USB3.x 扩展又支持到4K 60Hz的转接器基本都是这个类型的拓补应用，举一些常见的例子</p>
<ol>
<li>戴尔DA300[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_20">20]</a></li>
<li>戴尔DA310[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_21">21]</a></li>
<li>苹果 A2119[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_22">22]</a></li>
</ol>
<ul>
<li><strong>典型4 Lane DP Alt Mode 产品拓补</strong></li>
</ul>
<p>上面两类拓补都是由于保证USB 3.0/USB3.2 Gen2 应用，导致被迫选择 2Lane DP模式，在只能支持DP1.2 的情境下极大限制了  视频传输的带宽，即使转接器支持到 HBR3，也由于大量主机只支持DP1.2 输出（比如雷电接口只能核显输出）导致最终只能被多功能转接器锁在4K  30Hz，因此在 Type-C HBR3 输出尚未普及的时候，选择4Lane DP Alt Mode 比升级到 HBR3 更明智一些</p>
<p>于是大量的 4 Lane Mode专注于视频转接的线缆型单对单设备应运而生，比如 Nvidia USB-C to DisplayPort Adapter[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_23">23]</a></p>
<p><img src="https://pic.islet.space/2021/05/v2-3814f250fd70c1e0171891cc398e0732_b.jpg" alt="img"></p>
<p><img src="https://pic.islet.space/2021/05/v2-b8485a62056f17a0e3b787a1c9bfc669_b.jpg" alt="img"></p>
<p><img src="https://pic.islet.space/2021/05/v2-ad3301d173bce644fc40e11de4b3ab82_b.jpg" alt="img"></p>
<p><img src="https://pic.islet.space/2021/05/v2-420fcfeb486e5c98d986324eab578b78_b.jpg" alt="img"></p>
<p>该配件全机仅有一个功能性配件，即VL103，与上文的Satechi 配件采用的PD主控是一样的， 但在这里被配置为触发的4Lane 模式，可以清晰地看到有四对差分线的走线从上游线直通DP  接口，即ML0~ML3，PD控制器仅负责对DP Alt Mode的触发，完全不干涉DP信号自身；理论上这款线缆在HBR3支持下是可以支持8K  30Hz的输出能力的</p>
<p>在这样的4Lane 触发基础上加上DP信号转换即可以制作成各式各样的Type-C 转视频接口线，例如华为的CP76，Type-C转HDMI线缆[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_24">24]</a></p>
<p><img src="https://pic.islet.space/2021/05/v2-ad8aeafa0ce502ef34f2df340be10e82_b.jpg" alt="img"></p>
<p>采用的，其实还是 VL103 + PS176 的硬件组合，与上文的 Satechi 主体相同，VL103 同样被设置为触发 4Lane 模式，PS176  即使只支持 DP1.2，也凭借着翻倍的带宽支持到了4K 60Hz，发挥了Type-C口完整的 DP输出能力，然而代价是牺牲掉了USB 3.0应用</p>
<p>如果将PS176更换为PS186 设计，支持HBR3 的DP转换，那么HDMI的输出分辨率支持就能高达8K 30Hz了</p>
<p><img src="https://pic.islet.space/2021/05/v2-e8c09344ceb408b843341959ba4e46ff_b.jpg" alt="img"></p>
<p><img src="https://pic.islet.space/2021/05/v2-a99ad2572163711133df31bee162ac7c_b.jpg" alt="img"></p>
<p>然而 4 Lane DP Alt Mode 相对于 2Lane 模式仅仅是牺牲了 USB3.x 的支持，照理来说USB2.0 和PD 功能依然健在，做出跟常规转接器形态一致的设备并不是难事。</p>
<p>确实如此，只不过比较稀少，比如小米的 Type-C 转 Mini DP设备[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_25">25]</a></p>
<p><img src="https://pic.islet.space/2021/05/v2-deec7db196937f5b5fc1759901fe7c45_b.jpg" alt="img"></p>
<p>PD控制器采用的是FL7102，可以清晰地看到4对 差分线地走线从Type-C直奔 下游的Mini DP，尽管USB Hub采用的是支持USB3.2 gen1  的FL5000，但上游的走线只给了USB2.0的D+D-定义，因此两个扩展的USB接口被迫限制在在USB2.0模式；此外装备了PD输入口，也算功能齐全了。这款转接器理论上在HBR3支持下也是可以支持到8K分辨率输出，只不过 mini DP的走线过长，抗干扰能力能否满足要求就不得而知了。</p>
<p>目前市面上销售的 Type-C  转单视频口输出的应用可以说全都是应用了这个类型的结构，但是目前依然以支持到DP1.2  转换的为主流，支持到HBR3转换的较少（支持HBR3/DP1.4仍然可以向下兼容HBR2/DP1.2转换，图省事直接购买高规格的即可），支持4Lane 转换的多口转接器除上文提到的以外可以再举几个例子：</p>
<ol>
<li>戴尔 USB-C 转 HDMI/DP 适配器[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_26">26]</a></li>
</ol>
<ul>
<li><strong>可切换带宽型拓补</strong></li>
</ul>
<p>那么，既然4Lane 2Lane各有好处，我用什么的时候切什么不好么，再加上HBR3支持，那岂不是香的不行？</p>
<p>其实也是有的，但是非常稀少。翻阅VL102，VL103的文档时，VIA Tech已经给出了实现该功能的拓补（同时也给出了将USB与充电C口融合的参考，然而做的厂家也非常稀少）</p>
<p><img src="https://pic.islet.space/2021/05/v2-5e04ecfc898b01b77a6d97e6a229cefe_b.jpg" alt="img"></p>
<p>可以看到相对于上文的拓补，本案例中多出来了类似MUX的芯片VL170，该芯片就是可以用于把设备在2 Lane 与 4Lane 模式之间来回切换的关键</p>
<p><img src="https://pic.islet.space/2021/05/v2-d606ef4c0362b25a358b2b3839fd7374_b.jpg" alt="img"></p>
<p>感谢  提供的机型线索</p>
<p>这类拓补的应用实物之一就是  Startech DK30C2DAGPD， 很遗憾这里就没有拆解参考了</p>
<p><img src="https://pic.islet.space/2021/05/v2-fa87401c31ca6f3bb52ffc4074495a42_b.jpg" alt="img"></p>
<p><img src="https://pic.islet.space/2021/05/v2-5a82fd7b9e0bfee74b9d7389a32adada_b.jpg" alt="img"></p>
<p><img src="https://pic.islet.space/2021/05/v2-0618d8ef8ed93e037e5b90c79d68d207_b.jpg" alt="img"></p>
<p>根据 Startach 本身提供的信息来看，采用的主要IC如下</p>
<p>VIA/VLI - VL102</p>
<p>VIA/VLI - VL170</p>
<p>VIA/VLI - VL817</p>
<p>MegaChips - STDP4320</p>
<p>RealTek - RTL8153</p>
<p>负责视频输出的 STDP4320 支持双DP++输出，只是可惜作为 仅支持DP1.2 输入的方案，最高也就支持到 单口4K 60Hz 或者双 4K 30Hz 输出了</p>
<blockquote>
<p> Dual DisplayPort displays: Up to 4096 x 2160p @ 24Hz or 3840 x 2160p @ 30Hz<br>Single DisplayPort display: Up to 4096 x 2160p @ 60Hz or 3840 x 2160p @ 60Hz</p>
</blockquote>
<p>此外还有 Kensington 的 SD4820P USB-C 10Gbps Dual Video Driverless Docking Station 可惜这次连使用的芯片信息都没有了</p>
<p><img src="https://pic.islet.space/2021/05/v2-1b2d7f13dfb8a4de886cca67fd4e364d_b.jpg" alt="img"></p>
<p><img src="https://pic.islet.space/2021/05/v2-f3d06ce5afcd1135c490f6255cf345dc_b.jpg" alt="img"></p>
<p>但是根据Kensington 的手册介绍，扩展坞在4 Lane Mode 下支持单 4k 60Hz 或者 双 4K 30Hz 输出，似乎也不支持 HBR3 应用，甚是可惜</p>
<p><img src="https://pic.islet.space/2021/05/v2-c2503d9d9a6546e221326150a10394aa_b.jpg" alt="img"></p>
<p>除以上两例以外，目前暂时找不到更多类似拓补了，因此举不了更多实例了</p>
<ul>
<li><strong>再复用接口 拓补</strong> </li>
</ul>
<p>还记得我们在起初的时候对  DP Alt Mode 主机口的认识吗</p>
<p>多功能Type-C 主机口只要上游有 完整的USB通道和DP 信号源就可以以添加 PD控制器和MUX的方式组建了 </p>
<p>那么在经过设备的 Type-C 端口，Type C 传输信号被重新分解为 DP 与 USB之后，可以将USB信号复制之后再次和 DP信号 结合成 DP Alt Mode Type-C吗</p>
<p><img src="https://pic3.zhimg.com/v2-8580acd1b17f56740c1f1745be4fa78a_b.jpg" alt="img"></p>
<p>答案依然是肯定的，DA310 就通过 增加 MUX 芯片的方式 在 Type-C 扩展器里实现了信号的重新结合，为下游提供了一个 多功能Type-C[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_21">21]</a></p>
<p>然而美中不足的是该接口似乎吃了 2Lane 和 HBR2 两个DeBuff，最高只能支持到 4K 30hz 输出，装备了 支持 HBR3 的主机端MUX 芯片 PS8802 后表现这么拉跨只能说比较遗憾了</p>
<p><img src="https://pic.islet.space/2021/05/v2-68bd1cc3e9713d420baa55432e7d7e45_b.jpg" alt="img"></p>
<p>但这些缺陷在戴尔的新 WD19DCS中都被解决了</p>
<p>代价是连接主机的一个上游端口变为两根</p>
<p><img src="https://pic.islet.space/2021/05/v2-7d4014fd7cafa7c5d1cc6a92c0249ef4_b.jpg" alt="img"></p>
<p><img src="https://pic.islet.space/2021/05/v2-0230b0e5f9fddf62bffb4cb17f0af7f4_b.jpg" alt="img"></p>
<p>单Type-C口可以支持到 8K 30Hz输出，显然是完成了4Lane HBR3 的支持，然而没有 拆解图观察还是比较可惜的。</p>
<h1 id="硬件选用"><a href="#硬件选用" class="headerlink" title="硬件选用"></a>硬件选用</h1><ul>
<li><strong>PD控制器概览</strong></li>
</ul>
<p>上文介绍的案例都是采用的专用PD控制器</p>
<p>作为转接器核心部件的PD控制器其实门槛并不高，常规的MCU即可实现PD控制器的功能</p>
<p>例如 STM 就基于自家的STM32F072 推出了STEVAL-USBC2DP 配件，希望能从 Type-C市场分一杯羹，上文提过的惠普HP USB-C to Multi-Port Hub USB-C多端口集线器[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_17">17]</a> 也是用的这个主控</p>
<p><img src="https://pic.islet.space/2021/05/v2-775a929a96ed14fb25ac2f3a15c7b555_b.jpg" alt="img"></p>
<p>然而非专用化的设计必然在外部电路复杂度，功能开发，成本上处于弱势，因此使用这类主控的产品还是风毛菱角</p>
<p>但是PD控制器只能做PD 控制器吗？跟USB Hub 甚至 视频转换 做在一起不行吗？</p>
<p>可以的，也是有产品的</p>
<p>比如 Fresco 的 FL5002 即是 PD控制器 + USB 3.0集线器 （小米，联想有成品，皆是公版仿苹果A2119外形）</p>
<p>Genesys Logic 的GL3510 也是 PD控制器+USB3.0 集线器（米物 转接器）</p>
<p>更进一步的比如 龙讯 LT8711H，安格 AG9321 ，一颗芯片就可完成视频转换，PD充电 的功能</p>
<p><img src="https://pic.islet.space/2021/05/v2-7ea776cc7b2541fa2b06a28b6ee53b17_b.jpg" alt="img"></p>
<ul>
<li><strong>主控产品格局</strong></li>
</ul>
<p>介绍一下主控在Type-C 转接器市场中的主要IC和格局</p>
<p><a href="https://link.zhihu.com/?target=https://docs.qq.com/sheet/DWmZoUFJpTmVXRkVa">腾讯文档</a></p>
<p><a href="https://link.zhihu.com/?target=https://docs.qq.com/sheet/DWmZoUFJpTmVXRkVa">docs.qq.com</a></p>
<p><img src="https://pic.islet.space/2021/05/v2-1e8f184208cc70de95edd04e901f402c_b.jpg" alt="img"></p>
<p>Texas Instrument 我想EE背景的同学就算没用过应该也都听说过，它对电源，信号类的应用市场有着统治级的影响力，其 产品和企业价值观 对全球的 EE 领域从业者都有着深远影响；各位如果拆开自己的笔记本，九成九都可以在主板上发现 TI的芯片。 </p>
<p>Cypress 不像 Texas Instrument 那么巨无霸，但在消费电子领域也是巨头，为各类应用都提供了可靠高效的解决方案</p>
<p>这两家巨头 所提供的IC 基本代表了 Type-C 转接设备的顶级产品方案（不止DP Alt Mode，雷电也是）作为头部计算机制造商 HP，Dell  甚至 微软，Apple 的产品使用的都是来自这两大巨头的主控，唯一的遗憾可能就是 TI的主控至今都没有支持 PD Pass  through的产品，只有 DC供电的坞站形态或者无供电转接器形态</p>
<p>比如</p>
<p>Dell DA300[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_20">20]</a> （TPS65988 ，Texas Instrument）</p>
<p>Dell DA310[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_21">21]</a>  （CYPD4226+CY7C65219，Cypress）</p>
<p>Dell WD15 （TPS65982，Texas Instruments）</p>
<p>戴尔 USB-C 转 HDMI/DP 适配器[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_26">26]</a>（CYPD4226+CY7C65219，Cypress）</p>
<p>Surface Dock2[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_27">27]</a> （非Type-C 配件，TPS65988，Texas Instrument）</p>
<p> Apple A2119[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_22">22]</a> （CYPD5225+CY7C65211，Cypress）</p>
<p>中高端&amp;中端：Parade/Fresco</p>
<p>Fresco 已经被Parade 收购，两家的产品也完成了进一步的整合，目前的第三方新转接器产品基本都使用的该公司主控，并且整体设计方案和防护设计基本都到位，目前综合价格和性能来看还是比较理想的选择</p>
<p>中端：Genesys Logic</p>
<p>因为这家厂子隐藏自家产品资料并且广签NDA导致可获得的资料极少</p>
<p>产品还可以但真正使用Genesys 作为核心设计的产品并不多，基本是以 USB Hub 主控活跃在各家转接器上（苹果与微软的转接器都有用到）</p>
<p>中端&amp;中低端：VIA Tech</p>
<p>VIA算是我们的老朋友了，VIA与国内的第三方厂商联系甚密，产品特点是下限有一定保证，但基本没有再次开发的空间（下限可以且上下限差距极小）</p>
<p>低端：Lontium（龙讯），Algoltek（安格）</p>
<p>虽然两家的 LT8711H 以及 AG9321 公版设计 就是奔着缩成本去的简陋和稀烂，但是低价产品对市场带来的冲击是巨大的。</p>
<p>国内30+元，海外4.5USD，为上述中端产品的生存带来了巨大的压力</p>
<ul>
<li><strong>常见下级视频类应用</strong></li>
</ul>
<p>在上文所举例的应用中，我们已经可以看到一些转换器常见的转换应用，比如PS176，PS186，都是基于DP输出的单对单视频转换，由于苹果的采用才在第三方转接器中风行开来</p>
<p>单对单转换的意思是…….. 单入单出，那么单个DP输入像USB分线器那样扩展成多屏应用可以吗</p>
<p>也可以的，使用的技术主要是 DP MST （DP菊花链）根据所设置的分辨率（占用带宽）决定显示器扩展数量的上限，分配比例灵活，可以独立设置每个屏幕，但下游的单个显示器也有带宽限制</p>
<p>这里由于转换类型和应用太多所以暂时不做表了</p>
<ul>
<li><strong>可靠外围设计示例</strong></li>
</ul>
<p>由于转接器使用环境复杂，比如：</p>
<ul>
<li>大功耗外围（USB等）设备需要电源设计来保证供电，亦需要应对过流等预期外情况设计保险</li>
<li>信号线本身工作时载有高频跳变的电压，可以将线路当作天线辐射出射频信号，会干扰周围无线设备或被外界干扰，因此也需要无线屏蔽/隔断设计</li>
<li>人体（或其他物体）触摸转接器时可能带有高水平的电荷（静电）从而造成放电现象，放电过程会有极高可能性损坏转接器芯片，甚至损坏连接的主机接口</li>
</ul>
<p>这些情景却并不是单靠上文提到过的芯片本身的设计指南所能搞定的，需要PCB设计，相关安全器件和设计，产品设计一同来保障</p>
<p>第一点一般会有专用的器件来搞定，比如在DA310 中内置的 TPS2554 作为电流保险</p>
<p><img src="https://pic3.zhimg.com/v2-fd1fddbd162751ea3a0260a9d2519202_b.jpg" alt="img"></p>
<p>第二点一般利用法拉第笼的原理在转接器外围造一层金属罩进行无线屏蔽</p>
<p><img src="https://pic.islet.space/2021/05/v2-68a8b3984897e0937f3446f56b255dea_b.jpg" alt="img"></p>
<p><img src="https://pic.islet.space/2021/05/v2-e4e71c2210d763b837b9cee71ee442e5_b.jpg" alt="img"></p>
<p>第三点则较为复杂，尽管目前多数IC都会内置 ESD （electrical state discharge）防护，然而并不能确保芯片可以在较恶劣的环境下存活下来，因此外挂各种防护措施还是有价值的，毕竟要是把主机口也挂了那麻烦就大了</p>
<p>其中TVS管就是最常用的方式</p>
<p><img src="https://pic.islet.space/2021/05/v2-0cb4401a831b61646eaed46f15b20eca_b.jpg" alt="img"></p>
<p>其他的防护措施这里就不一一介绍了，可以参考该文 <a href="https://link.zhihu.com/?target=https://acroname.com/blog/industrial-usb-hub-teardown-esd-robustness">INDUSTRIAL USB HUB TEARDOWN: ESD ROBUSTNESS</a> 仅作参考，该文是较为典型的过分堆料</p>
<p><img src="https://pic.islet.space/2021/05/v2-98c67086b6a85d7b4014e261e778443e_b.jpg" alt="img"></p>
<p>一般情况下只要做到像TI参考设计的程度就足够了，即 使用TVS管作为ESD防护以及电源总线上附带过流保险</p>
<p><img src="https://pic.islet.space/2021/05/v2-f402b8767c2e6bbfdb96f8a06921c8b3_b.jpg" alt="img"></p>
<p><img src="https://pic.islet.space/2021/05/v2-c79f4ee4605017330e342cd9edb71679_b.jpg" alt="img"></p>
<p>此外，PCB的走线也会影响 ESD效果以及对外的无线干扰辐射[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_28">28]</a>，总之转接器PCB做工是一件比较复杂的考量事项。</p>
<h1 id="总结与指南-1"><a href="#总结与指南-1" class="headerlink" title="总结与指南"></a>总结与指南</h1><p>总的来说转接器产品有两大特点不同于 朴素认知</p>
<ul>
<li>作为转接器的核心部件PD控制器并不影响转接器的主要功能（视频转换和USB、扩展）</li>
<li>转接器接口多寡并不和其 成本 呈正相关 （原本可以给的接口会被阉割，市场内的常见手段），将多种接口整合变少才是本事（就像你用来扩展的Type C口）</li>
</ul>
<p>因此通过接口多寡来计算性价比（价格/接口）基本只能陷入坑货泥潭</p>
<p>此外 新款芯片一般至少需要一年的周期才能真正被采用到新产品里面，因此盲目追新 方案大可不必</p>
<hr>
<ul>
<li><strong>推荐</strong></li>
</ul>
<p>尽管各头部厂商 由于历史原因或者其他的一些因素多少都有一些坑货，而下面的白莲花制造商也少之又少，即使是 Belkin 也能找出一些 智商税产品</p>
<p>但是原则上依然推荐 HP，Dell，苹果，微软的新品转接器，这些厂子的转接器不分高端低端，出手即是代表性产品，但也导致</p>
<p>这些头部厂商的产品也会有一个共性的缺点就是不会在自己的产品上集成读卡器功能</p>
<p>其余的，功能和做工就拉不开多少差距了，很难说有完美的，各方面都做的很优秀的产品</p>
<p>总结一下本文提到的带有拆解文章的产品，转接器功能需求复杂，产品或多或少存有不足，仅作参考，长期更新</p>
<p>依然不建议依赖该表，建议通读</p>
<p><img src="https://pic.islet.space/2021/05/v2-8660a99fbe26365d9a3d7488288971f6_b-20210526000705763.jpg" alt="img"></p>
<hr>
<ul>
<li><strong>排雷</strong></li>
</ul>
<p>这个市场内显著的坑货有两大类</p>
<p>一类是长得像 Belkin 的 非Belkin 产品</p>
<p><img src="https://pic2.zhimg.com/v2-ed0fcb1bc9f15717df5a0549ff865e81_b.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/v2-395b6b257e5b4bfba528ae61084b04d9_b.jpg" alt="img"></p>
<p>这类产品一般都是VIA 的VL100系公模产品， 本来做的像样的也有，比如在我的专栏中拆过的Satechi</p>
<p> 但由于对压缩成本的追求，VIA的公版设计被无限压缩，导致市面上一大批的公模VIA产品坑点奇多，下面的雷至少踩两个：</p>
<ul>
<li>质劣价高（物料成本20块左右，直接抄公版设计无需研发成本，防护全无的扩展坞可以卖到150以上，200，300 也是常见）</li>
<li>供电稀烂，带不动一块移动机械硬盘的读写耗电</li>
<li>屏蔽基本无，是一个巨大的2.4Ghz污染源，干扰附近的蓝牙，WIFI设备的正常工作</li>
<li>工厂品控稀烂</li>
</ul>
<p>涉及品牌包括 绿联，Orico，飞利浦（转接器业务已经被别家收购），Unitek，倍思</p>
<p>国内能叫的上名字的配件厂几乎全部中枪，同样是 VL100系主控，没一家的做工和防护能比得上Satechi（苹果合作款）</p>
<p><img src="https://pic2.zhimg.com/v2-3dfff693a1575ca58b5c3b089f8c59c5_b.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/v2-fd6a19341d4d279adceae25faa1f4837_b.jpg" alt="img"></p>
<p>另一类是长得像苹果的非苹果产品</p>
<p><img src="https://pic3.zhimg.com/v2-222af6d53c029fc372a794c438375936_b.jpg" alt="img"></p>
<p>这类产品同样有VIA 阵营的VL100系产品牵涉其中</p>
<p>但在低端攻城掠地的 龙讯LT8711H ，安格 AG9321 同样也籍由这样的外型活得滋润（物料成本估计 10块左右，售价一般在30，40元水平）</p>
<p>此外 Fresco 的 FL5002 公版设计也是籍由这种 外形活得滋润，例如  小米ZJQ01TM[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_1">1]</a> ，联想也是[<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_2">2]</a>，尽管TVS防护尚可，但是绝对不会装配 屏蔽罩，另外FL5002 发热较大</p>
<p>还有一类较隐蔽坑货就是自己做标致的外壳，内藏稀烂的硬件</p>
<p>外形就请自行想象了，以下三款图内PCBA的售价都在10元内</p>
<p><img src="https://pic2.zhimg.com/v2-59012a67ebb1e0efd1eb6c053219cb6d_b.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/v2-17fd6a55704998d450f3a29924a272f2_b.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/v2-ceb7df6aa2250a6a365ee70f3d83296d_b.jpg" alt="img"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>^<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_1_0">a</a><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_1_1">b</a><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_1_2">c</a>全网首拆：小米USB-C至HDMI多功能转接器ZJQ01TM拆解 <a target="_blank" rel="noopener" href="http://consumer.linxee.cn/CPLT/132.html">http://consumer.linxee.cn/CPLT/132.html</a></li>
<li>^<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_2_0">a</a><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_2_1">b</a>拆解报告：联想USB-C迷你集线器 <a target="_blank" rel="noopener" href="https://www.chongdiantou.com/wp/archives/27256.html">https://www.chongdiantou.com/wp/archives/27256.html</a></li>
<li><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_3_0">^</a>INTEL 对USB3.0 射频干扰的测试和相关建议 <a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/products/docs/io/universal-serial-bus/usb3-frequency-interference-paper.html">https://www.intel.com/content/www/us/en/products/docs/io/universal-serial-bus/usb3-frequency-interference-paper.html</a></li>
<li>^<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_4_0">a</a><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_4_1">b</a>TI文档，PD Alternative Mode：Display Port <a target="_blank" rel="noopener" href="https://www.ti.com/lit/an/slva844b/slva844b.pdf?ts=1614791986776&ref_url=https://www.ti.com/sitesearch/docs/universalsearch.tsp?searchTerm=Alternate+Mode+Support">https://www.ti.com/lit/an/slva844b/slva844b.pdf?ts=1614791986776&amp;ref_url=https%253A%252F%252Fwww.ti.com%252Fsitesearch%252Fdocs%252Funiversalsearch.tsp%253FsearchTerm%253DAlternate%2BMode%2BSupport</a></li>
<li><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_5_0">^</a>HDMI组织官网对HDMI Alt Mode 的介绍 <a target="_blank" rel="noopener" href="https://www.hdmi.org/spec/typec">https://www.hdmi.org/spec/typec</a></li>
<li><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_6_0">^</a>视频标准电子协会 VESA 的说明 [<a target="_blank" rel="noopener" href="https://vesa.org/featured-articles/vesa-rolls-out-early-certification-program-for-video-source-and-display-products-using-hbr3-high-bandwidth-link-rate/#:~:text=DisplayPort&#39;s%20new%20HBR3%20data%20rate,at%208.1%20Gbps%20per%20lane]">https://vesa.org/featured-articles/vesa-rolls-out-early-certification-program-for-video-source-and-display-products-using-hbr3-high-bandwidth-link-rate/#:~:text=DisplayPort&#39;s%20new%20HBR3%20data%20rate,at%208.1%20Gbps%20per%20lane]</a>(<a target="_blank" rel="noopener" href="https://vesa.org/featured-articles/vesa-rolls-out-early-certification-program-for-video-source-and-display-products-using-hbr3-high-bandwidth-link-rate/#:~:text=DisplayPort&#39;s">https://vesa.org/featured-articles/vesa-rolls-out-early-certification-program-for-video-source-and-display-products-using-hbr3-high-bandwidth-link-rate/#:~:text=DisplayPort&#39;s</a> new HBR3 data rate,at 8.1 Gbps per lane)</li>
<li><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_7_0">^</a>Dell官方 关于显示带宽的说明 <a target="_blank" rel="noopener" href="https://www.dell.com/support/manuals/zh-cn/dell-wd19dcs-dock/wd19dcs_user_guide/%E6%98%BE%E7%A4%BA%E5%B8%A6%E5%AE%BD?guid=guid-f73113c5-ee42-47fe-a849-d669e93440e2&lang=zh-cn">https://www.dell.com/support/manuals/zh-cn/dell-wd19dcs-dock/wd19dcs_user_guide/%E6%98%BE%E7%A4%BA%E5%B8%A6%E5%AE%BD?guid=guid-f73113c5-ee42-47fe-a849-d669e93440e2&amp;lang=zh-cn</a></li>
<li>^<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_8_0">a</a><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_8_1">b</a>TI 文档 Alternative Mode on Type-C <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/335164290">https://zhuanlan.zhihu.com/p/335164290</a></li>
<li><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_9_0">^</a>普瑞科技主控产品清单 <a target="_blank" rel="noopener" href="https://www.paradetech.com/products/">https://www.paradetech.com/products/</a></li>
<li><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_10_0">^</a>Cypress， 提问是否需要在设备端使用MUX <a target="_blank" rel="noopener" href="https://community.cypress.com/t5/USB-EZ-PD-Type-C/do-we-need-a-switch-like-PS8740B-on-both-the-source-and-sink/td-p/187782?start=0&amp;tstart=0">https://community.cypress.com/t5/USB-EZ-PD-Type-C/do-we-need-a-switch-like-PS8740B-on-both-the-source-and-sink/td-p/187782?start=0&amp;tstart=0</a></li>
<li><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_11_0">^</a>TI中文社区对差分对的介绍 <a target="_blank" rel="noopener" href="https://e2echina.ti.com/blogs_/archives/b/signal_integrity_/archive/2015/05/13/51961">https://e2echina.ti.com/blogs_/archives/b/signal_integrity_/archive/2015/05/13/51961</a></li>
<li><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_12_0">^</a>Wiki 关于 Virtual Link <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/VirtualLink">https://en.wikipedia.org/wiki/VirtualLink</a></li>
<li><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_13_0">^</a>Satechi 多口转接器拆解 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/155895919">https://zhuanlan.zhihu.com/p/155895919</a></li>
<li><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_14_0">^</a>充电头网 拆解报告：UGREEN绿联3A1C四口多功能扩展坞（带SD卡槽版） <a target="_blank" rel="noopener" href="https://www.chongdiantou.com/wp/archives/44723.html">https://www.chongdiantou.com/wp/archives/44723.html</a></li>
<li><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_15_0">^</a>华为MateDock2扩展坞拆解 <a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_702183da0102xf73.html">http://blog.sina.com.cn/s/blog_702183da0102xf73.html</a></li>
<li><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_16_0">^</a>拆解报告：米物3A1C七合一多功能扩展坞MWCMA01 <a target="_blank" rel="noopener" href="https://www.chongdiantou.com/wp/archives/61247.html">https://www.chongdiantou.com/wp/archives/61247.html</a></li>
<li>^<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_17_0">a</a><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_17_1">b</a>售完存档：全新原装惠普HP USB-C to Multi-Port Hub USB-C多端口集线器外接HDMI USB-C USB3.0 1BG94AA 918965-001 919666-001 <a target="_blank" rel="noopener" href="https://qzxx.com/49896.html">https://qzxx.com/49896.html</a></li>
<li><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_18_0">^</a>售完存档：全新散装华硕ROG Phone (ZS600KL) ASUS Professional Dock Type-C 游戏手机 电脑 Macbook PD供电 HDMI USB3.0 千M网口 USB-C接口五合一扩展坞ADSU001 <a target="_blank" rel="noopener" href="https://qzxx.com/44938.html">https://qzxx.com/44938.html</a></li>
<li><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_19_0">^</a>【TearDown】DockCase DPR01S 可视化扩展坞 4K@60Hz 分线款 拆解 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/345184683">https://zhuanlan.zhihu.com/p/345184683</a></li>
<li>^<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_20_0">a</a><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_20_1">b</a>【Teardown】Dell 配件 DA300 拆解 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/339830297">https://zhuanlan.zhihu.com/p/339830297</a></li>
<li>^<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_21_0">a</a><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_21_1">b</a><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_21_2">c</a>【TearDown】 Dell DA310 初步测试和拆解 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/350808731">https://zhuanlan.zhihu.com/p/350808731</a></li>
<li>^<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_22_0">a</a><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_22_1">b</a>拆解报告：苹果最新USB-C 数字影音多端口转换器A2119 <a target="_blank" rel="noopener" href="https://www.chongdiantou.com/wp/archives/38952.html">https://www.chongdiantou.com/wp/archives/38952.html</a></li>
<li><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_23_0">^</a>售完存档：原装Nvidia 雷电3 USB-C to DisplayPort Adapter USB-C转DP显卡转换线 支持3840*2160 4K 60Hz 030-1036-00 DJ8A5T-4000-10H <a target="_blank" rel="noopener" href="https://qzxx.com/44009.html">https://qzxx.com/44009.html</a></li>
<li><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_24_0">^</a> 拆解报告：华为高清投屏连接线（CP76） <a target="_blank" rel="noopener" href="https://www.chongdiantou.com/wp/archives/27141.html">https://www.chongdiantou.com/wp/archives/27141.html</a></li>
<li><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_25_0">^</a>小米第二款DOCK转换器拆解：支持DP，用料残暴 <a target="_blank" rel="noopener" href="https://www.sohu.com/a/150498171_296845">https://www.sohu.com/a/150498171_296845</a></li>
<li>^<a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_26_0">a</a><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_26_1">b</a>拆解报告：DELL戴尔Type-C三合一多功能扩展坞 <a target="_blank" rel="noopener" href="https://www.chongdiantou.com/wp/archives/66590.html">https://www.chongdiantou.com/wp/archives/66590.html</a></li>
<li><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_27_0">^</a>Surface Dock 2 teardown <a target="_blank" rel="noopener" href="https://dancharblog.wordpress.com/2020/05/28/surface-dock-2-teardown/comment-page-1/#comment-7200">https://dancharblog.wordpress.com/2020/05/28/surface-dock-2-teardown/comment-page-1/#comment-7200</a></li>
<li><a href="about:reader?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342165494#ref_28_0">^</a>ESD Protection Layout Guide <a target="_blank" rel="noopener" href="https://www.ti.com/lit/an/slva680/slva680.pdf?ts=1616140396901&ref_url=https://www.google.com/">https://www.ti.com/lit/an/slva680/slva680.pdf?ts=1616140396901&amp;ref_url=https%253A%252F%252Fwww.google.com%252F</a></li>
</ol>
<p>​          </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/25/Hardware/ADI/2021-05-25-ADSP21479%E7%9A%84TWI%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/25/Hardware/ADI/2021-05-25-ADSP21479%E7%9A%84TWI%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">ADSP21479的TWI及相关寄存器操作</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-25 14:00:00" itemprop="dateCreated datePublished" datetime="2021-05-25T14:00:00+08:00">2021-05-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-23 20:51:37" itemprop="dateModified" datetime="2021-06-23T20:51:37+08:00">2021-06-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hardware/" itemprop="url" rel="index"><span itemprop="name">Hardware</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>以下所有对寄存器的描述均来自于《ADSP-214xx SHARC Processor Hardware Reference》，后简称《HWR》。</p>
<p>本笔记主要是针对芯片 ADSP21479 的TWI通信及其他相关寄存器（PLL、SDRAM、SRU、中断等）进行总结和记录。</p>
<p>[TOC]</p>
<h1 id="Register-View"><a href="#Register-View" class="headerlink" title="Register View"></a>Register View</h1><h2 id="寄存器使用须知"><a href="#寄存器使用须知" class="headerlink" title="寄存器使用须知"></a>寄存器使用须知</h2><h3 id="位类型和操作"><a href="#位类型和操作" class="headerlink" title="位类型和操作"></a>位类型和操作</h3><p>许多寄存器旁边都会标注位类型和操作方法，位类型包括 可读可写（RW）、只读（RO）、只读清除（ROC）、只写清除（WOC）、可读可写1清除（RW1C）、 可读可写1设置（RW1S）。</p>
<img src="https://pic.islet.space/2021/05/20210528141056.png" alt="image-20210528134312811" style="zoom: 80%;" />



<p><strong>注意</strong>：<mark>不要尝试去写入这些 <em><strong>reversed位</strong></em> ，读取的值就会使这些位上的值进行更新或者复位。</mark></p>
<img src="https://pic.islet.space/2021/05/20210528141255.png" alt="image-20210528134457084" style="zoom:67%;" />





<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>此处两份头文件是关于外围设备及寄存器宏定义的，其中，<code>&lt;def21479.h&gt;</code> 是关于 <strong>外围设备</strong>（peripherals）和 <strong>寄存器</strong>（registers）的子集。另一份文件，<code>&lt;cdef21479.h&gt;</code> 包含了对IOP寄存器的宏定义，对C/C++可用。所有定义均和 <code>&lt;def21479.h&gt;</code> 一致，除了以 <code>p</code> 作为前缀的宏定义 和 （relevant casts）以外，它们的用法如 <code>*pSYSTAT = 0x12345678;</code>。</p>
<p>在《HWR》中，仅有第99页中提及了这两份文件。</p>
<p><img src="https://pic.islet.space/2021/06/20210602171620.png" alt="image-20210602171608976"></p>
<h4 id="DEF21479-H"><a href="#DEF21479-H" class="headerlink" title="DEF21479.H"></a>DEF21479.H</h4><p>本头文件接口涉及到的接口如下：</p>
<ul>
<li><p>外部接口IOP寄存器（IOP registers for External Port）、SDRAM控制寄存器、AMI寄存器、DMA地址寄存器、SPORT（SP0~SP7）（包含串行接口寄存器、多通道发送接收（Multichannel tx/rx）、SPORT计数寄存器、错误中断控制寄存器、控制寄存器、多通道选择（Multichannel select））、SPI和SPIB寄存器、定时器寄存器、POWER MGT寄存器、外围设备中断优先级控制寄存器（Peripheral interrupt priority control register）、DAI寄存器（DAI参数寄存器、边缘中断锁存寄存器、中断优先级寄存器、（shadow）高/低优先级中断锁存寄存器、DAI状态寄存器、DAI针脚缓存状态寄存器、）、SRU寄存器（包括SRU时钟控制寄存器、数据控制寄存器、FS控制寄存器、针脚控制寄存器、外部Misc.A/B控制寄存器、针脚使能寄存器、shift寄存器的时钟控制和数据控制）、精度时钟控制寄存器（Precision Clock A/B Control Register 0/1）（包括脉冲宽度控制、幅度同步、脉冲宽度控制）、MTM寄存器、PWM寄存器、UART寄存器、TWI寄存器、FIR加速寄存器、IIR加速寄存器、FFT加速寄存器、MLB设备寄存器、WDT寄存器、Shift寄存器、RTC寄存器。</p>
</li>
<li><p>DPI、DTCP模块</p>
</li>
</ul>
<hr>
<ul>
<li><p>系统寄存器位定义（MODE1和MMASK寄存器、MODE2寄存器、ASTAT、STKYx和STKYy寄存器、IRPTL寄存器、IMASK寄存器、IMASKP寄存器、LIRPTL寄存器、FLAGS寄存器）</p>
</li>
<li><p>IOP控制/状态寄存器位定义（EEMUSTAT寄存器、RUNRSTCTL寄存器、SYSCTL寄存器、BRKCTL寄存器、REVPID、SDCTL寄存器位、SDRRC（SDRAM刷新速率控制）寄存器、SDSTAT（SDRAM状态）寄存器、SDSTAT（SDRAM状态）寄存器2、EPCTL寄存器位）</p>
</li>
<li><p>AMICTL寄存器位（DMAC寄存器控制位、SPICTL寄存器、SPISTAT寄存器、SPCTL（0~5、N0~N7）寄存器、GP计时器状态寄存器、GP计时器控制寄存器、电源管理控制寄存器、外部时钟管理控制寄存器、DAI中断锁存寄存器、IDP控制寄存器、IDP PDAP控制寄存器、DAI针脚缓存状态寄存器（0~19）、DAI状态寄存器、DPI针脚缓存状态寄存器（0~13）、DPI中断锁存寄存器）</p>
</li>
<li><p>精度时钟控制寄存器（A0、A1、B0、B1、C0、C1、D0、D1）、精度时钟脉冲宽度控制寄存器、精度时钟幅度同步、精度时钟脉冲宽度控制寄存器</p>
</li>
<li><p>优先级中断控制（Priority Interrupt Control）寄存器（可编程中断（Programmable Interrupt）寄存器位）</p>
</li>
<li><p>PWM全局控制寄存器、PWM全局状态寄存器、PWM控制寄存器、PWM状态寄存器、PWM输出禁用、PWM调试状态、PWM极性选择寄存器（Polarity Select Register）</p>
</li>
<li><p>TWI寄存器、主设备内部时钟寄存器（TWIMITR）、TWI从设备控制寄存器（TWISCTL）、TWI从设备状态寄存器（TWISSTAT）、TWI主设备控制寄存器（TWIMCTL）、TWI主设备状态寄存器（TWIMSTAT）、TWI中断控制寄存器（TWIIMASK/TWIIRPTL）、TWI先进先出控制寄存器（TWIFIFOCTL）、TWI先进先出状态寄存器（TWIFIFOSTAT）</p>
</li>
<li><p>UART寄存器、UARTIIR、UARTLCR、UARTMODE、UARTLSR、UARTTXCTL/RXCTL、UARTTXSTAT/RXSTAT</p>
</li>
<li><p>SPDIF传输寄存器、SPDIF通道状态寄存器、SPDIF用户位状态寄存器、SPDIF接收器寄存器、SPDIF传输控制寄存器、SPDIF TX输入数据格式、SPDIF接收控制寄存器、SPDIF接收状态（只读）</p>
</li>
<li><p>采样率转换控制寄存器（0~3）、输入数据格式、输出数据格式、SRC频应复元（Deemphasis）设置、彩艳率转换率（0~3）、采样率转换静音（MUTE）寄存器（SRCMUTE）</p>
</li>
<li><p>FIR加速器、IIR加速器、FFT加速器</p>
</li>
<li><p>MLB位定义（DCCR/SSCR/SMCR/IBCR/CECR/CSCR）、WDT寄存器位定义、Shift寄存器位定义、RTC寄存器位定义（控制、初始化、状态、初始化状态）</p>
</li>
</ul>
<h4 id="CDEF21479-H"><a href="#CDEF21479-H" class="headerlink" title="CDEF21479.H"></a>CDEF21479.H</h4><p>本头文件中涉及的寄存器如下：</p>
<ul>
<li>仿真、断点寄存器</li>
<li>外部接口的IOP寄存器</li>
<li>SDRAM控制寄存器</li>
<li>AMI的IOP寄存器</li>
<li>DAM地址寄存器</li>
<li>SPORT（0~7）（串行接口寄存器、MT/MR寄存器、TDM寄存器、）</li>
<li>SPI寄存器、SPIB寄存器（通过DAI进行路由）</li>
<li>计时器寄存器</li>
<li>电源管理寄存器</li>
<li>外围中断优先级控制寄存器</li>
<li>DAI寄存器（DMA参数寄存器、SRU寄存器、采样率转换寄存器）</li>
<li>DPI寄存器</li>
<li>DTCP模块</li>
<li>SPDIF传输寄存器（通道状态缓存、用户位缓存、SPDIF接收寄存器）</li>
<li>PCG精度时钟控制寄存器</li>
<li>MTM（Memory to Memory）寄存器</li>
<li>PWM脉冲调制寄存器</li>
<li>UART寄存器</li>
<li>TWI寄存器</li>
<li>FIR加速寄存器</li>
<li>IIR加速寄存器</li>
<li>FFT加速寄存器</li>
<li>MLB设备寄存器</li>
<li>WDT寄存器</li>
<li>Shift寄存器</li>
<li>RTC寄存器</li>
</ul>
<p>但是，在《HWR》“自己眼”中，可能自己就这么点儿寄存器。</p>
<p><img src="https://pic.islet.space/2021/05/20210529114430.png" alt="image-20210528140017190"></p>
<h2 id="PLL寄存器"><a href="#PLL寄存器" class="headerlink" title="PLL寄存器"></a>PLL寄存器</h2><h3 id="PMCTL"><a href="#PMCTL" class="headerlink" title="PMCTL"></a>PMCTL</h3><p><code>PMCTL</code> 寄存器，Power management control register。（是的，没错，就是不知道为啥管PLL的要叫PMCTL）</p>
<ul>
<li> Controls the <em><strong>SDCLK</strong></em> to core clock ratio <mark>or</mark> <em><strong>DDR2CLK</strong></em> to core clock ratio related to the external port timing.</li>
<li>The fundamental timing clock of the external port is <em><strong>SDRAM clock</strong></em> (SDCLK). The SDRAM clock ratio settings are independent from the peripheral clock (PCLK).<ul>
<li>The AMI/SDRAM controller is capable of running at up to <em><strong>133 MHz</strong></em> for ADSP-2147x processors. See Table 4-2 for more information about <em>EXTERNAL PORT CLOCK FREQUENCIES</em>.</li>
</ul>
</li>
<li>The fundamental timing clock of the external port is <em><strong>DDR2 clock</strong></em> (DDR2_CLK). The DDR2 clock ratio settings are independent from the <em><strong>peripheral clock</strong></em> (PCLK).</li>
<li> 32位内存映射寄存器（32-bit memory-mapped register）</li>
<li> 包含控制位，可控制：锁相环（PLL, phase lock loop）(PLL乘法器值（multiplier）、PLL除法器值（divider）、锁相环旁路模式（PLL bypass mode） 和 外围设备使能时钟控制（clock control for enabling peripherals）)</li>
<li> 包含状态位，可追踪：CLK_CFG针脚（可读写）</li>
<li> PMCTL 寄存器的复位值取决于 <code>CLK_CFG</code> 引脚（bits 5-0 &amp; 17-16）</li>
<li>包含三选一的加速器（FIR、IIR、FFT）</li>
</ul>
<img src="https://pic.islet.space/2021/06/20210608103432.png" alt="image-20210608101359924" style="zoom: 67%;" />



<p><img src="https://pic.islet.space/2021/05/20210527150918.png" alt="image-20210527150852485"></p>
<p style="text-align: center; color: gray; font-weight: 800;">图 A-2 PMCTL 寄存器</p>

<p style="text-align: center; color: gray; font-weight: 800;">表A-3  PMCTL寄存器位功能描述</p>

<p><img src="https://pic.islet.space/2021/05/20210527151117.png" alt="image-20210527151035867"></p>
<p><img src="https://pic.islet.space/2021/05/20210527151120.png" alt="image-20210527151017770"></p>
<p><img src="https://pic.islet.space/2021/05/20210527151124.png" alt="image-20210527151110432"></p>
<h3 id="PMCTL1"><a href="#PMCTL1" class="headerlink" title="PMCTL1"></a>PMCTL1</h3><img src="https://pic.islet.space/2021/05/20210527152316.png" alt="image-20210527152044822" style="zoom:67%;" />

<p style="text-align: center; color: gray; font-weight: 800;">图 A-3 PMCTL1 寄存器</p>

<p style="text-align: center; color: gray; font-weight: 800;">表A-4  PMCTL1寄存器位功能描述</p>

<p><img src="https://pic.islet.space/2021/05/20210527152313.png" alt="image-20210527152155406"></p>
<p><img src="https://pic.islet.space/2021/05/20210527152318.png" alt="image-20210527152229763"></p>
<p><img src="https://pic.islet.space/2021/05/20210527152322.png" alt="image-20210527152251696"></p>
<h3 id="PLLD"><a href="#PLLD" class="headerlink" title="PLLD"></a>PLLD</h3><p>PLLD是锁相环分频器（PLL Divider）。</p>
<p><mark style="font-weight: 900;">Page 888:</mark> <strong>PLLD</strong>（PLL Divider）定义了 <strong>VCO输出时钟</strong> 和 <strong>核心时钟</strong> 的比值，以构建 <strong>处理器核心时钟</strong>（CCLK）。正在使用的分频器可以被随时改变，新的分频比率可以实时被应用。</p>
<p><mark style="font-weight: 900;">Page 957:</mark> <strong>PLLD</strong>只有2位，可以设置为2、4、8、16。</p>
<img src="https://pic.islet.space/2021/05/20210529113458.png" alt="image-20210529113003651" style="zoom:67%;" />

<p><mark style="font-weight: 900;">&lt;def21479.h&gt;</mark>:<img src="https://pic.islet.space/2021/05/20210529113406.png" alt="image-20210529113403231"></p>
<p>以下这几个操作中均需要用到PLLD，分别是：</p>
<ul>
<li>输出时钟生成器编程模型 （Output Clock Generator Programming Model）</li>
<li>改变链接口时钟（Changing the Link Port Clock）</li>
<li>发布分频器（Post Divider）</li>
</ul>
<img src="https://pic.islet.space/2021/05/20210529113238.png" alt="image-20210529111641680" style="zoom:67%;" />

<img src="https://pic.islet.space/2021/05/20210529113241.png" alt="image-20210529111748944" style="zoom:67%;" />

<img src="https://pic.islet.space/2021/05/20210529113244.png" alt="image-20210529112121464" style="zoom:67%;" />



<h3 id="官方代码示例"><a href="#官方代码示例" class="headerlink" title="官方代码示例"></a>官方代码示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_PLL</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp,i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1 - change the PLLD to 4</span></span><br><span class="line">	temp=*pPMCTL;   <span class="comment">//备份PMCTL寄存器的值至temp</span></span><br><span class="line">	temp&amp;=~PLLD16 ;     <span class="comment">//0x20，将PLLD16的值和temp进行逐位“与”运算</span></span><br><span class="line">	temp|=(PLLD4 | DIVEN) ;   <span class="comment">//0x260    0010 0110 0000</span></span><br><span class="line">	*pPMCTL = temp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2 - 等待分频器稳定</span></span><br><span class="line">	SysWait(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 3 - set INDIV bit now to bring down the VCO speed and enter the bypass mode</span></span><br><span class="line">	temp&amp;=~DIVEN;</span><br><span class="line">	temp|=(INDIV | PLLBP);</span><br><span class="line">	*pPMCTL = temp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 4 -等待PLL锁定</span></span><br><span class="line">	SysWait(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 5 - come out of the bypass mode</span></span><br><span class="line">	temp=*pPMCTL;</span><br><span class="line">	temp&amp;=~PLLBP;</span><br><span class="line">	*pPMCTL = temp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 6 - 等待分频器稳定</span></span><br><span class="line">	SysWait(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 7 - set the required PLLM and INDIV values here  and enter the bypass mode</span></span><br><span class="line">	 <span class="comment">//PLLM=16, INDIV=0,  fVCO=2*PLLM*CLKIN = 2*16*16.625 = 532 MHz</span></span><br><span class="line">	temp = *pPMCTL;</span><br><span class="line">	temp&amp;=~ (INDIV | PLLM63);</span><br><span class="line">	temp|= (PLL_MULT| PLLBP);</span><br><span class="line">	*pPMCTL = temp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 8 - wait for the PLL to lock</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4096</span>;i++);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 9 - come out of the bypass mode</span></span><br><span class="line">	temp = *pPMCTL;</span><br><span class="line">	temp&amp;=~PLLBP;</span><br><span class="line">	*pPMCTL=temp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 10 - wait for dividers to stabilize</span></span><br><span class="line">	SysWait(<span class="number">16</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Step 11 - set the required values of PLLD(=2) and SDCKR (=2.5 for ADSP-21489 and 2 for ADSP-21479) here</span></span><br><span class="line">	<span class="comment">// fCCLK = fVCO/PLLD = 532/2 = 266 MHz, fSDCLK = fCCLK/SDCKR = 266/2 = 133 MHz</span></span><br><span class="line">	temp=*pPMCTL;</span><br><span class="line">	temp&amp;=~(PLLD16 | <span class="number">0x1C0000</span> );</span><br><span class="line">	temp|= (SDCKR2 | PLLD2 | DIVEN);</span><br><span class="line">	*pPMCTL=temp;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Step 12 - wait for the dividers to stabilize</span></span><br><span class="line">	SysWait(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>问题</strong>1： 为啥一定要使用temp变量来进行处理，直接使用 <code>*pPMCTL</code> 不是更方便吗？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPLL</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/********************************************************************************************/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i, pmctlsetting;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set INDIV bit in PMCTL register</span></span><br><span class="line">	pmctlsetting = *pPMCTL; <span class="comment">// 备份PMCTL寄存器的原始值</span></span><br><span class="line">	pmctlsetting |= INDIV;	<span class="comment">//设置锁相环输出的分频率，0则是1分频，1则是2分频，此处通过或运算设置为二分频</span></span><br><span class="line">	*pPMCTL = pmctlsetting; <span class="comment">// 将至重新写入PMCTL寄存器</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Program PLL multiplier to same value as CLK_CFGx pins/previously programmed value in software……</span></span><br><span class="line">	*pPMCTL = pmctlsetting;</span><br><span class="line">	pmctlsetting |= PLLBP; <span class="comment">//设置锁相环旁路模式</span></span><br><span class="line">	*pPMCTL = pmctlsetting;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Wait for recommended number of cycles</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4096</span>; i++)</span><br><span class="line">		NOP;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Bring PLL out of bypass mode by clearing PLLBP bit</span></span><br><span class="line">	*pPMCTL ^= PLLBP; <span class="comment">// 通过异或操作 取消旁路模式</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">		NOP;</span><br><span class="line"></span><br><span class="line">	pmctlsetting = *pPMCTL;</span><br><span class="line">	pmctlsetting &amp;= ~PLLM63; <span class="comment">//通过按位取反操作和与操作，清除PLLM所有位</span></span><br><span class="line">	pmctlsetting &amp;= ~INDIV;	 <span class="comment">//通过按位取反操作和与操作，清除分频</span></span><br><span class="line">	<span class="comment">// *pMCTL |= INDIV;</span></span><br><span class="line">	*pPMCTL = pmctlsetting;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// CLKIN = 16.625 MHz, PLLM=32, PLLD = 1, INDIV= 1 =&gt; fINPUT = 16.625/2 = 8.3125 MHz</span></span><br><span class="line">	<span class="comment">// CCLK = 2*PLLM*fINPUT/2*PLLD = (2*32*8.3125)/(2*1) = 266 MHz, SDCLK = CCLK/2 = 133 MHz</span></span><br><span class="line">	<span class="comment">// VCO frequency = 2*fINPUT*PLLM = 2*8.3125*32 = 532 &lt;= fVCOmax (532 MHz)</span></span><br><span class="line"></span><br><span class="line">	pmctlsetting = SDCKR2 | PLLM32 | INDIV | DIVEN; <span class="comment">//设置</span></span><br><span class="line">	*pPMCTL = pmctlsetting;</span><br><span class="line"></span><br><span class="line">	pmctlsetting |= PLLBP;	<span class="comment">//Setting the Bypass bit</span></span><br><span class="line">	pmctlsetting ^= DIVEN;	<span class="comment">//Clearing the DIVEN bit</span></span><br><span class="line">	*pPMCTL = pmctlsetting; <span class="comment">// Putting the PLL into bypass mode</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Wait for around 4096 cycles for the pll to lock.</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">		NOP;</span><br><span class="line"></span><br><span class="line">	pmctlsetting = *pPMCTL;</span><br><span class="line">	pmctlsetting ^= PLLBP; <span class="comment">//清除旁路模式</span></span><br><span class="line">	*pPMCTL = pmctlsetting;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Wait for around 15 cycles for the output dividers to stabilize.</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">		NOP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更改之后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SystemWait</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> MAX)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX; i++) NOP;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPLL</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*pPMCTL |= INDIV;	<span class="comment">//设置锁相环输出的分频率，0则是1分频，1则是2分频，此处通过或运算设置为二分频</span></span><br><span class="line">	*pPMCTL |= PLLBP; <span class="comment">//设置锁相环旁路模式</span></span><br><span class="line">	SystemWait(<span class="number">4096</span>);</span><br><span class="line">	</span><br><span class="line">    *pPMCTL ^= PLLBP; <span class="comment">// 通过异或操作 取消旁路模式</span></span><br><span class="line">	SystemWait(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    *pPMCTL &amp;= ~( PLLM63 | INDIV );  <span class="comment">//PLLM和INDIV位全部或操作后取反，再与原PMCTL里的数据与操作，清除该两个定义位的数据</span></span><br><span class="line">	*pPMCTL = SDCKR2 | PLLM32 | INDIV | DIVEN; <span class="comment">//设置这几个位置的值</span></span><br><span class="line">    *pPMCTL = (*pPMCTL | PLLBP) ^ DIVEN</span><br><span class="line">	SystemWait(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">	*pPMCTL ^= PLLBP; <span class="comment">//清除旁路模式</span></span><br><span class="line">	SystemWait(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用乘法器（multipliers）和已发布的分频器（post dividers）对PLL进行编程时，<code>DIVEN</code> 和 <code>PLLBP</code> 不可以在同一个时钟周期内被编程。注意：<code>DIVEN</code> 位会自动清零（self clearing）。</p>
<blockquote>
<p>∵ CLKIN = 16.625 MHz, PLLM=32, PLLD = 1, INDIV= 1<br>∴ f<del>INPUT</del> = 16.625/2 = 8.3125 MHz<br>∴ CCLK = 2*PLLM *f<del>INPUT</del>/2*PLLD = (2*32*8.3125)/(2*1) = 266 MHz<br>∴ SDCLK = CCLK/2 = 133 MHz， 符合 2147X 对 SDRAM 时钟的要求<br>VCO frequency = 2*f<del>INPUT</del>*PLLM = 2<em>8.3125</em>32 = 532 &lt;= f<del>VCOmax</del> (532 MHz)</p>
</blockquote>
<h2 id="复位寄存器"><a href="#复位寄存器" class="headerlink" title="复位寄存器"></a>复位寄存器</h2><p><em><strong>RUNRSTCTL</strong></em>，运行中复位控制寄存器（Running Reset Control Register）。</p>
<p style="text-align: center; color: gray; font-weight: 800;">表A-5 RUNRSTCTL寄存器位功能描述</p>

<p><img src="https://pic.islet.space/2021/05/20210527170843.png" alt="image-20210527170816951"></p>
<h2 id="可编程中断优先级控制寄存器"><a href="#可编程中断优先级控制寄存器" class="headerlink" title="可编程中断优先级控制寄存器"></a>可编程中断优先级控制寄存器</h2><ul>
<li><p>supports 19 programmable prioritized interrupts</p>
</li>
<li><p>任何外部中断输出都可能被连接至任何可编程优先级中断输入。</p>
</li>
</ul>
<p style="text-align: center; color: gray; font-weight: 800;">表A-6 默认中断路由</p>

<p><img src="https://pic.islet.space/2021/05/20210527171222.png" alt="image-20210527171119962"></p>
<p><img src="https://pic.islet.space/2021/05/20210527171224.png" alt="image-20210527171204914"></p>
<p><img src="https://pic.islet.space/2021/05/20210527171227.png" alt="image-20210527171219793"></p>
<h2 id="目标信号控制寄存器"><a href="#目标信号控制寄存器" class="headerlink" title="目标信号控制寄存器"></a>目标信号控制寄存器</h2><p>本寄存器控制了：</p>
<ul>
<li><p>programmable priority interrupts</p>
</li>
<li><p>default interrupt sources</p>
</li>
</ul>
<p><img src="https://pic.islet.space/2021/05/20210527172018.png" alt="image-20210527171809869"></p>
<p style="text-align: center; color: gray; font-weight: 800;">图 A-4  PICR0 寄存器</p>





<p><img src="https://pic.islet.space/2021/05/20210527172024.png" alt="image-20210527171824344"></p>
<p style="text-align: center; color: gray; font-weight: 800;">图 A-5 PICR1 寄存器</p>





<p><img src="https://pic.islet.space/2021/05/20210527172027.png" alt="image-20210527171841316"></p>
<p style="text-align: center; color: gray; font-weight: 800;">图 A-6 PICR2 寄存器</p>





<p><img src="https://pic.islet.space/2021/05/20210527172029.png" alt="image-20210527171852287"></p>
<p style="text-align: center; color: gray; font-weight: 800;">图 A-7 PICR3 寄存器</p>



<h2 id="DAI-DPI中断控制寄存器"><a href="#DAI-DPI中断控制寄存器" class="headerlink" title="DAI/DPI中断控制寄存器"></a>DAI/DPI中断控制寄存器</h2><h2 id="TWI寄存器"><a href="#TWI寄存器" class="headerlink" title="TWI寄存器"></a>TWI寄存器</h2><p>《HWR》第1193页起定义了TWI的寄存器。第1244页同样给了TWI相关的寄存器一个列表。</p>
<img src="https://pic.islet.space/2021/05/20210528140307.png" alt="image-20210528140209933" style="zoom:67%;" />



<p><code>&lt;cdef21479.h&gt;</code> 对TWI相关的寄存器定义如下，p为前缀的定义是该寄存器的地址位，通过与<code>&lt;def21479.h&gt;</code> 的定义进行 <code>或</code> 运算并赋值给对应的寄存器地址进行控制，如 <code>*pTWIMITR = (0x14) | TWIEN;</code> 。</p>
<p>TWI中所有的Status相关寄存器都是 “只读” 状态，其《位描述》表上都有一个 <code>RO</code> 标志。</p>
<img src="https://pic.islet.space/2021/05/20210527095059.png" alt="image-20210527095053483" style="zoom:80%;" />



<p>在VisualDSP++这款IDE中，也可以通过 直接观察到所有TWI的寄存器值。</p>
<p><img src="https://pic.islet.space/2021/06/20210607103819.png" alt="image-20210607103816755" style="zoom:80%;" /> <img src="https://pic.islet.space/2021/06/20210607103750.png" alt="image-20210607103747655"></p>
<h3 id="TWIMITR"><a href="#TWIMITR" class="headerlink" title="TWIMITR"></a>TWIMITR</h3><p>TWIMITR（<strong>Master Internal Time Register</strong>），即主机内部时间寄存器（如图A-143所示，并在表A-129中描述）。</p>
<ul>
<li>用于启用TWI模块，以及建立外围时钟（PCLK）和TWI控制器内部定时事件之间的关系。<ul>
<li>内部时间参考是从PCLK得出的，使用的是预标定值。<code>PRESCALE = fPCLK / 10 MHz</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>The internal time reference is <em><strong>derived from PCLK</strong></em> using the prescaled value shown below.</p>
<p><code>PRESCALE = fPCLK/10 MHz</code></p>
</blockquote>
<img src="https://pic.islet.space/2021/05/20210525135455.png" alt="image-20210525133555377" style="zoom: 67%;" />

<p style="text-align: center; color: gray; font-weight: 800;">图 A-143 TWIMITR 寄存器</p>



<p style="text-align: center; color: gray; font-weight: 800;">表A-129 寄存器位功能描述</p>

<table>
<thead>
<tr>
<th>BITS</th>
<th>NAME</th>
<th>DESCRIPTION</th>
</tr>
</thead>
<tbody><tr>
<td>6-0</td>
<td>PRESCALE</td>
<td><strong>预分频</strong><br>用于生成一个内部时间参考的外围时钟（PCLK）周期数。<br>必须设置PRESCALE的值，以创建一个周期为10MHz的内部时间参考。这表示为一个7位的二进制值。</td>
</tr>
<tr>
<td>7</td>
<td>TWIEN</td>
<td><strong>TWI使能</strong><br>该位必须设置为从属或主模式操作。<br>建议在初始化PRESCALE时设置该位，并保持设置，以确保总线繁忙检测逻辑的精确运行。<br/>- 0 = 禁用TWI<br/>- 1 = 启用TWI主、从模式操作。<mark>如果该位从高电平过渡到低电平，缓冲器将被刷新，需要2个时钟周期。</mark></td>
</tr>
</tbody></table>
<h3 id="TWIDIV"><a href="#TWIDIV" class="headerlink" title="TWIDIV"></a>TWIDIV</h3><p>在主模式运行期间，跟SCL相关的TWIDIV（<strong>Clock Divider Register</strong>），即时钟分频器寄存器（如图A-144所示，并在表A-130中描述）。</p>
<ul>
<li>被用来创建串行时钟（SCL）的 <strong>高</strong> 和 <strong>低</strong> 持续时间。</li>
<li>串行时钟的频率可以从400KHz到小于20KHz不等。产生的时钟分辨率为1/10 MHz或100 ns。</li>
</ul>
<img src="https://pic.islet.space/2021/05/20210525135457.png" alt="image-20210525134728762" style="zoom: 67%;" />

<p style="text-align: center; color: gray; font-weight: 800;">图 A-144 TWIDIV 寄存器</p>



<p style="text-align: center; color: gray; font-weight: 800;">表A-130 TWIDIV 寄存器位功能描述</p>

<table>
<thead>
<tr>
<th>BITS</th>
<th>NAME</th>
<th>DESCRIPTION</th>
</tr>
</thead>
<tbody><tr>
<td>7-0</td>
<td>CLKLOW</td>
<td>时钟低电平<br>该时间映射了串行时间低电平的周期。<br>以8位二进制数表示。</td>
</tr>
<tr>
<td>15-8</td>
<td>CLKHI</td>
<td>时钟高电平<br>该时间映射了串行时钟在等到一个新时钟低电平到来之前的持续时间。<br>以8位二进制数表示。</td>
</tr>
</tbody></table>
<h3 id="TWIMCTL"><a href="#TWIMCTL" class="headerlink" title="TWIMCTL"></a>TWIMCTL</h3><p>TWIMCTL（Master Control Register），即TWI主机控制寄存器。</p>
<ul>
<li>控制了控制与主机模式操作相关的逻辑。</li>
<li>该寄存器内的操作不会影响到从寄设备的操作；且不应该被修改以控制从属模式的功能。</li>
</ul>
<blockquote>
<p>The TWI master mode control register controls the logic associated with master mode  operation.</p>
<p>Bits in this register do not affect slave mode operation and should not be modified to control slave mode functionality.</p>
</blockquote>
<img src="https://pic.islet.space/2021/05/20210525143535.png" alt="image-20210525140532502" style="zoom: 67%;" />

<p style="text-align: center; color: gray; font-weight: 800;">图 A-145 TWIMCTL 寄存器</p>

<p style="text-align: center; color: gray; font-weight: 800;">表A-131 TWIMCTL 寄存器位功能描述</p>

<img src="https://pic.islet.space/2021/05/20210525143532.png" alt="image-20210525143454398" style="zoom: 67%;" />

<img src="https://pic.islet.space/2021/05/20210525143531.png" alt="image-20210525143529519" style="zoom: 67%;" />



<h3 id="TWIMADDR"><a href="#TWIMADDR" class="headerlink" title="TWIMADDR"></a>TWIMADDR</h3><p>在传输的寻址阶段中，TWI控制器的主机使能，并传输TWI主机模式地址寄存器中的内容。</p>
<p>在对本寄存器进行编程时，忽略读/写位。只有从机地址的前7位（6-0）会被写入本寄存器。</p>
<p>例如：从机的地址是 <code>1010 000x</code> ，则本寄存器的写入内容则是 <code>1010 000</code>（16进制的 <code>0x50</code> ）。<mark>将该地址发送至总线时，TWI控制器根据 主机控制寄存器上TWIMDIR 位来决定对从机的读写。</mark></p>
<blockquote>
<p>During the addressing phase of a transfer, the TWI controller, with its master enabled, transmits the contents of the TWI master mode address register.<br>When programming this register, omit the read/write bit. That is, only the upper 7 bits that make up the slave address should be written to this register.<br>For example, if the slave address is 1010000X, then TWIMADDR is programmed with 1010000, which corresponds to 0x50. When sending out the address on the bus, the TWI controller appends the read/write bit as appropriate, based on the state of the TWIMDIR bit in the master mode control register.</p>
</blockquote>
<img src="https://pic.islet.space/2021/05/20210525143542.png" alt="image-20210525140743855" style="zoom: 67%;" />

<p style="text-align: center; color: gray; font-weight: 800;">图 A-146 TWIMADDR 寄存器</p>



<h3 id="TWIMSTAT"><a href="#TWIMSTAT" class="headerlink" title="TWIMSTAT"></a>TWIMSTAT</h3><ul>
<li>Not directly associated with the generation of interrupts but offer information on the current transfer.</li>
<li>Slave mode operation does not affect master mode status bits.</li>
</ul>
<p><img src="https://pic.islet.space/2021/06/20210603153454.png" alt="image-20210603153452903"></p>
<p>如果TWIMSTAT寄存器中的第2位是1</p>
<img src="https://pic.islet.space/2021/06/20210603153720.png" alt="image-20210603153655529" style="zoom:80%;" />

<img src="https://pic.islet.space/2021/06/20210603153724.png" alt="image-20210603153719024" style="zoom:80%;" />







<h3 id="TWIFIFOCTL"><a href="#TWIFIFOCTL" class="headerlink" title="TWIFIFOCTL"></a>TWIFIFOCTL</h3><p>TWIFIFOCTL（<strong>FIFO Control Register</strong>），即先进先出控制寄存器，只控制FIFO，<mark>完全不与主机模式 或 从机模式操作绑定。</mark></p>
<img src="https://pic.islet.space/2021/05/20210525144902.png" alt="image-20210525144403383" style="zoom: 67%;" />

<p style="text-align: center; color: gray; font-weight: 800;">图 A-151 TWIFIFOCTL 寄存器</p>



<p style="text-align: center; color: gray; font-weight: 800;">表A-135 TWIFIFOCTL 寄存器位功能描述</p>

<img src="https://pic.islet.space/2021/05/20210525144904.png" alt="image-20210525144738016" style="zoom:67%;" />





<h3 id="TWIFIFOSTAT"><a href="#TWIFIFOSTAT" class="headerlink" title="TWIFIFOSTAT"></a>TWIFIFOSTAT</h3><ul>
<li>指示FIFO缓冲区的接收和发送内容的状态。</li>
<li>FIFO缓冲器不区分主数据和从数据。</li>
<li>可以对FIFO进行管理，允许同时进行主、从操作。</li>
</ul>
<p><img src="https://pic.islet.space/2021/06/20210603152241.png" alt="image-20210603152156841"></p>
<p><img src="https://pic.islet.space/2021/06/20210603152239.png" alt="image-20210603152211766"></p>
<p><img src="https://pic.islet.space/2021/06/20210603152242.png" alt="image-20210603152235432"></p>
<blockquote>
<p><strong>TWITXS</strong>: 传输FIFO状态。</p>
<p>这些只读位表示FIFO缓冲器中有效数据字节的数量。该状态在每次使用外围数据总线写入FIFO缓冲区或通过传输移位寄存器读取时被更新。</p>
<p>在每次使用外设数据总线写FIFO缓冲区或通过传输移位寄存器读访问时更新。允许同时访问。</p>
<ul>
<li>00 = FIFO是空的。无论是单字节还是双字节的FIFO外设写入都会立即通过。</li>
<li>01 = FIFO包含一个字节的数据。对FIFO的单字节外围写立即通过。一个双字节的外设写入要等到FIFO为空时才进行。</li>
<li>11 = FIFO已满，包含两个字节的数据。</li>
<li>10 = 保留</li>
</ul>
</blockquote>
<h3 id="TWIIRPTL"><a href="#TWIIRPTL" class="headerlink" title="TWIIRPTL"></a>TWIIRPTL</h3><p>TWIIRPTL（TWI interrupt sources register），即TWI中断源寄存器。</p>
<ul>
<li><p>包含了有关 <em>functional areas requiring servicing</em> 的信息。</p>
</li>
<li><p>大量的比特被当做鉴定器/指示器来使用，主要用于 <em>further read</em> 以及 为 不同的状态寄存器提供服务（service various status register）。</p>
</li>
<li><p>在维护了与位绑定的中断源后，用户需要清除该中断源位。</p>
</li>
<li><p>所有的位都是粘性的 （sticky）和 <em><strong>RW1C</strong></em>。</p>
</li>
</ul>
<img src="https://pic.islet.space/2021/05/20210525163021.png" alt="image-20210525163016113" style="zoom: 50%;" />

<p style="text-align: center; color: gray; font-weight: 800;">图 A-1534 TWIIRPTL 寄存器</p>



<p style="text-align: center; color: gray; font-weight: 800;">表A-137 TWIIRPTL 寄存器位功能描述</p>

<img src="https://pic.islet.space/2021/05/20210525164025.png" alt="image-20210525163933340" style="zoom:67%;" />

<img src="https://pic.islet.space/2021/05/20210525164028.png" alt="image-20210525163959598" style="zoom:67%;" />

<h4 id="TWITXINT"><a href="#TWITXINT" class="headerlink" title="TWITXINT"></a>TWITXINT</h4><p>首先要搞清楚，这个TWITXINT 是寄存器还是寄存器位，如果是寄存器位，哪它来自于哪个寄存器呢。目前已知包含TWITXINT的寄存器有：<code>TWIIRPTL</code> 、 <code>TWIIMASK</code> 、 <code>TWIFIFOCTL</code>(TWITXINT<em><strong>2</strong></em>)</p>
<blockquote>
<p>在TWIIRPT寄存器中的TWITXINT寄存器位：</p>
<p>发送FIFO服务。</p>
<p>如果 TWIFIFOCTL 寄存器中的 <code>XMTINTLEN2</code> 为 0，则每次 TWIFOSTAT 寄存器中的 TWITXS 字段被更新为 01 或 00 时，该位都被设置。</p>
<p>如果 <code>XMTINTLEN</code> 为 1，则每次 TWITXS 被更新为 00 时，该位都被设置。</p>
<p>1 = 发送 FIFO 缓冲区有一个或两个 8 位位置可供写入。</p>
<p>0 = FIFO不需要服务或TWITXS字段在该位最后被清除后没有变化。</p>
</blockquote>
<h5 id="TWITXINT-interrupt"><a href="#TWITXINT-interrupt" class="headerlink" title="TWITXINT interrupt"></a>TWITXINT interrupt</h5><blockquote>
<p>This interrupt is generated when there is one or two bytes of empty space in the FIFO. Simple data handling is all that is required.</p>
</blockquote>
<h3 id="TWIIMASK"><a href="#TWIIMASK" class="headerlink" title="TWIIMASK"></a>TWIIMASK</h3><p>TWIIMARK （<strong>TWI Interrupt mask register</strong>），即TWI中断<em><strong>隐藏</strong></em>寄存器。</p>
<ul>
<li>使能中断源（interrupt sources）插入中断输出（Interrupt output）</li>
<li>每一个<strong>使能位</strong>（enable bit）都会与 <strong>TWI中断延迟寄存器</strong>（TWIIRPTL，即TWI interrupt latch register）一个<strong>中断延迟位</strong>（interrupt latch bit）通信。</li>
<li>对TWIIMASK寄存器的读写不会影响 TWIIRPTL 寄存器的内容。</li>
</ul>
<img src="https://pic.islet.space/2021/05/20210525164217.png" alt="image-20210525145706357" style="zoom: 67%;" />

<p style="text-align: center; color: gray; font-weight: 800;">图 A-154 TWIIMASK 寄存器</p>



<p style="text-align: center; color: gray; font-weight: 800;">表A-138 TWIIMASK 寄存器位功能描述</p>

<img src="https://pic.islet.space/2021/05/20210525150124.png" alt="image-20210525150058029" style="zoom:67%;" />

<img src="https://pic.islet.space/2021/05/20210525164016.png" alt="image-20210525150122857" style="zoom:67%;" />



<h3 id="TXTWI8"><a href="#TXTWI8" class="headerlink" title="TXTWI8"></a>TXTWI8</h3><p>8位传输用FIFO寄存器（TWI 8-bit transmit FIFO register），做数据缓存之用。</p>
<ul>
<li>存储数据以“先进先出”的顺序进入通信传输缓存。</li>
<li>尽管外围总线写入带宽是32位，但是只有一个字节会被写入8位的 <em><strong>TXTWI8</strong></em>。</li>
<li>伴随着每一次数据写入，<strong>TWIFIFOSTAT</strong> 寄存器中的 <strong>TWITXS</strong> 传输状态位都会被更新。</li>
<li>当FIFO缓存存满时，仍有数据需要写入的话，核心就会让数据等着，直到转运缓存（TRANSMIT FIFO BUFFER）由至少一个字节的空间时才能完成写入操作。</li>
</ul>
<img src="https://pic.islet.space/2021/05/20210525161210.png" alt="image-20210525155309392" style="zoom:67%;" />

<p style="text-align: center; color: gray; font-weight: 800;">图 22-7 8位传输FIFO寄存器</p>



<img src="https://pic.islet.space/2021/05/20210527133602.png" alt="image-20210527114613231" style="zoom:67%;" />







<h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><h4 id="主寄存器初始化函数"><a href="#主寄存器初始化函数" class="headerlink" title="主寄存器初始化函数"></a>主寄存器初始化函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ADAU1772_1_ADDR = <span class="number">0X3C</span>;  <span class="comment">//第一个从设备的地址是0x3C，其ADDR1和ADDR0引脚均为0；</span></span><br><span class="line">ADAU1772_2_ADDR = <span class="number">0X3D</span>;  <span class="comment">//第一个从设备的地址是0x3D，其ADDR1和ADDR0引脚为0和1；</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Master_TWI_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 预分频为 fPCLK/10 MHz</span></span><br><span class="line">	*pTWIMITR = (<span class="number">0x14</span>) | TWIEN;  <span class="comment">//0x14和0x80进行 位或操作，将结果148写入TWI主机时间寄存器中</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// CLKDIV = TWI SCL period ? 10 MHz time reference</span></span><br><span class="line">	<span class="comment">// CLKDIV = (1/100 KHz) / 100 ns = 100</span></span><br><span class="line">	<span class="comment">// For 40 - 60 duty cycle, CLKHI = 40 and CLKLOW = 60</span></span><br><span class="line"></span><br><span class="line">	*pTWIDIV = (CLKHI &lt;&lt; <span class="number">8</span>) | CLKLOW;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 需要被访问的从设备的地址</span></span><br><span class="line">	*pTWIMADDR = ADAU1772_1_ADDR; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 传送至从属设备的第一个字节数据</span></span><br><span class="line">	*pTXTWI8 = <span class="number">0x00</span>;</span><br><span class="line">    *pTXTWI8 = <span class="number">0x85</span>; <span class="comment">//(0101 0101b)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  // 配置TWIFIFOCTL寄存器，为每个数据字节(byte)生成中断</span></span><br><span class="line"><span class="comment">	*pTWIFIFOCTL = TWITXFLUSH | TWIRXFLUSH;</span></span><br><span class="line"><span class="comment">	*pTWIFIFOCTL = 0;</span></span><br><span class="line"><span class="comment">	*/</span>  <span class="comment">//暂时禁用该数据写入寄存器配置（包括中断和写入读取规则等）</span></span><br><span class="line">    *pTWIFIFOCTL = <span class="number">0x15</span>;  <span class="comment">//即（0 1111b），详细配置信息请参照《ADSP-214xx SHARC Processor Hardware Reference》</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 中断使能位，上方已经写过了，有些重复</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INTERRUPT_MODE</span></span><br><span class="line">	*pTWIIMASK |= TWITXINT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开TWI的控制寄存器</span></span><br><span class="line">	*pTWIMCTL = (N &lt;&lt; <span class="number">6</span>);  <span class="comment">//？？</span></span><br><span class="line">	*pTWIMCTL |= TWIMEN;  <span class="comment">// 打开主机模式（Master Mode enable）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="TWI-IN-MASTER-TX"><a href="#TWI-IN-MASTER-TX" class="headerlink" title="TWI IN MASTER-TX"></a>TWI IN MASTER-TX</h1><p><strong>Peripherals with Multiple Interrupt Request Signals</strong></p>
<blockquote>
<p>TWI和UART有分离的中断输出。两者都默认连接至P14I（DPI）。然而，两者都允许分离连接至默认不路由的PICR，反而提供了更多可通过DAI/DPI中断优先级更改的混合模型。</p>
<p>The TWI and the UART have separate interrupt outputs. Both peripherals are already connected via the P14I (DPI) by default. However both peripherals allow separate connectivity into the PICR that are not routed by default. This provides more flexibility for priority change across the DAI/DPI interrupts.</p>
</blockquote>
<h2 id="特性-Features"><a href="#特性-Features" class="headerlink" title="特性 Features"></a>特性 Features</h2><p>《HWR》第855页起对TWI进行了描述。</p>
<p><img src="https://pic.islet.space/2021/06/20210603140236.png" alt="image-20210603140215469"></p>
<ul>
<li>需要使用DPI进行针脚信号的路由，不能使用DAI</li>
<li>支持主从模式</li>
<li>支持数据缓存接入和核心数据接入，不支持DMA</li>
<li>最大时钟频率400KHz</li>
<li>7-bit 寻址</li>
<li>支持多播主机仲裁</li>
<li>主时钟同步和时钟低延伸支持</li>
<li>低中断速率</li>
<li>分离多字节接收和传输的FIFOs</li>
<li>在总线锁死时，对数据和时钟线的独立复写控制</li>
<li>峰值抑制的输入滤波器</li>
</ul>
<img src="https://pic.islet.space/2021/05/20210527100924.png" alt="image-20210527100834503" style="zoom: 67%;" />

<img src="https://pic.islet.space/2021/05/20210527133611.png" alt="image-20210527100951355" style="zoom:67%;" />



<h2 id="针脚描述-Pin-Descriptions"><a href="#针脚描述-Pin-Descriptions" class="headerlink" title="针脚描述 Pin Descriptions"></a>针脚描述 Pin Descriptions</h2><img src="https://pic.islet.space/2021/05/20210527102109.png" alt="image-20210527101956389" style="zoom:67%;" />

<h2 id="SRU编程-SRU-Programming"><a href="#SRU编程-SRU-Programming" class="headerlink" title="SRU编程 SRU Programming"></a>SRU编程 SRU Programming</h2><p>TWI信号可以通过 <code>SRU2</code> ，如表22-3所示进行路由。</p>
<img src="https://pic.islet.space/2021/05/20210527102114.png" alt="image-20210527102029529" style="zoom:67%;" />



<blockquote>
<p>Identify the peripherals that you are trying to connect to the SHARC DSP, and count the unique signals. List the unique I/O signals and look carefully to see what else you may be able to eliminate.</p>
<ul>
<li><p>如果时钟或帧同步连接至多个设备，算作一个信号。If the same <em><strong>clock</strong></em> or <em><strong>frame</strong></em> sync is connected to multiple devices, it counts as one signal. </p>
</li>
<li><p>如果与一个串行数据流驱动多个设备，也算作一个信号。When a <em><strong>serial data stream</strong></em> drives multiple output devices, it also counts as a single signal. </p>
</li>
<li><p>如果两个信号相同，但极性相反（倒置），算作一个信号。（因为SRU可以从另一个信号中产生任何一个）</p>
</li>
<li><p>如果一个时钟信号是另一个时钟信号的相位对齐的整数子倍数，则将它们组合在一起。</p>
</li>
</ul>
<p>大多数引脚缓冲区在给定的设计中只在一个方向上使用。请注意，许多外设都具有能够实现双向操作的引脚，但仅在系统中的一个方向上使用。当针脚缓冲区是单向的时，SRU的编程会大大简化。</p>
<p>如果针是双向的，确定方向改变的原因。这是另一个别针的状态吗？它是处理器级控制寄存器的状态吗？它是一个端口的软件配置吗？想想当SHARC将逻辑值驱动到双向针上时，以及当针刚刚读取逻辑输入时，可能会控制什么。</p>
<p><em><strong>注意</strong></em> 下图中的 <code>PBxx_O</code> / <code>PBxx_I</code> / <code>PBENxx_I</code> 。针脚缓冲器就像一个小型缓冲器放大器，可以提供足够的电流来驱动针脚和电路板上的痕迹。打开时（即当其启用输入为逻辑高时），针缓冲输入处的逻辑值被驱动到针缓冲输出上。当关闭时（即，当其启用输入为逻辑低时），缓冲器放大器为高阻抗，并且引脚缓冲器输出的逻辑电平很容易由外部源控制。引脚缓冲区是与DAI相关联的物理IC包引线的逻辑网关。</p>
<img src="https://pic.islet.space/2021/06/20210603170450.png" alt="image-20210603170447943" style="zoom: 80%;" />

<p>由于引脚缓冲器是一个片上外设，连接到物理封装上的信号被称为引脚缓冲器的输出。虽然它是SHARC的一个输入，但它是引脚缓冲器的一个输出。请注意，图1显示了两个连接的轨迹，它们被标记为 <code>PBxx_O</code>（引脚缓冲器输出）。其中一个是SRU接口的一部分，另一个是外部封装连接引脚。当引脚缓冲器被用作输入时，信号会沿着这个路径。换句话说，SRU内的引脚缓冲器输出总是等于外部引脚的逻辑值。</p>
<p>——《<em>Configuring the Signal Routing Unit of ADSP-2126x SHARC® DSPs</em>》</p>
<p><mark>只有DAI有 PBEN ，DPI只有 PB。</mark></p>
</blockquote>
<p><em>PAGE 874</em>  - <em><strong>SRU PROGRAMMING MODE</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SRU(LOW, DPI_PBxx_I); <span class="comment">/* input buffer is low */</span></span><br><span class="line">SRU(TWI_DATA_PBEN_O, DPI_PBENxx_I); <span class="comment">/* TWI data output*/</span></span><br><span class="line"><span class="comment">//SRU(DPI_PBxx_O, TWI_DATA_I); /* TWI data input */</span></span><br><span class="line"></span><br><span class="line">SRU2(LOW, DPI_PByy_I); <span class="comment">/* input buffer is low */</span></span><br><span class="line">SRU2(TWI_CLK_PBEN_O, DPI_PBENyy_I); <span class="comment">/* TWI clock output*/</span></span><br><span class="line"><span class="comment">//SRU2(DPI_PByy_O, TWI_CLK_I); /* TWI clock input*/</span></span><br></pre></td></tr></table></figure>







<p>​        </p>
<h2 id="时钟频率-Clocking"><a href="#时钟频率-Clocking" class="headerlink" title="时钟频率 Clocking"></a>时钟频率 Clocking</h2><ul>
<li>外围时钟（f<del>PCLK</del>）是TWI时钟频率的基础。</li>
<li>串行时钟频率最高400KHz，最低20KHz；其分辨率为 1/10MHz 或 100ns。</li>
</ul>
<p>分频数的计算案例如下：</p>
<img src="https://pic.islet.space/2021/05/20210527102916.png" alt="image-20210527102754286" style="zoom:67%;" />



<h2 id="功能描述-Functional-Description"><a href="#功能描述-Functional-Description" class="headerlink" title="功能描述 Functional Description"></a>功能描述 Functional Description</h2><p>下图22-1展示了TWI控制器的架构。</p>
<ul>
<li><strong>外围接口</strong>（peripheral interface）支持32位宽的数据传输，并被处理器用于支持寄存器和FIFO缓冲器的读写。</li>
<li><strong>寄存器块</strong> 包含了所有的控制和状态位，并依托程序模型来反映了可以写入或读取的内容。状态位可由其各自的（respective）功能块更新。</li>
<li><strong>FIFO缓冲器</strong> 被配置为一个1字节宽、2字节深的发送/接收FIFO缓冲器。</li>
</ul>
<img src="https://pic.islet.space/2021/05/20210527133616.png" alt="image-20210527103515471"  />

<ul>
<li><strong>发送移位寄存器</strong>（transmit shift）串行地将其数据从外部移出芯片（shift its data out externally off chip）。该输出可以被控制以产生确认，也可以被手动改写。</li>
<li><strong>接收移位寄存器</strong>（receive shift）从片外串行接收其数据（receive its data serially from off chip）。接收移位寄存器的宽度为1个字节，收到的数据可以被转移到FIFO缓冲区或用于地址比较（address comparison）。</li>
<li><strong>地址比较块</strong> （address compare block）支持在TWI控制器模块作为从机访问时的地址比较。</li>
<li><strong>预分频器块</strong> （prescaler block）必须被编程以产生一个相对于外设时钟的 <code>10MHz</code> 时间基准。这个时间基准用于过滤数据和数据表中电气参数指定的定时事件（见飞利浦的I2C总线规范），以及 <code>TWI_CLOCK</code> 的时钟信号生成。</li>
<li><strong>时钟生成模块</strong> （clock generation module）用于在主模式下生成一个外部串行时钟（<code>TWI_CLOCK</code>）。它包括在多主时钟配置中进行同步所需的逻辑，以及在从属模式下配置时的时钟拉伸。</li>
</ul>
<h3 id="时钟输出"><a href="#时钟输出" class="headerlink" title="时钟输出"></a>时钟输出</h3><p>TWI控制器的时钟输出遵循以下规则。</p>
<ol>
<li><p>一旦时钟高电平（<code>CLKHI</code>）计数完成，串行时钟输出（serial clock output）被驱动为低电平，时钟低电平（<code>CLKLOW</code>）计数开始。</p>
</li>
<li><p>一旦时钟低电平计数完成，串行时钟线被三振（three-stated），时钟同步逻辑进入延迟模式（阴影区），直到 <code>TWI_CLOCK</code> 线被检测到逻辑1电平。这时，时钟高电平计数开始。</p>
</li>
</ol>
<p><mark>TWI控制器只在主控模式运行时发出时钟，而且只在传输启动时发出</mark>。如果总线的仲裁（arbitration）丢失，串行时钟输出立即进入三态（three-states）。如果多个时钟试图驱动串行时钟线，TWI控制器将其时钟与其他剩余的时钟同步。这在图22-2中有所说明。</p>
<blockquote>
<p>The TWI controller only issues a clock during master mode operation and only at the time a transfer has been initiated.</p>
</blockquote>
<img src="https://pic.islet.space/2021/06/20210603144929.png" alt="image-20210603144317584" style="zoom:80%;" />



<p>TWI控制器遵守《<em>Philips I2C Bus Specification version 2.1 dated January 2000</em>》传输协议。图22-3是简易的TWI传输示意。</p>
<img src="https://pic.islet.space/2021/06/20210603172309.png" alt="image-20210603145223033" style="zoom:80%;" />

<p>图22-4是TWI控制器在传输过程中的寄存器映射。</p>
<img src="https://pic.islet.space/2021/06/20210603172312.png" alt="image-20210603145235075" style="zoom: 80%;" />



<h3 id="总线仲裁-Bus-Arbitration"><a href="#总线仲裁-Bus-Arbitration" class="headerlink" title="总线仲裁 Bus Arbitration"></a>总线仲裁 Bus Arbitration</h3><p>略</p>
<img src="https://pic.islet.space/2021/06/20210603145741.png" alt="image-20210603145739629" style="zoom:67%;" />

<h3 id="开始与结束情景-Start-amp-Stop-condition"><a href="#开始与结束情景-Start-amp-Stop-condition" class="headerlink" title="开始与结束情景 Start &amp; Stop condition"></a>开始与结束情景 Start &amp; Stop condition</h3><p>略</p>
<p>​    </p>
<h2 id="操作模式-Operating-Modes"><a href="#操作模式-Operating-Modes" class="headerlink" title="操作模式 Operating Modes"></a>操作模式 Operating Modes</h2><h3 id="通用呼叫寻址-General-Call-Addressing"><a href="#通用呼叫寻址-General-Call-Addressing" class="headerlink" title="通用呼叫寻址 General Call Addressing"></a>通用呼叫寻址 General Call Addressing</h3><p>如果TWI控制器被启用为从机（TWISEN），并且使用TWIGCE位启用了一般呼叫，则TWI控制器总是解码并确认一般呼叫地址。一般呼叫寻址（0x00）由GCALL位的设置表示，根据传输的性质，TWI控制器是一个从属接收者。如果与传输相关的数据不被确认（NAKed），TWINAK位可以被设置。</p>
<p>如果TWI控制器作为主发射器发出一个总调用，可以设置适当的地址和传输方向，同时加载发送FIFO数据。</p>
<blockquote>
<p>The TWI controller always decodes and acknowledges a general call address if it is enabled as a slave (TWISEN) and if general call is enabled using the TWIGCE bit. General call addressing (0x00) is indicated by the setting of the GCALL bit, and by the nature of the transfer, the TWI controller is a slave-receiver. If the data associated with the transfer is to be not acknowledged (NAKed), the TWINAK bit can be set.</p>
<p>If the TWI controller is to issue a general call as a master-transmitter, the appropriate address and transfer direction can be set along with loading transmit FIFO data.</p>
</blockquote>
<h3 id="从设备模式寻址-Slave-Mode-Addressing"><a href="#从设备模式寻址-Slave-Mode-Addressing" class="headerlink" title="从设备模式寻址 Slave Mode Addressing"></a>从设备模式寻址 Slave Mode Addressing</h3><blockquote>
<p>With the appropriate selection of 7-bit addressing using the TWISLEN bit, the corresponding number of address bits (SADDR) are referenced during the address phase of a transfer.</p>
</blockquote>
<h3 id="主设备模式寻址-Master-Mode-Addressing"><a href="#主设备模式寻址-Master-Mode-Addressing" class="headerlink" title="主设备模式寻址 Master Mode Addressing"></a>主设备模式寻址 Master Mode Addressing</h3><p>无论是启用主发送器还是使用 <em><strong>TWIMLEN</strong></em> 位进行7位寻址的主接收器，TWI主站都会按要求执行所有寻址和数据传输。这包括产生重复启动条件，重新传输第一个地址字节的7位，以及确认和产生一个新的传输方向变化（由 <em><strong>TWIMLEN</strong></em> 位指示）。</p>
<blockquote>
<p>Whether enabled as a master-transmitter or master-receiver with 7-bit addressing using the <em><strong>TWIMLEN</strong></em> bit, the TWI master performs all addressing and data transfers as required. This includes generating the repeated start condition, re-transmission of the 7-bits of the first address byte, and acknowledgement and generation of a new transfer direction change (indicated by the <em><strong>TWIMLEN</strong></em> bit). </p>
</blockquote>
<h3 id="快速模式-Fast-Mode"><a href="#快速模式-Fast-Mode" class="headerlink" title="快速模式 Fast Mode"></a>快速模式 Fast Mode</h3><blockquote>
<p>Fast mode (400 kHz) uses essentially the same mechanics as standard mode (100 kHz). It is the electrical specifications and timing that are different. When fast mode is enabled using the <em><strong>TWIFAST</strong></em> bit, the following timings are modified to meet the electrical requirements.</p>
<ul>
<li>Serial data rise times before arbitration evaluation (tr)</li>
<li>Stop condition setup time from serial clock to serial data (tSUSTO)</li>
<li>Bus free time between a stop and start condition (tBUF)</li>
</ul>
</blockquote>
<h2 id="数据传输-Data-Transfer"><a href="#数据传输-Data-Transfer" class="headerlink" title="数据传输 Data Transfer"></a>数据传输 Data Transfer</h2><p>PAGE867:</p>
<p>数据传输部分介绍 <strong>3个寄存器</strong>、<strong>4个缓冲区域</strong> 和 <strong>3个缓存状态</strong>。</p>
<h3 id="寄存器-Register"><a href="#寄存器-Register" class="headerlink" title="寄存器 Register"></a>寄存器 Register</h3><p><strong>Serial Shift Register</strong>： TWI有一个输入和输出的串行移位器，下面将介绍。</p>
<p><strong>Output Shift Register</strong>： 发送移位寄存器接收字节宽的缓冲区数据或寄存器数据（地址），并将其数据从外部串行移出芯片。该输出可以被控制以产生确认信号，也可以被手动改写。</p>
<p><strong>Input Shift Register</strong>： 接收移位寄存器从芯片外串行地接收数据。在内部，接收移位寄存器是字节宽的，收到的数据可以被转移到缓冲区或用于地址比较。</p>
<h3 id="缓存区域-Buffer"><a href="#缓存区域-Buffer" class="headerlink" title="缓存区域 Buffer"></a>缓存区域 Buffer</h3><p>TWI有多个用于8位和16位数据的接收和发送数据缓冲区，每个缓冲区都是独立访问的，可以同时访问。</p>
<p>例如，在接收移位寄存器向接收缓冲区写入数据的同时，可以向发送缓冲区写入数据。</p>
<p><strong>8-Bit Transmit Buffer</strong>： </p>
<p><strong>16-Bit Transmit Buffer</strong>： </p>
<p><strong>8-Bit Receive Buffer</strong>： </p>
<p><strong>16-Bit Receive Buffer</strong>： </p>
<h3 id="缓存状态-Buffer-Status"><a href="#缓存状态-Buffer-Status" class="headerlink" title="缓存状态 Buffer Status"></a>缓存状态 Buffer Status</h3><p><strong>Buffer Error</strong>： </p>
<p><strong>Flushing the Buffer</strong>： </p>
<p><strong>Buffer Hang Disable</strong>： </p>
<h2 id="中断-Interrupt"><a href="#中断-Interrupt" class="headerlink" title="中断 Interrupt"></a>中断 Interrupt</h2><img src="https://pic.islet.space/2021/05/20210527133619.png" alt="image-20210527104039047" style="zoom:67%;" />

<h3 id="中断源"><a href="#中断源" class="headerlink" title="中断源"></a>中断源</h3><h2 id="Effect-Latency"><a href="#Effect-Latency" class="headerlink" title="Effect Latency"></a>Effect Latency</h2><h2 id="编程模型-Programming-Model"><a href="#编程模型-Programming-Model" class="headerlink" title="编程模型 Programming Model"></a>编程模型 Programming Model</h2><h2 id="电气特性-Electrical-Specifications"><a href="#电气特性-Electrical-Specifications" class="headerlink" title="电气特性 Electrical Specifications"></a>电气特性 Electrical Specifications</h2><h2 id="调试特征-Debug-Feature"><a href="#调试特征-Debug-Feature" class="headerlink" title="调试特征 Debug Feature"></a>调试特征 Debug Feature</h2><h3 id="Masking"><a href="#Masking" class="headerlink" title="Masking"></a>Masking</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bit <span class="built_in">set</span> IMASK P14I; <span class="comment">/* unmasks P14I interrupt */</span></span><br><span class="line">ustat1=dm(DPI_IMASK_RE); <span class="comment">/* set TWI Int */</span></span><br><span class="line">bit <span class="built_in">set</span> ustat1 TWI_INT;</span><br><span class="line">dm(DPI_IMASK_RE)=ustat1;</span><br></pre></td></tr></table></figure>







<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TWI_ISR:</span><br><span class="line">ustat1 = dm(TWIIRPTL); <span class="comment">/* read IRPTL to identify cause*/</span></span><br><span class="line">bit TST ustat1 TWITXINT; <span class="comment">/* test TX buffer bit*/</span></span><br><span class="line">IF TF jump TX_BUF;</span><br><span class="line"></span><br><span class="line">TX_BUF:</span><br><span class="line">dm(TWIIRPTL) = ustat1; <span class="comment">/* RW1C to clear TWI TX buffer </span></span><br><span class="line"><span class="comment"> interrupt */</span></span><br><span class="line">r0=dm(TWIMCTL); <span class="comment">/* dummy read*/</span></span><br><span class="line">instruction;</span><br><span class="line">rti;</span><br></pre></td></tr></table></figure>



<h2 id="主设备发送模式"><a href="#主设备发送模式" class="headerlink" title="主设备发送模式"></a>主设备发送模式</h2><p>以下为单主机传输模式的的编程过程：</p>
<ol>
<li>Program the <code>TWIMADDR</code> register. <ul>
<li>This defines the address transmitted during the address phase of the transfer.</li>
</ul>
</li>
<li>Program the <code>TXTWI8</code> or <code>TXTWI16</code> registers. <ul>
<li>This is the initial data transmitted. </li>
<li>It is considered an error to complete the address phase of the transfer and not have data available in the transmit FIFO buffer. </li>
</ul>
</li>
<li>Program the <code>TWIFIFOCTL</code> register. <ul>
<li>Indicate if transmit FIFO buffer interrupts should occur with each byte transmitted (8 bits) or with each 2 bytes transmitted (16 bits). </li>
</ul>
</li>
<li>Program the <code>TWIIMASK</code> register. <ul>
<li>Enable the bits associated with the desired interrupt sources. </li>
<li>For example, programming the value <code>0x0030</code> results in an interrupt output to the processor when the master transfer completes, or if a master transfer error has occurred. </li>
</ul>
</li>
<li>Program the <code>TWIMCTL</code> register. <ul>
<li>This prepares and enables master mode operation. </li>
<li>As an example, programming the value <code>0x0201</code> enables master mode operation, generates a 7-bit address, sets the direction to master-transmit, uses standard mode timing, and transmits 8 data bytes before generating a stop condition. </li>
</ul>
</li>
</ol>
<img src="https://pic.islet.space/2021/05/20210527105334.png" alt="image-20210527104628291" style="zoom:67%;" />







<h2 id="TWI物理接口（引脚）确定"><a href="#TWI物理接口（引脚）确定" class="headerlink" title="TWI物理接口（引脚）确定"></a>TWI物理接口（引脚）确定</h2><p>TWI物理引脚的确定请参考另一篇文章《AnalogDeviceSigmaStudio》，以下为ADI官方提供的TWI物理引脚定义代码样例。</p>
<p>需要注意的是，在实操时，若使用DPI_12作为SCL，会出现12引脚因 SW （Switch）调整不到位或其他原因导致无法使用该引脚，可更换其他引脚进行使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitSRU</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SRU(LOW, DPI_PB11_I);				<span class="comment">//定义DPI_PB11为数据输出引脚，即SDA，TWI针脚连接至逻辑电平0，TWI输出是open-drain输出</span></span><br><span class="line">	SRU(TWI_DATA_PBEN_O, DPI_PBEN11_I); <span class="comment">//TWI数据输出连接至DPI_11输入</span></span><br><span class="line">	SRU(DPI_PB11_O, TWI_DATA_I);		<span class="comment">//DPI_11输出连接至TWI数据输入</span></span><br><span class="line">										<span class="comment">//TWI设备不论主从，其数据口SDA都需要双向发送和接收，因为主设备在发送的时候也需要接收从设备发过来的ACK确认信标</span></span><br><span class="line"></span><br><span class="line">	SRU(LOW, DPI_PB12_I);				<span class="comment">//定义DPI_PB12为时钟输出引脚，即SDA，TWI针脚连接至逻辑电平0，TWI输出是open-drain输出</span></span><br><span class="line">	SRU2(TWI_CLK_PBEN_O, DPI_PBEN12_I); <span class="comment">//TWI时钟输出，连接至DPI_12输入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>即 <strong>DPI_P11</strong> 为 <em><strong>SDA</strong></em>，<strong>DPI_P12</strong> 为 <em><strong>SCLK</strong></em>。（已更新为其他引脚）</p>
 <img src="https://pic.islet.space/2021/05/20210527144920.png" alt="image-20210524112141809" style="zoom:67%;" />









<h2 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h2><blockquote>
<p>The PLLD bits define the VCO output clock to core clock ratio to build the processor core clock (CCLK). The post divider can be changed any time and new division ratios are implemented on the fly.</p>
</blockquote>
<blockquote>
<p>The PCLK and CLKIN clocks are used in the arbitration logic for the shared external bus.</p>
</blockquote>
<blockquote>
<p>The PLL bit settings PLLM/PLLD in PMCTL register need to be programmed such that the PLLM/PLLD ratio is integer (for example 15/2=7.5 fractional, is not allowed).</p>
</blockquote>
<h3 id="IOP-Clock-PCLK"><a href="#IOP-Clock-PCLK" class="headerlink" title="IOP Clock (PCLK)"></a>IOP Clock (PCLK)</h3><p>The <em><strong>peripheral clock</strong></em> is derived from the <em><strong>core clock</strong></em> with <em><strong>a fixed post divisor of 2</strong></em>. </p>
<p>This clock is the <em><strong>master clock for</strong></em> most peripherals including the <em><strong>I/O processor</strong></em> (IOP).</p>
<h1 id="Interrupt-Control-of-PINs"><a href="#Interrupt-Control-of-PINs" class="headerlink" title="Interrupt Control of PINs"></a>Interrupt Control of PINs</h1><p><em>Page93</em>：</p>
<blockquote>
<p>For information on the IRPTL, LIRPTL, and IMASK registers, see <em>SHARC Processor Programming Reference</em>.</p>
</blockquote>
<p>下表2-1介绍了经过DAI和DPI的数据通道：</p>
<ul>
<li>DAI共有32个通道（22个外围设备通道，10个miscellaneous通道），DPI共有12个通道（3个外围设备通道，9个miscellaneous通道）</li>
<li>DAI允许设置优先级，而DPI不允许</li>
<li>DAI和DPI都能识别上升沿（Rising Edge）或下降沿（Falling Edge）</li>
<li>到核心的中断（Interrupt to Core)，DAI为2，DPI为1</li>
<li>DAI和DPI都是4分频</li>
</ul>
<p><img src="https://pic.islet.space/2021/06/20210602150124.png" alt="image-20210602150117965"></p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul>
<li><p>两个系统中断控制器（SIC, System Interrupt Controller），分别为DAI SIC 和 DPI SIC，连接至核心中断控制器（CIC, Core Interrupt Controller）。</p>
</li>
<li><p>DAI SIC 允许高/低中断优先级配置选项</p>
</li>
<li><p>DAI中断控制器提供最高32条独立可配置通道</p>
</li>
<li><p>DPI中断控制器提供最高12条独立可配置通道</p>
</li>
<li><p>DAI SIC和DPI SIC都允许针对波形的上升沿或下降沿进行锁存</p>
</li>
<li><p>与核心锁存中断一致的中断延迟</p>
</li>
<li><p>时钟：系统中断控制器的基础时钟是 <em>4分频</em> (f<del>PCLK</del>)/4 ；所有中断的确认响应速度为4分频最高。</p>
</li>
</ul>
<h2 id="中断寄存器"><a href="#中断寄存器" class="headerlink" title="中断寄存器"></a>中断寄存器</h2><p><strong>可编程中断控制寄存器</strong>（<strong>PICR</strong>3 - 0）： 为了登记（assign）独立优先级（individual priorities）到各外围通道，19个外围设备可路由至可编程中断输入。</p>
<p><strong>DAI 中断屏蔽寄存器</strong>（<strong>DAI_IMASK</strong>）：屏蔽上升或下降沿波形。因可屏蔽的边沿有上升沿或下降沿，因此DAI中断屏蔽寄存器分为 DAI_IMASK_RE 和  DAI_IMASK_FE。</p>
<p><strong>DAI 中断屏蔽优先级寄存器</strong>（<strong>DAI_IMASK_PRI</strong>）：为DAI高/低中断优先级屏蔽中断。</p>
<p><strong>DAI 中断锁存寄存器</strong>（<strong>DAI_IRPTL</strong>）: 为DAI高/低优先级中断锁存中断。</p>
<p><strong>DPI 中断屏蔽寄存器</strong>（<strong>DPI_IMASK</strong>）：屏蔽上升或下降沿波形。因可屏蔽的边沿有上升沿或下降沿，因此DPI中断屏蔽寄存器分为 DPI_IMASK_RE 和  DPI_IMASK_FE。</p>
<p><strong>DPI 中断锁存寄存器</strong>（<strong>DPI_IRPTL</strong>）：为DPI中断锁存中断。</p>
<p><img src="https://pic.islet.space/2021/06/20210603134601.png" alt="image-20210603134437928"></p>
<p><img src="https://pic.islet.space/2021/06/20210603134603.png" alt="image-20210603134453465"></p>
<h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><h3 id="可编程中断优先级控制"><a href="#可编程中断优先级控制" class="headerlink" title="可编程中断优先级控制"></a>可编程中断优先级控制</h3><h4 id="外围中断"><a href="#外围中断" class="headerlink" title="外围中断"></a>外围中断</h4><h4 id="软件中断"><a href="#软件中断" class="headerlink" title="软件中断"></a>软件中断</h4><h4 id="多重中断请求信号的外围设备"><a href="#多重中断请求信号的外围设备" class="headerlink" title="多重中断请求信号的外围设备"></a>多重中断请求信号的外围设备</h4><h3 id="系统中断控制器"><a href="#系统中断控制器" class="headerlink" title="系统中断控制器"></a>系统中断控制器</h3><p>DAI/DPI外围相关事件发生时，这些针脚各自拥有能够指向核心的系统中断控制器。</p>
<p>相对于SHARC核心，音频事件通常发生不频繁，DAI/DPI中断控制器将其所有中断减少到核心主中断系统中的三个中断信号上：</p>
<ul>
<li>一个映射为DAI低优先级</li>
<li>一个映射为DAI高优先级</li>
<li>第三个映射到DPI中断。</li>
</ul>
<p>以上这种操作，允许程序更加粗略地去表示优先级。</p>
<p>输出总线中断信号可以有逻辑地导向（ORed）一个中断线并递交至（fed to）核心中断控制逻辑。</p>
<blockquote>
<p>The output bus interrupt signals are logically ORed into one interrupt line and fed to the core’s interrupt controller logic.</p>
</blockquote>
<p><img src="https://pic.islet.space/2021/06/20210602155414.png" alt="image-20210602154656729"></p>
<p><strong>注意</strong>：DAI/DPI中断控制器拥有与核心中断控制器相同的中断延迟，或6个延时周期以相应异步中断。</p>
<p>被用于配置DAI中断控制器的有3个寄存器，被用于配置DPI中断控制器的有2个寄存器。32个DAI中断源和12个DPI中断源中的任意一个都可以用于独立配置开关，来控制进入信号的上升沿、下降沿、上升下降沿（both edges）或无沿（neither edge）。</p>
<p>需要注意的是，当核心中断寄存器是系统寄存器时，DAI/DPI中断控制寄存器是被内存映射的寄存器（memory mapped registers），且通过外围设备总线被接入（accessed via the peripheral bus）。</p>
<h4 id="DAI-DPI中断源"><a href="#DAI-DPI中断源" class="headerlink" title="DAI/DPI中断源"></a>DAI/DPI中断源</h4><p>DAI有5个外围（中断）源都被多路复用至（multiplexed into）32个中断源里，并以 <code>DAI_INT 0 ~ 31</code> 作为标签名称。</p>
<p>DPI有3个外围（中断）源都被多路复用至（multiplexed into）12个中断源里，并以 <code>DPI_INT 0 ~ 13</code> 作为标签名称。</p>
<p>下表介绍了DAI/DPI在不同的通信方式和信号响应的关系。</p>
<img src="https://pic.islet.space/2021/06/image-20210602195334432.png" alt="image-20210602195334432" style="zoom:67%;" />



<h4 id="DAI中断锁存优先级设置"><a href="#DAI中断锁存优先级设置" class="headerlink" title="DAI中断锁存优先级设置"></a>DAI中断锁存优先级设置</h4><p>DAI系统中断控制器寄存器对（ <code>DAI_IRPTL_H</code> 和 <code>DAI_IRPTL_L</code>）取代了通常由核心中断控制器的IRPTL寄存器执行的功能。一个单一的寄存器（ <code>DAI_IRPTL_PRI</code>）指定了这些中断被映射到哪个锁存器中。</p>
<p>当一个DAI中断被配置为低优先级（<code>DAI_IMASK_PRI</code> 位被清除，默认设置），它将被锁在 <code>DAI_IRPTL_L</code> 寄存器中。低优先级的DAI中断，<code>DAILI</code>，被连接到 <code>P12I</code> 核心中断上。默认情况下。<code>PICR</code> 寄存器可以改变这种连接。每当DAI的低优先级中断被设置，<code>LIRPTL </code>寄存器中的 <code>DAILI</code> 位就会被设置，核心就会为该低优先级中断服务。</p>
<img src="https://pic.islet.space/2021/06/image-20210602200433030.png" alt="image-20210602200433030" style="zoom:67%;" />

<p><strong>注意</strong>： DAI会在<strong>中断向量表</strong>中触发一个高优先级一个低优先级的中断。当任一来自DAI的中断需要服务时，两个核心ISR之一必须审查（interrogate）DAI的中断控制器以判定其中断源。</p>
<blockquote>
<p>中断向量表（Interrupt Vector Table, IVT）, Page 177</p>
<img src="https://pic.islet.space/2021/06/image-20210602205507981.png" alt="image-20210602205507981" style="zoom:67%;" />
</blockquote>
<h4 id="DPI中断锁存"><a href="#DPI中断锁存" class="headerlink" title="DPI中断锁存"></a>DPI中断锁存</h4><p>DPI系统中断控制寄存器（<code>DPI_IRPTL</code>）取代了通常是由核心控制器寄存器（<code>IRPTL</code>）的功能。</p>
<p>当DPI中断配置时，将被锁存在 <code>DPI_IRPTL</code> 寄存器中。默认情况下，DPI中断被连接至P14I核心中断。PICR寄存器可以改变其连接。无论何时，DPI中断一旦设置，<code>LIRPTL</code> 寄存器中已编程的DPI位会被设置，且核心将会为已编程优先级的中断服务。</p>
<h4 id="DAI-DPI边沿触发中断屏蔽"><a href="#DAI-DPI边沿触发中断屏蔽" class="headerlink" title="DAI/DPI边沿触发中断屏蔽"></a>DAI/DPI边沿触发中断屏蔽</h4><p>DAI上升沿中断屏蔽寄存器 <code>DAI_IMASK_RE</code> 和 DAI下降沿中断屏蔽寄存器 <code>DAI_IMASK_FE</code> 取代了核心中断控制器 <code>IMASK</code> 的版本。与 <code>IMASK</code> 寄存器一样，这些DAI寄存器提供了一种指定（specify）哪条中断被确认和处理，哪条中断会被忽略的方法。这对寄存器的功能与 <code>IMASK</code> 一致，但具有更高程度的细化。</p>
<p>对 <code>DAI_IMASK_RE</code> 、 <code>DAI_IMASK_FE</code> 、 <code>DPI_IMASK_RE</code>  、<code>DPI_IMASK_FE</code>这些寄存器的使用，能够使程序对上升沿、下降沿、上升下降沿、或者无沿（neither rising or falling edge）的程序确认或响应能够分别独立地屏蔽（masked separately）。</p>
<p>从SRU过来的信号能够被用于生成中断。例如，当 <code>DAI_IMASK_FE</code> 寄存器的 <code>DAI_30_INT</code> 位被设置为1时，任何从外部通道过来的下降沿信号都能在核心中生成中断，且中断锁存器会被设定。对 <code>MASK</code> 寄存器的读取不会清除 <code>IRPTL</code> 寄存器。</p>
<h4 id="DAI-DPI事件中断屏蔽"><a href="#DAI-DPI事件中断屏蔽" class="headerlink" title="DAI/DPI事件中断屏蔽"></a>DAI/DPI事件中断屏蔽</h4><p>系统中断控制器需要一个外设的中断源与事件信号相对应的信息（参考第2-8页中的表2-2）。如此一来，就只有上升沿被当做中断源。对于被标记为事件的DAI/DPI外设，程序可以只在上升沿解除中断源的屏蔽。</p>
<h4 id="DAI-DPI中断服务"><a href="#DAI-DPI中断服务" class="headerlink" title="DAI/DPI中断服务"></a>DAI/DPI中断服务</h4><p>当多通道被复用至一个中断输出信号时，中断确认的操作方式不尽相同。当DAI/DPI中的服务必须被处理时，三者任一的中断服务程序（interrupt service routines）（<code>DAILI</code>, <code>DAIHI</code> 和 <code>DPII</code>）必须查询RIC以确定中断源。该中断源可能是一个或多个DAI/DPI通道（<code>DAI_INT31-0</code> 、 <code>DPI_INT13-0</code>）。</p>
<ul>
<li>当 <code>DAI_IRPTL_H</code> 被读取时，高优先级锁存的中断将会被清除。</li>
<li>当 <code>DAI_IRPTL_L</code> 被读取时，低优先级锁存的中断将会被清除。</li>
<li>当 <code>DPI_IRPTL</code> 被读取时，锁存中断将会被清除。</li>
<li>当 <code>DAI_IRPTL_H/L</code> 寄存器被读取时， <code>IDP_FIFO_GTN_INT</code> 中断不会被清除。当中断需要离开的情况发生时，中断自然会被清除。（This interrupt is cleared automatically when the situation that caused the interrupt goes away.）</li>
<li><code>DPI_IRPTL_SH</code> 是被用于读取主寄存器 <code>DPI_IRPTL</code>的影子寄存器。读取这些影子寄存器将会返回 <code>DPI_IRPTL</code> 寄存器中的数据却不会清除里面的内容。</li>
</ul>
<p>如果在清空锁存器的同一周期内发生中断，则该机制的优先级较低，新的中断器被注册。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>TWII 和UARTRXI 中断不遵循这条原则。确认信号将在这些外围锁存器中发生。</li>
<li>读取中断锁存器（<code>DAI_IRPTL_X</code> 或 <code>DPI_IRPTL</code> ）将会清除中断（只读清除类型）。因此，ISR必须为所有已发现的中断提供服务。即如果复用中断（mumtiple interrupts）被锁存在复用屏蔽寄存器（multiple mask registers）中，必须在执行 <em><strong>RTI</strong></em> 指令前，对所有中断进行服务。</li>
</ul>
<blockquote>
<p><strong>RTI</strong> （(interrupt) return instruction）：中断返回指令</p>
<p>在中断服务程序中用于返回中断指令，在运行中断之前，用JSR指令将PC（程序计数器）和SR（状态寄存器）压入堆栈，当中断服务程序结束时，执行RTI或RTIS指令，将PC和SR从堆栈中弹出。</p>
<p>——<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/RTI/7461669">RTI</a></p>
</blockquote>
<h3 id="中断服务"><a href="#中断服务" class="headerlink" title="中断服务"></a>中断服务</h3><p>中断服务部分主要描述了中断服务程序操作（interrupt service routines operate）如何正确清除中断请求。</p>
<p>中断驱动I/O是较为有利（advantageous）的，因为核心并不需要去轮询（poll）输入信号。当一次中断触发时，定序器（sequencer）通常会完成其现有的指令并跳转至中断向量表（IVT）。（向量）地址（the address）通常会从向量表里指向ISR程序。定序器（sequencer）跳转至该程序，完成程序执行并通过执行RTI指令退出程序。然而，这条规则并不对所有情况适用，在ISR程序中，有三种中断确认机制，均取决于外围设备：</p>
<ul>
<li>RTI指令</li>
<li>只读清除（ROC）状态位 + RTI指令</li>
<li>写1清除（W1C，Write-1-to-clear）状态为 + RTI指令</li>
</ul>
<p><mark>锁存器必须在被读取的时候清除中断源</mark>，因此DAI/DPI被设计来正确地执行此项工作。需要注意的是，锁存器读取操作会在退出中断程序（exiting an interrupt routine）前自动确认请求（automatically acknowledges the request）。在W1C机制，程序必须写入锁存器的特定位（specific bit）以正确清除中断（terminate the interrupt properly）。</p>
<p><strong>注意</strong>：如果确认机制没有被正确遵守，中断将可能在未可预知且频率不定（unwanted and sporadic）的情况下发生。</p>
<h4 id="核心缓存服务请求（输入输出模式）"><a href="#核心缓存服务请求（输入输出模式）" class="headerlink" title="核心缓存服务请求（输入输出模式）"></a>核心缓存服务请求（输入输出模式）</h4><p>如果数据流外围设备通过核心访问各自DMA FIFO的数据缓存，则缓存（器）在中断确认过程中发挥着重要作用。</p>
<p>例如，一个接收缓存已满，中断生成时ISR中的缓存被读取，就会触发清除请求（ROC + RTI）。同样的，如果一个传输缓存已空，中断生成时，写入操作将会清除请求（WOC + RTI）。</p>
<h4 id="DMA接入"><a href="#DMA接入" class="headerlink" title="DMA接入"></a>DMA接入</h4><p>如果外设通过DMA访问缓冲区，逻辑操作就不同了。在DMA中，缓存状态对中断没有影响。相反，每当DMA计数寄存器达到0时就会产生一个中断。不同的外围设备所使用的中断确认机制都不同。</p>
<blockquote>
<p><strong>DMA</strong> Direct Memory Access 直接内存访问</p>
<p>是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。否则，CPU 需要从来源把每一片段的资料复制到暂存器，然后把它们再次写回到新的地方。在这个时间中，CPU 对于其他的工作来说就无法使用。</p>
</blockquote>
<h3 id="中断延迟"><a href="#中断延迟" class="headerlink" title="中断延迟"></a>中断延迟</h3><p>优秀的编程会要求一条（完整的）中断服务 <em>确认</em> 中断请求尽可能简洁地返回至外围设备。这种（中断）响应允许外围设备尽可能快地感知到其他事件。</p>
<p>此（中断确认）服务程序（routine）必须去确保（中断）请求在RTI指令执行前被释放，否则（中断）服务程序会在执行完RTI指令后被立即调用。</p>
<p>有些中断请求通过W1C操作来清除，该写入指令并没有让核心停滞（stall the core）。相反，该操作被自动锁存在写缓存中，并在被发送至外围总线前会通过外围时钟（<em><strong>PCLK</strong></em>）进行同步。</p>
<p>在W1C操作到达外围设备前，此操作可能会需要多个 <em><strong>CCLK</strong></em> 周期（cycles）。如果 W1C 操作在服务程序的结束点进行操作，一个 dummy 读取操作需要在RTI指令前被执行，以确保外围设备能够在RTI之前释放请求。</p>
<p>下列案例描述了中断延迟：</p>
<ul>
<li>对于具有W1C确认机制的外设来说，写入外设的状态寄存器以清除中断会导致一定的延迟（因为寄存器的写入效应延迟）。</li>
<li>中断驱动的数据传输（核心或DMA）来自任何产生中断和使用ISR程序（routine）的外设，写入外设数据缓冲区（以清除中断）或控制寄存器会导致一定的延迟（因为存在寄存器写入效果延迟和缓冲区时钟域）。</li>
</ul>
<p>如果像案例所示，程序在延迟的周期内（最多10个CCLK周期），程序从中断服务程序（RTI指令）中生成，中断再次出现。为了避免中断多次出现，需要采取下列其中一种措施：（<strong>注意</strong>：中断再生的限制（interrupt regeneration restriction）不适用于DMA操作模式下的任何SPORT。）</p>
<ol>
<li><strong>在中断返回（RTI）前，从相同的外围区块中读取IOP寄存器。读取操作（的同时）会强制写入，如下列样例所示。</strong></li>
</ol>
<p><strong>SPI中断服务程序</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R0 &#x3D; dm(i0,m0);</span><br><span class="line">dm(TXSPI) &#x3D; R0; &#x2F;&#x2F; 写入SPI数据缓存</span><br><span class="line">R0 &#x3D; dm(SPICTL); &#x2F;* this dummy read forces the previous write to complete *&#x2F;</span><br><span class="line">rti;</span><br></pre></td></tr></table></figure>

<p><strong>PWM中断服务程</strong>序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r1 &#x3D; PWM_STAT3;</span><br><span class="line">dm(PWMGSTAT)&#x3D;r1; &#x2F;* W1C to PWM status reg *&#x2F;</span><br><span class="line">r0&#x3D;dm(PWMGSTAT); &#x2F;* this dummy read forces the previous write to complete *&#x2F;</span><br><span class="line">rti;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>在写入操作后添加足够的NOP指令。在最坏的情况下，程序需要在写入后添加10条NOP指令，如下面的示例代码所示。</strong></li>
</ol>
<p><strong>中断服务程序</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R0 &#x3D; 0x0;</span><br><span class="line">dm(SPICTL) &#x3D; R0; &#x2F;* or disable SPI control *&#x2F;</span><br><span class="line">nop; nop; nop; nop; nop; </span><br><span class="line">nop; nop; nop; nop; nop; </span><br><span class="line">rti;</span><br></pre></td></tr></table></figure>



<h4 id="DMA完成类型"><a href="#DMA完成类型" class="headerlink" title="DMA完成类型"></a>DMA完成类型</h4><p>在SHARC处理器中，中断在内部传输完成（此时DMA计数器过期（expired））后被生成。但是，在某些案例中，传输可能尚未完成（不同通道优先级的原因）且有效的数据仍然存在于（resides in）外设的缓冲区中等待着被传输。为了解决此问题，引入了中断访问完成模式（interrupt access completion mode），在此模式下，上一个数据离开缓存时，中断会被生成。此模式可用于 SPORT 、 SPI 、 连接口 和 外部接口DMA。</p>
<h2 id="调试特征"><a href="#调试特征" class="headerlink" title="调试特征"></a>调试特征</h2><h4 id="影子中断寄存器"><a href="#影子中断寄存器" class="headerlink" title="影子中断寄存器"></a>影子中断寄存器</h4><ul>
<li><p>影子中断寄存器（Shadow Interrupt Register）可用于 IDP, S/PDIF, ASRC, UART, TWI 和 DAI/DPI。</p>
</li>
<li><p>DAI/DPI 中断控制器拥有可以简化调试活动且不会操纵状态控制（manipulate status control）的影子寄存器。</p>
</li>
<li><p>任何对 <code>DAI_IRPTL_x_SH</code> 或 <code>DPI_IRPTL_SH</code> 影子寄存器的读取都会提供 和 读取 <code>DAI_IRPTL_x</code> 或 <code>DPI_IRPTL</code> 寄存器一样的数据。</p>
</li>
<li><p>对DAI/DPI影子寄存器的读取不会改变核心中断控制器（core interrupt controller）对中断的确认状态。</p>
</li>
</ul>
<h2 id="术语总结"><a href="#术语总结" class="headerlink" title="术语总结"></a>术语总结</h2><p>中断确认</p>
<p>中断请求</p>
<p>中断服务</p>
<p>中断延迟</p>
<h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><h2 id="LATENCY"><a href="#LATENCY" class="headerlink" title="LATENCY"></a>LATENCY</h2><h3 id="TWI-效果延迟（时间）"><a href="#TWI-效果延迟（时间）" class="headerlink" title="TWI 效果延迟（时间）"></a>TWI 效果延迟（时间）</h3><p>在TWI寄存器设置后，其效果延迟大概是 1.5到2个PCLK周期。</p>
<p><img src="https://pic.islet.space/2021/05/20210525153905.png" alt="image-20210525153855627"></p>
<h2 id="ASM-“NOP”"><a href="#ASM-“NOP”" class="headerlink" title="ASM(“NOP”)"></a>ASM(“NOP”)</h2><p>[blog.csdn.net](<a target="_blank" rel="noopener" href="https://blog.csdn.net/Mr_White01/article/details/68488802#:~:text=asm">https://blog.csdn.net/Mr_White01/article/details/68488802#:~:text=asm</a> (“nop”)是内嵌汇编做空指令延时用的，其中asm ()的作用是指函数内部的参数翻译为汇编指令，其作用是在C语言环境下直接使用汇编指令执行。 nop是一个空等待汇编指令，这个指令执行时，单片机是什么也不做，仅仅起一个时间延时作用。,CC2530属于8051系列单片机，asm (“nop”)执行的是一条空指令（单周期指令），占用时间是一个机器周期，晶振为32Mhz。 于是，机器周期%3D12*1%2F32%3D0.375us。 即一句asm (“nop”)延时了0.375us。)</p>
<h3 id="asm-作用"><a href="#asm-作用" class="headerlink" title="asm()作用"></a>asm()作用</h3><p>将函数内部的参数翻译为汇编指令，在C语言环境下直接使用汇编指令执行。</p>
<ul>
<li><p><code>asm(&quot;nop&quot;)</code>是内嵌汇编做空指令延时用的；</p>
</li>
<li><p><code>nop</code>是一个空等待汇编指令，这个指令执行时，单片机是什么也不做，仅仅起一个时间延时作用。 </p>
</li>
</ul>
<blockquote>
<p>CC2530属于8051系列单片机，asm(“nop”)执行的是一条空指令（单周期指令），占用时间是一个机器周期，晶振为32Mhz。 </p>
<p>于是，机器周期=12*1/32=0.375us ; 即一句asm(“nop”)延时了0.375us。</p>
</blockquote>
<h3 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h3><p>时钟周期也称为振荡周期，定义为时钟脉冲的倒数(可以这样来理解，时钟周期就是单片机外接晶振的倒数，例如12M的晶振，它的时间周期就是1/12 us)，是计算机中最基本的、最小的时间单位。 </p>
<p>在一个时钟周期内，CPU仅完成一个最基本的动作。对于某种单片机，若采用了1MHZ的时钟频率，则时钟周期为1us;若采用4MHZ的时钟频率，则时钟  周期为250us。由于时钟脉冲是计算机的基本工作脉冲，它控制着计算机的工作节奏(使计算机的每一步都统一到它的步调上来)。显然，对同一种机型的计算机，时钟频率越高，计算机的工作速度就越快。具体计算就是1/fosc。也就是说如果晶振为1MHz，那么时钟周期就为1us；6MHz的话，就是1/6us。 </p>
<p> 8051单片机把一个时钟周期定义为一个节拍(用P表示)，二个节拍定义为一个状态周期(用S表示)。 </p>
<h3 id="机器周期"><a href="#机器周期" class="headerlink" title="机器周期"></a>机器周期</h3><p>在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶段，每一阶段完成一项工作。例如，取指令、存储器读、存储器写等，这每一项工作称为一个基本操作。完成一个基本操作所需要的时间称为机器周期。一般情况下，一个机器周期由若干个S周期(状态周期)组成。 </p>
<p>8051系列单片机的一个机器周期同6个  S周期(状态周期)组成。前面已说过一个时钟周期定义为一个节拍(用P表示)，二个节拍定义为一个状态周期(用S表示)，8051单片机的机器周期由6个 状态周期组成，也就是说一个机器周期=6个状态周期=12个时钟周期。 具体计算为：时钟周期 X  cycles。如果单片机是12周期的话，那么机器周期就是T×12。假设晶振频率为12M，单片机为12周期的话，那么机器周期就是1us。 </p>
<p>例如外接24M晶振的单片机，他的一个机器周期=12/24M 秒；52系列单片机一个机器周期等于12个时钟周期。设晶振频率为12MHz时，52单片机是12T的单片机，即频率要12分频。12M经过分频变为1M，由T=1/f,即一个机器周期变为1us。 </p>
<h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p>执行一条指令所需要的时间，一般由若干个机器周期组成。指令不同，所需的机器周期也不同。通常，包含一个机器周期的指令成为单周期指令，比如CLR,MOV等等。包含两个机器周期的指令称为双周期指令。另外还有4周期指令，比如乘法和除法指令。对于一些简单的的单字节指令，在取指令周期中，指令取出到指令寄存器后，立即译码执行，不再需要其它的机器周期。对于一些比较复杂的指令，例如转移指令、乘法指令，则需要两个或者两个以上的机器周期。 </p>
<h3 id="总线周期"><a href="#总线周期" class="headerlink" title="总线周期"></a>总线周期</h3><p>由于存贮器和I/O端口是挂接在总线上的，CPU对存贮器和I/O接口的访问，是通过总线实现的。通常把CPU通过总线对微处理器外部(存贮器或 I/O接口)进行一次访问所需时间称为一个总线周期。</p>
<p>总结一下，时钟周期是最小单位，机器周期需要1个或多个时钟周期，指令周期需要1个或多个机器周期;机器周期指的是完成一个基本操作的时间，这个基本操作有时可能包含总线读写，因而包含总线周期，但是有时可能与总线读写无关，所以，并无明确的相互包含的关系。  指令周期：是CPU的关键指标，指取出并执行一条指令的时间。一般以机器周期为单位，分单指令执行周期、双指令执行周期等。现在的处理器的大部分指令(ARM、DSP)均采用单指令执行周期。机器周期：完成一个基本操作的时间单元，如取指周期、取数周期。时钟周期：CPU的晶振的工作频率的倒数。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>个人对TWI作为主设备时，数据的发送流程框图的理解如下：</p>
<ul>
<li>TWI在需要发送数据时，才生成TWI时钟信号，通过SCLK线（对应评估板上的 <em><strong>DPI11</strong></em>， 以及下图的  <em><strong>TWI_CLK_PBEN_O</strong></em> ）输出。</li>
<li>需要传输的数据通过TWI接口写入FIFO中（对应的寄存器是<code>TXTWI8</code> ），并通过SDA线（对应21479评估板上的 <em><strong>DPI12</strong></em> , 以及下图的 <em><strong>TWI_DATA_PBEN_O</strong></em> ）输出，从机收到数据后通过SDA线（对应下图的 <em><strong>TWI_DATA_ I</strong></em>）返回确认（ACK）信息。<ul>
<li>在 <code>TWIIRPTL</code> 寄存器中，<code>TWIMCOM</code> 位为1则指示TWI初始化完毕，<code>TWITXINT</code> 为1则指示FIFO寄存器有空位，如果为0则说明 <code>TWIFIFOSTAT</code> 寄存器中的 <code>TWITXS</code> 位没有变化，即数据无法通过SDA发送出去；<code>TWIMERR</code> 则指示主设备传输过程中存在错误，具体错误需要查看 <code>TWIMSTAT</code> 寄存器。</li>
</ul>
</li>
<li>查看 <code>TWIMSTAT</code> 寄存器可知，<code>TWIMSTAT_REER</code> 位为1，该位为1则指示传输缓冲区读取错误，传输移位寄存器需要数据而缓冲区为空。</li>
<li>检查显示，<code>TXTWI8</code> 写入存在问题，写入语句 <code>*pTXTWI8 = 0xAA;</code> 执行后，观察寄存器窗口查看到数据仍为0x00。</li>
</ul>
<p><img src="https://pic.islet.space/2021/06/20210607155909.png" alt="image-20210607155906359"></p>
<p><img src="https://pic.islet.space/2021/06/20210607163901.png" alt="image-20210607163859502"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/24/Programming/C/2021-05-24-ISO-IEC_9899-2011-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/24/Programming/C/2021-05-24-ISO-IEC_9899-2011-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">ISO-IEC_9899-2011 学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-24 00:12:00" itemprop="dateCreated datePublished" datetime="2021-05-24T00:12:00+08:00">2021-05-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-26 00:26:57" itemprop="dateModified" datetime="2021-05-26T00:26:57+08:00">2021-05-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="C标准库"><a href="#C标准库" class="headerlink" title="C标准库"></a>C标准库</h2><p><img src="https://pic.islet.space/2021/05/image-20210524001458724.png" alt="image-20210524001458724"></p>
<h3 id="文本流"><a href="#文本流" class="headerlink" title="文本流"></a>文本流</h3><p><img src="https://pic.islet.space/2021/05/image-20210524001643408.png" alt="image-20210524001643408"></p>
<h3 id="二进制流"><a href="#二进制流" class="headerlink" title="二进制流"></a>二进制流</h3><p><img src="https://pic.islet.space/2021/05/image-20210524001722423.png" alt="image-20210524001722423"></p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="字符集和字符编码"><a href="#字符集和字符编码" class="headerlink" title="字符集和字符编码"></a>字符集和字符编码</h2><p><a target="_blank" rel="noopener" href="https://unicode.org/">UNICODE主页</a></p>
<p><img src="https://pic.islet.space/2021/05/image-20210524002528437.png" alt="image-20210524002528437"></p>
<h3 id="字符集对内存的影响"><a href="#字符集对内存的影响" class="headerlink" title="字符集对内存的影响"></a>字符集对内存的影响</h3><p>字符集涉及编码规则，包括单个字符所占用的空间大小，进而影响数据在硬件中的内存占用。</p>
<img src="https://pic.islet.space/2021/05/image-20210526002443105.png" alt="image-20210526002443105"  />





<p>如果将UTF-8转换成更为精简的GBK字符集，则会输出不同的结果。</p>
<p><img src="https://pic.islet.space/2021/05/image-20210526002630693.png" alt="image-20210526002630693"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/23/Programming/2021-05-23-POSIX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/23/Programming/2021-05-23-POSIX/" class="post-title-link" itemprop="url">POSIX</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-23 22:05:00 / Modified: 22:17:37" itemprop="dateCreated datePublished" datetime="2021-05-23T22:05:00+08:00">2021-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><em>可移植操作系统接口（英语：Portable Operating System Interface，缩写为POSIX）是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，而国际标准名称为ISO/IEC 9945。此标准源于一个大约开始于1985年的项目。POSIX这个名称是由理查德·斯托曼（RMS）应IEEE的要求而提议的一个易于记忆的名称。它基本上是Portable Operating System Interface（可移植操作系统接口）的缩写，而X则表明其对Unix API的传承。</em></p>
<p><em>Linux基本上逐步实现了POSIX兼容，但并没有参加正式的POSIX认证。[1]</em></p>
<p><em>微软的Windows NT声称部分实现了POSIX标准。</em></p>
<p><em>当前的POSIX主要分为四个部分[2]：Base Definitions、System Interfaces、Shell and Utilities和Rationale。</em> </p>
<p>——Wikipedia.org的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3">可移植操作系统接口</a></p>
</blockquote>
<blockquote>
<p><em>一般情况下，应用程序通过应用编程接口(API)而不是直接通过系统调用来编程。这点很重要，因为应用程序使用的这种编程接口实际上并不需要和内核 提供的系统调用对应。一个API定义了一组应用程序使用的编程接口。它们可以实现成一个系统调用，也可以通过调用多个系统调用来实现，而完全不使用任何系 统调用也不存在问题。实际上，API可以在各种不同的操作系统上实现，给应用程序提供完全相同的接口，而它们本身在这些系统上的实现却可能迥异。</em></p>
<p><em>在Unix世界中，最流行的应用编程接口是基于POSIX标准的。从纯技术的角度看，POSIX是由IEEE的一组标准组成，其目标是提供一套大体上基于Unix的可移植操作系统标准。Linux是与POSIX兼容的。</em></p>
<p><em>POSIX是说明API和系统调用之间关系的一个极好例子。在大多数Unix系统上，根据POSIX而定义的API函数和系统调用之间有着直接关 系。实际上，POSIX标准就是仿照早期Unix系统的界面建立的。另一方面，许多操作系统，像Windows NT，尽管和Unix没有什么关系，也提供了与POSIX兼容的库。</em></p>
<p><em>Linux的系统调用像大多数Unix系统一样，作为C库的一部分提供如图5-1所示。如图5-1所示C库实现了Unix系统的主要API，包括标 准C库函数和系统调用。所有的C程序都可以使用C库，而由于C语言本身的特点，其他语言也可以很方便地把它们封装起来使用。此外，C库提供了POSIX的 绝大部分API。</em></p>
<p><em>从程序员的角度看，系统调用无关紧要；他们只需要跟API打交道就可以了。相反，内核只跟系统调用打交道；库函数及应用程序是怎么使用系统调用不是内核所关心的。</em></p>
<p>——《Linux内核设计与实现（第2版）》第5章</p>
</blockquote>
<p><strong>简单总结</strong></p>
<p>完成同一功能，不同内核提供的系统调用（也就是一个函数）是不同的，例如创建进程，linux下是fork函数，windows下是creatprocess函数。好，我现在在linux下写一个程序，用到fork函数，那么这个程序该怎么往windows上移植？我需要把源代码里的fork通通改成creatprocess，然后重新编译…</p>
<p>posix标准的出现就是为了解决这个问题。linux和windows都要实现基本的posix标准，linux把fork函数封装成posix_fork（随便说的），windows把creatprocess函数也封装成posix_fork，都声明在unistd.h里。这样，程序员编写普通应用时候，只用包含unistd.h，调用posix_fork函数，程序就在源代码级别可移植了</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/23/Programming/C++/2021-05-23-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/23/Programming/C++/2021-05-23-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">基本数据类型 与 构造数据类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-23 19:21:00 / Modified: 23:50:04" itemprop="dateCreated datePublished" datetime="2021-05-23T19:21:00+08:00">2021-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[cnblogs.com](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ybtools/p/6432464.html#:~:text=%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%8C%87%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%85%B6%E4%BB%96%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E6%9E%84%E9%80%A0%EF%BC%8C%E5%8F%AF%E7%94%B1%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E5%AE%9A%E4%B9%89%EF%BC%8C%E6%95%85%E5%8F%88%E7%A7%B0%E4%B8%BA">https://www.cnblogs.com/ybtools/p/6432464.html#:~:text=构造数据类型指可以通过其他的数据类型进行构造，可由程序员自定义，故又称为</a> “,自定义数据类型 “。 基本数据类型包括整型（short%2Cint%2Clong）、实型（又称浮点型）（float和double）、字符型char、布尔型bool等，他们都可以用于定义常量和变量。)</p>
<p>PS：本文以C++为例介绍数据类型。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>从广义上根据量的值是否可变，可分为<strong>常量</strong>和<strong>变量</strong>两种数据类型。</p>
<p>根据数据复杂程度，划分为<strong>基本数据类型</strong>和<strong>构造数据类型</strong>这两大类。</p>
<p><strong>基本数据类型</strong> 包括：整型（short,int,long）、实型（又称浮点型）（float和double）、字符型char、布尔型bool等。</p>
<p><strong>构造数据类型</strong> 包括：数组类型、枚举类型enum、指针类型、引用类型、结构体struct、联合体union（又称联合，共用体）、类class等。</p>
<p>构造数据类型指可以通过其他的数据类型进行构造，可由程序员自定义，故又称为 “<strong>自定义数据类型</strong>“。</p>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>基本数据类型包括整型（short,int,long）、实型（又称浮点型）（float和double）、字符型char、布尔型bool等，他们都可以用于定义常量和变量。</p>
<p>基本数据类型，也叫做基础类型，或内置类型。</p>
<p><strong>1、整型（short,int,long）</strong></p>
<p>整型量，包括短整型short、整型int、长整型long，而且3种类型都可以分别再细分为：有符号(signed)以及无符号(unsigned)。 </p>
<p><strong>2、实型（又称浮点型）（float和double）</strong></p>
<p>实型，又称为浮点型，它包括两种数据类型：单精度浮点数float和双精度浮点数double。他们都是有符号数据类型。如果一个数值常量，包含小数点、指数部分（字符e），则为浮点数。</p>
<p>双精度浮点型，还可细分为双精度（double型）、长双精度（long double）</p>
<p><strong>3、字符型char</strong></p>
<p>字符型char类型定义的常量，必须要用单括号括起来。</p>
<p>例如：char ch=’a’ ; //把字符常量’a’存储到ch中。</p>
<p>字符型char类型量也可以细分为有符号(char)和无符号(unsigned char)。</p>
<p><strong>4、布尔型bool</strong></p>
<p>布尔型的取值为true或者false。</p>
<p>布尔型变量的说明：例：bool flag，则布尔型数据的变量flag取值：只有 false 和 true 两个值，即分别是0和1。</p>
<h1 id="构造数据类型"><a href="#构造数据类型" class="headerlink" title="构造数据类型"></a>构造数据类型</h1><p>有些比较复杂的数据，单纯用基本数据类型未能表示，在C++中程序员可以用基本数据类型来自定义构造出新的数据类型，称构造数据类型，也称作 <em><strong>构造类型</strong></em>、<em><strong>构造数据类型</strong></em>。</p>
<p>构造数据类型除了可以用常见的如int、float和double、char、bool等基本数据类型进行构造，也可以包含其他构造类型的数据。</p>
<p>构造数据类型包括：数组类型、枚举类型enum、指针类型、引用类型、结构体struct、联合体union（又称联合，共用体）、class类等，他们可以通过其他的数据类型进行构造，由程序员自定义，所以又称为自定义数据类型。</p>
<p>参考：<a target="_blank" rel="noopener" href="http://blog.csdn.net/u013174689/article/details/17484223">http://blog.csdn.net/u013174689/article/details/17484223</a></p>
<p>​          </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/23/Programming/C++/2021-05-23-enum-in-CC++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/23/Programming/C++/2021-05-23-enum-in-CC++/" class="post-title-link" itemprop="url">enum in C/C++</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-23 18:22:00 / Modified: 22:03:34" itemprop="dateCreated datePublished" datetime="2021-05-23T18:22:00+08:00">2021-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>enum</code> 是 Enumeration // 的缩写，是C/C++中的 <strong>枚举</strong> 关键字。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>符合以下场景时可能需要使用到枚举：</p>
<ul>
<li>需要使用到的变量 <strong>数量较大</strong>，通过枚举以简写代码，提高代码可读性</li>
<li>使用整形（integer）进行定义（但不同于直接定义成 <code>int</code> 的 <strong>显式整形</strong>，使用枚举类型定义的话会变成 <strong>隐式整形</strong>）</li>
<li>所有值都是有固定范围的，是可人为预设的。</li>
<li>具有常量的特性（主要特点是：不可在定义之外的地方被修改）</li>
</ul>
<p>注意：</p>
<ul>
<li><em>在所有枚举值都未被赋值的情况下</em>，枚举值默认从 0 开始，往后逐个加 1（递增）。</li>
</ul>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>枚举格式</strong>：一般为 <code>enum 枚举名&#123; 枚举值表 &#125;;</code> ，也可以省略枚举名，写成如下格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">typeName</span>&#123;</span> valueName1, valueName2, valueName3, ...... &#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>enum</code> 定义 <strong>枚举类型的关键字</strong>；</p>
<p><code>typeName</code>是 枚举类型的名称，即 <strong>枚举名</strong>。</p>
<p><code>valueName1, valueName2, valueName3, ......</code>是每个值对应的名字的列表，所有元素集合即为 <strong>枚举值表</strong></p>
<p>注意：最后的<code>;</code>不能少。</p>
</blockquote>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><h2 id="起始值赋值"><a href="#起始值赋值" class="headerlink" title="起始值赋值"></a>起始值赋值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">cats</span> &#123;</span></span><br><span class="line">    juran = <span class="number">3</span>,</span><br><span class="line">    guoran,</span><br><span class="line">    dala,</span><br><span class="line">    baomei,</span><br><span class="line">    baodi,</span><br><span class="line">    zhaofeng,</span><br><span class="line">    ainiao</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">juran = 3</span><br><span class="line">guoran = 4</span><br><span class="line">dala = 5</span><br><span class="line">ainiao = 9</span><br></pre></td></tr></table></figure>



<h2 id="值表中途赋值"><a href="#值表中途赋值" class="headerlink" title="值表中途赋值"></a>值表中途赋值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">cats</span> &#123;</span></span><br><span class="line">    juran,</span><br><span class="line">    guoran,</span><br><span class="line">    dala = <span class="number">0</span>,</span><br><span class="line">    baomei,</span><br><span class="line">    baodi,</span><br><span class="line">    zhaofeng,</span><br><span class="line">    ainiao</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>给出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">juran = 0</span><br><span class="line">guoran = 1</span><br><span class="line">dala = 0</span><br><span class="line">ainiao = 4</span><br></pre></td></tr></table></figure>



<h1 id="Typedef-enum"><a href="#Typedef-enum" class="headerlink" title="Typedef enum"></a>Typedef enum</h1><p>Typedef enum 的用法一般如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>....&#125; a; </span><br></pre></td></tr></table></figure>

<p>enum 的用法一般如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span>....&#125; a;</span><br></pre></td></tr></table></figure>

<p>前者是将 <code>enum&#123;….&#125;</code> 定义成一个 <em><strong>a类型</strong></em>，声明变量的时候可以用 <code>a b</code> 格式;可以理解为类似 <code>int i</code>;</p>
<p>后者是将 <code>enum&#123;….&#125;</code> 声明了一个 <em><strong>变量</strong></em><code>a</code>。</p>
<h1 id="枚举遍历"><a href="#枚举遍历" class="headerlink" title="枚举遍历"></a>枚举遍历</h1><p> 在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。</p>
<p>不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span>&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历枚举元素</span></span><br><span class="line">    <span class="keyword">for</span> (day = MON; day &lt;= SUN; day++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;枚举元素：%d \n&quot;</span>, day);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h1><p>以下错误示范给出的提示均由 Linux的 <em><strong>GNU</strong></em> 编译器 及 Mac的 <em><strong>Clang</strong></em>（*Apple clang version 11.0.0 (clang-1100.0.33.17)*）编译器给出。</p>
<h2 id="重复定义"><a href="#重复定义" class="headerlink" title="重复定义"></a>重复定义</h2><p>不允许 <strong>在同一个作用域内</strong> 定义 <strong>一样的枚举名称</strong> ；也不允许 <strong>在同一个作用域内</strong> 的不同枚举变量中定义 <strong>名称一样的元素</strong>。</p>
<p><img src="https://pic.islet.space/2021/05/image-20210523204125878.png" alt="image-20210523204125878"></p>
<p><img src="https://pic.islet.space/2021/05/image-20210523204041715.png" alt="image-20210523204041715"></p>
<p>以上两种情况的错误提示如下：</p>
<p><img src="https://pic.islet.space/2021/05/image-20210523182310296.png" alt="image-20210523182310296"></p>
<p><img src="https://pic.islet.space/2021/05/image-20210523204224839.png" alt="image-20210523204224839"></p>
<p>也就是说 <strong>枚举名称和枚举元素都要绝对唯一</strong>。</p>
<h2 id="数值更改"><a href="#数值更改" class="headerlink" title="数值更改"></a>数值更改</h2><p>枚举类数据不允许更改数值（包括自增和赋值都不允许），有点类似于常量（const）。</p>
<p>枚举中的元素自增时的错误提示：</p>
<p><img src="https://pic.islet.space/2021/05/image-20210523202049638.png" alt="image-20210523202049638"></p>
<p>枚举中的元素赋值时的错误提示：</p>
<p><img src="https://pic.islet.space/2021/05/image-20210523202501260.png" alt="image-20210523202501260"></p>
<blockquote>
<p>根据 <a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/142755629.html">网友的回答</a> : </p>
<p>C支持枚举类型的自增操作，但C++不支持。</p>
</blockquote>
<p>以下为常量自增时给出的错误提示：</p>
<p><img src="https://pic.islet.space/2021/05/image-20210523202757582.png" alt="image-20210523202757582"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/23/Programming/C++/2021-05-23-Difference-between-GCC,-gcc-and-g++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/23/Programming/C++/2021-05-23-Difference-between-GCC,-gcc-and-g++/" class="post-title-link" itemprop="url">Difference between GCC, gcc and g++</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-23 17:00:00 / Modified: 20:07:33" itemprop="dateCreated datePublished" datetime="2021-05-23T17:00:00+08:00">2021-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>gcc 和 GCC 是两个不同的东西。</p>
<blockquote>
<p><strong>GCC</strong>：GNU Compiler Collection(GUN 编译器集合)，它可以编译C、C++、JAV、Fortran、Pascal、Object-C、Ada等语言。</p>
<p><strong>gcc</strong>：GCC中的GUN C Compiler（C 编译器）</p>
<p>**g++**：GCC中的GUN C++ Compiler（C++编译器）</p>
</blockquote>
<p>一个有趣的事实就是，就本质而言，gcc和g++并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件的类型，调用对应的GUN编译器而已，比如，用gcc编译一个c文件的话，会有以下几个步骤：</p>
<blockquote>
<p>Step1：Call a preprocessor, like cpp.</p>
<p>Step2：Call an actual compiler, like cc or cc1.</p>
<p>Step3：Call an assembler, like as.</p>
<p>Step4：Call a linker, like ld</p>
</blockquote>
<p>由于编译器是可以更换的，所以gcc不仅仅可以编译C文件</p>
<p>所以，更准确的说法是：gcc调用了C compiler，而g++调用了C++ compiler</p>
<h1 id="gcc和g-的主要区别"><a href="#gcc和g-的主要区别" class="headerlink" title="gcc和g++的主要区别"></a>gcc和g++的主要区别</h1><ol>
<li><p>对于 <em>.c和</em>.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）</p>
</li>
<li><p>对于 <em>.c和</em>.cpp文件，g++则统一当做cpp文件编译</p>
</li>
<li><p>使用g++编译文件时，<strong>g++会自动链接标准库STL，而gcc不会自动链接STL</strong></p>
</li>
<li><p>gcc在编译C文件时，可使用的预定义宏是比较少的</p>
</li>
<li><p>gcc在编译cpp文件时/g++在编译c文件和cpp文件时（这时候gcc和g++调用的都是cpp文件的编译器），会加入一些额外的宏，这些宏如下：</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __GXX_WEAK__ 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __cplusplus 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __DEPRECATED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __GNUG__ 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __EXCEPTIONS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __private_extern__ extern</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在用gcc编译c++文件时，为了能够使用STL，需要加参数 –lstdc++ ，但这并不代表 gcc –lstdc++ 和 g++等价，它们的区别不仅仅是这个</li>
</ol>
<p>其主要参数：</p>
<blockquote>
<p>-g - turn on debugging (so GDB gives morefriendly output)</p>
<p>-Wall - turns on most warnings</p>
<p>-O or -O2 - turn on optimizations</p>
<p>-o - name of the output file</p>
<p>-c - output an object file (.o)</p>
<p>-I - specify an includedirectory</p>
<p>-L - specify a libdirectory</p>
<p>-l - link with librarylib.a</p>
</blockquote>
<p>使用示例：<code>g++ -ohelloworld -I/homes/me/randomplace/include helloworld.C</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/22/Linux/2021-05-21-Equipments_in_debian_linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/22/Linux/2021-05-21-Equipments_in_debian_linux/" class="post-title-link" itemprop="url">Equipments in Debian Linux(KALI)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-22 20:30:00" itemprop="dateCreated datePublished" datetime="2021-05-22T20:30:00+08:00">2021-05-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-23 23:51:40" itemprop="dateModified" datetime="2021-05-23T23:51:40+08:00">2021-05-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>作为一个日常开发的程序员，三大平台都在日常使用的软件（生产力工具及娱乐工具）如下：</p>
<ul>
<li>utools</li>
<li>typora</li>
<li>visual studio code</li>
<li>picgo</li>
<li>sogou pinyin</li>
<li>snipaste(win) / flameshot(linux) / ishot(mac)</li>
<li>cosbrowser</li>
<li>nodejs 及 npm</li>
<li>hexo</li>
<li>qqmusic</li>
</ul>
<p>win和mac安装软件都相对简单，linux安装需要使用者自身具有一定的耐心和排除困难的经验，为了更好地体验linux的方便，这里对linux装机后的生产力工具安装做个简单记录，以下安装均在 <strong>KALI</strong> （Kali也属于Debian系Linux）上进行。</p>
<p>使用Linux系统的最大好处是 “一个终端即可解决即可开启大部分软件和解决日常事务，最多再开启一个utools”。</p>
<p>Linux上的软件安装方式通常分为四种方式：</p>
<ul>
<li>通过 <code>dpkg</code> 命令安装 <code>.deb</code> 文件</li>
<li>通过 <code>apt</code> 或其他软件的软件安装命令（如，<code>npm</code> 和 <code>pip</code>）来安装</li>
<li>通过 <code>ln</code> 链接将程序绑定至全局变量来 “安装” 和使用</li>
<li>通过直接调用 <code>AppImage</code> 的方式直接使用软件，此类方式需要一般需要手动双击执行</li>
</ul>
<p>其中前三种方式的困难因系统而异，所说的困难是可能出现所安装的软件依赖不存在，需要使用者自行去定位（包括下载和添加源）和安装，或者链接方式错误等。而Linux源众多，每个节点的速度及其更新情况都不太一样，需要使用者判断。</p>
<h1 id="uTools-amp-Flameshot"><a href="#uTools-amp-Flameshot" class="headerlink" title="uTools &amp; Flameshot"></a>uTools &amp; Flameshot</h1><p><a target="_blank" rel="noopener" href="https://res.u-tools.cn/currentversion/utools_1.3.5_amd64.deb">uTools</a> 使用的是 <code>.deb</code> 安装包安装，flameshot 使用 <code>apt</code> 命令进行安装。</p>
<p><strong>依赖文件</strong>：</p>
<ol>
<li><code>libspdlog1-fmt7</code> 是 flameshot所需文件</li>
<li><code>libappindicator3-1</code> 是 utools所需文件</li>
</ol>
<h2 id="libspdlog1"><a href="#libspdlog1" class="headerlink" title="libspdlog1"></a>libspdlog1</h2><p>尝试安装utools和flameshot后，apt会提示缺少文件。使用 <code>sudo apt-get install libspdlog1-fmt7</code> 来安装 <code>libspdlog1-fmt7</code> 。</p>
<p>如果触发安装破损修复，使用<code>apt --fix-broken install</code> 可以让apt自动修复安装错误，自动补全依赖文件。</p>
<h2 id="libappindicator3"><a href="#libappindicator3" class="headerlink" title="libappindicator3"></a>libappindicator3</h2><p><code>libappindicator3-1</code> 文件需要使用者往 <code>/etc/apt/source.list</code> 中添加debian源，需要使用者掌握基本的 <code>vim</code> 软件使用方法（包括插入、保存和退出）。</p>
<ul>
<li><p>使用 <code>sudo vim /etc/apt/sources.list</code> 命令打开 <code>source.list</code> 。</p>
</li>
<li><p>按 <code>i</code> 进入 <strong>插入模式</strong>，复制粘贴 <code>deb http://ftp.de.debian.org/debian sid main</code> 至空白处，按 <code>ESC</code> 键，再依次输入 <code>:wq</code> 进行保存和退出。</p>
</li>
<li><p>在终端输入 <code>sudo apt-get update</code> 进行源库软件列表更新，再次尝试 <code>sudo apt-get install libappindicator3</code> 来安装</p>
<p> <code>libappindicator3-1</code> and <code>libappindicator3-7</code> 。</p>
</li>
</ul>
<p>最后再次尝试以下两条语句即可成功安装 utools 和 flameshot 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i utools_1.3.5_amd64.deb</span><br><span class="line">sudo apt-get install flameshot</span><br></pre></td></tr></table></figure>





<h1 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h1><p><a target="_blank" rel="noopener" href="https://tyopra.io/">TYPORA.IO</a> 官方提供的安装代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span><br><span class="line">sudo add-apt-repository <span class="string">&#x27;deb https://typora.io/linux ./&#x27;</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install typora</span><br></pre></td></tr></table></figure>



<p>其中，向apt中添加源的第二条语句 <code>add-apt-repository</code> 会因缺乏 <code>PPA</code> 而无法执行，可以参考 <a target="_blank" rel="noopener" href="https://ywnz.com/linuxjc/7953.html#:~:text=%E6%9C%89%E4%BA%9B%E7%94%A8%E6%88%B7%E5%9C%A8UOS%E3%80%81Deepin%E7%AD%89%E6%9F%90%E4%BA%9BLinux%E5%8F%91%E8%A1%8C%E7%89%88%E7%BB%88%E7%AB%AF%E4%B8%AD%E8%BE%93%E5%85%A5PPA%E5%91%BD%E4%BB%A4%E6%97%B6%E4%BC%9A%E6%8F%90%E7%A4%BA%E2%80%9Csudo%3A%20add-apt-repository%EF%BC%9A%E6%89%BE%E4%B8%8D%E5%88%B0%E5%91%BD%E4%BB%A4%EF%BC%88command,not%20found%EF%BC%89%E2%80%9D%EF%BC%8C%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BA%E6%B2%A1%E6%9C%89%E5%AE%89%E8%A3%85PPA%E6%89%80%E8%87%B4%EF%BC%8C%E6%8A%8A%E5%AE%83%E5%AE%89%E8%A3%85%E4%B8%8A%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%B8%AD%E8%BF%90%E8%A1%8C%E4%B8%89%E6%9D%A1%E5%91%BD%E4%BB%A4%E3%80%82">sudo: add-apt-repository：找不到命令的解决方法</a> 进行安装。</p>
<p>也可以参考 <code>libappindicator3</code> 的源添加方法，往 <code>source.list</code> 文件中添加 <code>deb https://typora.io/linux ./</code> 来添加源。</p>
<p>添加成功后即可成功安装tyopra。</p>
<h1 id="Sogou-Pinyin"><a href="#Sogou-Pinyin" class="headerlink" title="Sogou Pinyin"></a>Sogou Pinyin</h1><p> 从搜狗官方下载的 <a target="_blank" rel="noopener" href="https://ime.sogoucdn.com/dl/index/1612260778/sogoupinyin_2.4.0.3469_amd64.deb?st=USANnSZV6afzzi2u6c8J-g&e=1621603885&fn=sogoupinyin_2.4.0.3469_amd64.deb">Sogou</a> 安装包，需要用 <code>sudo dpkg -i sogoupinyin_2.4.0.3469_amd64.deb</code> 命令进行安装，会遇到以下缺乏库的提示，主要是因为缺少 <code>fcitx</code> 的提示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">dpkg: 依赖关系问题使得 sogoupinyin 的配置工作不能继续：</span><br><span class="line"> sogoupinyin 依赖于 fcitx (&gt;= 1:4.2.8)；然而：</span><br><span class="line">  未安装软件包 fcitx</span><br><span class="line"> sogoupinyin 依赖于 fcitx-frontend-gtk2；然而：</span><br><span class="line">  未安装软件包 fcitx-frontend-gtk2。</span><br><span class="line"> sogoupinyin 依赖于 fcitx-frontend-gtk3；然而：</span><br><span class="line">  未安装软件包 fcitx-frontend-gtk3。</span><br><span class="line"> sogoupinyin 依赖于 fcitx-frontend-qt5；然而：</span><br><span class="line">  未安装软件包 fcitx-frontend-qt5。</span><br><span class="line"> sogoupinyin 依赖于 fcitx-module-kimpanel；然而：</span><br><span class="line">  未安装软件包 fcitx-module-kimpanel。</span><br><span class="line"> sogoupinyin 依赖于 fcitx-module-x11；然而：</span><br><span class="line">  未安装软件包 fcitx-module-x11。</span><br><span class="line"> sogoupinyin 依赖于 im-config；然而：</span><br><span class="line">  未安装软件包 im-config。</span><br><span class="line"> sogoupinyin 依赖于 fcitx-libs | libfcitx-config4；然而：</span><br><span class="line">  未安装软件包 fcitx-libs。</span><br><span class="line">  未安装软件包 libfcitx-config4。</span><br><span class="line"> sogoupinyin 依赖于 fcitx-libs | libfcitx-qt0；然而：</span><br><span class="line">  未安装软件包 fcitx-libs。</span><br><span class="line">  未安装软件包 libfcitx-qt0。</span><br><span class="line"> sogoupinyin 依赖于 fcitx-libs | libfcitx-utils0；然而：</span><br><span class="line">  未安装软件包 fcitx-libs。</span><br><span class="line">  未安装软件包 libfcitx-utils0。</span><br><span class="line"> sogoupinyin 依赖于 fcitx-ui-classic；然而：</span><br><span class="line">  未安装软件包 fcitx-ui-classic。</span><br><span class="line"> sogoupinyin 依赖于 libqt5quickwidgets5；然而：</span><br><span class="line">  未安装软件包 libqt5quickwidgets5。</span><br><span class="line"> sogoupinyin 依赖于 qml-module-qtquick2；然而：</span><br><span class="line">  未安装软件包 qml-module-qtquick2。</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Fcitx[ˈfaɪtɪks]是 (Free Chinese Input Toy for X) 的英文缩写，中文名为小企鹅输入法，是一个以 GPL 方式发布的输入法框架， 编写它的目是为桌面环境提供一个灵活的输入方案，彻底解决在GNU/Linux下没有一个好的中文输入法的问题。</p>
</blockquote>
<h2 id="FCITX"><a href="#FCITX" class="headerlink" title="FCITX"></a>FCITX</h2><p>通过输入 <code>sudo apt-get install fcitx</code> 来尝试安装，会触发 apt fix broken install， 此时只要再次输入 <code>sudo apt --fix-broken install</code> 来修复。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">下列软件包有未满足的依赖关系：</span><br><span class="line"> fcitx : 依赖: fcitx-bin 但是它将不会被安装</span><br><span class="line">         依赖: fcitx-data 但是它将不会被安装</span><br><span class="line">         依赖: fcitx-modules 但是它将不会被安装</span><br><span class="line">         推荐: fcitx-config-gtk 但是它将不会被安装 或</span><br><span class="line">                 kde-config-fcitx 但是它将不会被安装</span><br><span class="line">         推荐: fcitx-frontend-all 但是它将不会被安装 或</span><br><span class="line">                 fcitx-frontend-fbterm 但是它将不会被安装</span><br><span class="line">         推荐: fcitx-ui-classic 但是它将不会被安装 或</span><br><span class="line">                 fcitx-ui-light 但是它将不会被安装</span><br><span class="line">         推荐: im-config (&gt;= 0.5) 但是它将不会被安装</span><br><span class="line"> sogoupinyin : 依赖: fcitx-frontend-gtk2 但是它将不会被安装</span><br><span class="line">               依赖: fcitx-frontend-gtk3 但是它将不会被安装</span><br><span class="line">               依赖: fcitx-frontend-qt5 但是它将不会被安装</span><br><span class="line">               依赖: fcitx-module-kimpanel 但是它将不会被安装</span><br><span class="line">               依赖: fcitx-module-x11 但是它将不会被安装</span><br><span class="line">               依赖: im-config 但是它将不会被安装</span><br><span class="line">               依赖: fcitx-libs 但是它将不会被安装 或</span><br><span class="line">                       libfcitx-config4 但是它将不会被安装</span><br><span class="line">               依赖: fcitx-libs 但是它将不会被安装 或</span><br><span class="line">                       libfcitx-qt0 但无法安装它</span><br><span class="line">               依赖: fcitx-libs 但是它将不会被安装 或</span><br><span class="line">                       libfcitx-utils0 但是它将不会被安装</span><br><span class="line">               依赖: fcitx-ui-classic 但是它将不会被安装</span><br><span class="line">               依赖: libqt5quickwidgets5 但是它将不会被安装</span><br><span class="line">               依赖: qml-module-qtquick2 但是它将不会被安装</span><br><span class="line">E: 有未能满足的依赖关系。请尝试不指明软件包的名字来运行“apt --fix-broken install”(也可以指定一个解决办法)。</span><br></pre></td></tr></table></figure>



<h2 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功"></a>安装成功</h2><p>FIX-BROKEN 成功后，再次尝试安装 FCITX 就可以提示成功；接着安装sogou即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install fcitx                   </span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树... 完成</span><br><span class="line">正在读取状态信息... 完成                 </span><br><span class="line">fcitx 已经是最新版 (1:4.2.9.8-3)。</span><br><span class="line">fcitx 已设置为手动安装。</span><br><span class="line">升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 136 个软件包未被升级。</span><br><span class="line"></span><br><span class="line">$ sudo dpkg -i sogoupinyin_2.4.0.3469_amd64.deb</span><br><span class="line">(正在读取数据库 ... 系统当前共安装有 270000 个文件和目录。)</span><br><span class="line">准备解压 sogoupinyin_2.4.0.3469_amd64.deb  ...</span><br><span class="line">正在解压 sogoupinyin (2.4.0.3469) 并覆盖 (2.4.0.3469) ...</span><br><span class="line">正在设置 sogoupinyin (2.4.0.3469) ...</span><br><span class="line">正在处理用于 mailcap (3.69) 的触发器 ...</span><br><span class="line">正在处理用于 desktop-file-utils (0.26-1) 的触发器 ...</span><br><span class="line">正在处理用于 hicolor-icon-theme (0.17-2) 的触发器 ...</span><br></pre></td></tr></table></figure>





<h2 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h2><p>sogou输入法依赖库具体如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">下列【新】软件包将被安装：</span><br><span class="line">  dbus-x11 fcitx fcitx-bin fcitx-config-common fcitx-config-gtk fcitx-data</span><br><span class="line">  fcitx-frontend-all fcitx-frontend-gtk2 fcitx-frontend-gtk3</span><br><span class="line">  fcitx-frontend-qt5 fcitx-libs fcitx-module-dbus fcitx-module-kimpanel</span><br><span class="line">  fcitx-module-lua fcitx-module-x11 fcitx-modules fcitx-ui-classic</span><br><span class="line">  fcitx5-module-quickphrase-editor im-config libfcitx-config4</span><br><span class="line">  libfcitx-core0 libfcitx-gclient1 libfcitx-qt5-1 libfcitx-qt5-data</span><br><span class="line">  libfcitx-utils0 libgettextpo0 libpresage-data libpresage1v5</span><br><span class="line">  libqt5qmlworkerscript5 libqt5quickwidgets5 libtinyxml2.6.2v5 presage</span><br><span class="line">  qml-module-qtquick2</span><br></pre></td></tr></table></figure>



<h1 id="NodeJS-amp-Hexo"><a href="#NodeJS-amp-Hexo" class="headerlink" title="NodeJS &amp; Hexo"></a>NodeJS &amp; Hexo</h1><p>使用 <code>sudo apt-get install nodejs</code> 或 <code>sudo apt-get install node.js</code> 均可以实现node.js 的安装，但是只能安装V12版。</p>
<p>可以在官方下载 <a target="_blank" rel="noopener" href="https://nodejs.org/dist/v16.2.0/node-v16.2.0-linux-x64.tar.xz">node-v16.2.0-linux-x64.tar.xz</a> ，并使用以下命令进行解压：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xz -d node-v16.2.0-linux-x64.tar.xz</span><br><span class="line">tar -xvf node-v16.2.0-linux-x64.tar</span><br></pre></td></tr></table></figure>

<p>解压完毕之后，以管理员身份将该文件移动至 <code>/usr/local/node</code> ，以下命令将 <code>node-v16.2.0-linux-x64</code> 拷贝的同时进行了 <strong>重命名</strong> 操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /home/XXX/downloads/node-v16.2.0-linux-x64 /usr/<span class="built_in">local</span>/node</span><br></pre></td></tr></table></figure>

<p style="color: gray; font-style: italic;">注：XXX是用户名</p>

<p>然后进行软连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/node/bin/node /usr/<span class="built_in">local</span>/bin</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/node/bin/npm /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Linux ln（英文全拼：link files）命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。</p>
<p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p>
</blockquote>
<p>以上是 <code>ln</code> 链接命令的解释，实际最重要的作用是将某个已下载的软件及其命令定义至全局，在终端的任意一个目录位置都可以使用该软件。</p>
<h2 id="“安装”-成功"><a href="#“安装”-成功" class="headerlink" title="“安装” 成功"></a>“安装” 成功</h2><p>实际上新版的nodejs并不涉及 前述 <code>dpkg</code> 或 <code>apt</code> 命令的安装，但软连接该文件目录至 <code>/usr/local/bin</code> 后，能实现安装效果，使用 <code>node -v</code> 及 <code>npm -v</code> 命令即可进行测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v16.2.0</span><br><span class="line"></span><br><span class="line">$ npm -v                   </span><br><span class="line">7.14.0</span><br></pre></td></tr></table></figure>



<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>对于使用此类安装方式进行安装的 依赖于nodejs的应用如果需要在全局进行使用可能也需要进行软连接，如 hexo。</p>
<p>使用 <code>npm install hexo-cli -g</code> 成功安装hexo后提示如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ whereis hexo</span><br><span class="line">hexo:</span><br></pre></td></tr></table></figure>



<p>此时需要将 <code>/usr/local/node/bin</code> 文件夹下安装的程序也拉到全局变量中 <code>/usr/local/bin</code> 中。再次使用 <code>whereis</code> 命令检测时即可成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ln -s /usr/<span class="built_in">local</span>/node/bin/hexo /usr/<span class="built_in">local</span>/bin/hexo</span><br><span class="line">                                                                             </span><br><span class="line">$ whereis hexo</span><br><span class="line">hexo: /usr/<span class="built_in">local</span>/bin/hexo</span><br></pre></td></tr></table></figure>



<h1 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h1><p>VS code安装使用 <code>dpkg</code> 命令，最大的问题是微软的源下载太慢，以下提供个人下载点，安装过程不再记录。</p>
<p>个人下载点： <a target="_blank" rel="noopener" href="https://storage.islet.space/02_Softwares/02_Microsoft/VisualStudioCode/Linux/code_1.55.2-1618307277_amd64.deb">Visual Studio Code Linux (deb)</a></p>
<h1 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h1><p><a target="_blank" rel="noopener" href="https://support.typora.io/Upload-Image/#picgo-core-command-line-opensource">Typora_Picgo</a> 有 command-line 版 和 app 版，参考 <a target="_blank" rel="noopener" href="https://picgo.github.io/PicGo-Doc/zh/">PicGo官方文档</a> （GFW封锁了<em><strong>github.io</strong></em>域名后缀，需要梯子）进行安装吧。</p>
<h1 id="QQmusic-amp-cosbrowser"><a href="#QQmusic-amp-cosbrowser" class="headerlink" title="QQmusic &amp; cosbrowser"></a>QQmusic &amp; cosbrowser</h1><p>这两个软件都是腾讯家产品，下载、安装和使用都很方便。</p>
<p>其中，QQMusic使用 <code>dpkg</code> 命令进行安装即可， <code>cosbrowser</code> 是 <code>AppImage</code> 格式文件，直接打开即可使用，无需安装。</p>
<p><strong>彩蛋</strong>：<code>sudo apt-get install cmatrix</code></p>
<p>—EOF—</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/21/Programming/C++/2021-05-21-How-to-Use-the-C-Preprocessors-#error-Directive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/21/Programming/C++/2021-05-21-How-to-Use-the-C-Preprocessors-#error-Directive/" class="post-title-link" itemprop="url">How to Use the C Preprocessor's error Directive</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-21 23:40:32" itemprop="dateCreated datePublished" datetime="2021-05-21T23:40:32+08:00">2021-05-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-23 20:06:47" itemprop="dateModified" datetime="2021-05-23T20:06:47+08:00">2021-05-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://barrgroup.com/embedded-systems/how-to/c-preprocessor-error-directive">barrgroup.com</a></p>
<p>One of the least used but potentially most useful features of the C  preprocessor is the <em><strong>ANSI-specified #error directive</strong></em>. Here’s a look at a couple of clever uses for <code>#error</code> that have proven invaluable in embedded software development.</p>
<p>The syntax of <code>#error</code> is very straightforward:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">&lt;writer supplied error message&gt;</span>  <span class="comment">//开发者提供的错误信息</span></span></span><br></pre></td></tr></table></figure>

<p><code>&lt;writer supplied error message&gt;</code> 中可包含任何可显示的文本，甚至不需要使用双引号 <code>&quot;&quot;</code> 。</p>
<blockquote>
<p>The <code> &lt;writer supplied error message&gt;</code> can consist of any  printable text. You don’t even have to enclose the text in quotes.  (Technically, the message is optional–though it rarely makes sense to omit it.)</p>
</blockquote>
<p>当C预处理器遇到 <code>#error</code> 语句时，会将停止编译，并将错误信息输出至 <code>stderr</code> 文件。C编译器的典型错误信息如下：</p>
<blockquote>
<p>When the C preprocessor encounters a <code>#error</code> statement, it causes  compilation to terminate and the writer-supplied error message to be  printed to <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Standard_streams">stderr (link is external)</a>. A typical error message from a C compiler looks like this:</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Filename(line_number): Error! </span><br><span class="line">Ennnn: &lt;writer supplied error message&gt; </span><br></pre></td></tr></table></figure>

<p>where Filename is the source file name, <code>line_number</code> is the line  number where the <code>#error</code> statement is located, and <code>Ennnn</code> is a  compiler-specific error number. Thus, the <code>#error</code> message is basically  indistinguishable from ordinary compiler error messages.</p>
<p>“Wait a minute,” you might say. “I spend enough time trying to get  code to compile and now he wants me to do something that causes more  compiler errors?” Absolutely! The essential point is that code that compiles but is incorrect is worse than useless. I’ve found three  general areas in which this problem can arise and <code>#error</code> can help. Read  on and see if you agree with me.</p>
<h2 id="Incomplete-code"><a href="#Incomplete-code" class="headerlink" title="Incomplete code"></a>Incomplete code</h2><p>I tend to code using a step-wise refinement approach, so it isn’t  unusual during development for me to have functions that do nothing, for loops that lack a body, and so forth. Consequently, I often have files  that are compilable but lack some essential functionality. Working this  way is fine, until I’m pulled off to work on something else (an  occupational hazard of being in the consulting business). Because these  distractions can occasionally run into weeks, I sometimes return to the  job with my memory a little hazy about what I haven’t completed. In the  worst-case scenario (which has occurred), I perform a make, which runs  happily, and then I attempt to use the code. The program, of course,  crashes and burns, and I’m left wondering where to start.</p>
<p>In the past, I’d comment the file to note what had been done and what was still needed. However, I found this approach to be rather weak  because I then had to read all my comments (and I comment heavily) in  order to find what I was looking for. Now I simply enter something like  the following in an appropriate place in the file:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#error *** Nigel - Function incomplete. Fix before using *** </span><br></pre></td></tr></table></figure>

<p>Thus, if I forget that I haven’t done the necessary work, an  inadvertent attempt to use the file will result in just about the most  meaningful compiler message I’ll ever receive. Furthermore, it saves me  from having to wade through pages of comments, trying to find what work I haven’t finished.</p>
<h2 id="Compiler-dependent-code"><a href="#Compiler-dependent-code" class="headerlink" title="Compiler-dependent code"></a>Compiler-dependent code</h2><p>As much as I strive to write portable code, I often find myself  having to trade off performance for portability - and in the embedded  world, performance tends to win. However, what happens if a few years  later I reuse some code without remembering that the code has <em><strong>compiler-specific peculiarities</strong></em>? The result is a much longer debug  session than is necessary. But a <em><strong>judicious</strong></em> <code>#error</code> statement can prevent a lot of grief. A couple of examples may help.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><p>Some floating-point code requires at least 12 digits of resolution to return the correct results. Accordingly, the various variables are defined as type long double. But <em><strong>ISO C</strong></em> only requires that <em><u>a long double have 10 digits of resolution</u></em>. Thus on certain machines, a long double may be <em><strong>inadequate</strong></em> to do the job. To protect against this, I would  include the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;float.h&gt;</span><br><span class="line">#if (LDBL_DIG &lt; 12) </span><br><span class="line">	#error *** long doubles need 12 digit resolution.</span><br><span class="line">	Do not use this compiler! *** </span><br><span class="line">#endif </span><br></pre></td></tr></table></figure>

<p>This approach works by examining the value of an ANSI-mandated constant found in <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Float.h">float.h (link is external)</a>.</p>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><p>An amazing amount of code makes invalid assumptions about the  underlying size of the various integer types. If you have code that has to use an int (as opposed to a user-specified data type such as <code>int16</code>),  and the code assumes that an int is 16 bits, you can do the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;limits.h&gt;</span><br><span class="line">#if (INT_MAX !&#x3D; 32767) </span><br><span class="line">	#error *** This file only works with 16-bit int.</span><br><span class="line">	Do not use this compiler! *** </span><br><span class="line">#endif </span><br></pre></td></tr></table></figure>

<p>Again, this works by checking the value of an ANSI-mandated constant. This time the constant is found in the file <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Limits.h">limits.h (link is external)</a>. This approach is a lot more useful than putting these limitations  inside a big comment that someone may or may not read. After all, you have to read the compiler error messages.</p>
<h2 id="Conditionally-compiled-code"><a href="#Conditionally-compiled-code" class="headerlink" title="Conditionally-compiled code"></a>Conditionally-compiled code</h2><p>Since conditionally compiled code seems to be a necessary evil in embedded programming, it’s common to find code sequences such as the  following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if defined OPT_1 </span><br><span class="line">	&#x2F;* Do option_1 *&#x2F; </span><br><span class="line">#else </span><br><span class="line">	&#x2F;* Do option_2 *&#x2F; </span><br><span class="line">#endif </span><br></pre></td></tr></table></figure>

<p>As it is written, this code means the following: if and only if OPT_1 is defined, we will do option_1; otherwise we’ll do option_2. The  problem with this code is that a user of the code doesn’t know (without explicitly examining the code) that OPT_1 is a valid compiler switch.  Instead, the naive user will simply compile the code without defining OPT_1 and get the alternate implementation, irrespective of whether  that is what’s required or not. A more considerate coder might be aware  of this problem, and instead do the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if defined OPT_1 </span><br><span class="line">	&#x2F;* Do option 1 *&#x2F; </span><br><span class="line">#elif defined OPT_2 </span><br><span class="line">	&#x2F;* Do option 2*&#x2F; </span><br><span class="line">#endif </span><br></pre></td></tr></table></figure>

<p>In this case, failure to define either OPT_1 or OPT_2 will typically  result in an obscure compiler error at a point later in the code. The  user of this code will then be stuck with trying to work out what must  be done to get the module to compile. This is where #error comes in.  Consider the following code sequence:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if defined OPT_1 </span><br><span class="line">	&#x2F;* Do option_1 *&#x2F; </span><br><span class="line">#elif defined OPT_2 </span><br><span class="line">	&#x2F;* Do option_2 *&#x2F; </span><br><span class="line">#else </span><br><span class="line">	#error *** You must define one of OPT_1 or OPT_2 *** </span><br><span class="line">#endif </span><br></pre></td></tr></table></figure>

<p>Now the compilation fails, but at least it tells the user explicitly  what to do to make the module compile. I know that if this procedure had been adopted universally, I would have saved a lot of time over the  years trying to reuse other people’s code.</p>
<p>So there you have it. Now tell me, don’t you agree that <code>#error</code> is a  really useful part of the preprocessor, worthy of your frequent use-and  occasional praise?</p>
<p>​          </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备19004822号 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liewzheng</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
