<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;islet.space&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script>
<meta name="description" content="笔记分享的旮旯孤岛而已">
<meta property="og:type" content="website">
<meta property="og:title" content="Coder的孤岛">
<meta property="og:url" content="http://islet.space/page/2/index.html">
<meta property="og:site_name" content="Coder的孤岛">
<meta property="og:description" content="笔记分享的旮旯孤岛而已">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liewzheng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://islet.space/page/2/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;en&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;2&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Coder的孤岛</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Coder的孤岛</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">islet of the coder</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liewzheng</p>
  <div class="site-description" itemprop="description">笔记分享的旮旯孤岛而已</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/03/25/Hardware/TI-%E5%A4%9A%E6%A0%B8%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/25/Hardware/TI-%E5%A4%9A%E6%A0%B8%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">TI-Multicore 开发笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-25 23:58:32" itemprop="dateCreated datePublished" datetime="2021-03-25T23:58:32+08:00">2021-03-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-26 00:17:11" itemprop="dateModified" datetime="2021-04-26T00:17:11+08:00">2021-04-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hardware/" itemprop="url" rel="index"><span itemprop="name">Hardware</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>多核开发涉及多核通信及任务分配管理的问题，任何多核通信都需要针对具体芯片的型号及系统特性去设计。多核通信包括资源共享、竞争、同步、异步等问题；多核任务分配则关系着各核心任务均衡和RTOS系统能否及时响应的问题。</p>
<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><h2 id="并发、并行、异步、同步、共享、互斥、进程、线程"><a href="#并发、并行、异步、同步、共享、互斥、进程、线程" class="headerlink" title="并发、并行、异步、同步、共享、互斥、进程、线程"></a>并发、并行、异步、同步、共享、互斥、进程、线程</h2><h3 id="Concurrency-并发"><a href="#Concurrency-并发" class="headerlink" title="Concurrency 并发"></a>Concurrency 并发</h3><p>仅表示计算机可以同时执行多项任务，以至于如何实现“同时”执行，则有许多不同形式。</p>
<p>如，单核处理器可以通过分配时间片，轮询任务来达到多任务并发。系统让一个任务运行一段时间，在切换到另一个任务运行，如此循环往复，此过程也被称为 线程的<strong>上下文切换（Context Switching）</strong>。</p>
<h3 id="Parallelism-并行"><a href="#Parallelism-并行" class="headerlink" title="Parallelism 并行"></a>Parallelism 并行</h3><p>多个任务于同一时刻在不同的和核心上进行处理，称为并行</p>
<h3 id="Synchronization-同步"><a href="#Synchronization-同步" class="headerlink" title="Synchronization 同步"></a>Synchronization 同步</h3><p>指程序任务间的先后关系，后面一个程序必须等前一个任务执行完毕方可启动。因此，在同步中，并无并发或并行概念</p>
<h3 id="Asynchronization-异步"><a href="#Asynchronization-异步" class="headerlink" title="Asynchronization 异步"></a>Asynchronization 异步</h3><p>指不同的任务之间不会相互等待</p>
<p>对于I/O资源访问频繁的系统，宜使用异步编程，</p>
<h3 id="Mutual-Exclusion-互斥"><a href="#Mutual-Exclusion-互斥" class="headerlink" title="Mutual Exclusion 互斥"></a>Mutual Exclusion 互斥</h3><p>程序内存开销 及 线程切换开销</p>
<h2 id="堆、栈"><a href="#堆、栈" class="headerlink" title="堆、栈"></a>堆、栈</h2><p>题目所指的 heap 和 stack 在 C++ 标准中相对的术语分别是<strong>自由存储</strong>（free store，即用<code>new</code>创建对象时所分配的空间）和<strong>自动变量</strong>（automatic variable，或称为局部变量，不要与 C++11 的<code>auto</code>混淆）。</p>
<p>编程角度，要分开两者，是因为两者的生命周期不一样。</p>
<p>如果只需要在作用域内维持变量的生命周期，最好就用自动变量，这样是最简单方便高效的。其他情况可考虑用自由存储、静态局部／全局变量，或类的（静态）成员变量。它们各有不同特点，不在此答案详述。另外，由于 C++ 不支持可变长数组（VLA），不可以定义动态长度的自动变量（成员变量也不行），这个情况下也需要用 new[] 来创建动态长度的数组。</p>
<p>自动变量会在作用域（如函数作用域、块作用域等）结束后析构、释放内存。因为分配和释放的次序是刚好完全相反的，所以可用到堆栈先进后出（first-in-last-out, FILO）的特性，而 C++ 语言的实现一般也会使用到调用堆栈（call stack）来分配自动变量（但非标准的要求）。<br>自由存储可以在函数结束后继续生存，所以也需要配合 delete 来手动析构、释放内存（也可使用智能指针避免手动 delete）。由于分配和释放次序没有限制，不能使用堆栈这种数据结构做分配，实现上可能采用自由链表（free list）或其他动态内存分配机制。</p>
<p><strong>堆</strong>，英文是 heap，在内存管理的语境下，指的是动态分配内存的区域。这个堆跟数据结构里的堆不是一回事。这里的内存，被分配之后需要手工释放，否则，就会造成内存泄漏。</p>
<p>C++ 标准里一个相关概念是自由存储区(free store)，特指使用 <code>new</code> 和 <code>delete</code> 来分配和释放内存的区域。一般而言，free store是堆(heap)的一个子集，原因如下：</p>
<ul>
<li><code>new</code> 和 <code>delete</code> 操作的区域是 free store；<code>malloc</code> 和 <code>free</code> 操作的区域是 heap</li>
<li><code>new</code> 和 <code>delete</code> 通常底层使用 <code>malloc</code> 和 <code>free</code> 来实现</li>
</ul>
<p><strong>栈</strong>，英文是 stack，在内存管理的语境下，指的是函数调用过程中产生的本地变量和调用数据的区域。这个栈和数据结构里的栈高度相似，都满足“后进先出”（last-in-first-out 或 LIFO）。</p>
<p><strong>RAII</strong>，完整的英文是 Resource Acquisition Is Initialization，是 C++ 所特有的资源管理方式。有少量其他语言，如 D、Ada 和 Rust 也采纳了 RAII，但主流的编程语言中， C++ 是唯一一个依赖 RAII 来做资源管理的。</p>
<p>RAII 依托栈和析构函数，来对所有的资源——包括堆内存在内——进行管理。对 RAII 的使用，使得 C++ 不需要类似于 Java 那样的垃圾收集方法，也能有效地对内存进行管理。RAII 的存在，也是垃圾收集虽然理论上可以在 C++ 使用，但从来没有真正流行过的主要原因。 </p>
<p>嵌入式的设备如DSP上的栈空间是Kb级别，在函数内定义数组或申请空间都不能像linux下那样直接定义和申请，要么定义成全局的，要么指向一块划分好的空间，否则就会造成覆盖代码段等的问题。</p>
<p>DSP的所有变量，函数，以及程序员定义的地址都保存在这三片空间上，程序员在定义变量时，若没有特殊规定，则编译器自动把变量分配到可读写空间上的任意位置，所以当程序员使用 <code>int *p = 0x00810000</code> ；这种语法的时候，很有可能会覆盖掉程序保存变量和函数的空间，导致程序运行异常，因此需要一个 <code>.cmd</code> 文件来约束，哪些地方用来给程序员自己定义变量地址用，哪些地方用来给程序为变量和函数申请内存来用。</p>
<h1 id="2-多核通信模块"><a href="#2-多核通信模块" class="headerlink" title="2. 多核通信模块"></a>2. 多核通信模块</h1><blockquote>
<p><em>IPC Modules can be used in a variety of combinations.</em> </p>
</blockquote>
<p>以上即是说，各类IPC模块可以根据需要进行组合混用。</p>
<p>IPC以独立插件的形式进行安装与使用，使用时可能需要手动挂载至项目属性中。</p>
<p>Here are some introductions about heap in the &lt;SPRUEX3K.pdf&gt; as follows: </p>
<blockquote>
<p>SYS/BIOS provides the following Heap implementations:</p>
<ul>
<li><strong>HeapMem.</strong> Allocate variable-size blocks. Section 6.8.1</li>
<li><strong>HeapBuf.</strong> Allocate fixed-size blocks. Section 6.8.2</li>
<li><strong>HeapMultiBuf.</strong> Specify variable-size allocation, but internally allocate from a variety of fixed-size<br>blocks. Section 6.8.3</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>Module</th>
<th>Module Path</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>GateMP（门）</td>
<td><code>GateMP</code></td>
<td>Manages gates for mutual exclusion of shared resources by multiple processors and threads. <br/><em>See Section 2.6.</em></td>
</tr>
<tr>
<td>HeapBufMP（堆缓存）</td>
<td><code>ti.sdo.ipc.heaps.HeapBufMP</code></td>
<td>Fixed-sized shared memory Heaps. Similar to SYS/BIOS’s <code>ti.sysbios.heaps.HeapBuf </code> module, but with some configuration differences. <br/><em>See Section 2.5.</em></td>
</tr>
<tr>
<td>HeapMemMP（堆储存）</td>
<td><code>ti.sdo.ipc.heaps.HeapMemMP</code></td>
<td>Variable-sized shared memory Heaps. <br/><em>See Section 2.5.</em></td>
</tr>
<tr>
<td>HeapMultiBufMP（堆混合缓存）</td>
<td><code>ti.sdo.ipc.heaps.HeapMultiBufMP</code></td>
<td>Multiple fixed-sized shared memory Heaps. <br/><em>See Section 2.5.</em></td>
</tr>
<tr>
<td>Ipc（核间通信）</td>
<td><code>ti.sdo.ipc.Ipc</code></td>
<td>Provides <code>Ipc_start()</code> function and allows startup sequence configuration. <br/><em>See Section 2.2.</em></td>
</tr>
<tr>
<td>ListMP（列表）</td>
<td><code>ti.sdo.ipc.ListMP</code></td>
<td>Doubly-linked list for shared-memory, multi-processor applications. Very similar to the ti.sdo.utils.List module. <br/><em>See Section 2.4.</em></td>
</tr>
<tr>
<td>MessageQ （Q报文）</td>
<td><code>ti.sdo.ipc.MessageQ</code></td>
<td>Variable size messaging module. 可拥有不同大小的信息模块。<br/><em>See Section 2.3.</em></td>
</tr>
<tr>
<td>TransportShm（运输表）</td>
<td><code>ti.sdo.ipc.transports.TransportShm</code></td>
<td>Transport used by MessageQ for remote communication with other processors via shared memory. <br/><em>See Section 2.3.11.</em></td>
</tr>
<tr>
<td>Notify （通知）</td>
<td><code>ti.sdo.ipc.Notify</code></td>
<td>Low-level interrupt mux/demuxer module. <br/><em>See Section 2.7.</em></td>
</tr>
<tr>
<td>NotifyDriverShm（通知驱动表）</td>
<td><code>ti.sdo.ipc.notifyDrivers.NotifyDriverShm</code></td>
<td>Shared memory notification driver used by the Notify module to communicate between a pair of processors. <br/><em>See Section 2.7.</em></td>
</tr>
<tr>
<td>SharedRegion （共享区域）</td>
<td><code>ti.sdo.ipc.SharedRegion</code></td>
<td>Maintains shared memory for multiple shared regions. <br/><em>See Section 2.8.</em></td>
</tr>
</tbody></table>
<h2 id="Header-Files-included"><a href="#Header-Files-included" class="headerlink" title="Header Files included"></a>Header Files included</h2><p>除了<code> &lt;ipc_install_dir&gt;/packages/ti/ipc/</code> 路径下可以找到IPC必须的头文件外， <code>&lt;ipc_install_dir&gt;/packages/ti/sdo/ipc/</code> 路径下同样有IPC的头文件，但是请勿直接引用至 <code>.c</code>文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/std.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/* ---- XDC.RUNTIME module Headers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/runtime/Memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/runtime/System.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/runtime/IHeap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/runtime/Timestamp.h&gt;</span>    <span class="comment">//not officially included</span></span></span><br><span class="line"><span class="comment">/* ----- IPC module Headers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/ipc/GateMP.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/ipc/Ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/ipc/MessageQ.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/ipc/HeapBufMP.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/ipc/MultiProc.h&gt;</span></span></span><br><span class="line"><span class="comment">/* ---- BIOS6 module Headers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/sysbios/BIOS.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/sysbios/knl/Task.h&gt;</span></span></span><br><span class="line"><span class="comment">/* ---- Get globals from .cfg Header */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/cfg/global.h&gt;</span></span></span><br></pre></td></tr></table></figure>



<h2 id="Standard-IPC-Function-Call-Sequence"><a href="#Standard-IPC-Function-Call-Sequence" class="headerlink" title="Standard IPC Function Call Sequence"></a>Standard IPC Function Call Sequence</h2><p>Standard IPC Function Call Sequence，即标准IPC函数的调用顺序。</p>
<blockquote>
<p> <em><strong>MODULE</strong></em> 在本处指任一类型的IPC调用（如，GateMP、IPC、MessageQ等），如  <code>MODULE_Open()</code> 即可替换成 <code>MessageQ_Open()</code> ，具体实参见对应的头文件。</p>
</blockquote>
<p>An application that uses IPC APIs—such as <code>MessageQ</code>, <code>GateMP</code>, and <code>ListMP</code>—**must include the Ipc module header file and call <code>Ipc_start()</code> in the <code>main()</code> function. ** <code>Ipc_start()</code> does the following:</p>
<ul>
<li>初始化：Initializes a number of objects and modules used by IPC.</li>
<li>同步：Synchronizes multiple processors so they can boot in any order.</li>
</ul>
<p><strong>NOTES:</strong> If the <code>main()</code> function calls any IPC APIs, the call to <code>Ipc_start()</code> must be placed before any calls to IPC modules.</p>
<h3 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h3><ul>
<li>Firstly, initialize a <code>MODULE_Params</code> structure to its default values via a <code>MODULE_Params_init() </code> function.  The creator thread can then set individual parameter fields in this structure as needed.</li>
<li>Secondly, calls the <code>MODULE_create()</code> function to creates the instance and initializes any shared memory used by the instance. <em>If the instance is to be opened remotely, a unique name must be supplied in the parameters.</em></li>
<li>Other threads can access this instance via the <code>MODULE_open()</code> function, which <strong>returns a handle with access to the instance.</strong> The name that was used for instance creation must be used in the <code>MODULE_open()</code> function.</li>
<li>Finally, the thread that called <code>MODULE_create()</code> can call <code>MODULE_delete()</code> to free the memory used by the instance.</li>
</ul>
<blockquote>
<ul>
<li>首先，使用 <code>MODULE_Params_init() </code> 来初始化 <code>MODULE_Params</code> 结构。（创建它的线程）可以根据需要单独调整结构体内的个别参数。</li>
<li>然后，调用 <code>MODULE_create()</code> 函数来创建对象实例，并初始化其内存。如果该对象在别处被打开，需要给被调用的参数取好名字防止重复。</li>
<li>接着， 其他线程可以通过 <code>MODULE_open()</code>  函数接入该对象，并返回一个对应的句柄。该对象的创建名称必须与打开名称保持一致。</li>
<li>最后，调用 <code>MODULE_create()</code> 来创建对象实例的线程就可以调用 <code>MODULE_delete()</code> 来释放被对象占用的内存。</li>
</ul>
</blockquote>
<p><strong>注意：</strong> </p>
<blockquote>
<p><em>All threads that opened an instance must close that instance before the thread that created it can delete it.</em> <em>Also, a thread that calls <code>MODULE_create()</code> cannot call <code>MODULE_close()</code>.</em> <em>Likewise, a thread that calls <code>MODULE_open()</code> cannot call <code>MODULE_delete()</code>.</em></p>
<p>在由创建者删除（delete）某IPC对象时，由谁使用（open）就由谁关闭（close）。且决不能由创建者来调用关闭函数，否则创建者无法删除该对象。（顺序如下图所示）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stateDiagram-v2</span><br><span class="line">	[*] --&gt; Core0</span><br><span class="line">	[*] --&gt; Core1</span><br><span class="line">	Core0 --&gt; IPC_Start()</span><br><span class="line">	IPC_Start() --&gt; Module_Create()</span><br><span class="line">	IPC_Start() --&gt; Core1 : Wait for Sychronization</span><br><span class="line">	Core1 --&gt; UsersProgram()</span><br><span class="line">	UsersProgram() --&gt; Module_Open()</span><br><span class="line">	Module_Open() --&gt; Module_Close()</span><br><span class="line">	Module_Create() --&gt; Module_Delete()</span><br><span class="line">	Module_Close() --&gt; Module_Delete() : Closed by who opens</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="Ipc-Start-使用示例"><a href="#Ipc-Start-使用示例" class="headerlink" title="Ipc_Start() 使用示例"></a>Ipc_Start() 使用示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/ipc/Ipc.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="function">Int <span class="title">main</span><span class="params">(Int argc, Char* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     Int status;</span><br><span class="line">     <span class="comment">/* Call Ipc_start() */</span></span><br><span class="line">     status = Ipc_start();</span><br><span class="line">     <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         System_abort(<span class="string">&quot;Ipc_start failed\n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     BIOS_start();</span><br><span class="line">     <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="MessageQ-Create-使用示例"><a href="#MessageQ-Create-使用示例" class="headerlink" title="MessageQ_Create() 使用示例"></a>MessageQ_Create() 使用示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">messageQ = MessageQ_create(DSP_MESSAGEQNAME, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (messageQ == <span class="literal">NULL</span>) &#123;   <span class="comment">//an error occurred when creating the object</span></span><br><span class="line">	System_abort(<span class="string">&quot;MessageQ_create failed\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Error-Handling-in-IPC"><a href="#Error-Handling-in-IPC" class="headerlink" title="Error Handling in IPC"></a>Error Handling in IPC</h2><p>Success codes always have values greater or equal to zero. The Failure codes are always negative.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MessageQ_Msg msg; </span><br><span class="line">MessageQ_Handle messageQ;</span><br><span class="line">Int status;</span><br><span class="line">...</span><br><span class="line">status = MessageQ_get(messageQ, &amp;msg, MessageQ_FOREVER);</span><br><span class="line"><span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	System_abort(<span class="string">&quot;Should not happen\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="IPC-Module-Configuration"><a href="#IPC-Module-Configuration" class="headerlink" title="IPC Module Configuration"></a>IPC Module Configuration</h2><p>Configure how the IPC module synchronizes processors by configuring the <code>Ipc.procSync</code> property. For example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CONFIGURATION ABOUT INTER-PROCESS COMMUNICATION */</span></span><br><span class="line">var Ipc = xdc.useModule(&#x27;ti.sdo.ipc.Ipc&#x27;);</span><br><span class="line">Ipc.procSync = Ipc.ProcSync_ALL;</span><br></pre></td></tr></table></figure>

<p>Here are three options: <code>Ipc.ProcSync_ALL</code> | <code>Ipc.ProcSync_PAIR</code> | <code>Ipc.ProcSync_NONE</code></p>
<table>
<thead>
<tr>
<th>Options</th>
<th>Conditions</th>
<th>Specialties</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Ipc.ProcSync_ALL</strong></td>
<td>- IPC processors on a device start up at the same time<br/>- Connections should be established between every possible pair of processors</td>
<td>- <code>Ipc_start() API</code> automatically attaches to and synchronizes all remote processors.  <br/>- Application <em><strong>should never call</strong></em> <code>Ipc_attach()</code>.</td>
</tr>
<tr>
<td><strong>Ipc.ProcSync_PAIR</strong> <em>(Default Mode)</em></td>
<td><em>One of the following is true:</em><br>- You need to control when synchronization with each remote processor occurs.<br/>- Useful work can be done while trying to synchronize with a remote processor by yielding a thread after each attempt to Ipc_attach() to the processor. <br/> - Connections to some remote processors are unnecessary and should be made selectively to save memory.</td>
<td>- Must explicitly call <code>Ipc_attach()</code> to attach to a specific remote processor. <br/>- <code>Ipc_start()</code> performs system-wide IPC initialization, but does not <strong>make connections to remote processors</strong>.</td>
</tr>
<tr>
<td><strong>Ipc.ProcSync_NONE</strong></td>
<td><em>Use this option with caution.</em> <br/>It is intended for use in cases where the application performs its own synchronization and you want to avoid a potential deadlock situation with the IPC synchronization.</td>
<td><code>Ipc_start()</code> doesn’t synchronize any processors before setting up the objects needed by other modules.</td>
</tr>
</tbody></table>
<h4 id="Attach-and-Detach-（依附与分离）"><a href="#Attach-and-Detach-（依附与分离）" class="headerlink" title="Attach and Detach （依附与分离）"></a>Attach and Detach （依附与分离）</h4><p>In addition to the default actions performed when attaching to or detaching from a remote processor, You can configure a function to perform custom actions. </p>
<p>Attach and Detach are provided for the processor synchronization:</p>
<ul>
<li><p><code>Ipc_attach()</code> Creates a connection to the specified remote processor. </p>
</li>
<li><p><code>Ipc_detach()</code> Deletes the connection to the specified remote processor.</p>
</li>
</ul>
<p>在 <code>.cfg</code> 文件中以下为两个互相依赖和两个互相分离的函数配置，每一组函数都会传递一个不同的参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Ipc = xdc.useModule(&#x27;ti.sdo.ipc.Ipc&#x27;);</span><br><span class="line"></span><br><span class="line">var fxn = <span class="keyword">new</span> Ipc.UserFxn;</span><br><span class="line">fxn.attach = &#x27;&amp;userAttachFxn1&#x27;;</span><br><span class="line">fxn.detach = &#x27;&amp;userDetachFxn1&#x27;;</span><br><span class="line">Ipc.addUserFxn(fxn, <span class="number">0x1</span>);</span><br><span class="line"></span><br><span class="line">fxn.attach = &#x27;&amp;userAttachFxn2&#x27;;</span><br><span class="line">fxn.detach = &#x27;&amp;userDetachFxn2&#x27;;</span><br><span class="line">Ipc.addUserFxn(fxn, <span class="number">0x2</span>);</span><br></pre></td></tr></table></figure>

<p><em><strong>These functions run near the end of <code>Ipc_attach()</code> and near the beginning of <code>Ipc_detach()</code> , respectively.</strong></em></p>
<p><em><strong>Such functions must be non-blocking and must run to completion. 这些被定义的函数必须为非阻塞且（一旦开始就）运行到底。</strong></em></p>
<p><strong>注意：</strong> Call <code>Ipc_attach()</code> to the processor that owns shared memory region 0 (usually the processor with id = 0) before making a connection to any other remote processor. For example, if there are three processors configured with <em><strong>MultiProc</strong></em>, #1 should attach to #0 before it can attach to #2.</p>
<h1 id="3-多核任务分配"><a href="#3-多核任务分配" class="headerlink" title="3. 多核任务分配"></a>3. 多核任务分配</h1><blockquote>
<p>如果多个核共享一个工程及相同的bios 配置文件，是不能指定某一个任务到特定的core上，如果某个任务只有某个core才会运行，可以在任务中区分core运行。如果多个core分别有不同的工程，则没有“多核任务分配”的问题，每个工程可以根据各自core的应用创建各自的任务，不需要软件区分core。</p>
</blockquote>
<blockquote>
<p>单核可以是一个out生成最终的bin文件烧写在flash，多核如果存在多个out文件，可以把out文件合并成一个bin烧写，或者多个bin分开烧写均可。bin文件中都有程序的地址及长度信息，在多个bin时，也是一样可以由core0负责对flash的程序文件解析，将程序搬移到相应的地址上，最后core0再向其他core magic address写入入口地址，并发送ipc触发即可。</p>
</blockquote>
<blockquote>
<p>这个并非由SYS/BIOS分配，需要开发者指定。</p>
<p>可以根据core number来做判断，然后确认该任务是否运行在该核上。 </p>
</blockquote>
<h1 id="4-Chip-Support-Library"><a href="#4-Chip-Support-Library" class="headerlink" title="4. Chip Support Library"></a>4. Chip Support Library</h1><p>CSL，即芯片支持库( Chip Support Library)。在程序设计过程中利用CSL库函数可以方便地访问 <strong>DSP的寄存器和硬件资源</strong>，提高DSP软件的开发效率和速度。</p>
<p>CSL库包含了对INTC、Boot Configuration、BWMNGMT、CACHE、CHIP、CPINTC、EDMA3、EMAC、EMIF4F、GPIO、IDMA、IPC、MDIO、MEMPROT、MPU、MSMC、PLLC、PSC、Semaphore、SGMII、SRIO、TIMER、TSC、VCP2、XMC、CGEM、CPPI、QMSS、CPPI_LLD_SYMBOL 及 CPPI_LLD_ENUM共30种模块的支持。</p>
<h2 id="Cache-Module"><a href="#Cache-Module" class="headerlink" title="Cache Module"></a>Cache Module</h2><p>位于 <code>ti\pdk_C6657_1_1_2_6\packages\ti\csl\</code> 下的头文件 <code>&lt;csl_cacheAux.h&gt;</code> 提供了缓存（Cache）配置相关的CSL功能层API。</p>
<blockquote>
<p>This is the CACHE Auxilary Header File which exposes the <em><strong>various CSL Functional Layer API</strong></em>‘s to <em><strong>configure the CACHE Module</strong></em>.</p>
</blockquote>
<blockquote>
<p>Cache API包含了对L1D（L1 Data Cache）、L1P 及 L2的各种操作。关于L1D、L1P及L2 的详细文件参考《SPRS814D》第193页。</p>
</blockquote>
<p>该头文件中对三种缓存的可操作方式如下示：</p>
<table>
<thead>
<tr>
<th>OPERATION</th>
<th>L1D</th>
<th>L1P</th>
<th>L2</th>
</tr>
</thead>
<tbody><tr>
<td>setSize</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>getSize</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>freeze</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>unfreeze</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>getPrevMode<br/><em>– get the previous operating state</em></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>invAllWait<br/><em>– wait for the cache global invalidate operation to complete</em></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>invAll<br/><em>– globally invalidate cache</em></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>wbAllWait<br/><em>– wait for the cache writeback operation to complete</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>wbAll<br/><em>– writeback the dirty lines of the cache</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>wbInvAllWait<br/><em>– wait for the cache writeback invalidate operation to complete</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>wbInvAll<br/><em>– invalidate and writeback the dirty lines of the cache</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>invWait<br/><em>– wait for the cache invalidate block operation to complete</em></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>inv<br/><em>– to invalidate a block in cache</em></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>wbWait<br/><em>– wait for the cache writeback block operation to complete</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>wb<br/><em>– writeback the dirty lines of the block address</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>wbInvWait<br/><em>– wait for the cache invalidate/writeback block operation to complete</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>wbInv<br/><em>– invalidate and writeback the dirty lines of the block address</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="IPC-Module"><a href="#IPC-Module" class="headerlink" title="IPC Module"></a>IPC Module</h2><p>IPC，即进程间通信（Inter-process communication）。</p>
<p>位于 <code>ti\pdk_C6657_1_1_2_6\packages\ti\csl\</code> 下的头文件 <code>&lt;csl_ipcAux.h&gt;</code> 提供了<strong>查询定义</strong> 和 <strong>控制函数</strong>。IPC API包含了对 NMI、GEM、Host的各种操作。其中 <strong>GEM</strong> 对 IPCGRx 及 IPCARx 进行操作；而 <strong>Host</strong> 对 IPCGRH 及 IPCARH 进行操作。</p>
<p><strong>注意：</strong> 下文中， <code>index</code> 和 <code>srcId</code> 均是函数形参，如在<code>CSL_IPC_isGEMInterruptAckSet（uint32 index, uint32 srcId)</code>中：<code>index</code> 指需要检查IPCARx寄存器的GEM编号。<code>srcId</code> 指示在指定的索引对应的IPCARx寄存器中需要读取0-27 SRCCx位中的哪一个。</p>
<blockquote>
<p><strong>NMI</strong>，即 <strong>不可屏蔽中断</strong>（Non Maskable Interrupt）。<strong>NMIG</strong>，即 <strong>不可屏蔽中断产生寄存器</strong>（NMI Generation Register *(NMIGRx)*）。NMIGRx registers are used for generating NMI events to the corresponding CorePac. The C6657 has two NMIGRx registers (NMIGR0 and NMIGR1). The NMIGR0 register generates an NMI event to CorePac0, and the NMIGR1 register generates an NMI event to CorePac1.Writing 1 to the NMIG field generates an NMI pulse. Writing 0 has no effect and reads return 0 and have no other effect.</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_09-00-03.png" style="zoom:50%;" />

<p><strong>IPCGRx</strong>，即 <strong>进程间通信产生寄存器</strong>（IPC interrupt generation register）。IPCGRx are to facilitate inter CorePac interrupts. The C6657 has two IPCGRx registers (IPCGR0 and IPCGR1). These registers can be used by external hosts or CorePacs to generate interrupts to other CorePacs. A write of 1to the IPCG field of the IPCGRx register will generate an interrupt pulse to CorePacx (0 &lt;= x &lt;= 1).</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_08-54-09.png" style="zoom:50%;" />

<p><strong>IPCARx</strong>，即 <strong>IPC中断确认寄存器</strong>（IPC interrupt-acknowledgement registers）。IPCARx are to facilitate inter-CorePac core interrupts. The C6657 has two IPCARx registers (IPCAR0 and IPCAR1). These registers also provide a <em>Source ID facility</em> by which up to 28 different sources of interrupts can be identified. Allocation of source bits to source processor and meaning is entirely based on software convention. The register field descriptions are shown in the following tables. Virtually anything can be a source for these registers as this is completely controlled by software. Any master that has access to BOOTCFG module space can write to these registers.</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_08-57-22.png" style="zoom:50%;" />

<p><strong>IPCGRH</strong>，即 <strong>主机IPC产生寄存器</strong>（IPC Generation Host）。The IPCGRH register facilitates interrupts to external hosts. Operation and use of the IPCGRH register is the same as for other IPCGR registers. The interrupt output pulse created by the IPCGRH register appears on device pin HOUT. <mark><i>The host interrupt output pulse should be stretched. It should be asserted for 4 bootcfg clock cycles (CPU/6) followed by a deassertion of 4 bootcfg clock cycles. Generating the pulse will result in 8 CPU/6 cycle pulse blocking window. </i></mark>Write to IPCGRH with IPCG bit (bit 0) set will only generate a pulse if they are beyond 8 CPU/6 cycle period. </p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_09-33-14.png" style="zoom:50%;" />

<p><strong>IPCARH</strong>，即 <strong>主机IPC确认寄存器</strong>（Host IPC Acknowledgment Register）。</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_14-57-07.png" style="zoom: 67%;" />
</blockquote>
<p>该头文件中的可操作方式如下示：</p>
<table>
<thead>
<tr>
<th></th>
<th>NMI</th>
<th>GEM</th>
<th>Host</th>
</tr>
</thead>
<tbody><tr>
<td>genEvent</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>genInterrupt<br><em>– generate an interrupt pulse</em></td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>isInterruptSourceSet</td>
<td></td>
<td>√<br><em>– checks if the SRCSx bit of the <strong>IPCGRx</strong> register is set</em></td>
<td>√<br><em>– checks if the SRCSx bit of the <strong>IPCGRH</strong> register is set</em></td>
</tr>
<tr>
<td>isInterruptAckSet</td>
<td></td>
<td>√<br><em>– checks if the SRCCx bit of the <strong>IPCARx</strong> register is set.</em></td>
<td>√<br><em>– checks if the SRCCx bit of the <strong>IPCARH</strong> register is set.</em></td>
</tr>
<tr>
<td>clearInterruptSource</td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p><code>isGEMInterruptSourceSet()</code> returns 1 if the <u>SRCCx bit corresponding to the <strong>srcId</strong> is set</u> in the IPCARx register corresponding to the index specified. 如果与srcId对应的SRCCx位在与指定索引对应的IPCARx寄存器中被设置，则返回1。</p>
<blockquote>
<p><code>CSL_IPC_clearGEMInterruptSource()</code> clears the interrupt source IDs by setting the <strong>SRCCx bit of IPCARx</strong> and <strong>SRCSx bit of IPCGRx</strong> corresponding to the GEM index and Source ID specified.  </p>
<p><code>CSL_IPC_clearGEMInterruptSource()</code> 通过设置 <em><strong>GEM 索引</strong></em> 和 <em><strong>指定源 ID</strong></em> 对应的 <strong>IPCARx寄存器上的SRCCx位</strong> 和 <strong>IPCGRx寄存器上的SRCSx位</strong> 来清除 中断源ID 。</p>
</blockquote>
<blockquote>
<p><code>CSL_IPC_clearHostInterruptSource()</code> function clears the interrupt source IDs by setting the <strong>SRCCx bit of IPCARH</strong> and <strong>SRCSx bit of IPCGRH</strong> corresponding to the Source ID specified.  </p>
<p><code>CSL_IPC_clearHostInterruptSource()</code> 通过设置 <em><strong>指定源ID</strong></em> 对应的 <strong>IPCARH上的SRCCx位</strong> 和 <strong>IPCGRH上的SRCSx位</strong> 来清楚中断源ID。</p>
</blockquote>
<h3 id="CACHE-wbInvL1d"><a href="#CACHE-wbInvL1d" class="headerlink" title="CACHE_wbInvL1d()"></a>CACHE_wbInvL1d()</h3><p>This function is used to <mark><strong>invalidate and writeback</strong> the <em>dirty lines</em> of the block address</mark>.  </p>
<p>Although the block size can be specified in the number of bytes, the cache controller operates on whole cache lines. </p>
<p>To prevent unintended behavior “blockPtr” should be aligned on the cache line size and “byteCnt” should be a multiple of the cache line size.</p>
<h3 id="CACHE-invL1d"><a href="#CACHE-invL1d" class="headerlink" title="CACHE_invL1d ()"></a>CACHE_invL1d ()</h3><p>This function is used to <mark><strong>invalidate</strong> a <em>block</em> in the L1D Cache</mark>. </p>
<p>Although the block size can be specified in the number of bytes, the cache controller operates on whole cache lines. </p>
<p>To prevent unintended behavior “blockPtr” should be aligned on the cache line size and “byteCnt” should be a multiple of the cache line size.</p>
<h2 id="Chip-Module"><a href="#Chip-Module" class="headerlink" title="Chip Module"></a>Chip Module</h2><p><code>#include &lt;csl_chipAux.h&gt;</code></p>
<p>本头文件是以C( <code>extern &quot;C&quot;</code> )的方式来书写的，包含芯片读取与写入相关操作的API，名称以 <code>CSL_chipRead</code> 或 <code>CSL_chipWrite</code> 开头，所有函数均以静态内联（static inline，重定义成 <code>CSL_IDEF_INLINE</code> ）32位非负整数（Uint32）的方式定义，如 <code>CSL_IDEF_INLINE Uint32 CSL_chipRead***();</code> 。</p>
<p><code>&lt;csl_chipAux.h&gt;</code> 提供了26个读取寄存器相关的函数，函数定义均是对寄存器的读取并返回数值，某些读取函数需要注意 <em>前置条件</em>（Pre-condition）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CSL_chipReadAMR();    <span class="comment">//Addressing Mode control register 寻址模式控制寄存器</span></span><br><span class="line">CSL_chipReadCSR();    <span class="comment">//Control Status register 控制状态寄存器</span></span><br><span class="line">CSL_chipReadIFR();    <span class="comment">//Interrupt Flag register 中断标志寄存器</span></span><br><span class="line">CSL_chipReadIER();    <span class="comment">//Interrupt Enable register 中断使能寄存器</span></span><br><span class="line">CSL_chipReadISTP();    <span class="comment">//Interrupt Service Table Pointer register 中断服务表指针寄存器</span></span><br><span class="line">CSL_chipReadIRP();    <span class="comment">//Interrupt Return Pointer register 中断返回指针寄存器</span></span><br><span class="line">CSL_chipReadNRP();    <span class="comment">//Nonmaskable Interrupt Return Pointer register </span></span><br><span class="line">CSL_chipReadERP();    <span class="comment">//Exception Return Pointer register 异常返回指针寄存器</span></span><br><span class="line">CSL_chipReadTSCL();    <span class="comment">//Time Stamp Counter Lower Order 32-bits register 时间戳计数器低32位</span></span><br><span class="line">CSL_chipReadTSCH();    <span class="comment">//Time Stamp Counter Higer Order 32-bits register 时间戳计数器高32位</span></span><br><span class="line">CSL_chipReadARP();    <span class="comment">//Analysis Return Pointer register </span></span><br><span class="line">CSL_chipReadILC();    <span class="comment">//Inner Loop SPL buffer Counter(ILC) register</span></span><br><span class="line">CSL_chipReadRILC();    <span class="comment">//Reload Inner Loop SPL buffer Counter(RILC) register</span></span><br><span class="line">CSL_chipReadREP();    <span class="comment">//Restricted Entry Point Address register</span></span><br><span class="line">CSL_chipReadPCE1();    <span class="comment">//Program Counter, E1 Phase register E1字段程序计数器</span></span><br><span class="line">CSL_chipReadDNUM();    <span class="comment">//DSP Core Number register 核心数寄存器</span></span><br><span class="line">CSL_chipReadSSR();    <span class="comment">//Saturation Status Register 饱和状态寄存器</span></span><br><span class="line">CSL_chipReadGPLYA();    <span class="comment">//GMPY A-side polynomial register </span></span><br><span class="line">CSL_chipReadGPLYB();    <span class="comment">//GMPY B-side polynomial register</span></span><br><span class="line">CSL_chipReadGFPGFR();    <span class="comment">//Golios Field Multiply Control Register</span></span><br><span class="line">CSL_chipReadDIER();    <span class="comment">//Debug Interrupt Enable Register 调试中断使能寄存器</span></span><br><span class="line">CSL_chipReadTSR();    <span class="comment">//Task State Register 任务状态寄存器</span></span><br><span class="line">CSL_chipReadITSR();    <span class="comment">//Interrupt Task State Register 中断任务状态寄存器</span></span><br><span class="line">CSL_chipReadNTSR();    <span class="comment">//NMI/Exception Task State Register 异常任务状态寄存器</span></span><br><span class="line">CSL_chipReadEFR();    <span class="comment">//Exception Flag Register 异常标志寄存器</span></span><br><span class="line">CSL_chipReadIERR();    <span class="comment">//Internal Exception Report Register 内部异常报告寄存器</span></span><br></pre></td></tr></table></figure>



<p><code>&lt;csl_chipAux.h&gt;</code> 提供了24个写入寄存器相关的函数，且与读取寄存器相关函数并不呈现一一对应关系。函数定义均是将一个Uint32类型（重定义为 <code>CSL_Reg32</code> ）的新值赋值给寄存器，并将旧值返回，写入寄存器均不需要注意 前置条件，部分需要注意后置条件（Post-condition）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CSL_chipWriteAMR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteCSR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteISR(CSL_Reg32  val);    <span class="comment">//Interrupt Set Register 中断设置寄存器</span></span><br><span class="line">CSL_chipWriteICR(CSL_Reg32  val);    <span class="comment">//Interrupt Clear Register 中断清除寄存器</span></span><br><span class="line">CSL_chipWriteIER(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteISTP(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteIRP(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteNRP(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteERP(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteTSCL(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteARP(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteILC(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteRILC(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteREP(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteSSR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteGPLYA(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteGPLYB(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteGFPGFR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteDIER(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteTSR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteITSR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteNTSR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteECR(CSL_Reg32  val);    <span class="comment">//Exception Clear Register 异常清除寄存器</span></span><br><span class="line">CSL_chipWriteIERR(CSL_Reg32  val);</span><br></pre></td></tr></table></figure>



<p>共30个寄存器涉及是否可读写：</p>
<table>
<thead>
<tr>
<th>Register</th>
<th>Read</th>
<th>Write</th>
</tr>
</thead>
<tbody><tr>
<td>AMR</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>CSR</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>IFR</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>ISR</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>ICR</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>IER</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>ISTP</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>IRP</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>NRP</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>ERP</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>TSCL</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>TSCH</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>ARP</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>ILC</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>RILC</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REP</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>PCE1</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>DNUM</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>SSR</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>GPLYA</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>GPLYB</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>GFPGFR</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>DIER</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>TSR</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>ITSR</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>NTSR</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>ECR</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>EFR</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>IERR</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<h2 id="IPC-HW-Example-in-ANC"><a href="#IPC-HW-Example-in-ANC" class="headerlink" title="IPC_HW Example in ANC"></a>IPC_HW Example in ANC</h2><p><strong>硬件（中断）层核间通信</strong>（不需要修改）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ipc_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Hwi_Params params;    <span class="comment">//创建HWI对象</span></span><br><span class="line">	Error_Block eb;    <span class="comment">//创建错误块处理对象</span></span><br><span class="line"></span><br><span class="line">	Error_init(&amp;eb);    <span class="comment">//初始化错误块</span></span><br><span class="line">	Hwi_Params_init(&amp;params);    <span class="comment">//初始化HWI对象</span></span><br><span class="line">	params.eventId = <span class="number">90</span>;    <span class="comment">//IPC INT	/* Set the event ID of the associated host interrupt */</span></span><br><span class="line">	params.enableInt = TRUE;    <span class="comment">//打开中断</span></span><br><span class="line"></span><br><span class="line">	Hwi_create(<span class="number">5</span>, &amp;IpcIsr, &amp;params, &amp;eb);    <span class="comment">//INT5	/* Create Hwi thread Hwi function is CpIntc_dispatch */</span></span><br><span class="line">	Hwi_enable();    <span class="comment">//打开中断</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(CSL_chipReadDNUM() == <span class="number">0</span>)&#123;     <span class="comment">//core0	//检测运行前触发的ipc，因为运行前写入的ipc无法触发中断</span></span><br><span class="line">		<span class="keyword">if</span>(CSL_IPC_isGEMInterruptAckSet(<span class="number">0</span>,<span class="number">2</span>))&#123;    <span class="comment">//判断索引为0对应的IPCARx中的第2位是否为中断确认位</span></span><br><span class="line">			CSL_IPC_clearGEMInterruptSource(<span class="number">0</span>,<span class="number">2</span>);    <span class="comment">//是则清除</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;    <span class="comment">//core1</span></span><br><span class="line">		<span class="keyword">if</span>(CSL_IPC_isGEMInterruptAckSet(<span class="number">1</span>,<span class="number">2</span>))&#123;    <span class="comment">//判断索引为1对应的IPCARx中的第2位是否为中断确认位</span></span><br><span class="line">			CSL_IPC_clearGEMInterruptSource(<span class="number">1</span>,<span class="number">2</span>);   <span class="comment">//是则清除</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>核心同步</strong>（不需要修改）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ipc_CoreSync</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(CSL_chipReadDNUM() == <span class="number">0</span>)&#123;    <span class="comment">//core0</span></span><br><span class="line">                CSL_IPC_genGEMInterrupt(<span class="number">1</span>,<span class="number">1</span>);    <span class="comment">//IPC_IPCGR_SRCS1 = 1;</span></span><br><span class="line">                <span class="keyword">while</span>(!CSL_IPC_isGEMInterruptAckSet(<span class="number">0</span>,<span class="number">1</span>));    <span class="comment">//等待core1启动</span></span><br><span class="line">                CSL_IPC_clearGEMInterruptSource(<span class="number">0</span>,<span class="number">1</span>);    <span class="comment">//core1启动成功，清除标志</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;    <span class="comment">//core1</span></span><br><span class="line">		CSL_IPC_genGEMInterrupt(<span class="number">0</span>,<span class="number">1</span>);    <span class="comment">//IPC_IPCGR_SRCS1 = 1;</span></span><br><span class="line">		<span class="keyword">while</span>(!CSL_IPC_isGEMInterruptAckSet(<span class="number">1</span>,<span class="number">1</span>));    <span class="comment">//等待core0启动</span></span><br><span class="line">		CSL_IPC_clearGEMInterruptSource(<span class="number">1</span>,<span class="number">1</span>);    <span class="comment">//core0启动成功，清除标志</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>核间IPC信号发送</strong>（可根据需要进行修改）</p>
<p>可定义多个IPC核间通信函数，但是要区分得清各函数在何时何处被调用到，否则将会引起混乱。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ipc_Core0ToCore1</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 可自定义区域 */</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line">		ptr0[i] = adData[i];</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* 可自定义区域 */</span></span><br><span class="line">	CACHE_wbInvL1d(ptr0,<span class="number">64</span>,CACHE_WAIT);<span class="comment">//L1D line size 64bytes</span></span><br><span class="line">	CSL_IPC_genGEMInterrupt(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">////ipcgr1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ipc_Core1ToCore0</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 可自定义区域 */</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		ptr1[i] = daData[i];</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* 可自定义区域 */</span></span><br><span class="line">	CACHE_wbInvL1d(ptr1,<span class="number">64</span>,CACHE_WAIT);                 <span class="comment">//L1D line size 64bytes</span></span><br><span class="line">	CSL_IPC_genGEMInterrupt(<span class="number">0</span>,<span class="number">2</span>);                               <span class="comment">//ipcgr0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>核间通信中断函数</strong>（可根据需要进行修改）</p>
<p><strong>注意：</strong>实际使用时，并不需要在某处调用 <code>IpcIsr()</code> 函数，即实际上是被硬件中断进行控制的，在 <code>HWI_Create()</code> 函数中被使用到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IpcIsr</span><span class="params">(UArg arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(CSL_chipReadDNUM() == <span class="number">0</span>) &#123;                      <span class="comment">// core0</span></span><br><span class="line">		<span class="keyword">if</span>(CSL_IPC_isGEMInterruptAckSet(<span class="number">0</span>,<span class="number">2</span>))&#123;                      <span class="comment">//ipcgr0</span></span><br><span class="line">			CSL_IPC_clearGEMInterruptSource(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">			CACHE_invL1d(ptr1,<span class="number">64</span>,CACHE_WAIT);</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">				daData[i] = ptr1[i];</span><br><span class="line">			&#125;</span><br><span class="line">			Semaphore_post(sem0_da);    <span class="comment">//执行发送程序，将数据通过SPI发送到DA：通过semaphore切换task</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;	<span class="comment">// core1</span></span><br><span class="line">		<span class="keyword">if</span>(CSL_IPC_isGEMInterruptAckSet(<span class="number">1</span>,<span class="number">2</span>))&#123;                          <span class="comment">//ipcgr1</span></span><br><span class="line">			CSL_IPC_clearGEMInterruptSource(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">			CACHE_invL1d(ptr0,<span class="number">64</span>,CACHE_WAIT);</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line">				adData[i] = ptr0[i];</span><br><span class="line">			&#125;</span><br><span class="line">			Semaphore_post(sem1_anc);    <span class="comment">//执行core1的计算步骤，计算完后应该通知core0的ipc启动结果发送程序：通过semaphore切换task</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="5-C6657特性"><a href="#5-C6657特性" class="headerlink" title="5. C6657特性"></a>5. C6657特性</h1><h2 id="L2缓存"><a href="#L2缓存" class="headerlink" title="L2缓存"></a>L2缓存</h2><p>Debug模式下，程序文件都写在L2缓存中。而C6657总共有 <code>2048KB</code> 大小的L2 缓存，其中每个核心分配到 <code>1024KB</code> ，缓存起始地址为 <code>0x00800000</code> 。</p>
<p>在仿真器中分配内存大小一致，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">    L2SRAM (RWX) : org = <span class="number">0x800000</span>, len = <span class="number">0x100000</span></span><br><span class="line">    MSMCSRAM (RWX) : org = <span class="number">0xc000000</span>, len = <span class="number">0x100000</span></span><br><span class="line">    DDR3 (RWX) : org = <span class="number">0x80000000</span>, len = <span class="number">0x20000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Written in &lt;*TMS320C6655/57 DataManual*&gt;:</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/01/15/Networking/C%20Socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/15/Networking/C%20Socket/" class="post-title-link" itemprop="url">C socket</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-15 23:58:32" itemprop="dateCreated datePublished" datetime="2021-01-15T23:58:32+08:00">2021-01-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-26 00:12:11" itemprop="dateModified" datetime="2021-04-26T00:12:11+08:00">2021-04-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Networking/" itemprop="url" rel="index"><span itemprop="name">Networking</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>在TCP/IP协议族中，网络层IP提供的是一种不可靠的服务。也就是说，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。而另一方面，TCP在不可靠的IP层上提供了一个可靠的运输层。为了提供这种可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。由此可见，运输层和网络层分别负责不同的功能。</p>
<p>在四层网络结构，由下之上分别是：<code>数据链路层</code>、<code>网络层</code>、<code>传输层</code>及<code>应用层</code>。</p>
<p>**数据链路层 **协议典型如：Ethernet、ARP、ICMP</p>
<p><strong>网络层</strong> 协议典型如：IP</p>
<p>**传输层 **协议典型如：TCP、UDP</p>
<p><strong>应用层</strong> 协议典型如：HTTP、FTP等</p>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/TCPIP-01.png" alt="TCPIP-01"></p>
<p style="text-align: center; color: #999; font-weight: 600;">图1-4 TCP/IP协议族中不同层次的协议</p>

<p>为协议ICMP和IGMP定位一直是一件很棘手的事情。在图1-4中，把它们与IP放在同一层上，那是因为事实上它们是IP的附属协议。但是在这里，又把它们放在IP层的上面，这是因为ICMP和IGMP报文都被封装在IP数据报中。</p>
<p>使用TCP/IP协议的应用程序通常采用两种应用编程接口（API）：socket和TLI（运输层接口：Transport Layer Interface）。前者有时称作“Berkeley Socket”，表明它是从 <strong>伯克利</strong> 版发展而来的。后者起初是由AT&amp;T开发的，有时称作XTI（X/Open运输层接口），以承认X/Open这个自己定义标准的国际计算机生产商所做的工作。XTI实际上是TLI的一个超集。</p>
<h2 id="TCP-Introduce"><a href="#TCP-Introduce" class="headerlink" title="TCP Introduce"></a>TCP Introduce</h2><p>TCP(Transmission Control Protocol)传输控制协议，是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。</p>
<h3 id="TCP-Structure"><a href="#TCP-Structure" class="headerlink" title="TCP Structure"></a>TCP Structure<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/20210218-03.png" alt="20210218-03"></h3><p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/20210218-02.png" alt="20210218-02"></p>
<table>
<thead>
<tr>
<th align="left">Definitions</th>
<th align="left">Length</th>
<th>Explain</th>
</tr>
</thead>
<tbody><tr>
<td align="left">源端口 Source Port</td>
<td align="left">16bits（2bytes）</td>
<td></td>
</tr>
<tr>
<td align="left">目的端口 Destination Port</td>
<td align="left">16bits（2bytes）</td>
<td></td>
</tr>
<tr>
<td align="left"><strong>序号 Sequence Number</strong></td>
<td align="left">32bits（4bytes）</td>
<td>指定了当前数据分片中分配给 <mark>第一字节数据</mark> 的序列号。<em><strong>在TCP传输流中每一个字节为一个序号</strong></em>。如果TCP报文中flags标志位为SYN，该序列号表示 ***初始化序列号(ISN)***，此时第一个数据应该是从序列号ISN+1开始。</td>
</tr>
<tr>
<td align="left"><strong>确认号 Acknowledgement Number</strong></td>
<td align="left">32bits（4bytes）</td>
<td>表示TCP发送者期望接受下一个数据分片的序列号。该序号在TCP分片中Flags标志位为ACK时生效。序列号分片的方向和流的方向同方向，而确认序列号分片方向和流方向反方向。</td>
</tr>
<tr>
<td align="left"><em>偏移量 Data-Offset</em></td>
<td align="left">4bits</td>
<td>数据偏移也叫首部长度。<br/>因为首部长度实际也说明了数据区在分片中的起始偏移值。它表示TCP头包含了多少个32-bit的words。因为4bits在十进制中能表示的最大值为15，32bits表示4个字节，那么Data Offset的最大可表示<code>15*4=60</code>个字节（bytes）。<br />所以TCP报头长度最大为60字节。如果<code>options field</code>为0的话，报文头长度为20个字节。</td>
</tr>
<tr>
<td align="left"><em>保留域 Reserved field</em></td>
<td align="left">3bits（或6bits）</td>
<td>值全为零</td>
</tr>
<tr>
<td align="left"><strong>标志位 Flags</strong></td>
<td align="left">9bits（或6bits）</td>
<td>表示TCP包特定的连接状态，一个标签位占一个bit。</td>
</tr>
<tr>
<td align="left">窗口 Window</td>
<td align="left">16bits（2bytes）</td>
<td>表示滑动窗口的大小，用来告诉发送端接收端的buffer space的大小。接收端buffer大小用来控制发送端的发送数据数率，从而达到流量控制。最大值为65535.</td>
</tr>
<tr>
<td align="left">检验和 Checksum</td>
<td align="left">16bits（2bytes）</td>
<td>用来检查TCP头在传输中是否被修改。</td>
</tr>
<tr>
<td align="left">紧急指针 Urgent Pointer</td>
<td align="left">16bits（2bytes）</td>
<td>表示TCP片中第一个紧急数据字节的指针。只有当URG标志置1时紧急指针才有效。</td>
</tr>
<tr>
<td align="left"><em><strong>可变部分 Options Field</strong></em> 和 <em><strong>填充部分 Padding Field</strong></em></td>
<td align="left">可变长度。</td>
<td>表示TCP可选选项以及填充位。当选项不足32bits时，填充字段加入额外的0填充。</td>
</tr>
</tbody></table>
<h3 id="TCP-Flags"><a href="#TCP-Flags" class="headerlink" title="TCP Flags"></a>TCP Flags</h3><p>对于旧版本的TCP头定义，Flags有6bits，新版TCP头对flags扩展了3bits。每个TCP flag对应于1bit 。所以旧版TCP头flags值有6个，新版扩展了3个值。</p>
<p>从低位到高位分别是：</p>
<table>
<thead>
<tr>
<th>Definition</th>
<th>Declaration</th>
</tr>
</thead>
<tbody><tr>
<td><strong>FIN</strong><br/> (finished 结束)</td>
<td>表示发送者以及发送完数据。通常用在发送者发送完数据的最后一个包中。</td>
</tr>
<tr>
<td><strong>SYN</strong><br/> (synchronous 建立联机)</td>
<td></td>
</tr>
<tr>
<td><strong>RST</strong><br/>(reset 重置)</td>
<td>重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。<br />或者发送包发送到一个不是期望的目的主机时，接收端发送reset 重置连接标志的包。</td>
</tr>
<tr>
<td><strong>PSH</strong><br/> (push 传送)</td>
<td>通知接收端处理接收的报文，而不是将报文缓存到buffer中。</td>
</tr>
<tr>
<td><strong>ACK</strong><br/>(acknowledgement 确认)</td>
<td></td>
</tr>
<tr>
<td><strong>URG</strong><br/> (urgent 紧急)</td>
<td>通知接收端处理在处理其他包前优先处理接收到的紧急报文。</td>
</tr>
<tr>
<td><strong>ECE</strong><br/> (Explicit Congestion Notification Echo) 【新】</td>
<td>表示TCP peer有ECN能力。</td>
</tr>
<tr>
<td><strong>CWR</strong><br/>(Congestion Window Reduced)【新】</td>
<td>发送者在接收到一个带有ECE flag包时，将会使用CWR flag。</td>
</tr>
<tr>
<td><strong>NS</strong><br/> (Nonce Sum)【新】</td>
<td>该标签用来保护不受发送者发送的突发的恶意隐藏报文的侵害。</td>
</tr>
</tbody></table>
<p>TCP 连接的建立都是采用<code>客户-服务器(Client-Server)</code>方式：</p>
<ul>
<li>主动发起连接建立的应用进程叫做客户(client)。</li>
<li>被等待连接建立的应用进程叫做服务器(server)。</li>
</ul>
<p>传输连接就有三个阶段，即：<strong>连接建立</strong>、<strong>数据传输</strong> 和 <strong>连接释放</strong> 。</p>
<p>TCP 采用全双工模式，在连接建立后和连接释放前进行数据传输。数据传输是单向的，从发送端传输给接受端。TCP通过序列号能够保证数据被接受端接受。TCP建立连接是通过三次握手的方式来建立连接的。</p>
<h2 id="TCP-Three-Way-Handshake"><a href="#TCP-Three-Way-Handshake" class="headerlink" title="TCP Three-Way Handshake"></a>TCP Three-Way Handshake</h2><blockquote>
<p><strong>注意</strong>： 不管是大小写，<code>ack</code>  ( 或 <code>Ack</code> )和 <code>ACK</code> 都是 <strong>确认</strong> 的意思， 不同之处在于：</p>
<ul>
<li>在TCP首部中，<code>ACK</code>为确认标志位 ——占 1 字节，只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。；</li>
<li><code>Ack</code>为确认号字段（Ack Number）——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。</li>
</ul>
</blockquote>
<h3 id="The-Steps-of-Three-Way-Handshake"><a href="#The-Steps-of-Three-Way-Handshake" class="headerlink" title="The Steps of Three-Way Handshake"></a>The Steps of Three-Way Handshake</h3><p><strong>第一次握手：</strong>Client发送位码为<code>SYN＝1</code> ，随机产生 <code>seq number=1234567</code> 的数据包到服务器，Server收到 <code>SYN=1</code>，知道Client要求建立联机；</p>
<p><strong>第二次握手：</strong>Server收到请求后要确认联机信息，向Client发送<code>ack number=(Client的seq+1)</code>，<code>SYN=1</code>， <code>ACK=1</code> ，随机产生 <code>seq number=7654321</code> 的包；</p>
<p><strong>第三次握手：</strong>Client 收到后检查 <code>ack number</code> 是否正确，即第一次发送的seq number+1，以及位码 <code>ACK</code>是否为 1，若正确，Client 会再发送 <code>ack number=(主机B的seq+1)</code> ，<code>ACK=1</code>，Server 收到后确认<code>seq number</code> 值与<code>ACK=1</code>则连接建立成功。</p>
<p>完成三次握手，主机A与主机B开始传送数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">Client -&gt;&gt; Server: SYN&#x3D;1  [seq number&#x3D;1234567]</span><br><span class="line">Server --&gt;&gt; Client: SYN &#x3D; 1, ACK &#x3D; 1  [ack number &#x3D; 1234568，seq number &#x3D; 7654321]</span><br><span class="line">Client -&gt;&gt; Server: ACK &#x3D; 1 [ack number &#x3D; 7654322]</span><br></pre></td></tr></table></figure>



<p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。<br><strong>第一次握手：</strong>建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；<br><strong>第二次握手：</strong>服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br><strong>第三次握手：</strong>客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据.</p>
<h3 id="The-Meaning-of-Three-way-handshake"><a href="#The-Meaning-of-Three-way-handshake" class="headerlink" title="The Meaning of Three-way handshake"></a>The Meaning of Three-way handshake</h3><p>向客户端确认这个请求，这两个数据包（前两次握手）足以证明客户端与服务器之间的网络是畅通的，并且协商数据通信所需要的参数。比如协商接收窗口大小，所支持的数据包最大字节数等。</p>
<p>如果没有最后一个数据包确认（第三次握手），A先发出一个建立连接的请求数据包，由于网络原因绕远路了。A经过设定的超时时间后还未收到B的确认数据包，于是发出第二个建立连接的请求数据包，这次网路通畅，数据包很快到达B，B的确认数据包也很快就到达A。于是A与B开始传输数据，过了一会A第一次发出的建立连接的请求数据包到达了B，B以为是再次建立连接，所以又发出一个确认数据包。由于A已经收到了一个确认数据包，所以会忽略B发来的第二个确认数据包，但是B发出确认数据包之后就要一直等待A的回复，而A永远也不会回复。由此造成服务器资源浪费，这种情况多了B计算机可能就停止响应了。</p>
<p>第三次握手（第三个数据包）作用在于，告诉B计算机，B第二次握手发给A的确认数据包A收到了，是有效的。避免B计算机等待造成资源浪费。随后A与B可进行下一步的通信。</p>
<p>**连接建立 **过程中要解决以下三个问题：</p>
<ul>
<li>要使每一方能够确知对方的存在。</li>
<li>要允许双方协商一些参数（如 <code>最大报文段长度</code>，<code>最大窗口大小</code>，<code>服务质量</code> 等）。</li>
<li>能够对运输实体资源（如 <code>缓存大小</code>，<code>连接表中的项目</code> 等）进行分配。</li>
</ul>
<p><strong>连接建立过程中，客户端存在以下状态：</strong></p>
<p><strong>SYN-SENT：</strong>在未与目标服务器建立连接之前始终处于此状态，并将不断向目标服务器发送请求，直到 <code>收到</code> 并 <code>回复</code> 来自服务器的信息后，方进入下一个状态。<br><strong>ESTABLISHED：</strong>稳定连接状态。</p>
<p><strong>连接建立过程中，服务器存在以下状态：</strong></p>
<p><strong>LISTEN：</strong> 在未与客户端建立连接之前，始终处于此状态，在收到客户端的连接请求后答复其请求，并进入下一个状态。<br><strong>SYN-RCVD：</strong> 等待SYN信息到达后进入下一个状态。<br><strong>ESTABLISHED：</strong>稳定连接状态。</p>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/20210218-01.png" alt="20210218-01"></p>
<p><strong>连接建立文字图解：</strong></p>
<blockquote>
<p>Client 发出 <code>同步数据包（请求建立连接的数据包）</code> 并进入SYN-SENT状态。</p>
<ul>
<li>SYN = 1， 表示该为一个连接建立请求数据包；</li>
<li>ACK = 0，说明数据包确认号无效，省略；</li>
<li>Seq=x，x为所传送数据的第一个字节的序号。</li>
</ul>
<p>Server 收到Client发出的 <code>同步数据包</code> 后结束LISTEN状态，进入SYN-RCVD状态并向A发出 <code>确认同步数据包 </code>。</p>
<ul>
<li>SYN=1；</li>
<li>ACK=1；</li>
<li>seq=y，y的值由B指定表示B发送数据时的 <em><strong>第一个数据字节的序号</strong></em> ；</li>
<li>ack=x+1，表示已经收到A发送的x个字节数据，并告诉A下次应从数据的第x+1个字节开始发送。</li>
</ul>
<p>Client 收到<code>确认同步数据包 </code>之后，向B答复 <code>确认数据包</code> ，结束 SYN-SENT 状态，进入 ESTABLISHED 状态。</p>
<ul>
<li>SYN=0，表示双方已同意建立连接；</li>
<li>ACK=1，表示收到B的确认数据包；</li>
<li>seq=x+1，表示发出的数据包就是数据的第x+1个字节；</li>
<li>ack=y+1，表示收到了B发送y字节数据，并告诉B下次应从数据的第y+1个字节开始发送。</li>
</ul>
<p>Server 收到 Client 的 <code>确认数据包</code> 之后，结束SYN-RCVD状态，进入ESTABLISHED状态。</p>
</blockquote>
<h2 id="TCP-Four-Way-Wavehand"><a href="#TCP-Four-Way-Wavehand" class="headerlink" title="TCP Four-Way-Wavehand"></a>TCP Four-Way-Wavehand</h2><p>结束连接时，不管是Client或Server均可以主动发起结束信标FIN或RST。此处称主动发起结束信标的一方为主动方，另一方为被动方。</p>
<h3 id="The-Meaning-of-Four-Way-Wavehand"><a href="#The-Meaning-of-Four-Way-Wavehand" class="headerlink" title="The Meaning of Four-Way-Wavehand"></a>The Meaning of Four-Way-Wavehand</h3><p>当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。</p>
<p>但未必被动方所有的数据都完整的发送给了主动方，所以 <mark>被动方不会马上关闭SOCKET</mark>，它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。</p>
<h3 id="The-Steps-of-Four-Way-Wavehand"><a href="#The-Steps-of-Four-Way-Wavehand" class="headerlink" title="The Steps of Four-Way-Wavehand"></a>The Steps of Four-Way-Wavehand</h3><ol>
<li><p> <strong>第一次挥手：</strong>Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入 <code>FIN_WAIT_1</code> 状态。</p>
</li>
<li><p> <strong>第二次挥手：</strong>Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入``CLOSE_WAIT` 状态。</p>
</li>
<li><p> <strong>第三次挥手：</strong>Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入 <code>LAST_ACK</code> 状态。</p>
</li>
<li><p> <strong>第四次挥手：</strong>Client收到FIN后，Client进入``TIME_WAIT<code>状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入</code>CLOSED` 状态，完成四次挥手</p>
</li>
</ol>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/70.jpg" style="zoom:50%;" />





<h3 id="RST"><a href="#RST" class="headerlink" title="RST"></a>RST</h3><h4 id="Differences-between-FIN-and-RST"><a href="#Differences-between-FIN-and-RST" class="headerlink" title="Differences between FIN and RST"></a>Differences between FIN and RST</h4><blockquote>
<p><strong>关键字：</strong> 主动释放、有序释放、终止释放</p>
</blockquote>
<p><strong>释放</strong> 即发送方和接收方终止连接，解除连接状态。</p>
<p>发送方和接收方均可主动释放。最常见的是，主动释放端会发送<code>FIN</code>包，并且因为TCP是双工的， 仅关闭一个方向上的数据流，从而TCP连接处于<strong>半关闭状态</strong>，继续完成四次挥手完成连接释放。</p>
<p>上述挥手是一种 <strong>有序释放</strong> ， 即，标志位为<code>FIN</code>的TCP报文会在之前所有排队的数据发送完之后，才会发送，在socket缓冲区和窗口中的数据也能保证发送成功。</p>
<p>通常我们调用 <code>shutdown()</code> , <code>close()</code> 函数后， TCP会发送<code>FIN</code>报文。</p>
<blockquote>
<p>shutdown 和 close 的区别：</p>
<ul>
<li>shutdown是关闭一个socket， 可以关闭读、写、读写；</li>
<li>close是关闭一个linux系统的文件描述符fd。</li>
</ul>
</blockquote>
<p>除了“有序释放”， 还有一种 <strong>终止释放</strong> ，比如进程异常退出，用来关闭异常连接使用，是通过 <code>RST</code> 标志位实现的。 标志位为 <code>RST</code> 的TCP报文，会立即发送，<u>而之前所有在缓存区排队的数据都将被RST发送方丢弃。</u></p>
<p><mark>FIN报文需要应答 <code>ACK</code> , RST报文不需要应答 <code>ACK</code>。</mark></p>
<p><strong>半开连接</strong>：如果发生断点，或网络条件很差，其中一端发送 <code>RST</code> 后会立马关闭连接；而另一端可能感知不到，仍然认为连接正常，造成一种半开连接的状态。</p>
<h4 id="Why-do-we-send-RST"><a href="#Why-do-we-send-RST" class="headerlink" title="Why do we send RST?"></a>Why do we send RST?</h4><p>RST标志位被发送，通常是因为一下几种原因：</p>
<blockquote>
<ol>
<li>A向B发起连接，但B之上并没有应用监听相应的端口，这时B操作系统上的TCP处理程序会发RST包。</li>
<li>请求超时，即由于主动连接端连接请求超时，主动发起RST关闭连接。</li>
<li>在一个已关闭的socket上收到数据</li>
<li>字节流接收不完全</li>
</ol>
</blockquote>
<p><strong>情况二：</strong><br>有89、27两台主机。主机89向主机27发送了一个SYN，表示希望连接8888端口，主机27回应了主机89一个SYN表示可以连接。但是主机89却很不友好，莫名其妙的发送了一个RST表示我不想连接你了。<br>后来经过排查发现，在主机89上的程序在建立了socket之后，用setsockopt的SO_RCVTIMEO选项设置了recv的超时时间为100ms。而我们看上面的抓包结果表示，从主机89发出SYN到接收SYN的时间多达110ms。（从15:01:27.799961到15:01:27.961886， 小数点之后的单位是微秒）。因此主机89上的程序认为接收超时，所以发送了RST拒绝进一步发送数据。</p>
<p><strong>情况三：</strong><br>比如，AB正常建立连接了，正在通讯时，A向B发送了FIN包要求关连接，B发送ACK后，网断了，A通过若干原因排查后放弃了这个连接（例如进程重启）。网通了后，B又开始发数据包，A收到后表示压力很大，不知道这野连接哪来的，就发了个RST包强制把连接关了，B收到后会出现connect reset by peer错误。</p>
<h1 id="Wireshark-Tutorial"><a href="#Wireshark-Tutorial" class="headerlink" title="Wireshark Tutorial"></a>Wireshark Tutorial</h1><p>Wireshark是一款可以监听和捕捉网络通信数据的软件，对捕获的数据自下而上进行解码和分析至已知协议。如(Ethernet II – IP – TCP 或 Ethernet II – IP – TCP – HTTP)。</p>
<p>Wireshark主要通过 <strong>捕获过滤</strong> 和 <strong>显示过滤</strong> 对所有数据进行 <strong>捕获时过滤</strong> 或 <strong>捕获后显示过滤</strong>。</p>
<h2 id="Capturing-Filters-捕获过滤"><a href="#Capturing-Filters-捕获过滤" class="headerlink" title="Capturing Filters 捕获过滤"></a>Capturing Filters 捕获过滤</h2><h3 id="Filtering-packets-while-capturing-捕获时可用的过滤组件"><a href="#Filtering-packets-while-capturing-捕获时可用的过滤组件" class="headerlink" title="Filtering packets while capturing 捕获时可用的过滤组件"></a>Filtering packets while capturing 捕获时可用的过滤组件</h3><p>Capture Filters are used to filter out uninteresting packets already at capture time. This is done to reduce the size of the resulting capture (file) and is especially useful on high traffic networks or for long term capturing.  </p>
<p>Wireshark uses the pcap (libpcap/WinPcap) filter language for capture filters. This language is explained in the tcpdump man page under “expression” (<a target="_blank" rel="noopener" href="http://www.tcpdump.org/">http://www.tcpdump.org</a> and search for “selects which”).</p>
<p>Note: This capture filter language is different from the one used for the Wireshark display filters!</p>
<p>捕获过滤器的使用方式为：菜单栏上的 <code>捕获</code> –&gt; <code>选项</code> –&gt; <code>所选择接口的捕获过滤器</code> 中输入对应的过滤条件。</p>
<hr>
<h4 id="Some-common-examples-一些通用示例"><a href="#Some-common-examples-一些通用示例" class="headerlink" title="Some common examples 一些通用示例"></a>Some common examples 一些通用示例</h4><p><strong>Example Ethernet:</strong> capture all traffic to and from the Ethernet address 08:00:08:15:ca:fe</p>
<p>ether <code>host 08:00:08:15:ca:fe</code></p>
<p><strong>Example IP:</strong> capture all traffic to and from the IP address 192.168.0.10</p>
<p><code>host 192.168.0.10</code></p>
<p><strong>Example TCP:</strong> capture all traffic to and from the TCP port 80 (http) of all machines</p>
<p><code>tcp port 80</code></p>
<p><strong>Examples combined:</strong> capture all traffic to and from 192.168.0.10 except http</p>
<p><code>host 192.168.0.10 and not tcp port 80</code></p>
<p>Beware: if you capture TCP/IP traffic with the primitives “host” or “port”, you will not see the ARP traffic belonging to it!</p>
<hr>
<h4 id="Capture-Filter-Syntax-捕获过滤器标志"><a href="#Capture-Filter-Syntax-捕获过滤器标志" class="headerlink" title="Capture Filter Syntax 捕获过滤器标志"></a>Capture Filter Syntax 捕获过滤器标志</h4><p>The following is a short description of the capture filter language syntax. For a further reference, have a look at: <a target="_blank" rel="noopener" href="http://www.tcpdump.org/tcpdump_man.html">http://www.tcpdump.org/tcpdump_man.html</a></p>
<p>A capture filter takes the form of a series of <strong>primitive expressions</strong>, connected by conjunctions (and/or) and optionally preceded by not:</p>
<p><strong>[not] primitive [and|or [not] primitive …]</strong></p>
<p>A primitive is simply one of the following:</p>
<p><strong>[src|dst] host <host></strong></p>
<p>This primitive allows you to filter on a host IP address or name. You can optionally precede the primitive with the keyword <code>src|dst</code> to specify that you are only interested in source or destination addresses. If these are not present, packets where the specified address appears as either the source or the destination address will be selected.</p>
<p><strong>ether [src|dst] host <ehost></strong></p>
<p>This primitive allows you to filter on Ethernet host addresses. You can optionally include the keyword <code>src|dst</code> between the keywords ether and host to specify that you are only interested in source or destination addresses. If these are not present, packets where the specified address appears in either the source or destination address will be selected.</p>
<p><strong>gateway host <host></strong></p>
<p>This primitive allows you to filter on packets that used host as a gateway. That is, where the Ethernet source or destination was host but neither the source nor destination IP address was host.</p>
<p><strong>[src|dst] net <net> [{mask <mask>}|{len <len>}]</strong></p>
<p>This primitive allows you to filter on network numbers. You can optionally precede this primitive with the keyword <code>src|dst</code> to specify that you are only interested in a source or destination network. If neither of these are present, packets will be selected that have the specified network in either the source or destination address. In addition, you can specify either the netmask or the <strong>CIDR</strong> <em>(Classless Inter-Domain Routing)</em> prefix for the network if they are different from your own.</p>
<p><strong>[tcp|udp] [src|dst] port <port></strong></p>
<p>This primitive allows you to filter on TCP and UDP port numbers. You can optionally precede this primitive with the keywords src|dst and tcp|udp which allow you to specify that you are only interested in source or destination ports and TCP or UDP packets respectively. The keywords tcp|udp must appear before src|dst.<br>If these are not specified, packets will be selected for both the TCP and UDP protocols and when the specified address appears in either the source or destination port field.</p>
<p><strong>less|greater <length></strong></p>
<p>This primitive allows you to filter on packets whose length was less than or equal to the specified length, or greater than or equal to the specified length, respectively.</p>
<p><strong>ip|ether proto <protocol></strong></p>
<p>This primitive allows you to filter on the specified protocol at either the Ethernet layer or the IP layer.</p>
<p>ether|ip broadcast|multicast</p>
<p>This primitive allows you to filter on either Ethernet or IP broadcasts or multicasts.</p>
<p><strong><expr> relop <expr></strong></p>
<p>This primitive allows you to create complex filter expressions that select bytes or ranges of bytes in packets. Please see the tcpdump man pages for more details.</p>
<h2 id="Capturing-捕获"><a href="#Capturing-捕获" class="headerlink" title="Capturing 捕获"></a>Capturing 捕获</h2><p>This section will explain the capturing options and give hints on what to do in some special cases.</p>
<h3 id="Capture-options-捕获设置"><a href="#Capture-options-捕获设置" class="headerlink" title="Capture options 捕获设置"></a>Capture options 捕获设置</h3><p>The capture options can be logically divided into the following categories:</p>
<p>-input<br>-filtering<br>-stop conditions<br>-storing<br>-display while capturing</p>
<h3 id="Input-options-输入设置"><a href="#Input-options-输入设置" class="headerlink" title="Input options 输入设置"></a>Input options 输入设置</h3><p><strong>-Interface</strong>: You have to choose which interface (network card) will be used to capture packets from. Be sure to select the correct one, as it’s a common mistake to select the wrong interface.</p>
<p><strong>-Link-layer header type</strong>: unless you are in the rare case that you will need this, just keep the default.</p>
<h3 id="Filtering-options-过滤设置"><a href="#Filtering-options-过滤设置" class="headerlink" title="Filtering options 过滤设置"></a>Filtering options 过滤设置</h3><p><strong>-Capture packets in promiscuous mode</strong>: Usually a network card will only capture the traffic to its own network address. If you want to capture all traffic that the network card can “see”, mark this option. See the FAQ for some more details of capturing packets from a switched network.</p>
<p><strong>-Limit each packet to xy bytes</strong>: Will limit the maximum size to be captured of each packet, this includes the link-layer header and all subsequent headers. This can be useful when an error is known to be in the first 20 bytes of a packet, for example, as the size of the resulting capture file will be reduced.</p>
<p><strong>-Capture Filter</strong>: Use a capture filter to reduce the amount of packets to be captured. See “Capture Filters” in this help for further information how to use it.</p>
<h3 id="Storing-options-存储设置"><a href="#Storing-options-存储设置" class="headerlink" title="Storing options 存储设置"></a>Storing options 存储设置</h3><p><strong>-File</strong>: You can choose the file to which captured data will be written. If you don’t enter something here a temporary file will be used.</p>
<p><strong>-Use multiple files</strong>: Instead of using a single capture file, multiple files will be created. The generated filenames will contain an incrementing number and the start time of the capture. For example, if you choose “/foo.cap” in the “File” field, files like “/foo_00001_20040205110102.cap”, “/foo_00002_20040205110102.cap”, … will be created.<br>This feature can be useful if you do long term capturing, as working with a single capture file of several GB usually isn’t very fast.</p>
<h3 id="Stop-condition-options-终止设置"><a href="#Stop-condition-options-终止设置" class="headerlink" title="Stop condition options 终止设置"></a>Stop condition options 终止设置</h3><p>These three fields should be obvious; the capture process will be automatically stopped if one of the selected conditions is exceeded.</p>
<h3 id="Display-while-capturing-options"><a href="#Display-while-capturing-options" class="headerlink" title="Display while capturing options"></a>Display while capturing options</h3><p>-Update list of packets in real time: Using this will show the captured packets immediately on the main screen.<br>Please note: this will slow down capturing, so increased packet drops might appear.</p>
<p>-Automatic scrolling in live capture: This will scroll the “Packet List” automatically to the latest captured packet, when the “Update List of packets in real time” option is used.</p>
<p>-Name resolution: perform the corresponding name resolution while capturing.</p>
<h3 id="High-performance-capturing-高性能模式捕获"><a href="#High-performance-capturing-高性能模式捕获" class="headerlink" title="High performance capturing 高性能模式捕获"></a>High performance capturing 高性能模式捕获</h3><p>When your network traffic is high, you might need to take some steps to ensure Wireshark doesn’t get behind on its capture, particularly if you’re running it on a slow computer.</p>
<p>When Wireshark cannot keep up, packets are dropped. To help avoid this as much as possible:</p>
<p>a) Don’t use the “Update list of packets in real time” option (see above). This has a significant performance penalty.</p>
<p>b) Close other programs that might slow down your system, such as virus scanner software, server processes, etc.</p>
<p>c) It might be a good idea not to use a capture filter. This will depend on the task you have to do.<br>As a rule of thumb: if you want to see most of the packets and only filter a small number out, don’t use a capture filter (you can use a display filter later). If you only want to capture a small proportion of the packets, it might be better to set a capture filter, as this will reduce the number of packets that have to be saved.</p>
<p>d) If you still get packet drops, it might be an idea to use a tool dedicated to packet capturing and only use Wireshark for displaying and analyzing the packets.</p>
<p>Have a look at tshark, the command line variant of wireshark, which is included in this package.<br>XXX: add a list of possibly useful standalone capture programs.</p>
<h3 id="Long-term-capturing-长期捕获"><a href="#Long-term-capturing-长期捕获" class="headerlink" title="Long term capturing 长期捕获"></a>Long term capturing 长期捕获</h3><p>By “Long term capturing”, it’s meant to capture data from a network for several hours or even days. Long term capturing will usually result in huge capture files, being hundreds of MB’s or even several GB’s in size!</p>
<p>Before doing a long term capture, get familiar with the options to use for it, as you might not get what you desire. Doing a long term capture not getting the results needed, is usually wasting a lot of time. ;-)</p>
<p>Rules of thumb for this task:<br>-Use the ring buffer feature when you expect very large capture files.<br>-Don’t use the “Update list of packets in real time” option.<br>-Set an appropriate capture filter, when you are only interested in some special packets from the net.</p>
<h2 id="Display-Filter-显示过滤器"><a href="#Display-Filter-显示过滤器" class="headerlink" title="Display Filter 显示过滤器"></a>Display Filter 显示过滤器</h2><h3 id="Filtering-packets-while-viewing-观察时的过滤器组件"><a href="#Filtering-packets-while-viewing-观察时的过滤器组件" class="headerlink" title="Filtering packets while viewing 观察时的过滤器组件"></a>Filtering packets while viewing 观察时的过滤器组件</h3><p>After capturing packets or loading some network traffic from a file, Wireshark will display the packet data immediately on the screen.</p>
<p>Using display filters, you can choose which packets should (not) be shown on the screen. This is useful to reduce the “noise” usually on the network, showing only the packets you want to. So you can concentrate on the things you are really interested in. </p>
<p>The display filter will not affect the data captured, it will only select which packets of the captured data are displayed on the screen.</p>
<p>Every time you change the filter string, all packets will be reread from the capture file (or from memory), and processed by the display filter “machine”. Packet by packet, this “machine” is asked, if this particular packet should be shown or not.</p>
<p>Wireshark offers a very powerful display filter language for this. It can be used for a wide range of purposes, from simply: “show only packets from a specific IP address”, or on the other hand, to very complex filters like: “find all packets where a special application specific flag is set”.</p>
<p>Note: This display filter language is different from the one used for the Wireshark capture filters!</p>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><h4 id="constains-和-matches"><a href="#constains-和-matches" class="headerlink" title="constains 和 matches"></a>constains 和 matches</h4><p><strong>contains</strong> 用来判断是否包含一个值，<strong>matches</strong> 用来判断是否匹配一个表达式</p>
<hr>
<h3 id="Some-common-examples-一些通用示例-1"><a href="#Some-common-examples-一些通用示例-1" class="headerlink" title="Some common examples 一些通用示例"></a>Some common examples 一些通用示例</h3><p><strong>Example Ethernet</strong>: display all traffic to and from the Ethernet address 08.00.08.15.ca.fe</p>
<p><code>eth.addr==08.00.08.15.ca.fe</code></p>
<p><strong>Example IP</strong>: display all traffic to and from the IP address 192.168.0.10</p>
<p><code>ip.addr==192.168.0.10</code></p>
<p><strong>Example TCP</strong>: display all traffic to and from the TCP port 80 (http) of all machines</p>
<p><code>tcp.port==80</code></p>
<p><strong>Examples combined</strong>: display all traffic to and from 192.168.0.10 except http</p>
<p><code>ip.addr==192.168.0.10 &amp;&amp; tcp.port!=80</code></p>
<p>Beware: The filter string builds a logical expression, which must be true to show the packet. The &amp;&amp; is a “logical and”, “A &amp;&amp; B” means: A must be true AND B must be true to show the packet (it doesn’t mean: A will be shown AND B will be shown). </p>
<hr>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>Filtering can lead to side effects, which are sometimes not obvious at first sight. Example: If you capture TCP/IP traffic with the primitive “ip”, you will not see the ARP traffic belonging to it, as this is a lower protocol layer than IP!</p>
<h2 id="WIRESHARK中的各种标志（TCP）"><a href="#WIRESHARK中的各种标志（TCP）" class="headerlink" title="WIRESHARK中的各种标志（TCP）"></a>WIRESHARK中的各种标志（TCP）</h2><h3 id="OUT-OF-ORDER"><a href="#OUT-OF-ORDER" class="headerlink" title="OUT OF ORDER"></a>OUT OF ORDER</h3><p><code>TCP Out-of-Order</code> </p>
<p><strong>正常情况：</strong>在TCP传输过程中，同一台主机发出的数据段应该是连续的，即后一个包的 <code>Seq</code> 号等于前一    个包的 <code>Seq</code> + <code>Len</code> （三次握手和四次挥手是例外）。</p>
<p>异常情况：当Wireshark发现后一个包的 <code>Seq</code> 号 <mark>小于</mark> 前一个包的 <code>Seq</code> + <code>Len</code> 时，就会认为是乱序了，因此提示 <code>TCP Out-of-Order</code> 。</p>
<h3 id="Previous-segment-not-captured"><a href="#Previous-segment-not-captured" class="headerlink" title="Previous segment not captured"></a>Previous segment not captured</h3><p><code>Previous segment not capturedd</code> ，即报文缺失，指存在未抓取的数据包</p>
<p><strong>正常情况：</strong>在TCP传输过程中，同一台主机发出的数据段应该是连续的，即后一个包的 <code>Seq</code> 号等于前一个包的 <code>Seq</code> + <code>Len</code> （三次握手和四次挥手是例外）。</p>
<p><strong>异常情况：</strong>如果Wireshark发现后一个包的 <code>Seq</code> 号大于前一个包的 <code>Seq</code> + <code>Len</code> ，就知道中间缺失了一段数据。假如缺失的那段数据在整个网络包中都找不到（即排除了乱序），就会提示<code>TCP Previous segment not captured</code> 。</p>
<blockquote>
<p><strong>TCP Previous segment lost</strong> - Occurs when a packet  arrives with a sequence number greater than the “next expected sequence  number” on that connection, indicating that one or more packets prior to the flagged packet did not arrive. This event is a good indicator of  packet loss and will likely be accompanied by “TCP Retransmission”  events.</p>
<p>– Wireshark</p>
</blockquote>
<h3 id="TCP-DUP-ACK"><a href="#TCP-DUP-ACK" class="headerlink" title="TCP DUP ACK"></a>TCP DUP ACK</h3><p><code>Tcp Dup Ack xxx#y</code> ，即重复确认。</p>
<p>当乱序或者丢包发生时，接收方会收到一些Seq号比期望值大的包。</p>
<p><u>接收方每收到一个这种包就会进行答复，<code>Ack</code> 一次期望的 <code>Seq</code> 值，以此方式来提醒发送方，于是就产生了一些重复的 <code>Ack</code> 。</u> </p>
<p>Wireshark会在这种重复的Ack上标记 <code>TCP Dup ACK</code> ，代表了数据段丢失 TCP 状态，<code>xxx</code> 代表数据丢失的位置， <code>y</code> 后代表第几次丢失报文。</p>
<h3 id="TCP-Fast-Retransmission"><a href="#TCP-Fast-Retransmission" class="headerlink" title="TCP Fast Retransmission"></a>TCP Fast Retransmission</h3><p>快速重传，当发送方收到来自接收方的3个或以上<code>TCP Dup ACK</code> ，就意识到之前发的包可能丢了，于是发送方快速重传该数据（这是RFC的规定）。</p>
<h3 id="TCP-Spurious-Retransmission"><a href="#TCP-Spurious-Retransmission" class="headerlink" title="TCP Spurious Retransmission"></a>TCP Spurious Retransmission</h3><h3 id="TCP-Retransmission"><a href="#TCP-Retransmission" class="headerlink" title="TCP Retransmission"></a>TCP Retransmission</h3><p>超时重传。</p>
<p>如果一个包真的丢了，且无后续包，则可以在接收方触发 <code>Dup Ack</code> ，就不会快速重传。</p>
<p>这种情况下发送方只好等到超时了再重传，此类重传包就会被Wireshark标上 <code>TCP Retransmission</code> 。</p>
<h3 id="TCP-ACKed-unseen-segment"><a href="#TCP-ACKed-unseen-segment" class="headerlink" title="TCP ACKed unseen segment"></a>TCP ACKed unseen segment</h3><p>抓取遗漏。</p>
<p>当Wireshark发现被Ack的那个包没被抓到，就会提示 <code>TCP ACKed unseen  segment</code>， 即此为由于抓包不到造成的报错。</p>
<p><em>这可能是最常见的Wireshark提示了，幸好它几乎是永远可以忽略的。</em></p>
<p>以图3为例，32号包的<code>Seq=6889</code>  <code>Len=1448</code> ，相加得 8337，说明服务器发出的下一个包应该是 <code>Seq=8337</code>。而我们看到的却是35号包的<code>Seq=11233</code>，这意味着 8337～11232 这段数据没有被抓到。这段数据本应该出现在34号之前，所以Wireshark提示了<code>TCP ACKed unseen segment</code>。</p>
<img src="http://tc.sinaimg.cn/maxwidth.2048/tc.service.weibo.com/community_emc_com/8ccefb660da3f07e9a83e0625c6c7f19.png" style="zoom:150%;" />



<h3 id="TCP-Zerowindow"><a href="#TCP-Zerowindow" class="headerlink" title="TCP Zerowindow"></a>TCP Zerowindow</h3><p>窗口清零。</p>
<p>TCP包中的 <code>win=</code> 代表接收窗口的大小，即表示这个包的发送方当前还有多少缓存区可以接收数据。</p>
<p>当Wireshark在一个包中发现 <code>win=0</code> 时，就会给它打上 <code>TCP  zerowindow</code> 的标志，表示缓存区已满，不能再接受数据了。下图就是服务器的缓存区已满，所以通知客户端不要再发数据了。我们甚至可以在3258～3263这几个包中看出它的窗口逐渐减少的过程，即从 <code>win=15872</code> 减小到 <code>win=1472</code> 。</p>
<img src="http://tc.sinaimg.cn/maxwidth.2048/tc.service.weibo.com/community_emc_com/1b59377ebee4107bed8557a6a4a9d35f.png" style="zoom:150%;" />



<h3 id="TCP-Window-Update"><a href="#TCP-Window-Update" class="headerlink" title="TCP Window Update"></a>TCP Window Update</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Sockets API和Internet在许多 <em><strong>竞争性协议族</strong></em>（包括 <em>IPX</em>、<em>AppleTalk</em>、<em>DECNet</em>、<em>OSI</em>、<em>SNA</em> 及 <em>TCP</em>/IP）的世界中逐渐成长起来，并且 <mark>Sockets被设计成支持所有这些协议</mark> 。</p>
<h4 id="IPv4映射"><a href="#IPv4映射" class="headerlink" title="IPv4映射"></a>IPv4映射</h4><p>IPv4映射的地址是通过在IPv4地址前添加4个字节的前缀 <code>::fff:</code> 而构成。</p>
<p>如，<code>132.3.23.7 </code> 的IPv4地址映射至IPv6即 <code>::ffff:132.3.32.7</code> 。</p>
<p>协议互操作性</p>
<h4 id="回送地址"><a href="#回送地址" class="headerlink" title="回送地址"></a>回送地址</h4><p>IPv4的回送地址是<code>127.0.0.1</code></p>
<p>IPv6的回送地址是 <code>0:0:0:0:0:0:0:1</code></p>
<h4 id="专用网络地址"><a href="#专用网络地址" class="headerlink" title="专用网络地址"></a>专用网络地址</h4><p>以 <code>10</code> 、<code>192.168</code> 、<code>172.16</code>~`172.31`开头的地址最初被指定在不属于全球Internet的专用网络中使用。</p>
<h4 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h4><p>Hostname是指 <em>计算机名称</em> ，Domain Name是指 <em>域名</em> 。</p>
<p>通常情况下，一个name都是指Hostname。</p>
<h1 id="C-Socket-in-TI"><a href="#C-Socket-in-TI" class="headerlink" title="C Socket in TI"></a>C Socket in TI</h1><h2 id="NETCTRL-H-及-SOCKET-H"><a href="#NETCTRL-H-及-SOCKET-H" class="headerlink" title="NETCTRL.H 及 SOCKET.H"></a>NETCTRL.H 及 SOCKET.H</h2><p>以下两句话是TI官方对<code>&lt;netctrl.h&gt;</code> 的描述，即简易控制网络开断的包装函数，以此类方法实现接口的目的是隐藏可以被调用的HAL/STACK功能</p>
<blockquote>
<ul>
<li>Shell functions for simplified net startup and shutdown</li>
<li>The idea behind this API is to hide the user callable HAL/STACK functions</li>
</ul>
</blockquote>
<p><code>&lt;netctrl.h&gt;</code> 是用于初始化和维护服务的。为了完成此功能，其调用了NETTOOLS库提供的配置管理器。要注意的是，此处的配置定义和结构声明是对针对NETCTRL 的，而不是针对 CONFIG。</p>
<blockquote>
<p>NETCTRL is used to initialize the stack and maintain services. To accomplish this, it makes use of the configuration manager provided in the NETTOOLS library. Note that the configuration definitions and structures defined here are specific to NETCTRL, not CONFIG.</p>
</blockquote>
<h3 id="NETCTRL-API"><a href="#NETCTRL-API" class="headerlink" title="NETCTRL API"></a>NETCTRL API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化运行环境</span></span><br><span class="line"><span class="function">_extern <span class="keyword">int</span>  <span class="title">NC_SystemOpen</span><span class="params">( <span class="keyword">int</span> Priority, <span class="keyword">int</span> OpMode )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数可选择任务等级高或任务等级低</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_PRIORITY_LOW             OS_SCHEDULER_LOWPRI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_PRIORITY_HIGH            OS_SCHEDULER_HIGHPRI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义打开模式为POLLING或中断</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPMODE_POLLING           1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPMODE_INTERRUPT         2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NC_SystemOpen()的返回结果</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPEN_SUCCESS             0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPEN_ILLEGAL_PRIORITY    -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPEN_ILLEGAL_OPMODE      -2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPEN_MEMINIT_FAILED      -3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPEN_EVENTINIT_FAILED    -4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭运行环境</span></span><br><span class="line"><span class="function">_extern <span class="keyword">void</span> <span class="title">NC_SystemClose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用提供的配置信息开启网络</span></span><br><span class="line"><span class="function">_extern <span class="keyword">int</span> <span class="title">NC_NetStart</span><span class="params">( HANDLE hCfg, <span class="keyword">void</span> (*NetStart)(),</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">void</span> (*NetStop)(), <span class="keyword">void</span> (*NetIP)(IPN,uint,uint) )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开网络</span></span><br><span class="line"><span class="function">_extern <span class="keyword">void</span> <span class="title">NC_NetStop</span><span class="params">( <span class="keyword">int</span> rc )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当Boot线程完成时被调用</span></span><br><span class="line"><span class="function">_extern <span class="keyword">void</span> <span class="title">NC_BootComplete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当IP地址被添加或移除时被调用</span></span><br><span class="line"><span class="function">_extern <span class="keyword">void</span> <span class="title">NC_IPUpdate</span><span class="params">( IPN IPAddr, uint IfIdx, uint fAdd )</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="SOCKET-API"><a href="#SOCKET-API" class="headerlink" title="SOCKET API"></a>SOCKET API</h2><h3 id="UNIVERSAL-TCP"><a href="#UNIVERSAL-TCP" class="headerlink" title="UNIVERSAL_TCP"></a>UNIVERSAL_TCP</h3><h4 id="defined-in-lt-ws2def-h-gt"><a href="#defined-in-lt-ws2def-h-gt" class="headerlink" title="defined in &lt;ws2def.h&gt;"></a>defined in <code>&lt;ws2def.h&gt;</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                 ai_flags;       <span class="comment">// AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST</span></span><br><span class="line">    <span class="keyword">int</span>                 ai_family;      <span class="comment">// PF_xxx</span></span><br><span class="line">    <span class="keyword">int</span>                 ai_socktype;    <span class="comment">// SOCK_xxx</span></span><br><span class="line">    <span class="keyword">int</span>                 ai_protocol;    <span class="comment">// 0 or IPPROTO_xxx for IPv4 and IPv6</span></span><br><span class="line">    <span class="keyword">size_t</span>              ai_addrlen;     <span class="comment">// Length of ai_addr</span></span><br><span class="line">    <span class="keyword">char</span> *              ai_canonname;   <span class="comment">// Canonical name for nodename</span></span><br><span class="line">    _Field_size_bytes_(ai_addrlen) <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *   <span class="title">ai_addr</span>;</span>        <span class="comment">// Binary address</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *   <span class="title">ai_next</span>;</span>        <span class="comment">// Next structure in linked list</span></span><br><span class="line">&#125;</span><br><span class="line">ADDRINFOA, *PADDRINFOA;</span><br></pre></td></tr></table></figure>



<h4 id="defined-in-TI-lt-socket-h-gt"><a href="#defined-in-TI-lt-socket-h-gt" class="headerlink" title="defined in TI &lt;socket.h&gt;"></a>defined in <em><strong>TI</strong></em> <code>&lt;socket.h&gt;</code></h4><h5 id="IPv4套接字地址数据结构"><a href="#IPv4套接字地址数据结构" class="headerlink" title="IPv4套接字地址数据结构"></a>IPv4套接字地址数据结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AF_INET family (IPv4) Socket address data structure.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    UINT8   sin_len;            <span class="comment">// total length</span></span><br><span class="line">    UINT8   sin_family;         <span class="comment">// address family</span></span><br><span class="line">    UINT16  sin_port;           <span class="comment">// port</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span></span><br><span class="line">    INT8    sin_zero[<span class="number">8</span>];        <span class="comment">// fixed length address value</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="内核用地址存储数据结构"><a href="#内核用地址存储数据结构" class="headerlink" title="内核用地址存储数据结构"></a>内核用地址存储数据结构</h5><p>这个套娃里还有个套娃 <code>in_addr</code> ，这个结构体供内核调用，以储存更多地址数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Structure used by kernel to store most addresses.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    UINT32  s_addr;             <span class="comment">// 32 bit long IP address, net order</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="通用套接字地址储存数据结构"><a href="#通用套接字地址储存数据结构" class="headerlink" title="通用套接字地址储存数据结构"></a>通用套接字地址储存数据结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generic Socket address storage data structure.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    UINT8    sa_len;            <span class="comment">// Length </span></span><br><span class="line">    UINT8    sa_family;         <span class="comment">// address family</span></span><br><span class="line">    <span class="keyword">char</span>     sa_data[<span class="number">14</span>];       <span class="comment">// socket data</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>      <span class="title">SA</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>      *<span class="title">PSA</span>;</span></span><br></pre></td></tr></table></figure>









<p>以下为Socket <strong>接口协议簇</strong> 、 <strong>接口类型</strong>、 <strong>接口协议</strong> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Socket address families</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_TASK         1               <span class="comment">// Intertask Communication</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_INET         2               <span class="comment">// Internet: UDP, TCP, etc.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_INET6        10              <span class="comment">// IPV6</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _INCLUDE_NIMU_CODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_RAWETH       12              <span class="comment">// Raw Ethernet Protocol</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Socket Types</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_STREAM     1               <span class="comment">// stream socket</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_DGRAM      2               <span class="comment">// datagram socket</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_RAW        3               <span class="comment">// raw-protocol interface</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_STREAMNC   4               <span class="comment">// non-copy stream socket</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _INCLUDE_NIMU_CODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_RAWETH     5               <span class="comment">// non-copy raw eth socket</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Protocols</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_IP      0               <span class="comment">// IP Placeholder</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_ICMP    1               <span class="comment">// ICMP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_IGMP    2               <span class="comment">// IGMP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_TCP     6               <span class="comment">// TCP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_UDP     17              <span class="comment">// UDP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_IPV6    41              <span class="comment">// IPV6 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_ICMPV6  58              <span class="comment">// ICMPV6 Header.</span></span></span><br></pre></td></tr></table></figure>



<p>以下Socket接口均以Ti NDK为载体，以C为实现方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Socket Oriented Functions</span></span><br><span class="line"><span class="function">SOCKET <span class="title">accept</span><span class="params">( SOCKET s, PSA pName, <span class="keyword">int</span> *plen )</span></span>;	<span class="comment">//接受一个套接字的连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">bind</span><span class="params">( SOCKET s, PSA pName, <span class="keyword">int</span> len )</span></span>;	<span class="comment">//给套接字绑定一个名字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">connect</span><span class="params">( SOCKET s, PSA pName, <span class="keyword">int</span> len )</span></span>;		<span class="comment">//在一个套接字上初始化连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">getpeername</span><span class="params">( SOCKET s, PSA pName, <span class="keyword">int</span> *plen )</span></span>;	<span class="comment">//在已连接的peer上返回名称地址</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">getsockname</span><span class="params">( SOCKET s, PSA pName, <span class="keyword">int</span> *plen )</span></span>;	<span class="comment">//返回套接字的本地名称地址</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">getsockopt</span><span class="params">( SOCKET s, <span class="keyword">int</span> level, <span class="keyword">int</span> op, <span class="keyword">void</span> *pbuf, <span class="keyword">int</span> *pbufsize )</span></span>;	<span class="comment">//获取套接字设置信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">listen</span><span class="params">( SOCKET s, <span class="keyword">int</span> maxcon )</span></span>;		<span class="comment">//监听数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">recv</span><span class="params">( SOCKET s, <span class="keyword">void</span> *pbuf, <span class="keyword">int</span> size, <span class="keyword">int</span> flags )</span></span>;		<span class="comment">//接收数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">recvfrom</span><span class="params">( SOCKET s, <span class="keyword">void</span> *pbuf, <span class="keyword">int</span> size, <span class="keyword">int</span> flags, PSA pName, <span class="keyword">int</span> *plen )</span></span>;		<span class="comment">//从指定对象处接收信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">recvnc</span><span class="params">( SOCKET s, <span class="keyword">void</span> **ppbuf, <span class="keyword">int</span> flags, HANDLE *pHandle )</span></span>;	<span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">recvncfrom</span><span class="params">( SOCKET s, <span class="keyword">void</span> **ppbuf, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                           PSA pName, <span class="keyword">int</span> *plen, HANDLE *pHandle )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">recvncfree</span><span class="params">( SOCKET Handle )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">send</span><span class="params">( SOCKET s, <span class="keyword">void</span> *pbuf, <span class="keyword">int</span> size, <span class="keyword">int</span> flags )</span></span>;		<span class="comment">//发送信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">sendto</span><span class="params">( SOCKET s, <span class="keyword">void</span> *pbuf, <span class="keyword">int</span> size, <span class="keyword">int</span> flags, PSA pName, <span class="keyword">int</span> len )</span></span>;	<span class="comment">//在未连接的套接字上往指定目的地发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">setsockopt</span><span class="params">( SOCKET s, <span class="keyword">int</span> level, <span class="keyword">int</span> op, <span class="keyword">void</span> *pbuf, <span class="keyword">int</span> bufsize )</span></span>;	<span class="comment">//设置套接字设置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">shutdown</span><span class="params">( SOCKET s, <span class="keyword">int</span> how )</span></span>;	<span class="comment">//关闭一半的套接字连接</span></span><br><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">( <span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol )</span></span>;	<span class="comment">//创建套接字</span></span><br></pre></td></tr></table></figure>



<h3 id="SOCKET-API-IN-CLIENT"><a href="#SOCKET-API-IN-CLIENT" class="headerlink" title="SOCKET API IN CLIENT"></a>SOCKET API IN CLIENT</h3><hr>
<div class="Step" style="font-size: 20px; font-weight: 700;">第一步 创建套接字</div>

<p><code>SOCKET socket( int domain, int type, int protocol );</code> </p>
<p>如果创建成功，则返回一个代表套接字的文件描述符。否则就返回一个 <code>INVALID_SOCKET </code> 值，并且可以调用 <code>fdError()</code> 来诊断错误原因。</p>
<blockquote>
<p><code>domain</code>是指链路层类型IPv4还是IPv6，分别书写为 <strong>AF_INET</strong> | <strong>AF_INET6</strong></p>
<p><code>type</code>是指传输层套接字类型，共有 <strong>报文数据</strong>、<strong>流式数据</strong>、<strong>原始数据</strong> 三种可选，分别是 <strong>SOCK_DGRAM</strong> | <strong>SOCK_STREAM</strong> | <strong>SOCK_RAW</strong></p>
<p><code>protocol</code>是指网络层协议类型，IPPROTO_TCP | IPPROTO_UDP，在套接字类型是原始数据时可以任意指定，如果是套接字类型是 <strong>SOCK_STREAM</strong>，则协议需要指定为 <strong>IPPROTO_TCP</strong></p>
</blockquote>
<div class="Step" style="font-size: 20px; font-weight: 700;">第二步 设定套接字参数</div>

<p>通常在套接字创建之后，使用Pv4套接字地址数据结构 <code>sockaddr_in</code>设定参数，以下实例是下位机做客户端时的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bzero(&amp;sin1, <span class="keyword">sizeof</span>(struct sockaddr_in));            <span class="comment">/* Set Port, IP address = IPAddrSend */</span></span><br><span class="line">sin1.sin_family = AF_INET;</span><br><span class="line">sin1.sin_len    = <span class="keyword">sizeof</span>(sin1);</span><br><span class="line">sin1.sin_addr.s_addr = inet_addr(REMOTE_IPADDR_STRING);          <span class="comment">//连接服务器的地址</span></span><br><span class="line">sin1.sin_port   = htons(TCP_CLIENT_PORT);</span><br></pre></td></tr></table></figure>



<div class="Step" style="font-size: 20px; font-weight: 700;">第三步 连接</div>

<p><code>int    connect( SOCKET s, PSA pName, int len );</code></p>
<blockquote>
<p><code>PSA</code> 是 <code>sockaddr </code> 结构体的 <em><strong>指针</strong></em> 对象类型，定义为 <code>typedef struct sockaddr      *PSA;</code></p>
<p>另，<code>SA</code> 是 <code>sockaddr </code> 结构体的对象类型。</p>
</blockquote>
<p><code>sockaddr</code> 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用套接字地址存储数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    UINT8    sa_len;            <span class="comment">//套接字长度</span></span><br><span class="line">    UINT8    sa_family;         <span class="comment">//套接字类型，AF_INET</span></span><br><span class="line">    <span class="keyword">char</span>     sa_data[<span class="number">14</span>];       <span class="comment">//套接字数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实际连接时，通常设置一定时间的任务休眠以等待网络稳定后再行连接，且连接次数自定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(count = <span class="number">0</span>; count &lt; <span class="number">30</span>; count ++)&#123;</span><br><span class="line">        res = connect(stcp, (PSA) &amp;sin1, <span class="keyword">sizeof</span>(sin1));</span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            ConsoleWarning(<span class="string">&quot;网络连接失败！\n&quot;</span>);</span><br><span class="line">            TaskSleep(SLEEPTIME);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ConsoleWarning(<span class="string">&quot;网络连接成功！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过特定配置设置，打开网络。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_extern <span class="keyword">int</span> <span class="title">NC_NetStart</span><span class="params">( HANDLE hCfg,   <span class="keyword">void</span> (*NetStart)(),   <span class="keyword">void</span> (*NetStop)(),    <span class="keyword">void</span> (*NetIP)(IPN,uint,uint) )</span></span>;</span><br></pre></td></tr></table></figure>





<h4 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h4><p>HANDLE  is a <em>void pointer*</em> defined in the <code>&lt;usertype.h&gt;</code>.</p>
<blockquote>
<p>在<code>&lt;socket.h&gt;</code>中，<strong>SOCKET</strong>类型其实是个HANDLE，而<strong>HANDLE</strong>其实是<code>void*</code>数据。</p>
<p><code>typedef HANDLE           SOCKET;          // OS Socket Type</code></p>
<p><code>typedef void *         HANDLE;    </code></p>
</blockquote>
<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><blockquote>
<p>文件描述符，即 <em><strong>File Descriptor</strong></em>，其实一个是 <code>void* </code>类型</p>
</blockquote>
<h5 id="FD集"><a href="#FD集" class="headerlink" title="FD集"></a>FD集</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Select uses bit masks of file descriptors.  These macros</span></span><br><span class="line"><span class="comment">// manipulate handle lists. FD_SETSIZE can be modified as</span></span><br><span class="line"><span class="comment">// needed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_SETSIZE      16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fd_set</span> &#123;</span></span><br><span class="line">    uint    count;</span><br><span class="line">    HANDLE  fd[FD_SETSIZE];</span><br><span class="line">&#125; fd_set;</span><br></pre></td></tr></table></figure>





<h4 id="字节顺序转换函数"><a href="#字节顺序转换函数" class="headerlink" title="字节顺序转换函数"></a>字节顺序转换函数</h4><p>在C/C++写网络程序的时候，往往会遇到字节的网络顺序和主机顺序的问题。这是就可能用到<code>htons()</code> ,  <code>ntohl()</code> ,  <code>ntohs()</code>，<code>htons()</code>这4个函数。</p>
<p>网络字节顺序与本地字节顺序之间的转换函数：</p>
<blockquote>
<p><code>htonl()</code>–”Host to Network Long”<br><code>ntohl()</code>–”Network to Host Long”<br><code>htons()</code>–”Host to Network Short”<br><code>ntohs()</code>–”Network to Host Short”</p>
</blockquote>
<p><em><strong>网络字节顺序(NBO, Network Byte Order):</strong></em> 按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。</p>
<p><em><strong>主机字节顺序(HBO, Host Byte Order):</strong></em> 不同的机器HBO不相同，与CPU设计有关，数据的顺序是由cpu决定的,而与操作系统无关。</p>
<blockquote>
<p>如 Intel x86结构下, short型数 <code>0x1234</code> 表示为<code>34 12</code>, int型数 <code>0x12345678</code> 表示为<code> 78 56 34 12</code></p>
<p>如 IBM power PC结构下, short型数<code>0x1234</code> 表示为 <code>12 34</code> , int型数 <code>0x12345678</code> 表示为 <code>12 34 56 78</code></p>
</blockquote>
<p>由于这个原因不同体系结构的机器之间无法通信,所以要转换成一种约定的数序,也就是网络字节顺序,其实就是如同power pc那样的顺序. 在PC开发中有ntohl和htonl函数可以用来进行网络字节和主机字节的转换.</p>
<h4 id="timeval结构体"><a href="#timeval结构体" class="headerlink" title="timeval结构体"></a>timeval结构体</h4><blockquote>
<p>Ti SysBios中，<code>timeval</code> 是在 <code>&lt;SOCKET.H&gt;</code> 中被定义，被 <code>fdSelect()</code> 使用的；</p>
</blockquote>
<p>结构体定义与Linux C中的一致</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    INT32 tv_sec;	<span class="comment">//Second Level</span></span><br><span class="line">    INT32 tv_usec;	<span class="comment">//Microsecond Level</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 <em><strong>Linux C</strong></em> 中，<code>timeval</code> 与 <code>timezone</code> 结构体都隶属于 <code>sys/time.h</code> 头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> tz_minuteswest;</span><br><span class="line"><span class="keyword">int</span> tz_dsttime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Linux C 中对 TIMEVAL 使用的补充资料：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct timeval*tv, struct timezone *tz)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其参数tv是保存获取时间结果的结构体，参数tz用于保存时区结果，tz 参数若不使用则传入NULL即可。</p>
<p><code>gettimeofday()</code> 使用举例-1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv_begin</span>, <span class="title">tv_end</span> ;</span></span><br><span class="line">gettimeofday(&amp;tv_begin, <span class="literal">NULL</span>);</span><br><span class="line">foo();</span><br><span class="line">gettimeofday(&amp;tv_end, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>



<p><code>gettimeofday()</code> 使用举例-2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;time %u:%u\n&quot;</span>,tv.tv_sec,tv.tv_usec);</span><br><span class="line">      sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><em>源自：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/Neddy/archive/2012/01/31/2332957.html">http://www.cnblogs.com/Neddy/archive/2012/01/31/2332957.html</a></em></p>
<h3 id="SOCKET-API-IN-SERVER"><a href="#SOCKET-API-IN-SERVER" class="headerlink" title="SOCKET API IN SERVER"></a>SOCKET API IN SERVER</h3><div class="Step" style="font-size: 20px; font-weight: 700;">第一步 创建套接字</div>

<p>同client，略</p>
<div class="Step" style="font-size: 20px; font-weight: 700;">第二步 监听套接字</div>

<p><code>int    listen( SOCKET s, int maxcon );</code>    </p>
<blockquote>
<p> <code>maxcon</code> 参数用于定义最大的阻塞数，如果阻塞值最高，则会发送一个 <code>ECONNREFUSED</code> 错误给客户端</p>
</blockquote>
<ul>
<li><p><code>listen()</code> 监听套接字上的连接请求。为了连接请求，需要先由<code>socket()</code> 函数创建套接字。</p>
</li>
<li><p><code>listen()</code> 函数用于等待设备接入并声明有限接入数的队列。</p>
</li>
<li><p>新连接接入时需要调用 <code>accept()</code> 函数。</p>
</li>
</ul>
<div class="Step" style="font-size: 20px; font-weight: 700;">第三步 从套接字接收数据</div>

<p><code>int    recv( SOCKET s, void *pbuf, int size, int flags );</code></p>
<blockquote>
<p><code>pbuf</code> 参数用于储存数据</p>
<p><code>size</code> 为欲接收数据的大小</p>
<p><code>flags</code> 为接收不到数据时的行为定义</p>
</blockquote>
<table>
<thead>
<tr>
<th>FLAGS</th>
<th>CONDITIONS</th>
</tr>
</thead>
<tbody><tr>
<td>MSG_DONTWAIT</td>
<td>Requests that the operation not block when no data is available</td>
</tr>
<tr>
<td>MSG_OOB</td>
<td>Requests receipt of out-of-band data that would not be received in the normal data stream. Some protocols place expedited data at the head of the normal data queue, and thus, this flag cannot be used with such protocols.</td>
</tr>
<tr>
<td>MSG_PEEK</td>
<td>Causes the receive operation to return data from the beginning of the receive queue without removing that data from the queue. Thus, a subsequent receive call will return the same data.</td>
</tr>
<tr>
<td>MSG_WAITALL</td>
<td>Requests that the operation block until the full request is satisfied. However, the call may still return less data than requested if an error or disconnect occurs, or the next data to be received is of a different type than that returned.</td>
</tr>
</tbody></table>
<h3 id="SOCKET-API-IN-SERVER-LINUX-C"><a href="#SOCKET-API-IN-SERVER-LINUX-C" class="headerlink" title="SOCKET API IN SERVER (LINUX C)"></a>SOCKET API IN SERVER (LINUX C)</h3><div class="Step" style="font-size: 20px; font-weight: 700;">第一步 创建套接字</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> servSock;  <span class="comment">//Socket descriptor for server</span></span><br><span class="line"><span class="keyword">if</span>( ( servSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP ) ) &lt; <span class="number">0</span> ) <span class="built_in">printf</span>(<span class="string">&quot;socket() failed.\n&quot;</span>);</span><br></pre></td></tr></table></figure>



<div class="Step" style="font-size: 20px; font-weight: 700;">第二步 套接字地址初始化</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servAddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;servAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>( servAddr ) );</span><br><span class="line">servAddr.sin_family = AF_INET;</span><br><span class="line">servAddr.sin_addr.s_addr = htonl( INADDR_ANY );</span><br><span class="line">servAddr.sin_port = htons( servPort );</span><br></pre></td></tr></table></figure>



<div class="Step" style="font-size: 20px; font-weight: 700;">第三步 绑定套接字</div>

<p><strong>注意：</strong> <strong>客户端</strong>把服务器的地址提供给 <code>connect()</code> 以供连接至服务器，而 <strong>服务器</strong> 必须将自己的地址指定给 <code>bind()</code> 进行绑定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( ( bind( servSock, (struct sockaddr*) &amp;servAddr, <span class="keyword">sizeof</span>( servAddr ) ) ) &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;bind() failed.\n&quot;</span>);</span><br></pre></td></tr></table></figure>



<div class="Step" style="font-size: 20px; font-weight: 700;">第四步 监听套接字</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> MAXPENDING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span>( ( listen( servSock, MAXPENDING ) ) &lt; <span class="number">0</span> ) <span class="built_in">printf</span>(<span class="string">&quot;listen() failed.\n&quot;</span>);</span><br></pre></td></tr></table></figure>



<div class="Step" style="font-size: 20px; font-weight: 700;">第四步 处理程序 <div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaaddr_in</span> <span class="title">cintAddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clntAddrLen = <span class="keyword">sizeof</span>( clntAddr );</span><br><span class="line">    <span class="keyword">int</span> clntSock = accept( servSock, (struct sockaddr*)&amp;clntAddr, &amp;clntAddrLen );</span><br><span class="line">    <span class="keyword">if</span>( clntSock &lt; <span class="number">0</span> ) <span class="built_in">printf</span>(<span class="string">&quot;accept() failed.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> clntName[ INET_ADDRSTRLEN ];</span><br><span class="line">    <span class="keyword">if</span>( inet_ntop( AF_INET, &amp;clntAddr.sin_addr.s_addr, clntName, <span class="keyword">sizeof</span>( clntName ) ) != <span class="literal">NULL</span> ) <span class="built_in">printf</span>(<span class="string">&quot;Handling client %s/%d.\n&quot;</span>, clntName, ntohs( clntAddr.sin_port ));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Unable to get client address.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    HandleTCPClient(clntSock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="Daemon-API"><a href="#Daemon-API" class="headerlink" title="Daemon API"></a>Daemon API</h3><p>DAEMON，即TCP/UDP Server Daemon Support。</p>
<p>A server daemon is a <strong>single network task</strong> that <strong>monitors the socket status of multiple network servers</strong>. When activity is detected, the <strong>daemon creates a task thread specifically to handle the new activity</strong>. This is more efficient than having multiple servers, <strong>each with their own listening thread</strong>.</p>
<p>要使用服务器守护，首先要创建入口(entry)，创建成功时会返回一个句柄，失败则返回NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">DaemonNew</span><span class="params">(<span class="keyword">uint32_t</span> Type, <span class="keyword">uint32_t</span> LocalAddress, <span class="keyword">uint32_t</span> LocalPort, <span class="keyword">int</span>(*pCb)(SOCKET,<span class="keyword">uint32_t</span>), </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">uint32_t</span> Priority, <span class="keyword">uint32_t</span> StackSize, <span class="keyword">uint32_t</span> Argument, <span class="keyword">uint32_t</span> MaxSpawn)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Type</code> Socket type (SOCK_STREAM, SOCK_STREAMNC, or SOCK_DGRAM)<br><code>LocalAddress</code> Local IP address (set to NULL for wildcard)<br><code>LocalPort</code> Local Port to serve (cannot be NULL)<br><code>pCb</code> Pointer to callback to handle server event (connection or activity)<br><code>Priority</code> Priority of new task to create for callback function<br><code>StackSize</code> Stack size of new task to create for callback function<br><code>Argument</code> Argument (besides socket) to pass to callback function<br><code>MaxSpawn</code> Maximum number of callback function instances (must be 1 for UDP)</p>
</blockquote>
<p>在TCP环境中，当新连接稳定时，新任务线程会被创建，套接字Session会被打开。在新的任务线程上，用户的回调函数会被调用以供新连接上的套接字和调用的指定参数使用。回调函数可以一直维护套接字和任务线程。一旦完成连接它将从回调任务中返回。该任务能够判断是否关闭套接字（或翻译成：该任务能够在需要时关闭套接字）。</p>
<p>In the case of TCP, when a new connection is established, a new task thread is created, and a socket session is opened. Then the user’s callback function is called on the new task thread, being supplied with both the socket to the new connection and the caller specified argument (as supplied to DaemonNew()). The callback function can keep the socket and task thread for as long as necessary. It returns from the callback once it is done with the connection. The function can choose to close the socket if desired. The return code informs the daemon whether the socket has been closed (0) or is still open (1).</p>
<h2 id="NETCFG-H"><a href="#NETCFG-H" class="headerlink" title="NETCFG.H"></a>NETCFG.H</h2><blockquote>
<p><code>CI</code> means <code>Configuration Item</code> , and <code>CFG</code> means <code>Configuration</code> .</p>
</blockquote>
<p>Data-type <code>UINT32</code> and <code>IPN</code> are both defined in the header file <code>&lt;usertype.h&gt;</code> .</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>   UINT32;</span><br><span class="line"><span class="keyword">typedef</span> UINT32         IPN;             <span class="comment">// IP Address in NETWORK format</span></span><br></pre></td></tr></table></figure>

<p>Structure  <code>CI_IPNET</code>  and structure  <code>CI_ROUTE</code>  are different from each other. </p>
<p>Structure  <code>CI_IPNET</code>  is as follow:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPNet Instance</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ci_ipnet</span> &#123;</span></span><br><span class="line">        uint    NetType;                <span class="comment">// 网络地址类型标志</span></span><br><span class="line">        IPN     IPAddr;                 <span class="comment">// 32bits地址((2^8)*4)</span></span><br><span class="line">        IPN     IPMask;                 <span class="comment">// 子网掩码</span></span><br><span class="line">        HANDLE  hBind;                  <span class="comment">// 绑定句柄</span></span><br><span class="line">        <span class="keyword">char</span>    Domain[CFG_DOMAIN_MAX]; <span class="comment">// 域名</span></span><br><span class="line">        &#125; CI_IPNET;</span><br></pre></td></tr></table></figure>



<p>Structure  <code>CI_ROUTE</code>  is as follow:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Route Instance</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ci_route</span> &#123;</span></span><br><span class="line">        IPN     IPDestAddr;             <span class="comment">// 目的地址</span></span><br><span class="line">        IPN     IPDestMask;             <span class="comment">// 目的地址掩码</span></span><br><span class="line">        IPN     IPGateAddr;             <span class="comment">// 默认网关地址</span></span><br><span class="line">        HANDLE  hRoute;                 <span class="comment">// Route handle (resets to NULL)</span></span><br><span class="line">        &#125; CI_ROUTE;</span><br></pre></td></tr></table></figure>





<h2 id="CONFIGIF-H"><a href="#CONFIGIF-H" class="headerlink" title="CONFIGIF.H"></a>CONFIGIF.H</h2><p>请先阅读 <em>&lt;spru524k.pdf&gt;</em></p>
<h3 id="Configuration-特性"><a href="#Configuration-特性" class="headerlink" title="Configuration 特性"></a>Configuration 特性</h3><ul>
<li>任何对（已激活）配置的作用都将立即生效。</li>
</ul>
<blockquote>
<p><em>The configuration is based on an active database. That is, any change to the database can cause an immediate reaction in the system. For example, if a route is added to the configuration, it is added to the system route table. If the route is then removed from the configuration, it is removed from the system route table.</em></p>
</blockquote>
<ul>
<li>配置存在激活与失效两种状态。</li>
</ul>
<blockquote>
<p><em>Configurations can be set active or inactive. When a configuration is active, any change to the configuration results in a change in the system. When a configuration is inactive, it behaves like a standard database. Part of the main initialization sequence is to make the system configuration active, and then inactive when shutting down.</em></p>
</blockquote>
<ul>
<li>配置(Configurations)和配置入口(Configuration Entries)都使用句柄(handle)来映射，但不同的是，配置使用CfgHandle，而配置入口使用Cfg<em>Entry</em>Handle，所以不能混淆。</li>
</ul>
<blockquote>
<p><em>Both the configurations and configuration entries are referenced by a generic handle. Configuration functions (named as <code>CfgXxx()</code>) take a configuration handle parameter, while configuration entry functions (name as <code>CfgEntryXxx()</code>) take a configuration entry handle parameter. These handles are not interchangeable.</em></p>
</blockquote>
<ul>
<li>配置条目(Entry)包含着*(contains)* 一个内部引用计数(Internal Reference Count)，即如果有任务想使用它，它就不能被其他任务销毁。配置条目被引用一次，引用计数就会加一。</li>
</ul>
<blockquote>
<p><em>Configuration entry handles are referenced. This means that each handle contains an internal reference count so that the handle is not destroyed by one task while another task expects it to stay valid. Functions that return a configuration entry handle supply a referenced handle in that its reference count has already been incremented for the caller.</em></p>
</blockquote>
<ul>
<li>理论上句柄能够被无限持有，一旦释放则将被dereference。</li>
</ul>
<blockquote>
<p><em>The caller can hold this handle indefinitely, but should dereference it when it is through.</em></p>
</blockquote>
<p><code>IF</code> 是指 Interface。<code>ifconfig</code> 是unix系统上的ip接口查看语句。而 <code>CONFIGIF</code> 是配置管理接口的意思。</p>
<p><code>DeRef</code> ，即 <em>Dereference</em> 之意。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_extern <span class="keyword">int</span>  <span class="title">CfgAddEntry</span><span class="params">( HANDLE hCfg, uint Tag, uint Item, uint Mode, <span class="keyword">int</span> Size, UINT8 *pData, HANDLE *phCfgEntry )</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>HANDLE hCfg</code></p>
<p><code>uint Tag</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Defined Configuration Tags</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_OS               0x0001          <span class="comment">// OS Configuration</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_IP               0x0002          <span class="comment">// IP Stack Configuration</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_SERVICE          0x0003          <span class="comment">// Service</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_IPNET            0x0004          <span class="comment">// IP Network</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_ROUTE            0x0005          <span class="comment">// Gateway Route</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_CLIENT           0x0006          <span class="comment">// DHCPS Client</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_SYSINFO          0x0007          <span class="comment">// System Information</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_ACCT             0x0008          <span class="comment">// User Account</span></span></span><br></pre></td></tr></table></figure>

<p><code>uint Item</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Currently Used DHCP Compatible Items</span></span><br><span class="line"><span class="comment">// Multiple instances are always to be stored as multiple config entries, not a concatenated byte string in a single config entry.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_DHCP_DOMAINNAMESERVER   6       <span class="comment">// Stack&#x27;s DNS servers</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_DHCP_HOSTNAME           12      <span class="comment">// Stack&#x27;s host name</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_DHCP_NBNS               44      <span class="comment">// Stack&#x27;s NBNS servers</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_DHCP_CLIENT_OPTION		61		<span class="comment">// Stack DHCP Client Identifier</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_SYSINFO_REALM1          256     <span class="comment">// Realm Name 1 (max 31 chars)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_SYSINFO_REALM2          257     <span class="comment">// Realm Name 2 (max 31 chars)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_SYSINFO_REALM3          258     <span class="comment">// Realm Name 3 (max 31 chars)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_SYSINFO_REALM4          259     <span class="comment">// Realm Name 4 (max 31 chars)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_SYSINFO_REALMPPP        260     <span class="comment">// Realm Name PPP (max 31 chars)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_SYSINFO_EVALCALLBACK    261    <span class="comment">// Callback function to notify</span></span></span><br><span class="line">                                               <span class="comment">// application 5 min before</span></span><br><span class="line">                                               <span class="comment">// end of stack evaluation period         </span></span><br></pre></td></tr></table></figure>

<p><code>uint Mode</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add Entry Flags</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFG_ADDMODE_UNIQUE      0x0001  <span class="comment">// Replace all previous instances</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFG_ADDMODE_DUPLICATE   0x0002  <span class="comment">// Allow duplicate data entry</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFG_ADDMODE_NOSAVE      0x0004  <span class="comment">// Don&#x27;t include this entry in CfgSave</span></span></span><br></pre></td></tr></table></figure>


</blockquote>
<h1 id="SEND-BLOCKING"><a href="#SEND-BLOCKING" class="headerlink" title="SEND() BLOCKING"></a>SEND() BLOCKING</h1><blockquote>
<p>In some cases where send() would block, it instead returns without copying all of the data as requested.</p>
<p>In this case, the return value of send() indicates how many bytes were actually copied. One example of this is if your program is blocking on send() and then receives a signal from the operating system.</p>
<p>In these cases, it is up to caller to try again with any remaining data.</p>
</blockquote>
<h1 id="套接字及流输入输出接口-IO"><a href="#套接字及流输入输出接口-IO" class="headerlink" title="套接字及流输入输出接口(IO)"></a>套接字及流输入输出接口(IO)</h1><p><strong>TOPIC</strong></p>
<blockquote>
<ul>
<li>文件描述符环境</li>
<li>文件描述符编程接口</li>
<li>套接字编程接口</li>
<li>元以太网套接字编程接口</li>
<li>全双工管道编程接口</li>
<li>因特网群组管理协议(IGMP)</li>
</ul>
</blockquote>
<p>在各嵌入式系统中，对文件描述符的支持都大相径庭。大部分情况，都只支持基本功能（bare minimum functionality）， 通常都以通用名称命名和提供被修剪过的函数(trimmed down support functions)。</p>
<p>TI NDK支持标准套接字接口函数，这些函数也要求文件描述符的支持，堆栈提供一个小型文件系统。</p>
<p>在堆栈代码内部的基本构建块是一个对象句柄。在其内部，套接字和管道都通过对象句柄寻址。然而，在应用层，套接字和管道都被当做文件描述符看待。文件描述符内涵附加状态信息（additional state information），允许根据套接字活动阻塞和解除阻塞任务。</p>
<p><strong>注意：</strong>尽管文件描述符能够在传统函数中使用，如select()， 但在这种实现方式中，他们仍然是句柄，而不是整型。</p>
<p>出于兼容性考虑，网络程序必须使用NDK头文件，然后使用INVALID_SOCKET作为错误情况判定，并且在检查SOCKET有效性时，不要直接与（&lt;0）比较。</p>
<p>使用文件描述符前，需要一个任务首先创建一个文件描述符表格（FD table / session）。只需要在应用层调用文件描述符函数 <code>fdOpenSession()</code> 来完成。</p>
<p>当任务结束使用FD接口，或被关闭时，调用 <code>fdCloseSession()</code> 。</p>
<p>为确保堆栈操作正确，每个任务在使用FD相关的函数前，都应创建FD session，在使用完毕后关闭它。</p>
<h2 id="Open-FD-Session"><a href="#Open-FD-Session" class="headerlink" title="Open FD Session"></a>Open FD Session</h2><ol>
<li><p>最简单的方式就是用 <code>TaskCreate()</code> ，他可以（自动）在内部打开和关闭FD session。</p>
</li>
<li><p>另一种方式就是在函数调用的最开头进行session创建，在函数结束的末尾进行session关闭。如下：</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">socket_task</span><span class="params">(<span class="keyword">int</span> IPAddr, <span class="keyword">int</span> TcpPort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        SOCKET s;</span><br><span class="line">        <span class="comment">// Open the file session</span></span><br><span class="line">        fdOpenSession(TaskSelf());</span><br><span class="line">       <span class="comment">// &lt; socket application code &gt;</span></span><br><span class="line">        <span class="comment">// Close the file session</span></span><br><span class="line">        fdCloseSession(TaskSelf());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>另一种方式就是创建子线程。注意的是，父线程需要保证子线程的任务被执行前打开子线程的session。可通过任务优先级或信标来完成，但会增加任务创建复杂度，并不是理想方案。</li>
<li>也可以通过让子任务调用session创建函数，并且由父线程来监控和关闭子线程门。</li>
</ol>
<p>栈库支持一些通常被认为是文件函数的功能，因此套接字应用程序可以在更传统的意义上编程。</p>
<blockquote>
<p>The stack library supports a handful of what are normally considered file functions, so that sockets applications can be programmed in a more traditional sense.</p>
</blockquote>
<p><code>fdPoll()</code> 远比 <code>fdSelect()</code> 来得更有效率。它轮询提供的套接字列表，并指定以毫秒为单位的超时(或使用<em>POLLINFTIM</em> 来设置无限超时)。拥有 <code>fdSelect()</code> 的优点，即对原始文件描述符列表（或者套接字）的检验不会被结果所改写，因此可以不用重建便多次使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fdpollitem</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *fd;  <span class="comment">//the fd or socket to check</span></span><br><span class="line">    <span class="keyword">uint16_t</span> eventsRequested;  <span class="comment">//a set of flags for requested events</span></span><br><span class="line">    <span class="keyword">uint16_t</span> eventsDetected;  <span class="comment">//a set of resulting flags for a detected event</span></span><br><span class="line">&#125; FDPOLLITEM;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/01/05/Signal/2021-01-05-%E6%A8%A1%E6%95%B0%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%8F%AF%E7%BC%96%E7%A8%8B%E5%A2%9E%E7%9B%8A%E6%94%BE%E5%A4%A7%E5%99%A8%EF%BC%88PGA%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/05/Signal/2021-01-05-%E6%A8%A1%E6%95%B0%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%8F%AF%E7%BC%96%E7%A8%8B%E5%A2%9E%E7%9B%8A%E6%94%BE%E5%A4%A7%E5%99%A8%EF%BC%88PGA%EF%BC%89/" class="post-title-link" itemprop="url">模数接口中的可编程增益放大器（PGA）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-05 23:58:32" itemprop="dateCreated datePublished" datetime="2021-01-05T23:58:32+08:00">2021-01-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-29 00:36:28" itemprop="dateModified" datetime="2021-04-29T00:36:28+08:00">2021-04-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Signal/" itemprop="url" rel="index"><span itemprop="name">Signal</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>原文出处：<a target="_blank" rel="noopener" href="https://www.21ic.com/app/analog/201207/134812.htm">https://www.21ic.com/app/analog/201207/134812.htm</a></p>
<p>用可编程增益放大器(PGA)处理数据采集系统中传感器/变送器模拟输出和信号处理数字之间的接口。单片和高集成度PGA现在被可编程、更高精度、更高吞吐量和更小封装尺寸的模块和混合方案替代。 </p>
<p>由于来自传感器/变送器的模拟信号的本性，使其工作必须具备相当大的动态范围。这要求采用连续增益级在进行任何实际的数字处理之前增大这些信号，PGA能满足这种要求。 </p>
<p>PGA是可变增益放大器(VGA)的一种。VGA提供可变和连续增益控制，而PGA <mark>必须在软件控制下以固定步(通常6dB步)做到可变增益控制</mark>。达到更精细的分辨步0.5dB是可能的。 一般多通道数据采集系统用很多不同类型的传感器/变送器，这包括 <strong>热电偶</strong>、<strong>惠斯登电桥</strong>，<strong>热敏电阻</strong>、<strong>应变计</strong> 和 <strong>超声系统</strong>。虽然，传感器/变送器是基于不同的物理原理，但大多数产品是 <strong>以电压做为输出</strong>。甚至这会产生中间值(如电容或电阻)，但最终变换为电压，以便在数据采集系统中进行</p>
<p><img src="http://pic.islet.space/2021/04/fb222bc5a544088d5a7fc0c708476621.jpg"></p>
<p>传感器/变送器的输出可覆盖非常大的范围，需要PGA来处理传感器/变送器输出到ADC的接口。</p>
<blockquote>
<p>例如，在工业过程控制系统中，低频信号可以几毫伏到几伏变化。需要PGA来匹配这种宽传感器/变送器输出范围到特定的ADC输入范围。通常，在输入数据采集通道最低信号电平与最高信号电平之比是2个量级或更大。  12位ADC接收小于ADC满标输入十分之一的信号仅可提供8位分辨率，除非在信号到达ADC之前用PGA放大。PGA允许在软件控制下使接收信号的增益达到宽范围增益一带宽乘积。这可避免钳位并允许采用较便宜的ADC，如用12位ADC替代16位ADC。 </p>
</blockquote>
<p>PGA可做更多事情。PGA缓冲来自前级(通常是多路转换器)ADC的输入，防止多路转换器导通电阻所引起的加载。PGA也提供差分别单端的变换，大多数跟踪和保持型ADC需要单输入。把PGA连接到差分多路转换器输出时，PGA提供共模抑制。 </p>
<p>在市场上可以得到很多种PGA和支持元件。这包括可独立应用的运放被专门设计成PGA、ASIC、集成有可编程滤波器的PGA、仪表放大器PGA、用于运放的数字电位器前端、PGA用数字可编程分压器、ADC驱动器。有时把PGA和DAC集成在同一芯片上。 </p>
<p>对于不需要信号宽动态范围的应用，PGA不是必须的。放大器可以直接接口传感器/变送器到ADC。</p>
<blockquote>
<p>例如，Maxim的MAX1494仪表放大器适合于250V/V或更小增益范围的应用。 </p>
</blockquote>
<h1 id="各种性能的PGA"><a href="#各种性能的PGA" class="headerlink" title="各种性能的PGA"></a>各种性能的PGA</h1><p>对于特殊性能参量(如高增益稳定性和高精度，低漂移，低失真，高输出驱动电流，高转换率，快速建立时间，高共模抑制比，低功率和小尺寸)有很多PGA是最佳的。 </p>
<blockquote>
<ul>
<li>Microchip公司的MCP6S2X家族PGA具有2、6和8通道输入，包含多路转换器并可通过串行外设接口(SPI)总线进行增益控制和通道选择。</li>
<li>NS公司的LMH6718IC是双PGA，具有高输出(200mA)驱动信号。  </li>
<li>高性能小封装的PAG有ADI公司的AD8555，这是封装在微型8引线SOIC中的数字可编程信号调理自动零放大器，它包含放大器，比较器，用Digit  Trim技术的电阻调节分压器和缓冲器。其500V/℃总输入失调漂移是其他竞争产品的1/20。</li>
<li>Linear公司的LTC6915A也是小封装高性能PGA。此仪表放大器封装为16引线SSOP或12引线DFN，可把它放置在最靠近传感器/变送器的地方。它所占电路板面积是等效分立方案的1/6。零漂移特性具有高达4096的宽可编程动态范围(增益精度0.1%)。它也有50mV/℃漂移和与增益无关的125dB CMRR。  </li>
<li>对于低失真是主要考虑因素的应用，可以选择Intersil公司PGA缓冲器HFA11XX，其低失真电平低到-73dBc、噪声电平低到7”9nV/√Hz。</li>
<li>TI公司的THS7001/7002单/双PGA采用Power PAD封装，包含分离的低噪声前置放大器和增益放大级。此器件可达到非常低的噪声电平(低到1.7nV/√Hz)。 </li>
<li>其他可注意的PGA包括ADI公司的AD628首款具有可编程增益的共模差分放大器和Linear公司的LTC1564 PGA(除放大器外，它还具有8阶软件可编程抗混淆滤波器)。 </li>
</ul>
</blockquote>
<p>PGA也集成有其他前端电路。</p>
<blockquote>
<p>如Maxim公司的MAX14XX家族，这是包含PGA的信号调理ASIC。这种器件直接用于传感器/变送器和ADC之间。</p>
<p>Maxim公司的ADC驱动器MAX2055具有低失真(-76dBc 2次谐波和-69dBc 3次谐波)特性，其差分输出是为驱动高速ADC专门设计的。 </p>
</blockquote>
<p>一些PGA供应商也提供驱动PGA前端的数字电位计和分压器IC。</p>
<blockquote>
<p>例如，Maxim公司的MAX5420/21数字可编程电压分压器；</p>
<p>ADI公司的AD5321数字电位计(常用于可编程增益和衰减的非易失性存储器)。  </p>
<p>另外，Xicor也提供不少PGA器件，这些PGA器件对于执行数字控制的电位计(DCP)是最佳的。  </p>
</blockquote>
<h1 id="集成方案"><a href="#集成方案" class="headerlink" title="集成方案"></a>集成方案</h1><p>现在，很多公司把PGA和其他信号调理电路直接集成在ADC芯片上。这种方法有利于所占空间更小，比分离PGA和ADC方案具有更好的性能。然而，其成本比较高，集成PGA在ADC上除灵活性较低外，还有 <mark>较高的时钟噪声电平</mark>。 </p>
<blockquote>
<p>带线化前端的Maxim公司的MAX1457(图2)传统器线性化IC就是其中一种，它包含12位ADC。</p>
<p>ADI公司的ADC7707高精度信号调理16位S-D  ADC包含多路转换器、缓冲器、PGA、电荷平衡电路、串行接口和时钟产生器。</p>
<p>ADI公司的ADC7708/18S-D6位/24位ADC具有与AD7707相同的电路，但它们的目标是低电压和低功率应用。 </p>
</blockquote>
<p><img src="http://pic.islet.space/2021/04/8b55f596bcfdf9a408bd3c959504fb21.jpg" alt="img"></p>
<p>一个感兴趣的高集成度ADC是ADC7731  24位S-D器件，它具有ADC77017的所有电路。另外，还加上定标微控制器(图3)。此IC的目标是低噪声高吞吐量应用。</p>
<p>Maxim公司也有带集成PGA的双6位ADC，它具有90Sample/s吞吐率、功耗仅550mW。 </p>
<p><img src="http://pic.islet.space/2021/04/8CzZ7BjS2OMEYQJ.jpg"></p>
<p>我们将会看到更多包含PGA和其他信号处理电路的ADC吗？</p>
<p>不可回避的事实是高集成度是IC业的准则，而PGA和其他信号调理支持电路也不例外。所以希望看到PGA与ADC集成在同一芯片，并能解决片上性能参量(如时钟引起的噪声)和降低高分辨率器件的单个ADC价格。</p>
<p>事实上，设计人员主要的目标是把传感器/变送器电路放在高集成度ADC上。</p>
<p>这将是最终解决问题：现实世界模拟信号与计算机的数字世界结合起来的途经。</p>
<p>这也将聚焦在模拟和数字电路设计的两种不同方法。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/01/05/Linux/C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/05/Linux/C++/" class="post-title-link" itemprop="url">C++</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-05 23:58:32" itemprop="dateCreated datePublished" datetime="2021-01-05T23:58:32+08:00">2021-01-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-26 00:12:40" itemprop="dateModified" datetime="2021-04-26T00:12:40+08:00">2021-04-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="C-语法及基础"><a href="#C-语法及基础" class="headerlink" title="C++语法及基础"></a>C++语法及基础</h1><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>杂项运算符</li>
</ul>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p>
<table>
<thead>
<tr>
<th>p</th>
<th>q</th>
<th>p &amp; q</th>
<th>p | q</th>
<th>p ^ q</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：</p>
<blockquote>
<p>A = 0011 1100</p>
<p>B = 0000 1101</p>
</blockquote>
<p>-—————-</p>
<blockquote>
<p>A&amp;B = 0000 1100</p>
<p>A|B = 0011 1101</p>
<p>A^B = 0011 0001</p>
<p>~A = 1100 0011</p>
</blockquote>
<p>下表显示了 C 语言支持的位运算符。假设变量 <strong>A</strong> 的值为 60，变量 <strong>B</strong> 的值为 13，则：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与操作，按二进制位进行”与”运算。运算规则： <code>0&amp;0=0;    0&amp;1=0;     1&amp;0=0;      1&amp;1=1;</code></td>
<td>(A &amp; B) 将得到 12，即为 0000 1100</td>
</tr>
<tr>
<td>|</td>
<td>按位或运算符，按二进制位进行”或”运算。运算规则： `0</td>
<td>0=0;    0</td>
</tr>
<tr>
<td>^</td>
<td>异或运算符，按二进制位进行”异或”运算。运算规则： <code>0^0=0;    0^1=1;    1^0=1;   1^1=0;</code></td>
<td>(A ^ B) 将得到 49，即为 0011 0001</td>
</tr>
<tr>
<td>~</td>
<td>取反运算符，按二进制位进行”取反”运算。运算规则： <code>~1=-2;    ~0=1;</code></td>
<td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</td>
<td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</td>
<td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td>
</tr>
</tbody></table>
<h2 id="Mangling"><a href="#Mangling" class="headerlink" title="Mangling"></a>Mangling</h2><p><strong>重载</strong>，包括 <strong>函数重载</strong> 和 <strong>操作符重载</strong> 。</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><blockquote>
<p><strong>函数重载</strong> 也叫 <strong>方法重载</strong>。是编译器通过把原方法名称与其参数相结合产生一个独特的内部名字来取代原方法名称的技术。</p>
<p>基本上，支持函数重载的语言都需要进行Name Mangling。Mangling的目的就是为了给重载的函数不同的签名，以避免调用时的二义性调用。</p>
</blockquote>
<p><strong>Name Mangling</strong> 不是一个非常新的技术，在C语言中也有，<em><strong>在汇编C语言时经常看到的以 下划线“_”开头的函数名，其实就是C编译器将函数名进行了 Name Mangling</strong></em> 。</p>
<p>但是在C++中Name-mangling要复杂的多。 因为C++中支持 <em><strong>overload</strong></em> 和 <em><strong>override</strong></em> ，这就导致了C++编译器必须要有完成的Name-mangling把函数名或者变量名进行调整。 </p>
<p>在面向对象编程语言出现之前，如果你想要打印不同类型的数据,需要写多个方法 ,象是 <code>PrintInteger(int i)</code> ，<code>PrintString(string s)</code>  和 <code>PrintFloat(float f)</code> 。也就是说必须<strong>通过命名来区别行为和数据类型</strong>，因为 OOP语言出现前，任一语言都（像是C）不允许使用相同的名字命名函数， 即使参数类型不同。</p>
<p>但在C++中，像是 Print(int i)、Print(string s) 和 Print(float  f)，编译器自会准确调用特定的Print方法。当调用 <code>Print(1)</code> 的时候, 编译器可能在内部用源于参数类型的前缀重命名Print方法，这样一来 <code>Print(1)</code> 可能就变成  <code>i_Print (1)</code> 。</p>
<p> 下面是更详细的例子：</p>
<p> C++编译器实际上将下面这些重载函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">float</span> f)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>* s)</span></span>;</span><br></pre></td></tr></table></figure>

<p>编译为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_print_int</span><br><span class="line">_print_char</span><br><span class="line">_print_float</span><br><span class="line">_pirnt_string</span><br></pre></td></tr></table></figure>

<p> 这样的函数名，来唯一标识每个函数。</p>
<p><strong>注：</strong>不同的编译器实现可能不一样，但是都是利用这种机制。所以当连接是调用 <code>print(3)</code> 时，它会去查找 <code>_print_int(3)</code> 这样的函数。下面说个题外话，正是因为这点，重载被认为不是多态，多态是运行时动态绑定（“一种接口多种实现”），<strong>如果硬要认为重载是多态，它顶多是编译时“多态”。</strong></p>
<p>C++中的变量，编译也类似，如全局变量可能编译g_xx，类变量编译为c_xx等。连接是也是按照这种机制去查找相应的变量。</p>
<blockquote>
<p><code>方法重载</code> 仅是多态性的一种情形。 </p>
<p><code>名称重整</code> 是一种支持方法重载的机制。更普遍的情况下，多态性是与继承相联系。 </p>
</blockquote>
<h2 id="Inherit"><a href="#Inherit" class="headerlink" title="Inherit"></a>Inherit</h2><blockquote>
<p>继承就是一个新类 (称为子类) 从被继承类（称为父类或超类）取得自身的部分定义同时增加一些自己的新的信息。</p>
</blockquote>
<p>如果你在相同的类中重载方法, 数据类型必须是不同的。如果你在继承关系下重载方法, 子类与父类的方法可能完全相同，而且名称重整器生成同样的重整名称。</p>
<p> 举例来说，假设一个超类定义一个 <code>Print(int i)</code> 方法而一个从它继承的子类也定义了一个 <code>Print(int i)</code> 方法。当你有一个子类的实例时，运用多态性调用 <code>Child.Print(int)</code> ；而当你产生一个父类的实例时运用多态性调用 <code>Parent.Print(int)</code> 。这就是继承多态性：相同的名字和签字但是类却不同。</p>
<p><code>继承多态性</code> 是通过使用一种与名称重整相关的另外一种机制实现的。编译器把方法放置在一个被称为虚拟方法表（其实是一个方法数组）的地方。每一个方法在VMT中都有一个索引, 如此当 <code>Print(int)</code> 被调用的时候, 编译器将被路由到VMT处找寻Print方法和类的内在索引。这样一来，编译器就可以调用正确的方法实现。由编译器负责管理所有的VMT索引和类偏移量。</p>
<p> 简言之，多态性使你能够用非常相似的名字定义许多方法，这里的名字往往都是直观易记的。 OOP编译器自会根据调用者类理解到底该调用哪个方法。</p>
<p>Only one version of an overloaded function can appear within the  extern C block. The code in the following example would result in an error.</p>
<p>While you can use name overloading in your SYS/BIOS C++ applications, only one version of the overloaded function can be called from the configuration.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> “C” &#123; <span class="comment">// Example causes ERROR</span></span><br><span class="line">	<span class="function">Int <span class="title">addNums</span><span class="params">(Int x, Int y)</span></span>;</span><br><span class="line">	<span class="function">Int <span class="title">addNums</span><span class="params">(Int x, Int y, Int z)</span></span>; <span class="comment">// error, only one version of addNums is allowed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Inline-Function"><a href="#Inline-Function" class="headerlink" title="Inline Function"></a>Inline Function</h2><p>**内联方法 **即内联函数，成员函数，inline functions，是指定义在类体内的函数。</p>
<p>该函数可以在类体内被声明和定义，也可以在类体内声明同时在体外使用 <code>inline</code> 关键字进行定义，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">angle</span>&#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">double</span> value;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">SetValue</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">angle::SetValue</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;                <span class="comment">//定义内联函数</span></span><br><span class="line">	value = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>内联函数无法递归。</p>
<h2 id="Constructor-and-Destructor"><a href="#Constructor-and-Destructor" class="headerlink" title="Constructor and Destructor"></a>Constructor and Destructor</h2><p><strong>构造函数(Constructor Function)</strong> 在调用时会为对象开辟储存空间、作初始化 及 其他管理操作。</p>
<ul>
<li>如果为编写，则系统默认生成</li>
<li>可以接受参数不能有返回值</li>
<li>可以有多个构造函数，因此可以接受名称重载（Name Mangling）。</li>
</ul>
<p><strong>析构函数(Destructor Function)</strong> 仅在释放对象的内存空间时使用，如 <em><strong>程序超出类对象的作用域</strong></em> 或 <em><strong>类指针运行delete运算符</strong></em>  时。</p>
<h2 id="Friend-Function"><a href="#Friend-Function" class="headerlink" title="Friend Function"></a>Friend Function</h2><p><strong>友元函数</strong> 是指 <code>在类内部声明</code>，可以 <code>自由访问该类的私有部分</code> 并且 <code>不属于类成员</code> 的 <strong>函数</strong>或<strong>类</strong>。</p>
<p>在友元函数声明时定义一个该类的对象，可以通过引用该对象作为参数进行对类的访问。</p>
<p>为了确保数据完整性并遵循数据封装和隐藏的原则，因尽量少用或不用友元。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Student;</span><br><span class="line">class Teacher&#123;</span><br><span class="line">	public:</span><br><span class="line">		&#x2F;&#x2F;....</span><br><span class="line">&#125;</span><br><span class="line">	protected:</span><br><span class="line">		int NoOfStudent;</span><br><span class="line">		Student * pList[100];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Student&#123;</span><br><span class="line">	public:</span><br><span class="line">		friend class Teacher;             &#x2F;&#x2F;友元类声明</span><br><span class="line">		&#x2F;&#x2F;....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Preprocessing"><a href="#Preprocessing" class="headerlink" title="Preprocessing"></a>Preprocessing</h2><p><strong>定义</strong></p>
<p>预处理是指将源文件的文本作为翻译的第一阶段操作的文本处理步骤。 预处理不会分析源文本，但会为了查找宏调用而将源文本细分为标记。 主要包括了下面三个方面：</p>
<ul>
<li>预处理指令</li>
<li>预处理运算符</li>
<li>预定义宏，这个有很多了，比如__FILE__、__LINE__和__DATA__等。</li>
</ul>
<p><strong>常识</strong></p>
<ul>
<li>预处理并不是编译，也不是“预编译”</li>
<li>预处理并不是每个语言都有</li>
<li>C/C++预处理仅仅是把源程序划分和整理成一个个的段（phase），并不进行编译。</li>
<li>预处理器在UNIX传统中通常缩写为PP，在自动构建脚本中C预处理器被缩写为CPP的宏指代。为了不造成歧义，C++(c-plus-plus) 经常并不是缩写为CPP，而改成CXX</li>
</ul>
<p><strong>Preprocessing Directives 预处理指令</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>#include</td>
<td>#import</td>
<td>#using</td>
<td>#progma</td>
</tr>
<tr>
<td>#if</td>
<td>#ifdef</td>
<td>#ifndef</td>
<td>#elif</td>
</tr>
<tr>
<td>#lese</td>
<td>#endif</td>
<td>#define</td>
<td>#undef</td>
</tr>
<tr>
<td>#error</td>
<td>#line</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="预处理运算符号"><a href="#预处理运算符号" class="headerlink" title="预处理运算符号"></a>预处理运算符号</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>字符串化运算符（#）</td>
<td>导致对应的实参括在双引号内</td>
</tr>
<tr>
<td>Charizing运算符（#@）</td>
<td></td>
</tr>
<tr>
<td>标记粘贴运算符（##）</td>
<td></td>
</tr>
<tr>
<td>定义的运算符</td>
<td></td>
</tr>
</tbody></table>
<h4 id="and"><a href="#and" class="headerlink" title="# and"></a># and</h4><h5 id="字符串化运算符"><a href="#字符串化运算符" class="headerlink" title="字符串化运算符"></a>字符串化运算符</h5><p><code>#</code> 除了是 <em><strong>预处理符号</strong></em>，也是一种 <strong>运算符</strong> ，即 <strong>字符串化运算符</strong>，只能出现在带参的宏的替换文本中，<strong>将跟在后面的参数转换成一个字符串常量</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_INT(i) printf(#i<span class="meta-string">&quot;=%d\n&quot;</span>,i)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">100</span>;</span><br><span class="line">    PF_INT(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预处理后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span><span class="string">&quot;=%d\n&quot;</span>,x);</span><br></pre></td></tr></table></figure>

<p>C语言常将相邻的字符串合并处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d\n&quot;</span>,x);</span><br></pre></td></tr></table></figure>



<h5 id="标记粘贴运算符"><a href="#标记粘贴运算符" class="headerlink" title="标记粘贴运算符"></a>标记粘贴运算符</h5><p><code>##</code> 是一种 <strong>运算符</strong> ，即 <strong>标记粘贴运算符</strong>，是将两个 <strong>运算对象</strong> 连接（拼接）在一起，只能出现在带参宏定义的替换文本中。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM(h,t,u)  h##t##u</span></span><br></pre></td></tr></table></figure>

<p>假设u代表个位，t代表十位，h代表百位，则x=NUM(1,2,3)后,x=123。</p>
<p><strong>注：</strong><code>##</code>也可以用于拼接一些开头一样，尾巴不一样的宏，这样的宏一般用于描述代表特定意义的对象的不同状态等。宏开头固定，根据不同条件则选择拼接不同尾巴，最后拼接的字符串代表一个具体的状态等。</p>
<h2 id="Differences-between-C-amp-C"><a href="#Differences-between-C-amp-C" class="headerlink" title="Differences between C &amp; C++"></a>Differences between C &amp; C++</h2><ul>
<li>从语法要求来说，C++的语法要求更为严格，编译器对参数变量的检查要求更高，更容易报错；很多在C中可以被顺利编译的语句，在C++中会被严厉拒绝，例如，在C++中，当形参为unsigned char，而实参为const char时会报错。</li>
<li>C是面向过程语言，代码复用复杂。C++是面向对象语言。</li>
</ul>
<h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h1><h2 id="PORT"><a href="#PORT" class="headerlink" title="PORT"></a>PORT</h2><blockquote>
<p>0~1023被分配给任何TCP/IP实现所提供的服务</p>
<p>1024~5000被分配给临时端口</p>
<p>5000以上被分配给不常用的服务器</p>
</blockquote>
<ul>
<li>网络编程时要为程序指定一个1024以上的端口。</li>
</ul>
<h1 id="WINDOW-SOCKET"><a href="#WINDOW-SOCKET" class="headerlink" title="WINDOW SOCKET"></a>WINDOW SOCKET</h1><p>Windows Sockets可以保证应用程序在任何支持Windows Sockets API 的网络内正常通信。</p>
<p>流式Socket：基于TCP，数据无差错且无重复发送；</p>
<p>数据报Socket：基于UDP，不能保证数据按发送顺序接收，可能丢失或重复。</p>
<p>真正与客户端Socket对象通信都不是服务器 Socket对象，而是新创建的“临时”Socket对象</p>
<blockquote>
<p>构造函数：CAsyncSocket();</p>
<p>Create();【成功返回非0，失败返回0】            //SOCK_DGRAM 数据报</p>
<p>GetSockName();                //用于获取Socket对象的本地名称（自己的信息），ip地址及端口号，或</p>
<p>GetPeerName();                //用于获取连接的Socket对象名称（对方的信息）</p>
<p>Listen();                              //面向流式使用，参数范围1~5，表示等待连接队列的最大长度</p>
<p>Accept();                            //用以接收等待队列中存在的连接请求</p>
<p>Connect();                         //建立连接请求函数</p>
<p>Send();                              //</p>
</blockquote>
<p>除字符型与布尔型外，其余整型用于表示（可能）不同尺寸的整数。</p>
<p>C++规定一个int（最小16bit）至少和一个short（16bit）一样大，一个long（最小32bit）至少和一个int一样大，一个long long（64bit）至少和一个long一样大。</p>
<p>其中，long long 是在C++ 11中新定义的。</p>
<p>尽管字符型char有三种（char、signed char、unsigned char），但是字符的表现形式只有2种，signed或unsigned。类型char实际上会表现为其中一种，具体由编译器决定。</p>
<p>字面值常量</p>
<blockquote>
<p>20           //十进制</p>
<p>020        //0开头的为8进制</p>
<p>0x20      //0x开头的为16进制</p>
</blockquote>
<h1 id="Q-A"><a href="#Q-A" class="headerlink" title="Q/A"></a>Q/A</h1><h4 id="1-C-常见的内存错误及解决方法"><a href="#1-C-常见的内存错误及解决方法" class="headerlink" title="1. C++常见的内存错误及解决方法"></a>1. C++常见的内存错误及解决方法</h4><p><strong>（1）内存分配未成功，却使用了它。</strong></p>
<blockquote>
<p>在使用内存之前先检查指针是否是NULL。如果是用malloc来申请内存，应该用if(p == NULL)或if（p != NULL）进行防错处理。如果是new来申请内存，申请失败会抛出异常，所以应该捕捉异常来进行防错处理。</p>
</blockquote>
<p><strong>（2）内存虽然分配成功，但尚未初始化就引用它。</strong></p>
<blockquote>
<p>尽管有时候缺省时会自动初始化，但无论什么时候创建对象均要对其进行初始化，即使是赋0值也是不可忽略的。</p>
</blockquote>
<p><strong>（3）内存分配成功，但访问越界</strong></p>
<blockquote>
<p>对数组for循环时要把握越界，否则可能会导致数组越界。</p>
</blockquote>
<p><strong>（4）忘记释放内存，导致内存泄漏</strong></p>
<blockquote>
<p>动态内存的申请和释放必须配对，new-delete和malloc-free其使用次数必须相等。</p>
</blockquote>
<p><strong>（5）已经释放内存还在使用它</strong></p>
<blockquote>
<p>free或delete后 ，没有将指针设为NULL，产生“野指针”。</p>
</blockquote>
<h4 id="2-C-中struct与class的区别是什么？"><a href="#2-C-中struct与class的区别是什么？" class="headerlink" title="2. C++中struct与class的区别是什么？"></a>2. C++中struct与class的区别是什么？</h4><p>如果没有多态和虚拟继承，在C++中，struct和class的存取效率完全相同，存取class的数据成员与非虚函数效率和struct完全相同，不管该数据成员是定义在基类还是派生类。</p>
<p>class的数据成员在内存中的布局不一定是数据成员的声明顺序，C++只保证处于同一个access section的数据成员按照声明顺序排列。</p>
<p>C++中，class和struct做类型定义是只有两点区别：</p>
<ul>
<li>默认继承权限不同，<strong>class继承默认是private继承，而struct默认是public继承</strong>。</li>
<li>class还可用于定义模板参数，像typename，但是关键字struct不能同于定义模板参数。</li>
</ul>
<p>C++保留struct关键字，原因：</p>
<ul>
<li>保证与C语言的向下兼容性，C++必须提供一个struct。</li>
<li>C++中的struct定义必须百分百地保证与C语言中的struct的向下兼容性，把C++中的最基本的对象单元规定为class而不是struct，就是为了避免各种兼容性要求的限制。</li>
<li>对struct定义的扩展使C语言的代码能够更容易的被移植到C++中。</li>
</ul>
<h4 id="3-如何将结构体传递给函数？"><a href="#3-如何将结构体传递给函数？" class="headerlink" title="3. 如何将结构体传递给函数？"></a>3. 如何将结构体传递给函数？</h4><p>与类对象一样，结构体变量也可以通过值、引用和常量引用传递给函数。</p>
<p>默认情况下，它们通过值传递，这意味着需要生成整个原始结构的副本并传递给函数。</p>
<p>因为不希望浪费时间来复制整个结构体，所以，除非结构很小，否则一般会通过 <strong>引用</strong> 将结构体传递给函数。但是，这样意味着函数可以访问原始结构的成员变量，从而可能更改它们。</p>
<p>如果不想让函数更改任何成员变量值，那么可以考虑将结构体变量作为一个 <strong>常量引用</strong> 传递给函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Invltem</span>                       // <span class="title">Holds</span> <span class="title">data</span> <span class="title">for</span> <span class="title">an</span> <span class="title">inventory</span> <span class="title">item</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> partNum;                     <span class="comment">// Part number</span></span><br><span class="line">    <span class="built_in">string</span> description;              <span class="comment">// Item description</span></span><br><span class="line">    <span class="keyword">int</span> onHand;                      <span class="comment">// Units on hand</span></span><br><span class="line">    <span class="keyword">double</span> price;                    <span class="comment">// Unit price</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Function prototypes</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getltemData</span><span class="params">(InvItem &amp;)</span> </span>;        <span class="comment">//普通引用，函数可能会对结构体数据造成影响</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showItem</span><span class="params">(<span class="keyword">const</span> InvItem &amp;)</span></span>;      <span class="comment">//常量引用，不会让函数对结构体造成数据变化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InvItem part;                    <span class="comment">// Define an Invltem structure variable.</span></span><br><span class="line">    getItemData(part);</span><br><span class="line">    showItem(part);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getItemData</span><span class="params">(InvItem &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the part number: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; item.partNum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the part description: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">    getline (<span class="built_in">cin</span>, item.description);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the quantity on hand: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; item.onHand;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the unit price: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; item.price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showItem</span><span class="params">(<span class="keyword">const</span> InvItem &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Part Number : &quot;</span> &lt;&lt; item.partNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Description : &quot;</span> &lt;&lt; item.description &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Units On Hand : &quot;</span> &lt;&lt; item.onHand &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Price : $&quot;</span> &lt;&lt; item.price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Enter the part number: 800</span><br><span class="line">Enter the part description: Screwdriver</span><br><span class="line">Enter the quantity on hand: 135</span><br><span class="line">Enter the unit price: 1.25</span><br><span class="line"></span><br><span class="line">Part Number : 800</span><br><span class="line">Description : Screwdriver</span><br><span class="line">Units On Hand: 135</span><br><span class="line">Price : $1.25</span><br></pre></td></tr></table></figure>



<h4 id="4-如何从函数返回一个结构体？"><a href="#4-如何从函数返回一个结构体？" class="headerlink" title="4. 如何从函数返回一个结构体？"></a>4. 如何从函数返回一个结构体？</h4><p> 也可以从函数返回结构体变量。在这种情况下，函数的返回类型是结构体的名称。可以改写程序 1 以允许 getItemData 函数创建 Invltem 结构体的局部实例，将数据值放入其成员变量中，然后将其传递回 main，而不是将其作为引用变量从 main 接收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InvItem <span class="title">getItemData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InvItem item;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the part number:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; item.partNum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the part description: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">    getline(<span class="built_in">cin</span>, item.description);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the quantity on hand: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; item.onHand;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the unit price: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; item.price;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是从 main 中调用它的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">part = getItemData();</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> <em>C++ 只允许从函数返回单个值。然而，结构体提供了解决这一限制的方法。即使一个结构体可能有几个成员，它在技术上还是一个单一的对象。通过在结构体中打包多个值，可以从函数返回任意数量的值。</em></p>
<h4 id="5-gt-符号区分？"><a href="#5-gt-符号区分？" class="headerlink" title="5. . | -&gt; | :: | :符号区分？"></a>5. . | -&gt; | :: | :符号区分？</h4><ol>
<li><p>A.B则A为对象或者结构体；</p>
</li>
<li><p>A-&gt;B则A为指针，-&gt;是成员提取，A-&gt;B是提取A中的成员B，A只能是指向类、结构、联合的指针；</p>
</li>
<li><p>:: 是作用域运算符，A::B表示作用域A中的名称B，A可以是名字空间、类、结构；</p>
</li>
<li><p>: 一般用来表示继承；</p>
</li>
</ol>
<h4 id="6-计算机上正在运行的句柄、线程、进程分别是什么意思？"><a href="#6-计算机上正在运行的句柄、线程、进程分别是什么意思？" class="headerlink" title="6. 计算机上正在运行的句柄、线程、进程分别是什么意思？"></a>6. 计算机上正在运行的句柄、线程、进程分别是什么意思？</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bluestorm/p/5712238.html">https://www.cnblogs.com/bluestorm/p/5712238.html</a></p>
<blockquote>
<p>所谓 <code>句柄</code> 实际上是一个数据，是一个Long (整长型)的数据。</p>
<p>句柄是WONDOWS用来标识被应用程序所建立或使用的对象的唯一整数，WINDOWS使用各种各样的句柄标识诸如应用程序实例，窗口，控制，位图，GDI对象等等。WINDOWS句柄有点像C语言中的文件句柄。 </p>
</blockquote>
<p>从上面的定义中的我们可以看到，句柄是一个 <code>标识符</code>，是拿来标识对象或者项目的，它就像我们的姓名一样，每个人都会有一个，不同的人的姓名不一样，但是，也可能有一个名字和你一样的人。从数据类型上来看它只是一个 <strong>16位的无符号整数</strong> 。<em><strong>应用程序几乎总是通过调用一个WINDOWS函数来获得一个句柄，之后其他的WINDOWS函数就可以使用该句柄，以引用相应的对象。</strong></em></p>
<p>句柄是一种 <code>指向指针的指针</code>。所谓指针是一种内存地址。应用程序启动后，组成这个程序的各对象是驻留在内存的。如果简单地理解，似乎只要获知这个内存的首地址，那么就可以随时用这个地址访问对象。但是非也，<strong>Windows是一个以虚拟内存为基础的操作系统</strong>。在这种系统环境下，Windows内存管理器经常在内存中来回移动对象，依此来满足各种应用程序的内存需要。对象被移动意味着它的地址变化了。如果地址总是如此变化，该到哪里去找该对象呢?</p>
<p>为了解决这个问题，Windows操作系统为各应用程序腾出一些 <code>内存储地址</code>，用来专门登记各应用对象在内存中的地址变化，而这个<strong>地址(存储单元的位置)本身是不变的</strong>。<strong>Windows内存管理器在移动对象在内存中的位置后，把对象新的地址告知这个句柄地址来保存。这样我们只需记住这个句柄地址就可以间接地知道对象具体在内存中的哪个位置。</strong>这个地址是在对象装载(Load)时由系统分配给的，当系统卸载时(Unload)又释放给系统。</p>
<p>句柄地址(稳定)→记载着对象在内存中的地址→对象在内存中的地址(不稳定)→实际对象</p>
<p><strong>本质：</strong>WINDOWS程序中并不是用物理地址来标识一个内存块，文件，任务或动态装入模块的，相反的，WINDOWS API给这些项目分配确定的句柄，并将句柄返回给应用程序，然后通过句柄来进行操作。 </p>
<p>但是必须注意的是程序每次从新启动，系统不能保证分配给这个程序的句柄还是原来的那个句柄，而且绝大多数情况的确不一样的。假如我们把进入电影院看电影看成是一个应用程序的启动运行，那么系统给应用程序分配的句柄总是不一样，这和每次电影院售给我们的门票总是不同的一个座位是一样的道理。</p>
<p><code>线程</code> 是指程序的一个指令执行序列，WIN32 平台支持多线程程序，允许程序中存在多个线程。 在单 CPU 系统中，系统把 CPU 的时间片按照调度算法分配给各个线程，因此各线程实际上是分时执行的，在多 CPU 的 Windows NT 系统中， 同一个程序的不同线程可以被分配到不同的 CPU 上去执行。<em>由于一个程序的各线程是在相同的地址空间运行的，因此设及到了如何共享内存， 如何通信等问题，这样便需要处理各线程之间的同步问题，这是多线程编程中的一个难点。</em></p>
<blockquote>
<p>线程,也被称为轻量进程（lightweight processes）。计算机科学术语，指运行中的程序的调度单位。</p>
<p>线程是进程中的实体，一个进程可以拥有多个线程，一个线程必须有一个父进程。线程不拥有系统资源，只有运行必须的一些数据结构；它与父进程的其它线程共享该进程所拥有的全部资源。线程可以创建和撤消线程，从而实现程序的并发执行。一般，线程具有 <code>就绪</code> 、 <code>阻塞</code> 和 <code>运行</code> 三种基本状态。</p>
</blockquote>
<p>在多中央处理器的系统里，不同线程可以同时在不同的中央处理器上运行，甚至当它们属于同一个进程时也是如此。<em><strong>大多数支持多处理器的操作系统都提供编程接口来让进程可以控制自己的线程与各处理器之间的关联度（affinity）。</strong></em></p>
<p><code>进程</code> 是程序在一个数据集合上运行的过程(注:一个程序有可能同时属于多个进程),它是操作系统进行资源分配和调度的一个独立单位,进程可以简单的分为 <code>系统进程</code> (包括一般Windows程序和服务进程)和 <code>用户进程</code> 。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2020/12/25/Others/Phrases/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/25/Others/Phrases/" class="post-title-link" itemprop="url">Phrases</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-25 23:58:32" itemprop="dateCreated datePublished" datetime="2020-12-25T23:58:32+08:00">2020-12-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-26 00:15:30" itemprop="dateModified" datetime="2021-04-26T00:15:30+08:00">2021-04-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/English/" itemprop="url" rel="index"><span itemprop="name">English</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>comment out sth. 注释掉</p>
<blockquote>
<p> Therefore, commenting out a continued line comments out the entire command.</p>
<p>因此，注释掉一个连续的行就会注释掉整个命令.</p>
</blockquote>
<blockquote>
<p>That is, no white space is implied, nor is a comment terminated. </p>
<p>也就是说，没有空格，注释也不会终止。</p>
</blockquote>
<p>several-input-lines command 多行输入命令</p>
<blockquote>
<p>Commands may extend over several input lines by ending each line but the last with a backslash ().</p>
<p>命令可以扩展到多个输入行，每一行以反斜杠()结束，最后一行以反斜杠()结束。</p>
</blockquote>
<p>curly braces 花括号</p>
<p>denote optional arguments 表示可选参数</p>
<p>mutually exclusive choices 互相排斥的选择</p>
<blockquote>
<p>In this document, curly braces ({}) denote optional arguments and a vertical bar (|) separates mutually exclusive choices.</p>
<p>在本文档中，花括号({})表示可选参数，竖线(|)分隔互斥的选项。</p>
</blockquote>
<p> mutual <span style="color: #CCC; font-style: italic;">/‘mju: tfuel/</span> exclusion 互斥</p>
<blockquote>
<p>Manages gates for mutual exclusion of shared resources by multiple processors and threads. 管理多个处理器和线程共享资源的互斥门。</p>
</blockquote>
<p>care should be taken when 当/在……时需要小心</p>
<blockquote>
<p><em>Care should be taken</em> when choosing a Task stack size. </p>
<p>在选择任务堆栈大小时要小心。</p>
</blockquote>
<p>recursive nature 递归性质</p>
<p>a significant amount of 大量的</p>
<blockquote>
<p>Due to its recursive nature, a Task tends to consume a significant amount of stack. </p>
<p>由于其递归性质，任务往往会消耗大量的堆栈。</p>
</blockquote>
<p>the proper adjustment 适当调整</p>
<blockquote>
<p>The scheduler thread can run at any priority with the proper adjustment.</p>
<p>调度器线程经适当调整可以运行在任何优先级。</p>
</blockquote>
<p><em>sb./sth.</em> places certain restrictions on <em>sth. / sw.</em> 某物对某物产生影响</p>
<blockquote>
<p>Running the scheduler thread at a low priority places certain restrictions on how a Task can operate at the socket layer.</p>
<p>以低优先级运行调度程序线程会对任务在套接字层上的操作方式产生某些限制。</p>
</blockquote>
<p>re-entrance exclusion methodology 重连拒绝方法</p>
<blockquote>
<p>The NDK requires a re-entrance exclusion methodology to call into internal  tack functions.</p>
</blockquote>
<p>interactive plot windows 互动式绘制窗口</p>
<blockquote>
<p><em>-p</em> tells the program not to close any remaining interactive plot windows when the program exits.</p>
</blockquote>
<p>bad font metrics 糟糕的字体度量</p>
<blockquote>
<p><em>-s</em> tells the program to wait for slow font initialization on startup. Otherwise it prints an error and continues with bad font metrics.</p>
</blockquote>
<p>batch session 批处理会话</p>
<blockquote>
<p>To launch a batch session using two command files “input1” and “input2”.</p>
</blockquote>
<p>use <em>sth.</em> from <em>sb.</em>/<em>sth.</em></p>
<blockquote>
<p>In earlier versions of gnuplot, some terminal types used the values from ‘set size’ to control also the size of the output canvas.</p>
<p>在gnuplot的早期版本中，一些终端类型使用set size中的值来控制输出画布的大小。</p>
</blockquote>
<p>minimum addressable units 最小可寻址单元</p>
<blockquote>
<p>Memory allocation sizes are measured in “Minimum Addressable Units” (MAUs) of memory. An MAU is the smallest unit of data storage that can be read or written by the CPU.</p>
</blockquote>
<p>memory policy 存储策略</p>
<p>on a *** basis 在*** 的基础上</p>
<blockquote>
<p>You can reduce the amount of code space used by an application by setting the memory Policy on a global or per-module basis.</p>
</blockquote>
<p>be significantly constrained 非常有限 / 显著不足的</p>
<blockquote>
<p>This is particularly useful on targets where the code memory is significantly constrained.</p>
</blockquote>
<p>A make calls to B  A调用B</p>
<blockquote>
<p>it makes calls to the Heap module through the <code>IHeap_Handle</code>.</p>
</blockquote>
<p>a particular heap implementation 特定堆生成</p>
<blockquote>
<p>Using Memory APIs makes applications and middleware portable and not tied to a particular heap implementation.</p>
</blockquote>
<p><em>A</em> calls into <em>B</em>  A调用B</p>
<blockquote>
<p> Internally, the Memory module calls into the heap’s interface functions.</p>
</blockquote>
<p>memory management traits 内存管理特征</p>
<blockquote>
<p>Different heap implementations optimize for different memory management traits.</p>
</blockquote>
<p><em>sth</em>. become scattered throughout <em>somewhere</em> 某物被分散到某处</p>
<blockquote>
<p> As memory blocks are “freed” back to the <code>HeapMem</code>, the available memory in the <code>HeapMem</code> becomes scattered throughout the heap. </p>
</blockquote>
<p>presume / assume 假定</p>
<blockquote>
<p>So this book <em>presumes</em> that you have already learned something about Python programming from the many excellent tutorials and books on the subject.</p>
<p>On the other hand, this book does not start by <em>assuming</em> that you know any networking! </p>
</blockquote>
<p>sophisticated services </p>
<blockquote>
<p>The idea of a <em>protocol stack</em>, in which very simple network services are used as a foundation on which to build more sophisticated services. </p>
</blockquote>
<p>ship(<em>v.</em>) with  与某物一起（类似于打包在一起）</p>
<blockquote>
<p>The fact that you will often be using Python libraries of prepared code—whether from the built-in standard library that ships with Python.</p>
</blockquote>
<p>other than …. 除了……</p>
<blockquote>
<p>Blue boxes identify modules for which your application will call C API functions <em>other than</em> those used to dynamically create objects.</p>
</blockquote>
<p>be used in a variety of combinations 被用于多种组合</p>
<blockquote>
<p>IPC modules can be used in variety of combinations.</p>
</blockquote>
<p>previous versions 以前的版本</p>
<blockquote>
<p>Note that the appropriate include file location has changed from previous versions of IPC. 注意，适当的头文件位置已经从以前的IPC版本中更改。</p>
</blockquote>
<p>function call sequence 函数调用顺序</p>
<blockquote>
<p>Standard IPC Function Call Sequence</p>
</blockquote>
<p>the corresponding modules</p>
<blockquote>
<p> For example, <code>Ipc_S_SUCCESS</code>, <code>MessageQ_E_FAIL</code>, and <code>SharedRegion_E_MEMORY</code> are status codes that may be returned by functions in the corresponding modules.</p>
</blockquote>
<p>the remote processor</p>
<blockquote>
<p>The response from the remote processor triggers a hardware interrupt, which then posts a Semaphore to allow to Task to resume execution.  远程处理器的响应触发硬件中断，然后硬件中断发布一个信号量以允许任务继续执行。</p>
</blockquote>
<p>register optimizations 寄存器优化</p>
<p>local optimizations 本地优化</p>
<p>global optimizations 全局优化</p>
<p>interprocedure optimization 进程优化</p>
<p>runtime support library 运行时支持库</p>
<blockquote>
<p>This module provides <code>xdc.runtime.ITimestampClient</code> APIs for the xdc Runtime Support Library.</p>
</blockquote>
<p>Exploring the Ecosystem 探索生态系统</p>
<p>maximum outstanding connection request 最大未完成连接请求</p>
<p>zero out 清零</p>
<blockquote>
<p>Zero out structure object. 清空结构体对象</p>
</blockquote>
<p>memory region 内存区域</p>
<blockquote>
<p>This function enables caching for a specific memory region. </p>
</blockquote>
<p>software convertion 软件公约、软件惯例</p>
<blockquote>
<p>Allocation of source bits to source processor and meaning is entirely based on software convention.源位分配到源处理器和意义完全基于软件惯例。</p>
</blockquote>
<p>facility n. 设备，设施</p>
<p>facilitate v. 促进，帮助，使容易</p>
<blockquote>
<p>These registers also provide a <em>Source ID facility</em> by which up to 28 different sources of interrupts can be identified. 这些寄存器还提供了一个 <em>源 ID设备</em> ，通过它可以识别多达28个不同的中断源。</p>
<p>The IPCGRH register facilitates interrupts to external hosts. IPCGRH寄存器促进中断到外部主机。</p>
</blockquote>
<p>be aligned on B    对齐至B</p>
<p>A be a multiple of B    A应该是B的数倍</p>
<blockquote>
<p>To prevent unintended behavior “blockPtr” should be aligned on the cache line size and “byteCnt” should be a multiple of the cache line size.</p>
</blockquote>
<p>adaptive layout 自适应布局</p>
<p>give you more control over <em>sth</em>. 在某事上予以更多控制权</p>
<p>a handful of <em>sth</em>. 一些某物（可数）</p>
<blockquote>
<p>An adaptive layout will give you more control over the design because you only have a handful of states to consider. </p>
</blockquote>
<p>derived <span style="color: #CCC; font-style: italic;">/dɪˈraɪvd/</span> class 派生类</p>
<blockquote>
<p>In derived classes, <code>super()</code> must be called before you can use <code>this</code>. 在派生类中，使用<code>this</code> 前必先调用 <code>super()</code> 函数。</p>
</blockquote>
<p>granularity n. 间隔尺寸，[岩] 粒度</p>
<blockquote>
<p>the quality of being composed of relatively large particles</p>
</blockquote>
<p>an entire contiguous Ethernet packet 一个完整连续的以太网包</p>
<p>aligned <span style="color: #CCC; font-style: italic;">/əˈlaɪnd/</span> v. 结盟；支持；使成一直线；校准；安放，排列；使一致（align 的过去式和过去分词）</p>
<blockquote>
<p> byte-aligned memory address 字节内存地址</p>
</blockquote>
<p>explicitly  <span style="color: #CCC; font-style: italic;">/ɪkˈsplɪsɪtli/</span> adv. 明确地；明白地</p>
<p>implicitly  <span style="color: #CCC; font-style: italic;">/ɪmˈplɪsɪtli/</span> adv. 含蓄地；暗中地</p>
<blockquote>
<p>explicity and implicity 显性和隐性</p>
</blockquote>
<p>auxiliary <span style="color: #CCC; font-style: italic;">/ɔːɡˈzɪliəri/</span> adj. 辅助的；副的；附加的；（发动机、设备等）备用的</p>
<blockquote>
<p>auxiliary definitions 辅助定义</p>
</blockquote>
<p>assert vt. 维护，坚持；断言；主张；声称</p>
<p>assertion <span style="color: #CCC; font-style: italic;">/əˈsɜːʃn/</span> n. 断言，声明；主张，要求；坚持；认定</p>
<blockquote>
<p>assertion check 断言检查</p>
<p>internal asserts 内部断言</p>
</blockquote>
<p>mangle <span style="color: #CCC; font-style: italic;">/mæŋgl/</span> vt. 乱砍、损坏</p>
<p>name mangling （函数）命名重整</p>
<blockquote>
<p>The process of encoding the signature into the link name is referred to as <strong>name mangling</strong>.  对链接名称解码签名的过程被称为命名重整。</p>
<p>Since function overloading is accomplished through <strong>name mangling</strong>, function overloading has limitations for functions that are called from the configuration. 由于函数重载是通过命名重整完成的，因此函数重载对从配置中调用的函数有限制。</p>
</blockquote>
<p>assemble vt. 集合，聚集；装配；收集 vi. 集合，聚集</p>
<p>assembly n. 装配；集会，集合 n. 汇编，编译</p>
<blockquote>
<p>assembly source 汇编源代码</p>
<p>assembly code 汇编码</p>
</blockquote>
<p>toggle <span style="color: #CCC; font-style: italic;">/ˈtɒɡl/</span> n. 拴扣；切换键，开关；套索钉 v. 切换；拴牢，系紧</p>
<p>split <span style="color: #CCC; font-style: italic;">/splɪt/</span> vt. 分离；使分离；劈开；离开；分解 vi. 离开；被劈开；断绝关系 n. 劈开；裂缝 adj. 劈开的</p>
<blockquote>
<p>toggle split editor 切换分屏编辑器</p>
<p>toggle full screen 切换全屏幕</p>
<p>toggle funciton 切换功能？</p>
</blockquote>
<p>perspective n. 观点；远景；透视图 adj. 透视的</p>
<blockquote>
<p>customize perspective 定制化的角度（来看）</p>
</blockquote>
<p>specification n. 规范  (a detailed description of design criteria for a piece of work)</p>
<p>benchmark n. 参考标准，基准 (a standard by which something can be measured or judged)</p>
<blockquote>
<p>specifications for benchmark tests 基准测试规范</p>
</blockquote>
<p>target-specific functions 目标特定的功能</p>
<blockquote>
<p>device-specific functions 设备特定的功能</p>
</blockquote>
<p>instantiation n. 实例化；[计] 例示 </p>
<p>implement v. vt. 实施，执行；实现，使生效 n. 工具，器具；手段 (apply in a manner consistent with its purpose or design)</p>
<blockquote>
<p>implementation of the IGateProvider interface 接口的实现</p>
<p>instantiation of clock 时钟实例化</p>
</blockquote>
<p>fixed    adj. 固定的</p>
<blockquote>
<p>variable-sized buffers 可变大小缓冲</p>
<p>fixed-size buffers 固定大小缓冲</p>
</blockquote>
<p>dynamic memory allocation and deallocation 动态内存分配和回收</p>
<p>reentrant versions 可重入版本</p>
<blockquote>
<p>SYS/BIOS provides reentrant versions of malloc() and free() that internally use the xdc.runtime. SYS/BIOS为内部使用XDC.RUNTIME的 malloc() 和 free() 提供了可重入版本。</p>
</blockquote>
<p>formal parameter 形式参数</p>
<blockquote>
<p>C++ allows you to specify default values for formal parameters within the function declaration. C++允许你在函数声明中指定形参的默认值。</p>
</blockquote>
<p>invoke the class member function 调用类成员函数</p>
<blockquote>
<p>By writing a wrapper function which accepts a class instance as a parameter, you can invoke the class member function from within the wrapper. 通过编写以类实例作为参数的包装函数，你可以在包装函数中调用其类成员函数。</p>
</blockquote>
<p>context of a software interrupt 软件中断的上下文</p>
<blockquote>
<p>Memory allocation APIs such as <code>Memory_alloc()</code> and <code>Memory_calloc()</code> cannot be called from within the context of a software interrupt.内存分配接口如A和B不能够在软件中断的上下文中被调用。</p>
</blockquote>
<p>commit <span style="color: #CCC; font-style: italic;">/kəˈmɪt/</span>    vt. 犯罪；把…交托给；指派…作战；使…承担义务；（公开地）表示意见</p>
<p>​    vi. 忠于（某个人、机构等）；承诺</p>
<blockquote>
<p>amend last commit 修改上一次提交（的数据）</p>
<p>initial commit message 初始提交消息</p>
</blockquote>
<p>advance vt. 使……前进</p>
<blockquote>
<p>advancing the connected timer by one second 将连接的时钟向前推进1秒</p>
<p>advance at different rates 以不同的速率前进</p>
</blockquote>
<p>preempt 抢占</p>
<blockquote>
<p> All Clock functions run at the same Swi priority, so one Clock function cannot preempt another. 所有的时钟函数都运行在相同的SWI优先级，所以一个时钟函数不能抢占另一个时钟函数。</p>
</blockquote>
<p>optimal isolation 最佳隔离？？？</p>
<blockquote>
<p>As previously stated, the stack has been designed for optimal isolation, and so that it may seamlessly plug in to varying run-time environments. </p>
</blockquote>
<p>parse <span style="color: #CCC; font-style: italic;">/‘pɑːz/</span> v.理解，从语法上分析，解析</p>
<blockquote>
<p>Parsing CGI Form Data 解析CGI结构的数据</p>
</blockquote>
<p>constructor n. 构造函数；构造器；建造者</p>
<p>destructor n. 析构函数</p>
<p>millenium n. 千年；千禧年</p>
<p>leap year 闰年</p>
<p>second 秒</p>
<p>microsecond 微秒</p>
<p>millisecond 毫秒</p>
<p>nanosecond 纳秒</p>
<p>farad 法拉</p>
<p>microfarad 微法</p>
<p>millifarad 毫法</p>
<p>nanofarad 纳法</p>
<p>the attached clock 附带的时钟</p>
<p>results in an accurate clock 产生了（导致、致使）一个精确的时钟</p>
<p>period n. 周期</p>
<p>periodic <span style="color: #CCC; font-style: italic;">/periɒdik/</span> adj. 周期的</p>
<p>semaphore  <span style="color: #CCC; font-style: italic;">/ˈseməfɔːr/</span> n. 信号标，旗语；臂板信号装置 v. 打旗语，发信号</p>
<p>diagnostics n. 诊断学（用作单数）</p>
<p>declaration <span style="color: #CCC; font-style: italic;">/,deklə’reiʃən/</span> n. （纳税品等的）申报；宣布；公告；申诉书；声明；</p>
<p>prefix n. 前缀 vt. 加前缀；将某事物加在前面</p>
<p>stage changed （确认）暂存（数据）已变化</p>
<p>device endianness  设备字节顺序</p>
<p>terminate <span style="color: #CCC; font-style: italic;">/ˈtɜːmɪneɪt/</span>   vi./vt. 使终止；使结束；解雇</p>
<p>Event Combiner 事件组合器</p>
<p>octet <span style="color: #CCC; font-style: italic;">/ɔk’tet/</span> 八重、八位（计算机语境下，基本与byte同意）</p>
<p>configuration entry 配置条目</p>
<p>is independent of 独立于……；相对于……独立</p>
<p>wrapper function 包装函数</p>
<p>patched <span style="color: #CCC; font-style: italic;">/pætʃt/</span>  adj. 打补丁的  v. 打补丁；遮盖（视力好的眼）促进弱视眼看；（用补丁对程序）改错（patch 的过去式和过去分词）</p>
<p>be patched with 用**修补</p>
<p>volatile <span style="color: #CCC; font-style: italic;">/ˈvɒlətaɪl/</span> adj. [化学] 挥发性的；不稳定的；爆炸性的；反复无常的 n. 挥发物；有翅的动物</p>
<p>volatile unsigned int</p>
<p>prior <span style="color: #CCC; font-style: italic;">/ˈpraɪər/</span> adj. （时间、顺序等）先前的；优先的</p>
<p>priority n. 优先级</p>
<p>prioritize <span style="color: #CCC; font-style: italic;">/praɪˈɒrətaɪz/</span> v. 按优先顺序列出，确定 (任务) 优先顺序；优先处理，优先考虑</p>
<p>prior to 在……之前； 居先</p>
<blockquote>
<p>It is important to enrich the soil prior to planting. 栽种之前给土壤施肥很重要。</p>
</blockquote>
<p>indicate vt. 表明；指出；预示；象征</p>
<p>prologue <span style="color: #CCC; font-style: italic;">/prəʊlɒg/</span> <em>n</em>. 开场白</p>
<p>static inline 静态内联</p>
<p>hint n. 暗示；线索 <em>vt</em>. 暗示；示意 <em>vi</em>. 示意</p>
<blockquote>
<p>This chapter provides hints for improving the runtime performance and shared memory usage of applications that use IPC.</p>
</blockquote>
<p>mandatory <span style="color: #CCC; font-style: italic;">/‘mændətəri/</span> <em>adj</em>. 强制的；命令的；托管的； <em>n</em>. 受托者</p>
<p>elicit <span style="color: #CCC; font-style: italic;">/i’lisit/</span> <em>vt</em>. 引出</p>
<blockquote>
<p>Ping uses the ICMP protocol’s mandatory ECHO_REQUEST datagram to elicit  an ICMP ECHO_RESPONSE from a host or gateway.</p>
<p>PING使用ICMP协议的强制性的“回声请求”数据报来引出主机或网关的“回声响应”。</p>
</blockquote>
<p>incorporate 包含</p>
<blockquote>
<p>The ADAU1772 is a codec with four inputs and two outputs that incorporates a digital processing engine to perform filtering, level control, signal level monitoring, and mixing. </p>
</blockquote>
<p>low latency 低延迟</p>
<p>noise cancelling headset 降噪耳机</p>
<blockquote>
<p>The path from the analog input to the DSP core to the analog output is<br>optimized for low latency and is ideal for noise cancelling headsets.</p>
</blockquote>
<p>analog to analog latency 模比延迟</p>
<blockquote>
<p>38 μs analog-to-analog latency</p>
</blockquote>
<p>bias <em>n</em>. 偏移；偏差；偏见；<em>vt</em>. 使存偏见 <em>adj</em>. 偏斜的 <em>adv</em>. 偏斜地</p>
<p>bias generators 偏置发生器</p>
<p>ADC<br>modulator ADC调制器</p>
<p>ADC decimator</p>
<p>clock oscillator <span style="color: #CCC; font-style: italic;">/ˈɒsɪleɪtə(r)/</span> 时钟振荡器</p>
<p>Cofficient write 系数写？？？</p>
<p>base address 基地址</p>
<p>schematic n. 原理图</p>
<p>offset error 便宜误差</p>
<p>gain error 增益误差</p>
<p>interchannel isolation 通道间隔</p>
<p>power supply rejection ratio 电源抑制比</p>
<p>SNR（Signal-to-Noise Ratio） 信噪比</p>
<p>attenuation 衰减</p>
<p>digital attenuation step 数字衰减步长</p>
<p>digital attenuation range 数字衰减范围</p>
<p>Total Harmonic Distortion + Noise 总谐波失真噪声</p>
<p>tristate <em>n</em>. 三角洲的</p>
<p>tristate buffer 三态缓冲器</p>
<p>tristate control 三态控制</p>
<p>tristating <em>adj</em>. ????</p>
<p>on-board fractional PLL 小数分频PLL</p>
<p>on-board regulator 板载调节器</p>
<blockquote>
<p>The on-board regulator generates the 3.3 V dc or 1.8 V dc supply, determined by S1, for the on-board circuitry. 板载整流器为板载电流提供了由S1决定的1.8V或3.3V电压。</p>
</blockquote>
<p>internal digital supply voltage 内部数字电源电压</p>
<blockquote>
<p>The operating voltage range is 1.8 V to<br>3.63 V, with an on-board regulator generating the internal<br>digital supply voltage.</p>
</blockquote>
<p>electret  <span style="color: #CCC; font-style: italic;">/ɪˈlektrət/</span> <em>n</em>. 驻极体；电介体</p>
<p>electret microphone 驻极体麦克风</p>
<p>seamless interfacing 无缝连接（的接口）</p>
<blockquote>
<p>Two microphone bias pins provide seamless interfacing to electret microphones. 两个麦克风偏置针为驻极体麦克风提供了无缝连接。</p>
</blockquote>
<p> graphical programming software 图形化编程软件</p>
<blockquote>
<p>The program and parameter RAMs can be loaded with custom audio processing signal flow built using the SigmaStudio™ graphical programming software from Analog Devices, Inc. 在使用Analog Devices公司的SigmaStudio图形化编程软件建立自定义音频处理信号流时，程序和参数内存会被自动加载。</p>
</blockquote>
<p>standalone operation 独立操作</p>
<blockquote>
<p>For standalone operation, the clock can be generated using the on-board crystal oscillator.</p>
</blockquote>
<p>A be fed directly to <em>somewhere</em> / B      A被直接带到某处 、A被直接喂给B（吃掉）</p>
<blockquote>
<p>The ADAU1772 can generate its clocks either from an externally provided clock or from a crystal oscillator. In both cases, the on board PLL can be used or the clock can be fed directly to the core. </p>
</blockquote>
<p>rate <em>n</em>. 比率，率；速度；价格；等级<br><em>vt</em>. 认为；估价；责骂<br><em>vi</em>. 责骂；被评价</p>
<p>ratio <em>n</em>. 比率，比例</p>
<p>speed <em>n</em>. 速度，速率；进度；迅速；繁荣；感光度；排挡；<br><em>v</em>. 快速运动；加速；促进；</p>
<blockquote>
<p>The rate of the internal master clock must be set properly using the CC_MDIV bit in the clock control register (Address 0x0000).  内部主时钟的速率必须要在时钟控制寄存器下的CC_MDIV位上设置正确。</p>
</blockquote>
<p>LDO regulator （某种）线性稳压器？</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210421160130520.png" alt="image-20210421160130520" style="zoom: 67%;" />



<p>circuitry <span style="color: #CCC; font-style: italic;">/ˈsɜːkɪtri/</span> n. 电路；电路系统；电路学；一环路</p>
<blockquote>
<p>The easiest way to achieve this is to use a regulator that<br>has a power good (PGOOD) signal to power the ADAU1772 or<br>generate a power good signal using additional circuitry external<br>to the regulator itself.</p>
</blockquote>
<p>regular <em>adj</em>. 有规律的</p>
<p>regulate <em>vt</em>. 调节；规定；控制；校准；有系统地管理</p>
<p>regulated voltage 稳定电压</p>
<p>regulator <em>n</em>. 监管机构，监管者；调整者；校准器；稳压器</p>
<blockquote>
<p>Typically, on such regulators the power good<br>signal changes state when the regulated voltage drops below ~90%<br>of its target value. 通常只有在稳定电压低于规定目标的90%以下时，这些稳压器的良好信号才会改变状态。</p>
</blockquote>
<p>polar 北极</p>
<p>polarity <span style="color: #CCC; font-style: italic;">/pəˈlærəti/</span> <em>n</em>. [物] 极性；两极；对立</p>
<p>signal polarity 信号极性</p>
<p>unipolar signal 单极信号（仅有零值和正值）</p>
<p>bipolar signal 双极信号（有正负值和零值）</p>
<p>impedance <span style="color: #CCC; font-style: italic;">/ɪmˈpiːdns/</span> n. 阻抗</p>
<p>input impedance 输入阻抗</p>
<p>output impedance 输出阻抗</p>
<p>load impedance 负载阻抗</p>
<p>impedance matching 阻抗匹配</p>
<p>impedance mismatch 阻抗失配</p>
<p>amplify <em>vt</em>. 放大，扩大；增强；详述<br><em>vi</em>. 详述</p>
<p>amplifier <em>n</em>. 增益器；放大器；</p>
<p>power amplifier （也简写: power amp）功率放大器</p>
<p>pre-amplifier 前置放大器（也写作：preamplifier 或 preamp）</p>
<p>signal path 信号通路，信号路径</p>
<p><em>【这语法令我迷惑】</em></p>
<blockquote>
<p>The MICBIASx pins can also be used to cleanly supply voltage to digital or analog MEMS microphones with separate power supply pins. </p>
<p>能够为数字（信号）和模拟（信号）的MEMS麦克风提供稳定供应的电压（cleanly supply voltage）</p>
</blockquote>
<p>attenuate <em>v</em>. （使）减弱；（使）纤细，稀薄<br>adj. 减弱的；稀薄的；细小的</p>
<p>attenuated <em>adj</em>. （力量或效果）衰减的；（人）瘦长的<br><em>v</em>. 使减弱；使变细；稀释</p>
<p>attenuation n. [物] 衰减；变薄；稀释</p>
<blockquote>
<p>The volume setting of each ADC can be digitally attenuated in the ADCx_VOLUME registers (Address 0x001F to Address 0x0022).</p>
</blockquote>
<p>PCM (Pulse Code Modulation) 脉冲编码调至</p>
<p>PDM (Pulse Density Modulation) 脉冲密度调制</p>
<p>PDM modulator</p>
<p>coupling capacitor 耦合电容器</p>
<p>connect A in series with B  让A与B以串联形式连接</p>
<blockquote>
<p>The headphone outputs can also be configured as ground centered outputs by connecting coupling capacitors in series with the output pins. </p>
</blockquote>
<p>corner frequency 角频率</p>
<p>suppress vt. 抑制；镇压；废止</p>
<p>suppression n. 抑制；镇压；[植] 压抑</p>
<p>Pop-and-Click Suppression 音频杂音（嘀嗒和爆破）抑制</p>
<p>potentiostat  <span style="color: #CCC; font-style: italic;">/pəu’tenʃiəstæt/</span> <em>n</em>. 恒电势器；[电] 稳压器</p>
<p>potentiostatic <em>adj</em>. 电压稳定器的；恒电势的；电势恒定器的</p>
<p>potentiometer <span style="color: #CCC; font-style: italic;">/pəˌtenʃiˈɒmɪtə(r)/</span> <em>n</em>. 电位计；分压计</p>
<p>potentiometric <span style="color: #CCC; font-style: italic;">/pəu,tenʃiə’metrik/</span> <em>adj</em>. 电势测定的，电位计的</p>
<blockquote>
<p>control interface: switches and potentiometers 控制接口：开关和电位器</p>
</blockquote>
<p>level 有 <code>层级</code>、 <code>等级</code> 、<code>电平</code>、<code>水平</code> 之意，较难区分。</p>
<p><strong>等级</strong>：relative stack priority level 相对堆栈优先（等）级</p>
<blockquote>
<p>The below options allow you to set the scheduler’s relative stack priority level and run mode.</p>
<p>下列设置允许你调整调度器的相对堆栈优先级和运行模式。</p>
</blockquote>
<p><strong>层级</strong>：以下为音频信号从弱到强的各层：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>microphone level 麦克风层</td>
<td>microphone output</td>
<td></td>
</tr>
<tr>
<td>instrument level 乐器层</td>
<td></td>
<td></td>
</tr>
<tr>
<td>line level 线路层</td>
<td>line output</td>
<td></td>
</tr>
<tr>
<td>speak level 喇叭层</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>be driven either by a line output driver or by a microphone driver.</p>
<p>drive differential loads</p>
</blockquote>
<p><strong>电平</strong>：full-scale level 满量程电平</p>
<blockquote>
<p>Therefore, the full-scale level of a signal in the processing core will be slightly different from a full-scale level external to the IC. </p>
</blockquote>
<blockquote>
<p>full-scale 全尺寸的、全尺度的、满量程的</p>
<p>full-scale input voltage 满量程输入电压</p>
</blockquote>
<p>precision 精度</p>
<p>single-precision 单精度</p>
<p>double-precision 双精度</p>
<p>Single-precision biquad filter 单精度双四轴滤波器</p>
<blockquote>
<p>The double length memory enables the core to double precision arithmetic with double length data and single length coefficients.</p>
</blockquote>
<p>second order filter 二阶滤波器</p>
<p>limiter 限幅器</p>
<p>endian <em>n</em>. 字节存储次序，元组排列顺序</p>
<p>big-endian</p>
<p>small-endian</p>
<p>two parameter banks 参数集（参数组， two sets of parameters）</p>
<blockquote>
<p>There are two parameter banks available. Each bank can hold a full set of 160 parameters (32 filters × 5 coefficients).</p>
</blockquote>
<p>A be assigned to B   A被分配给了B</p>
<blockquote>
<p>Parameters are assigned to instructions in the order in which<br>the instructions are instantiated in the code. 参数按照在代码中实例化指令的顺序被分配给了指令。</p>
</blockquote>
<p>以下词汇均有 “<strong>线路</strong>“ 之意：line、wire、trace、cable</p>
<p>connect the audio cables 连接音频电缆</p>
<p>wider trace 更宽的线路、更宽的导线</p>
<blockquote>
<p>If the<br>headphone amplifiers are enabled, the PCB trace to this pin should<br>be wider than traces to other pins to increase the current carrying<br>capacity. A wider trace should also be used for the headphone<br>output lines.</p>
</blockquote>
<p>equivalent <em>adj</em>. （在价值、数量等方面）相等的；等价的；等效的；等量的；同意义的<br><em>n</em>. 对等的人（或事物）；当量</p>
<p>equidistant <span style="color: #CCC; font-style: italic;">/ˌiːkwɪˈdɪstənt/</span> <em>adj</em>. 等距的；距离相等的</p>
<p>locate <em>sth</em>. from <em>somewhere</em> 从某处定位某物</p>
<blockquote>
<p>For maximum effectiveness, <em>locate</em> the capacitor equidistant<br><em>from</em> the power and ground pins or slightly closer to the power pin<br>if equidistant placement is not possible. 为了获取最大效率，应在电源及接地的等距接口处置放电容，若等距放置无法采用，则应在放置在电源一侧。</p>
</blockquote>
<p>bypass capacitor 旁路电容</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Bypass-capacitor.png" alt="旁路电容" style="zoom:50%;" />

<p>be bypassed with a capacitor 用一个电容进行绕装</p>
<blockquote>
<p>Each supply signal on the board should also be bypassed with a single bulk capacitor (10 μF to 47 μF).</p>
</blockquote>
<p>sequence file</p>
<p>address/data file</p>
<p>solder <em>n</em>. 焊料；接合物<br><em>v</em>. 焊接；使联接在一起</p>
<p>unpopulated header pads 未焊接点（盘）</p>
<p>unpopulated pcb 无载印制电路板</p>
<blockquote>
<p>To use an external speaker, wires can be soldered to the<br>unpopulated header pads, J13 and J16.</p>
<p>The R2 resistor is not populated from the factory.  在工厂时，R2电阻未安装。</p>
</blockquote>
<p>left/right justified</p>
<p>install <em>sth</em>. across <em>sth</em>. 在某物上安装某物</p>
<blockquote>
<p>To use MCLK on the J4 header, first install a resistor across<br>the R2 pads.  要在J4引脚上使用MCLK，首先要在R2焊盘上安装一个电阻。</p>
</blockquote>
<p><img src="http://pic.islet.space/2021/04/aiologo.png" alt="aiologo"></p>
<p>single-address mode</p>
<p>burst mode</p>
<blockquote>
<p>All addresses can be accessed in either single-address mode or burst mode. </p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2020/11/05/Web/%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/05/Web/%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">网页前端开发笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-05 23:58:32" itemprop="dateCreated datePublished" datetime="2020-11-05T23:58:32+08:00">2020-11-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-26 00:08:57" itemprop="dateModified" datetime="2021-04-26T00:08:57+08:00">2021-04-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Networking/" itemprop="url" rel="index"><span itemprop="name">Networking</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="PART-1-HTML"><a href="#PART-1-HTML" class="headerlink" title="PART 1: HTML"></a>PART 1: HTML</h1><div style="font-style: italic; color: #999; text-align: right;">——佳佳</div>

<p>Hyper Text Markup Language超文本标记语言</p>
<h2 id="HTML框架"><a href="#HTML框架" class="headerlink" title="HTML框架"></a>HTML框架</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">long</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">title</span>&gt;</span>TAG<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h2><h3 id="基础标签"><a href="#基础标签" class="headerlink" title="基础标签"></a>基础标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">long</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>内容标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">hr</span>&gt;</span><span class="comment">&lt;!--此处添加水平线--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                此处为<span class="tag">&lt;<span class="name">br</span>&gt;</span>段落内容</span><br><span class="line">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">标签</th>
<th align="center">功能</th>
<th align="center">应用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;DOCTYPE&gt;</td>
<td align="center">定义文档类型</td>
<td align="center">&lt;!DOCTYPE html&gt;</td>
</tr>
<tr>
<td align="center">&lt;html&gt;</td>
<td align="center">定义一个HTML文档</td>
<td align="center">&lt;html long=”zh”&gt;内容&lt;/html&gt;</td>
</tr>
<tr>
<td align="center">&lt;title&gt;</td>
<td align="center">为文档定义一个标题</td>
<td align="center">&lt;title&gt;标题&lt;/title&gt;</td>
</tr>
<tr>
<td align="center">&lt;body&gt;</td>
<td align="center">文档的主体</td>
<td align="center">&lt;body&gt;主体&lt;/body&gt;</td>
</tr>
<tr>
<td align="center">&lt;h1&gt;to&lt;h6&gt;</td>
<td align="center">HTML标题</td>
<td align="center">&lt;h1&gt;标题&lt;/h1&gt;</td>
</tr>
<tr>
<td align="center">&lt;p&gt;</td>
<td align="center">一个段落</td>
<td align="center">&lt;p&gt;内容&lt;/p&gt;</td>
</tr>
<tr>
<td align="center">&lt;br&gt;</td>
<td align="center">换行</td>
<td align="center">&lt;br/&gt;</td>
</tr>
<tr>
<td align="center">&lt;hr&gt;</td>
<td align="center">水平线</td>
<td align="center">&lt;hr&gt;</td>
</tr>
<tr>
<td align="center">&lt;!—-&gt;</td>
<td align="center">注释</td>
<td align="center">&lt;!–需要注释的内容–&gt;</td>
</tr>
</tbody></table>
<h3 id="格式标签"><a href="#格式标签" class="headerlink" title="格式标签"></a>格式标签</h3><table>
<thead>
<tr>
<th align="center">标签</th>
<th align="left">功能</th>
<th align="left">应用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;abbr&gt;</td>
<td align="left">定义一个缩写</td>
<td align="left">&lt;abbr title=”蹲坑”&gt;dk&lt;/abbr&gt;</td>
</tr>
<tr>
<td align="center">&lt;address&gt;</td>
<td align="left">定义文档作者/所有者的联系信息</td>
<td align="left">&lt;address&gt;地址联系信息&lt;/address&gt;</td>
</tr>
<tr>
<td align="center">&lt;b&gt;</td>
<td align="left">加粗(无语义)</td>
<td align="left">&lt;b&gt;文本&lt;/b&gt;</td>
</tr>
<tr>
<td align="center">&lt;bdi&gt;</td>
<td align="left">设置一段文本，使其脱离其父元素的文本方向设置</td>
<td align="left">&lt;bdi&gt;文本&lt;/bdi&gt;</td>
</tr>
<tr>
<td align="center">&lt;bdo&gt;</td>
<td align="left">定义文本方向（rtl&amp;ltr）</td>
<td align="left">&lt;bdo dir=”rtl”&gt;文本&lt;/bdo&gt;</td>
</tr>
<tr>
<td align="center">&lt;blockquote&gt;</td>
<td align="left">块引用(cite)</td>
<td align="left">&lt;blockquote cite=”url”&gt;引用内容&lt;/blockquote&gt;</td>
</tr>
<tr>
<td align="center">&lt;cite&gt;</td>
<td align="left">定义作品的标题（书籍、歌曲、电影等）</td>
<td align="left">&lt;cite&gt;作品标题&lt;/cite&gt;</td>
</tr>
<tr>
<td align="center">&lt;code&gt;</td>
<td align="left">定义计算机代码文本</td>
<td align="left">&lt;code&gt;代码&lt;/code&gt;</td>
</tr>
<tr>
<td align="center">&lt;del&gt;</td>
<td align="left">删除线</td>
<td align="left">&lt;del&gt;要删除的文本&lt;/del&gt;</td>
</tr>
<tr>
<td align="center">&lt;dfn&gt;</td>
<td align="left">定义项目</td>
<td align="left">&lt;dfn&gt;项目名&lt;/dfn&gt;</td>
</tr>
<tr>
<td align="center">&lt;em&gt;</td>
<td align="left">倾斜字体（语义较强）</td>
<td align="left">&lt;em&gt;字体&lt;/em&gt;</td>
</tr>
<tr>
<td align="center">&lt;i&gt;</td>
<td align="left">倾斜字体（无语义）</td>
<td align="left">&lt;i&gt;需倾斜文本&lt;/i&gt;</td>
</tr>
<tr>
<td align="center">&lt;ins&gt;</td>
<td align="left">定义删除后新插入的文本</td>
<td align="left">&lt;del&gt;red&lt;/del&gt;&lt;ins&gt;blue&lt;/ins&gt;</td>
</tr>
<tr>
<td align="center"><mark>&lt;mark&gt;</mark></td>
<td align="left">高亮文本</td>
<td align="left">&lt;mark&gt;文本&lt;/mark&gt;</td>
</tr>
<tr>
<td align="center"><mark>&lt;meter&gt;</mark></td>
<td align="left">已知最大最小值的度量<br>value(必须)：规定当前值<br>max:规定最大值；min:规定最小值<br>high:规定最高值；low:规定最低值<br>optimum:规定最优值</td>
<td align="left">&lt;meter value=”2” min=”0” max=”10”&gt;2 out of 10&lt;/meter&gt;<br>&lt;meter value=”0.6”&gt;60%&lt;/meter&gt;</td>
</tr>
<tr>
<td align="center"><mark>&lt;progress&gt;</mark></td>
<td align="left">定义运行任务进度</td>
<td align="left">&lt;progress value=”22”  max=”100”&gt;&lt;/progress&gt;</td>
</tr>
<tr>
<td align="center">&lt;q&gt;</td>
<td align="left">定义短的引用</td>
<td align="left">&lt;q&gt;引用内容&lt;/q&gt;</td>
</tr>
<tr>
<td align="center"><mark>&lt;rp&gt;</mark></td>
<td align="left">定义不支持 ruby 元素的浏览器所显示的内容</td>
<td align="left">&lt;ruby&gt;&lt;br/&gt;汉  &lt;rt&gt;&lt;rp&gt;(&lt;/rp&gt;ㄏㄢˋ&lt;rp&gt;)&lt;/rp&gt;&lt;/rt&gt;&lt;br/&gt;&lt;/ruby&gt;</td>
</tr>
<tr>
<td align="center"><mark>&lt;rt&gt;</mark></td>
<td align="left">定义字符（中文注音或字符）的解释或发音</td>
<td align="left">&lt;ruby&gt;&lt;br/&gt;汉 &lt;rt&gt; ㄏㄢˋ  &lt;/rt&gt;&lt;br/&gt;&lt;/ruby&gt;</td>
</tr>
<tr>
<td align="center"><mark>&lt;ruby&gt;</mark></td>
<td align="left">定义ruby注释（中文注音或字符）</td>
<td align="left">&lt;ruby&gt;&lt;br/&gt;汉 &lt;rt&gt; ㄏㄢˋ  &lt;/rt&gt;&lt;br/&gt;&lt;/ruby&gt;</td>
</tr>
<tr>
<td align="center">&lt;s&gt;</td>
<td align="left">删除线</td>
<td align="left">&lt;s&gt;文本&lt;/s&gt;</td>
</tr>
<tr>
<td align="center">&lt;strong&gt;</td>
<td align="left">加粗（语义较强）</td>
<td align="left">&lt;strong&gt;文本&lt;/strong&gt;</td>
</tr>
<tr>
<td align="center">&lt;sub&gt;</td>
<td align="left">下标文本</td>
<td align="left">&lt;sub&gt;文本&lt;/sub&gt;</td>
</tr>
<tr>
<td align="center">&lt;sup&gt;</td>
<td align="left">上标文本</td>
<td align="left">&lt;sup&gt;文本&lt;/sup&gt;</td>
</tr>
<tr>
<td align="center"><mark>&lt;time&gt;</mark></td>
<td align="left">定义公历时间（24）或日期</td>
<td align="left">The concert starts at &lt;time&gt;20:00&lt;/time&gt;<br>The concert took place on <time datetime="2001-05-15 19:00">May 15</time></td>
</tr>
<tr>
<td align="center">&lt;u&gt;</td>
<td align="left">下划线</td>
<td align="left">&lt;u&gt;文本&lt;/u&gt;</td>
</tr>
</tbody></table>
<h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;form&gt;</td>
<td>定义一个表单域</td>
</tr>
<tr>
<td>&lt;input&gt;</td>
<td>定义一个输入控件<br>type: <br>button:定义一个按钮。<br>file:选择文件<br>submit:提交按钮(点击后会向后台提交所选表单域中的信息)<br>search:搜索框<br>password:密码框<br>date:选择时间框(年-月-日)<br>text:单行文本<br>datetime-local:选择年月日时分<br>tel:电话号码 <br>radio:单选按钮(需要给<mark>相同的name</mark>)<br>checkbox:复选按钮<br>color:选择颜色<br>email:邮箱<br>number:输入数字<br>reset:重新输入<br>week:多少年的第几周</td>
</tr>
<tr>
<td>&lt;textarea&gt;</td>
<td>多行文本输入框&lt;textarea&gt;自定义内容&lt;/textarea&gt;</td>
</tr>
<tr>
<td>&lt;select&gt;</td>
<td>下拉选择列表&lt;select&gt;option*N&lt;/select&gt;<br>size:规定下拉菜单中可见的选项数目<br>required=”required”:必须要选一个<br>multiple=”true”:可选多个选项</td>
</tr>
<tr>
<td>&lt;optgroup&gt;</td>
<td>选择列表中相关选项的组合{<optgroup label="组合名">option*N</optgroup>}N</td>
</tr>
<tr>
<td>&lt;option&gt;</td>
<td>选择列表中的选项</td>
</tr>
<tr>
<td>&lt;label&gt;</td>
<td>input元素的标注(不点击控件，点链接到的文字也可以定位到控件)<br>&lt;label <mark>for=”male”</mark>&gt;Male&lt;/label&gt;<br/>&lt;input type=”radio”  name=”sex” <mark>id=”male”</mark> value=”male”&gt;</td>
</tr>
<tr>
<td>&lt;fieldset&gt;</td>
<td>围绕表单中元素的边框</td>
</tr>
<tr>
<td>&lt;legend&gt;</td>
<td>定义fieldset元素的标题</td>
</tr>
<tr>
<td>&lt;datalist&gt;</td>
<td>规定input元素可能的选项列表</td>
</tr>
<tr>
<td>&lt;keygen&gt;</td>
<td>用于表单的秘钥对生成器字段</td>
</tr>
<tr>
<td>&lt;output&gt;</td>
<td>定义计算的结果</td>
</tr>
</tbody></table>
<h3 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h3><h4 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h4><p><mark>&lt;img&gt;</mark></p>
<p><strong>作用：</strong>向网页中嵌入一张图片</p>
<p><strong>应用：</strong><code>&lt;img src=&quot;url&quot; alt=&quot;图片加载不出来时的代替文本&quot; title=&quot;鼠标放到图片上的介绍文本&quot;&gt;</code></p>
<p>**Note:**绝对路径用“\”;相对路径用“/”</p>
<h4 id="视频标签"><a href="#视频标签" class="headerlink" title="视频标签"></a>视频标签</h4><h4 id="音频标签"><a href="#音频标签" class="headerlink" title="音频标签"></a>音频标签</h4><h3 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h3><p><mark>&lt;a&gt;</mark></p>
<p><strong>作用</strong>：超链接</p>
<p><strong>应用</strong>：&lt;a href=”链接地址” target=”_blank”&gt;连接描述&lt;/a&gt;<strong><code>（内部、外部链接）</code></strong></p>
<p>​            &lt;a href=”#”&gt;链接描述&lt;/a&gt;<strong><code>（空链接）</code></strong></p>
<p>​            &lt;a href=”文件地址、压缩包地址”&gt;<strong><code>下载文件</code><strong>&lt;/a&gt;</strong><code>（文本、图片、视频、音频等均可以为超链接）</code></strong></p>
<p>​            &lt;a href=”#age”&gt;年龄&lt;/a&gt;</p>
<p>​            &lt;h3 id=”age”&gt;年龄详情&lt;/h3&gt;<strong><code>(锚点链接)</code></strong></p>
<p>Note:</p>
<ul>
<li>默认为_self(当前窗口打开)</li>
<li>_blank(新窗口中打开)</li>
<li>​    _top(整个窗口中打开)</li>
</ul>
<h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>功能</th>
<th>应用</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;ul&gt;</td>
<td>定义一个无序列表</td>
<td>&lt;ul&gt;&lt;li&gt;&lt;li&gt;&lt;/li&gt;&lt;/li&gt;&lt;&lt;/ul&gt;</td>
</tr>
<tr>
<td>&lt;ol&gt;</td>
<td>定义一个有序列表</td>
<td>&lt;ol&gt;&lt;li&gt;&lt;li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/ol&gt;</td>
</tr>
<tr>
<td>&lt;li&gt;</td>
<td>定义列表项</td>
<td>&lt;ol&gt;&lt;li&gt;&lt;li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/ol&gt;</td>
</tr>
<tr>
<td>&lt;dl&gt;</td>
<td>定义一个定义列表</td>
<td>&lt;dl&gt;&lt;dt&gt;电脑&lt;/dt&gt;&lt;dd&gt;电脑的解释&lt;/dd&gt;&lt;/dl&gt;</td>
</tr>
<tr>
<td>&lt;dt&gt;</td>
<td>定义列表中的项目</td>
<td>&lt;dl&gt;&lt;dt&gt;电脑&lt;/dt&gt;&lt;dd&gt;电脑的解释&lt;/dd&gt;&lt;/dl&gt;</td>
</tr>
<tr>
<td>&lt;dd&gt;</td>
<td>定义列表中的项目描述</td>
<td>&lt;dl&gt;&lt;dt&gt;电脑&lt;/dt&gt;&lt;dd&gt;电脑的解释&lt;/dd&gt;&lt;/dl&gt;</td>
</tr>
</tbody></table>
<p>Note:</p>
<ul>
<li><p>&lt;ul&gt;&lt;ol&gt;里面只能放&lt;li&gt;标签，&lt;li&gt;标签里面可以放弃他标签</p>
</li>
<li><p>&lt;dd&gt;中的内容是&lt;dt&gt;中内容的说明或是包含于&lt;dd&gt;内容</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">long</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>列表<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span>洗衣机<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span>冰箱<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span>空调<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span>太阳<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span>地球<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span>西安<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">dt</span>&gt;</span>跨栏<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dd</span>&gt;</span>是一项运动<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dd</span>&gt;</span>奥运会项目<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dd</span>&gt;</span>刘翔是冠军<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;table&gt;</td>
<td>定义一个表格<br>border=”num”定义边框宽度</td>
</tr>
<tr>
<td>&lt;tr&gt;</td>
<td>定义行</td>
</tr>
<tr>
<td>&lt;td&gt;</td>
<td>定义单元格<br>colspan:规定单元格可横跨的列数<br>rowspan:规定单元格可横跨的行数</td>
</tr>
<tr>
<td>&lt;th&gt;</td>
<td>定义表头<mark>单元格</mark>(使内容居中加粗)</td>
</tr>
<tr>
<td>&lt;thead&gt;</td>
<td>定义表头<mark>整行</mark></td>
</tr>
<tr>
<td>&lt;tbody&gt;</td>
<td>定义表格主题内容</td>
</tr>
<tr>
<td>&lt;tfoor&gt;</td>
<td>定义表注（脚注）</td>
</tr>
</tbody></table>
<p>Note:</p>
<ul>
<li><p><mark>合并单元格时，选定操作目标单元格后，需要删掉被合并单元格的代码。</mark></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>表格<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">th</span>&gt;</span>序号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>张佳佳<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>24<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>张亮亮<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>33<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>张盼盼<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>22<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>张志荣<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>63<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="高级HTML知识"><a href="#高级HTML知识" class="headerlink" title="高级HTML知识"></a>高级HTML知识</h2><h3 id="网站图标设置"><a href="#网站图标设置" class="headerlink" title="网站图标设置"></a>网站图标设置</h3><h5 id="favicon"><a href="#favicon" class="headerlink" title="favicon"></a>favicon</h5><p><code>&lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot;&gt;</code></p>
<h3 id="头部标签设置"><a href="#头部标签设置" class="headerlink" title="头部标签设置"></a>头部标签设置</h3><h4 id="TDK三大标签及SEO优化"><a href="#TDK三大标签及SEO优化" class="headerlink" title="TDK三大标签及SEO优化"></a>TDK三大标签及SEO优化</h4><p>TDK三大标签即title、description、keyword；SEO即Search Engine Optimization，即搜索引擎优化。</p>
<h5 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h5><p> <code>&lt;title&gt;blablabla...&lt;/title&gt;</code></p>
<h5 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h5><p><code>&lt;meta name=&quot;description&quot; content=&quot;blablablabla...&quot; /&gt;</code></p>
<h5 id="Keyword"><a href="#Keyword" class="headerlink" title="Keyword"></a>Keyword</h5><p><code>&lt;meta name=&quot;keyword&quot; content=&quot;blablabla...&quot;&gt;</code></p>
<h1 id="PART-2-CSS"><a href="#PART-2-CSS" class="headerlink" title="PART 2: CSS"></a>PART 2: CSS</h1><div style="font-style: italic; color: #999; text-align: right;">——佳佳、铭锐、吉财</div>



<p><strong>WebKit浏览器：</strong></p>
<blockquote>
<p>基于WebKit Core的浏览器。</p>
<p>WebKit是一种用来让网页浏览器绘制网页的排版引擎。它被用于Apple Safari。其分支Blink被用于基于Chromium的网页浏览器，如Opera与Google Chrome。</p>
<p>Webkit亦使用于Apple iOS、BlackBerry Tablet OS、Tizen及Amazon Kindle的默认浏览器。WebKit的C++应用程序接口提供了一系列的Class以在视窗上显示网页内容，并且实现了一些浏览器的特色，如用户链接点击、管理前后页面列表及近期历史页面等等。</p>
<p>WebKit的HTML及JavaScript代码源自KDE的KHTML及KJS库的一个分支[3]，现已由KDE、Apple、Google、Nokia、Bitstream、BlackBerry及Igalia等独立开发[4]。OS X、Windows、GNU/Linux以及其他类Unix系统操作系统，皆支持这个项目[5]。2013年4月3日，Google宣布它创建了WebKit中WebCore组件的分支——Blink，Blink用于新版Google Chrome与Opera[6][7]。</p>
<p>WebKit的WebCore及JavaScriptCore组件使用GNU宽通用公共许可证，其他组件则采用BSD许可证[8]。</p>
<p>截至2013年3月7日，Webkit商标已被苹果公司在美国专利及商标局注册为其商标。[9]</p>
<p>——Wikipedia</p>
</blockquote>
<p>CSS是层叠样式表（Cascading Style Sheets）标记语言，主要用来设置文本的内容（大小、字体、对齐方式等）、图片的外形等等。</p>
<p><strong>CSS语法规范：</strong>由 <u>选择器</u> 以及 <u>一条或多条声明</u> 两个主要的部分构成。</p>
<p><strong>书写方式：</strong> <code>选择器:</code>  { <code>属性值;</code> }</p>
<h2 id="CSS基础知识"><a href="#CSS基础知识" class="headerlink" title="CSS基础知识"></a>CSS基础知识</h2><h3 id="1-CSS-类命名规则"><a href="#1-CSS-类命名规则" class="headerlink" title="1. CSS 类命名规则"></a>1. CSS 类命名规则</h3><h4 id="公共命名规则"><a href="#公共命名规则" class="headerlink" title="公共命名规则"></a>公共命名规则</h4><table>
<thead>
<tr>
<th align="left">CSS样式命名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">wrapper</td>
<td align="left">页面外围控制整体布局宽度</td>
</tr>
<tr>
<td align="left">container或content</td>
<td align="left">容器,用于最外层</td>
</tr>
<tr>
<td align="left">layout</td>
<td align="left">布局</td>
</tr>
<tr>
<td align="left">head, header</td>
<td align="left">页头部分</td>
</tr>
<tr>
<td align="left">foot, footer</td>
<td align="left">页脚部分</td>
</tr>
<tr>
<td align="left">nav</td>
<td align="left">主导航</td>
</tr>
<tr>
<td align="left">subnav</td>
<td align="left">二级导航</td>
</tr>
<tr>
<td align="left">menu</td>
<td align="left">菜单</td>
</tr>
<tr>
<td align="left">submenu</td>
<td align="left">子菜单</td>
</tr>
<tr>
<td align="left">sideBar</td>
<td align="left">侧栏</td>
</tr>
<tr>
<td align="left">sidebar_a, sidebar_b</td>
<td align="left">左边栏或右边栏</td>
</tr>
<tr>
<td align="left">main</td>
<td align="left">页面主体</td>
</tr>
<tr>
<td align="left">tag</td>
<td align="left">标签</td>
</tr>
<tr>
<td align="left">msg message</td>
<td align="left">提示信息</td>
</tr>
<tr>
<td align="left">tips</td>
<td align="left">小技巧</td>
</tr>
<tr>
<td align="left">vote</td>
<td align="left">投票</td>
</tr>
<tr>
<td align="left">friendlink</td>
<td align="left">友情连接</td>
</tr>
<tr>
<td align="left">title</td>
<td align="left">标题</td>
</tr>
<tr>
<td align="left">summary</td>
<td align="left">摘要</td>
</tr>
<tr>
<td align="left">loginbar</td>
<td align="left">登录条</td>
</tr>
<tr>
<td align="left">searchInput</td>
<td align="left">搜索输入框</td>
</tr>
<tr>
<td align="left">hot</td>
<td align="left">热门热点</td>
</tr>
<tr>
<td align="left">search</td>
<td align="left">搜索</td>
</tr>
<tr>
<td align="left">search_output</td>
<td align="left">搜索输出和搜索结果相似</td>
</tr>
<tr>
<td align="left">searchBar</td>
<td align="left">搜索条</td>
</tr>
<tr>
<td align="left">search_results</td>
<td align="left">搜索结果</td>
</tr>
<tr>
<td align="left">copyright</td>
<td align="left">版权信息</td>
</tr>
<tr>
<td align="left">branding</td>
<td align="left">商标</td>
</tr>
<tr>
<td align="left">logo</td>
<td align="left">网站LOGO标志</td>
</tr>
<tr>
<td align="left">siteinfo</td>
<td align="left">网站信息</td>
</tr>
<tr>
<td align="left">siteinfoLegal</td>
<td align="left">法律声明</td>
</tr>
<tr>
<td align="left">siteinfoCredits</td>
<td align="left">信誉</td>
</tr>
<tr>
<td align="left">joinus</td>
<td align="left">加入我们</td>
</tr>
<tr>
<td align="left">partner</td>
<td align="left">合作伙伴</td>
</tr>
<tr>
<td align="left">service</td>
<td align="left">服务</td>
</tr>
<tr>
<td align="left">regsiter</td>
<td align="left">注册</td>
</tr>
<tr>
<td align="left">arr/arrow</td>
<td align="left">箭头</td>
</tr>
<tr>
<td align="left">guild</td>
<td align="left">指南</td>
</tr>
<tr>
<td align="left">sitemap</td>
<td align="left">网站地图</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left">列表</td>
</tr>
<tr>
<td align="left">homepage</td>
<td align="left">首页</td>
</tr>
<tr>
<td align="left">subpage</td>
<td align="left">二级页面子页面</td>
</tr>
<tr>
<td align="left">tool, toolbar</td>
<td align="left">工具条</td>
</tr>
<tr>
<td align="left">drop</td>
<td align="left">下拉</td>
</tr>
<tr>
<td align="left">dorpmenu</td>
<td align="left">下拉菜单</td>
</tr>
<tr>
<td align="left">status</td>
<td align="left">状态</td>
</tr>
<tr>
<td align="left">scroll</td>
<td align="left">滚动</td>
</tr>
<tr>
<td align="left">.tab</td>
<td align="left">标签页</td>
</tr>
<tr>
<td align="left">.left .right .center</td>
<td align="left">居左、中、右</td>
</tr>
<tr>
<td align="left">.news</td>
<td align="left">新闻</td>
</tr>
<tr>
<td align="left">.download</td>
<td align="left">下载</td>
</tr>
<tr>
<td align="left">.banner</td>
<td align="left">广告条(顶部广告条)</td>
</tr>
</tbody></table>
<h4 id="其他DIV命名规则"><a href="#其他DIV命名规则" class="headerlink" title="其他DIV命名规则"></a>其他DIV命名规则</h4><p>　　登录条:loginBar</p>
<p>　　标志:logo</p>
<p>　　侧栏:sideBar</p>
<p>　　广告:banner</p>
<p>　　导航:nav</p>
<p>　　子导航:subNav</p>
<p>　　菜单:menu</p>
<p>　　子菜单:subMenu</p>
<p>　　搜索:search</p>
<p>　　滚动:scroll</p>
<p>　　页面主体:main</p>
<p>　　内容:content</p>
<p>　　标签页:tab</p>
<p>　　文章列表:list</p>
<p>　　提示信息:msg</p>
<p>　　小技巧:tips</p>
<p>　　栏目标题:title</p>
<p>　　友情链接:friendLink</p>
<p>　　页脚:footer</p>
<p>　　加入:joinus</p>
<p>　　指南:guild</p>
<p>　　服务:service</p>
<p>　　热点:hot</p>
<p>　　新闻:news</p>
<p>　　下载:download</p>
<p>　　注册:regsiter</p>
<p>　　状态:status</p>
<p>　　按钮:btn</p>
<p>　　投票:vote</p>
<p>　　合作伙伴:partner</p>
<p>　　版权:copyRight</p>
<h3 id="2-选择器"><a href="#2-选择器" class="headerlink" title="2. 选择器"></a>2. 选择器</h3><h4 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h4><p>选择器按作用大小（从小到大）分为  <code>ID选择器(使用井字符做特殊标注：#)</code> 、<code>类选择器（使用英文点号做特殊标注：.）</code> 、 <code>标签选择器</code> 及 <code>通配符选择器（使用英文星号做特殊标注：*）</code>。</p>
<p>CCS 选择器的作用：选择器是为了选定标签，声明对象设置具体样式</p>
<table>
<thead>
<tr>
<th>选择器类型</th>
<th>选择器特性</th>
<th>style书写方式</th>
<th>style应用方式</th>
</tr>
</thead>
<tbody><tr>
<td>ID选择器</td>
<td>1. 与其他选择器类型一致，特殊之处是大部分情况作JavaScript调用<br/>2. 需要编写唯一id不可重复使用</td>
<td>#DivStyle { color: red; }</td>
<td>id=”DivStyle”</td>
</tr>
<tr>
<td>类选择器</td>
<td>1. 作用于使用class属性的一类标签，同面向对象的其他语言特性一致<br/>2. 单个标签可以使用多个类，中间以空格隔开</td>
<td>.ClassStyle { color: black;}</td>
<td>Class=”ClassStyle …..”</td>
</tr>
<tr>
<td>标签选择器</td>
<td>作用于所有使用本标签的标签</td>
<td>div { color: blue; }</td>
<td>/</td>
</tr>
<tr>
<td>通配符选择器</td>
<td>作用于所有标签</td>
<td>* { clolor: pink; }</td>
<td>/</td>
</tr>
</tbody></table>
<h4 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h4><table>
<thead>
<tr>
<th>复合选择器类型</th>
<th>选择器特性</th>
<th>style书写方式</th>
</tr>
</thead>
<tbody><tr>
<td>后代选择器</td>
<td>1. 可以选择<strong>某个</strong>父标签下的<strong>某个</strong>全部子标签，不管其是否在同一个层级<br/>2. 当标签发生嵌套时，内层标签就称为外层标签的后代<br/>3. 浏览器按照标签层级的关系进行查找，并<u>对最内层标签进行修改</u>，因此可以定义多重标签选择，如可以使用基础选择器（类选择器及ID选择器）进行组合使用<br/>4. 内外层选择器之间 <mark>以空格隔开</mark></td>
<td>外层标签 内层标签 {属性}<br/>ol li { color: #000; }<br/>ol li a { color: #777; }<br/>.nav li a { color: pruple;}</td>
</tr>
<tr>
<td>子代选择器</td>
<td>1. 即与后代选择器不同，仅对父级标签下的某一类选择器进行操作，不会作用于其他子代的同类标签<br/>2. 使用符号 <code>&gt;</code> 进行操作</td>
<td>.nav&gt;a {color: pink;}</td>
</tr>
<tr>
<td>集选择器（相邻选择器）</td>
<td>1. 在两个没有从属关系（子代或后代）和相同特点（如同类标签）的同级不同类标签中，定义一个相同的样式<br/>2. 多个标签进行选择时使用英文逗号 <code>,</code> 进行并列选择<br/>3. 并集选择器内可使用 <strong>简单选择器</strong> 和 <strong>复合选择器</strong>（如 后代选择器 和 子代选择器），竖向书写选择器</td>
<td>div, p {color: pink; }</td>
</tr>
<tr>
<td>伪类选择器</td>
<td>1. 用于给某些选择器添加特殊效果（如给链接添加特殊效果），或者选择某个元素<br/>2. 结构伪类、链接伪类、表单伪类<br/>3. 伪类选择器其实更像是一个行为选择器（或状态选择器），它定义了一个/类标签在不同状态下的样式，书写形式如：<code>标签</code>: <code>状态/行为</code> <code>&#123;属性&#125;</code></td>
<td>.OnlineTitle:link {<br/>    color: #222222;<br/>    text-decoration: none;<br/>}</td>
</tr>
<tr>
<td>属性选择器（高级）</td>
<td>元素名[属性（及关键搜索项）]<br />E[att] 选择具有att属性的E元素<br />E[att=”val”] 选择ett=val的E元素<br />E[att^=”val”] 选择att属性开头为val的E元素<br />E[att$=”val”] 选择att属性结尾为val的E元素<br />E[att*=”val”] 选择att属性中包含”val”字符的E元素</td>
<td></td>
</tr>
<tr>
<td>结构伪类选择器（高级）</td>
<td>根据文档结构来选择元素，常用于父级元素里的子元素<br />E:first-child 匹配父元素中的第一个子元素E<br />E:last-child 匹父元素中的最后一个元素E<br />E:nth-child(n) 匹配父级元素中的第n个子元素E<br />E:first-of-type 指定类型E的第一个<br />E:last-of-type 指定类型E的最后一个<br />E:nth-of-type(n)指定类型E的第n个</td>
<td>n可以是<strong>正数</strong>、<strong>关键字</strong>（even偶数、odd奇数）和<strong>公式</strong><br />可以配合其他复合选择器进行选择，如子代选择器、后代选择器等。<br />在使用<code>nth-child(n)</code>后，未指定特殊数字时，将从0开始计数，直到所有子代结束，即等同于全选所有该类子代。</td>
</tr>
<tr>
<td>伪元素选择器（高级）</td>
<td>::before 在元素内部的前面插入东西<br />::after 在元素内部的后面插入东西<br /></td>
<td>所创建的元素为行内元素；<br />必须有content属性；<br /></td>
</tr>
</tbody></table>
<p>并集选择器</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">如要求将下方熊大、熊二及佩奇一家都改为粉色，则按照&lt;style&gt;中的方式进行书写</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">            //在两个没有从属关系（子代或后代）和相同特点（如同类标签）的同级不同类标签中，定义一个相同的样式</span><br><span class="line"><span class="css">            <span class="selector-tag">div</span>,</span></span><br><span class="line"><span class="css">            <span class="selector-tag">p</span>,</span></span><br><span class="line"><span class="css">            <span class="selector-class">.pig</span> <span class="selector-tag">li</span> &#123;                //类选择器</span></span><br><span class="line"><span class="css">                <span class="attribute">color</span>: pink;</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>熊大<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>熊二<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>关头强<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;pig&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>PIG 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>PIG 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>PIG 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>链接伪类选择器</strong></p>
<p>四个使用方式: link / visited / hover / active</p>
<ol>
<li>为了确保生效，应按照LVHA的顺序进行声明。</li>
<li><code>&lt;a&gt;</code> 链接在浏览器中具有默认样式，不会因为在<code>&lt;body&gt;</code>中而随之改变，实际工作中需要给链接单独指定样式。</li>
<li>使用时，加上冒号 <code>:</code> 与 四种<code>状态</code>之一 即可</li>
</ol>
<p>举例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="attribute">background-color</span>:yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当鼠标经过父级元素时，显示子元素的遮罩层：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tudou</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.mask</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: block;      <span class="comment">/* 显示遮罩层 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>最小盒子：</strong>即只能存放文字了，不能再存放其他标签/元素，如 <code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code>等文字块级标签；</p>
<p><strong>结构伪类选择器</strong></p>
<p><code>nth-child()</code>在执行时会先把所有子元素都进行排序，先看<code>nth-child()</code>括号中的数字，再匹配前方的标签是否与实际标签一致，如果不一致则不执行。</p>
<p><code>nth-of-type()</code>在执行时会先把指定类型的子元素都进行排序，先看<code>nth-of-type()</code>括号中的数字，再匹配查找到具体的标签。</p>
<p>CSS中使用伪类选择器，根据结构顺序精确选择标签：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span>:<span class="built_in">nth-chile</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  color: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HTML结构如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>自增长序列，n是从0开始的，按照公式从0开始计算，所得结果为选择器选择的行数。</p>
<table>
<thead>
<tr>
<th>公式</th>
<th>取值</th>
</tr>
</thead>
<tbody><tr>
<td>2n</td>
<td>偶数</td>
</tr>
<tr>
<td>2n+1</td>
<td>奇数</td>
</tr>
<tr>
<td>5n</td>
<td>5、10、15…</td>
</tr>
<tr>
<td>n+5</td>
<td>从第5个开始（包含第5个）直到最后</td>
</tr>
<tr>
<td>-n+5</td>
<td>前5个（包含第5个）</td>
</tr>
</tbody></table>
<h4 id="元素显示模式"><a href="#元素显示模式" class="headerlink" title="元素显示模式"></a>元素显示模式</h4><p>是指在页面上的元素以 <strong>块状模式</strong> 、 <strong>行内模式</strong> 或 <strong>行内块模式</strong> 进行显示。元素按显示模式可以分为 <strong>块状（级）元素</strong> 及 <strong>行内元素（内联元素）</strong> 及 <strong>行内块元素</strong> 三种类型。</p>
<table>
<thead>
<tr>
<th>元素类型</th>
<th>典型标签</th>
<th>特点</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>块状元素</td>
<td><code>&lt;h1&gt;</code>~`<h6><code>、</code><p><code>、 </code><div> <code>、</code><ul> <code>、</code><ol><code>、</code> <li>`……</td>
<td>1. 即使设置标签宽度，也是独占一行<br/>2. 高、宽、外边距及内边距可调节<br/>3. 默认宽度是父级宽度的100%<br/>4. 是一个容器及盒子，可以放任何标签</td>
<td>文字类的标签内不可以存放块元素</td>
</tr>
<tr>
<td>行内元素（内联元素）</td>
<td><code>&lt;a&gt;</code>、 <code>&lt;strong&gt;</code>、<code>&lt;b&gt;</code>、 <code>&lt;em&gt;</code>、<code>&lt;i&gt;</code> ……</td>
<td>1. 相邻行内元素在一行上，一行可以显示多个<br/>2. 直接设置宽高无效，可以间接设置<br/>3. 默认宽度就是其内容宽度<br/>4. 行内元素只能容纳文本及其他行内元素</td>
<td>1. 链接中不允许再放其他链接<br/>2. <code>&lt;a&gt;</code>中可以放置块元素，但是转换成块级元素最安全</td>
</tr>
<tr>
<td>行内块元素</td>
<td><code>&lt;input&gt;</code>、 <code>&lt;image&gt;</code>、<code>&lt;td&gt;</code>……</td>
<td>1. 同时具有块元素及行内元素的特定<br/>2. 和相邻行内元素（行内块）在一行上，但是有空白缝隙，可以一行显示多个<br/>3. 默认宽度即内容宽度<br/>4. 高度、行高、外边距及内边距可控制</td>
<td></td>
</tr>
</tbody></table>
<p><strong>元素显示模式的转换</strong></p>
<p>即一个模式的元素需要另一个模式的特性，可以通过在CSS的标签样式属性中添加display语句进行转换。</p>
<p>转换为块级元素： <em><code>display: block;</code></em> </p>
<p>转换为行内元素： <em><code>display: inline;</code></em> </p>
<p>转换为行内块元素： <em><code>display: inline-block;</code></em> </p>
<h4 id="选择器特性"><a href="#选择器特性" class="headerlink" title="选择器特性"></a>选择器特性</h4><p>层叠性、继承性、优先性</p>
<p><strong>层叠性</strong></p>
<blockquote>
<p>样式冲突，就近原则</p>
</blockquote>
<p><strong>继承性</strong></p>
<blockquote>
<p>子标签会继承父标签的某些样式</p>
<p>子元素可以继承父元素的样式（text-，font-，line-这些元素开头的可以继承，以及color属性</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>:pink;</span></span><br><span class="line"><span class="css">        <span class="attribute">font</span>:<span class="number">25px</span>/<span class="number">1.5</span> <span class="string">&#x27;Microsoft YaHei&#x27;</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">font</span>:<span class="number">14px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css"><span class="comment">/*此时div会继承body中1.5倍的行高，此时div中的行高就是14*1.5=21px*/</span></span></span><br><span class="line">    行高可以跟单位也可以不跟单位</span><br><span class="line">    如果子元素没有设置行高，则会继承父元素行高为1.5</span><br><span class="line">    此时子元素的行高是：当前子元素的文字大小*1.5</span><br><span class="line"><span class="css">    <span class="selector-tag">body</span>行高<span class="number">1.5</span>这样写法最大的优势就是里面子元素可以根据自己文字大小自动调整行高</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>优先性（权重）</strong></p>
<table>
<thead>
<tr>
<th>选择器类型</th>
<th>权重</th>
</tr>
</thead>
<tbody><tr>
<td>继承</td>
<td>无</td>
</tr>
<tr>
<td>通配符选择器、子代选择器、相邻选择器（并集选择器）</td>
<td>0,0,0,0</td>
</tr>
<tr>
<td>元素选择器（标签选择器）、伪元素选择器</td>
<td>0,0,0,1</td>
</tr>
<tr>
<td>类选择器、伪类选择器、属性选择器</td>
<td>0,0,1,0</td>
</tr>
<tr>
<td>ID选择器</td>
<td>0,1,0,0</td>
</tr>
<tr>
<td>内联选择器</td>
<td>1,0,0,0</td>
</tr>
<tr>
<td>!IMPORTANT</td>
<td>无限</td>
</tr>
</tbody></table>
<p>选择器的加权结果并非二进制，而是在各个数位上进行单独相加，例如元素选择器与类选择器的加权结果为 <code>0,0,1,1</code>，左侧数位的数值越大，权重越高。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">		<span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">			<span class="attribute">color</span>: red;</span></span><br><span class="line">		&#125;</span><br><span class="line">		.colour &#123;</span><br><span class="line"><span class="css">			<span class="attribute">color</span>: green;</span></span><br><span class="line">		&#125;</span><br><span class="line">		#demo &#123;</span><br><span class="line"><span class="css">			<span class="attribute">color</span>: burlywood;</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">			<span class="attribute">color</span>: <span class="number">#008000</span>;</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;colour&quot;</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: #4682B4;&quot;</span>&gt;</span></span><br><span class="line">		不爱绿色爱蓝色</span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			继承的权重为0</span><br><span class="line">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">/*此时p是继承不到父级的设定* 所以看标签到底执行哪个样式，就先看这个标签有没有直接被选出来/</span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div style="color: red; font-weight: 800;">继承的权重是0，如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是0。</div>



<h3 id="3-List"><a href="#3-List" class="headerlink" title="3. List"></a>3. List</h3><p><code>list-style</code> CSS 属性是一个简写对属性集合，包括<code>list-style-type</code>, <code>list-style-image,</code> 和 <code>list-style-position</code>。</p>
<p><code>list-style: none | circle | square inside ;</code>表示<code>&lt;ul&gt;</code> 下 <code>&lt;li&gt;</code> 前的小点样式，如“无、圆圈、实心方形”。</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>List Item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>List Item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>List Item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">List 2</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>List Item A<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>List Item B<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>List Item C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>及</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: circle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: square inside;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="4-Background"><a href="#4-Background" class="headerlink" title="4. Background"></a>4. Background</h3><p><code>background-color</code> 可以设置为 <code>transparent</code>，即透明的，不可视的。</p>
<p><code>background-image</code> 可以设置为 <code>none</code>，也可以跟上一个 <code>url()</code> 链接。如：<code>background-image: url(http://xxxxxx.com/123.jpg)</code></p>
<p><code>background-repeat: repeat | no-repea | repeat-x | repeat-y</code> ，分别是指 重复（平铺）、不平铺、在x轴上平铺 及 在y轴上平铺 。</p>
<p><code>background-position: top | bottom | left | right | center;</code> 除了可以使用类似于左侧的方位词定位，还可以使用坐标轴数值定位。</p>
<p><code>background: [image] [repeat] [position];</code> 是复合写法，<code>repeat</code> 和 <code>position</code> 可省略，<code>image</code> 不可省略。</p>
<h3 id="5-Font"><a href="#5-Font" class="headerlink" title="5. Font"></a>5. Font</h3><p><strong>FONT-FAMILY 字体族</strong></p>
<p>通用属性之一，用于设置网页显示字体，font-family的使用方式为 <code>font-family=&quot; &quot;</code> ，双引号内可以书写多个字体，引擎会按顺序搜索本地字体并使用，如果都没有则使用本地字体。</p>
<p><strong>注意：</strong>建议使用字体的全英文进行书写，如 <strong>微软雅黑</strong> 全英文为 <strong>Microsoft YaHei</strong>，英文书写时有空格的应用单引号<code>‘’</code> 进行包裹。</p>
<p><strong>FONT-SIZE 字体大小</strong></p>
<p>通常用于对body标签内所有正文字体大小的设置，对标题（如<code>h3</code>）大小的设置仍需另起样式。</p>
<p><strong>复合写法</strong></p>
<p><code>font: font-style font-weight font-size/line-height font-family;</code></p>
<p><code>font-size</code> 和 <code>font-family</code> 不可缺省</p>
<h3 id="6-Text"><a href="#6-Text" class="headerlink" title="6. Text"></a>6. Text</h3><p><strong>文本属性</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>书写方式</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>color<br/>颜色</td>
<td>1. 常见英文表示法，直接书写该颜色英文即可，如 pink \ red \ blue \ purple<br/>2. 16进制表示法，用#号进行书写，如#FF00FF<br/>3. RGB表示法，如rgb(0,0,255)</td>
<td>16进制简写为#fff<br/>实际开发中用16进制</td>
</tr>
<tr>
<td>text-align<br/>文本对齐</td>
<td>仅有左、中、右三种表示方式，用英文 left \ center \ right 进行书写</td>
<td></td>
</tr>
<tr>
<td>text-indent<br/>文本缩进</td>
<td>缩进可以用2种方式表示：<br/>1. 精准缩进：即直接使用 <code>px</code> 单位进行书写，表示缩进多少像素点，缺点是容易出现问题<br/>2. 字符单位缩进：即按照字符大小，自适应缩进字符距离，单位是em，如 <code>2em</code>，可以缩进2个字符</td>
<td></td>
</tr>
<tr>
<td>text-decoration<br/>文本修饰</td>
<td>常见的修饰类型有四种：无（none）、上划线（overline）、下划线（underline）、删除线（line-through）</td>
<td></td>
</tr>
<tr>
<td>line-height</td>
<td>行高=上行距+下行距+字高，且上行距=下行距</td>
<td></td>
</tr>
</tbody></table>
<h3 id="7-Box-Module"><a href="#7-Box-Module" class="headerlink" title="7. Box Module"></a>7. Box Module</h3><p>盒子模型主要分三部分：<strong>border</strong>（边框）、<strong>padding</strong>（内边距）及 <strong>margin</strong>（外边距）。</p>
<h4 id="Border"><a href="#Border" class="headerlink" title="Border"></a>Border</h4><p>边框主要有一下三种参数：粗细、颜色及样式</p>
<ul>
<li>粗细(<code>border-width: 5px;</code>)</li>
<li>颜色(<code>boder-color: #555</code>) （<em>注意：如果这个值没有设置，它的默认值是元素的 color属性值（是文字颜色而非背景色）</em>），可以定义为<code>transparent</code>（透明的）</li>
<li>样式(<code>boder-style: none | hidden | dotted | dashed | solid | double(双层线) | groove(内雕刻) | ridge(外浮雕) | inset(内凹陷) | outset(外凹陷) ;</code>) </li>
</ul>
<p>border属性之可以在中间添加上、下、左、右四个方位词和三参数之一，如 <code>border-top-color</code> | <code>border-bottom-style</code> ….</p>
<p>边框使用时会影响盒子大小，需要注意调整。</p>
<p><strong>复合写法</strong> </p>
<p><code>border: [border-width ||border-style ||border-color |inherit] ;</code></p>
<p>如：<code>border: 10px solid transparent;</code></p>
<h4 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h4><p>内边距涉及到的参数包括 上下左右四边的边距。</p>
<p>在未设置内盒子的width时，设置padding对内盒子实际显示大小不起影响，一旦设置width，则会让盒子的width在显示时超过设置参数的大小。</p>
<h4 id="Margin"><a href="#Margin" class="headerlink" title="Margin"></a>Margin</h4><p>外边距同内边距。</p>
<p>在标准流下，设置块级盒子width参数后，设置margin左右为auto，可以让盒子实现居中效果。（以下三种写法，推荐第一个，第一个参数表示上下，第二个参数表示左右）</p>
<p><code>margin: 0 auto;</code></p>
<p><code>margin: auto;</code></p>
<p><code>margin-left: auto; margin-right: auto;</code></p>
<h4 id="Q-A"><a href="#Q-A" class="headerlink" title="Q/A"></a>Q/A</h4><p><strong>盒子塌陷的解决方案</strong></p>
<p>以下为两个盒子嵌套，同时设置上边距导致塌陷问题的解决方案：</p>
<ul>
<li>可以为父元素定义上边框/上内边距</li>
<li>可以为父元素添加 <code>overflow: hidden;</code></li>
<li>利用浮动、固定、绝对定位解决</li>
</ul>
<h3 id="8-Float"><a href="#8-Float" class="headerlink" title="8. Float"></a>8. Float</h3><p>浮动最初的开发目的是让图片和文字产生环绕效果的，浮动可以让多个块级元素在一行内显示。</p>
<p><code>float: none | left | right;</code></p>
<p><strong>注意：</strong>两个行内块元素中间会有空白间隙存在，如果父级元素设定了宽度，会让元素存放不下。需要给此类行内块元素设定浮动</p>
<p><strong>浮动特性：</strong></p>
<ul>
<li><p>脱标</p>
</li>
<li><p>顶端对齐</p>
</li>
<li><p>具有行内块元素特性</p>
</li>
</ul>
<p><strong>外边距合并</strong></p>
<blockquote>
<p>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p>
</blockquote>
<p><strong>注释：</strong>只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。</p>
<p>在标准流中嵌套一个带有外边距的浮动框，不会让他们产生外边距合并。</p>
<h3 id="9-Clean-Float"><a href="#9-Clean-Float" class="headerlink" title="9. Clean Float"></a>9. Clean Float</h3><p>清除浮动也叫闭合浮动，是指在未指定父级元素高度而子级元素为浮动时，会对父级元素同级的标准流造成影响，因而需要清除该类浮动造成的弊端的情况。</p>
<p>清除浮动的四种方式：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>写法</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>额外标签</td>
<td>[w3c推荐]也称隔墙法，指在浮动的块（行内块）级元素后面新增一个带有<code>clear: both;</code>属性的额外标签（要求是块级元素）来屏蔽浮动的影响。</td>
<td><code>clear: both;</code></td>
<td>弊端是增加了额外标签，对H5结构造成负担；<br/>要求新增的标签不能是行内元素</td>
</tr>
<tr>
<td>父级添加overflow</td>
<td>仅给父级元素添加overflow，添加hidden、auto、scroll皆可。</td>
<td>`overflow: hidden</td>
<td>auto</td>
</tr>
<tr>
<td>:after伪元素</td>
<td>额外标签法的升级版，利用CSS样式添加额外标签<br/>仅给父级元素添加</td>
<td>见下方</td>
<td>没有增加额外标签，样式写法较为复杂；</td>
</tr>
<tr>
<td>双伪元素</td>
<td>在子级前后各添加一个伪元素</td>
<td>见下方</td>
<td>代码简洁，照顾低版本。</td>
</tr>
</tbody></table>
<p><strong>:after伪元素代码示例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:after &#123;</span><br><span class="line">	content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="attribute">display</span>: block;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">clear</span>: both;</span><br><span class="line">	<span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;       <span class="comment">/* IE6、7专有 */</span></span><br><span class="line">	*zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><strong>双伪元素代码示例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:before, .clearfix:after&#123;</span><br><span class="line">	content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span>:after&#123;</span><br><span class="line">	clear: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">	*zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="10-Position"><a href="#10-Position" class="headerlink" title="10. Position"></a>10. Position</h3><h4 id="定位的意义"><a href="#定位的意义" class="headerlink" title="定位的意义"></a>定位的意义</h4><p>让盒子自由地在某个盒子中移动或固定在屏幕中的某个位置，并且可以压住其他盒子。</p>
<p><strong>注意：</strong>对于标准流和浮动，不可以使用定位。</p>
<h4 id="定位模式"><a href="#定位模式" class="headerlink" title="定位模式"></a>定位模式</h4><p><code>position: static | relative | absolute | fixed ;</code></p>
<table>
<thead>
<tr>
<th>定位分类</th>
<th>脱标</th>
<th>使用情况</th>
<th>参考系</th>
<th>其他特点</th>
</tr>
</thead>
<tbody><tr>
<td>静态定位 <code>static</code></td>
<td>否，不能使用边偏移</td>
<td>很少</td>
<td>无，不设置边偏移</td>
<td>按照标准流特性摆放位置</td>
</tr>
<tr>
<td>相对定位 <code>relative</code></td>
<td>否，占用标准流的位置</td>
<td>常用</td>
<td>自身原来的位置</td>
<td>相对于自身原来的位置来移动<br/>设置相对定位后，后面的标准流<strong>不会脱标</strong>，不会让身后的标准流往前挤或往后挤；<br/>通常是给绝对定位当父级元素的属性</td>
</tr>
<tr>
<td>绝对定位 <code>absolute</code></td>
<td>是，不占用标准流的位置</td>
<td>常用</td>
<td>最近一级父级以上带有定位的盒子（子绝父相）</td>
<td>如果没有已定位的父级元素，则以浏览器进行绝对定位</td>
</tr>
<tr>
<td>固定定位 <code>fixed</code></td>
<td>是，不占用标准流的位置</td>
<td>常用</td>
<td>浏览器的可视窗口</td>
<td>与父级元素无关，不随窗口滚动条滚动<br/></td>
</tr>
<tr>
<td>粘性定位 <code>sticky</code></td>
<td>否，占用标准流的位置</td>
<td>很少</td>
<td>浏览器的可视窗口</td>
<td>相对定位和固定定位的混合体，具有两者的某些特点<br/>必须添加至少一个边偏移参数<br/>需与滚动搭配使用，对IE兼容性差，类似粘性定位的做法通常用JavaScript来做</td>
</tr>
</tbody></table>
<h4 id="边偏移"><a href="#边偏移" class="headerlink" title="边偏移"></a>边偏移</h4><p>相对于父级盒子（或者有定位的祖辈盒子）的边线偏移量（偏移量可以为负值）。</p>
<p>需要在设置好定位模式后边偏移才能生效。</p>
<p><strong>四种偏移：</strong>top、bottom、right、left；</p>
<p><strong>例：</strong><code>top: 10px; right: 20px;</code></p>
<p><strong>如何将内容固定到版心右侧？</strong></p>
<p>使用固定定位至左侧的50%，在调整<code>margin-left</code>值至版心宽度的一般（直接书写数值px）。</p>
<p><strong>如何让内容固定到屏幕正中心？</strong></p>
<p>使用固定定位至左侧和顶部的50%，再使用<code>margin-left</code>和<code>margin-right</code>的负值来抵消自身宽高的一半。</p>
<h4 id="定位显示优先级"><a href="#定位显示优先级" class="headerlink" title="定位显示优先级"></a>定位显示优先级</h4><p>定位显示优先级，即定位叠放顺序，是指 <strong>具有定位属性的盒子</strong>（类似于PS图层）在Z轴上的显示优先级，数值越大则优先级越高。</p>
<p>如果设置为<code>auto</code>，则按照H5结构书写顺序以“后来居上”的原则显示。</p>
<p>如果设置为数值，则比auto优先级更高，但是不能写单位。</p>
<p><code>z-index: (number) | auto;</code></p>
<h4 id="定位的特殊性质"><a href="#定位的特殊性质" class="headerlink" title="定位的特殊性质"></a>定位的特殊性质</h4><ul>
<li>给行内元素添加绝对或者固定定位后，可以设置宽度和高度（不等同于与块级元素互换特性？）</li>
<li>给块级元素添加绝对或者固定宽度后，不设置宽高也可以则应用内容的大小</li>
</ul>
<h3 id="11-显示与隐藏"><a href="#11-显示与隐藏" class="headerlink" title="11. 显示与隐藏"></a>11. 显示与隐藏</h3><p>显示与隐藏的三种方式：display（显示隐藏）、visibility（显示隐藏）、overflow （溢出显示隐藏）</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>用法</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>display（显示隐藏）</td>
<td>该属性本来是设置元素如何显示的；<br /><code>display: none;</code> 用于隐藏对象；<br /><code>display: block;</code> 除了用于转换成块级元素，还可以用于显示元素；</td>
<td>隐藏元素后，不再占有其原位置；<br />应用广泛，搭配js做网页特效用；</td>
</tr>
<tr>
<td>visibility（显示隐藏）</td>
<td>用于设置元素的可见性；<br />`visibility: visible</td>
<td>hidden</td>
</tr>
<tr>
<td>overflow （溢出显示隐藏）</td>
<td>仅针对溢出元素框的部分进行显示或隐藏；<br /><code>overflow: visible;</code> 设置时<code>clip</code>属性设置将失效；<br /><code>overflow: hidden;</code> 不显示超过对象尺寸的内容；<br /><code>overflow: scroll;</code> 以滚动条形式显示，不管是否内容是否溢出；<br /><code>overflow: auto; </code> 自动判断内容长度，按需添加滚动条；</td>
<td>如果带有定位属性，应慎用 <code>overflow: hidden;</code> ，会隐藏多余的部分</td>
</tr>
</tbody></table>
<h3 id="12-布局"><a href="#12-布局" class="headerlink" title="12. 布局"></a>12. 布局</h3><h4 id="常见的布局形式"><a href="#常见的布局形式" class="headerlink" title="常见的布局形式"></a>常见的布局形式</h4><p><strong>传统布局方式：</strong>普通流（文档流、标准流）、浮动、定位。</p>
<p><strong>通栏：</strong>是指和浏览器一样宽。</p>
<p><strong>布局设计准则：</strong></p>
<ul>
<li><p>纵向块级元素用标准流，横向块级元素用浮动。</p>
</li>
<li><p>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置，复合网页布局第一准则。</p>
</li>
<li><p>浮动的盒子只会影响浮动盒子后方的标准流，不影响前方的标准流。</p>
</li>
<li><p>应首先采用“一浮全浮”设计原则。</p>
</li>
<li><p>在产品列表数量众多、文字数量众多等不能明确盒子高度的情况下不应指定父级盒子的高度， 否则会出现父级盒子因高度限制而出现子元素无法显示的情况，应让子元素撑开父元素。</p>
</li>
<li><p>当给父元素设置标准流却未设置高度，而子元素为浮动时，父元素会高度塌陷。因浮动的子元素不占有高度，因此子元素浮动会会导致无高度的标准流父级元素高度塌陷，影响后续布局。</p>
</li>
</ul>
<h4 id="CSS属性书写建议"><a href="#CSS属性书写建议" class="headerlink" title="CSS属性书写建议"></a>CSS属性书写建议</h4><ol>
<li>布局定位属性：display / position / float / clear / visibility / overflow (建议display第一个写)</li>
<li>自身属性：width / height / margin / padding / border / background</li>
<li>文本属性：color / font / text-decoration / text-align / vertical-align / white-space / break-word</li>
<li>其他属性：content / cursor / border-radius / box-shadow / text-shadow / background:liner-gradient ….</li>
</ol>
<h4 id="页面布局的整体思路"><a href="#页面布局的整体思路" class="headerlink" title="页面布局的整体思路"></a>页面布局的整体思路</h4><ol>
<li>确定版心，即可视区</li>
<li>分析行、块 以及 块中的列模块</li>
<li>列模块经常浮动布局，确定列大小后确定列的位置</li>
<li>先结构，后样式</li>
</ol>
<h4 id="关于导航栏"><a href="#关于导航栏" class="headerlink" title="关于导航栏"></a>关于导航栏</h4><p>实际开发中，不会直接只用<code>&lt;a&gt;</code>来制作导航栏，而是用<code>&lt;li&gt;</code>包含链接的<code>&lt;li&gt;</code>+<code>&lt;a&gt;</code>来制作。</p>
<p><code>&lt;li&gt;</code>+<code>&lt;a&gt;</code>语义更加清晰，更为有条理的列表型内容。如果直接用<code>&lt;a&gt;</code>，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字存在被搜索引擎降权的风险），从而影响网站排名。</p>
<h3 id="13-特殊符号"><a href="#13-特殊符号" class="headerlink" title="13. 特殊符号"></a>13. 特殊符号</h3><p>小于号 &lt; <code>&amp;lt;</code></p>
<p>大于号 &gt; <code>&amp;gt;</code></p>
<h2 id="CSS高级知识"><a href="#CSS高级知识" class="headerlink" title="CSS高级知识"></a>CSS高级知识</h2><p>目标：</p>
<ul>
<li><p>能够使用精灵图</p>
</li>
<li><p>能够使用字体图标</p>
</li>
<li><p>能够写出CSS三角</p>
</li>
<li><p>能够写出常见的CSS用户界面样式</p>
</li>
<li><p>能够说出常见的布局技巧</p>
</li>
</ul>
<h3 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h3><p>CSS精灵技术的目的：减少客户端向服务器的请求次数，减小服务器的压力，提高网页的加载速度。</p>
<p>使用专用的位置测量工具，如Firework、photoshop或者其他专业工具，可以精确测量精灵图中的小图坐标，设定好盒子大小，使用专业工具测量的图片位置取负值进行平移定位。</p>
<p>建议使用position复合写法进行书写，如 <code>position: url(images/abc.jpg) no-repeat -150px 120px;</code> 。</p>
<p><strong>缺点：</strong></p>
<ol>
<li>图片文件较大</li>
<li>放大或缩小导致失真</li>
<li>制作完毕后更换图片复杂</li>
</ol>
<h3 id="Icon-Font"><a href="#Icon-Font" class="headerlink" title="Icon Font"></a>Icon Font</h3><p><strong>优点：</strong></p>
<ol>
<li>轻量级：字体加载时，字体图标就会马上渲染出来，减少了服务器的请求。</li>
<li>灵活性：本质是文字，具有font相关的所有特性。</li>
<li>兼容性：几乎支持所有浏览器。</li>
</ol>
<p><strong>适用场景：</strong>结构和样式较为简单的图标。</p>
<p><strong>缺点：</strong>不能胜任复杂的结构和样式。</p>
<p><strong>字体图标下载网站：</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="http://icomoon.io/">icomoon字库</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iconfont.cn/">阿里iconfont</a></li>
</ol>
<p><strong>四种字体文件格式：</strong></p>
<table>
<thead>
<tr>
<th>字体格式</th>
<th>兼容性</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>.ttf</td>
<td>最高</td>
<td>win及mac最常见字体格式</td>
</tr>
<tr>
<td>.woff</td>
<td>一般</td>
<td></td>
</tr>
<tr>
<td>.eot</td>
<td>低</td>
<td>IE专用字体，支持IE4+</td>
</tr>
<tr>
<td>.svg</td>
<td>较低</td>
<td></td>
</tr>
</tbody></table>
<p><strong>使用教程：</strong></p>
<ol>
<li>字体文件下载完毕之后，会有四种格式的字体文件（请勿删除任一文件）。</li>
<li>所有的图标字体复制粘贴到资源管理器下即可。</li>
<li>在效果预览中复制该图标字体，并粘贴至H5文件中。</li>
<li>在 <code>&lt;style&gt;</code>中添加 <code>font-face</code> 相关的属性（下载的文件包中会有相关代码可供复制粘贴）。</li>
</ol>
<p><strong>示例</strong></p>
<hr>
<p>字体声明：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Logo 字体 */</span></span><br><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;iconfont logo&quot;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;fonts/demofont.eot?t=1545807318834&#x27;</span>);</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;fonts/demofonteot?t=1545807318834#iefix&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;embedded-opentype&#x27;</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&#x27;fonts/demofont.woff?t=1545807318834&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&#x27;fonts/demofont.ttf?t=1545807318834&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&#x27;fonts/demofont.svg?t=1545807318834#iconfont&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;svg&#x27;</span>);</span><br><span class="line">  <span class="attribute">font-weight</span>: normal;</span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时需要在标签中引用<code>font-family</code>属性：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">	<span class="attribute">font-family</span>: <span class="string">&#x27;iconfont logo&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>字体追加：</strong></p>
<p>从网站上下载文件时，自带<code>.json</code>文件，里面记录了所有已选择的字体的信息，只要在网站中导入该文件，即可包含过往所选择的所有图标信息，避免选择新图标后旧图标消失。</p>
<h3 id="Triangle"><a href="#Triangle" class="headerlink" title="Triangle"></a>Triangle</h3><p>三角形，其实是在一个长宽皆为0的盒子中，利用一条border显示，其余三条boders皆透明来制作的。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">  inline-<span class="attribute">height</span>: <span class="number">0</span>;     <span class="comment">/*兼容性*/</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;         <span class="comment">/*兼容性*/</span></span><br><span class="line">	<span class="attribute">border</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line">	<span class="attribute">border-right-color</span>: <span class="built_in">rgb</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际应用中，常与另一个盒子共同包裹在一个大盒子中，使用 <code>position: absolute;</code> 和 <code>位移属性</code> 来制作气泡窗口。</p>
<h3 id="User-Interface-Style"><a href="#User-Interface-Style" class="headerlink" title="User Interface Style"></a>User Interface Style</h3><h4 id="Cursor"><a href="#Cursor" class="headerlink" title="Cursor"></a>Cursor</h4><p><code>cursor: default | pointer | move | text | not-allowed ;</code></p>
<p>分别是 <strong>箭头</strong>、<strong>手指</strong>、<strong>十字架</strong>、<strong>文本</strong>、<strong>禁止</strong> 样式。</p>
<h4 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h4><p><code>outline: 0;</code> 或者 <code>outline: none;</code>可取消表单轮廓线。</p>
<h4 id="Resize"><a href="#Resize" class="headerlink" title="Resize"></a>Resize</h4><p><code>resize: none;</code> 可以设置让 <code>&lt;textarea&gt;</code> 不能随意拖动。</p>
<h4 id="Vertical-align"><a href="#Vertical-align" class="headerlink" title="Vertical-align"></a>Vertical-align</h4><p><code>vertical-align: baseline | top | middle | bottom;</code></p>
<p>分别可以实现 <strong>父元素基线对齐</strong>、<strong>（与最高元素的）顶端对齐</strong>、<strong>父元素中部对齐</strong>、<strong>（与最低元素的）的顶端对齐</strong>。</p>
<p><strong>注意：</strong>本属性针对行内元素或行内块元素，可以使其水平对齐，<em>对块级元素无效</em>。</p>
<p>四种线类型从高往底分别是：top line / middle line / base line / bottom line，默认情况下图片与文字是 <em>baseline align</em> 样式。</p>
<p><strong>行内块元素与（父级）块元素的底部缝隙消除？</strong></p>
<p>当在<code>&lt;div&gt;</code>中装入<code>&lt;img&gt;</code>时，<code>&lt;img&gt;</code>标签会与<code>&lt;div&gt;</code>标签的基线对齐，留下小缝隙，此时需要添加除了<em>baseline</em>以外的属性来消除缝隙。</p>
<p>也可以将行内块元素或行内元素转换为块级元素来实现，但是会有导致其他问题。</p>
<h4 id="Text-overflow"><a href="#Text-overflow" class="headerlink" title="Text-overflow"></a>Text-overflow</h4><p>单行文本省略显示</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: white;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">	<span class="attribute">white-space</span>: nowrap;       <span class="comment">/* 1. 强制一行显示 */</span></span><br><span class="line">	<span class="attribute">overflow</span>: hidden;          <span class="comment">/* 2. 隐藏溢出内容 */</span></span><br><span class="line">	<span class="attribute">text-overflow</span>: ellipsis;   <span class="comment">/* 3. 省略号代替溢出部分 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多行文本显示省略号</p>
<p>需要WebKit内核的支持，在最新的浏览器及移动端浏览器上较为兼容，IE不支持。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: white;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">	<span class="attribute">overflow</span>: hidden;               <span class="comment">/* 1. 隐藏溢出内容 */</span></span><br><span class="line">	<span class="attribute">text-overflow</span>: ellipsis;        <span class="comment">/* 2. 省略号代替溢出部分 */</span></span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;           <span class="comment">/* 3. 转换为弹性伸缩的盒子 */</span>      </span><br><span class="line">  -webkit-line-clamp: <span class="number">2</span>;          <span class="comment">/* 4. 设置需要显示的行数 */</span></span><br><span class="line">  -webkit-box-orient: vertical;   <span class="comment">/* 5. 设置排列方式 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Highlight"><a href="#Highlight" class="headerlink" title="Highlight"></a>Highlight</h4><p>鼠标滑过<code>&lt;div&gt;</code>时高亮显示，可以使用 <code>position: relative;</code> 或者 <code>z-index: 1;</code> 搭配其他特效 来让盒子图层置顶高亮显示。</p>
<h4 id="单个盒子内文字围绕图片效果"><a href="#单个盒子内文字围绕图片效果" class="headerlink" title="单个盒子内文字围绕图片效果"></a>单个盒子内文字围绕图片效果</h4><ul>
<li>可以在一个父级只装了文字的盒子内，放置一个浮动模块，产生文字围绕图片的效果。</li>
<li>此时文字和盒子的间距为0，显得不美观，可以为图片添加一个 <code>padding </code>属性。</li>
</ul>
<h4 id="页面导航制作"><a href="#页面导航制作" class="headerlink" title="页面导航制作"></a>页面导航制作</h4><p>使用行内块可以制作不需要添加 <code>margin</code> 属性，却有 <code>margin</code> 效果的页码导航部分。<br>所有行内块元素可以在同一列显示，且使用 <code>text-align: center;</code> 即可让所有元素居中对齐。</p>
<h4 id="梯形制作"><a href="#梯形制作" class="headerlink" title="梯形制作"></a>梯形制作</h4><p>梯形是由矩形+直角三角形获得，直角三角形获得方式如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid transparent;     <span class="comment">/* 其中一边设置为长边，且设置为透明色 */</span></span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid skyblue;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">0</span> solid blue;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">0</span> solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: transparent red transparent transparent;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">22px</span> <span class="number">8px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="CSS初始化样式"><a href="#CSS初始化样式" class="headerlink" title="CSS初始化样式"></a>CSS初始化样式</h3><p><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css/base.css&quot;&gt;</code></p>
<p>最简单的初始化方法就是： <code>* &#123;padding: 0; margin: 0;&#125; </code>。虽然通配符<code>*</code> 在编写代码的时候非常方便快捷，但如果网站和CSS样式表文件都很大，书写通配符<code>*</code>会把所有的标签都初始化一遍，加大了网站渲染的负担，延后网页加载时间。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CSS 初始化 */</span></span><br><span class="line"><span class="comment">/* 标签选择器 */</span></span><br><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">li</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">dl</span>, <span class="selector-tag">dd</span>, <span class="selector-tag">dt</span>, <span class="selector-tag">p</span>, <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>, </span><br><span class="line"><span class="selector-tag">form</span>, <span class="selector-tag">fieldset</span>, <span class="selector-tag">legend</span>, <span class="selector-tag">img</span> &#123; <span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>:<span class="number">0</span>; &#125; </span><br><span class="line"><span class="selector-tag">fieldset</span>, <span class="selector-tag">img</span>,<span class="selector-tag">input</span>,<span class="selector-tag">button</span> &#123; <span class="attribute">border</span>:none; <span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">outline-style</span>:none; &#125;</span><br><span class="line"><span class="selector-tag">ul</span>, <span class="selector-tag">ol</span> &#123; <span class="attribute">list-style</span>:none; &#125;</span><br><span class="line"><span class="selector-tag">input</span> &#123; <span class="attribute">padding-top</span>:<span class="number">0</span>; <span class="attribute">padding-bottom</span>:<span class="number">0</span>; <span class="attribute">font-family</span>: <span class="string">&quot;SimSun&quot;</span>,<span class="string">&quot;宋体&quot;</span>;&#125;</span><br><span class="line">select, <span class="selector-tag">input</span> &#123; <span class="attribute">vertical-align</span>:middle; &#125;</span><br><span class="line">select, <span class="selector-tag">input</span>, <span class="selector-tag">textarea</span> &#123; <span class="attribute">font-size</span>:<span class="number">12px</span>; <span class="attribute">margin</span>:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="selector-tag">textarea</span> &#123; <span class="attribute">resize</span>:none; &#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123;<span class="attribute">border</span>:<span class="number">0</span>;    <span class="attribute">vertical-align</span>:middle;&#125;</span><br><span class="line"><span class="selector-tag">table</span> &#123; <span class="attribute">border-collapse</span>:collapse; &#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font</span>:<span class="number">12px</span>/<span class="number">150%</span> Arial,Verdana,<span class="string">&quot;\5b8b\4f53&quot;</span>;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#666</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="number">#fff</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>:before,.clearfix:after&#123; </span><br><span class="line">    content:<span class="string">&quot;&quot;</span>; </span><br><span class="line">    <span class="attribute">display</span>:table; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.clearfix</span>:after&#123;clear:both;&#125; </span><br><span class="line"><span class="selector-class">.clearfix</span>&#123; </span><br><span class="line">    *zoom:<span class="number">1</span>;<span class="comment">/*IE/7/6*/</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-tag">a</span>&#123;<span class="attribute">color</span>:<span class="number">#666</span>; <span class="attribute">text-decoration</span>:none; &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>:<span class="number">#C81623</span>;&#125;</span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>&#123;<span class="attribute">text-decoration</span>:none;<span class="attribute">font-weight</span>:normal;&#125;</span><br><span class="line">s,<span class="selector-tag">i</span>,<span class="selector-tag">em</span>&#123;<span class="attribute">font-style</span>:normal;<span class="attribute">text-decoration</span>:none;&#125;</span><br><span class="line"><span class="selector-class">.col-red</span>&#123;<span class="attribute">color</span>: <span class="number">#C81623</span><span class="meta">!important</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 公共类选择器 */</span></span><br><span class="line"><span class="selector-class">.w</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1210px</span>;<span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fl</span> &#123;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fr</span> &#123;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:right</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.al</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span><span class="selector-pseudo">:left</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ac</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>:center</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ar</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span><span class="selector-pseudo">:right</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.hide</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="CSS公共样式"><a href="#CSS公共样式" class="headerlink" title="CSS公共样式"></a>CSS公共样式</h3><p><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css/common.css&quot;&gt;</code></p>
<h3 id="CSS3函数支持"><a href="#CSS3函数支持" class="headerlink" title="CSS3函数支持"></a>CSS3函数支持</h3><h4 id="滤镜函数"><a href="#滤镜函数" class="headerlink" title="滤镜函数"></a>滤镜函数</h4><p>**<code>filter </code>**属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。</p>
<p>CSS标准里包含了一些已实现预定义效果的函数。</p>
<p>设置一种函数，方法如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">filter</span>: &lt;filter-function&gt; [&lt;filter-function&gt;]* | none</span><br></pre></td></tr></table></figure>



<p>filter中所有的滤镜函数：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* URL to SVG filter */</span></span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">url</span>(<span class="string">&quot;filters.svg#filter-id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;filter-function&gt; values */</span></span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">5px</span>);                           <span class="comment">/*设置高斯模糊*/</span></span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">brightness</span>(<span class="number">0.4</span>);                     <span class="comment">/*设置明亮度*/</span></span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">contrast</span>(<span class="number">200%</span>);</span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">drop-shadow</span>(<span class="number">16px</span> <span class="number">16px</span> <span class="number">20px</span> blue);    <span class="comment">/**/</span></span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">50%</span>);</span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">hue-rotate</span>(<span class="number">90deg</span>);</span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">invert</span>(<span class="number">75%</span>);</span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">opacity</span>(<span class="number">25%</span>);</span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">saturate</span>(<span class="number">30%</span>);</span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">sepia</span>(<span class="number">60%</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 多种滤镜复合使用 */</span></span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">contrast</span>(<span class="number">175%</span>) <span class="built_in">brightness</span>(<span class="number">3%</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局变量 */</span></span><br><span class="line"><span class="attribute">filter</span>: inherit;</span><br><span class="line"><span class="attribute">filter</span>: initial;</span><br><span class="line"><span class="attribute">filter</span>: unset;</span><br></pre></td></tr></table></figure>



<h4 id="计算函数"><a href="#计算函数" class="headerlink" title="计算函数"></a>计算函数</h4><p><em><strong><code>calc()</code></strong></em> 函数可以在任何定义数值大小的地方进行使用，不同于代码的严格输入要求，CSS支持混合类型输入，即百分比和精确数值混合使用，如 <code>width: calc(100% - 3px)</code>; 运算符号支持 + | - | * | / 四则。</p>
<h3 id="CSS3动画效果"><a href="#CSS3动画效果" class="headerlink" title="CSS3动画效果"></a>CSS3动画效果</h3><h4 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h4><p>过渡可以为一个元素在不同状态之间切换的时候定义不同的过渡效果。比如在不同的伪元素之间切换，像是 <code>:hover</code>，<code>:active</code> 或者通过 JavaScript 实现的状态变化。</p>
<p>***<code>transition CSS</code>***属性是 <code>transition-property</code>，<code>transition-duration</code>，<code>transition-timing-function</code> 和 <code>transition-delay</code> 的一个简写属性。</p>
<p><code>transition-property</code> 可设置的参数如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 关键值 */</span></span><br><span class="line"><span class="attribute">transition-property</span>: none;</span><br><span class="line"><span class="attribute">transition-property</span>: all;</span><br><span class="line"><span class="attribute">transition-property</span>: test_05;</span><br><span class="line"><span class="attribute">transition-property</span>: -specific;</span><br><span class="line"><span class="attribute">transition-property</span>: sliding-vertically;</span><br><span class="line"></span><br><span class="line"><span class="attribute">transition-property</span>: test1;</span><br><span class="line"><span class="attribute">transition-property</span>: test1, animation4;</span><br><span class="line"><span class="attribute">transition-property</span>: all, height, all;</span><br><span class="line"><span class="attribute">transition-property</span>: all, -moz-specific, sliding;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局变量 */</span></span><br><span class="line"><span class="attribute">transition-property</span>: inherit;</span><br><span class="line"><span class="attribute">transition-property</span>: initial;</span><br><span class="line"><span class="attribute">transition-property</span>: unset;</span><br></pre></td></tr></table></figure>

















<h1 id="PART-3-JavaScript"><a href="#PART-3-JavaScript" class="headerlink" title="PART 3: JavaScript"></a>PART 3: JavaScript</h1><div style="font-style: italic; color: #999; text-align: right;">——吉财</div>

<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>1. 减少服务器交互-数据发送到服务器前验证输入，减少流量及计算量<br />2. 立即反馈给服务者-不必等待页面重载而立即判断输入是否遗漏<br />3. 交互性增强-各种悬停交互或键盘交互<br />4. 更丰富的界面-拖放组件或滑块组件使界面更丰富</td>
<td>1. 客户端的JavaScript不允许读取或写入文件，出于安全考虑<br />2. 不能用于网络应用，不支持此功能<br />3. 没有任何多线程或多处理器能力</td>
</tr>
</tbody></table>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul>
<li><code>//</code> 及随后的文本</li>
<li><code>/*</code> 及 <code>*/</code>之间的文本</li>
<li><code>&lt;!--</code> （HTML注释开始序列）被视为与 <code>//</code> 一致的单行注释</li>
<li>HTML注释结束序列 <code>--&gt;</code> 无法被识别为注释</li>
</ul>
<h4 id="非JavaScript浏览器警告"><a href="#非JavaScript浏览器警告" class="headerlink" title="非JavaScript浏览器警告"></a>非JavaScript浏览器警告</h4><p>可以使用<code>&lt;noscript&gt;</code>标记向用户显示缺少JavaScript功能警告。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;javascript&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">	&lt;!--</span><br><span class="line">	JavaScript</span><br><span class="line">	--&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">	Sorry... JavaScript is needed to go ahead.</span><br><span class="line"><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>JavaScript支持三种原始数据类型：Numbers | Strings | Boolean ; 及两种简单数据类型：Null | Undefined</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>for…in循环</p>
<p>类似于C# / Java中的用法</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="onclick事件"><a href="#onclick事件" class="headerlink" title="onclick事件"></a>onclick事件</h4><p>可以通过在HTML的标签中设置<code>onclick</code>属性，结合JavaScript定义函数来构成 <strong>鼠标单击事件</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    	<span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&quot;Hello, World!&quot;</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;sayHello()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;say Hello&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>









<h2 id="进阶知识"><a href="#进阶知识" class="headerlink" title="进阶知识"></a>进阶知识</h2><h1 id="PART-4-网站及框架"><a href="#PART-4-网站及框架" class="headerlink" title="PART 4: 网站及框架"></a>PART 4: 网站及框架</h1><div style="font-style: italic; color: #999; text-align: right;">——吉财</div>

<p>框架是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法。另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。</p>
<p>可以说，一个框架是一个可复用的设计构件，它规定了应用的体系结构，阐明了整个设计、协作构件之间的依赖关系、责任分配和控制流程，表现为一组抽象类以及其实例之间协作的方法，它为构件复用提供了上下文(Context)关系。因此构件库的大规模重用也需要框架。</p>
<p>构件领域框架方法在很大程度上借鉴了硬件技术发展的成就，它是 <strong>构件技术</strong> 、 <strong>软件体系结构研究</strong> 和 <strong>应用软件开发</strong> 三者发展结合的产物。在很多情况下，框架通常以 <strong>构件库</strong> 的形式出现，但构件库只是框架的一个重要部分。框架的关键还在于框架内对象间的 <strong>交互模式</strong> 和 <strong>控制流模式</strong> 。</p>
<p>框架比构件可定制性强。在某种程度上，将构件和框架看成两个不同但彼此协作的技术或许更好。框架为构件提供重用的环境，为构件处理错误、交换数据及激活操作提供了标准的方法。</p>
<p><strong>应用框架</strong></p>
<blockquote>
<p>应用框架并不是包含构件应用程序的小片程序，而是实现了某应用领域通用完备功能（除去特殊应用的部分）的底层服务。使用这种框架的编程人员可以在一个通用功能已经实现的基础上开始具体的系统开发。框架提供了所有应用期望的默认行为的类集合。具体的应用通过重写子类(该子类属于框架的默认行为)或组装对象来支持应用专用的行为。应用框架强调的是软件的设计重用性和系统的可扩充性,以缩短大型应用软件系统的开发周期，提高开发质量。与传统的基于类库的面向对象重用技术比较，应用框架更注重于面向专业领域的软件重用。应用框架具有领域相关性，构件根据框架进行复合而生成可运行的系统。框架的粒度越大，其中包含的领域知识就更加完整。</p>
</blockquote>
<blockquote>
<p><em><strong>“框架其实是某种应用的半成品，就是一组组件，供你选用完成你自己的系统。简单说就是使用别人搭好的舞台，你来做表演。而且，框架一般是成熟的，不断升级的软件。 ”</strong></em></p>
</blockquote>
<p>框架的概念最早起源于Smalltalk环境，其中最著名的框架是Smalltalk  80的用户界面框架MVC(Model-View-Controller)。随着用户界面框架Interviews 【Linton 89】和ET++  【Weinand 89】  的开发和发布，框架研究越来越受到研究人员的重视。虽然框架研究最初起源于用户界面领域，但它还被成功地应用到其他领域中，如操作系统、火警系统  等。Taligent公司于1992年成立后，框架研究受到了广泛的重视。该公司计划基于框架来开发一个完整的面向对象操作系统。另外，该公司还发布了一套支持快速应用开发的工具集CommonPoint，其中包括了上百个面向对象框架 【Andert 94,Cotter 95】。框架还没有统一的定义，其中Ralph Johnson所给出的定义基本上为大多数研究人员所接受：</p>
<blockquote>
<p><em><strong>一个框架是一个可复用设计，它是由一组抽象类及其实例间协作关系来表达的。</strong></em></p>
</blockquote>
<p>这个定义是从框架内涵的角度来定义框架的，当然也可以从框架用途的角度来给出框架的定义：</p>
<blockquote>
<p> <em><strong>一个框架是在一个给定的问题领域内，一个应用程序的一部分设计与实现。</strong></em></p>
</blockquote>
<p>从以上两个定义可以看出，框架是对特定应用领域中的应用系统的部分设计和实现的整体结构。框架将应用系统划分为类和对象，定义类和对象的责任，类和对象如何互相协作，以及对象之间的控制线程。这些共有的设计因素由框架预先定义，应用开发人员只须关注于特定的应用系统特有部分。框架刻画了其应用领域所共有的设计决策，所以说框架着重于设计复用，尽管框架中可能包含用某种程序设计语言实现的具体类。</p>
<p>一个基于框架开发的应用系统包含一个或多个框架，与框架相关的构件类，以及与应用系统相关的功能扩展。与应用系统相关的扩展包括与应用系统相关的类和对象。应用系统可能仅仅复用了面向对象框架的一部分，或者说，它可能需要对框架进行一些适应性修改，以满足系统需求。</p>
<p>面向对象的框架作为一种可复用的软件，在基于框架的软件开发过程中会涉及到框架的开发和利用两个方面的工作。框架的开发阶段在于产生领域中可复用的设计。该阶段的主要结果是框架以及与框架相关的构件类。该阶段的一个重要活动是框架的演变和维护。象所有软件一样，框架也易于变化。产生变化的原因很多，如应用出错，业务领域变化，等等。</p>
<p>不论是哪一种技术，最终都是为业务发展而服务的。从业务的角度来讲。首先，框架的是为了企业的业务发展和战略规划而服务的，他服从于企业的愿景；其次，框架最重要的目标是提高企业的竞争能力，包括降低成本、提高质量、改善客户满意程度，控制进度等方面。最后，框架实现这一目标的方式是进行有效的知识积累。软件开发是一种知识活动，因此知识的聚集和积累是至关重要的。框架能够采用一种结构化的方式对某个特定的业务领域进行描述，也就是将这个领域相关的技术以代码、文档、模型等方式固化下来。</p>
<h2 id="MVC-框架"><a href="#MVC-框架" class="headerlink" title="MVC 框架"></a>MVC 框架</h2><p>即 Model-View-Control 三层框架。</p>
<h2 id="MVVM-框架"><a href="#MVVM-框架" class="headerlink" title="MVVM 框架"></a>MVVM 框架</h2><p>即 Model-View-ViewModel，一个软件架构设计模式。由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表。</p>
<p>MVVM 源自于经典的 Model–View–Controller（MVC）模式（期间还演化出了 Model-View-Presenter（MVP）模式，可忽略不计）。</p>
<p>MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。</p>
<p>当然这些事 ViewModel 已经帮我们做了，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示：</p>
<img src="http://pic.liewzheng.cn/2021/02/2021-02-19-20210219-02.png" alt="20210219-02" style="zoom: 80%;" />

<h3 id="MVVM框架详解"><a href="#MVVM框架详解" class="headerlink" title="MVVM框架详解"></a>MVVM框架详解</h3><img src="http://pic.liewzheng.cn/2021/02/2021-02-19-20210219-01.png" alt="20210219-01" style="zoom: 80%;" />

<h4 id="View-Level"><a href="#View-Level" class="headerlink" title="View Level"></a>View Level</h4><p>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建，为了更方便地展现 ViewModel 或者 Model 层的数据，已经产生了各种各样的前后端模板语言，比如 FreeMarker、Marko、Pug、Jinja2等等，各大 MVVM 框架如 KnockoutJS，Vue，Angular 等也都有自己用来构建用户界面的内置模板语言。</p>
<h4 id="Model-Level"><a href="#Model-Level" class="headerlink" title="Model Level"></a>Model Level</h4><p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。</p>
<h4 id="ViewModel-Level"><a href="#ViewModel-Level" class="headerlink" title="ViewModel Level"></a>ViewModel Level</h4><p>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。</p>
<p><strong>注意：</strong></p>
<ul>
<li><p><em><strong>ViewModel 所封装出来的数据模型包括视图的状态和行为两部分</strong></em>，而 <u>Model  层的数据模型是只包含状态的</u>（比如页面的这一块展示什么，那一块展示什么这些都属于视图状态（展示），而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互）），<u>视图状态和行为都封装在了 ViewModel 里。</u></p>
</li>
<li><p>这样的封装使得 ViewModel 可以完整地去描述 View 层。由于实现了双向绑定，ViewModel 的内容会实时展现在 View 层，这是激动人心的，因为前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM  框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护  ViewModel，更新数据视图就会自动得到相应更新，真正实现数据驱动开发。</p>
</li>
<li><p>View 层展现的不是 Model 层的数据，而是  ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model  层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</p>
</li>
</ul>
<p><strong>意义：</strong></p>
<p>MVVM用接口实现了前后端数据的通信，这样可以使前后端之间的业务逻辑没有什么关系，促进了 <em><strong>GUI 前端开发与后端业务逻辑的分离</strong></em>， 极大地提高了前端开发效率</p>
<h3 id="MVVM框架编程实例"><a href="#MVVM框架编程实例" class="headerlink" title="MVVM框架编程实例"></a>MVVM框架编程实例</h3><p>Vue 的 View 模板：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;showMessage()&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<p>Vue 的 ViewModel 层（下面是伪代码）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;     <span class="comment">// 用于描述视图状态（有基于 Model 层数据定义的，也有纯前端定义）</span></span><br><span class="line">        message: <span class="string">&#x27;Hello Vue!&#x27;</span>,  <span class="comment">// 纯前端定义</span></span><br><span class="line">        server: &#123;&#125;, <span class="comment">// 存放基于 Model 层数据的二次封装数据</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;  <span class="comment">// 用于描述视图行为（完全前端定义）</span></span><br><span class="line">        <span class="function"><span class="title">showMessage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> vm = <span class="built_in">this</span>;</span><br><span class="line">            alert(vm.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> vm = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ajax 获取 Model 层的数据</span></span><br><span class="line">        ajax(&#123;</span><br><span class="line">            url: <span class="string">&#x27;/your/server/data/api&#x27;</span>,</span><br><span class="line">            <span class="function"><span class="title">success</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">                <span class="comment">// TODO 对获取到的 Model 数据进行转换处理，做二次封装</span></span><br><span class="line">                vm.server = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<p>服务端的 Model 层（省略业务逻辑处理，只描述对外接口）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;/your/server/data/api&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;res&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;success&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;IoveC&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;domain&quot;</span>: <span class="string">&quot;www.cnblogs.com&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p><strong>渐进式</strong></p>
<hr>
<p>指VUE.JS并未强制开发者一定要使用哪种方式进行开发，更不必严格按照规矩来开发（较Angular、React），适用于开发水平不尽相同的团队，其只是提供了视图层（View Level），对于底层的开发方式还是提供了很多选择。</p>
<blockquote>
<p><em>“资料非常多，规则非常多，你要用它开发，你就必须使用它的开发规则，像模块机制、依赖注入及组件的定义，你都得按它的来，不然开发过程中就会有很多坑等着你。”</em></p>
<p>——对Angular的评价</p>
</blockquote>
<blockquote>
<p><em>“你必须要有优秀的函数式编程思想，能把业务很好的映射到函数式编程的理念，……，对于刚接触这个框架的新人来说，如果在没有人或者架构师去详细跟他们讲解公司里react项目框架细节情况的前提下，直接拿着公司项目框架来进行业务模型、逻辑组件开发或者是快速开发，结果可能是非常糟糕的。”</em></p>
<p>——对React的评价</p>
</blockquote>
<p><strong>响应式</strong></p>
<hr>
<p>此概念于2010年5月由国外著名网页设计师Ethan Marcotte所提出。</p>
<p>响应式网站设计(Responsive Web design)的理念是：</p>
<p><strong>页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整。</strong>具体的实践方式由多方面组成，包括弹性网格和布局、图片、CSS media query的使用等。无论用户正在使用笔记本还是iPad，我们的页面都应该能够自动切换分辨率、图片尺寸及相关脚本功能等，以适应不同设备；换句话说，页面应该有能力去自动响应用户的设备环境。</p>
<p><strong>响应式网页设计就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。</strong>这样，我们就可以不必为不断到来的新设备做专门的版本设计和开发了。 [1]  </p>
<p>响应式网站设计是一种网络页面设计布局，其理念是：集中创建页面的图片排版大小，可以智能地根据用户行为以及使用的设备环境进行相对应的布局。</p>
<h2 id="目前流行的9大前端框架"><a href="#目前流行的9大前端框架" class="headerlink" title="目前流行的9大前端框架"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/76463271">目前流行的9大前端框架</a></h2><hr>
<p>1.<a target="_blank" rel="noopener" href="https://cn.vuejs.org/">Vue</a></p>
<p>Vue (读音 */vjuː/*，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
<p>2.<a target="_blank" rel="noopener" href="https://react.docschina.org/">React</a></p>
<p>React 是一个用于构建用户界面的 JAVASCRIPT 库。React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。</p>
<p>3.<a target="_blank" rel="noopener" href="https://angular.io/">Angular</a></p>
<p>AngularJS诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。</p>
<p>4.<a target="_blank" rel="noopener" href="http://www.uileader.com/product_quickui">QucikUI</a></p>
<p>QucikUI 4.0是一套完整的企业级web前端开发解决方案，由基础框架、UI组件库、皮肤包、示例工程和文档等组成。底层基于jquery构建。使用QucikUI 开发者可以极大地减少工作量，提高开发效率，快速构建功能强大、美观、兼容的web应用系统。</p>
<p>5.<a target="_blank" rel="noopener" href="https://www.layui.com/">Layui</a></p>
<p>layui（谐音：类UI) 是一款采用自身模块规范编写的前端 UI 框架，遵循原生 HTML/CSS/JS 的书写与组织形式，门槛极低，拿来即用。其外在极简，却又不失饱满的内在，体积轻盈，组件丰盈，从核心代码到 API 的每一处细节都经过精心雕琢，非常适合界面的快速开发。layui 首个版本发布于2016年金秋，她区别于那些基于 MVVM 底层的 UI 框架，却并非逆道而行，而是信奉返璞归真之道。准确地说，她更多是为服务端程序员量身定做，你无需涉足各种前端工具的复杂配置，只需面对浏览器本身，让一切你所需要的元素与交互，从这里信手拈来。</p>
<p>6.<a target="_blank" rel="noopener" href="http://avalonjs.coding.me/">Avalon</a></p>
<p>avalon2是一款基于虚拟DOM与属性劫持的 迷你、 易用、 高性能 的 前端MVVM框架， 拥有超优秀的兼容性, 支持移动开发, 后端渲染, WEB Component式组件开发, 无需编译, 开箱即用。</p>
<p>7.<a target="_blank" rel="noopener" href="https://dojo.io/">Dojo</a></p>
<p>Dojo致力于实现最大的互操作性。Web组件提供了一种机制，可以在Dojo应用程序中利用非Dojo组件，并在非Dojo应用程序中轻松使用基于Dojo的小部件。Dojo为Web组件提供一流的支持。您今天做出的决定不应该将您锁定在未来的决策中。</p>
<p>8.<a target="_blank" rel="noopener" href="https://emberjs.com/">Ember</a></p>
<p>Ember.js可能是最固执己见的主流框架，这也是其最大的优势。它有创建Ember.js应用程序的正确方法，通常只有一种方法来创建应用程序。Ember.js更类似于一个产品或平台，在那里你会到一个供应商的长期支持和维护。Ember.js提供了对其平台的全面版本管理，升级工具以及对API升级的强大指导和工具。成熟，是对Ember.js的一个很好的总结。</p>
<p>9.<a target="_blank" rel="noopener" href="https://aurelia.io/">Aurelia</a><br>Aurelia是一个令人惊叹的框架，它在不牺牲功能的情况下采用简单而干净的代码。在本教程中，我们将通过构建“Todo”应用程序向您介绍Aurelia的简单性。您将看到应用程序代码的简洁程度，您将学习Aurelia的几个基本概念和功能。</p>
<h2 id="Web前端js框架有哪些"><a href="#Web前端js框架有哪些" class="headerlink" title="Web前端js框架有哪些"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/145228252%3Ffrom%5Fvoters%5Fpage%3Dtrue">Web前端js框架有哪些</a></h2><hr>
<p><strong>MobX</strong></p>
<blockquote>
<p>MobX 支持单向数据流，也就是动作改变状态，而状态的改变会更新所有受影响的视图。</p>
<p>当状态改变时，所有衍生都会进行原子级的自动更新。因此永远不可能观察到中间值。</p>
</blockquote>
<p><strong>Ractive.js</strong></p>
<blockquote>
<p>active最初是在The Guardian <a href="https://link.zhihu.com/?target=http://theguardian.com">http://theguardian.com</a>上创建的，用于制作新闻应用程序。典型的新闻应用是高度互动的，结合了HTML和SVG，并且是在极端的最后期限压力下开发的。它必须跨浏览器可靠地工作，即使在移动设备上也能很好地运行。</p>
</blockquote>
<p><strong>WebRx</strong></p>
<blockquote>
<p>WebRx是一个基于浏览器的MVVM-Framework，它将功能反应编程与声明性数据绑定，模板和客户端路由相结合。</p>
<p>该框架构建于ReactiveX for Javascript（RxJs）之上，它是一组功能强大的库，用于处理和查询异步数据流，这些数据流可以来自不同的来源，如Http-Requests，Input-Events，Timers等等。</p>
</blockquote>
<p><strong>Deku</strong></p>
<blockquote>
<p>Deku是一个使用纯函数和虚拟DOM渲染接口的库。</p>
<p>Deku只使用函数并将所有状态管理和副作用的责任推送到像Redux这样的工具，而不是使用类和本地状态。它还旨在仅支持现代浏览器以保持简单。</p>
</blockquote>
<p><strong>Roit.js</strong></p>
<blockquote>
<p>Riot为所有现代浏览器带来了自定义组件。它旨在为您提供Web组件API所需的所有本机<strong>。</strong></p>
</blockquote>
<p><strong>Mithril</strong></p>
<blockquote>
<p>用于构建单页应用程序的现代客户端Javascript框架。它很小（9.55 KB gzip），速度快，提供开箱即用的路由和XHR实用程序。</p>
</blockquote>
<p><strong>jQuery</strong></p>
<blockquote>
<p>Query是一个快速，小巧，功能丰富的JavaScript库。它通过易于使用的API在大量浏览器中运行，使得HTML文档遍历和操作，事件处理，动画和Ajax变得更加简单。通过多功能性和可扩展性的结合，jQuery改变了数百万人编写JavaScript的方式。</p>
</blockquote>
<p><strong>React</strong></p>
<blockquote>
<p>React 组件使用一个名为 render() 的方法，接收输入的数据并返回需要展示的内容。在示例中这种类似 XML 的写法被称为 JSX。被传入的数据可在组件中通过 this.props 在 render() 访问。</p>
</blockquote>
<p><strong>Polymer</strong></p>
<blockquote>
<p>Polymer 库提供用于创建自定义元素的一组功能。这些功能的设计，使其更容易、更快地创建像标准的 DOM 元素一样工作的自定义元素。 </p>
</blockquote>
<p><strong>Node.js</strong></p>
<blockquote>
<p>Node.js®是基于Chrome的V8 JavaScript引擎构建的JavaScript运行时。 </p>
</blockquote>
<p><strong>Meteor</strong></p>
<blockquote>
<p>Meteor是一个用于构建现代Web应用程序的超简单环境。</p>
</blockquote>
<p><strong>D3.js</strong></p>
<blockquote>
<p>D3.js是一个用于根据数据操作文档的JavaScript库。D3可帮助您使用HTML，SVG和CSS将数据变为现实。D3对Web标准的强调为您提供了现代浏览器的全部功能，而无需将自己与专有框架联系起来，将强大的可视化组件和数据驱动方法结合到DOM操作中。</p>
</blockquote>
<p><strong>Ember</strong></p>
<blockquote>
<p>Ember.js是一个JavaScript框架，可以大大减少构建任何Web应用程序所需的时间，精力和资源。它致力于通过执行大多数Web开发项目中涉及的所有常见，重复但必不可少的任务，使您（开发人员）尽可能高效地工作。</p>
</blockquote>
<p><strong>Aurelia</strong></p>
<blockquote>
<p>Aurelia是一个现代的前端JavaScript框架，用于构建浏览器，移动和桌面应用程序。它侧重于与Web平台规范紧密结合，使用约定优于配置，并具有最小的框架入侵。</p>
</blockquote>
<p><strong>Knockout</strong></p>
<blockquote>
<p>Knockout是一个JavaScript  MVVM（MVC的现代变体）库，可以更轻松地使用JavaScript和HTML创建丰富的，类似桌面的用户界面。它使用观察器使您的UI自动与底层数据模型保持同步，以及一组功能强大且可扩展的声明性绑定，以实现高效的开发。</p>
</blockquote>
<p><strong>Keystore</strong></p>
<blockquote>
<p>KeystoneJS是一个功能强大的Node.js内容管理系统和基于Express Web框架和Mongoose ODM构建的Web应用程序框架。Keystone可以轻松创建复杂的网站和应用程序，并附带一个漂亮的自动生成的管理UI。</p>
</blockquote>
<p><strong>Backbone</strong></p>
<blockquote>
<p>Backbone.js的提供给结构的Web应用程序的模型与键值绑定和自定义事件， 收集与枚举功能丰富的API， 观点与陈述事件处理，而这一切在一个RESTful JSON接口连接到现有的API。</p>
</blockquote>
<p><strong>Zepto</strong></p>
<blockquote>
<p>Zepto是一个用于现代浏览器的极简主义JavaScript库，具有与jQuery兼容的API。</p>
</blockquote>
<h2 id="网站相关知识"><a href="#网站相关知识" class="headerlink" title="网站相关知识"></a>网站相关知识</h2><h3 id="静态网站与动态网站"><a href="#静态网站与动态网站" class="headerlink" title="静态网站与动态网站"></a>静态网站与动态网站</h3><h4 id="静态网站"><a href="#静态网站" class="headerlink" title="静态网站"></a>静态网站</h4><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ol>
<li>静态网站是最初的建站方式，浏览者所看到的每个页面是建站者上传到服务器上的一个 html （ htm ）文件，这种网站每增加、删除、修改一个页面，都必须重新对服务器的文件进行一次下载上传。网页内容一经发布到网站服务器上，无论是否有用户访问，每个静态网页的内容都是保存在网站服务器上的，也就是说，静态网页是实实在在保存在服务器上的文件，每个网页都是一个独立的文件；</li>
<li>静态网页的内容相对稳定，因此容易被搜索引擎检索；</li>
<li>静态网页没有数据库的支持，在网站制作和维护方面工作量较大，因此当网站信息量很大时完全依靠静态网页制作方式比较困难；</li>
<li>静态网页的交互性较差，在功能方面有较大的限制。</li>
</ol>
<h4 id="动态网站"><a href="#动态网站" class="headerlink" title="动态网站"></a>动态网站</h4><ol>
<li><p>交互性：网页会根据用户的要求和选择而动态地改变和响应，浏览器作为客户端，成为一个动态交流的桥梁，动态网页的交互性也是今后 Web 发展的潮流。</p>
</li>
<li><p>自动更新：即无须手动更新 HTML 文档，便会自动生成新页面，可以大大节省工作量。</p>
</li>
<li><p>因时因人而变：即当不同时间、不同用户访问同一网址时会出现不同页面。</p>
</li>
</ol>
<p>动态网站在页面里嵌套了程序，这种网站对一些框架相同，更新较快的信息页面进行内容与形式的分离，将信息内容以记录的形式存入了网站的数据库中，以便于网 站各处的调用。这样，我们看到的一个页面，可能在服务器上不一一对应某个 html 的文件了，网页框架里套了很多数据库里的记录中的内容。此外动态网页是与静态网页相对应的，也就是说，网页 URL 的后缀不是 <code>.htm</code> 、 <code>.html</code> 、 <code>.shtml</code> 、 <code>.xml</code> 等静态网页的常见形式，而是以 <code>.asp</code> 、 <code>.jsp</code> 、 <code>.php</code> 、<code>.perl</code> 、 <code>.cgi</code> 等形式为后缀。</p>
<p>这里说的动态网页，与网页上的各种动画、滚动字幕等视觉上的 “ 动态效果 ” 没有直接关系，动态网页也可以是纯文字内容的，也可以是包含各种动画的内容，这些只是网页具体内容的表现形式，无论网页是否具有动态效果，采用动态网站技术生成的网页都称为动态网页。</p>
<h4 id="静态或动态的选择"><a href="#静态或动态的选择" class="headerlink" title="静态或动态的选择"></a>静态或动态的选择</h4><p>对于一个业务稳定，页面变化频率不大的公司来说，静态网站是一个很好的选择。因为不用开发后台程序，报 价会便宜很多。对于一个公司规模比较大的公司来说，可能经常会有动态信息要发布给浏览者，可以考虑用动态网站的后台来管理网站信息。</p>
<h4 id="服务器端运行状态区别"><a href="#服务器端运行状态区别" class="headerlink" title="服务器端运行状态区别"></a>服务器端运行状态区别</h4><p>静态服务器</p>
<img src="http://pic.liewzheng.cn/2021/02/2021-03-01-20210301-01.png" style="zoom:100%;" />

<p>动态服务器-没有数据库</p>
<img src="http://pic.liewzheng.cn/2021/02/2021-03-01-20210301-02.png" style="zoom:100%;" />

<p>动态服务器-有数据库</p>
<img src="http://pic.liewzheng.cn/2021/02/2021-03-01-20210301-03.png" style="zoom:100%;" />

<p>动态服务器-多个数据库</p>
<img src="http://pic.liewzheng.cn/2021/02/2021-03-01-20210301-04.png" style="zoom:100%;" />

<p>动态服务器-负载均衡</p>
<img src="http://pic.liewzheng.cn/2021/02/2021-03-01-20210301-05.png" style="zoom:100%;" />



<h3 id="网站制作流程"><a href="#网站制作流程" class="headerlink" title="网站制作流程"></a>网站制作流程</h3><ol>
<li>网站功能书编写</li>
<li>网站原型图设计</li>
<li>网站效果图制作</li>
<li>网站搭建（前后端同步）</li>
</ol>
<h1 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h1><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><p>官方网站：<a target="_blank" rel="noopener" href="http://cn.vuejs.org/">http://cn.vuejs.org/</a> </p>
</li>
<li><p>视频教程：<a target="_blank" rel="noopener" href="https://learning.dcloud.io/#/">https://learning.dcloud.io/#/</a></p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2019/04/19/Others/%E4%B8%93%E5%88%A9%E6%92%B0%E5%86%99%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%BB%8F%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/19/Others/%E4%B8%93%E5%88%A9%E6%92%B0%E5%86%99%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%BB%8F%E9%AA%8C/" class="post-title-link" itemprop="url">专利撰写及经验</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-04-19 23:58:32" itemprop="dateCreated datePublished" datetime="2019-04-19T23:58:32+08:00">2019-04-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-26 00:10:41" itemprop="dateModified" datetime="2021-04-26T00:10:41+08:00">2021-04-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/patent/" itemprop="url" rel="index"><span itemprop="name">patent</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="专利基础"><a href="#专利基础" class="headerlink" title="专利基础"></a>专利基础</h1><h2 id="专利概述"><a href="#专利概述" class="headerlink" title="专利概述"></a>专利概述</h2><ol>
<li>专利的特点、作用</li>
<li>我国专利制度概述</li>
<li>专利基础知识点</li>
</ol>
<h3 id="知识产权分类"><a href="#知识产权分类" class="headerlink" title="知识产权分类"></a>知识产权分类</h3><p>知识产权分为 <strong>工业产却</strong> 与 <strong>著作权</strong> 两大类，而工业产权又分为 <strong>专利</strong> 、<strong>商标</strong> 等。其中，专利分为 <strong>发明专利</strong> 、 <strong>实用新型专利</strong> 及 <strong>外观设计专利</strong> 三类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	知识产权 --&gt; 工业产权 --&gt; 专利</span><br><span class="line">	工业产权 --&gt; 商标</span><br><span class="line">	工业产权 --&gt; 集成电路布图设计</span><br><span class="line">	工业产权 --&gt; 植物新品种</span><br><span class="line">	知识产权 --&gt; 著作权</span><br><span class="line">	专利 --&gt; 发明专利</span><br><span class="line">	专利 --&gt; 实用新型专利</span><br><span class="line">	专利 --&gt; 外观设计专利</span><br></pre></td></tr></table></figure>



<h3 id="知识产权特点"><a href="#知识产权特点" class="headerlink" title="知识产权特点"></a>知识产权特点</h3><ul>
<li>无形性：客体无形、载体有形</li>
<li>独占性：专属于权利人，经其同意或法律规定外，任何人不得享有或行使该权利。</li>
<li>时间性：法律对各项知识产权保护都有一定有效期。</li>
<li>地域性：只在所确认和保护的地域内有效。除了签订有国际公约或双边互惠协定外，经一国法律所保护的某项权利只在该国范围内发生法律效力。</li>
</ul>
<h3 id="专利权"><a href="#专利权" class="headerlink" title="专利权"></a>专利权</h3><ul>
<li>发明创造的合法所有人依法对其发明享有的独占权。</li>
<li>国家主管机关依法授予申请人（或发明人）的，在一定期限内禁止他人未经允许实施其专利的权利。</li>
</ul>
<h3 id="专利制度作用"><a href="#专利制度作用" class="headerlink" title="专利制度作用"></a>专利制度作用</h3><ul>
<li>鼓励发明创造，促进创新</li>
<li>传播技术信息，推动发明创造的应用和推广</li>
<li>促进科学进步和经济发展</li>
<li>构建良好的竞争秩序，激励创新</li>
<li>创建良好的投资环境，吸引投资和先进技术</li>
</ul>
<h3 id="专利制度宗旨"><a href="#专利制度宗旨" class="headerlink" title="专利制度宗旨"></a>专利制度宗旨</h3><ul>
<li>为了保护专利权人的合法权益</li>
<li>鼓励发明创造</li>
<li>推动发明创造的应用</li>
<li>提高创新能力，促进科学技术进步和经济社会发展</li>
</ul>
<h3 id="专利保护"><a href="#专利保护" class="headerlink" title="专利保护"></a>专利保护</h3><h4 id="专利相关法律"><a href="#专利相关法律" class="headerlink" title="专利相关法律"></a>专利相关法律</h4><p>1984年3月12日，全国人大常委会表决通过专利法</p>
<p>1985年04月01日，《中华人民共和国专利法》实施</p>
<p>现今适用法律、法规：</p>
<p>《专利法》 、《专利法实施细则》、 《专利审查指南》</p>
<p>《专利法》的篇章结构  共8章 76条</p>
<blockquote>
<p>第一章 总则 21条；<br>第二章 授予专利权的条件 4条；<br>第三章 专利的申请 8条；<br>第四章 专利申请的审查和批准 8条；<br>第五章 专利权的期限、终止和无效 6条；<br>第六章 专利实施的强制许可 11条；<br>第七章 专利权的保护 16条；<br>第八章 附则 2条</p>
</blockquote>
<p>《专利法实施细则》作为专利法的配套行政法规，经国务院批准于1985年1月19日公布，1985年4月1日与专利法一同实施。 目前细则条文总共11章，123条。</p>
<h4 id="专利保护的对象和期限"><a href="#专利保护的对象和期限" class="headerlink" title="专利保护的对象和期限"></a>专利保护的对象和期限</h4><table>
<thead>
<tr>
<th>类型</th>
<th>定义</th>
<th>保护年限</th>
</tr>
</thead>
<tbody><tr>
<td>发明</td>
<td>对 <strong>产品、方法</strong> 或其改进提出的 <strong>新的技术方案</strong></td>
<td>20</td>
</tr>
<tr>
<td>实用新型</td>
<td>对 <strong>产品的形状、构造</strong> 或者其结合提出的适于实用<strong>新的技术方案</strong></td>
<td>10</td>
</tr>
<tr>
<td>外观设计</td>
<td>对 <strong>产品的形状、图案</strong> 或者其 <strong>形状与图案的结合</strong>以及<strong>色彩与形状、图案的结合</strong>所作出富有美感的并适于工业应用<strong>新设计</strong></td>
<td>10</td>
</tr>
</tbody></table>
<h3 id="专利审查"><a href="#专利审查" class="headerlink" title="专利审查"></a>专利审查</h3><h4 id="专利审查机关"><a href="#专利审查机关" class="headerlink" title="专利审查机关"></a>专利审查机关</h4><p><strong>国家知识产权局</strong> 统一受理和审查专利申请，依法授予专利权。</p>
<p>涉及国防利益需要保密的专利申请，由 <strong>国防专利机构</strong> 受理并进行审查。</p>
<h4 id="专利审查制度"><a href="#专利审查制度" class="headerlink" title="专利审查制度"></a>专利审查制度</h4><p><strong>发明</strong> 专利采用 <strong>实审制</strong>（发明初审公布后，需经实质审查，审查其是否符合专利法的相关规定，发现没有驳回理由的，应当公告授予专利权）。其 <strong>正常流程</strong> 为，自申请日（有优先权的指优先权日）起18个月公布，申请日（有优先权的指优先权日）起3年内提实审。其<strong>加快流程</strong> 为，初审、公布、实审、授权，大概2-3个月公布，最快1年内授权。</p>
<p><strong>实用新型</strong> 采用 <strong>初审制</strong>（初审合格即公告授权，不进行实质审查），最快需要3-4个月授权公告。</p>
<p>外观设计采用 <strong>初审制</strong>。</p>
<blockquote>
<p>技术淘汰快的最好申请实用新型；技术淘汰慢的最好申请发明</p>
</blockquote>
<h3 id="专利权授予条件"><a href="#专利权授予条件" class="headerlink" title="专利权授予条件"></a>专利权授予条件</h3><p>对于发明与实用新型专利，应当具 <strong>新颖性</strong> 、 <strong>创造性</strong> 及 <strong>实用性</strong> 三大条件。</p>
<p><strong>新颖性</strong> 是指不属于现有技术，也没有抵触申请的新技术，即是否处在一样的技术，是否有区别。<strong>创造性</strong> 是指非显而易见性，即区别是否足够大。<strong>实用性</strong> 是指能够在制造和使用上产生积极效果。</p>
<p>对 <strong>现有技术</strong> 的定义是：自申请日以前在国内外为公众所知的技术。包括出版物公开、使用公开、其他方式公开。</p>
<blockquote>
<p><em>授予专利权的发明和实用新型，应当具备新颖性、创造性和实用性。新颖性，是指该发明或者实用新型不属于现有技术；也没有任何单位或者个人就同样的发明或者实用新型在申请日以前向国务院专利行政部门提出过申请，并记载在申请日以后公布的专利申请文件或者公告的专利文件中。创造性，是指与现有技术相比，该发明具有突出的实质性特点和显著的进步，该实用新型具有实质性特点和进步。实用性，是指该发明或者实用新型能够制造或者使用，并且能够产生积极效果。本法所称现有技术，是指申请日以前在国内外为公众所知的技术。</em></p>
<p>——《专利法》第22条</p>
</blockquote>
<p>现行专利法——绝对新颖性原则</p>
<p>且以上专利授予条件 <mark>必须满足</mark>  “不属于《专利法》第法5、9及25条等其他不授予的情况”。</p>
<h3 id="专利权保护范围"><a href="#专利权保护范围" class="headerlink" title="专利权保护范围"></a>专利权保护范围</h3><p><strong>发明/实用新型</strong> 专利权的保护范围以其 <strong>权利要求的内容为准</strong>，说明书及附图可以用于解释权利要。</p>
<p><strong>外观设计</strong> 专利权的保护范围以表示在<strong>图片或者照片中的该产品的外观设计为准</strong>，简单说明可以用于解释图片或者照片所表示的该产品的外观设计。</p>
<h2 id="专利意识"><a href="#专利意识" class="headerlink" title="专利意识"></a>专利意识</h2><p>统计显示，全世界90%以上的技术信息都将通过专利信息公开。充分利用专利信息，避免重复研发。</p>
<p>专利布局工作能够使我们的研发成果得到全面的保护，避免竞争对手抄袭，通过专利手段提升我司产品的市场份额。</p>
<p>侵权排查与无效规避是我们工作中不可逾越的红线，一旦越过红线，将导致我司产品无法上市，所有的研发心血付诸东流。</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417091043022.png" alt="image-20210417091043022" style="zoom:50%;" />

<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417091131935.png" alt="image-20210417091131935" style="zoom:50%;" />

<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417091222349.png" alt="image-20210417091222349" style="zoom:50%;" />

<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417091245709.png" alt="image-20210417091245709" style="zoom:50%;" />

<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417091430726.png" alt="image-20210417091430726" style="zoom:50%;" />

<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417091604437.png" alt="image-20210417091604437" style="zoom:50%;" />



<h2 id="格力专利制度"><a href="#格力专利制度" class="headerlink" title="格力专利制度"></a>格力专利制度</h2><ol>
<li><p>我司专利团队架构</p>
</li>
<li><p>我司知识产权管理办法</p>
</li>
<li><p>我司知识产权相关活动</p>
</li>
<li><p>我司知识产权荣誉</p>
</li>
</ol>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417091758176.png" alt="image-20210417091758176" style="zoom:50%;" />

<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417091832811.png" alt="image-20210417091832811" style="zoom:50%;" />



<h3 id="专利管理办法"><a href="#专利管理办法" class="headerlink" title="专利管理办法"></a>专利管理办法</h3><p>我司知识产权管理办法 QG0203.07-02</p>
<p>我司专利管理办法 QG0203.06-03</p>
<h4 id="职务发明"><a href="#职务发明" class="headerlink" title="职务发明"></a>职务发明</h4><p>即 <strong>执行本单位的任务</strong> 或者主要是利用本单位的物质技术条件所完成的发明创造为职务发明创造。职务发明创造申请专利的权利属于该单位；申请被批准后，该单位为 <strong>专利权人</strong>。</p>
<p>管理办法中对人员的定义如下：</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417092038416.png" alt="image-20210417092038416" style="zoom: 33%;" />

<p>“<strong>执行本公司的任务</strong>”完成的智力劳动成果定义：</p>
<ul>
<li><p>在本职工作中取得的智力劳动成果，即在执行科研计划（含补充计划和临时计划）课题和合同计划课题，完成计划创作任务和设计任务，实施技术改造工程或履行其他所在岗位职责的过程中所取得的智力劳动成果。包括但不限于公司所派的项目和各项目组自己提出的项目所产生的劳动成果。动</p>
</li>
<li><p>履行本公司交付的本职工作之外的任务所取得的智力劳动成果。</p>
</li>
<li><p>离休、退休、辞退或调离工作后一年内做出的与其在本公司承担的本职工作或本公司分配的任务有关的智力劳动成果。</p>
</li>
</ul>
<p>“<strong>利用公司物质技术条件</strong>”完成的智力劳动成果定义：</p>
<p>利用本公司资金、设备、原材料、试验条件、场地或者不对外公开的技术资料、图纸及其说明、声像材料等等。</p>
<p>“<strong>利用本公司的名义</strong>”定义：</p>
<p>在经济技术合同中使用本公司名称。</p>
<p>“<strong>享受本单位的待遇</strong>”定义：</p>
<p>指自选课题、自筹资金、自立项目，但在工作时间内完成的智力劳动成果。</p>
<h2 id="格力专利务实操作基础知识"><a href="#格力专利务实操作基础知识" class="headerlink" title="格力专利务实操作基础知识"></a>格力专利务实操作基础知识</h2><ol>
<li>我司专利申请流程</li>
<li>我司知识产权管理系统操作方法</li>
<li>我司一级专利评定及标准</li>
<li>我司发明人及专利权人变更相关注意事项</li>
</ol>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417092724954.png" alt="image-20210417092724954" style="zoom:50%;" />

<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417092937790.png" alt="image-20210417092937790" style="zoom:50%;" />

<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417093010187.png" alt="image-20210417093010187" style="zoom:50%;" />

<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417093053523.png" alt="image-20210417093053523" style="zoom:50%;" />

<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417094700862.png" alt="image-20210417094700862" style="zoom:67%;" />

<h1 id="专利撰写准备"><a href="#专利撰写准备" class="headerlink" title="专利撰写准备"></a>专利撰写准备</h1><h2 id="专利新创性"><a href="#专利新创性" class="headerlink" title="专利新创性"></a>专利新创性</h2><p>据《专利法》二十二条第二款，<strong>新颖性：</strong></p>
<p>是指该发明或者实用新型不属于<strong>现有技术</strong>；也没有任何单位或者个人就 <strong>同样的发明或者实用新型</strong>向国务院专利行政部门提出过申请，并且记载在<strong>申请日以后公布</strong>的专利申请文件中或者公告的专利文件中。</p>
<p>据《专利法》二十二条第三款，<strong>创造性：</strong></p>
<p>是指与现有技术相比，该发明具有<strong>突出的实质性特点</strong> 和 <strong>显著的进步</strong>，该实用新型有 <strong>实质性特点和进步</strong>。</p>
<h3 id="抵触申请"><a href="#抵触申请" class="headerlink" title="抵触申请"></a>抵触申请</h3><blockquote>
<p><em>是指损害新颖性的专利申请。具体是指在申请日以前，任何单位或个人就同样的技术已向专利行政部门提出过申请，并且记载在申请日以后公布的专利申请文件或者公告的专利文件中，那么这一申请就被称之为 <mark>专利申请的抵触申请 </mark>。</em></p>
<p>——百度百科</p>
</blockquote>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417100345018.png" alt="image-20210417100345018" style="zoom:50%;" />



<h3 id="审查原则"><a href="#审查原则" class="headerlink" title="审查原则"></a>审查原则</h3><blockquote>
<p>1、单独对比原则，即每项权利要求与单独一项现有技术（或抵触申</p>
<p>请）进行对比。</p>
<p>2、整体原则（四相同）：</p>
<p>（1）技术方案（实质）相同；</p>
<p>（2）能够适用相同的 <strong>技术领域</strong>、解决相同的 <strong>技术问题</strong>、并且具有相</p>
<p>同的 <strong>预期效果</strong>。</p>
<p>——《专利审查指南》</p>
</blockquote>
<p>从权利要求书上的每一条逐条与现有技术进行比对，此为 <strong>单独比对原则</strong>。</p>
<p><strong>整体比对原则</strong> 是指从 <strong>技术方案（的实质）</strong>、 <strong>技术领域</strong> 、 <strong>技术问题</strong> 及 <strong>预期效果</strong> 上进行全方面比对。如果全都相同，则说明该专利方案不具有新颖性。</p>
<h3 id="本领域技术人员要求"><a href="#本领域技术人员要求" class="headerlink" title="本领域技术人员要求"></a>本领域技术人员要求</h3><ul>
<li><strong>知晓</strong>申请日或者优先权日之前发明所属技术领域所有的普通技术知识；</li>
<li>能够<strong>获知</strong>该领域中所有的现有技术；</li>
<li>具有<strong>应用</strong>该日期之前常规实验手段的能力，但他<strong>不具有</strong>创造能力；</li>
<li>如果所要解决的技术问题能够<strong>促使</strong>本领域的技术人员在其他技术领域寻找技术手段，他也应具有从该其他技术领域中获知该申请日或优先权日之前的相关现有技术、普通技术知识和常规实验手段的能力。</li>
</ul>
<h3 id="突出的实质性特点"><a href="#突出的实质性特点" class="headerlink" title="突出的实质性特点"></a>突出的实质性特点</h3><p>突出的实质性特点，是指对所属技术领域的技术人员来说，发明相对于现有技术是 <mark>非显而易见</mark> 的。如果发明是所属技术领域的技术人员在现有技术的基础上仅仅通过合乎逻辑的分析、推理或者有限的试验可以得到的，则该发明是显而易见的，也就不具备突出的实质性特点</p>
<p style="color: #CCC; font-weight: 100; font-style: italic;">无论如何发明出来的专利一定是具有实用性的，也就是有用的，这种有用会体现在实际解决的技术问题上，对于某项发明解决的问题应该明确描述。</p>

<p><strong>判断方法：</strong></p>
<ol>
<li>确定最接近的现有技术</li>
<li>确定发明的区别技术特征和发明实际解决的技术问题</li>
<li>判断要求保护的发明对本领域的技术人员来说是否显而易见</li>
</ol>
<h3 id="显著的进步"><a href="#显著的进步" class="headerlink" title="显著的进步"></a>显著的进步</h3><p>发明有显著的进步，是指发明与现有技术相比能够产生有益的技术效果。</p>
<ul>
<li>发明与现有技术相比具有 <strong>更好的技术效果</strong>，例如，质量改善、产量提高、节约能源、防治环境污染等；</li>
<li>发明提供了一种 <strong>技术构思不同的方案</strong>，其技术效果能够基本上达到现有技术的水平；</li>
<li>发明代表某种 <strong>新技术发展趋势</strong>；</li>
<li>尽管发明在某些方面有负面效果，但在其他方面具有 <strong>明显积极的技术效果</strong>。</li>
</ul>
<h3 id="发明的分类"><a href="#发明的分类" class="headerlink" title="发明的分类"></a>发明的分类</h3><p><strong>开拓性发明</strong>，是指一种全新的技术方案，在技术史上未曾有过先例，它为人类科学技术在某个时期的发展开创了新纪元。开拓性发明同现有技术相比，具有突出的实质性特点和显著的进步，具备创造性。</p>
<p><strong>组合发明</strong>，是指将某些技术方案进行组合，构成一项新的技术方案，以解决现有技术客观存在的技术问题。在进行组合发明创造性的判断时通常需要考虑：组合后的各技术特征在功能上是否彼此相互支持、组合的难易程度、现有技术中是否存在组合的启示以及组合后的技术效果等。</p>
<p><strong>选择发明</strong>，是指从现有技术中公开的宽范围中，有目的地选出现有技术中未提到的窄范围或个体的发明。<u>在进行选择发明创造性的判断时，选择所带来的预料不到的技术效果是考虑的主要因素。</u></p>
<blockquote>
<ol>
<li>如果发明仅是从一些已知的可能性中进行选择，或者发明仅仅是从一些具有相同可能性的技术方案中选出一种，而选出的方案未能取得预料不到的技术效果，则该发明不具备创造性。</li>
<li>如果发明是在可能的、有限的范围内选择具体的尺寸、温度范围或者其他参数，而<br>这些选择可以由本领域的技术人员通过常规手段得到并且没有产生预料不到的技术效果，<br>则该发明不具备创造性。</li>
<li>如果发明是可以从现有技术中直接推导出来的选择，则该发明不具备创造性。</li>
<li>如果选择使得发明取得了预料不到的技术效果，则该发明具有突出的实质性特点和显著的进步，具备创造性。</li>
</ol>
</blockquote>
<p><strong>转用发明</strong>，是指将某一技术领域的现有技术转用到其他技术领域中的发明。在进行转用发明的创造性判断时通常需要考虑：转用的技术领域的远近、是否存在相应的技术启示、转用的难易程度、是否需要克服技术上的困难、转用所带来的技术效果等</p>
<blockquote>
<ol>
<li>如果转用是在类似的或者相近的技术领域之间进行的，并且未产生预料不到的技术效果，则这种转用发明不具备创造性。</li>
<li>如果这种转用能够产生预料不到的技术效果，或者克服了原技术领域中未曾遇到的困难，则这种转用发明具有突出的实质性特点和显著的进步，具备创造性。</li>
</ol>
</blockquote>
<p><strong>已知产品的新用途发明</strong>，是指将已知产品用于新的目的的发明。在进行已知产品新用途发明的创造性判断时通常需要考虑：新用途与现有用途技术领域的远近、新用途所带来的技术效果等。</p>
<blockquote>
<ol>
<li>如果新的用途仅仅是使用了已知材料的已知的性质，则该用途发明不具备创造性。</li>
<li>如果新的用途是利用了已知产品新发现的性质，并且产生了预料不到的技术效果，则这种用途发明具有突出的实质性特点和显著的进步，具备创造性。</li>
</ol>
</blockquote>
<p><strong>要素变更的发明</strong>，包括 <strong>要素关系改变的发明</strong> 、 <strong>要素替代的发明</strong> 和 <strong>要素省略的发明</strong> 。在进行要素变更发明的创造性判断时通常需要考虑：要素关系的改变、要素替代和省略是否存在技术启示、其技术效果是否可以预料等。</p>
<p><strong>要素关系改变的发明</strong>，是指发明与现有技术相比，其形状、尺寸、比例、位置及作用关系等发生了变化</p>
<blockquote>
<ol>
<li>如果要素关系的改变没有导致发明效果、功能及用途的变化，或者发明效果、功能及用途的变化是可预料到的，则发明不具备创造性。</li>
<li>如果要素关系的改变导致发明产生了预料不到的技术效果，则发明具有突出的实质性特点和显著的进步，具备创造性</li>
</ol>
</blockquote>
<p><strong>要素替代的发明</strong>，是指已知产品或方法的某一要素由其他已知要素替代的发明。</p>
<blockquote>
<ol>
<li>如果发明是相同功能的已知手段的等效替代，或者是为解决同一技术问题，用已知最新研制出的具有相同功能的材料替代公知产品中的相应材料，或者是用某一公知材料替代公知产品中的某材料，而这种公知材料的类似应用是已知的，且没有产生预料不到的技术效果，则该发明不具备创造性。</li>
<li>如果要素的替代能使发明产生预料不到的技术效果，则该发明具有突出的实质性特点和显著的进步，具备创造性。</li>
</ol>
</blockquote>
<p><strong>要素省略的发明</strong>，是指省去已知产品或者方法中的某一项或多项要素的发明。</p>
<blockquote>
<ol>
<li>如果发明省去一项或多项要素后其功能也相应地消失，则该发明不具备创造性。</li>
<li>如果发明与现有技术相比，发明省去一项或多项要素(例如，一项产品发明省去了一个或多个零、部件或者一项方法发明省去一步或多步工序) 后，依然保持原有的全部功能，或者带来预料不到的技术效果，则具有突出的实质性特点和显著的进步，该发明具备创造性。</li>
</ol>
</blockquote>
<h2 id="专利文件"><a href="#专利文件" class="headerlink" title="专利文件"></a>专利文件</h2><h3 id="专利文件结构"><a href="#专利文件结构" class="headerlink" title="专利文件结构"></a>专利文件结构</h3><ol>
<li><strong>著录项：</strong>包括：公开号、公告/公布日、申请号、申请日、专利权人/ 申请人、发明人、专利代理机构、代理人、分类号等。</li>
<li><strong>摘要及摘要附图</strong></li>
<li><strong>权利要求书</strong></li>
<li><strong>说明书及说明书附图</strong></li>
</ol>
<ul>
<li><strong>扉页</strong>：著录项、摘要、附图，快速获取信息</li>
<li><strong>权利要求书</strong>：以说明书为依据，清楚限定专利保护范围</li>
<li><strong>说明书</strong>：背景技术、发明内容、具体实施方式、附图</li>
</ul>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417110814683.png" alt="image-20210417110814683" style="zoom:67%;" />

<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417110835219.png" alt="image-20210417110835219" style="zoom:67%;" />

<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417110846476.png" alt="image-20210417110846476" style="zoom:67%;" />



<h3 id="专利文件阅读技巧"><a href="#专利文件阅读技巧" class="headerlink" title="专利文件阅读技巧"></a>专利文件阅读技巧</h3><ul>
<li>看技术方案，即 <strong>说明书</strong> 中的具体实施方式。</li>
<li>看结构，即 <strong>说明书</strong> 附图。</li>
<li>看保护范围，即 <strong>权利要求书</strong> 如何描述。</li>
<li>看本发明有益效果，即 <strong>摘要</strong>。</li>
<li>看本发明要解决的技术问题，即 <strong>说明书</strong> 背景技术部分及 <strong>发明内容</strong> 的第一段。</li>
</ul>
<h2 id="无效对比与分析"><a href="#无效对比与分析" class="headerlink" title="无效对比与分析"></a>无效对比与分析</h2><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417111224516.png" alt="image-20210417111224516" style="zoom:50%;" />



<blockquote>
<p><mark>无效宣告请求的理由，是指被授予专利的发明创造不符合专利法</mark>第二条、第二十条第一款、第二十二条、第二十三条、第二十六条第三款、第四款、第二十七条第二款、第三十三条或者本细则第二十条第二款、第四十三条第一款的规定，或者属于专利法第五条、第二十五条的规定，或者依照专利法第九条规定 <mark>(而)不能取得专利权</mark>。</p>
</blockquote>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417111400147.png" alt="image-20210417111400147" style="zoom:50%;" />



<h1 id="专利撰写实践"><a href="#专利撰写实践" class="headerlink" title="专利撰写实践"></a>专利撰写实践</h1><h2 id="专利检索"><a href="#专利检索" class="headerlink" title="专利检索"></a>专利检索</h2><ol>
<li>基本知识</li>
<li>检索方法</li>
<li>检索技巧</li>
<li>常用检索数据库</li>
</ol>
<h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>指从用户特定的信息需求出发，对特定的信息集合采用一定的方法、<br>技术手段，根据一定的线索与规则从中找出相关信息。</p>
<p><strong>专利检索</strong> 是根据一项或多项特征，从海量专利文献或专利数据库中挑选出符合某一特定要求的文献或信息的过程。</p>
<h3 id="检索方法"><a href="#检索方法" class="headerlink" title="检索方法"></a>检索方法</h3><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419101550917.png" alt="image-20210419101550917" style="zoom:67%;" />





<h3 id="检索技巧"><a href="#检索技巧" class="headerlink" title="检索技巧"></a>检索技巧</h3><h3 id="常用检索数据库"><a href="#常用检索数据库" class="headerlink" title="常用检索数据库"></a>常用检索数据库</h3><h2 id="专利提案书"><a href="#专利提案书" class="headerlink" title="专利提案书"></a>专利提案书</h2><p>提案书是发明人将发明内容清晰、完整地传达给 <strong>专利管理员</strong>、<strong>代理人</strong> 的文书。而 <em><strong>清楚、完整</strong></em> 是指使用所属技术领域的技术术语，明确表达想做什么和如何 去做，使得所属技术领域的技术人员能够实现该方案。 </p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417111740858.png" alt="image-20210417111740858" style="zoom: 50%;" />



<h3 id="提案书架构"><a href="#提案书架构" class="headerlink" title="提案书架构"></a>提案书架构</h3><ul>
<li>发明创造名称</li>
<li>背景技术</li>
<li>解决的技术问题及有益效果</li>
<li>发明点</li>
<li>附图</li>
<li>最优实施方式</li>
</ul>
<h4 id="发明创造名称"><a href="#发明创造名称" class="headerlink" title="发明创造名称"></a>发明创造名称</h4><p>应清楚、简要、全面地反映要求保护的发明创造的主题和类型。一件专利申请 <mark><strong>可以同时包含产品和方法</strong></mark>，如《空调器除霜系统及除霜控制方法》</p>
<p><em>其中，*<em>主题</em></em> 是指专利所要求保护的技术内容，而 <strong>类型</strong> 是指要求保护的是产品还是方法*</p>
<p><strong>注意：</strong>避免使用“技术”、“设计”等笼统且抽象的术语。</p>
<h5 id="错误示例"><a href="#错误示例" class="headerlink" title="错误示例"></a>错误示例</h5><ul>
<li>柜机新增缺氟保护功能</li>
<li>空调主动降噪技术 </li>
<li>吸气管减振结构设计 </li>
<li>一种可以在导电材料面上实现的触摸检测技术 </li>
<li> 智能功率模块的集成设计及结构实现 </li>
<li>一种提升PCB抗冲击的结构方案</li>
</ul>
<h5 id="正确示例"><a href="#正确示例" class="headerlink" title="正确示例"></a>正确示例</h5><ul>
<li>柜式空调器的缺氟保护方法</li>
<li>空调器的主动降噪方法和降噪系统</li>
<li>具有圆弧段减震结构的吸气管 </li>
<li>金属电容式触摸键盘</li>
<li>集成PFC电路和逆变电路的智能功率模块</li>
<li>一种具有缓冲部件的电器盒及电器盒组件</li>
</ul>
<h4 id="背景技术"><a href="#背景技术" class="headerlink" title="背景技术"></a>背景技术</h4><h5 id="撰写原则"><a href="#撰写原则" class="headerlink" title="撰写原则"></a>撰写原则</h5><ul>
<li>应当系统、全面地介绍对本申请的理解和检索有用的现有技术。</li>
<li>有相关专利文献(或科技文献)的，请 <strong>给出引证的专利号</strong>(或文献编号)。</li>
<li>通过分析推理，说明现有技术中存在的问题和缺点（仅限于由本申请 的技术方案能解决的），其产生的原因和解决问题时曾遇到的困难</li>
</ul>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ol>
<li>（不能满足则被认为没有引证） 所引证的非专利文件和外国专利文件的公开日应当在本申 请的申请日之前； </li>
<li>所引证的中国专利文件的公开日不能晚于本申请的公开日。</li>
<li>现有技术中的技术问题分析不到位时，将导致审查员低估专利的新创性高度。<strong>建议介绍一下发现问题的过程，以及发现问题过程的难度，进而结合到具体的现有技术通过推理的方式阐述技术问题产生的原因。</strong></li>
</ol>
<h5 id="错误示例-1"><a href="#错误示例-1" class="headerlink" title="错误示例"></a>错误示例</h5><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417113935138.png" alt="image-20210417113935138" style="zoom: 67%;" />



<h5 id="优秀示例"><a href="#优秀示例" class="headerlink" title="优秀示例"></a>优秀示例</h5><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417113847130.png" alt="image-20210417113847130" style="zoom:80%;" />





<h4 id="解决的技术问题及有益效果"><a href="#解决的技术问题及有益效果" class="headerlink" title="解决的技术问题及有益效果"></a>解决的技术问题及有益效果</h4><h5 id="技术问题"><a href="#技术问题" class="headerlink" title="技术问题"></a>技术问题</h5><ul>
<li>正面直接、清楚、客观地指出要解决的问题；</li>
<li>技术问题应该是背景技术中存在的技术问题；</li>
<li>可以同时解决多个技术问题，也可以解决一个技术问题，也可以多个方 案解决多个技术问题</li>
</ul>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417133524015.png" alt="image-20210417133524015" style="zoom:67%;" />

<h5 id="有益效果"><a href="#有益效果" class="headerlink" title="有益效果"></a>有益效果</h5><p>有益效果是指与背景技术相比具有的有益效果。</p>
<ul>
<li>应当通过对本申请结构特点的分析和理论说明相结合，或者通过列出实 验数据（给出必要实验条件和方法）的方式，说明与背景技术的区别以 及由该区别所取得的有益效果，不得只断言具有有益效果。</li>
<li>有益效果可以由产率、质量、精度和效率的提高，能耗、原材料、工序 的节省，加工、操作、控制、使用的简便，环境污染的治理以及有用性 能的出现等方面反映出来</li>
</ul>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417133718557.png" alt="image-20210417133718557" style="zoom:67%;" />

<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210417133700056.png" alt="image-20210417133700056" style="zoom:67%;" />



<h6 id="有益效果的作用"><a href="#有益效果的作用" class="headerlink" title="有益效果的作用"></a>有益效果的作用</h6><p>有益效果是确定 <strong>发明</strong> 是否具有 “<strong>显著进步</strong>” 的重要依据，是确定 <strong>实用新型</strong> 是否具有 “<strong>进步</strong>” 的重要依据！</p>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p><strong>设备、装置等结构类：</strong> 通过说明增加或者改进了哪些部件，给出机械运动过程，给出推理过 程，围绕需要解决的问题做技术上的说明。</p>
<p><strong>控制方法、工艺等方法类：</strong> 重点介绍增加或者改进了哪个步骤，给出为什么可以实现预期效果， 给出推理过程，围绕需要解决的问题做技术上的说明。</p>
<h4 id="发明点"><a href="#发明点" class="headerlink" title="发明点"></a>发明点</h4><p> 发明点，即本申请相对于背景技术改进的技术点，该技术点是 解决前述技术问题的关键；</p>
<p>简明扼要，突出重点，根据重要程度一一列举改进的技术点。 </p>
<p><strong>举例</strong></p>
<p>一项关于空调器清洁杀菌方法的发明，技术方案是通过控制空调按 凝露、结霜、化霜、高温杀菌步骤完成清洁杀菌。</p>
<p><strong>发明点列举：</strong></p>
<ol>
<li><p>杀菌控制方法；</p>
</li>
<li><p>高压保护；</p>
</li>
<li><p>低压保护。</p>
</li>
</ol>
<h4 id="附图"><a href="#附图" class="headerlink" title="附图"></a>附图</h4><p>附图部分，应当提供可编辑的附图（CAD、VISIO等），<mark>写明各附图的图名</mark> ；</p>
<p><strong>结构类附图</strong> 最好能够 <mark>提供立体图及爆炸图，标号表明各部件</mark>；</p>
<p><strong>模块框图</strong> 需要 <mark>描述清楚各个模块的名称及连接关系</mark>；</p>
<p><em><strong>照片仅能起到帮助理解方案的作用，在专利申请文件中一般不能使用</strong></em></p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419092202673.png" alt="image-20210419092202673" style="zoom: 50%;" />

<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419092228518.png" alt="image-20210419092228518" style="zoom:50%;" />



<h3 id="具体实施方式"><a href="#具体实施方式" class="headerlink" title="具体实施方式"></a>具体实施方式</h3><ul>
<li>围绕发明点，结合附图详细地描述技术方案，所有附图都应详 细描述，以不看附图即可明白技术方案为准； </li>
<li>对采用的技术手段逐一描述有益效果； </li>
<li>用词规范，含义明确</li>
</ul>
<h4 id="针对各类提案书的书写建议"><a href="#针对各类提案书的书写建议" class="headerlink" title="针对各类提案书的书写建议"></a>针对各类提案书的书写建议</h4><h5 id="产品、装置类技术方案"><a href="#产品、装置类技术方案" class="headerlink" title="产品、装置类技术方案"></a>产品、装置类技术方案</h5><ul>
<li><p>首先，描述产品整体构造；</p>
</li>
<li><p>其次，详细描述关键改进部分的具体构造； </p>
</li>
<li><p>最后，说明动作过程和工作原理 </p>
</li>
</ul>
<p><strong>注意：</strong>尽可能详细地描述各个部件之间的连接关系及位置关系。</p>
<h5 id="方法类技术方案"><a href="#方法类技术方案" class="headerlink" title="方法类技术方案"></a>方法类技术方案</h5><ul>
<li><p>描述具体的实现流程； </p>
</li>
<li><p>描述方式：通过XX设备执行了XX动作/操作，达到了XX条件/目的； </p>
</li>
<li><p>详细介绍方法的步骤构成，各步骤间的关系，工艺参数等 </p>
</li>
</ul>
<h5 id="电子类技术方案"><a href="#电子类技术方案" class="headerlink" title="电子类技术方案"></a>电子类技术方案</h5><ul>
<li>描述电子产品的元器件、部件，相互配置关系，以及各器件/部件在整个产品中的功能</li>
</ul>
<h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><blockquote>
<p><strong>例1：</strong>产品类 技术方案</p>
<p>首先，描述产品整体构造。</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419093156426.png" alt="image-20210419093156426" style="zoom:50%;" />



<p>其次，详细描述关键改进部分的具体构造</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419093239539.png" alt="image-20210419093239539" style="zoom:50%;" />

<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419093255210.png" alt="image-20210419093255210" style="zoom:50%;" />



<p>最后，说明动作过程和工作原理</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419093337481.png" alt="image-20210419093337481" style="zoom:50%;" />
</blockquote>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419093524237.png" alt="image-20210419093524237" style="zoom: 50%;" />

<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419093534973.png" alt="image-20210419093534973" style="zoom: 50%;" />



<h4 id="实施例撰写准则"><a href="#实施例撰写准则" class="headerlink" title="实施例撰写准则"></a>实施例撰写准则</h4><ul>
<li>实施例中，不仅要对技术方案所涉及的各技术特征进行具体描述，还要对有助于理解本发明创造的相关内容进行具体描述。例如：产品的制造过程及设备、原料来源、使用方法等；方法的实施设备、使用范围等。</li>
<li>技术内容保证详实、实质性的描述，切忌只有功能性描述，而无实现该功能的具体技术方案。</li>
<li>如果涉及公式，需要写出具体的公式形式，并给出公式中的每个参数的物理含义。</li>
<li>如果涉及到实验，请尽量提供实验数据（以表格形式）或实验过程，通过实验数据支撑实验结果。</li>
<li>如果涉及到算法，需以步骤形式写出具体的算法逻辑规则。如果是现有算法，请采用业内通用名称，并简单介绍算法原理；若非现有算法，请详细介绍算法原理。</li>
</ul>
<h4 id="实施例拓展"><a href="#实施例拓展" class="headerlink" title="实施例拓展"></a>实施例拓展</h4><blockquote>
<p>《专利审查指南》规定：</p>
<ul>
<li>当专利要求保护范围较宽时，应当给出至少两个不同的实施例，以支持要求保护的范围。</li>
<li>专利的改进涉及数值范围时，通常应当给出两端值的实施例，范围较宽时，还应当给出至少一个中间值的实施例。</li>
</ul>
</blockquote>
<h3 id="提案书内核标准"><a href="#提案书内核标准" class="headerlink" title="提案书内核标准"></a>提案书内核标准</h3><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210419094300129.png" alt="image-20210419094300129" style="zoom:67%;" />
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备19004822号 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liewzheng</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
