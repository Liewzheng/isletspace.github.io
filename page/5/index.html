<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://code.islet.space/font//css?family=/CascadiaCode/CascadiaCode:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"islet.space","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/db.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>
<meta name="description" content="笔记分享的旮旯孤岛而已">
<meta property="og:type" content="website">
<meta property="og:title" content="Coder的孤岛">
<meta property="og:url" content="http://islet.space/page/5/index.html">
<meta property="og:site_name" content="Coder的孤岛">
<meta property="og:description" content="笔记分享的旮旯孤岛而已">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liewzheng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://islet.space/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Coder的孤岛</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Coder的孤岛</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">islet of the coder</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-文章"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>文章</a></li>
        <li class="menu-item menu-item-目录"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-简历"><a href="/resume/" rel="section"><i class="fa fa-address-card fa-fw"></i>简历</a></li>
        <li class="menu-item menu-item-友链"><a href="/friends/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>友链</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liewzheng</p>
  <div class="site-description" itemprop="description">笔记分享的旮旯孤岛而已</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">112</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">210</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="mailto:liewzheng@foxmail.com" title="E-Mail → mailto:liewzheng@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/05/Programming/C++/2021-07-05-%E5%9C%A8linux%E4%B8%8A%E7%BC%96%E5%86%99%E6%B1%82%E8%A7%A3ADAU1772%E7%9A%84PLL%E7%B3%BB%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/05/Programming/C++/2021-07-05-%E5%9C%A8linux%E4%B8%8A%E7%BC%96%E5%86%99%E6%B1%82%E8%A7%A3ADAU1772%E7%9A%84PLL%E7%B3%BB%E6%95%B0/" class="post-title-link" itemprop="url">在linux上编写求解ADAU1772的PLL系数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-05 20:00:00" itemprop="dateCreated datePublished" datetime="2021-07-05T20:00:00+08:00">2021-07-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-07-06 01:01:05" itemprop="dateModified" datetime="2021-07-06T01:01:05+08:00">2021-07-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>通过在Linux上编写代码，计算求解ADAU1772在 <strong>输入时钟</strong>（MCLK Input）为16.6MHz时，如何设置内部的4个参数，以达到符合输出时钟要求的目的。</p>
<p>据《ADAU1772》和SigmaStudio，1772 Codec 内部可修改的参数有 <strong>输入时钟分频</strong>（Input Clock Divider）、<strong>整数设置</strong>（Integer Setting）、<strong>分子</strong>（Numerator） 和 <strong>分母</strong>（Denominator）四个。</p>
<p><strong>目标输出时钟</strong>（VCO Output） 是 24.576MHz。</p>
<h1 id="原公式">原公式</h1>
<p>以下为《ADAU1772》第30页中，关于PLL计算的公式描述：</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210706002255187.png" alt="image-20210706002255187" /><figcaption aria-hidden="true">image-20210706002255187</figcaption>
</figure>
<p>以下为SigmaStudio中的PLL设定界面参数设定：</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210706002412136.png" alt="image-20210706002412136" /><figcaption aria-hidden="true">image-20210706002412136</figcaption>
</figure>
<h1 id="代码编写">代码编写</h1>
<p>注意：本代码在Linux上，以C++17的版本进行编译运行。</p>
<p>编译代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -std=c++17 -lpthread</span><br></pre></td></tr></table></figure>
<p>在编写代码时，考虑到SigmaStudio和数据手册之间可能存在表述差异，因此计算PLL的源代码中，也包含了开启 <code>1/2</code> 系数的宏定义 <code>#define HALFCOFF 1</code> ，具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * HEADER FILES</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * MACRO DEFINITION</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACCURACY 1000000000   <span class="comment">//输出时钟精度，小数点后9个0</span></span></span><br><span class="line"><span class="comment">// #define HALFCOFF 1            //打开1/2系数进行计算，SigmaStudio图示中有该系数，但《ADAU1772》数据手册中没有该系数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * MACRO DEFINITION FOR DEBUG</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">// #define DEBUG_MODE         //Debug模式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * DATA TYPES</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> CLK;           <span class="comment">//数据类型_时钟</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> COFF;  <span class="comment">//数据类型_系数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * FILE DOMAIN DATA DECLARATION</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line">CLK CLK_IN = <span class="number">16.6</span>;            <span class="comment">//输入时钟</span></span><br><span class="line">CLK CLK_OUT = <span class="number">24.576</span>;         <span class="comment">//输出时钟</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TargetCofficient</span> &#123;</span></span><br><span class="line">    COFF Numerator;</span><br><span class="line">    COFF Denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">COFF Maxiator = <span class="number">65535</span>;</span><br><span class="line">COFF InputClockDivider = <span class="number">4</span>;</span><br><span class="line">COFF IntegerSetting = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * FUNCTIONS DECLARATION</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isSafe</span><span class="params">(COFF, COFF)</span></span>;      <span class="comment">//判断系数的分子和分母相除是否满足要求</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isOK</span><span class="params">(CLK)</span></span>;               <span class="comment">//判断输出结果是否符合输出时钟的精度要求</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CofficientCalculate</span><span class="params">(CLK, COFF, COFF)</span></span>;         <span class="comment">//计算</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD1</span><span class="params">(<span class="keyword">void</span>)</span></span>;             <span class="comment">//子线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD2</span><span class="params">(<span class="keyword">void</span>)</span></span>;             <span class="comment">//子线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD3</span><span class="params">(<span class="keyword">void</span>)</span></span>;             <span class="comment">//子线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD4</span><span class="params">(<span class="keyword">void</span>)</span></span>;             <span class="comment">//子线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysPrintf</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * MAIN FUNCTIONS</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;SYSTEM: Procedure starts.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">thread1</span><span class="params">(ICD1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread2</span><span class="params">(ICD2)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread3</span><span class="params">(ICD3)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread4</span><span class="params">(ICD4)</span></span>;</span><br><span class="line"></span><br><span class="line">    thread1.<span class="built_in">join</span>();</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">    thread3.<span class="built_in">join</span>();</span><br><span class="line">    thread4.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;SYSTEM: Procedure ends up.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * FUNCTIONS DEFINITION</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isSafe</span><span class="params">(COFF N, COFF D)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = (<span class="keyword">double</span>)N / (<span class="keyword">double</span>)D;</span><br><span class="line">    <span class="keyword">if</span>( (result &gt;= <span class="number">0.1</span>) &amp;&amp; (result &lt;= <span class="number">0.9</span>) ) <span class="keyword">return</span> <span class="number">1</span>;       <span class="comment">//判断系数是否满足要求，满足则返回1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isOK</span><span class="params">(CLK clock)</span></span>&#123;</span><br><span class="line">    CLK integerClock , fractClock;</span><br><span class="line">    fractClock = <span class="built_in">modf</span>(clock , &amp;integerClock);                <span class="comment">//分别取出整数和小数部分</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( ((<span class="keyword">int</span>)(fractClock * ACCURACY) == (<span class="keyword">int</span>)(<span class="number">576</span>/(<span class="keyword">double</span>)<span class="number">1000</span> * ACCURACY)) &amp;&amp; ((<span class="keyword">int</span>)integerClock == (<span class="keyword">int</span>)CLK_OUT) ) &#123;  <span class="comment">//如果小数点精度满足要求，且整数部分相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                                           <span class="comment">//则返回1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CofficientCalculate</span><span class="params">(CLK ClockInput, COFF ICD, COFF IS)</span></span>&#123;</span><br><span class="line">    CLK tempCLK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(COFF i = <span class="number">0</span>; i &lt; Maxiator; i++)&#123;                     <span class="comment">//分母</span></span><br><span class="line">        <span class="keyword">for</span>(COFF j = <span class="number">0</span>; j &lt; Maxiator; j++)&#123;                 <span class="comment">//分子</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isSafe</span>(j, i))&#123;</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">ifdef</span> HALFCOFF</span></span><br><span class="line">                tempCLK = ClockInput /(<span class="keyword">double</span>)ICD * ((<span class="keyword">double</span>)IS + ((<span class="keyword">double</span>)j/(<span class="keyword">double</span>)i)) *<span class="number">1</span>/<span class="number">2</span>;   <span class="comment">//有系数时</span></span><br><span class="line">                <span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line">                tempCLK = ClockInput /(<span class="keyword">double</span>)ICD * ((<span class="keyword">double</span>)IS + ((<span class="keyword">double</span>)j/(<span class="keyword">double</span>)i)) ;       <span class="comment">//无系数时</span></span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                <span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_MODE</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;SYSTEM:IDC = &quot;</span> &lt;&lt; ICD &lt;&lt; <span class="string">&quot;, IS = &quot;</span> &lt;&lt; IS &lt;&lt; hex &lt;&lt;<span class="string">&quot;, Numerator = 0x&quot;</span>&lt;&lt; j &lt;&lt; <span class="string">&quot;, Denominator = 0x&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, OutputClock = &quot;</span> &lt;&lt; tempCLK &lt;&lt; endl;</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">isOK</span>(tempCLK)) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;SYSTEM:IDC = &quot;</span> &lt;&lt; ICD &lt;&lt; <span class="string">&quot;, IS = &quot;</span> &lt;&lt; IS &lt;&lt; hex &lt;&lt;<span class="string">&quot;, Numerator = 0x&quot;</span>&lt;&lt; j &lt;&lt; <span class="string">&quot;, Denominator = 0x&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, OutputClock = &quot;</span> &lt;&lt; tempCLK &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * THREAD _ CALCULATOR</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD1</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(COFF enumIS = <span class="number">2</span>; enumIS &lt;= IntegerSetting; enumIS++) <span class="built_in">CofficientCalculate</span>(CLK_IN , <span class="number">1</span>, enumIS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD2</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(COFF enumIS = <span class="number">2</span>; enumIS &lt;= IntegerSetting; enumIS++) <span class="built_in">CofficientCalculate</span>(CLK_IN , <span class="number">2</span>, enumIS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD3</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(COFF enumIS = <span class="number">2</span>; enumIS &lt;= IntegerSetting; enumIS++) <span class="built_in">CofficientCalculate</span>(CLK_IN , <span class="number">3</span>, enumIS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD4</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(COFF enumIS = <span class="number">2</span>; enumIS &lt;= IntegerSetting; enumIS++) <span class="built_in">CofficientCalculate</span>(CLK_IN , <span class="number">4</span>, enumIS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysPrintf</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// while(1) cout &lt;&lt; &quot;Calculating...&quot;;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r\003&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="运行结果">运行结果</h1>
<p>通过自行编写的代码，遍历所有可更改的系数进行计算求解，取得小数点后9位精度，并且符合要求的系数如下（含1/2系数）：</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210706001243698.png" alt="image-20210706001243698" /><figcaption aria-hidden="true">image-20210706001243698</figcaption>
</figure>
<p>以下为不含1/2系数的结果：</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210706001350802.png" alt="image-20210706001350802" /><figcaption aria-hidden="true">image-20210706001350802</figcaption>
</figure>
<p>经过手工计算，结果（小数点后9位）确实满足要求。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/02/Signal/2021-07-02-PCMWAV%E6%A0%BC%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/02/Signal/2021-07-02-PCMWAV%E6%A0%BC%E5%BC%8F/" class="post-title-link" itemprop="url">PCM/WAV格式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-02 10:10:00" itemprop="dateCreated datePublished" datetime="2021-07-02T10:10:00+08:00">2021-07-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-12-10 22:37:12" itemprop="dateModified" datetime="2021-12-10T22:37:12+08:00">2021-12-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Signal/" itemprop="url" rel="index"><span itemprop="name">Signal</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/renhui/p/12148330.html">cnblogs.com</a></p>
<h1 id="名词解析">名词解析</h1>
<p>PCM(Pulse Code Modulation)也被称为脉码编码调制，PCM中的声音数据没有被压缩，它是由模拟信号经过采样、量化、编码转换成的标准的数字音频数据。采样转换方式参考下图进行了解：</p>
<figure>
<img src="https://img2018.cnblogs.com/blog/682616/202001/682616-20200104125147149-1090015063.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>音频采样包含以下几大要素：</p>
<h2 id="采样率">采样率</h2>
<p>采样率表示音频信号每秒的数字快照数。该速率决定了音频文件的频率范围。采样率越高，数字波形的形状越接近原始模拟波形。低采样率会限制可录制的频率范围，这可导致录音表现原始声音的效果不佳。根据奈奎斯特采样定理，为了重现给定频率，采样率必须至少是该频率的两倍。例如，一般CD唱片的采样率为每秒 44,100 个采样，因此可重现最高为 22,050 Hz 的频率，此频率刚好超过人类的听力极限 20,000 Hz。</p>
<figure>
<img src="https://img2018.cnblogs.com/blog/682616/202001/682616-20200104124551841-1606892798.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>图中A是低采样率的音频信号，其效果已经将原始声波进行了扭曲，B则是完全重现原始声波的高采样率的音频信号。</p>
<p>数字音频常用的采样率如下：</p>
<figure>
<img src="https://img2018.cnblogs.com/blog/682616/202001/682616-20200104124756569-1015603325.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="位深度">位深度</h2>
<p>位深度决定动态范围。采样声波时，为每个采样指定最接近原始声波振幅的振幅值。较高的位深度可提供更多可能的振幅值，产生更大的动态范围、更低的噪声基准和更高的保真度。</p>
<figure>
<img src="https://img2018.cnblogs.com/blog/682616/202001/682616-20200104124916045-1853047547.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>位深度越高，提供的动态范围越大。</p>
<h1 id="pcm">PCM</h1>
<p>在上面的名词解析中我们应该对PCM有了一定的理解和认识，下面我们将对PCM做更多的讲解。</p>
<h2 id="pcm音频数据存储方式">PCM音频数据存储方式</h2>
<p>如果是单声道的文件，采样数据按时间的先后顺序依次存入。如果是单声道的音频文件，采样数据按时间的先后顺序依次存入（也可能采用 LRLRLR 方式存储，只是另一个声道的数据为 0）。</p>
<p>如果是双声道的话通常按照 LRLRLR 的方式存储，存储的时候还和机器的大小端有关。（关于字节序大小端的相关内容可参考《<a target="_blank" rel="noopener" href="https://www.cnblogs.com/renhui/p/13600572.html">字节序问题之大小端模式讲解</a>》进行了解）</p>
<p>PCM的存储方式为小端模式，存储Data数据排列如下图所示：</p>
<figure>
<img src="https://img2018.cnblogs.com/blog/682616/202001/682616-20200104112313716-290297915.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="pcm-音频数据的参数">PCM 音频数据的参数</h2>
<p>描述 PCM 音频数据的参数的时候有如下描述方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">44100HZ 16bit stereo: 每秒钟有 44100 次采样, 采样数据用 16 位（2 字节）记录, 双声道（立体声）</span><br><span class="line">22050HZ 8bit  mono: 每秒钟有 22050 次采样, 采样数据用 8 位（1 字节）记录, 单声道</span><br><span class="line">48000HZ 32bit 51ch: 每秒钟有 48000 次采样, 采样数据用 32 位（4 字节浮点型）记录, 5.1 声道</span><br></pre></td></tr></table></figure>
<p>44100Hz 指的是采样率，它的意思是每秒取样 44100 次。采样率越大，存储数字音频所占的空间就越大。</p>
<p>16bit 指的是采样精度，意思是原始模拟信号被采样后，每一个采样点在计算机中用 16 位（两个字节）来表示。采样精度越高越能精细地表示模拟信号的差异。</p>
<p>Stereo 指的是声道数，也即采样时用到的麦克风的数量，麦克风越多就越能还原真实的采样环境（当然麦克风的放置位置也是有规定的）。</p>
<h1 id="wav">WAV</h1>
<p>WAV 是 Microsoft 和 IBM 为 PC 开发的一种声音文件格式，它符合 RIFF（Resource Interchange File Format）文件规范，用于保存 Windows 平台的音频信息资源，被 Windows 平台及其应用程序所广泛支持。WAVE 文件通常只是一个具有单个 “WAVE” 块的 RIFF 文件，该块由两个子块（”fmt” 子数据块和 ”data” 子数据块），它的格式如下图所示：</p>
<figure>
<img src="https://img2018.cnblogs.com/blog/682616/202001/682616-20200104131622902-1855086338.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>WAV 格式定义</strong></p>
<p>该格式的实质就是在 PCM 文件的前面加了一个文件头，每个字段的的含义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    char          ChunkID[4]; &#x2F;&#x2F;内容为&quot;RIFF&quot;</span><br><span class="line">    unsigned long ChunkSize;  &#x2F;&#x2F;存储文件的字节数（不包含ChunkID和ChunkSize这8个字节）</span><br><span class="line">    char          Format[4];  &#x2F;&#x2F;内容为&quot;WAVE“</span><br><span class="line">&#125; WAVE_HEADER;</span><br><span class="line"> </span><br><span class="line">typedef struct &#123;</span><br><span class="line">   char           Subchunk1ID[4]; &#x2F;&#x2F;内容为&quot;fmt&quot;</span><br><span class="line">   unsigned long  Subchunk1Size;  &#x2F;&#x2F;存储该子块的字节数（不含前面的Subchunk1ID和Subchunk1Size这8个字节）</span><br><span class="line">   unsigned short AudioFormat;    &#x2F;&#x2F;存储音频文件的编码格式，例如若为PCM则其存储值为1。</span><br><span class="line">   unsigned short NumChannels;    &#x2F;&#x2F;声道数，单声道(Mono)值为1，双声道(Stereo)值为2，等等</span><br><span class="line">   unsigned long  SampleRate;     &#x2F;&#x2F;采样率，如8k，44.1k等</span><br><span class="line">   unsigned long  ByteRate;       &#x2F;&#x2F;每秒存储的bit数，其值 &#x3D; SampleRate * NumChannels * BitsPerSample &#x2F; 8</span><br><span class="line">   unsigned short BlockAlign;     &#x2F;&#x2F;块对齐大小，其值 &#x3D; NumChannels * BitsPerSample &#x2F; 8</span><br><span class="line">   unsigned short BitsPerSample;  &#x2F;&#x2F;每个采样点的bit数，一般为8,16,32等。</span><br><span class="line">&#125; WAVE_FMT;</span><br><span class="line"> </span><br><span class="line">typedef struct &#123;</span><br><span class="line">   char          Subchunk2ID[4]; &#x2F;&#x2F;内容为“data”</span><br><span class="line">   unsigned long Subchunk2Size;  &#x2F;&#x2F;接下来的正式的数据部分的字节数，其值 &#x3D; NumSamples * NumChannels * BitsPerSample &#x2F; 8</span><br><span class="line">&#125; WAVE_DATA;</span><br></pre></td></tr></table></figure>
<p><strong>WAV 文件头解析</strong></p>
<p>这里是一个 WAVE 文件的开头 72 字节，字节显示为十六进制数字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">52 49 46 46 | 24 08 00 00 | 57 41 56 45</span><br><span class="line">66 6d 74 20 | 10 00 00 00 | 01 00 02 00 </span><br><span class="line">22 56 00 00 | 88 58 01 00 | 04 00 10 00</span><br><span class="line">64 61 74 61 | 00 08 00 00 | 00 00 00 00 </span><br><span class="line">24 17 1E F3 | 3C 13 3C 14 | 16 F9 18 F9</span><br><span class="line">34 E7 23 A6 | 3C F2 24 F2 | 11 CE 1A 0D</span><br></pre></td></tr></table></figure>
<p>字段解析如下图：</p>
<figure>
<img src="https://img2018.cnblogs.com/blog/682616/202001/682616-20200104131832991-1533022058.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h1 id="pcm-wav-开发实践">PCM &amp; WAV 开发实践</h1>
<h2 id="pcm格式转为wav格式基于c语言">PCM格式转为WAV格式（基于C语言）</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">int simplest_pcm16le_to_wave(const char *pcmpath,int channels,int sample_rate,const char *wavepath)</span><br><span class="line">&#123;</span><br><span class="line">    typedef struct WAVE_HEADER&#123;  </span><br><span class="line">        char         fccID[4];        </span><br><span class="line">        unsigned   long    dwSize;            </span><br><span class="line">        char         fccType[4];    </span><br><span class="line">    &#125;WAVE_HEADER;  </span><br><span class="line">    typedef struct WAVE_FMT&#123;  </span><br><span class="line">        char         fccID[4];        </span><br><span class="line">        unsigned   long       dwSize;            </span><br><span class="line">        unsigned   short     wFormatTag;    </span><br><span class="line">        unsigned   short     wChannels;  </span><br><span class="line">        unsigned   long       dwSamplesPerSec;  </span><br><span class="line">        unsigned   long       dwAvgBytesPerSec;  </span><br><span class="line">        unsigned   short     wBlockAlign;  </span><br><span class="line">        unsigned   short     uiBitsPerSample;  </span><br><span class="line">    &#125;WAVE_FMT;  </span><br><span class="line">    typedef struct WAVE_DATA&#123;  </span><br><span class="line">        char       fccID[4];          </span><br><span class="line">        unsigned long dwSize;              </span><br><span class="line">    &#125;WAVE_DATA;  </span><br><span class="line">    if(channels&#x3D;&#x3D;0||sample_rate&#x3D;&#x3D;0)&#123;</span><br><span class="line">    channels &#x3D; 2;</span><br><span class="line">    sample_rate &#x3D; 44100;</span><br><span class="line">    &#125;</span><br><span class="line">    int bits &#x3D; 16;</span><br><span class="line">    WAVE_HEADER   pcmHEADER;  </span><br><span class="line">    WAVE_FMT   pcmFMT;  </span><br><span class="line">    WAVE_DATA   pcmDATA;  </span><br><span class="line"> </span><br><span class="line">    unsigned   short   m_pcmData;</span><br><span class="line">    FILE   *fp,*fpout;  </span><br><span class="line">    fp&#x3D;fopen(pcmpath, &quot;rb&quot;);</span><br><span class="line">    if(fp &#x3D;&#x3D; NULL) &#123;  </span><br><span class="line">        printf(&quot;open pcm file error\n&quot;);</span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;</span><br><span class="line">    fpout&#x3D;fopen(wavepath,   &quot;wb+&quot;);</span><br><span class="line">    if(fpout &#x3D;&#x3D; NULL) &#123;    </span><br><span class="line">        printf(&quot;create wav file error\n&quot;);  </span><br><span class="line">        return -1; </span><br><span class="line">    &#125;        </span><br><span class="line">    &#x2F;&#x2F;WAVE_HEADER</span><br><span class="line">    memcpy(pcmHEADER.fccID,&quot;RIFF&quot;,strlen(&quot;RIFF&quot;));                    </span><br><span class="line">    memcpy(pcmHEADER.fccType,&quot;WAVE&quot;,strlen(&quot;WAVE&quot;));  </span><br><span class="line">    fseek(fpout,sizeof(WAVE_HEADER),1); </span><br><span class="line">    &#x2F;&#x2F;WAVE_FMT</span><br><span class="line">    pcmFMT.dwSamplesPerSec&#x3D;sample_rate;  </span><br><span class="line">    pcmFMT.dwAvgBytesPerSec&#x3D;pcmFMT.dwSamplesPerSec*sizeof(m_pcmData);  </span><br><span class="line">    pcmFMT.uiBitsPerSample&#x3D;bits;</span><br><span class="line">    memcpy(pcmFMT.fccID,&quot;fmt &quot;,strlen(&quot;fmt &quot;));  </span><br><span class="line">    pcmFMT.dwSize&#x3D;16;  </span><br><span class="line">    pcmFMT.wBlockAlign&#x3D;2;  </span><br><span class="line">    pcmFMT.wChannels&#x3D;channels;  </span><br><span class="line">    pcmFMT.wFormatTag&#x3D;1;  </span><br><span class="line"> </span><br><span class="line">    fwrite(&amp;pcmFMT,sizeof(WAVE_FMT),1,fpout); </span><br><span class="line">    &#x2F;&#x2F;WAVE_DATA;</span><br><span class="line">    memcpy(pcmDATA.fccID,&quot;data&quot;,strlen(&quot;data&quot;));  </span><br><span class="line">    pcmDATA.dwSize&#x3D;0;</span><br><span class="line">    fseek(fpout,sizeof(WAVE_DATA),SEEK_CUR);</span><br><span class="line">    fread(&amp;m_pcmData,sizeof(unsigned short),1,fp);</span><br><span class="line">    while(!feof(fp))&#123;  </span><br><span class="line">        pcmDATA.dwSize+&#x3D;2;</span><br><span class="line">        fwrite(&amp;m_pcmData,sizeof(unsigned short),1,fpout);</span><br><span class="line">        fread(&amp;m_pcmData,sizeof(unsigned short),1,fp);</span><br><span class="line">    &#125;  </span><br><span class="line">    pcmHEADER.dwSize&#x3D;44+pcmDATA.dwSize;</span><br><span class="line">    rewind(fpout);</span><br><span class="line">    fwrite(&amp;pcmHEADER,sizeof(WAVE_HEADER),1,fpout);</span><br><span class="line">    fseek(fpout,sizeof(WAVE_FMT),SEEK_CUR);</span><br><span class="line">    fwrite(&amp;pcmDATA,sizeof(WAVE_DATA),1,fpout);</span><br><span class="line">    </span><br><span class="line">    fclose(fp);</span><br><span class="line">    fclose(fpout);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：函数里声明的数据类型unsigned long在有些C编译器上是64位的，这时候要改成unsigned int才可以，否则wav头有88bytes，标准的是44bytes，改完就正常了，对C还不熟悉的人小小的心得，另外，声道数和采样率也要注意，一般采样率有44100/16000/8000，要确认是哪个，声道是1还是2，这两个参数要设置好才会有正确的转换结果。</p>
<h2 id="pcm降低某个声道的音量基于c语言">PCM降低某个声道的音量（基于C语言）</h2>
<p>一般来说 PCM 数据中的波形幅值越大，代表音量越大，对于 PCM 音频数据而言，它的幅值（即该采样点采样值的大小）代表音量的大小。</p>
<p>如果我们需要降低某个声道的音量，可以通过减小某个声道的数据的值来实现降低某个声道的音量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int pcm16le_half_volume_left( char *url ) &#123;</span><br><span class="line">    FILE *fp_in &#x3D; fopen( url, &quot;rb+&quot; );</span><br><span class="line">    FILE *fp_out &#x3D; fopen( &quot;output_half_left.pcm&quot;, &quot;wb+&quot; );</span><br><span class="line">    unsigned char *sample &#x3D; ( unsigned char * )malloc(4); &#x2F;&#x2F; 一次读取一个sample，因为是2声道，所以是4字节 </span><br><span class="line">    while ( !feof( fp_in ) )&#123;</span><br><span class="line">        fread( sample, 1, 4, fp_in );</span><br><span class="line">        short* sample_num &#x3D; ( short* )sample; &#x2F;&#x2F; 转成左右声道两个short数据</span><br><span class="line">        *sample_num &#x3D; *sample_num &#x2F; 2; &#x2F;&#x2F; 左声道数据减半</span><br><span class="line">        fwrite( sample, 1, 2, fp_out ); &#x2F;&#x2F; L</span><br><span class="line">        fwrite( sample + 2, 1, 2, fp_out ); &#x2F;&#x2F; R</span><br><span class="line">    &#125;</span><br><span class="line">    free( sample );</span><br><span class="line">    fclose( fp_in );</span><br><span class="line">    fclose( fp_out );</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码做的事情是：在读出左声道的 2 Byte 的取样值之后，将其转成了 C 语言中的一个 short 类型的变量。将该数值除以 2 之后写回到了 PCM 文件中。</p>
<h2 id="分离pcm音频数据左右声道的数据">分离PCM音频数据左右声道的数据</h2>
<p>因为PCM音频数据是按照LRLRLR的方式来存储左右声道的音频数据的，所以我们可以通过将它们交叉的读出来的方式来分离左右声道的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int simplest_pcm16le_split(char *url) &#123;</span><br><span class="line">    FILE *fp&#x3D;fopen(url,&quot;rb+&quot;);</span><br><span class="line">    FILE *fp1&#x3D;fopen(&quot;output_l.pcm&quot;,&quot;wb+&quot;);</span><br><span class="line">    FILE *fp2&#x3D;fopen(&quot;output_r.pcm&quot;,&quot;wb+&quot;);</span><br><span class="line">    unsigned char *sample&#x3D;(unsigned char *)malloc(4);</span><br><span class="line">    while(!feof(fp))&#123;</span><br><span class="line">        fread(sample,1,4,fp);</span><br><span class="line">        &#x2F;&#x2F;L</span><br><span class="line">        fwrite(sample,1,2,fp1);</span><br><span class="line">        &#x2F;&#x2F;R</span><br><span class="line">        fwrite(sample+2,1,2,fp2);</span><br><span class="line">    &#125;</span><br><span class="line">    free(sample);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    fclose(fp1);</span><br><span class="line">    fclose(fp2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="从pcm16le单声道音频采样数据中截取一部分数据">从PCM16LE单声道音频采样数据中截取一部分数据</h2>
<p>本程序中的函数可以从PCM16LE单声道数据中截取一段数据，并输出截取数据的样值。函数的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Cut a 16LE PCM single channel file.</span><br><span class="line"> * @param url        Location of PCM file.</span><br><span class="line"> * @param start_num  start point</span><br><span class="line"> * @param dur_num    how much point to cut</span><br><span class="line"> *&#x2F;</span><br><span class="line">int simplest_pcm16le_cut_singlechannel(char *url,int start_num,int dur_num)&#123;</span><br><span class="line">    FILE *fp&#x3D;fopen(url,&quot;rb+&quot;);</span><br><span class="line">    FILE *fp1&#x3D;fopen(&quot;output_cut.pcm&quot;,&quot;wb+&quot;);</span><br><span class="line">    FILE *fp_stat&#x3D;fopen(&quot;output_cut.txt&quot;,&quot;wb+&quot;);</span><br><span class="line"> </span><br><span class="line">    unsigned char *sample&#x3D;(unsigned char *)malloc(2);</span><br><span class="line"> </span><br><span class="line">    int cnt&#x3D;0;</span><br><span class="line">    while(!feof(fp))&#123;</span><br><span class="line">        fread(sample,1,2,fp);</span><br><span class="line">        if(cnt&gt;start_num&amp;&amp;cnt&lt;&#x3D;(start_num+dur_num))&#123;</span><br><span class="line">            fwrite(sample,1,2,fp1);</span><br><span class="line"> </span><br><span class="line">            short samplenum&#x3D;sample[1];</span><br><span class="line">            samplenum&#x3D;samplenum*256;</span><br><span class="line">            samplenum&#x3D;samplenum+sample[0];</span><br><span class="line"> </span><br><span class="line">            fprintf(fp_stat,&quot;%6d,&quot;,samplenum);</span><br><span class="line">            if(cnt%10&#x3D;&#x3D;0)</span><br><span class="line">                fprintf(fp_stat,&quot;\n&quot;,samplenum);</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    free(sample);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    fclose(fp1);</span><br><span class="line">    fclose(fp_stat);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将pcm16le双声道音频采样数据转换为pcm8音频采样数据">将PCM16LE双声道音频采样数据转换为PCM8音频采样数据</h2>
<p>本程序中的函数可以通过计算的方式将PCM16LE双声道数据16bit的采样位数转换为8bit。函数的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Convert PCM-16 data to PCM-8 data.</span><br><span class="line"> * @param url  Location of PCM file.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int simplest_pcm16le_to_pcm8(char *url)&#123;</span><br><span class="line">    FILE *fp&#x3D;fopen(url,&quot;rb+&quot;);</span><br><span class="line">    FILE *fp1&#x3D;fopen(&quot;output_8.pcm&quot;,&quot;wb+&quot;);</span><br><span class="line"> </span><br><span class="line">    int cnt&#x3D;0;</span><br><span class="line"> </span><br><span class="line">    unsigned char *sample&#x3D;(unsigned char *)malloc(4);</span><br><span class="line"> </span><br><span class="line">    while(!feof(fp))&#123;</span><br><span class="line"> </span><br><span class="line">        short *samplenum16&#x3D;NULL;</span><br><span class="line">        char samplenum8&#x3D;0;</span><br><span class="line">        unsigned char samplenum8_u&#x3D;0;</span><br><span class="line">        fread(sample,1,4,fp);</span><br><span class="line">        &#x2F;&#x2F;(-32768-32767)</span><br><span class="line">        samplenum16&#x3D;(short *)sample;</span><br><span class="line">        samplenum8&#x3D;(*samplenum16)&gt;&gt;8;</span><br><span class="line">        &#x2F;&#x2F;(0-255)</span><br><span class="line">        samplenum8_u&#x3D;samplenum8+128;</span><br><span class="line">        &#x2F;&#x2F;L</span><br><span class="line">        fwrite(&amp;samplenum8_u,1,1,fp1);</span><br><span class="line"> </span><br><span class="line">        samplenum16&#x3D;(short *)(sample+2);</span><br><span class="line">        samplenum8&#x3D;(*samplenum16)&gt;&gt;8;</span><br><span class="line">        samplenum8_u&#x3D;samplenum8+128;</span><br><span class="line">        &#x2F;&#x2F;R</span><br><span class="line">        fwrite(&amp;samplenum8_u,1,1,fp1);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Sample Cnt:%d\n&quot;,cnt);</span><br><span class="line"> </span><br><span class="line">    free(sample);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    fclose(fp1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PCM16LE格式的采样数据的取值范围是-32768到32767，而PCM8格式的采样数据的取值范围是0到255。所以PCM16LE转换到PCM8需要经过两个步骤：第一步是将-32768到32767的16bit有符号数值转换为-128到127的8bit有符号数值，第二步是将-128到127的8bit有符号数值转换为0到255的8bit无符号数值。在本程序中，16bit采样数据是通过short类型变量存储的，而8bit采样数据是通过unsigned char类型存储的。</p>
<h2 id="将pcm16le双声道音频采样数据的声音速度提高一倍">将PCM16LE双声道音频采样数据的声音速度提高一倍</h2>
<p>本程序中的函数可以通过抽象的方式将PCM16LE双声道数据的速度提高一倍，采用采样每个声道奇(偶)数点的样值的方式，函数的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Re-sample to double the speed of 16LE PCM file</span><br><span class="line"> * @param url  Location of PCM file.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int simplest_pcm16le_doublespeed(char *url)&#123;</span><br><span class="line">    FILE *fp&#x3D;fopen(url,&quot;rb+&quot;);</span><br><span class="line">    FILE *fp1&#x3D;fopen(&quot;output_doublespeed.pcm&quot;,&quot;wb+&quot;);</span><br><span class="line"> </span><br><span class="line">    int cnt&#x3D;0;</span><br><span class="line"> </span><br><span class="line">    unsigned char *sample&#x3D;(unsigned char *)malloc(4);</span><br><span class="line"> </span><br><span class="line">    while(!feof(fp))&#123;</span><br><span class="line"> </span><br><span class="line">        fread(sample,1,4,fp);</span><br><span class="line"> </span><br><span class="line">        if(cnt%2!&#x3D;0)&#123;</span><br><span class="line">            &#x2F;&#x2F;L</span><br><span class="line">            fwrite(sample,1,2,fp1);</span><br><span class="line">            &#x2F;&#x2F;R</span><br><span class="line">            fwrite(sample+2,1,2,fp1);</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Sample Cnt:%d\n&quot;,cnt);</span><br><span class="line"> </span><br><span class="line">    free(sample);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    fclose(fp1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考">参考</h1>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/leixiaohua1020/article/details/50534316">视音频数据处理入门：PCM音频采样数据处理</a> --&gt; 致敬雷神！</p>
<p>​</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/06/30/Hardware/DSP/2021-06-30-ADSP%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/30/Hardware/DSP/2021-06-30-ADSP%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">ADSP混合编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-30 14:00:00" itemprop="dateCreated datePublished" datetime="2021-06-30T14:00:00+08:00">2021-06-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-07-01 01:31:56" itemprop="dateModified" datetime="2021-07-01T01:31:56+08:00">2021-07-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hardware/" itemprop="url" rel="index"><span itemprop="name">Hardware</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="伪操作和伪指令">伪操作和伪指令</h1>
<p><strong><em>Directives</em></strong>，即 <strong>伪操作</strong>，是汇编语言中的特殊指令助记符。主要作用是为完成汇编程序做各种准备。伪操作仅是在源程序进行汇编时由汇编程序处理，而不是在计算机运行期间由机器执行的指令。即，伪操作只在汇编时起作用，一旦汇编结束，其使命也就结束了。</p>
<p><strong><em>Pseudo-Instruction</em></strong>，即 <strong><em>伪指令</em></strong>，是汇编语言程序里的特殊指令助记符，不是 真指令。伪指令在汇编时被替换成合适的机器指令（根据芯片架构而定，不同芯片架构之间指令可能不同），故其也只在汇编时其作用，不在机器运行期间由机器执行。</p>
<h1 id="adi汇编文件样式">ADI汇编文件样式</h1>
<p>.asm 文件具有以下样式，包含 <strong><em>预处理指令</em></strong>（主要是C/C++宏定义）、汇编伪操作类别（assembler direcitives）、数据块、代码块、条件编译预处理 和 汇编标签。</p>
<figure>
<img src="https://pic.islet.space/2021/06/image-20210630170546778.png" alt="image-20210630170546778" /><figcaption aria-hidden="true">image-20210630170546778</figcaption>
</figure>
<h2 id="混合编程">混合编程</h2>
<h3 id="使用asm">使用asm()</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> img288; <span class="comment">//定义C语言变量</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;ax0 = 0x5C;&quot;</span>);</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;dm(img288_) = ax0;&quot;</span>);  <span class="comment">//用汇编语言赋值时，变量需要加后置下划线？？？</span></span><br><span class="line">img288 = <span class="number">0x5C</span>;  <span class="comment">//直接用C语言赋值</span></span><br></pre></td></tr></table></figure>
<p>以上C语言与汇编代码经过编译后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ax0 &#x3D; 0x5C;</span><br><span class="line">dm(img288_) &#x3D; ax0;</span><br><span class="line">my1 &#x3D; 92;</span><br><span class="line">dm(img288_) &#x3D; my1;</span><br></pre></td></tr></table></figure>
<p><mark>此处可否把 <code>dm()</code> 当成一个类似于指针的东西</mark></p>
<h3 id="使用汇编子程序">使用汇编子程序</h3>
<p>使用汇编子程序是C语言程序与汇编语言接口的另一种方法。<mark>用户定义的子程序放在单独的汇编文件中，或是做成二进制的库文件，并将子程序的定义用GLOBEL输出，汇编后就可以供C语言程序调用</mark>。下面是一个不需要参数的子程序的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.MODULE&#x2F;RAM_delay_;</span><br><span class="line">.external del_cycle;  &#x2F;&#x2F;声明del_cycle是外部变量</span><br><span class="line">.global delay;  &#x2F;&#x2F;声明delay是全局变量</span><br><span class="line"></span><br><span class="line">delay_:</span><br><span class="line">function_entry;  &#x2F;&#x2F;子程序开始标志，必不可少</span><br><span class="line">ar &#x3D; dm(del_cycle_);</span><br><span class="line">cntr &#x3D; ar;</span><br><span class="line">do d_loop until ce;</span><br><span class="line">d_loop:nop;</span><br><span class="line">exit;  &#x2F;&#x2F;子程序结束标志，必不可少</span><br><span class="line">.ENDMOD;</span><br></pre></td></tr></table></figure>
<p>注意：以上代码源自参考链接4，实际上代码中的关键字相差可能较大，需要根据实际情况进行改动。</p>
<p>比如，21479系列芯片与ADAU1939芯片一同工作，其ADC采样代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.section&#x2F;pm seg_pmco;  &#x2F;&#x2F;程序代码块，procedure memory section</span><br><span class="line"></span><br><span class="line">_Receive_ADC_Samples:  &#x2F;*应该类似于 &#123; *&#x2F;</span><br><span class="line">.global _Receive_ADC_Samples;  &#x2F;&#x2F;定义自己为全局函数</span><br><span class="line"></span><br><span class="line">	r1 &#x3D; -31;     </span><br><span class="line">	r0 &#x3D; dm(_rx1a_buf + Internal_ADC_L1);	</span><br><span class="line">	f0 &#x3D; float r0 by r1;	</span><br><span class="line">	dm(_Left_Channel_In1) &#x3D; r0;</span><br><span class="line">  </span><br><span class="line">	r0 &#x3D; dm(_rx1a_buf + Internal_ADC_R1);	</span><br><span class="line">	f0 &#x3D; float r0 by r1;	</span><br><span class="line">	dm(_Right_Channel_In1) &#x3D; r0;			</span><br><span class="line"></span><br><span class="line">	r0 &#x3D; dm(_rx1b_buf + Internal_ADC_L2);	</span><br><span class="line">	f0 &#x3D; float r0 by r1;	</span><br><span class="line">	dm(_Left_Channel_In2) &#x3D; r0;	</span><br><span class="line">	</span><br><span class="line">	r0 &#x3D; dm(_rx1b_buf + Internal_ADC_R2);	</span><br><span class="line">	f0 &#x3D; float r0 by r1;	</span><br><span class="line">	dm(_Right_Channel_In2) &#x3D; r0;			</span><br><span class="line"></span><br><span class="line">	r0 &#x3D; DM(AD1939_audio_frame_timer);</span><br><span class="line">	r0 &#x3D; r0 + 1;</span><br><span class="line">	DM(AD1939_audio_frame_timer) &#x3D; r0;</span><br><span class="line">	</span><br><span class="line">	leaf_exit;  &#x2F;&#x2F;程序结束标志，应该类似于return;吧</span><br><span class="line">_Receive_ADC_Samples.end:  &#x2F;*应该类似于 &#125;*&#x2F;</span><br></pre></td></tr></table></figure>
<h1 id="dual-memory-support-keywords-dm-pm">Dual Memory Support Keywords (dm / pm)</h1>
<p>This section describes <strong><em>cc21k</em></strong> language extension keywords to C and C++ that support the dual-memory space, modified Harvard architecture of the ADSP-21xxx processors. There are two keywords used to designate memory space: <strong><em>dm</em></strong> and <strong><em>pm</em></strong>. They can be used to specify the location of a static or global variable or to qualify a pointer declaration.</p>
<p>以下规则适用于两种内存关键字（dm/pm）：</p>
<ul>
<li>The memory space keyword (dm or pm) refers to the expression to the right of the keyword.</li>
<li>You can specify a memory space for each level of pointer. This corresponds to one memory space for each * in the declaration.</li>
<li>The compiler uses <strong><em>Data Memory</em></strong> (DM) as the default memory space for all variables. All undeclared spaces for data are Data Memory spaces.</li>
<li>The compiler always uses <strong><em>Program Memory</em></strong> (PM) as the memory space for functions. Function pointers always point to Program Memory.</li>
<li>You cannot assign memory spaces to <strong><em>automatic variables</em></strong>. <mark>All automatic variables reside on the stack, which is always in Data Memory</mark>.</li>
<li>Literal character strings always reside in Data Memory.</li>
</ul>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《<a target="_blank" rel="noopener" href="https://www.analog.com/media/en/dsp-documentation/software-manuals/50_21k_cc_mn_rev_1.5.pdf">VisualDSP++ 5.0 C/C++ Compiler Manual for SHARC Processors</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://www.analog.com/media/en/dsp-documentation/processor-manuals/236999443isr_21xxx.pdf">ADSP-21160 SHARC DSP Instruction Set Reference</a>》</li>
<li>《嵌入式系统原理与应用设计》王光学，电子工业出版社</li>
<li><a target="_blank" rel="noopener" href="http://www.gzweix.com/article/sort0250/sort0251/sort0288/info-228197_2.html">嵌入式C语言开发ADSP21XX系列</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/06/28/Communication/2021-06-28-I2S%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/28/Communication/2021-06-28-I2S%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">I2S通信</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-28 08:40:00" itemprop="dateCreated datePublished" datetime="2021-06-28T08:40:00+08:00">2021-06-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-07-09 00:15:13" itemprop="dateModified" datetime="2021-07-09T00:15:13+08:00">2021-07-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Communication/" itemprop="url" rel="index"><span itemprop="name">Communication</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>数字音频信号的传输标准，如：</p>
<ul>
<li><strong><em>I2S</em></strong>、<strong><em>PCM</em></strong> (Pulse Code Modulation) 和 <strong><em>PDM</em></strong> (Pulse Density Modulation)主要用于同一块电路板上芯片之间音频信号的传输；</li>
<li><strong><em>Intel HDA</em></strong> (Intel High Definition Audio) 用于PC的Audio子系统（声卡）应用；</li>
<li><strong><em>S/PDIF</em></strong> 和 <strong><em>Ethernet AVB</em></strong> 主要应用于板间长距离及需要电缆连接的场合。</li>
</ul>
<h1 id="philips-i2s-标准">Philips I2S 标准</h1>
<p>I2S的标准文件源自 <strong>飞利浦半导体</strong>（Philips Semiconductors）发表于1986年的《<strong>I2S bus specification</strong>（1996年修订版）》。</p>
<blockquote>
<p>I2S（Inter-IC Sound）采用了独立的导线传输时钟与数据信号的设计，通过将数据和时钟信号分离，避免了因时差诱发的失真，为用户节省了购买抵抗音频抖动的专业设备的费用。</p>
</blockquote>
<p><strong>需要注意</strong>：I2S是一种音频编码协议，同时也是一种音频接口，因此采用I2S接口方式的不一定采用I2S编码，还可以采用 <strong>左对齐</strong>（Left Justifying）编码 或 <strong>右对齐</strong>（Right Justifying）编码。</p>
<figure>
<img src="https://pic.islet.space/2021/06/20210629145837.png" alt="image-20210629145800027" /><figcaption aria-hidden="true">image-20210629145800027</figcaption>
</figure>
<h2 id="特点">特点</h2>
<ol type="1">
<li><p>支持全双工/半双工</p></li>
<li><p>支持主/从模式</p></li>
<li><p>和PCM相比，I2S更适合立体声系统。当然，I2S的变体也支持多通道的时分复用，因此可以支持多声道。</p></li>
</ol>
<h2 id="硬件特性">硬件特性</h2>
<h3 id="总线介绍">总线介绍</h3>
<blockquote>
<p>To minimize the number of pins required and to keep wiring simple, a <strong><em>3-line serial bus is used</em></strong> consisting of a line for <strong><em>two time-multiplexed data channels</em></strong>, <strong><em>a word select line</em></strong>(WS) and <strong><em>a clock line</em></strong> (SCK).</p>
</blockquote>
<p><img src="https://pic.islet.space/2021/06/20210629172149.png" alt="image-20210629112429113" style="zoom:67%;" /></p>
<p>从上图得知，I2S总线共需要三个引脚：</p>
<ul>
<li>连续串行时钟线（<strong>SCK</strong> / <strong>SCLK</strong> / <strong>BCLK</strong>），也叫位时钟，即对应数字音频的每一位数据，SCLK都有1个脉冲。SCLK的频率=2×采样频率×采样位数。</li>
<li>字选择线（<strong>WS</strong> / <strong>LRCLK</strong>），也叫帧时钟，用于切换左右声道的数据。LRCK为“1”表示正在传输的是右声道的数据，为“0”则表示正在传输的是左声道的数据。LRCK的频率等于采样频率。</li>
<li>时分多路复用（简称 TDM）数据线，即串行数据（<strong>SD</strong> 或 <strong>SDATA</strong>），就是<mark>用二进制补码表示的</mark>音频数据。</li>
</ul>
<p>另，有时为了使系统间能够更好地同步，还需要另外传输一个信号MCLK，称为<strong>主时钟</strong>，也叫系统时钟（Sys Clock），<mark>是采样频率的256倍或384倍</mark>。</p>
<p><strong><em>注意</em></strong>：能够生成SCK和WS的就是主设备（Master）。</p>
<h3 id="电压要求">电压要求</h3>
<table>
<thead>
<tr class="header">
<th></th>
<th>VL</th>
<th>VH</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>输出电平</td>
<td>&lt;0.4V</td>
<td>&gt;2.4V</td>
</tr>
<tr class="even">
<td>输入电平</td>
<td>0.8V</td>
<td>2.0V</td>
</tr>
</tbody>
</table>
<p>这是使用的TTL电平标准，随着其他IC（LSI）的流行，其他电平也会支持。</p>
<h2 id="串行数据">串行数据</h2>
<blockquote>
<p>I2S格式的信号无论有多少位有效数据，数据的最高位总是出现在LRCK变化（也就是一帧开始）后的第2个SCLK脉冲处。这就使得<mark>接收端与发送端的有效位数可以不同</mark>。如果接收端能处理的有效位数少于发送端，可以放弃数据帧中多余的低位数据；如果接收端能处理的有效位数多于发送端，可以自行补足剩余的位。这种同步机制使得数字音频设备的互连更加方便，而且不会造成数据错位。</p>
<p>随着技术的发展，在统一的 <strong>I2S接口</strong> 下，出现了多种不同的数据格式。根据SDATA数据相对于LRCK和SCLK的位置不同，分为左对齐（较少使用）、I2S格式（即飞利浦规定的格式）和右对齐（也叫日本格式、普通格式）。</p>
<p>为了保证数字音频信号的正确传输，发送端和接收端应该采用相同的数据格式和长度。当然，对I2S格式来说数据长度可以不同。</p>
</blockquote>
<h2 id="字选择">字选择</h2>
<p>字选择（word select），也可以叫命令选择线，表明了正在被传输的声道。</p>
<ul>
<li><code>WS=0</code> ，表示正在传输的是 <strong>左声道</strong> 的数据。</li>
<li><code>WS=1</code> ，表示正在传输的是 <strong>右声道</strong> 的数据。</li>
</ul>
<p>WS可以在串行时钟的上升沿或者下降沿发生改变，并且WS信号不需要一定是对称的。在从属装置端，WS<mark>在时钟信号的上升沿发生改变</mark>。WS总是<mark>在最高位传输前的一个时钟周期发生改变</mark>，这样可以使从属装置得到与被传输的串行数据同步的时间，并且使接收端存储当前的命令以及为下次的命令清除空间。</p>
<h1 id="adi-codec-i2s移植">ADI-Codec I2S移植</h1>
<p>以下文章/教程仅针对官方提供的例程《AD1939_I2S_Sample_Based_Talkthru》进行修改。</p>
<blockquote>
<ul>
<li><code>&lt;ad1939.h&gt;</code> 定义了ADAU1939的宏定义，包括锁相环、时钟、DAC、ADC等的寄存器，与直接从SigmaStudio导出的文件并没有太大差别，应该经过精简。</li>
<li></li>
</ul>
</blockquote>
<p>首先，需要清晰认识1939和1772的硬件差异。ADAU1939和ADAU1772硬件上的异同，都有4个差分输入，但是1939有8个差分输出，1772有2个双声道输出（4个差分输出）。</p>
<figure>
<img src="https://pic.islet.space/2021/06/20210628095302.png" alt="image-20210628095252103" /><figcaption aria-hidden="true">image-20210628095252103</figcaption>
</figure>
<blockquote>
<p><strong><em>SPORTS</em></strong> ，即Serial Ports的简称，串行接口。</p>
</blockquote>
<p>在<code>&lt;ADDS_21479_EzKit.h&gt;</code> 头文件里，以下声明适用于21479和1939的音频通信通道，定义了 <strong><em>2个双声道输入</em></strong> 和 <strong><em>4个双声道输出</em></strong> ，正好符合1939的 <strong><em>4个差分输入</em></strong> 和 <strong><em>8个差分输出</em></strong> 的硬件描述，对应修改到1772时需要减少输出的声音通道。本文件仅对一些全局变量、声音通道、函数等做出声明，具体应用在其他.c文件或.asm文件中。</p>
<p>通过 <strong><em>Sport1 A</em></strong> 从Codec接收数据，并通过 <strong><em>Sport0 A/B</em></strong> 和 <strong><em>Sport2 A/B</em></strong> 将音频数据传输至Codec的四个立体声DAC接口。Sport1 接收中断服务程序以在 DMA接收缓存 <code>rx1a_buf</code> 上完成算术运算（arithmetic computations），并将计算结果存放至 DMA传输缓存 <code>tx0a_buf</code> 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************************************</span></span><br><span class="line"><span class="comment">/                                                                                                     /</span></span><br><span class="line"><span class="comment">/                            AD1939 - SPORT1 RX INTERRUPT SERVICE ROUTINE                             /</span></span><br><span class="line"><span class="comment">/                                                                                                     /</span></span><br><span class="line"><span class="comment">/    Receives input data from the AD1939 ADCs via SPORT1 A and transmits processed audio data         /</span></span><br><span class="line"><span class="comment">/    back out to the four AD1939 Stereo DACs/Line Outputs through SPORT0 A/B and SPORT2 A/B           /</span></span><br><span class="line"><span class="comment">/                                                                                                     /</span></span><br><span class="line"><span class="comment">/                                                                                                     /</span></span><br><span class="line"><span class="comment">/   This Serial Port 1 Recieve Interrupt Service Routine performs arithmetic computations on          /</span></span><br><span class="line"><span class="comment">/   the SPORT1 receive DMA buffer (rx1a_buf) and places results to SPORT0 transmit                    /</span></span><br><span class="line"><span class="comment">/   DMA buffer (tx0a_buf)                                                                             /</span></span><br><span class="line"><span class="comment">/                                                                                                     /</span></span><br><span class="line"><span class="comment">/  rx1a_buf[2] - DSP SPORT0 A receive buffer - AD1939 ASDATA1                                         /</span></span><br><span class="line"><span class="comment">/  Slot # Description                             DSP Data Memory Address                             /</span></span><br><span class="line"><span class="comment">/  ------ --------------------------------------  --------------------------------------------------  /</span></span><br><span class="line"><span class="comment">/  0      Internal ADC 0 Left Channel             DM(_rx1a_buf + 0) = DM(_rx1a_buf + Internal_ADC_L1) /</span></span><br><span class="line"><span class="comment">/  1      Internal ADC 0 Right Channel            DM(_rx1a_buf + 1) = DM(_rx1a_buf + Internal_ADC_R1) /</span></span><br><span class="line"><span class="comment">/                                                                                                     /</span></span><br><span class="line"><span class="comment">/  rx1b_buf[2] - DSP SPORT0 B receive buffer - AD1939 ASDATA2                                         /</span></span><br><span class="line"><span class="comment">/  Slot # Description                             DSP Data Memory Address                             /</span></span><br><span class="line"><span class="comment">/  ------ --------------------------------------  --------------------------------------------------  /</span></span><br><span class="line"><span class="comment">/  0      Internal ADC 1 Left Channel             DM(_rx1b_buf + 2) = DM(_rx1b_buf + Internal_ADC_L2) /</span></span><br><span class="line"><span class="comment">/  1      Internal ADC 1 Right Channel            DM(_rx1b_buf + 3) = DM(_rx1b_buf + Internal_ADC_R2) /</span></span><br><span class="line"><span class="comment">/                                                                                                     /</span></span><br><span class="line"><span class="comment">/  tx0a_buf[2] - DSP SPORT0 A transmit buffer - AD1939 DSDATA1                                        /</span></span><br><span class="line"><span class="comment">/  Slot # Description                             DSP Data Memory Address                             /</span></span><br><span class="line"><span class="comment">/  ------ --------------------------------------  --------------------------------------------------  /</span></span><br><span class="line"><span class="comment">/  0      Internal DAC 1 Left Channel             DM(_tx0a_buf + 0) = DM(_tx0a_buf + Internal_DAC_L1) /</span></span><br><span class="line"><span class="comment">/  1      Internal DAC 1 Right Channel            DM(_tx0a_buf + 1) = DM(_tx0a_buf + Internal_DAC_R1) /</span></span><br><span class="line"><span class="comment">/                                                                                                     /</span></span><br><span class="line"><span class="comment">/  tx0a_buf[2] - DSP SPORT0 B transmit buffer - AD1939 DSDATA2                                        /</span></span><br><span class="line"><span class="comment">/  Slot # Description                             DSP Data Memory Address                             /</span></span><br><span class="line"><span class="comment">/  ------ --------------------------------------  --------------------------------------------------  /</span></span><br><span class="line"><span class="comment">/  2      Internal DAC 2 Left Channel             DM(_tx0b_buf + 2) = DM(_tx0b_buf + Internal_DAC_L2) /</span></span><br><span class="line"><span class="comment">/  3      Internal DAC 2 Right Channel            DM(_tx0b_buf + 3) = DM(_tx0b_buf + Internal_DAC_R2) /</span></span><br><span class="line"><span class="comment">/                                                                                                     /</span></span><br><span class="line"><span class="comment">/  tx2a_buf[2] - DSP SPORT2 A transmit buffer - AD1939 DSDATA3                                        /</span></span><br><span class="line"><span class="comment">/  Slot # Description                             DSP Data Memory Address                             /</span></span><br><span class="line"><span class="comment">/  ------ --------------------------------------  --------------------------------------------------  /</span></span><br><span class="line"><span class="comment">/  4      Internal DAC 3 Left Channel             DM(_tx2a_buf + 4) = DM(_tx2a_buf + Internal_DAC_L3) /</span></span><br><span class="line"><span class="comment">/  5      Internal DAC 3 Right Channel            DM(_tx2a_buf + 5) = DM(_tx2a_buf + Internal_DAC_R3) /</span></span><br><span class="line"><span class="comment">/                                                                                                     /</span></span><br><span class="line"><span class="comment">/  tx2b_buf[2] - DSP SPORT2 B transmit buffer - AD1939 DSDATA4                                        /</span></span><br><span class="line"><span class="comment">/  Slot # Description                             DSP Data Memory Address                             /</span></span><br><span class="line"><span class="comment">/  ------ --------------------------------------  --------------------------------------------------  /</span></span><br><span class="line"><span class="comment">/  6      Internal DAC 4 Left Channel             DM(_tx2b_buf + 6) = DM(_tx2b_buf + Internal_DAC_L4) /</span></span><br><span class="line"><span class="comment">/  7      Internal DAC 4 Right Channel            DM(_tx2b_buf + 7) = DM(_tx2b_buf + Internal_DAC_R4) /</span></span><br><span class="line"><span class="comment">/                                                                                                     /</span></span><br><span class="line"><span class="comment">******************************************************************************************************/</span></span><br></pre></td></tr></table></figure>
<h2 id="sptcl寄存器操作">SPTCL寄存器操作</h2>
<p>下方代码是官方示例给出，并经过唐昊整合修改过，其寄存器设置的功能解读和验证如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*pSPCTL0 = (SPTRAN | OPMODE | SLEN32 | SPEN_A | SCHEN_A | SDEN_A | SPEN_B | SCHEN_B | SDEN_B);</span><br><span class="line">*pSPCTL1 = (OPMODE | SLEN32 | SPEN_A | SCHEN_A | SDEN_A | SPEN_B | SCHEN_B | SDEN_B);</span><br><span class="line">*pSPCTL2 = (OPMODE | SLEN32 | SPEN_A | SCHEN_A | SDEN_A | SPEN_B | SCHEN_B | SDEN_B);</span><br></pre></td></tr></table></figure>
<p><strong>SPTRAN</strong>: Serial port Data Transfer Direction. Transfer / Receive from both Channel A and Channel B. 需要注意的是，传输和接收功能只有一个会在 <code>SOPRTx_CLK</code> 和 <code>SPORTx_FS</code> 控制 <strong><em>传输/接收位移寄存器</em></strong>（Transmit/Receive shift register） 时被激活。</p>
<p><strong>OPMODE</strong>: SPORT Operation Mode, <strong><em>I2S</em></strong> / <strong><em>packed</em></strong>, <strong><em>left-justified</em></strong> mode</p>
<p><strong>SLEN32</strong>: Serial port word length, in I2S / left-justified mode , we used SLEN8 ~ SLEN32. <mark>但实际上，1772输出的I2S声道字长度是24bits</mark>。</p>
<p><strong>SPEN_A</strong>: Serial port <strong><em>Channel A DMA</em></strong> enabled.</p>
<p><strong>SCHEN_A</strong>: Serial port <strong><em>Channel A DMA Chainning</em></strong> enabled.</p>
<p><strong>SDEN_A</strong>: Serial port <strong><em>Channel A DMA</em></strong> enabled.</p>
<p><strong>SPEN_B</strong>: Serial port <strong><em>Channel B DMA</em></strong> enabled.</p>
<p><strong>SCHEN_B</strong>: Serial port <strong><em>Channel B DMA Chainning</em></strong> enabled.</p>
<p><strong>SDEN_B</strong>: Serial port <strong><em>Channel B DMA</em></strong> enabled.</p>
<p>通过查询表《HWR》中的表A-84可知，SPORT 0 ~ 2 的设置符合 0用于传输，1和2用于接收的要求。</p>
<figure>
<img src="https://pic.islet.space/2021/07/20210702110602.png" alt="image-20210702110559930" /><figcaption aria-hidden="true">image-20210702110559930</figcaption>
</figure>
<p>需要尽可能拉高逻辑分析仪的采样频率，如24MHz以上。</p>
<figure>
<img src="https://pic.islet.space/2021/07/20210702111537.png" alt="image-20210702111535166" /><figcaption aria-hidden="true">image-20210702111535166</figcaption>
</figure>
<p>1772下I2S的数据深度为16 ~ 24bit，后面的长度都会由0补齐，采集显示设置时可以设置32bit或24bit皆可。</p>
<figure>
<img src="https://pic.islet.space/2021/07/20210702113337.png" alt="image-20210702113249646" /><figcaption aria-hidden="true">image-20210702113249646</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/20210702113543.png" alt="image-20210702113540262" /><figcaption aria-hidden="true">image-20210702113540262</figcaption>
</figure>
<h1 id="asrc-of-adau1772">ASRC OF ADAU1772</h1>
<p>ADAU1772 master clock input, but the LRCLK and BCLK must be synchronous to each other. The LRCLK and BCLK pins are used to clock both the serial input and output ports.</p>
<p>ADAU1772 can be set to be either the master or the slave in a system. <mark>Because there is only one set of serial data clocks, the input and output ports must always both be either master or slave.</mark></p>
<p>It is <mark>recommended to use the high drive settings on the serial port pins</mark>.</p>
<p>串行音频接口的通信时序说明图如下，</p>
<p>其中， t<sub>SOD</sub> 是指：ADC_SDATAx delay; time from BCLK falling (master and slave modes)。从下图中看出PDM（ LJ / RJ / I2S ）都有 t<sub>SOD</sub> 。</p>
<p><img src="https://pic.islet.space/2021/07/20210702135103.png" alt="image-20210702111739875" style="zoom: 80%;" /></p>
<p>虽然同样是I2S，且LJ的标准和飞利浦I2S的标准都是左端对齐，但是飞利浦的数据会比LRCLK延时一个完整的时钟周期。而标准LJ则是LRCLK、BCLK 和 SDATA 完全对齐。</p>
<h2 id="通信时钟要求">通信时钟要求</h2>
<p>量产版采用统一的 <code>16.6MHz</code> 为2个codecs和1个DSP主芯片提供时钟。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210705151852538.png" alt="image-20210705151852538" /><figcaption aria-hidden="true">image-20210705151852538</figcaption>
</figure>
<p>异步设备通信开发顺利的前提要求是两者的通信时钟能否保持一致，即最关键的通信时钟信号（<strong><em>BCLK</em></strong> / <strong><em>LRCLK</em></strong>）是否符合设定要求(3.072MHz / 48KHz)。</p>
<figure>
<img src="https://pic.islet.space/2021/07/20210705084415.png" alt="image-20210705084133066" /><figcaption aria-hidden="true">image-20210705084133066</figcaption>
</figure>
<p>使用逻辑分析仪去测量音频设备的输出 <strong>帧时钟</strong>（LRCLK） 频率，如果其时钟输出结果符合设置的 <code>48KHz</code> 要求，则说明正确。其 <strong>位时钟频率要求</strong> 应等于 <code>帧时钟长度 * 数据深度 * 2</code> ，如 帧时钟频率为48KHz的 位时钟频率为 <code>48KHz * 32bits * 2</code> ，大致等于 <code>3.072 MHz</code> 。</p>
<p><strong>注意</strong>：逻辑分析仪能否清晰测量和指示波形周期，仍需要该设备自身支持较高频率的采样速率，最好采样速率能与需要采样的目标速率成倍数关系。如果速率过低，则会出现采样变形。如下图中的位时钟采样和测量为 <code>3MHz</code> ，中途会偶然出现 <code>3.429MHz</code>。</p>
<figure>
<img src="https://pic.islet.space/2021/07/20210705095045.png" alt="image-20210705095017424" /><figcaption aria-hidden="true">image-20210705095017424</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/20210705095205.png" alt="image-20210705095203461" /><figcaption aria-hidden="true">image-20210705095203461</figcaption>
</figure>
<p>在设置错误时，会出现如下情况：</p>
<figure>
<img src="https://pic.islet.space/2021/07/20210705085250.png" alt="image-20210705085041206" /><figcaption aria-hidden="true">image-20210705085041206</figcaption>
</figure>
<p>在21479上设置好I2S的 slave端 代码，被动接收master端音频并转发回给master端，而ADAU1772在使用USBi单独通信设置好通信频率48KHz后，成功与21479实现全双工音频转发。</p>
<p>在评估版用户手册中，提示需要16.625MHz的时钟提供给DSP21479。通过修改量产板上codec的PLL寄存器设置，发现 <code>16.625MHz</code> 无效，设置时不起作用，因为与所提供的时钟频率（16.6MHz）不符。</p>
<p><img src="https://pic.islet.space/2021/07/20210705134121.png" alt="image-20210705104426587" style="zoom: 50%;" /></p>
<p><img src="https://pic.islet.space/2021/07/image-20210705143238320.png" alt="image-20210705143238320" style="zoom: 80%;" /></p>
<p>设置成 <code>16.6MHz</code> 则可以工作，能够顺利采集到数据（暂停时刻查看缓存数据）。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210705143246050.png" alt="image-20210705143246050" style="zoom: 80%;" /></p>
<p><img src="https://pic.islet.space/2021/07/image-20210705143606164.png" alt="image-20210705143606164" style="zoom:67%;" /></p>
<p>仔细阅读以下寄存器信息。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210705145709904.png" alt="image-20210705145709904" /><figcaption aria-hidden="true">image-20210705145709904</figcaption>
</figure>
<p><strong>注意</strong>：SigmaStudio中，设置 <strong>输入时钟信号</strong>（MCLK input）和 <strong>输出时钟信号</strong>（VCO Output）后，仅有 <strong>输入信号分频</strong>（input clock divider，下简称 <strong><em>ICD</em></strong>）是可以设置的，其他参数由 <code>load parameters</code> 自动计算。在 <strong><em>输入频率</em></strong> <code>16.6MHz</code> 和 <strong><em>输出频率</em></strong> <code>24.576MHz</code> 不变的情况下，改变 输入信号分频 以生成下表：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>ICD = 1</th>
<th>ICD = 2</th>
<th>ICD = 3</th>
<th>ICD = 4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PLL_CTRL0</td>
<td>0x08</td>
<td>0x08</td>
<td>0x08</td>
<td>0x08</td>
</tr>
<tr class="even">
<td>PLL_CTRL1</td>
<td>0x1B</td>
<td>0x1B</td>
<td>0x1B</td>
<td>0x1B</td>
</tr>
<tr class="odd">
<td>PLL_CTRL2</td>
<td>0x07</td>
<td>0x07</td>
<td>0x17</td>
<td>0x1F</td>
</tr>
<tr class="even">
<td>PLL_CTRL3</td>
<td>0xCA</td>
<td>0x79</td>
<td>0x5E</td>
<td>0x28</td>
</tr>
<tr class="odd">
<td>PLL_CTRL4</td>
<td>0x11</td>
<td>0x2B</td>
<td>0x35</td>
<td>0x47</td>
</tr>
<tr class="even">
<td>PLL_CTRL5</td>
<td>0x01</td>
<td>0x01</td>
<td>0x01</td>
<td>0x01</td>
</tr>
</tbody>
</table>
<ul>
<li><code>PLL_CTRL0</code> 和 <code>PLL_CTRL1</code> 分别构成 PLL分母（denominator）的高位和低位。</li>
<li><code>PLL_CTRL2</code> 和 <code>PLL_CTRL3</code> 分别构成 PLL分子（numerator）的高位和低位。</li>
<li><code>PLL_CTRL4</code> 控制着 <strong>PLL类型</strong>（整数型/分数型）、<strong>输入时钟分频</strong>（1 - 4）和 PLL设置的 <strong>整数部分</strong>。</li>
<li><code>PLL_CTRL5</code> 目前只能是 <code>0x00</code> 或 <code>0x01</code> 。</li>
</ul>
<p>以下为PLL_CTRL4寄存器的位描述：n</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210706101429733.png" alt="image-20210706101429733" /><figcaption aria-hidden="true">image-20210706101429733</figcaption>
</figure>
<p>至于 <code>CLK_CONTROL</code> 寄存器，主要是数值 <code>0x89</code> 和 <code>0x8F</code> 的差别。见下表可知，是关于PLL分频的问题。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210705153843902.png" alt="image-20210705153843902" /><figcaption aria-hidden="true">image-20210705153843902</figcaption>
</figure>
<p>通过自行编写的代码，遍历所有可更改的系数进行计算求解，取得小数点后9位精度，并且符合要求的系数如下（含1/2系数）：</p>
<p>根据PLL_CTRL4寄存器，ICD=3、IS=8时，该寄存器的值为 <code>01000101</code> ，即 <code>0x45</code> 。（下图IDC更正为ICD）</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210706001243698.png" alt="image-20210706001243698" /><figcaption aria-hidden="true">image-20210706001243698</figcaption>
</figure>
<p>以下为不含1/2系数的结果：</p>
<p>根据PLL_CTRL4寄存器，ICD=3、IS=4时，该寄存器的值为 <code>00100101</code> ，即 <code>0x25</code> 。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210706001350802.png" alt="image-20210706001350802" /><figcaption aria-hidden="true">image-20210706001350802</figcaption>
</figure>
<ul>
<li>CLK_IN mean value is 16.6Mhz</li>
<li>LRCLK mean value is 45.92Khz</li>
</ul>
<h1 id="anc主板硬件量产">ANC主板硬件（量产）</h1>
<p>以下为ADAU1772的特征：</p>
<p><strong>Master clock</strong> = <strong>core clock</strong> = 12.288 MHz</p>
<p><strong>serial input sample rate</strong> = 48 kHz</p>
<p><strong>measurement bandwidth</strong> = 20 Hz to 20 kHz</p>
<p><strong>word width</strong> = 24 bits</p>
<p><strong>ambient temperature</strong> = 25°C</p>
<p><strong>outputs line loaded</strong> with 10 kΩ</p>
<p>Codec A是接了DAC输出的，Codec B没有，其地址分别为 <code>0x3D</code> 与 <code>0x3E</code>。</p>
<h2 id="twi-i2c">TWI (I2C)</h2>
<table>
<thead>
<tr class="header">
<th></th>
<th>Codec A</th>
<th>Codec B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SCK</td>
<td>DPI_P08</td>
<td>DPI_P08</td>
</tr>
<tr class="even">
<td>SDA</td>
<td>DPI_P07</td>
<td>DPI_P07</td>
</tr>
<tr class="odd">
<td>ADDR0</td>
<td>+3.3VA</td>
<td>AGND</td>
</tr>
<tr class="even">
<td>ADDR1</td>
<td>AGND</td>
<td>+3.3VA</td>
</tr>
</tbody>
</table>
<h2 id="i2s">I2S</h2>
<table>
<thead>
<tr class="header">
<th></th>
<th>Codec A</th>
<th>Codec B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ADC_SDATA_0</td>
<td>DAI_P13</td>
<td>DAI_P15</td>
</tr>
<tr class="even">
<td>ADC_SDATA_1 <em>(clock)</em></td>
<td>DAI_P03</td>
<td>DAI_P16</td>
</tr>
<tr class="odd">
<td>LRCLK</td>
<td>DAI_P02</td>
<td>DAI_P11 (<em>useless</em>)</td>
</tr>
<tr class="even">
<td>BCLK</td>
<td>DAI_P01</td>
<td>DAI_P12 (<em>useless</em>)</td>
</tr>
<tr class="odd">
<td>DAC_SDATA</td>
<td>DAI_P07</td>
<td>/</td>
</tr>
</tbody>
</table>
<p><img src="https://pic.islet.space/2021/07/20210702100719.png" alt="image-20210702100716720" style="zoom:80%;" /></p>
<p><img src="https://pic.islet.space/2021/07/20210702101017.png" alt="image-20210702100920210" style="zoom:67%;" /><img src="https://pic.islet.space/2021/07/20210702101020.png" alt="image-20210702101004870" style="zoom:67%;" /></p>
<h2 id="spi">SPI</h2>
<table>
<thead>
<tr class="header">
<th></th>
<th>FLASH</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SPI_SOMI</td>
<td>DPI_P01</td>
</tr>
<tr class="even">
<td>SPI_SIMO</td>
<td>DPI_P02</td>
</tr>
<tr class="odd">
<td>SPI_CLK</td>
<td>DPI_P03</td>
</tr>
<tr class="even">
<td>SPI_SCS</td>
<td>DPI_P05</td>
</tr>
</tbody>
</table>
<h1 id="参考">参考</h1>
<ol type="1">
<li><p>《<a href="">I2S bus specification</a>》</p></li>
<li><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/I2S/3443390">I2S</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/q2519008/article/details/80413695">【音频】I2S协议详解</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/353520173">I2S/PCM</a></p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/06/21/Programming/C/2021-06-21-%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/21/Programming/C/2021-06-21-%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">存储类别、链接和内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-21 21:50:00 / Modified: 22:12:11" itemprop="dateCreated datePublished" datetime="2021-06-21T21:50:00+08:00">2021-06-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="存储类别">存储类别</h1>
<p>即 stroage class，C语言提供了多种不同的模型和存储类别在内存中存储数据。</p>
<blockquote>
<p>从硬件方面看， 被存储的每个值都占有一定的物理内存，C语言称之为对象（object）。</p>
<p>与面向对象编程中的对象不同，面向对象编程的对象指的是“类对象”。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> entity = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>该声明创造了一个名为 entity 的 <strong>标识符</strong>（identifier）。标识符可以用来 <strong>指定</strong>（desingate）特定对象的内容，且须遵循变量的命名规则。</p>
<p>标识符即 软件（C语言）指定硬件内存中的对象（内存区块）的方式。</p>
<p>同时，那些指定对象的表达式被称为 <strong>左值</strong>。</p>
<p>左值可以被理解为是 “有具体存储位置的 <strong>对象</strong> ”，区别于 “仅有值而没有具体存储位置” 的数据。</p>
<p>另，左值中也有可修改的 <strong>普通左值</strong>， 和不能支持修改的 <strong>常量左值</strong>。</p>
<blockquote>
<p><em>“左”(left)的原意是指可以放在赋值符号“=”的左边，但其实也表示能作为&amp;和++等操作符的操作数（B语言中已经如此）。而且，现代C/C++中的含义已经不局限于此。lvalue的 <code>l</code> 被重新解释为location。这也对应于ISO C11/ISO C++11的 <strong>内存位置</strong>(memory location)。</em></p>
<p>——百度百科</p>
</blockquote>
<p>从一个左值中必定可以解析出对应对象的地址，除非该对象是位字段（bit-field）或者被声明为寄存器存储类。生成左值的运算符包括下标运算符（subscript operator）[]和间接运算符（indirection operator）*，如下表所示（如果 array 已被声明为数组，而 ptr 被声明为指针变量）。</p>
<table>
<thead>
<tr class="header">
<th>表达式</th>
<th>是左值吗</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>array[1]</td>
<td>是；一个数组元素是一个具有位置的对象</td>
</tr>
<tr class="even">
<td>&amp;array[1]</td>
<td>否；此对象的位置，并非一个具有位置的对象</td>
</tr>
<tr class="odd">
<td>ptr</td>
<td>是；此指针变量是一个具有位詈的对象</td>
</tr>
<tr class="even">
<td>*ptr</td>
<td>是；指针所指的地方是一个具有位置的对象</td>
</tr>
<tr class="odd">
<td>ptr+1</td>
<td>否；此加法产生一个新的地址值，但不是一个对象</td>
</tr>
<tr class="even">
<td>*ptr+l</td>
<td>否；此加法产生一个新的算术值，但不是一个对象</td>
</tr>
</tbody>
</table>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《C Primer Plus》, Stephen Prata</li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B7%A6%E5%80%BC">左值</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/281.html">C语言左值与右值详解</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/31/Programming/C++/2021-05-31-C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%88try-catch-throw%EF%BC%89%E5%AE%8C%E5%85%A8%E6%94%BB%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/31/Programming/C++/2021-05-31-C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%88try-catch-throw%EF%BC%89%E5%AE%8C%E5%85%A8%E6%94%BB%E7%95%A5/" class="post-title-link" itemprop="url">C++异常处理（try catch throw）完全攻略</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-31 23:05:00" itemprop="dateCreated datePublished" datetime="2021-05-31T23:05:00+08:00">2021-05-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-01 22:21:27" itemprop="dateModified" datetime="2021-06-01T22:21:27+08:00">2021-06-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/422.html">c.biancheng.net</a></p>
<p>程序运行时常会碰到一些异常情况，例如：</p>
<ul>
<li>做除法的时候除数为 0；</li>
<li>用户输入年龄时输入了一个负数；</li>
<li>用 new 运算符动态分配空间时，空间不够导致无法分配；</li>
<li>访问数组元素时，下标越界；打开文件读取时，文件不存在。</li>
</ul>
<p>这些异常情况，如果不能发现并加以处理，很可能会导致程序崩溃。</p>
<blockquote>
<p>所谓“处理”，可以是给出错误提示信息，然后让程序沿一条不会出错的路径继续执行；</p>
<p>也可能是不得不结束程序，但在结束前做一些必要的工作，如将内存中的数据写入文件、关闭打开的文件、释放动态分配的内存空间等。</p>
</blockquote>
<p><strong>一发现异常情况就立即处理未必妥当，因为在一个函数执行过程中发生的异常，在有的情况下由该函数的调用者决定如何处理更加合适。 尤其像库函数这类提供给程序员调用，用以完成与具体应用无关的通用功能的函数，执行过程中贸然对异常进行处理，未必符合调用它的程序的需要。</strong></p>
<p><strong>此外，将异常分散在各处进行处理不利于代码的维护，尤其是对于在不同地方发生的同一种异常，都要编写相同的处理代码也是一种不必要的重复和冗余。如果能在发生各种异常时让程序都执行到同一个地方，这个地方能够对异常进行集中处理，则程序就会更容易编写、维护。</strong></p>
<p>鉴于上述原因，<a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 引入了异常处理机制。其基本思想是：</p>
<blockquote>
<p>函数 A 在执行过程中发现异常时可以不加处理，而只是“拋出一个异常”给 A 的调用者，假定为函数 B。</p>
</blockquote>
<p>拋出异常而不加处理会导致函数 A 立即中止，在这种情况下，函数 B 可以选择捕获 A 拋出的异常进行处理，也可以选择置之不理。如果置之不理，这个异常就会被拋给 B 的调用者，以此类推。</p>
<p>【也就是说，在C++中，异常发生时，是否处理可以由函数的上一级调用函数去决定，如果选择不处理则会将该异常交给更上一级函数去决断。】</p>
<p>如果一层层的函数都不处理异常，异常最终会被拋给最外层的 main 函数。main 函数应该处理异常。如果main函数也不处理异常，那么程序就会立即异常地中止。</p>
<h1 id="c异常处理基本语法">C++异常处理基本语法</h1>
<h2 id="threw语法定义">threw语法定义</h2>
<p>C++ 通过 <code>throw</code> 语句和 <code>try-catch</code> 语句实现对异常的处理。<code>throw</code> 语句的语法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span>  <span class="comment">/*表达式*/</span>;</span><br></pre></td></tr></table></figure>
<p>该语句拋出一个异常。异常是一个表达式，其值的类型可以是 <mark>基本类型</mark>，也可以是 <mark>类</mark>。</p>
<h2 id="try-catch语法定义">try-catch语法定义</h2>
<p><code>try-catch</code> 语句的语法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">//语句组</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in"><span class="keyword">catch</span></span>(<span class="comment">/* 异常类型 */</span>) &#123;</span><br><span class="line">   <span class="comment">//异常处理代码</span></span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"> <span class="built_in"><span class="keyword">catch</span></span>( <span class="comment">/* 异常类型 */</span>) &#123;</span><br><span class="line">   <span class="comment">//异常处理代码</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>catch</code> 可以有多个，但至少要有一个。</p>
<p>不妨把 try 和其后<code>&#123;&#125;</code>中的内容称作“try块”，把 catch 和其后<code>&#123;&#125;</code>中的内容称作“catch块”。</p>
<h2 id="try-catch执行过程">try-catch执行过程</h2>
<p><code>try-catch</code> 语句的执行过程是：</p>
<ul>
<li>执行 try 块中的语句，如果执行的过程中没有异常拋出，那么执行完后就执行最后一个 catch 块后面的语句，所有 catch 块中的语句都不会被执行；</li>
<li>如果 try 块执行的过程中拋出了异常，那么拋出异常后立即跳转到第一个“异常类型”和拋出的异常类型匹配的 catch 块中执行（称作异常被该 catch 块“捕获”），执行完后再跳转到最后一个 catch 块后面继续执行。</li>
</ul>
<h2 id="例程">例程</h2>
<p>例如下面的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">	<span class="keyword">double</span> m ,n;    </span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;    </span><br><span class="line">	<span class="keyword">try</span> &#123;        </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;before dividing.&quot;</span> &lt;&lt; endl;        </span><br><span class="line">		<span class="keyword">if</span>( n == <span class="number">0</span>) <span class="keyword">throw</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; m / n &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;after dividing.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">double</span> d)&#123;</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;catch(double) &quot;</span> &lt;&lt; d &lt;&lt;  endl;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span> e)&#123;</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;catch(int) &quot;</span> &lt;&lt; e &lt;&lt; endl;    </span><br><span class="line">  &#125;    </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;finished&quot;</span> &lt;&lt; endl;    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">9 6</span><br><span class="line">before dividing.</span><br><span class="line">1.5</span><br><span class="line">after dividing.</span><br><span class="line">finished</span><br></pre></td></tr></table></figure>
<p>说明当 n 不为 0 时，try 块中不会拋出异常。因此程序在 try 块正常执行完后，越过所有的 catch 块继续执行，catch 块一个也不会执行。</p>
<p>程序的运行结果也可能如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">9 0</span><br><span class="line">before dividing.</span><br><span class="line">catch\(int) -1</span><br><span class="line">finished</span><br></pre></td></tr></table></figure>
<p>当 n 为 0 时，try 块中会拋出一个整型异常。拋出异常后，try 块立即停止执行。该整型异常会被类型匹配的第一个 catch 块捕获，即进入<code>catch(int e)</code>块执行，该 catch 块执行完毕后，程序继续往后执行，直到正常结束。</p>
<p>如果拋出的异常没有被 catch 块捕获，例如，将<code>catch(int e)</code>，改为<code>catch(char e)</code>，当输入的 n 为 0 时，拋出的整型异常就没有 catch 块能捕获，这个异常也就得不到处理，那么程序就会立即中止，try...catch 后面的内容都不会被执行。</p>
<h1 id="能够捕获任何异常的-catch-语句">能够捕获任何异常的 catch 语句</h1>
<p>如果希望不论拋出哪种类型的异常都能捕获，可以编写如下 catch 块：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这样的 catch 块能够捕获任何还没有被捕获的异常。例如下面的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> m, n;</span><br><span class="line">  cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before dividing.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">throw</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">throw</span> - <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; m / n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after dividing.&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">double</span> d) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;catch (double)&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (...) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;catch (...)&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;    </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;finished&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">9 0</span><br><span class="line">before dividing.</span><br><span class="line">catch (...)</span><br><span class="line">finished</span><br></pre></td></tr></table></figure>
<p>当 n 为 0 时，拋出的整型异常被<code>catchy(...)</code>捕获。</p>
<p>程序的运行结果也可能如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 6</span><br><span class="line">before dividing.</span><br><span class="line">catch (double) -1</span><br><span class="line">finished</span><br></pre></td></tr></table></figure>
<p>当 m 为 0 时，拋出一个 double 类型的异常。虽然<code>catch (double)</code>和<code>catch(...)</code>都能匹配该异常，但是<code>catch(double)</code>是第一个能匹配的 catch 块，因此会执行它，而不会执行<code>catch(...)</code>块。</p>
<p>由于<code>catch(...)</code>能匹配任何类型的异常，它后面的 catch 块实际上就不起作用，因此不要将它写在其他 catch 块前面。</p>
<h1 id="异常的再拋出">异常的再拋出</h1>
<p>如果一个函数在执行过程中拋出的异常在本函数内就被 catch 块捕获并处理，那么该异常就不会拋给这个函数的调用者（也称为“上一层的函数”）；如果异常在本函数中没有被处理，则它就会被拋给上一层的函数。例如下面的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CException</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:    </span><br><span class="line">  string msg;    </span><br><span class="line">  <span class="built_in">CException</span>(string s) : <span class="built_in">msg</span>(s) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Devide</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">throw</span> <span class="built_in">CException</span>(<span class="string">&quot;devided by zero&quot;</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;in Devide&quot;</span> &lt;&lt; endl;    </span><br><span class="line">  <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CountTax</span><span class="params">(<span class="keyword">int</span> salary)</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (salary &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="number">-1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;counting tax&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">int</span>)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;salary &lt; 0&quot;</span> &lt;&lt; endl;    </span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;tax counted&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> salary * <span class="number">0.15</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> f = <span class="number">1.2</span>;    </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">CountTax</span>(<span class="number">-1</span>);  <span class="comment">//此处会报错，立即抛出错误被catch(int)捕获，并终止运行</span></span><br><span class="line">    f = <span class="built_in">Devide</span>(<span class="number">3</span>, <span class="number">0</span>);  <span class="comment">//此处也会报错，在”devided by zero“处立即停止，且没有返回值返回赋给f</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;end of try block&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (CException e)&#123;</span><br><span class="line">    cout &lt;&lt; e.msg &lt;&lt; endl;    </span><br><span class="line">  &#125;    </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;f = &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;finished&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">salary &lt; 0</span><br><span class="line">tax counted</span><br><span class="line">devided by zero</span><br><span class="line">f=1.2</span><br><span class="line">finished</span><br></pre></td></tr></table></figure>
<p>CountTa 函数拋出异常后自行处理，这个异常就不会继续被拋给调用者，即 main 函数。因此在 main 函数的 try 块中，CountTax 之后的语句还能正常执行，即会执行<code>f = Devide(3, 0);</code>。</p>
<p>第 33 行，Devide 函数拋出了异常却不处理，该异常就会被拋给 Devide 函数的调用者，即 main 函数。拋出此异常后，Devide 函数立即结束，第 13 行不会被执行，函数也不会返回一个值，这从第 33 行 f 的值不会被修改可以看出。</p>
<p><code>Devide()</code> 中第 12 行 拋出的异常被 main 函数中类型匹配的 catch 块捕获。第 36 行中的 e 对象是用<strong>复制构造函数初始化</strong>的。</p>
<p><mark>如果拋出的异常是派生类的对象，而 catch 块的异常类型是基类，那么这两者也能够匹配，因为派生类对象也是基类对象。</mark></p>
<blockquote>
<p>虽然函数也可以通过返回值或者传引用的参数通知调用者发生了异常，但采用这种方式的话，每次调用函数时都要判断是否发生了异常，这在函数被多处调用时比较麻烦。有了异常处理机制，可以将多处函数调用都写在一个 try 块中，任何一处调用发生异常都会被匹配的 catch 块捕获并处理，也就不需要每次调用后都判断是否发生了异常。</p>
</blockquote>
<p>有时，虽然在函数中对异常进行了处理，但是还是希望能够通知调用者，以便让调用者知道发生了异常，从而可以作进一步的处理。在 catch 块中拋出异常可以满足这种需要。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CountTax</span><span class="params">(<span class="keyword">int</span> salary)</span></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">  	<span class="keyword">if</span>( salary &lt; <span class="number">0</span> ) <span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;zero salary&quot;</span>);</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;counting tax&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (string s )&#123;</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;CountTax error : &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span>;  <span class="comment">//单写一个throw会把最近的错误传给上一级进行处理</span></span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;tax counted&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> salary * <span class="number">0.15</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> f = <span class="number">1.2</span>;    </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">CountTax</span>(<span class="number">-1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;end of try block&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span>(string s) &#123;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">  &#125;    </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;finished&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CountTax error:zero salary</span><br><span class="line">zero salary</span><br><span class="line">finished</span><br></pre></td></tr></table></figure>
<p>第 12行的<code>throw;</code>没有指明拋出什么样的异常，因此<mark>拋出的就是 catch 块捕获到的异常</mark>，即 <code>string("zero salary”)</code> 。这个异常会被 <code>main</code> 函数中的 <code>catch</code> 块捕获。</p>
<h1 id="函数的异常声明列表">函数的异常声明列表</h1>
<p>为了增强程序的可读性和可维护性，使程序员在使用一个函数时就能看出这个函数可能会拋出哪些异常，C++ 允许在函数声明和定义时，加上它所能拋出的异常的列表，称为 <mark>异常声明列表</mark>，具体写法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>, A, B, C)</span></span>;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>, A, B, C)</span></span>&#123;…&#125;</span><br></pre></td></tr></table></figure>
<p>上面的写法表明 func 可能拋出 int 型、double 型以及 A、B、C 三种类型的异常。异常声明列表可以在函数声明时写，也可以在函数定义时写。如果两处都写，则两处应一致。</p>
<p>如果异常声明列表如下编写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span> <span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>则说明 func 函数不会拋出任何异常。</p>
<p><mark>一个函数如果不交待能拋出哪些类型的异常，就可以拋出任何类型的异常。</mark></p>
<p>函数如果拋出了其异常声明列表中没有的异常，在编译时不会引发错误，但在运行时， Dev C++ 编译出来的程序会出错；用 Visual Studio 2010 编译出来的程序则不会出错，异常声明列表不起实际作用。</p>
<h1 id="c标准异常类">C++标准异常类</h1>
<p>C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的。常用的几个异常类如图 1 所示。</p>
<figure>
<img src="https://pic.islet.space/2021/05/1-1P912101914246.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p style="font-weight: 900; text-align: center;">
图1：常用的异常类
</p>
<p>bad_typeid、bad_cast、bad_alloc、ios_base::failure、out_of_range 都是 exception 类的派生类。<mark>C++ 程序在碰到某些异常时，即使程序中没有写 throw 语句，也会自动拋出上述异常类的对象。这些异常类还都有名为 <code>what()</code> 的成员函数，返回字符串形式的异常描述信息。使用这些异常类需要包含头文件 <code>&lt;stdexcept&gt;</code> 。</mark></p>
<p>下面分别介绍以上几个异常类。本节程序的输出以 Visual Studio 2010为准，Dev C++ 编译的程序输出有所不同。</p>
<h2 id="bad_typeid">1) bad_typeid</h2>
<p>使用 typeid 运算符时，如果其操作数是一个多态类的<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>，而该指针的值为 NULL，则会拋出此异常。</p>
<h2 id="bad_cast">2) bad_cast</h2>
<p>在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常。程序示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="keyword">public</span>:    </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintObj</span><span class="params">(Base &amp; b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    Derived &amp; rd = <span class="keyword">dynamic_cast</span> &lt;Derived &amp;&gt;(b);</span><br><span class="line">    rd.<span class="built_in">Print</span>();    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (bad_cast &amp; e)&#123;</span><br><span class="line">    cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Base b;    </span><br><span class="line">  <span class="built_in">PrintObj</span>(b);    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bad dynamic_cast!</span><br></pre></td></tr></table></figure>
<p>在 PrintObj 函数中，通过 dynamic_cast 检测 b 是否引用的是一个 Derived 对象，如果是，就调用其 <code>Print()</code> 成员函数；如果不是，就拋出异常，不会调用 <code>Derived::Print</code>。</p>
<h2 id="bad_alloc">3) bad_alloc</h2>
<p>在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常。程序示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">char</span> * p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0x7fffffff</span>];</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (bad_alloc &amp; e)&#123;</span><br><span class="line">    cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bad allocation</span><br><span class="line">ios_base::failure</span><br></pre></td></tr></table></figure>
<p>在默认状态下，输入输出流对象不会拋出此异常。如果用流对象的 exceptions 成员函数设置了一些标志位，则在出现打开文件出错、读到输入流的文件尾等情况时会拋出此异常。此处不再赘述。</p>
<h2 id="out_of_range">4) out_of_range</h2>
<p>用 vector 或 string 的 at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v.<span class="built_in">at</span>(<span class="number">100</span>) = <span class="number">100</span>;</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (out_of_range &amp; e) &#123;</span><br><span class="line">    cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;    </span><br><span class="line">  string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">char</span> c = s.<span class="built_in">at</span>(<span class="number">100</span>);</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (out_of_range &amp; e) &#123;</span><br><span class="line">    cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invalid vector subscript</span><br><span class="line">invalid string position</span><br></pre></td></tr></table></figure>
<p>如果将<code>v.at(100)</code>换成<code>v[100]</code>，将<code>s.at(100)</code>换成<code>s[100]</code>，程序就不会引发异常（但可能导致程序崩溃）。因为 at 成员函数会检测下标越界并拋出异常，而 <code>operator[]</code> 则不会。<code>operator[]</code> 相比 at 的好处就是不用判断下标是否越界，因此执行速度更快。</p>
<p>​</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/31/Programming/C++/2021-05-31-C%2011%E5%A4%9A%E7%BA%BF%E7%A8%8Bjoin()%E5%92%8Cdetach()%E7%9A%84%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/31/Programming/C++/2021-05-31-C%2011%E5%A4%9A%E7%BA%BF%E7%A8%8Bjoin()%E5%92%8Cdetach()%E7%9A%84%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">C++11多线程join()和detach()的理解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-31 20:05:00" itemprop="dateCreated datePublished" datetime="2021-05-31T20:05:00+08:00">2021-05-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-01 22:27:16" itemprop="dateModified" datetime="2021-06-01T22:27:16+08:00">2021-06-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36784975/article/details/87699113">blog.csdn.net</a></p>
<h1 id="简介">简介</h1>
<p>每一个程序至少拥有一个线程，那就是执行 <code>main()</code> 函数的主线程，而多线程则是出现两个或两个以上的线程并行运行，即主线程和子线程在同一时间段同时运行。而在这个过程中会出现几种情况：</p>
<ol type="1">
<li>主线程先运行结束</li>
<li>子线程先运行结束</li>
<li>主子线程同时结束</li>
</ol>
<p>在一些情况下需要在子线程结束后主线程才能结束，而一些情况则不需要等待，但需注意一点，并不是主线程结束了其他子线程就立即停止，其他子线程会进入后台运行</p>
<h1 id="join">join()</h1>
<p>join()函数是一个等待线程完成函数，<mark>主线程需要等待子线程运行结束了才可以结束</mark></p>
<p><img src="https://pic.islet.space/2021/05/image-20210531223156398.png" alt="image-20210531223156398" style="zoom:80%;" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">-10</span>; i &gt; <span class="number">-20</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;from func():&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  <span class="comment">//主线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;  <span class="comment">//子线程</span></span><br><span class="line">	t.<span class="built_in">join</span>();  <span class="comment">//等待子线程结束后才进入主线程</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://pic.islet.space/2021/05/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Nzg0OTc1,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">-10</span>; i &gt; <span class="number">-20</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;from func():&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>			<span class="comment">//主线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;	<span class="comment">//子线程</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	t.<span class="built_in">join</span>();		<span class="comment">//等待子线程结束后才进入主线程</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://pic.islet.space/2021/05/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Nzg0OTc1,size_16,color_FFFFFF,t_70-20210531224629846.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">-10</span>; i &gt; <span class="number">-20</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;from func():&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>			<span class="comment">//主线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;	<span class="comment">//子线程</span></span><br><span class="line">	t.<span class="built_in">join</span>();		<span class="comment">//等待子线程结束后才进入主线程</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://pic.islet.space/2021/05/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Nzg0OTc1,size_16,color_FFFFFF,t_70-20210531224634866.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<h1 id="detach">detach()</h1>
<figure>
<img src="https://pic.islet.space/2021/06/image-20210601222337419.png" alt="image-20210601222337419" /><figcaption aria-hidden="true">image-20210601222337419</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">-10</span>; i &gt; <span class="number">-20</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;from func():&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>			<span class="comment">//主线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;	<span class="comment">//子线程</span></span><br><span class="line">	t.<span class="built_in">detach</span>();		<span class="comment">//分离子线程</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://pic.islet.space/2021/05/20190220120254940.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>可以明显看到，主线程太快了，还没等子线程运行就结束了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">-10</span>; i &gt; <span class="number">-20</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;from func():&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>			<span class="comment">//主线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;	<span class="comment">//子线程</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	t.<span class="built_in">detach</span>();		<span class="comment">//分离子线程</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://pic.islet.space/2021/05/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Nzg0OTc1,size_16,color_FFFFFF,t_70-20210531224653683.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>同样没等子线程运行完就结束了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">-10</span>; i &gt; <span class="number">-20</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;from func():&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>			<span class="comment">//主线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;	<span class="comment">//子线程</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mian()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	t.<span class="built_in">detach</span>();		<span class="comment">//分离子线程</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://pic.islet.space/2021/05/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Nzg0OTc1,size_16,color_FFFFFF,t_70-20210531224659144.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>没等子线程运行完就结束</p>
<h1 id="总结">总结</h1>
<ul>
<li><p>如果想要分离一个线程，可以在线程启动后，直接使用 <code>detach()</code> 进行分离。如果打算等待对应线程，则需要细心挑选调用 <code>join()</code> 的位置。当在线程运行之后产生异常，在 <code>join()</code> 调用之前抛出，就意味着很这次调用会被跳过。</p></li>
<li><p><code>join()</code> 函数是一个<strong>等待线程函数</strong>，主线程需等待子线程运行结束后才可以结束（注意不是才可以运行，运行是并行的），如果打算等待对应线程，<mark>则需要细心挑选调用 <code>join()</code> 的位置</mark></p></li>
<li><p><code>detach()</code> 函数是子线程的分离函数，当调用该函数后，线程就被分离到后台运行，<mark>主线程不需要等待该线程结束才结束</mark></p></li>
</ul>
<p>​</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/29/Programming/C++/2021-05-29-C++11-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%B2%BE%E8%AE%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/29/Programming/C++/2021-05-29-C++11-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%B2%BE%E8%AE%B2/" class="post-title-link" itemprop="url">C++11 lambda表达式精讲</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-29 23:30:00 / Modified: 23:51:21" itemprop="dateCreated datePublished" datetime="2021-05-29T23:30:00+08:00">2021-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3741.html">c.biancheng.net</a></p>
<h1 id="编译注意">编译注意</h1>
<p><strong>注意</strong>：在clang上使用lambda表达式时可能会报错，编译时需要添加option <code>-std=c++11</code> 。</p>
<blockquote>
<p>This is because <strong>clang++</strong> <a target="_blank" rel="noopener" href="http://clang.llvm.org/cxx_status.html">by default compiles your code using ISO C++ 1998 standard (including the defects addressed in the ISO C++ 2003 standard) except for 'export' (which has been removed in C++11)</a></p>
<p>Lambdas are part of <a target="_blank" rel="noopener" href="http://clang.llvm.org/">Clang's</a> <a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/LanguageExtensions.html#cxx11">C++11 Language Extension</a>, therefore you need to compile your code with <strong>-std=c++11</strong> or <strong>-std=gnu++11</strong></p>
<p>——<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/13351032/clangs-support-of-c-11-lambda#:~:text=Lambdas%20are%20part%20of%20Clang%27s%20C%2B%2B11%20Language%20Extension%2C,support%20status%20and%20Activating%20C%2B%2B11%20support%20in%20Clang">STACKOVERFLOW</a></p>
</blockquote>
<h1 id="lambda介绍">Lambda介绍</h1>
<p>lambda 表达式是 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a>11 最重要也最常用的一个特性之一，<a target="_blank" rel="noopener" href="http://c.biancheng.net/csharp/">C#</a> 3.5 和 <a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 8 中就引入了 lambda 表达式。</p>
<p>lambda 来源于 <strong>函数式编程</strong> 的概念，也是现代编程语言的一个特点。C++11 这次终于把 lambda 加进来了。</p>
<p>lambda表达式有如下优点：</p>
<ul>
<li><strong>声明式编程风格</strong>：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或者函数对象。以更直接的方式去写程序，好的可读性和可维护性。</li>
<li><strong>简洁</strong>：不需要额外再写一个函数或者函数对象，避免了代码膨胀和功能分散，让开发者更加集中精力在手边的问题，同时也获取了更高的生产率。</li>
<li>在需要的时间和地点实现功能闭包，使程序更灵活。</li>
</ul>
<p>下面，先从 lambda 表达式的基本功能开始介绍它。</p>
<h1 id="lambda-表达式的概念和基本用法">Lambda 表达式的概念和基本用法</h1>
<p>lambda 表达式定义了一个 <strong>匿名函数</strong>，并且可以 <strong>捕获一定范围内的变量</strong>。lambda 表达式的语法形式可简单归纳如下：</p>
<p><code>[ capture ] ( params ) opt -&gt; ret &#123; body; &#125;;</code></p>
<blockquote>
<ul>
<li>capture 是捕获列表</li>
<li>params 是参数表</li>
<li>opt 是函数选项</li>
<li>ret 是返回值类型</li>
<li>body是函数体。</li>
</ul>
</blockquote>
<p>因此，一个完整的 lambda 表达式看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;;std::cout &lt;&lt; <span class="built_in">f</span>(<span class="number">1</span>) &lt;&lt; std::endl;  </span><br></pre></td></tr></table></figure>
<p>可以看到，上面通过一行代码定义了一个小小的功能闭包，用来将输入加 1 并返回。</p>
<p>在 C++11 中，lambda 表达式的返回值是通过前面介绍的《<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3727.html">C++返回值类型后置</a>》语法来定义的。</p>
<p>其实很多时候，lambda 表达式的返回值是非常明显的，比如这个例子。因此，C++11 中允许省略 lambda 表达式的返回值定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a)&#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>这样编译器就会根据 return 语句自动推导出返回值类型。</p>
<p>需要注意的是，初始化列表不能用于返回值的自动推导：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = [](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> i; &#125;; <span class="comment">// OK: return type is int</span></span><br><span class="line"><span class="keyword">auto</span> x2 = []()&#123; <span class="keyword">return</span> &#123; <span class="number">1</span>, <span class="number">2</span> &#125;; &#125;; <span class="comment">// error: 无法推导出返回值类型</span></span><br></pre></td></tr></table></figure>
<p>这时我们需要显式给出具体的返回值类型。</p>
<p>另外，lambda 表达式在没有参数列表时，参数列表是可以省略的。因此像下面的写法都是正确的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f1 = []()&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> f2 = []&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;; <span class="comment">// 省略空参数表</span></span><br></pre></td></tr></table></figure>
<h1 id="捕获列表">捕获列表</h1>
<p>lambda 表达式还可以通过捕获列表捕获一定范围内的变量：</p>
<ul>
<li>[] 不捕获任何变量。</li>
<li>[&amp;] 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li>
<li>[=] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。</li>
<li>[=，&amp;foo] 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。</li>
<li>[bar] 按值捕获 bar 变量，同时不捕获其他变量。</li>
<li>[this] 捕获当前类中的 this <a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 &amp; 或者 =，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。</li>
</ul>
<p>下面看一下它的具体用法，如下所示。</p>
<p>【实例】lambda 表达式的基本用法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">	<span class="keyword">int</span> i_ = <span class="number">0</span>;    </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;        </span><br><span class="line">		<span class="keyword">auto</span> x1 = []&#123; <span class="keyword">return</span> i_; &#125;;                            </span><br><span class="line">		<span class="keyword">auto</span> x2 = [=]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;                   </span><br><span class="line">		<span class="keyword">auto</span> x3 = [&amp;]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;                   </span><br><span class="line">		<span class="keyword">auto</span> x4 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i_; &#125;;                        </span><br><span class="line">		<span class="keyword">auto</span> x5 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;                </span><br><span class="line">		<span class="keyword">auto</span> x6 = [<span class="keyword">this</span>, x, y]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;          </span><br><span class="line">		<span class="keyword">auto</span> x7 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i_++; &#125;;                  </span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = []&#123; <span class="keyword">return</span> a; &#125;;               </span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;]&#123; <span class="keyword">return</span> a++; &#125;;            </span><br><span class="line"><span class="keyword">auto</span> f3 = [=]&#123; <span class="keyword">return</span> a; &#125;;              </span><br><span class="line"><span class="keyword">auto</span> f4 = [=]&#123; <span class="keyword">return</span> a++; &#125;;            </span><br><span class="line"><span class="keyword">auto</span> f5 = [a]&#123; <span class="keyword">return</span> a + b; &#125;;          </span><br><span class="line"><span class="keyword">auto</span> f6 = [a, &amp;b]&#123; <span class="keyword">return</span> a + (b++); &#125;;  </span><br><span class="line"><span class="keyword">auto</span> f7 = [=, &amp;b]&#123; <span class="keyword">return</span> a + (b++); &#125;;  </span><br></pre></td></tr></table></figure>
<p>从上例中可以看到，lambda 表达式的捕获列表精细地控制了 lambda 表达式能够访问的外部变量，以及如何访问这些变量。</p>
<p><strong>注意</strong>：默认状态下 lambda 表达式无法修改通过复制方式捕获的外部变量。如果希望修改这些变量的话，我们需要使用引用方式进行捕获。</p>
<p>一个容易出错的细节是关于 lambda 表达式的延迟调用的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [=]&#123; <span class="keyword">return</span> a; &#125;;      </span><br><span class="line">a += <span class="number">1</span>;                         </span><br><span class="line">std::cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; std::endl;  </span><br></pre></td></tr></table></figure>
<p>在这个例子中，lambda 表达式按值捕获了所有外部变量。在捕获的一瞬间，a 的值就已经被复制到f中了。之后 a 被修改，但此时 f 中存储的 a 仍然还是捕获时的值，因此，最终输出结果是 0。</p>
<p>如果希望 lambda 表达式在调用时能够即时访问外部变量，我们应当使用引用方式捕获。</p>
<p>从上面的例子中我们知道，按值捕获得到的外部变量值是在 lambda 表达式定义时的值。此时所有外部变量均被复制了一份存储在 lambda 表达式变量中。此时虽然修改 lambda 表达式中的这些外部变量并不会真正影响到外部，我们却仍然无法修改它们。</p>
<p>那么如果希望去修改按值捕获的外部变量应当怎么办呢？这时，需要显式指明 lambda 表达式为 mutable：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [=]&#123; <span class="keyword">return</span> a++; &#125;;             </span><br><span class="line"><span class="keyword">auto</span> f2 = [=]() <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> a++; &#125;;  </span><br></pre></td></tr></table></figure>
<p>需要注意的一点是，被 mutable 修饰的 lambda 表达式就算没有参数也要写明参数列表。</p>
<h1 id="lambda-表达式的类型">Lambda 表达式的类型</h1>
<p>最后，介绍一下 lambda 表达式的类型。</p>
<p>lambda 表达式的类型在 C++11 中被称为“闭包类型（Closure Type）”。它是一个特殊的，匿名的非 nunion 的类类型。</p>
<p>因此，我们可以认为它是一个带有 operator() 的类，即仿函数。因此，我们可以使用 std::function 和 std::bind 来存储和操作 lambda 表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt;  f1 = [](<span class="keyword">int</span> a)&#123; <span class="keyword">return</span> a; &#125;;std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">void</span>)&gt; f2 = std::<span class="built_in">bind</span>([](<span class="keyword">int</span> a)&#123; <span class="keyword">return</span> a; &#125;, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p>另外，对于没有捕获任何变量的 lambda 表达式，还可以被转换成一个普通的函数指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">func_t</span> = <span class="built_in"><span class="keyword">int</span></span>(*)(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">func_t</span> f = [](<span class="keyword">int</span> a)&#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p>lambda 表达式可以说是就地定义仿函数闭包的“语法糖”。它的捕获列表捕获住的任何外部变量，最终均会变为闭包类型的成员变量。而一个使用了成员变量的类的 operator()，如果能直接被转换为普通的函数指针，那么 lambda 表达式本身的 this 指针就丢失掉了。而没有捕获任何外部变量的 lambda 表达式则不存在这个问题。</p>
<p>这里也可以很自然地解释为何按值捕获无法修改捕获的外部变量。因为按照 C++ 标准，lambda 表达式的 operator() 默认是 const 的。一个 const 成员函数是无法修改成员变量的值的。而 mutable 的作用，就在于取消 operator() 的 const。</p>
<p>需要注意的是，没有捕获变量的 lambda 表达式可以直接转换为函数指针，而捕获变量的 lambda 表达式则不能转换为函数指针。看看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Ptr)</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line">Ptr p = [](<span class="keyword">int</span>* p)&#123;<span class="keyword">delete</span> p;&#125;;  </span><br><span class="line">Ptr p1 = [&amp;](<span class="keyword">int</span>* p)&#123;<span class="keyword">delete</span> p;&#125;;  </span><br></pre></td></tr></table></figure>
<p>上面第二行代码能编译通过，而第三行代码不能编译通过，因为第三行的代码捕获了变量，不能直接转换为函数指针。</p>
<h1 id="声明式的编程风格简洁的代码">声明式的编程风格，简洁的代码</h1>
<p>就地定义匿名函数，不再需要定义函数对象，大大简化了标准库算法的调用。比如，在 C++11 之前，我们要调用 for_each 函数将 vector 中的偶数打印出来，如下所示。</p>
<p>【实例】lambda 表达式代替函数对象的示例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountEven</span>&#123;</span>    </span><br><span class="line">	<span class="keyword">int</span>&amp; count_;<span class="keyword">public</span>:    </span><br><span class="line">	<span class="built_in">CountEven</span>(<span class="keyword">int</span>&amp; count) : <span class="built_in">count_</span>(count) &#123;&#125;    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span>    </span>&#123;        <span class="keyword">if</span> (!(val &amp; <span class="number">1</span>))               &#123;            ++ count_;        &#125;    &#125;&#125;;</span><br><span class="line">	std::vector&lt;<span class="keyword">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> even_count = <span class="number">0</span>;for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">CountEven</span>(even_count));std::cout &lt;&lt; <span class="string">&quot;The number of even is &quot;</span> &lt;&lt; even_count &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>这样写既烦琐又容易出错。有了 lambda 表达式以后，我们可以使用真正的闭包概念来替换掉这里的仿函数，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> even_count = <span class="number">0</span>;</span><br><span class="line">for_each( v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [&amp;even_count](<span class="keyword">int</span> val)        &#123;            <span class="keyword">if</span> (!(val &amp; <span class="number">1</span>))              &#123;                ++ even_count;            &#125;        &#125;);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The number of even is &quot;</span> &lt;&lt; even_count &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>lambda 表达式的价值在于，就地封装短小的功能闭包，可以极其方便地表达出我们希望执行的具体操作，并让上下文结合得更加紧密。</p>
<p>​</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/29/Programming/C++/2021-05-29-C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/29/Programming/C++/2021-05-29-C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">C++多线程笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-29 21:28:00" itemprop="dateCreated datePublished" datetime="2021-05-29T21:28:00+08:00">2021-05-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-31 22:29:50" itemprop="dateModified" datetime="2021-05-31T22:29:50+08:00">2021-05-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="线程创建">线程创建</h1>
<p>C++中对线程的创建都需要使用到库函数 <code>&lt;thread&gt;</code> ，但是线程的启动和使用可以通过 <strong><em>函数</em></strong> 和 <strong><em>带有函数调用操作符的类实例</em></strong> 来进行。</p>
<h2 id="函数式启动">函数式启动</h2>
<h3 id="函数名启动">函数名启动</h3>
<p>无论是从何处启用多线程，都需要从C++线程库 <code>&lt;thread&gt;</code> 来开始一个线程，通过构造一个 <code>std::thread</code> 对象来启动，以下为最常见的线程创建方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadHello</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">thread1</span><span class="params">(threadHello)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>threadHello()</code> 就是需要执行线程的函数；</p>
<p><code>std::thread</code> 就是创建线程对象的类型；</p>
<p><code>thread1</code> 就是被创造的线程对象，而 <code>()</code> 中则填写着被这个对象调用的函数。</p>
</blockquote>
<h3 id="函数启动">函数启动</h3>
<p>不同于通过函数名启动，函数启动时会带上其括号 <code>()</code> ， 多个线程可被同时被一个线程对象启动。</p>
<p>式1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">((background_task()))</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，通过第二层外层 <code>()</code> 将函数及其 <code>()</code> 括起来避免被解释为函数声明，即 <code>my_thread( ( f() ) )</code> 。</p>
<p>式2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::thread my_thread&#123; <span class="built_in">background_task</span>() &#125;;</span><br></pre></td></tr></table></figure>
<p>通过将 <code>background()</code> 包括在 <code>&#123;&#125;</code> 中，同样是将 <code>background()</code> 声明为一个变量的方法。</p>
<h3 id="lambda表达式">Lambda表达式</h3>
<p>lambda表达式是在C++11以后的新特性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 类实例启动</span><br><span class="line"></span><br><span class="line">`std::thread` 可以与任何 可调用（callable）类型一同工作，因此可以将一个带有函数调用操作符的类的实例传递给 `std::thread` 的构造函数来进行代替。</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">background_task</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;   <span class="comment">//带有函数调用操作符</span></span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">    <span class="built_in">do_something_else</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">background_task threadF;  <span class="comment">//类实例</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">thread1</span><span class="params">(threadF)</span></span>;  <span class="comment">//线程调用该类实例</span></span><br></pre></td></tr></table></figure>
<p>这种情况下，所提供的函数对象被赋值（copied）到属于新创建的执行线程的存储器中，并从那里调用。因此，副本与原版有着灯箱的行为，否则结果可能与预期不符。</p>
<h3 id="函数调用操作符">函数调用操作符</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AA</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	cout&lt;&lt;<span class="string">&quot;aa&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>AA()()</code> 中，<code>AA()</code> 是构造函数，调用了<code>()</code> 操作符。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/27/Linux/Shell/2021-05-27-UnixShell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/27/Linux/Shell/2021-05-27-UnixShell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">UnixShell常用命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-27 23:55:00" itemprop="dateCreated datePublished" datetime="2021-05-27T23:55:00+08:00">2021-05-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-28 00:33:04" itemprop="dateModified" datetime="2021-05-28T00:33:04+08:00">2021-05-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="coreshell">Core/Shell</h1>
<p>首先，要理解Core / shell的概念，系统内核一般被称之为core，而unix及类unix（即与unix类似）系统（如linux）都继承了这一概念，都有其内核。</p>
<p>古早时期，都是一台电脑就是一台服务器，为了提高服务器的利用率，大家都在用很多客户端登录系统，系统分时（电脑高效处理任务，看起来像是同时进行，其实还是存在先后顺序的）为许多客户端提供服务，即“一点对多点”式的服务模式，客户端都通过小黑窗进行操作。</p>
<p>如今，独立PC都已经没了服务器这一概念，一台设备就只为一个客户服务（单点对单点），但是这个小黑窗的高效操作的理念却被保留了下来。</p>
<p>因为所有的客户端对主机的使用都没有进入到内核层面，仅仅停留在表面，所以这种小黑窗的操作层被称为shell层，即外壳。</p>
<p>逐渐衍生了终端的概念，即客户端即用户终端，即terminal；现在shell、terminal、command-line（命令行）这几个概念都可以被视为同一个概念。</p>
<p>但shell的流行，逐渐衍生除了很多个人制作的版本，流行的有bash shell、zsh等。</p>
<h1 id="目录操作">目录操作</h1>
<h2 id="cd">cd</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd zplusplus</span><br></pre></td></tr></table></figure>
<p>即Change directory，改变目录</p>
<p>类unix中没有路径这个概念，只有目录。</p>
<blockquote>
<ul>
<li><p><code>~</code> 主目录，个人目录</p></li>
<li><p><code>/</code> 根目录，硬盘目录</p></li>
</ul>
</blockquote>
<p>TIPS:</p>
<ul>
<li>按<code>tabs</code>键可以快速补全相符的目录名称</li>
</ul>
<p><code>cd ../</code>可以返回上一层文件目录</p>
<figure>
<img src="https://pic.islet.space/2021/05/image-20210528002003445.png" alt="image-20210528002003445" /><figcaption aria-hidden="true">image-20210528002003445</figcaption>
</figure>
<h2 id="mkdir">mkdir</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir zplusplus</span><br></pre></td></tr></table></figure>
<p>即make directory，创建目录</p>
<figure>
<img src="https://pic.islet.space/2021/05/image-20210528001730316.png" alt="image-20210528001730316" /><figcaption aria-hidden="true">image-20210528001730316</figcaption>
</figure>
<h2 id="mv">mv</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv zplusplus</span><br></pre></td></tr></table></figure>
<p>即move，移动或删除</p>
<blockquote>
<ul>
<li><code>-f</code> force 强制</li>
</ul>
</blockquote>
<p>也可以用来改名，用法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv main.c test.c</span><br></pre></td></tr></table></figure>
<p>其他类似的语句如 <code>rm</code>，可以参考手册</p>
<h2 id="ls">ls</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>
<p>即List，（展现）列表</p>
<p>这个命令非常好用，学会了就基本忘不了，各别shell能够提供不同的色彩显示，对于文档类型识别来说非常高效。</p>
<figure>
<img src="https://pic.islet.space/2021/05/image-20210528001701289.png" alt="image-20210528001701289" /><figcaption aria-hidden="true">image-20210528001701289</figcaption>
</figure>
<h1 id="文件编辑">文件编辑</h1>
<h2 id="vim">vim</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim main.c</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：如果已经存在了<code>main.c</code> 他就不会新生成一个，否则就会新建。</p>
<p><strong>操作方法</strong>：</p>
<ol type="1">
<li>刚进去的时候需要按 <code>i</code> 进行插入（insert）操作</li>
<li>编辑完毕之后需要先按 <code>ESC</code> 键，在依次输入 <code>:</code> 及其他指令进行退出，具体参考下方，可以看手册。</li>
</ol>
<blockquote>
<p><code>:</code> instructor 指令输入</p>
<p><code>w</code> wirte</p>
<p><code>q</code> quit</p>
<p><code>!</code> 强制</p>
</blockquote>
<p><strong>编辑界面如下</strong>：</p>
<figure>
<img src="https://pic.islet.space/2021/05/image-20210528002252175.png" alt="image-20210528002252175" /><figcaption aria-hidden="true">image-20210528002252175</figcaption>
</figure>
<p><strong>科普视频</strong>：</p>
<iframe src="//player.bilibili.com/player.html?aid=55498503&amp;bvid=BV164411P7tw&amp;cid=97032762&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
<p><strong>自行科普</strong>：GUI，Graphic User Interface 图形用户界面</p>
<h1 id="代码运行">代码运行</h1>
<h2 id="gcc">gcc</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c </span><br></pre></td></tr></table></figure>
<p>是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/gnu/671972">GNU</a>下的GCC编译器之一，c的编译器是<code>gcc</code>，c++的编译器是<code>g++</code></p>
<blockquote>
<ul>
<li><code>-o main</code> 参数</li>
</ul>
</blockquote>
<figure>
<img src="https://pic.islet.space/2021/05/image-20210528002708689.png" alt="image-20210528002708689" /><figcaption aria-hidden="true">image-20210528002708689</figcaption>
</figure>
<p>编译完成之后使用 <code>ls</code> 可以查看已生成的文件 <code>a.out</code>（默认命名）。</p>
<figure>
<img src="https://pic.islet.space/2021/05/image-20210528002757152.png" alt="image-20210528002757152" /><figcaption aria-hidden="true">image-20210528002757152</figcaption>
</figure>
<p>这个 <code>a.out</code> 文件是CPU能够直接识别和运行的文件，因此直接使用以下代码运行即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out</span><br></pre></td></tr></table></figure>
<p>运行效果如下：</p>
<figure>
<img src="https://pic.islet.space/2021/05/image-20210528002900901.png" alt="image-20210528002900901" /><figcaption aria-hidden="true">image-20210528002900901</figcaption>
</figure>
<p>遇到问题可以再进行调试。</p>
<p>对GNU和开源的概念可以参考下方视频：</p>
<iframe src="//player.bilibili.com/player.html?aid=413061830&amp;bvid=BV1zV411d7La&amp;cid=186095567&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备19004822号 </a>
  </div>

<div class="copyright">
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liewzheng</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@8.12.0/dist/mermaid.min.js","integrity":"sha256-0dD7vUjUCTGJjeLnPotQQJIcSzug5fO6WDMYYyNIX4c="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  <script src="/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":"enable","tags":"all","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
