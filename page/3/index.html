<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://code.islet.space/font//css?family=/CascadiaCode/CascadiaCode:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"islet.space","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/db.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>
<meta name="description" content="笔记分享的旮旯孤岛而已">
<meta property="og:type" content="website">
<meta property="og:title" content="Coder的孤岛">
<meta property="og:url" content="http://islet.space/page/3/index.html">
<meta property="og:site_name" content="Coder的孤岛">
<meta property="og:description" content="笔记分享的旮旯孤岛而已">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liewzheng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://islet.space/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Coder的孤岛</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Coder的孤岛</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">islet of the coder</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-文章"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>文章</a></li>
        <li class="menu-item menu-item-目录"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-简历"><a href="/resume/" rel="section"><i class="fa fa-address-card fa-fw"></i>简历</a></li>
        <li class="menu-item menu-item-友链"><a href="/friends/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>友链</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liewzheng</p>
  <div class="site-description" itemprop="description">笔记分享的旮旯孤岛而已</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">101</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">184</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="mailto:liewzheng@foxmail.com" title="E-Mail → mailto:liewzheng@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/15/Hardware/Circuit/2021-07-15-IGBT%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8%E8%8A%AF%E7%89%87%E8%A7%84%E6%A0%BC%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/15/Hardware/Circuit/2021-07-15-IGBT%E5%8F%8A%E5%85%B6%E9%A9%B1%E5%8A%A8%E8%8A%AF%E7%89%87%E8%A7%84%E6%A0%BC%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">IGBT及其驱动芯片规格学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-15 08:50:00" itemprop="dateCreated datePublished" datetime="2021-07-15T08:50:00+08:00">2021-07-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-07-17 14:13:02" itemprop="dateModified" datetime="2021-07-17T14:13:02+08:00">2021-07-17</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hardware/" itemprop="url" rel="index"><span itemprop="name">Hardware</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[TOC]</p>
<p>IGBT和其驱动芯片的电气特性、引脚等参数的开发记录。</p>
<h1 id="igbt">IGBT</h1>
<p>IGBT芯片选型为 IKW50N65WR5。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210715090401339.png" alt="image-20210715090401339" /><figcaption aria-hidden="true">image-20210715090401339</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210715093221500.png" alt="image-20210715093221500" /><figcaption aria-hidden="true">image-20210715093221500</figcaption>
</figure>
<p>IGBT有三个极，发射极、集电极 和 栅极。</p>
<p>从其电气性能表格中，可以看出：</p>
<ul>
<li>集电极到发射极的击穿电压 <em>最小</em> 为650V</li>
<li>在 V<span style="font-size: 0.8rem; font-weight: 500;">GE</span> 完全导通（最高15V）时，集电极到发射极的饱和电压为1.8V以下，此时 IGBT 处于截止状态</li>
<li>在 V<span style="font-size: 0.8rem; font-weight: 500;">GE</span> 完全截止（0V）时，二极管的正向电压为1.9V以下。<mark> 此时，V<span style="font-size: 0.8rem; font-weight: 500;">CE</span> 处于导通状态。</mark></li>
</ul>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210715094151439.png" alt="image-20210715094151439" /><figcaption aria-hidden="true">image-20210715094151439</figcaption>
</figure>
<p>从上方表中可以看出，在官方的《开关特性测试情况》下，V<span style="font-size: 0.8rem; font-weight: 500;">GE</span> 的通电情况是 0V 或者 15V，故此推断给此IGBT的栅极电源输入信号应该是0V ~ 15V的方波。</p>
<p>因此，下图中IGBT器件的电路连接方式为：G 接0/15V方波信号，C 接最高650V电源，E 接地。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210715095656309.png" alt="image-20210715095656309" /><figcaption aria-hidden="true">image-20210715095656309</figcaption>
</figure>
<h1 id="driver-ic">DRIVER IC</h1>
<p>选用芯片型号为 2EDL05I06PF。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210715102359830.png" alt="image-20210715102359830" /><figcaption aria-hidden="true">image-20210715102359830</figcaption>
</figure>
<p>根据表1索引可得，芯片封装类型为DSO-8，目标驱动芯片是 IGBT，而非 MOSFET。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210715102251417.png" alt="image-20210715102251417" /><figcaption aria-hidden="true">image-20210715102251417</figcaption>
</figure>
<p>再根据图3可得芯片引脚分布，根据表2可得所有引脚描述。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210715095931941.png" alt="image-20210715095931941" /><figcaption aria-hidden="true">image-20210715095931941</figcaption>
</figure>
<p>结合表2和图3，再根据图1的典型应用电路，可以大致知道芯片的连接方法。</p>
<table>
<thead>
<tr class="header">
<th>针脚</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>VDD</td>
<td>芯片供电接口</td>
</tr>
<tr class="even">
<td>GND</td>
<td>芯片接地接口</td>
</tr>
<tr class="odd">
<td>HIN</td>
<td>调制波形输入接口——高位</td>
</tr>
<tr class="even">
<td>LIN</td>
<td>调制波形输入接口——低位</td>
</tr>
<tr class="odd">
<td>VB</td>
<td>高位正电</td>
</tr>
<tr class="even">
<td>HO</td>
<td>控制高位IGBT栅极的信号输出接口</td>
</tr>
<tr class="odd">
<td>VS</td>
<td>高位负电</td>
</tr>
<tr class="even">
<td>LO</td>
<td>控制低位IGBT栅极的信号输出接口</td>
</tr>
</tbody>
</table>
<blockquote>
<p>还是不太明白VB和VS的作用</p>
</blockquote>
<p>表4给出了 V<span style="font-size: 0.8rem; font-weight: 500;">DD</span> 和 V<span style="font-size: 0.8rem; font-weight: 500;">B</span> 的供电范围：</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210715105358524.png" alt="image-20210715105358524" /><figcaption aria-hidden="true">image-20210715105358524</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210715105816397.png" alt="image-20210715105816397" /><figcaption aria-hidden="true">image-20210715105816397</figcaption>
</figure>
<p>表6 给出了输入 V<span style="font-size: 0.8rem; font-weight: 500;">IN</span> 的逻辑电平高低的电压范围，高电平为1.7 ~ 2.4 V， 低电平为0.7 ~ 1.1V。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210715103507327.png" alt="image-20210715103507327" /><figcaption aria-hidden="true">image-20210715103507327</figcaption>
</figure>
<p>图2 提供了驱动芯片内部结构示意图</p>
<p>概括地说，IGBT栅极驱动器是一个放大器，其通过提高电压和电流来放大控制信号。</p>
<p>栅极驱动器的主要作用是对 <mark>IGBT的输入和反向输出电容放电</mark>。因此栅极驱动器（初其他影响因素外）与IGBT的开关性能密切相关，也与通态损耗与开关损耗有关。</p>
<p>绝大多数IGBT驱动器都是基于电压源的，与电流源驱动器相比，电压源的优势是其功率损耗在栅极电阻上，而非驱动中的电流源内。通过栅极电阻，可以调整最大的栅极电流。另一优势是，电压源相对简单的电路和控制方法。</p>
<h2 id="驱动功能">驱动功能</h2>
<p>IGBT驱动电路为系统提供的功能：</p>
<ol type="1">
<li>在IGBT开通过程中，栅极处的电容充电直到IGBT的开通阈值电压，反向传输电容（密勒电容）也如此。</li>
<li>在IGBT关断过程中，输入电容放电直到栅极电压达到关断阈值电压以下，反向传输电容（密勒电容）也如此。</li>
<li>IGBT驱动可以具有保护IGBT免受损坏的功能，如 <strong>避免IGBT短路</strong> 和 <strong>过电压保护</strong>。</li>
</ol>
<h2 id="驱动供电">驱动供电</h2>
<p>大部分情况下，IGBT驱动需要用隔离的供电电源。隔离电源可以看做是IGBT驱动的一部分。这些电源一般由 <strong>DC-DC变换器</strong> 或 <strong>自举电路</strong> 构成。</p>
<p>同时，驱动会影响IGBT和续流二极管的动态特性，此外仍须确保IGBT输入电路电压（低压侧）和输出电路（高压侧）的电压隔离。<mark>低压侧与控制电路连接，高压侧与IGBT电路连接。</mark></p>
<h2 id="信号传输">信号传输</h2>
<p>阿博说的电路PCB布局要点：强弱隔离，数模隔离，信号沿地。</p>
<p>IGBT需要隔离的控制信号 包括： <strong>开通信号</strong>、<strong>关断信号</strong>、<strong>反馈信号</strong>。</p>
<p>这些控制信号的传输路径的隔离是通过 <strong>电隔离</strong> 或 <strong>非电隔离</strong> 的方式形成的，这种电隔离被进一步划分为基于磁感应的、光学的隔离，极少情况下是电容性的隔离。需要通过 <strong><em>IGBT阻断电压</em></strong> 或 <strong><em>应用电压的高低</em></strong> 来判断组个方式，在 高压应用 或 IGBT阻隔电压 U<span style="font-size: 0.6rem;">CES</span> 高至 <code>1.2kV</code> 时，采用磁感应式 或 光学式信号传送器；在 低压 或 中压 应用中 或 低于 <code>1.2kV</code> 时，采用光电耦合驱动芯片。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210717130119184.png" alt="image-20210717130119184" style="zoom:50%;" /></p>
<div style="text-align: center; font-weight: 900;">
图 Infineon对电气隔离的定义
</div>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210717115141036.png" alt="image-20210717115141036" /><figcaption aria-hidden="true">image-20210717115141036</figcaption>
</figure>
<h3 id="光电耦合器">光电耦合器</h3>
<p>光电耦合器就是一种可以实现IGBT驱动的同时实现强弱电隔离的器件。由于光电耦合器的结构设计，集成光电耦合器的IGBT只能实现信息传递，不能为任何设备提供充足的能量支撑，需要一个隔离电源为驱动核心和光电耦合器的二次侧（高压侧）提供电能。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210717113118307.png" alt="image-20210717113118307" style="zoom:80%;" /></p>
<p>另外有个相当重要的参数需要考虑——<strong><em>传输延迟时间</em></strong>，即 信号从光电耦合器IGBT输入到控制电流输出的时间。常规而言，传播延迟时间 <em>t</em><span style="font-size: 0.6rem;">PLH</span> 和 <em>t</em><span style="font-size: 0.6rem;">PHL</span> 在几百个纳秒时间，但通常大于200ns。这种延时本身不会构成真正的问题，因为微控制器的控制算法可以考虑这一点，最大的问题在于 延时的公差（传输延迟时间不匹配），即最小和最大延时的不一致性。一旦该公差越大，上下桥臂的IGBT死区时间 <em>t</em><span style="font-size: 0.6rem;">DT</span> 就越大，加重了逆变器输出电流的失真影响。光电耦合器里信号延迟的误差因为操作使用会发生巨大变化，最终可导致高达1us的偏差。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210717114405335.png" alt="image-20210717114405335" /><figcaption aria-hidden="true">image-20210717114405335</figcaption>
</figure>
<h3 id="脉冲变压器">脉冲变压器</h3>
<p>利用脉冲变压器为信号传输的IGBT，可以达到较低的延时水平，但与光电耦合器一样，只能传输信号，提供所需能量仍需由隔离电源提供。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210717115333071.png" alt="image-20210717115333071" /><figcaption aria-hidden="true">image-20210717115333071</figcaption>
</figure>
<h3 id="单片电平转换器">单片电平转换器</h3>
<p><strong>单片电平转换器</strong>，即 仅通过一个集成电路来实现 输入信号 和 输出信号 之间的隔离。需要注意的是，并不想光耦、变压器、脉冲等技术的完全绝缘的电气隔离，如果出现差错（如输出侧寄生电感产生的负电压瞬变），电路高压侧和地压侧将会直接连在一起（导致内部集成芯片的损坏）。将 <strong><em>SOI（绝缘硅）技术</em></strong> 应用于电平转换器可以解决这一缺陷，Infineon的产品大多都应用这项技术。这样的SOI装置不是由PN结反向偏置来提供内部电路隔离的，而是通过一层绝缘层（通常是二氧化硅 SiO2）来为不同的内部电路提供隔离，其反向电压耐压高达较高（因产品而不同）。</p>
<p>单片电平转换器主要应用于 U<span style="font-size: 0.6rem;">CES</span> 低于 600V 的IGBT，通常一个驱动器有六路输出。但是在驱动 1.2kV 以上时，其驱动芯片和其他驱动方式相比成本劣势较少采用。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210717122123709.png" alt="image-20210717122123709" /><figcaption aria-hidden="true">image-20210717122123709</figcaption>
</figure>
<div style="text-align: center; font-weight: 900;">
图 带电平转换器的IGBT工作原理
</div>
<h1 id="产品概念">产品概念</h1>
<p>栅极驱动芯片 又可以称作 门极驱动芯片。按照门极驱动结构类型可以分为 <strong>单通道</strong>、<strong>双通道</strong>、<strong>四通道</strong> 和 <strong>六通道</strong>，又进一步划分 <strong>高边</strong>、<strong>地边</strong>、<strong>高低边</strong>、<strong>半桥</strong>、<strong>全桥</strong>、<strong>三相</strong>。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210717125203004.png" alt="image-20210717125203004" /><figcaption aria-hidden="true">image-20210717125203004</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210717125219691.png" alt="image-20210717125219691" /><figcaption aria-hidden="true">image-20210717125219691</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210717125337142.png" alt="image-20210717125337142" /><figcaption aria-hidden="true">image-20210717125337142</figcaption>
</figure>
<h2 id="eicedriver">EiceDriver</h2>
<p>下图为Infineon提供的栅极驱动芯片品类示意：</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210717120650887.png" alt="image-20210717120650887" /><figcaption aria-hidden="true">image-20210717120650887</figcaption>
</figure>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://storage.islet.space/01_Learning/12_Hardwares/03_Semiconductor/IGBT%E6%A8%A1%E5%9D%97%EF%BC%9A%E6%8A%80%E6%9C%AF%E9%A9%B1%E5%8A%A8%E5%92%8C%E5%BA%94%E7%94%A8.pdf">《IGBT模块：技术驱动和应用》</a></li>
<li><a target="_blank" rel="noopener" href="https://toshiba.semicon-storage.com/content/dam/toshiba-ss/shared/docs/design-support/document/Reference-design/application-note/MOSFET-Gate-Drive-Circuit-Application-Notes_EN_36267-CN.pdf">《MOSFET 栅极驱动电路》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infineon.com/dgdl/Infineon-Power_and_Sensing-ProductSelectionGuide-v00_01-EN.pdf?fileId=5546d4625607bd13015621522aa012cb&amp;da=t">《Infineon-Power_and_Sensing-ProductSelectionGuide-v00_01-EN》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infineon.com/dgdl/Infineon-EiceDRIVER_Gate_Driver_ICs-ProductSelectionGuide-v01_01-CN.pdf?fileId=5546d46269e1c019016ab0ec653015cc">《Infineon-EiceDRIVER_Gate_Driver_ICs-ProductSelectionGuide-v01_01-CN》</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/14/Hardware/2021-07-14-Semiconductor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/14/Hardware/2021-07-14-Semiconductor/" class="post-title-link" itemprop="url">Semiconductor</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-14 20:30:00" itemprop="dateCreated datePublished" datetime="2021-07-14T20:30:00+08:00">2021-07-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-07-17 12:13:36" itemprop="dateModified" datetime="2021-07-17T12:13:36+08:00">2021-07-17</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Semiconductor/" itemprop="url" rel="index"><span itemprop="name">Semiconductor</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文章用于记录半导体（晶体管的工作原理等blablabla的知识）。</p>
<h1 id="半导体的定义">半导体的定义</h1>
<p><strong>半导体</strong> 是指常温下导电性能介于导体与绝缘体之间的材料。 按照国际通行的半导体产品标准方式进行分类，半导体可以分为四类：<strong>集成电路</strong>（Integer Circuit），<strong>分立器件</strong>（Discrete Device），<strong>传感器</strong>（Sensor） 和 <strong>光电子器件</strong>（Optoelectronic Devices） ，统称为半导体元件。</p>
<p>分立器件按照功率转换进行分类，可以分为 <strong>功率器件</strong> 和 <strong>非功率器件</strong>，其中，<strong>传感器</strong> 和 <strong>光电器件</strong> 属于 分立器件下的 <strong>非功率器件</strong>，剩下的均是 <strong>功率器件</strong>，包含大部分晶体管，如 Zener Diode、BJT、IGFET、IGBT、Thyristor等。</p>
<p><strong>注意</strong>：功率器件的概念很大，不仅在分立器件中存在功率半导体，在IC中也存在功率半导体的产品。</p>
<h2 id="本征半导体">本征半导体</h2>
<p><mark>导电性介于导体与绝缘体之间的物质</mark>称为 <strong>半导体</strong>。</p>
<p><strong>导体</strong>：如铁、铝、铜等金属元素等低价元素，其最外层电子在外电场作用下很容易产生定向移动，形成电流。</p>
<p><strong>绝缘体</strong>：如惰性气体、橡胶等，其原子的最外层电子受原子核的束缚力很强，只有在外电场强到一定程度时才可能导电。</p>
<p><strong>半导体</strong>：如硅（Si）、锗（Ge），均为四价元素，它们原子的最外层电子受原子核的束缚力介于导体与绝缘体之间。</p>
<p><strong>本征半导体</strong>：intrinsic semiconductor， 是 <strong>纯净</strong>（Purity）的 <strong>晶体结构</strong>（Crystal Texture）的 半导体；intrinsic 具有 “本质，固有” 之意。<strong>纯净</strong>，即无杂质之意；<strong>晶体结构</strong>，即稳定的结构。</p>
<h2 id="pn型半导体">P/N型半导体</h2>
<p>纯净的硅晶体不带电荷，不显示出任何导电特性。</p>
<p><strong>自由电子</strong>（Electron）：由于热运动，具有足够能量的价电子挣脱共价键的束缚而成为自由电子</p>
<p><strong>空穴</strong>（Hole）：自由电子的产生使共价键中留有一个空位置</p>
<p><strong>复合</strong>：自由电子与空穴相碰同时消失</p>
<p><strong>电荷</strong>：电子和空穴都是电荷，电子呈现负电荷，空穴呈现正电荷</p>
<p><strong>载流子</strong>（Carrier）：运载电荷的粒子称为载流子</p>
<p><strong>导电性</strong>：物体呈现出的传导电流的能力</p>
<p><strong>多数载流子</strong>：在纯净硅晶体中掺杂数量较多的电荷称为多数载流子。</p>
<p><strong>少数载流子</strong>：在纯净硅晶体中掺杂数量较少的电荷称为少数载流子。</p>
<p>外加电场时，带负电的自由电子和带正电的空穴均参与导电，且运动方向相反。由于载流子数目很少，故导电性很差。温度升高，热运动加剧，载流子浓度增大，导电性增强。热力学温度0K时不导电。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210714204623205.png" alt="image-20210714204623205" style="zoom: 33%;" /></p>
<div style="text-align: center; font-weight:900;">
图 N型半导体结构
</div>
<p><img src="https://pic.islet.space/2021/07/image-20210714204653816.png" alt="image-20210714204653816" style="zoom: 33%;" /></p>
<div style="text-align: center; font-weight:900;">
图 P型半导体结构
</div>
<p>往纯净的硅晶体中掺杂一定浓度的 <strong>磷</strong>（P）或 <strong>硼</strong>（B）即可获得 使得硅晶半导体带上电子或空穴，即获得了 <strong>N型半导体</strong> 和 <strong>P型半导体</strong>。</p>
<p><strong>杂质半导体</strong>：在本征的基础上掺杂其他元素。</p>
<p><strong>P型半导体</strong>：掺杂了硼元素的硅晶体，空穴为多数载流子。</p>
<p><strong>N型半导体</strong>：掺杂了磷元素的硅晶体。自由电子为多数载流子。</p>
<h2 id="pn结">PN结</h2>
<p><strong>结</strong>：即 Junction，在纯净硅晶体中掺杂两种不同电荷所形成的杂质接触截面。</p>
<p><strong>扩散运动</strong>：物质 <mark>因浓度差而产生</mark> 的运动。气体、液体、固体均有之。扩散运动使靠近接触面P区的空穴浓度降低、靠近接触面N区的自由电子浓度降低，产生内电场。</p>
<p><strong>漂移运动</strong>：因 <mark>电场作用</mark> 所产生的运动。</p>
<p><strong>动态平衡</strong>：结处因空穴和电子一刻不停地复合和分离（官方：参与扩散运动和漂移运动的载流子数目相同）而形成 “无多数载流子” 的状态。</p>
<blockquote>
<p><strong>注意</strong>：扩散运动和漂移运动是相反的，</p>
</blockquote>
<p><img src="https://pic.islet.space/2021/07/image-20210714210922380.png" alt="image-20210714210922380" style="zoom:50%;" /></p>
<div style="text-align: center; font-weight:900;">
图 扩散运动
</div>
<p><img src="https://pic.islet.space/2021/07/image-20210714210942004.png" alt="image-20210714210942004" style="zoom:67%;" /></p>
<div style="text-align: center; font-weight:900;">
图 漂移运动
</div>
<p><strong>耗尽层</strong>：PN结处，因动态平衡而达到的“无多数载流子”的状态，该结的大小称为耗尽层。</p>
<p>如果此时让P区的多数载流子，即空穴尽量往N区移动，让N区的多数载流子，即自由电子尽量往P区移动，则两种电荷进行复合，形成更宽的耗尽层，此时因为耗尽层因为没有多数载流子而呈现不导电特性。</p>
<p>反之，让P区的多数载流子尽量往P区靠拢，让N区的多数载流子尽量往N区靠拢（注意，这里用的是“靠拢”，因为中间已经有耗尽层的形成，此时的“靠拢”是让耗尽层中已经复合消失的电子和空穴重新拆开，分别往各自原来的反向回归。），耗尽层的宽度会逐渐缩小，显现出导电特性。</p>
<p><strong>正向</strong>：电源的正、负极分别对准半导体的P、N极进行连接。</p>
<p><strong>反向</strong>：电源的正、负极分别对准半导体的N、P极进行连接。</p>
<p><strong>正向导通</strong>：耗尽层变窄，扩散运动加剧，由于外电源的作用，形成扩散电流，PN结处于导通状态。</p>
<p><strong>反向截止</strong>：耗尽层变宽，阻止扩散运动，有利于漂移运动，形成漂移电流。由于电流很小，故可近似认为其截止。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210714212136379.png" alt="image-20210714212136379" style="zoom:33%;" /></p>
<div style="text-align: center; font-weight:900;">
图 正向导通
</div>
<p><img src="https://pic.islet.space/2021/07/image-20210714212143706.png" alt="image-20210714212143706" style="zoom:33%;" /></p>
<div style="text-align: center; font-weight:900;">
图 反向截止
</div>
<h3 id="电容效应">电容效应</h3>
<p><strong>势垒电容</strong>：PN结外加电压变化时，空间电荷区的宽度将发生变化，有电荷的积累和释放的过程，与电容的充放电相同，其等效电容称为势垒电容Cb。</p>
<p><strong>扩散电容</strong>：PN结外加的正向电压变化时，在扩散路程中载流子的浓度及其梯度均有变化，也有电荷的积累和释放的过程，其等效电容称为扩散电容Cd。</p>
<p><strong>结电容</strong>：等于 势垒电容 与 扩散电容 之和。但 <mark>结电容不是常量！</mark> 若PN结外加电压频率高到一定程度，则失去单向导电性！</p>
<h1 id="二极管">二极管</h1>
<p>The diode is the most used semiconductor device in electronics circuits. <strong><em>It is a two-terminal electrical check valve that allows the flow of current in one direction.</em></strong> They are mostly made up of <strong><em>silicon</em></strong> but <strong><em>germanium</em></strong> is also used. Usually, they are used for <strong><em>rectification</em></strong>. But there are different properties &amp; characteristics of diodes which can be used for different application. These characteristics are modified to form different types of diodes.</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210713102126884.png" alt="image-20210713102126884" /><figcaption aria-hidden="true">image-20210713102126884</figcaption>
</figure>
<p><img src="https://pic.islet.space/2021/07/Types-of-Diodes-and-Their-Applications.jpg" alt="Types of Diodes and Their Applications" style="zoom:67%;" /></p>
<div style="text-align: center; font-weight: 900;">
图 二极管的几种外形
</div>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210713102141393.png" alt="image-20210713102141393" /><figcaption aria-hidden="true">image-20210713102141393</figcaption>
</figure>
<div style="text-align: center; font-weight: 900;">
图 二极管的几种常见结构和符号
</div>
<h2 id="主要特征参数">主要特征参数</h2>
<ol type="1">
<li>最大整流电流（Maximum Rectification Current）</li>
<li>最高反向工作电压（Maximum Reverse Voltage）</li>
<li>反向电流（Reverse Current）</li>
<li>最高工作频率（Maximum Frequency）</li>
</ol>
<h2 id="自举二极管">自举二极管</h2>
<h1 id="晶体管">晶体管</h1>
<p>晶体管主要分为两种类型，BJT 和 FET。</p>
<p><strong>工作区域</strong>：晶体管的导通状态，分为三种，分别是饱和、截止和放大，分别是指</p>
<h2 id="bjt">BJT</h2>
<p>BJT，即 Bioplar Junction Transistor，双极性结型晶体管。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210714213248733.png" alt="image-20210714213248733" /><figcaption aria-hidden="true">image-20210714213248733</figcaption>
</figure>
<div style="text-align: center; font-weight:900;">
图 晶体管内部结构和符号示意
</div>
<p><strong>注意</strong>：晶体管的符号示意中，箭头的方向永远是从P指向N的，此时先不用管c、b、e是怎么接，确定好。</p>
<blockquote>
<p>BJT结构特点：三极三区两PN结，发射区多子浓度高，基区多子浓度低且薄，集电区 面积大。</p>
</blockquote>
<p><strong>发射区</strong>：多数载流子较高的区域，自由电子流出的方向。</p>
<p><strong>基区</strong>：多数载流子浓度较低且薄的区域。</p>
<p><strong>集电区</strong>：面积大的区域，空穴流出的反向。</p>
<blockquote>
<p>某极 是根导线，与BJT中的物理区不同。</p>
</blockquote>
<p><strong>发射结</strong>：发射区和基区之间的PN结。</p>
<p><strong>集电结</strong>：集电区和基区之间的PN结。</p>
<blockquote>
<p><strong>注意</strong>：以上多数载流子可以是 空穴 或 自由电子，因此 BJT 可以有 NPN 和 PNP 两种类型的BJT。</p>
</blockquote>
<p>联系到实际电路连接中，一般情况下，<strong>集电区</strong> 都是接 <strong>供电电源</strong> ， <strong>基区</strong> 都是接 <strong>控制电源</strong>， <strong>发射区</strong> 都是接 <strong>负端/地</strong>。控制电源的电压会低于供电电源的电压，但会大于发射区的电压。</p>
<p>基区所连接的控制电源 为BJT提供 高电平或低电平 予以控制半导体的导通或截止，<mark>半导体所控制的负载的最大电压取决于发射极的供电电源电压 和 基区的控制电源电压</mark>。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210713104805683.png" alt="image-20210713104805683" style="zoom:67%;" /></p>
<div style="text-align: center; font-weight: 900;">
图 BJT的几种常见外形
</div>
<p><img src="https://pic.islet.space/2021/07/image-20210713105054978.png" alt="image-20210713105054978" style="zoom:67%;" /></p>
<div style="text-align: center; font-weight: 900;">
图 BJT的结构和符号
</div>
<h3 id="工作原理">工作原理</h3>
<p>从下图可以看出，下图 BJT 为 NPN 型半导体，集电区接正电，发射区接地，基区接地。集电区与基区为反向截止状态，集电结的耗尽层增大，进一步阻止集电区和发射区之间的电流导通。</p>
<p>若此时向基区施加正向电流，基区电压高于发射区电压，发射结正偏导通，发射区多子（电子）往基区流动，。发射区的电子能够顺利往集电区流动，集电区的电流往发射区流动，从而导通 该BJT。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210714215347959.png" alt="image-20210714215347959" style="zoom:33%;" /></p>
<div style="text-align: center; font-weight:900;">
图 BJT导通时的内部电荷流向示意
</div>
<p>集电极电流是漂移形成的，发射极电流是扩散形成的。</p>
<p><strong>发射区电流</strong> I<span style="font-size: 0.8rem;">E</span> 是由 扩散运动形成的。</p>
<p><strong>基区电流</strong> I<span style="font-size: 0.8rem;">B</span> 是由 复合运动形成的。</p>
<p><strong>集电区电流</strong> I<span style="font-size: 0.8rem;">C</span> 是由 漂移运动形成的。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210714222731446.png" alt="image-20210714222731446" style="zoom:33%;" /></p>
<div style="text-align: center; font-weight:900;">
图 BJT输入特性曲线
</div>
<p><img src="https://pic.islet.space/2021/07/image-20210714222645318.png" alt="image-20210714222645318" style="zoom: 33%;" /></p>
<div style="text-align: center; font-weight:900;">
图 BJT输出特性曲线
</div>
<h3 id="工作区域">工作区域</h3>
<p><img src="https://pic.islet.space/2021/07/image-20210714223024773.png" alt="image-20210714223024773" style="zoom:67%;" /></p>
<div style="text-align: center; font-weight:900;">
图 BJT工作区域
</div>
<h2 id="fet">FET</h2>
<p><strong>场效应晶体管</strong> 简称 <strong>场效应管</strong>。主要有 <strong>结型场效应管</strong>（JFET）和 <strong>金属氧化物半导体场效应管</strong>（MOSFET）两种类型。</p>
<h3 id="jfet">JFET</h3>
<p><img src="https://pic.islet.space/2021/07/image-20210713105852012.png" alt="image-20210713105852012" style="zoom:67%;" /></p>
<div style="text-align: center; font-weight: 900;">
图 JFET的结构和符号
</div>
<h3 id="mosfet">MOSFET</h3>
<p>在MOS管工作原理图上可以看到，漏极和源极之间有一个寄生二极管。这个叫体二极管，在驱动感性负载(如马达)，这个二极管很重要。顺便说一句，体二极管只在单个的MOS管中存在，在集成电路芯片内部通常是没有的。</p>
<p>下图a中，为增强型P衬底N沟道MOS，其栅极接 <u>高电平</u> 即导通。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210713110023509.png" alt="image-20210713110023509" style="zoom:67%;" /></p>
<div style="text-align: center; font-weight: 900;">
图 N沟道增强型MOS管结构示意图 及 增强型MOS管的符号
</div>
<p><img src="https://pic.islet.space/2021/07/image-20210713110146838.png" alt="image-20210713110146838" style="zoom:67%;" /></p>
<div style="text-align: center; font-weight: 900;">
图 N沟道耗尽型MOS管结构示意图 及 耗尽型MOS管的符号
</div>
<h4 id="nmos工作原理">NMOS工作原理</h4>
<iframe src="//player.bilibili.com/player.html?aid=931455726&amp;bvid=BV1DM4y1T7Yx&amp;cid=363622918&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
<p>MOS管有4个端子，其符号也是四个端子组成的，以下用NMOS举例：</p>
<p>NMOS底部端子连接到基板/主体（Substrate/Body），称为基板、衬底端子 或 <strong><em>主体端子</em></strong>。上方各有两个N沟道，各自连接 <strong><em>源极端子</em></strong> 和 <strong><em>漏极端子</em></strong>。两个端子中间添加了一层 薄绝缘体或电介质，在此层绝缘体上加了一个 <strong><em>栅极端子</em></strong>。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210716001316182.png" alt="image-20210716001316182" style="zoom:50%;" /></p>
<p>在NMOS内部构造中，源极端子 和 衬底端子 在内部连接，因此外露出来的端子只有三个。此时因 源极 和 衬底 的电位相同，阻止了任何电流从衬底流向源极。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210716001716986.png" alt="image-20210716001716986" style="zoom:50%;" /></p>
<p>在MOS中，希望电子从漏极流向源极，在两个极连接一个电源，其电压称为 V<span style="font-size: 0.6rem;">DS</span> ，此时加大电压，电流却不会增大，因为漏极沟道附近的耗尽层不断增大。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210716002453710.png" alt="image-20210716002453710" style="zoom:50%;" /></p>
<p>栅极端子 和 主体端子 都有绝缘材料，当给栅极端子接电压较小的电压 V<span style="font-size: 0.6rem;">GS</span> 时，两个绝缘材料形成电容效应，栅极处的多子不断吸引自由电子往栅极移动，暂时形成带自由电子较多的N区，从而导通了 源极 和 漏极，暂时形成了回路。因为 栅极处的N区是暂时连接 源极和漏极的通道，因此也被称为 N沟道。随着电压的增大或减小，沟道的大小也会随着变化。足以形成沟道的最低栅极电压被称为 <strong>阈值电压</strong>。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210716002900372.png" alt="image-20210716002900372" style="zoom:50%;" /></p>
<p>当不断增加栅极电压，漏极 和 衬底之间的耗尽层将因为 反向偏置 而不断增加。靠近漏极一侧的N沟道宽度将不断减小，直到某个电压点时，称为夹断效应。夹断下映实际上是说，沟道并未完全关闭，许多电子将保留通道，并不是停止了电流流动，而是出现了恒定的饱和电流，其电压被称为 饱和电压。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210716004255087.png" alt="image-20210716004255087" style="zoom:50%;" /></p>
<div style="text-align: center; font-weight: 900;">
表 FET的符号和特性
</div>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210713105437061.png" alt="image-20210713105437061" /><figcaption aria-hidden="true">image-20210713105437061</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210713105533255.png" alt="image-20210713105533255" /><figcaption aria-hidden="true">image-20210713105533255</figcaption>
</figure>
<h2 id="fet-and-bjt">FET and BJT</h2>
<p>FET 的 <strong>栅极</strong>、<strong>源极</strong> 和 <strong>漏极</strong> 对应 BJT的 <strong>基极</strong>、<strong>发射极</strong> 和 <strong>集电极</strong>，其作用类似。</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>FET</th>
<th>BJT</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>电流索取</td>
<td>用“栅-源”电压控制漏极电流，栅极基本不取电流<br>【输入电阻高的电路选用】</td>
<td>工作时基极总要索取一定的电流<br>【信号源若提供电流的选用】</td>
</tr>
<tr class="even">
<td>导电情况</td>
<td>仅多子参与导电</td>
<td>多子少子均参与导电</td>
</tr>
<tr class="odd">
<td>稳定性</td>
<td>较好</td>
<td>较差<br>【因少子数目受温度、辐射等因素影响较大，温度稳定性和抗辐射的能力较差些。】</td>
</tr>
<tr class="even">
<td>噪声系数</td>
<td>小<br>【低噪声放大器的输入级和信噪比要求高的电路选用】</td>
<td>大</td>
</tr>
<tr class="odd">
<td>源-漏互换</td>
<td>可以互换，互换后特性变化不大</td>
<td>互换后特性差异很大，特殊需求时互换</td>
</tr>
<tr class="even">
<td>电压范围</td>
<td>宽</td>
<td>窄</td>
</tr>
<tr class="odd">
<td>工艺</td>
<td>简单</td>
<td>复杂</td>
</tr>
<tr class="even">
<td>耗电</td>
<td>低</td>
<td>高</td>
</tr>
</tbody>
</table>
<blockquote>
<p>IGFET / MOS / MOSFET 是同一个东西，还有个词叫 MISFET（Metal-Insulated-Semiconductor Field Effect Transistor，金属绝缘半导体场效应管）</p>
</blockquote>
<h1 id="功率半导体">功率半导体</h1>
<p><strong>功率半导体</strong> 器件大致分为两类： <strong>可控功率半导体</strong> 和 <strong>不可控功率半导体</strong>。<strong>可控功率半导体</strong> 如 Thyristor（晶闸管）、BJT（双极型晶体管）、功率MOSFET 和 IGBT 。不可控功率半导体 包括各种类型的功率二极管。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210713112224602.png" alt="image-20210713112224602" style="zoom:67%;" /></p>
<div style="text-align: center; font-weight: 900;">
图 常见功率半导体器件及其典型的功率范围、阻断电压和开关频率
</div>
<h1 id="igbt">IGBT</h1>
<p><strong>绝缘栅型双极晶体管</strong>，即 <strong>IGBT</strong>（Insulated Gate Bipolar Transistor），是由 <strong><em>BJT</em></strong>（双极型三极管)）和 <strong><em>MOS</em></strong>（绝缘栅型场效应管）组成的 <strong>复合全控型电压驱动式功率半导体</strong> 器件, 兼有 <strong>MOSFET</strong>的 <u>高输入阻抗</u> 和 <strong>GTR</strong>的 <u>低导通压降</u> 两方面的优点。IGBT综合了以上两种器件的优点，驱动功率小而饱和压降低。非常适合应用于直流电压为600V及以上的变流系统如交流电机、变频器、开关电源、照明电路、牵引传动等领域。</p>
<blockquote>
<p>GTR 具有饱和压降低，载流密度大，但驱动电流较大的优点；</p>
<p>MOSFET 具有驱动功率很小，开关速度快，但导通压降大，载流密度小的优点。</p>
</blockquote>
<p><strong>IGBT模块</strong> 是由 IGBT（绝缘栅双极型晶体管芯片）与FWD（续流二极管芯片）通过特定的电路桥接封装而成的模块化半导体产品；封装后的IGBT模块直接应用于变频器、UPS不间断电源等设备上；IGBT模块 具有节能、安装维修方便、散热稳定等特点；当前市场上销售的多为此类模块化产品，一般所说的IGBT也指IGBT模块；随着节能环保等理念的推进，此类产品在市场上将越来越多见；</p>
<p><img src="https://pic.islet.space/2021/07/image-20210713142410853.png" alt="image-20210713142410853" style="zoom: 80%;" /></p>
<div style="text-align: center; font-weight: 900;">
图 IGBT内部结构和等效电路
</div>
<p>因为IGBT的构造所致，最好还是不要让IGBT长期工作在放大区，会让其降低使用寿命，因开关开断时而进入放大区无可避免，仅工作在 饱和区 和 截止区 即可。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210715221251088.png" alt="image-20210715221251088" style="zoom:80%;" /></p>
<p>三个英文符号分别表示为 <strong>栅极</strong>（Gate）、<strong>集电极</strong>（Collector）、<strong>发射极</strong>（Emitter）。</p>
<p>在漏极侧增加了高掺杂的P+层，称之为 <strong>集电极</strong>。</p>
<ul>
<li><p>当栅极接近 <u>负电压</u> 或 <u>零电压</u> 时，PN结 J2 阻断，发射极电压远低于集电极电压，IGBT 关断 （正向阻断）；但是此刻 结J1 和 结J3 <strong>正偏导通</strong>。</p></li>
<li><p>当栅极接到 <u>正电压</u>（通常是15V）时，氧化层下方的 P区 建立 <strong>反型导电沟道</strong>，为 N-区 提供导电通路，电子从发射极到 N-区 降低了 N-区 的电位，PN结 J1导通，IGBT导通。</p></li>
</ul>
<p>如果栅极电压不够大，形成的反型层较弱，流入漂移区的电子数相对较少，IGBT压降增大，即进入特性曲线的 <strong>线性放大区</strong>。工作在线性放大区会加剧损耗或损坏 IGBT，因而除了开关瞬间，应避免进入线性放大区。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210713144038325.png" alt="image-20210713144038325" style="zoom:67%;" /></p>
<div style="text-align: center; font-weight: 900;">
图 IGBT的输出特性
</div>
<p>IGBT 的关断电流分为 <strong>MOSFET关断阶段</strong> 和 <strong>BJT关断阶段</strong>。第一个阶段时，关断反型沟道，电流迅速下降；第二个阶段时，会产生持续时间较长的拖尾电流。</p>
<p>拖尾电流使得 IGBT 的关断损耗 高于 MOSFET 的关断损耗。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210713144838981.png" alt="image-20210713144838981" style="zoom: 67%;" /></p>
<div style="text-align: center; font-weight: 900;">
图 MOSFET和IGBT的主要开通和关断特性比较
</div>
<p>截止电压：</p>
<p>饱和电压：</p>
<p>击穿电压：</p>
<p><strong>阈值电压</strong>：描述的是 <strong>栅极</strong> 和 <strong>发射极</strong> 之间刚好足以打开导流通道的电压。</p>
<p><strong>漏电流</strong>：泄露电流，leakage current。主要是指栅极和发射极的在反向偏置状态的泄露电流，此处特性与二极管相近。</p>
<h2 id="分类">分类</h2>
<p>IGBT可以分为 <strong>穿通型</strong>（PT）IGBT、<strong>非穿通型</strong>（NPT）IGBT、<strong>场终止型</strong>（FS）IGBT、<strong>沟槽栅</strong>（Trench）IGBT、<strong>载流子存储沟槽栅双极晶体管</strong>（CSTBT）、<strong>注入增强晶体管</strong>（IEGT）、<strong>沟槽栅终止</strong>（Trench-FS）IGBT、<strong>逆导型</strong>（RC）IGBT。</p>
<p><strong>平面栅极结构</strong> 的IGBT设计，形成了JFET结构，以及发射极区软弱的电导调制效应，载流子的浓度从集电极到发射极之间逐步降低。</p>
<p><strong>沟槽型栅极结构</strong> 的IGBT设计，在平面型的基础上保持载流子浓度平均分布或逐步增加载流子浓度，进一步降低通态损耗，而不影响拖尾电流和关断损耗。</p>
<p>载流子越少越有助于降低关断损耗。</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 30%" />
<col style="width: 12%" />
<col style="width: 11%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>TYPE</th>
<th>内部构造（原理）</th>
<th>温度系数</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PT-IGBT<BR>穿通型IGBT</td>
<td><img src="https://pic.islet.space/2021/07/image-20210713112637086.png" alt="image-20210713112637086" style="zoom:67%;" /></td>
<td>正温度系数<br>负温度系数</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>NPT-IGBT<BR>非穿通型IGBT</td>
<td><img src="https://pic.islet.space/2021/07/image-20210713112654444.png" alt="image-20210713112654444" style="zoom:67%;" /></td>
<td>正温度系数</td>
<td>1. 有利于IGBT并联</td>
<td>1. 随着温度上升，损耗增大</td>
</tr>
<tr class="odd">
<td>FS-IGBT<BR>场终止型IGBT</td>
<td><img src="https://pic.islet.space/2021/07/image-20210713112712678.png" alt="image-20210713112712678" style="zoom:67%;" /></td>
<td>正温度系数</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Trench-IGBT<br>沟槽栅IGBT</td>
<td><img src="https://pic.islet.space/2021/07/image-20210713112728045.png" alt="image-20210713112728045" style="zoom:67%;" /></td>
<td></td>
<td></td>
<td>1. 更宽的导电沟道会增加IGBT短路时的电流</td>
</tr>
<tr class="odd">
<td>CSTBT<br>载流子存储沟槽双极晶体管</td>
<td><img src="https://pic.islet.space/2021/07/image-20210713122039519.png" alt="image-20210713122039519" style="zoom:67%;" /></td>
<td></td>
<td>1. 降低了IGBT的饱和压降</td>
<td></td>
</tr>
<tr class="even">
<td>IEGT<BR>注入增强栅晶体管</td>
<td><img src="https://pic.islet.space/2021/07/image-20210713112841613.png" alt="image-20210713112841613" style="zoom:67%;" /></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Trench-FS IGBT<br>沟槽栅终止IGBT</td>
<td><img src="https://pic.islet.space/2021/07/image-20210713112933604.png" alt="image-20210713112933604" style="zoom:67%;" /></td>
<td></td>
<td></td>
<td>1. 保持鲁棒性，通态损耗和开关损耗降低<br>2. 功率密度提升，即电流密度增大<br>3. 单位IGBT所需硅材料降低</td>
</tr>
<tr class="even">
<td>RC-IGBT<BR>逆导型IGBT</td>
<td><img src="https://pic.islet.space/2021/07/image-20210713122011473.png" alt="image-20210713122011473" style="zoom:67%;" /></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="术语总结">术语总结</h1>
<p><strong>FET</strong>： Filed Effect Transistor，即 <strong>场效应管</strong>，是 <mark>利用输入回路的电场效应来控制输出回路电流</mark> 的一种半导体器件，故此得名。由于其仅靠半导体中的多数载流子导电，因此也称为 <strong>单极型晶体管</strong>。</p>
<p><strong>JFET</strong>： Junction Filed Effect Transistor，即 <strong>结型场效应管</strong>，有 P沟道 和 N沟道 两种类型。</p>
<p><strong>IGFET</strong>： Insulated Gate Field Effect Transistor，即 <strong>绝缘栅型场效应管</strong>。因栅极与源极、栅极与漏极之间均采用二氧化硅绝缘层进行阻隔而得名如此。又因栅极为金属铝，故又称为MOS管。具有 高输入阻抗、高开关频率 和 低驱动功率 的优点。</p>
<p><strong>MOS</strong>： Metal-Oxide-Semiconductor，即 <strong>金属氧化物半导体</strong>。同上。</p>
<p><strong>MOSFET</strong>： Metal-Oxide-Semiconductor Field Effect Transistor，即 <strong>金属氧化物半导体场效应管</strong>。同上。</p>
<p><strong>BJT</strong>： Bipolar Junction Transistor， 即 <strong>双极结型晶体管</strong>。因带有两种不同极性电荷的载流子参与导电，故得名如此，或称 <strong>半导体三极管</strong>，简称 <strong>双极晶体管</strong> 或 <strong>晶体管</strong>。</p>
<p><strong>UJT</strong>： Unijunction Transistor，即 <strong>单结晶体管</strong>。因有两个基极，也称为 <strong>双基极晶体管</strong>。</p>
<p><strong>GTR</strong>： Giant Transistor，即 <strong>巨型晶体管</strong>。BJT的一种，亦称为 Power BJT（<strong>电力晶体管</strong>）。具有自关断、无须辅助关断电路、 高电流密度、低保和电压 和 耐高压 的优点。</p>
<p><strong>IGBT</strong>： Insulated Gate Bipolar Transistor，即 <strong>绝缘栅双极型晶体管</strong>。</p>
<p><strong>Thyristor</strong>：即 <strong>半导体闸流管</strong> 、<strong>晶闸管</strong>，又称为 <strong>硅可控元件</strong>（Silicon Controlled Rectifier）， 由按顺序排列的PNPN四层半导体组成。最外层的P区和N区构成了正负极，中间的P区构成了控制极（栅极），可以控制导通。具有耐压高、电流大、耐浪涌能力强 且 价格便宜 等优点。</p>
<p><strong>GTO</strong>： Gate Turn-Off Thyristor，即 <strong>可关断晶闸管</strong>。是一种通过门极来控制器件导通和关断的电力半导体器件。具有 普通晶闸管 和 GTR的优点，是应用于高压大容量场合中的一种大功率开关器件。</p>
<p><strong>PT</strong>： Power Transistor， 即 <strong>功率晶体管</strong> / <strong>功率管</strong>。</p>
<p><strong>IPM</strong>： Intelligent Power Module，即 <strong>智能功率模块</strong>。具有GTR 和 MOSFET 的优点。而且IPM内部集成了逻辑、控制、检测和保护电路，使用起来方便,不仅减小了系统的体积以及开发时间，也大大增强了系统的可靠性。</p>
<p><img src="https://pic.islet.space/2021/07/d4628535e5dde711c5d042b5a7efce1b9d166176" alt="img" style="zoom: 25%;" /></p>
<div style="text-align: center; font-weight: 900;">
图 IPM器件示意
</div>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《模拟电子技术基础》高等教育出版社，童师白</li>
<li>《IGBT模块：技术、驱动和应用》机械工业出版社，Andreas Volke and Michael Hornkamp</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/366981878">逆变器的分类方式有哪些</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/IGBT/2078902?fromtitle=%E7%BB%9D%E7%BC%98%E6%A0%85%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1&amp;fromid=12731336">IGBT</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1">场效应管</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%99%B6%E4%BD%93%E4%BA%8C%E6%9E%81%E7%AE%A1">晶体二极管</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%99%B6%E4%BD%93%E7%AE%A1/569042#:~:text=%E6%99%B6%E4%BD%93%E7%AE%A1%E6%9C%89%E6%97%B6%E5%A4%9A%E6%8C%87%E6%99%B6%E4%BD%93%E4%B8%89%E6%9E%81%E7%AE%A1%E3%80%82%20%E4%B8%89%E7%AB%AF%E5%AD%90%E6%99%B6%E4%BD%93%E7%AE%A1%E4%B8%BB%E8%A6%81%E5%88%86%E4%B8%BA%E4%B8%A4%E5%A4%A7%E7%B1%BB%EF%BC%9A%20%E5%8F%8C%E6%9E%81%E6%80%A7%E6%99%B6%E4%BD%93%E7%AE%A1,%EF%BC%88BJT%EF%BC%89%E5%92%8C%20%E5%9C%BA%E6%95%88%E5%BA%94%E6%99%B6%E4%BD%93%E7%AE%A1%20%EF%BC%88FET%EF%BC%8C%E5%8D%95%E6%9E%81%E6%80%A7%EF%BC%89%E3%80%82">晶体管</a></li>
<li><a target="_blank" rel="noopener" href="https://circuitglobe.com/difference-between-diode-and-transistor.html">Difference Between Diode &amp; Transistor</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/150177944">半导体分类知识大全</a></li>
<li><a target="_blank" rel="noopener" href="https://xueqiu.com/3593206238/153075165">IGBT—功率半导体皇冠上的明珠</a></li>
<li><a target="_blank" rel="noopener" href="https://www.electricaltechnology.org/2018/12/types-of-diodes-their-applications.html">Types of Diodes and Their Applications - 24 Types of Diodes</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/11/Hardware/DSP/2021-07-11-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%8A%AF%E7%89%87%E5%A4%96%E8%AE%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/11/Hardware/DSP/2021-07-11-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%8A%AF%E7%89%87%E5%A4%96%E8%AE%BE/" class="post-title-link" itemprop="url">嵌入式芯片外设</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-11 13:50:00" itemprop="dateCreated datePublished" datetime="2021-07-11T13:50:00+08:00">2021-07-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-07-15 21:11:03" itemprop="dateModified" datetime="2021-07-15T21:11:03+08:00">2021-07-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hardware/" itemprop="url" rel="index"><span itemprop="name">Hardware</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>嵌入式芯片（如MCU、DSP等）内部包含众多的模块化外设，如 串口控制模块，SPI模块，I2C模块，A/D模块，PWM模块，CAN模块，EEPROM，比较器模块，等等，它们都集成在芯片内部，有相对应的内部控制寄存器，可通过指令直接控制。</p>
<p>按照控制信号类别对外设进行分类，可以分为 <strong>模拟外设</strong>（Analog Peripherals）、<strong>控制外设</strong>（Control Peripherals） 和 <strong>通信外设</strong>（Communication Peripherals）。</p>
<p><strong>模拟外设</strong> 的常见外设如 <strong>模数转换器</strong>（Analog-to-Digital Convertor, ADC）、<strong>可编程增益放大器</strong>（Programmable Gain Amplifier, PGA）、<strong>温度传感器</strong>（Temperature Sensor）、<strong>缓冲数模转换器</strong>（Buffered Digital-to-Analog Convertor, DAC）和 <strong>比较器</strong>（Comparator Subsystem）。</p>
<p><strong>控制外设</strong> 的常见设备如 <strong>捕获器</strong>（Capture, CAP）、<strong>脉冲幅频调制器</strong>（Pulse Width Modulator, PWM）、<strong>正交编码器脉冲</strong>（ Quadrature Encoder Pulse, QEP）和 <strong>西格玛-德尔塔滤波器模块 </strong>（Sigma-Delta Filter Module, SDFM）。</p>
<p><strong>通信外设</strong> 的常见设备如 （Controller Area Network, CAN）、<strong>双线通信</strong>（Inter-Integrated Circuit, I2C）、<strong>电源管理总线接口</strong>（Power Management Bus Interface, PMBus）、<strong>串行通信接口</strong>（Serial Communications Interface, SCI）、<strong>串行外设接口</strong>（Serial Peripheral Interface, SPI）、<strong>局域互联网络</strong>（Local Interconnect Network, LIN） 和 <strong>高速串行接口</strong>（Fast Serial Interface, FSI）。</p>
<h1 id="cla">CLA</h1>
<p>为了解决DSP在对实时控制要求比较高的场合中CPU计算速度不足以及计算负担过重，TI很早之前就已经推出了具有CLA功能的DSP。</p>
<p>CLA，即Control Law Accelerator，是一个32位浮点数计算加速器，可以理解为一个专门为浮点数运算而优化的CPU。其可以 <strong>独立</strong> 于CPU进行运算操作，并 <mark>可以同时访问</mark> 到ePWM，eCAP，eQEP，ADC result以及Comparator <mark>寄存器</mark>。相当于两个CPU并行工作，从而减少了主CPU的运算负担。</p>
<p>也就是说 CLA可以同时访问所有模拟外设的寄存器。</p>
<p>可以将CLA看作是辅助CPU进行计算的浮点运算协处理器（co-processor）。</p>
<p>一个典型的应用场景如下：</p>
<p><img src="https://pic.islet.space/2021/07/v2-9fdd0b85b26f7ff8074a8c58b1aba945_720w.jpg" alt="img" />闭环控制电路</p>
<p>CPU通过ADC采集主电路的电压、电流信息，计算得到控制逻辑（包括频率以及占空比等），从而控制电路工作。因此如果CPU的计算负担很大，比如说需要计算傅里叶分解，比如说需要计算反三角函数等，那么就造成了极大的控制时延。而CLA应运而生，专门为计算浮点数进行优化，且不会造成CPU阻塞于计算而对异常情况无法响应的情况。</p>
<figure>
<img src="https://pic.islet.space/2021/07/v2-2d0d2214e132b1a9982d3ab50db429ff_720w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<div style="text-align: center; font-weight: 900;">
图 28069和28027对比
</div>
<p>上图则对比了具有CLA功能的28069和不具有CLA功能的28027的控制延时。对于没有CLA功能的28027，其CPU在ADC采样结束之后触发SOC中断，随后进行闭环计算，最后再结束一个周期的控制，开始下一个周期。而具有<mark>CLA</mark>功能的28069则<mark>可以在采样结束之后立即自主触发CLA计算</mark>（由于没有菊花链，所以触发迅速），并且由于<mark>CLA针对浮点数计算进行优化，因此计算时间更短</mark>。更重要的是，<mark>CPU不需要进行任何操作，因此CPU可以有空闲完成其他任务，比如异常检测，比如故障上报等等</mark>。</p>
<p>简单来说，采用CLA的系统具有<strong>更小的计算时延</strong>，<strong>CPU负担更小，</strong>因此其系统更加迅速稳定。</p>
<h1 id="clb">CLB</h1>
<p>The C2000 configurable logic block (CLB) is a collection of configurable blocks that interconnect through software to implement custom digital logic functions.</p>
<p>The CLB subsystem contains a number of identical tiles.</p>
<h1 id="gpio">GPIO</h1>
<p>GPIO，即General-purpose input/output，通用型之输入输出（接口）。功能类似8051的P0—P3，其接脚可以供使用者由程控自由使用，PIN脚依现实考量可作为通用输入（GPI）或通用输出（GPO）或通用输入与输出（GPIO），如当clk generator, chip select等。 既然一个引脚可以用于输入、输出或其他特殊功能，那么一定有寄存器用来选择这些功能。对于输入，一定可以通过读取某个寄存器来确定引脚电位的高低；对于输出，一定可以通过写入某个寄存器来让这个引脚输出高电位或者低电位；对于其他特殊功能，则有另外的寄存器来控制它们。</p>
<h1 id="cmpss">CMPSS</h1>
<p>CMPSS，即Comparator Subsystem，比较器子系统。由模拟比较器和支持电路组成，可用于峰值电流模式控制、开关电源、功率因数校正、电压跳闸监测等应用。</p>
<p>每个CMPSS包含两个比较器、两个12位DAC参考、两个数字滤波器和一个斜坡发生器。比较器在每个模块中表示为“H”或“L”，其中“H”和“L”分别表示高和低。每个比较器产生一个数字输出，指示正输入端的电压是否大于负输入端的电压。比较器的正输入由外部引脚或PGA驱动，负输入可由外部引脚或可编程参考12位DAC驱动。每个比较器输出通过一个可编程的数字滤波器，可以消除假跳闸信号。如果不需要滤波，也可以使用未滤波的输出。一个可选的斜坡发生器电路可用于控制高比较器的12位参考DAC值。</p>
<p><img src="https://pic.islet.space/2021/07/20200416154658460.png" /></p>
<h1 id="can">CAN</h1>
<p>A controller area network(CAN) is ideally suited to the many high-level industrial protocols embracing CAN and <strong><em>ISO-11898:2003</em></strong> as their physical layer.</p>
<h2 id="introduction">Introduction</h2>
<ul>
<li><p>The CAN bus was developed by BOSCH as a <strong><em>multi-master</em></strong>, <strong><em>message broadcast</em></strong> system that specifies a maximum signaling rate of <strong><em>1 megabit per second</em></strong>(bps).</p></li>
<li><p>CAN is an International Standardization Organization (ISO) defined serial communications bus originally developed for the automotive industry to replace the complex wiring harness with a two-wire bus.</p></li>
<li><p>CAN <em>does not</em> send large blocks of data point-to-point from node A to Node B under the supervision of the central bus master.</p></li>
<li><p>In a CAN network, <mark>many short messages</mark> like temperature or RPM <mark>are broadcast to the entire network</mark>, which provides for <mark>data consistency in every node of the system</mark>. 保证系统中各节点的数据一致性。</p></li>
<li><p>CAN's specification calls for high immunity to electrical interface and the ability to self-diagnose and repair data errors.</p></li>
</ul>
<p>以下为ISO 11898 对 CAN 标准架构层级解释框图：</p>
<figure>
<img src="C:\Users\431240.IT2004\AppData\Roaming\Typora\typora-user-images\image-20210711162150611.png" alt="image-20210711162150611" /><figcaption aria-hidden="true">image-20210711162150611</figcaption>
</figure>
<p>The CAN communication protocol is a <strong><em>carrier-sense</em></strong>, <strong><em>multiple-access</em></strong> protocol with <strong><em>collision detection</em></strong> and <strong><em>arbitration on message priority</em></strong> (<strong><em>CSMA</em></strong> / <strong><em>CD+AMP</em></strong>). <strong><em>CSMA</em></strong> means that each node on a bus must wait for a prescribed period of inactivity before attempting to send a message. <strong><em>CD+AMP</em></strong> means that collisions are resolved through a bit-wise arbitration, based on a preprogrammed priority of each message in the identifier field of a message. The higher priority identifier always wins bus access.</p>
<p>CAN 包含 standard CAN 和 Extended CAN。</p>
<figure>
<img src="C:\Users\431240.IT2004\AppData\Roaming\Typora\typora-user-images\image-20210711163535822.png" alt="image-20210711163535822" /><figcaption aria-hidden="true">image-20210711163535822</figcaption>
</figure>
<figure>
<img src="C:\Users\431240.IT2004\AppData\Roaming\Typora\typora-user-images\image-20210711163548817.png" alt="image-20210711163548817" /><figcaption aria-hidden="true">image-20210711163548817</figcaption>
</figure>
<h1 id="术语">术语</h1>
<p><strong>菊花链</strong>：在电子电气工程中菊花链代表一种配线方案，例如设备A和设备B用电缆相连，设备B再用电缆和设备C相连，设备C用电缆和设备D相连，在这种连接方法中不会形成网状的拓扑结构，只有相邻的设备之间才能直接通信，例如在上例中设备A是不能和设备C直接通信的，它们必须通过设备B来中转，这种方法同样不会形成环路。因为最后一个设备不会连向第一个设备。这种连线方法能够用来传输电力，数字信号和模拟信号。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/72232829">CLA介绍及使用指南</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/gpio">GPIO</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/whyorwhnt/article/details/105547472">TMS320F280049C 学习笔记16 比较器子系统(CMPSS)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ti.com/lit/an/sloa101b/sloa101b.pdf">《Introduction to the Controller Area Network(CAN)》</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/10/Communication/2021-07-10-JTAG%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/10/Communication/2021-07-10-JTAG%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">JTAG通信</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-07-10 21:00:00 / Modified: 21:28:00" itemprop="dateCreated datePublished" datetime="2021-07-10T21:00:00+08:00">2021-07-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Communication/" itemprop="url" rel="index"><span itemprop="name">Communication</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="入门">入门</h1>
<p>以下为 B站up主——“蛋饼的爹地” 制作上传的JTAG科普视频。</p>
<iframe src="//player.bilibili.com/player.html?aid=503270942&amp;bvid=BV1iN411Z7jk&amp;cid=346887915&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://xploreqa.ieee.org/stampPDF/getPDF.jsp?tp=&amp;arnumber=6515989&amp;ref=aHR0cHM6Ly94cGxvcmVxYS5pZWVlLm9yZy9kb2N1bWVudC82NTE1OTg5">《IEEE 1149.1-2013 Test Access Port and Boundary Scan Architecture》</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/10/Hardware/Circuit/2021-07-10-VCC%E3%80%81VDD%E3%80%81VEE%E3%80%81VSS%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/10/Hardware/Circuit/2021-07-10-VCC%E3%80%81VDD%E3%80%81VEE%E3%80%81VSS%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">VCC、VDD、VEE、VSS的区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-10 15:00:00" itemprop="dateCreated datePublished" datetime="2021-07-10T15:00:00+08:00">2021-07-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-07-15 21:10:58" itemprop="dateModified" datetime="2021-07-15T21:10:58+08:00">2021-07-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hardware/" itemprop="url" rel="index"><span itemprop="name">Hardware</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="对于晶体管">对于晶体管</h2>
<p><strong><em>Vcc</em></strong>：来源于集电极电源电压， <em>Collector Voltage</em>， 一般用于双极型晶体管， PNP 管时为负电源电压， 有时也标成 -Vcc， NPN 管时为正电压</p>
<p><strong><em>Vdd</em></strong>：来源于漏极电源电压， <em>Drain Voltage</em>， 用于 MOS 晶体管电路， 一般指正电源。 因为很少单独用 PMOS 晶体管， 所以在 CMOS 电路中 Vdd 经常接在 PMOS 管的源极上。</p>
<p><strong><em>Vss</em></strong>：源极电源电压， 在 CMOS 电路中指负电源， 在单电源时指零伏或接地。</p>
<p><strong><em>Vee</em></strong>：发射极电源电压， <em>Emitter Voltage</em>， 一般用于 ECL 电路的负电源电压。</p>
<p><strong><em>Vbb</em></strong>：基极电源电压， 用于双极晶体管的共基电路。</p>
<h2 id="对于电路及芯片">对于电路及芯片</h2>
<p><strong><em>VDD</em></strong>：电源电压(单极器件)；芯片电源电压。（Device）</p>
<p><strong><em>VCC</em></strong>：电源电压(双极器件)；电路电源电压。（Circuit）</p>
<p><strong><em>VSS</em></strong>：接地端、负极。（Series）</p>
<p><strong><em>VEE</em></strong>：负电压供电；</p>
<p><strong><em>VPP</em></strong>：编程/擦除电压。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/10/Hardware/DSP/2021-07-10-F280041PM%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/10/Hardware/DSP/2021-07-10-F280041PM%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">F280041PM开发笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-10 11:10:00" itemprop="dateCreated datePublished" datetime="2021-07-10T11:10:00+08:00">2021-07-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-10-15 00:00:01" itemprop="dateModified" datetime="2021-10-15T00:00:01+08:00">2021-10-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hardware/" itemprop="url" rel="index"><span itemprop="name">Hardware</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[TOC]</p>
<h1 id="概述">概述</h1>
<h2 id="命名方法">命名方法</h2>
<p>TMS320F28004x 下称 本系列芯片，本系列设备型号命名方法：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210719092842059.png" alt="image-20210719092842059" style="zoom:67%;" /></p>
<h2 id="开发手册">开发手册</h2>
<p>开发本系列芯片可能需要使用到的文件如下：</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210724112707176.png" alt="image-20210724112707176" /><figcaption aria-hidden="true">image-20210724112707176</figcaption>
</figure>
<p><strong>注意</strong>：下文中《TRM》 与《SPRUI33D》为同一份文件。</p>
<h2 id="封装形式">封装形式</h2>
<p>C28004x 共有2种芯片封装形式： LQFP 和 VQFN 。VQFN 仅有56针，LQFP 有 100针和 64针的区别。分别用 PZ 、PM 和 RSH 三种型号尾缀与 100-pin 、64-pin 和 56-pin 相关联。根据section4.3，可以知道还有个64PMQ的尾缀。</p>
<p>如型号TMS320F280041PM，仅有64针脚，引脚分布如下图所示：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210710144933414.png" alt="image-20210710144933414" style="zoom:100%;" /></p>
<h1 id="specification">Specification</h1>
<p>下图应该是F280049的系统功能框图，与F280041PM仍有些出入。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210710141413564.png" alt="image-20210710141413564" /><figcaption aria-hidden="true">image-20210710141413564</figcaption>
</figure>
<p><strong>注意</strong>：<span style="text-decoration: line-through">F280041PM不支持 CLA（控制律加速器，Control Law Accelerator）</span>，Flash为128KB（64KW），GPIO数量为26，AIO数量为14，ADC通道为14，同时280041支持5个PGA</p>
<p><strong>更正</strong>： F28004x系列均支持 CLA（控制律加速器，Control Law Accelerator），如《spru566n》中的下表示，支持type2型CLA。</p>
<p>TMS320F28004x 所支持外设如下：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210710142641475.png" alt="image-20210710142641475" style="zoom:110%;" /></p>
<blockquote>
<p><strong>Q</strong>: 为什么要区分type？</p>
<p><strong>A</strong>: 就同一类功能而言，在C2000系列上，都会有许多不同的增强/阉割版本，就出现了支持全部基础功能的、出现支持部分扩展功能的 和 支持全部扩展功能的等各种版本，那么就需要从功能范围的本质上去描述这些区别，再用相应的 “功能+type x” 的方式来表示其支持的类别。如下图所示，为《spru556n》page 24 所描述的关于CLA的功能类别。</p>
<p><code>CLA type 0</code>，表示的是支持原始CLA功能的模块类型。</p>
<p><code>CLA type 2</code> ，表示在原始功能的基础上，增加了后台代码模式，可以在后台运行通信和清理程序等任务；后台任务持续运行，直到禁用或设备/软复位；后台任务可以由外设或软件触发；其他前台任务可以按照定义的优先顺序中断后台任务；增加了使后台代码部分不被中断的规定；增加了调试功能，具有真正的软件断点支持，在调试停止期间，CLA从同一地址重新获取数据会被停止。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210712141632913.png" alt="image-20210712141632913" style="zoom: 67%;" /></p>
</blockquote>
<p>贴一张 <strong><em>系统控制基础地址</em></strong> 的总表：<img src="https://pic.islet.space/2021/07/image-20210802135651683.png" alt="image-20210802135651683" /></p>
<h2 id="引脚">引脚</h2>
<h3 id="引脚分配">引脚分配</h3>
<p>Page17 4.2 <strong><em>Pin Attributes</em></strong> 下可以查看各封装芯片引脚的名称、编号 及 功能。（共有10页左右，不粘贴了）</p>
<h3 id="引脚路由">引脚路由</h3>
<p>Page30 4.3 <strong><em>Signal Routing</em></strong> 下可以查看引脚的路由信息。包括模拟引脚和数字引脚的复用信息。</p>
<h3 id="引脚复用">引脚复用</h3>
<p>Page41 4.4 <strong><em>Pin Multiplexing</em></strong> 下可以查看引脚的复用信息，GPIO口的默认功能就是GPIO，除了GPIO35 和 GPIO37（默认情况下是TDI 和 TDO）。GPIO口的次级功能可以通过设置 <code>GPyGMUXn.GPIOz</code> 和 <code>GPyMUXn.GPIOz</code> 寄存器位来进行。</p>
<p><strong>注意</strong>：</p>
<ul>
<li><code>GPyGMUXn</code> 寄存器应在 <code>GPyMUXn</code> 之前配置，以避免交替复用选择对GPIO产生瞬时脉冲。</li>
<li>GPIO20 , GPIO21 和 GPIO41 至 GPIO55在任何封装上都不可复用。</li>
</ul>
<p>表6 为GPIO的针脚复用说明，表中未列明项为GPIO复用设置保留位。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210712094430159.png" alt="image-20210712094430159" /><figcaption aria-hidden="true">image-20210712094430159</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210712094455163.png" alt="image-20210712094455163" /><figcaption aria-hidden="true">image-20210712094455163</figcaption>
</figure>
<h3 id="引脚置高低">引脚置高/低</h3>
<p>部分引脚可以被置高/低，下表展示了各引脚的设置类型。默认情况下，GPIO不可置高，但是可以通过软件进行使能。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210712093251720.png" alt="image-20210712093251720" /><figcaption aria-hidden="true">image-20210712093251720</figcaption>
</figure>
<h2 id="x-bar">X-BAR</h2>
<p><strong>X-BAR</strong> 即 Crossbar。</p>
<p>X-BAR 包含四种，分别是 <strong>输入X-BAR</strong> 、 <strong>输出X-BAR</strong> 、 <strong>CLB X-BAR</strong> 和 <strong>ePWM X-BAR</strong>。每一种 X-BAR 都以其携带的信号命名，例如输入X-BAR携带外部信号“进入”芯片内部；输出X-BAR携带内部芯片信号“输出”至GPIO上；CLB和ePWM X-BAR 则对应其外设。</p>
<h3 id="输入x-bar">输入X-BAR</h3>
<p>输入X-BAR被用于从GPIO口引导信号至许多不同的IP块，如ADC、eCAP、ePWM 和 外部中断。</p>
<p>图5 展示了X-BAR的架构，表8 展示了各X-BAR输入可能的路由目的地。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210712095049189.png" alt="image-20210712095049189" /><figcaption aria-hidden="true">image-20210712095049189</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210712095346292.png" alt="image-20210712095346292" /><figcaption aria-hidden="true">image-20210712095346292</figcaption>
</figure>
<h3 id="clbepwm-和-输出x-bar">CLB、ePWM 和 输出X-BAR</h3>
<p>输出X-BAR有8个可以路由至各GPIO模块的输出口。ePWM X-BAR 有8个可以路由至各ePWM模块的输出口。</p>
<p>图6 展示了 <strong>输出 X-BAR</strong> 和 <strong>ePWM X-BAR</strong> 的 信号源，这些信号源都是 <strong>内部外设</strong> 或者 <strong>输入X-BAR</strong> 的输出。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210712095838640.png" alt="image-20210712095838640" style="zoom:120%;" /></p>
<h4 id="clb-x-bar">CLB X-BAR</h4>
<p>暂略</p>
<h4 id="epwm-x-bar">ePWM X-BAR</h4>
<p>ePWM X-BAR将是信号带到ePWM模块。特殊注意，ePWM X-BAR与每一个ePWM模块处理TZ和同步的数字比较器（Digital Compare）子模块相连。</p>
<p><strong>注意</strong>：ePWM X-BAR的架构 与 GPIO输出X-BAR的架构 相同（除了 <strong>输出闩</strong> / <strong>输出锁存器</strong>（output latch））</p>
<p><img src="https://pic.islet.space/2021/08/image-20210824141830457.png" alt="image-20210824141830457" style="zoom:80%;" /></p>
<p>ePWM X-BAR 拥有8个能够路由至每个ePWM模块的输出。图9-2仅展示了单条输出（Single Output）的架构，其他输出与上图一致。</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210824142639712.png" alt="image-20210824142639712" /><figcaption aria-hidden="true">image-20210824142639712</figcaption>
</figure>
<p><strong>配置流程</strong></p>
<ol type="1">
<li>从表9-2中挑选出应该传递给PWM的信号，最多为每个mux（最多32个mux）选择一个信号。</li>
<li>通过 <code>TRIPxMUX0TO15CFT</code> 和 <code>TRIPxMUX16TO31CFG</code> 寄存器选择每个mux的输入。</li>
<li>为了将任意信号传递至ePWM，必须在 <code>TRIPxMUXENABLE</code> 寄存器中使能mux。</li>
<li>所有已开启的mux会在被传递到对应ePWM的 TRIPx 信号前进行逻辑or操作。可以适当利用 <code>TRIPOUTINV</code> 寄存器地对信号进行取反操作（optionally invert）。</li>
</ol>
<h4 id="gpio-输出x-bar">GPIO 输出X-BAR</h4>
<p>GPIO 输出 X-BAR 将信号从设备内部带到GPIO引脚。图9-4展示了GPIO 输出 X-BAR的架构。X-BAR包含8个输出，且每个输出都包含至少1个 GPIO mux位置（at least one position on the GPIO mux），表示为 <code>OUTPUTXBARx</code> 。X-BAR允许 <strong>单个信号的选择</strong> 或者 <strong>最多32个信号的逻辑or操作</strong>。</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210824143551921.png" alt="image-20210824143551921" /><figcaption aria-hidden="true">image-20210824143551921</figcaption>
</figure>
<p>GPIO输出X-BAR也有8个能够路由至GPIO模块的输出。图9-4展示了单输出的架构，与其他剩余输出的架构一致。</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210824143615399.png" alt="image-20210824143615399" /><figcaption aria-hidden="true">image-20210824143615399</figcaption>
</figure>
<p><strong>配置流程</strong>：</p>
<ol type="1">
<li>根据表9-4确定需要传递到GPIO的信号。最多为每个 <code>OUTPUTXBARx</code> 输出配置一个信号（on signal per mux）（最多32 mux）。</li>
<li>通过 <code>OUTPUTxMUX0TO15CFG</code> 和 <code>OUTPUTxMUX16TO31CFG</code> 寄存器位每个mux选择输入。</li>
</ol>
<p>为了能够传递任何信号至GPIO，必须在 <code>OUTPUTxMUXENABLE</code> 寄存器中使能mux。所有已启用的mux将会在被传递到对应的 <code>OUTPUTx</code> 信号之前进行逻辑or操作。</p>
<p>可以选择性的使用 <code>OUTPUTINV</code> 取反信号，</p>
<h2 id="电压">电压</h2>
<p>本系列芯片支持以下三种之一的电源供应（在要求核心电压 <code>VDD = 1.2V</code> 的情况下）：</p>
<ul>
<li>外接电源（不支持56针RSH封装）</li>
<li>内部 1.2V LDO电压整流器</li>
<li>内部 1.2V 开关整流器</li>
</ul>
<p><strong>注意</strong>：必须使用同一个系统电压调节器来驱动VDDIO和VDDIO_SW。</p>
<p>下方是有关两个电压调节器的详细描述：</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210710154834139.png" alt="image-20210710154834139" /><figcaption aria-hidden="true">image-20210710154834139</figcaption>
</figure>
<h2 id="复位">复位</h2>
<p>暂略</p>
<h2 id="时钟">时钟</h2>
<p>设备时钟域为设备上的不同模块提供时钟输入支持，这些设备与派生时钟（derived clock）直接相连， 或通过额外的分频器连接。</p>
<p>F28004x 支持 <strong>内源</strong> 和 <strong>外源</strong> 两种类型时钟。<strong>内源</strong> 即芯片自带的，上电即起振的内源性时钟。<strong>外源</strong> 即需要通过引脚外接配置的。</p>
<p>下图展示了 本系列芯片支持的时钟系统框图，可以看到时钟源 有 <strong><em>INTOSC1</em></strong> / <strong><em>INTOSC2</em></strong> / <strong><em>X1(XTAL)</em></strong> 三个，由时钟源配置产生的时钟最终会产生 <strong><em>看门狗时钟</em></strong>、<strong><em>PLL系统时钟</em></strong>、<strong><em>芯片时钟</em></strong> 主要是这三种。其中 <strong><em>芯片时钟</em></strong> 又会 <em><u>进一步</u></em> 配置到给各种外设。</p>
<p>外设的时钟使用也是有区别的，其中 <strong><em>SYSCLK</em></strong> 被 ePIE、RAMs、GPIOs 和 DCSM 所使用；<strong><em>PERx.LSPCLK</em></strong> 被 SCIs 和 SPIs 所使用；<strong><em>CAN-Bit-Clock</em></strong> 被 CAN总线使用（注意，此时必须使用外源时钟进行配置）；<strong><em>PERx.SYSCLK</em></strong> 被 剩余其他外设所使用。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210710155206953.png" alt="image-20210710155206953"  /></p>
<p>下表 3-40 所示为《SPRUI33D》第173页 关于时钟配置相关的寄存器。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210726121525047.png" alt="image-20210726121525047" /><figcaption aria-hidden="true">image-20210726121525047</figcaption>
</figure>
<h3 id="内源时钟">内源时钟</h3>
<blockquote>
<p>At power-up, the device is clocked from an on-chip 10 MHz oscillator (INTOSC2). INTOSC2 is the primary internal clock source, and is the default system clock at reset. It is used to run the boot ROM and can be used as the system clock source for the application.</p>
</blockquote>
<p>下图展示了本系列芯片的时钟系统，本系列芯片支持两个独立的 <strong>内源时钟</strong>，直接映射为 <strong><em>INTOSC1</em></strong> 和 <strong><em>INTOSC2</em></strong> 。默认情况下，都会在芯片启动时开启，且 <strong><em>INTOSC2</em></strong> 才是 内源时钟的主时钟源，<strong>INTOSC1</strong> 是备用时钟源。<u>这一点可以手动修改</u>。</p>
<p>芯片启动时，<strong><em>INTOSC2</em></strong> 以10MHz速率起振，为 ROM的启动做准备，且可以被配置为 系统时钟。</p>
<p>即系统内部自带的内源时钟，<strong><em>INTOSCx</em></strong> ，可以在不外接晶振的情况下，仅用内源时钟即可驱动工作，且《sprui33》3.7.11中就以内源时钟 <strong><em>INTOSC2</em></strong> 为主时钟（仅有10MHz），讲述了系统运行时钟 <strong><em>SYSCLK</em></strong> （100MHz）的配置方法。</p>
<p>注意：</p>
<ul>
<li><p>如果需要使用 CAN 外设，那么仅使用 <strong><em>INTOSCx</em></strong> 的频率是不足以达到CAN的频率要求的，必须使用外部时钟 <strong><em>XTAL</em></strong> 。</p></li>
<li><p><mark style="font-weight: 900;">在使用内源时钟时，用于接外源时钟的X1引脚必须通过一个 1KΩ的电阻接地。</mark></p></li>
<li><p>与其他GPIO相比，<mark>GPIO18拥有不一样的电气特性</mark>，因为是可以被当做X2来使用的。</p></li>
</ul>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210730085027137.png" alt="image-20210730085027137" /><figcaption aria-hidden="true">image-20210730085027137</figcaption>
</figure>
<h4 id="看门狗">看门狗</h4>
<p>如图5-10所示，如果要启用看门狗，其速率最高与 <strong><em>INTOSC1</em></strong> 一致。</p>
<h3 id="外源时钟">外源时钟</h3>
<p><span style="text-decoration-line: line-through;">系统还可以使用 <strong><em>X1</em></strong> 或 <strong><em>X2</em></strong> 两个接口其中之一来连接 至 <strong>外部时钟</strong> 。</span></p>
<p>外源时钟有两个接口，分别是 <strong><em>第41</em></strong>（<em>GPIO18_X2</em>） 和 <strong><em>第42</em></strong>（<em>X1</em>）。按照连接方式分类，可以分为 <strong>外源时钟模式</strong> 和 <strong>单端外源时钟模式</strong>：</p>
<ul>
<li>外源时钟模式时，<em>X1</em> 和 <em>X2</em> 都进行连接。进一步区分为 <strong>EC</strong>（外部晶振器，External Crystal）和 <strong>ER</strong>（外部谐振器，External Resonator）。</li>
<li>单端外源时钟模式时，仅 <em>X1</em> 连接，<em>X2</em> 留空，VSS需要接地。</li>
</ul>
<p>图 5-12 至 5-14 展示了三种不同的外部时钟源电路：</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210711172426297.png" alt="image-20210711172426297" /><figcaption aria-hidden="true">image-20210711172426297</figcaption>
</figure>
<p><strong>注意</strong>：<mark>当 <strong><em>X1</em></strong> 接口被当作外源时钟接口使用时，X2接口不能被当做GPIO使用。仅当使用内源时钟时， <strong><em>X2</em></strong> 可以配置成 GPIO。</mark></p>
<p>如下方所示，为 LaunchPad 硬件的时钟电路，其中 Boosterpack 是指 ？？？</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210730134835054.png" alt="image-20210730134835054" /><figcaption aria-hidden="true">image-20210730134835054</figcaption>
</figure>
<p>需要使用到Boosterpack时，需要移除R35，在R31和R38上焊上0Ω的跨电阻连接器，下图为LaunchPad背面的镜像示意。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210730141929361.png" alt="image-20210730141929361" /><figcaption aria-hidden="true">image-20210730141929361</figcaption>
</figure>
<p>从C2000WARE套件里的《MCU025A(001)_BOM.xls》可以找到launchpads板上的板载时钟一共有2个，分别是Y1和Y2。其中，与F280049只接相连的是Y2，为Crystal。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210730145344856.png" alt="image-20210730145344856" /><figcaption aria-hidden="true">image-20210730145344856</figcaption>
</figure>
<h4 id="表格">表格</h4>
<p>表13 展示了（外部）输入时钟频率的范围要求</p>
<p>表14 展示了（外部）晶体振荡器的电气特性</p>
<p>表15 展示了X1的计时要求</p>
<p>表16 展示了PLL锁定的时间</p>
<p>表17 展示了内部时钟频率</p>
<p>表18 展示了输出时钟XCLKOUT的开断性能</p>
<p>表19 展示了（外部）晶体振荡器参数</p>
<p>表20 展示了（外部）晶体振荡器的等效电阻要求</p>
<p>表21 展示了（外部）晶体振荡器的电气特性</p>
<p>表22 展示了（内部）晶体振荡器的电气特性</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210710155540889.png" alt="image-20210710155540889" /><figcaption aria-hidden="true">image-20210710155540889</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210710160134644.png" alt="image-20210710160134644" /><figcaption aria-hidden="true">image-20210710160134644</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210710160150517.png" alt="image-20210710160150517" /><figcaption aria-hidden="true">image-20210710160150517</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210711172100592.png" alt="image-20210711172100592" /><figcaption aria-hidden="true">image-20210711172100592</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210711173148615.png" alt="image-20210711173148615" /><figcaption aria-hidden="true">image-20210711173148615</figcaption>
</figure>
<h3 id="pll计算方法">PLL计算方法</h3>
<p>下图展示了系统PLL的设置框图。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210710155140640.png" alt="image-20210710155140640"  /></p>
<p>系统PLL（PLLSYSCLK）的计算方法：<code>PLLSYSCLK = OSCCLK * IMULT * FMULT / PLLSYSCLKDIV</code></p>
<blockquote>
<p>PLLSYSCLK : 输出时钟频率</p>
<p>OSCCLK : 输入时钟频率</p>
<p>IMULT : 整数倍频，取值范围为 [0, 127]</p>
<p>FMULT : 分数倍频，取值范围为 [0 , 3]</p>
<p>PLLSYSCLKDIV : 分频， 取值范围为 {0, 1, 2, 4, 6, 8, ..., 124, 126}</p>
</blockquote>
<h3 id="内源时钟配置方法">内源时钟配置方法</h3>
<p>需要注意的是，内源时钟配置时，X1需要通过一个1KΩ的电阻接地。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210730085027137.png" alt="image-20210730085027137" style="zoom:67%;" /></p>
<p>Once the application requirements are understood, a specific clock configuration can be determined. The default configuration is for <strong><em>INTOSC2</em></strong> to be used as the system clock (<strong><em>PLLSYSCLK</em></strong>) with a divider of 1.</p>
<p>The following procedure can be used to set up the desired application configuration:</p>
<ol type="1">
<li><p>Select the reference clock source (<strong><em>OSCCLK</em></strong>) by writing to <strong><em>CLKSRCCTL1.OSCCLKSRCSEL</em></strong>. To enable XTAL, follow the instructions in the previous sections.</p></li>
<li><p>Select the reference clock source (<strong><em>OSCCLK</em></strong>) by writing to <strong><em>CLKSRCCTL1.OSCCLKSRCSEL</em></strong>. Allow at least 300 <em><u>NOP instructions</u></em> for this to take effect.</p></li>
<li><p>Set up the system PLL if desired. TI recommends using the C2000Ware <code>SysCtl:setClock()</code> function for proper configuration of the PLL clock.</p></li>
<li><p>Select the <strong><em>LSPCLK</em></strong> divider by writing to <strong><em>LOSPCP</em></strong>.</p></li>
<li><p>If an alternate CAN bit clock is needed, select it by writing to <strong><em>CLKSRCCTL2.CANABCLKSEL</em></strong> and <strong><em>CLKSRCCTL2.CANBBCLKSEL</em></strong>.</p></li>
<li><p>Enable the desired peripheral clocks by writing to the <strong><em>PCLKCRx</em></strong> registers.</p></li>
</ol>
<p>The system clock configuration can be changed at run time. Changing the <strong><em>OSCCLK</em></strong> source will automatically bypass the PLL and set the multiplier to zero. Changing the multiplier from one non-zero value to another will temporarily bypass the PLL until it re-locks.</p>
<p><mark style="font-weight: 900;">注意： At least a 300 CPU clock cycles delay is needed after OSSCLK source is changed. </mark></p>
<h4 id="配置示例">配置示例</h4>
<p>以下为工作频率设置的样例，利用内源时钟 <code>10MHz</code> ，产生芯片满负工作频率 <code>100MHz</code> ：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210715170724177.png" alt="image-20210715170724177"  /></p>
<h4 id="配置代码">配置代码</h4>
<p><code>f28004x_examples.h</code> 文件中，包含了对 <code>IMULT</code> 、<code>FMULT</code> 、 <code>PLLSYSCLKDIV</code> 的变量宏定义。</p>
<p>官方提供的PLL配置函数原型为：<code>void InitSysPll(Uint16 clock_source, Uint16 imult, Uint16 fmult, Uint16 divsel)</code> 。根据配置实例中的参数，函数调用时代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InitSysPll(INT_OSC2, IMULT_19, FMULT_0pt25, PLLCLK_BY_1);</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InitSysPll(<span class="number">0x00</span>, <span class="number">0x13</span>, <span class="number">0x01</span>, <span class="number">0x01</span>);</span><br></pre></td></tr></table></figure>
<p>即 <code>10MHz * ( 19 + 1/4 ) / (2^1) = 96.25MHz</code>，最后的CPU工作频率为 96.25MHz，但由于内源时钟振荡器可能存在变化，CPU的工作时钟也存在 ±3% 的公差。</p>
<h3 id="外部时钟配置方法">外部时钟配置方法</h3>
<p>下面配置步骤由《TRM》第104页提供，按照连接方式，将连接模式分为：<strong>外源时钟模式</strong> 和 <strong>单端外源时钟模式</strong></p>
<p>两个模式仅在第2和第7个步骤有所区别，其余均相同。</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>外源时钟模式：<em>CRYSTAL</em> or <em>RESONATOR</em></th>
<th>单端外源时钟模式：<em>OSCILLATOR</em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1. Clear the <code>XTALCR.OSCOFF</code> bit.</td>
<td>1. Clear the <code>XTALCR.OSCOFF</code> bit.</td>
</tr>
<tr class="even">
<td>2. Wait for the crystal to power up. 1ms is the typical wait time but this depends on the crystal that is being used.</td>
<td>2. Set the <code>XTALCR.SE</code> bit to enable <em>single-ended mode</em>.</td>
</tr>
<tr class="odd">
<td>3. Clear the X1 counter by writing a 1 to <code>X1CNT.CLR</code> and keep clearing until the X1 counter value in the <code>X1CNT</code> register is no longer saturated <code>1023 (0x3ff)</code>.</td>
<td>3. Clear the X1 counter by writing a 1 to <code>X1CNT.CLR</code> and keep clearing until the X1 counter value in the <code>X1CNT</code> register is no longer saturated <code>1023 (0x3ff)</code>.</td>
</tr>
<tr class="even">
<td>4. Wait for the X1 counter value in the <code>X1CNT</code> register to reach <code>1023 (0x3ff)</code>.</td>
<td>4. Wait for the X1 counter value in the <code>X1CNT</code> register to reach <code>1023 (0x3ff)</code>.</td>
</tr>
<tr class="odd">
<td>5. Repeat steps 3-4 three additional times.</td>
<td>5. Repeat steps 3-4 three additional times.</td>
</tr>
<tr class="even">
<td>6. Select XTAL as the OSCCLK source by writing a <code>1</code> to <code>CLKSRCCTL1.OSCCLKSRCSEL</code>.</td>
<td>6. Select XTAL as the OSCCLK source by writing a <code>1</code> to <code>CLKSRCCTL1.OSCCLKSRCSEL</code>.</td>
</tr>
<tr class="odd">
<td>7. Check the <code>MCLKSTS</code> bit in the <code>MCDCR</code> register. If it's set, the oscillator has not finished powering up, and more time is required:<br><strong><em>a.</em></strong> Clear the missing clock status by writing a <code>1</code> to <code>MCDCR.MCLKCLR</code>.<br><strong><em>b.</em></strong> Repeat steps 2-7. Do not reset the device. Doing so will power down the oscillator, which requires the procedure to be restarted from step 1.<br><strong><em>c.</em></strong> <mark style="font-style: italic;">If the oscillator has not finished powering up in 10 milliseconds, there is a real clock failure.</mark></td>
<td>7. Check the <code>MCLKSTS</code> bit in the <code>MCDCR</code> register. <mark style="font-style: italic;">If it's set, either the external oscillator or the device has failed.</mark></td>
</tr>
<tr class="even">
<td>8. If <code>MCDCR.MCLKSTS</code> is clear, the oscillator startup is a success. The system clock is now derived from XTAL.</td>
<td>8. If <code>MCLKSTS</code> is clear, the switch to the external clock is a success. The system clock is now derived from XTAL.</td>
</tr>
</tbody>
</table>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210730164642361.png" alt="image-20210730164642361" /><figcaption aria-hidden="true">image-20210730164642361</figcaption>
</figure>
<h3 id="子系统时钟sysclk-perx.sysclk">子系统时钟（SYSCLK / PERx.SYSCLK）</h3>
<p>CPU 为 CLA / DMA 和 绝大多数（片上）外设直接提供时钟信号，该时钟就是 <strong><em>PLLSYSCLK</em></strong> ， 但会在CPU进入 HALT模式时被栅断（gate off）。</p>
<p>每一个外设都拥有使用 <strong><em>PCLKCRx</em></strong> 寄存器进行独立控制的时钟。</p>
<p><strong>注意</strong>：当使用 PCLKCRx 时，应用需要在时钟接入外设后，等待5个 <strong><em>SYSCLK</em></strong> 周期。</p>
<p>如《SPRUI33D》中，表3-55所示，从第195页起可查看 <strong><em>PCLKCRx</em></strong> 相关寄存器的所有说明。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210726095356897.png" alt="image-20210726095356897" /><figcaption aria-hidden="true">image-20210726095356897</figcaption>
</figure>
<h2 id="闪存">闪存</h2>
<p>表23 展示了不同时钟源和频率下所需的最小闪存等待状态</p>
<p>表24 展示了闪存的性能参数</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210711173614732.png" alt="image-20210711173614732" /><figcaption aria-hidden="true">image-20210711173614732</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210711173721809.png" alt="image-20210711173721809" /><figcaption aria-hidden="true">image-20210711173721809</figcaption>
</figure>
<h2 id="jtag">JTAG</h2>
<p><img src="https://pic.islet.space/2021/07/image-20210730135537700.png" alt="image-20210730135537700" style="zoom: 80%;" /></p>
<h2 id="gpio">GPIO</h2>
<p><mark>在复位时，GPIO会被配置为输入。</mark></p>
<p>对于特定的输入，用户还可以选择 <strong>输入鉴定周期</strong>（input qualification cycles）的数量来过滤不需要的 <strong>噪声突变</strong>（unwanted noise glitches）。</p>
<p><strong><em>表 29</em></strong> 展示了GPIO的特性参数，<mark style="text-decoration-line: line-through;">需要注意的是，GPIO的频率只有25MHz最高。</mark></p>
<p><strong><em>表 30</em></strong> 展示了GPIO的输入时间要求</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210711174357812.png" alt="image-20210711174357812" /><figcaption aria-hidden="true">image-20210711174357812</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210711174530164.png" alt="image-20210711174530164" /><figcaption aria-hidden="true">image-20210711174530164</figcaption>
</figure>
<p>除了CPU控制的I/O功能外，最多可有12个独立的外设信号在一个GPIO功能口上进行多路复用。每个功能口的输出都可以被外设或者CPU主机（CPU1或者CPU1.CLA）进行控制。</p>
<p>有两个可输入输出接口：</p>
<ul>
<li><p>接口A包含GPIO1 ~ GPIO31</p></li>
<li><p>接口B包含GPIO32 ~ GPIO59</p></li>
</ul>
<p>本设备上的模拟信号被复用在数字输入上，这些模拟输入输出口（AIO）引脚不具备数字输出的能力。接口范围为：</p>
<ul>
<li>接口H包含GPIO224 ~ GPIO247</li>
</ul>
<p>虽然上述GPIO看起来很多，但实际上本系列芯片只有GPIOA和GPIOB的部分引脚，引脚总数为26个。</p>
<h3 id="引脚复用-1">引脚复用</h3>
<p>在 <code>GPyMUXx</code> 寄存器中，每个区域（field）都决定了每个引脚（IO PIN）的GPIO复用配置。设置为 <code>0x0</code> , <code>0x4</code> , <code>0x8</code> , <code>0xC</code> 时可以将该引脚配置为 GPIO，配置为其他值时，可以选择一个外设以控制该引脚。查看设备数据手册以获得《外设复用选项表格》。</p>
<p>引脚必须在改变 <code>GPyGMUXx</code> 对应域之前，通过寄存器设置为GPIO模式。</p>
<h3 id="流程图解读">流程图解读</h3>
<p>下图8-1 展示了单个GPIO引脚上的功能框图：</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210823153758838.png" alt="image-20210823153758838" /><figcaption aria-hidden="true">image-20210823153758838</figcaption>
</figure>
<p>从上图可以看出来，GPIO可以设置为输出或输入</p>
<ol type="1">
<li><p>输入时可以通过 <code>GPyPUD</code> 寄存器设置为是否 <strong>拉高</strong>，然后通过 <code>GPyINV</code> 寄存器设置是否信号 <strong>反转</strong>，<code>GPyCTRL</code> 寄存器控制着4个字段（每个字段独立控制8个GPIO）的 <strong>确认采样周期</strong>（qualification sampling period），通过设置该寄存器可以设置其 <strong>采样速率范围</strong> 为 {0, 2, 4, ...508, 510} 个 SYSCLK 周期；<code>GPyQSEL1/2</code> 寄存器控制着 <strong>输入确认类型</strong>（可选为 同步/三采样/六采样/异步），最后可以输出至 <strong>四个方向</strong>（外设、X-BAR、CPU1 和 CPU1CLA）。</p></li>
<li><p>输出暂略。</p></li>
<li><p>The input and output paths are entirely separate, connecting only at the pin.</p></li>
<li><p>Peripheral muxing takes place far from the pin.</p></li>
</ol>
<p>As a result, it is always possible for both CPUs and CLAs to read the physical state of the pin independent of CPU mastering and peripheral muxing.</p>
<p>Likewise, external interrupts can be generated from peripheral activity. All pin options such as input qualification and open-drain output are valid for all masters and peripherals.</p>
<p>However, the peripheral muxing, CPU muxing, and pin options can only be configured by CPU1.</p>
<h3 id="寄存器">寄存器</h3>
<p>《SPRUI33D》第857页起讲述GPIO特性，第870页起讲述相关寄存器信息。</p>
<p>如 <strong><em>表 8-8</em></strong> 所示，GPIO拥有两类寄存器，分别是 <strong><em>GPIO控制寄存器</em></strong> 和 <strong><em>GPIO数据寄存器</em></strong> 。另，控制/数据寄存器 下都有 <strong><em>GPIO A</em></strong> / <strong><em>GPIO B</em></strong> / <strong><em>GPIO H</em></strong> 三种区别。<strong><em>表 8-9</em></strong> 是GPIO控制寄存器的详细介绍，<strong><em>表 8-54</em></strong> 是GPIO数据寄存器的详细介绍。</p>
<table>
<thead>
<tr class="header">
<th>FUNCTIONS</th>
<th>GPIO A</th>
<th>GPIO B</th>
<th>GPIO H</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PINS</td>
<td><code>GPIO0</code> ~ <code>GPIO31</code></td>
<td><code>GPIO32</code> ~ <code>GPIO63</code></td>
<td><code>GPIO224</code> ~ <code>GPIO255</code></td>
</tr>
<tr class="even">
<td>QUALIFICATION SAMPLING PERIOD</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="odd">
<td>QUALIFICATION TYPE</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="even">
<td>PERIPHERAL MUX</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="odd">
<td>DIRECTION</td>
<td>Y</td>
<td>Y</td>
<td></td>
</tr>
<tr class="even">
<td>PULL-UP DISABLE</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="odd">
<td>INPUT INVERSION</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="even">
<td>OPEN DRAIN OUTPUT MODE</td>
<td>Y</td>
<td>Y</td>
<td></td>
</tr>
<tr class="odd">
<td>ANALOG MODE SELECT</td>
<td>Y</td>
<td></td>
<td>Y</td>
</tr>
<tr class="even">
<td>PERIPHERAL GROUP MAX</td>
<td>Y</td>
<td>Y</td>
<td></td>
</tr>
<tr class="odd">
<td>MASTER CORE SELECT</td>
<td>Y</td>
<td>Y</td>
<td></td>
</tr>
<tr class="even">
<td>LOCK</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="odd">
<td>LOCK COMMIT</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody>
</table>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210728104527100.png" alt="image-20210728104527100" /><figcaption aria-hidden="true">image-20210728104527100</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210728105035255.png" alt="image-20210728105035255" /><figcaption aria-hidden="true">image-20210728105035255</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210728105057621.png" alt="image-20210728105057621" /><figcaption aria-hidden="true">image-20210728105057621</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210728105118549.png" alt="image-20210728105118549" /><figcaption aria-hidden="true">image-20210728105118549</figcaption>
</figure>
<h3 id="配置">配置</h3>
<p>配置GPIO的通用流程如下：</p>
<ol type="1">
<li><strong>规划设备的引脚布局</strong> 列出应用所需的所有外围设备的清单。使用设备数据手册中的外设复用信息，选择哪些GPIO用于外设信号。决定在剩余的GPIO中，哪些作为每个CPU和CLA的输入和输出。一旦选择了外设复用，就应该通过向 <code>GPyMUX1/2</code> 和 <code>GPyGMUX1/2</code> 寄存器写入适当的值来实现。当改变一个引脚的GPyGMUX值时，一定要先将相应的GPyMUX位设置为0，以避免在复用中出现突发。默认情况下，所有引脚都是通用的I/O，而不是外围信号。</li>
<li>(可选）<strong>启用内部上拉电阻</strong> 要启用或禁用上拉电阻，请写到GPIO上拉禁用寄存器 <code>GPyPUD</code> 中的相应位。所有的上拉电阻在默认情况下是禁用的。当没有外部信号驱动时，上拉可以用来保持输入引脚处于已知状态。</li>
<li><strong>选择输入资格</strong> 如果该引脚将被用作输入，请指定所需的输入鉴定（如果有）。在 <code>GPyCTRL</code> 寄存器中选择输入鉴定的采样周期，而在 <code>GPyQSEL1</code> 和 <code>GPyQSEL2</code> 寄存器中选择鉴定的类型。默认情况下，所有鉴定都是同步的，采样周期等于 <code>PLLSYSCLK</code>。关于输入鉴定的解释，请参见第8.4节。</li>
<li><strong>选择任何通用I/O引脚的方向</strong> 对于每个配置为GPIO的引脚，使用 <code>GPyDIR</code> 寄存器指定该引脚的方向为输入或输出。<mark>默认情况下，所有的GPIO引脚都是输入</mark>。在改变引脚为输出之前，通过向 <code>GPySET</code> 、<code>GPyCLEAR</code> 或 <code>GPyDAT</code> 寄存器写入要驱动的值来加载输出闩锁。一旦锁存器被加载，写入 <code>GPyDIR</code> 来改变引脚的方向。默认情况下，所有输出锁存器为零。</li>
<li><strong>选择低功耗模式的唤醒源</strong> <code>GPIO 0-63</code> 可以用来将系统从低功耗模式唤醒。要选择一个或多个GPIO进行唤醒，请写到 <code>GPIOLPMSEL0</code> 和 <code>GPIOLPMSEL1</code> 寄存器的相应位。这些寄存器是CPU系统寄存器空间的一部分。关于低功耗模式和GPIO唤醒的更多信息，请参见系统控制和中断章节中的低功耗模式部分。</li>
<li><strong>选择外部中断源</strong> 配置外部中断是一个两步的过程。首先，中断本身必须被启用，其极性必须通过 <code>XINTnCR</code> 寄存器进行配置。其次，必须通过选择输入X-BAR信号4、5、6、13和 14 的来源来设置XINT1-5 GPIO引脚。关于输入X-BAR结构的更多信息，请参见本手册的Crossbar(XBAR)章节。</li>
</ol>
<h4 id="案例">案例</h4>
<p>如 <a target="_blank" rel="noopener" href="http://code.islet.space/TI/f28004x/group__gpio__api.html">GPIO配置手册</a> 所示，<code>GPIO_SetupPinMux();</code> 和 <code>GPIO_SetupPinOption();</code> 并不存在，这两个是存在于 <code>f28004x_gpio.h</code> 中的自定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// AFE_InitGpio - Initialize the GPIOs on launchpad and boosterpack</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AFE_InitGpio</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EALLOW; <span class="comment">// below registers are &quot;protected&quot;, allow access.</span></span><br><span class="line">    <span class="comment">//GPIO-23 - LaunchPad RED LED</span></span><br><span class="line">    GPIO_SetupPinMux(<span class="number">23</span>, GPIO_MUX_CPU1, <span class="number">0</span>);</span><br><span class="line">    GPIO_SetupPinOptions(<span class="number">23</span>, GPIO_OUTPUT, GPIO_PUSHPULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GPIO-34 - LaunchPad GREEN LED</span></span><br><span class="line">    GPIO_SetupPinMux(<span class="number">34</span>, GPIO_MUX_CPU1, <span class="number">0</span>);</span><br><span class="line">    GPIO_SetupPinOptions(<span class="number">34</span>, GPIO_OUTPUT, GPIO_PUSHPULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GPIO AFE BoosterPack LED</span></span><br><span class="line">    GPIO_SetupPinMux(<span class="number">4</span>, GPIO_MUX_CPU1, <span class="number">0</span>);</span><br><span class="line">    GPIO_SetupPinOptions(<span class="number">4</span>, GPIO_OUTPUT, GPIO_PUSHPULL);</span><br><span class="line"></span><br><span class="line">    GPIO_SetupPinMux(<span class="number">5</span>, GPIO_MUX_CPU1, <span class="number">0</span>);</span><br><span class="line">    GPIO_SetupPinOptions(<span class="number">5</span>, GPIO_OUTPUT, GPIO_PUSHPULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    GPIO_WritePin(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">    GPIO_WritePin(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">    EDIS;</span><br><span class="line">    <span class="comment">// Disable register access</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数说明">函数说明</h4>
<h5 id="引脚复用设置函数">引脚复用设置函数</h5>
<p>本函数用于将指定引脚与函数进行绑定，绑定前会自动检查对应的CPU和外设是否可用。</p>
<p>然后，创建指向相应寄存器的指针，这是对GPIO寄存器定义方式的一种变通。</p>
<p>头文件中的标准定义使得对一个寄存器或位进行命名访问非常容易，但很难进行任意的数字访问。有一个具有相同寄存器的GPIO模块阵列，包括像 <code>GPyCSEL1-4</code> 这样的多寄存器组的阵列，会更容易。但是头文件没有定义任何我们可以变成数组的东西，所以就用手动指针运算来代替。</p>
<p>要改变多路复用，首先将外设多路复用设置为0/GPIO，以避免出现故障，然后改变组复用，再将外设多路复用设置为目标值。最后，设置CPU选择。这个过程在《TRM》中有所描述。不幸的是，由于我们事先不知道引脚，我们不能硬编码一个位域参考，所以这里有一些棘手的位操作。</p>
<p><strong>警告</strong>：该代码不涉及模拟模式选择寄存器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// GPIO_SetupPinMux - Set the peripheral muxing for the specified pin.</span></span><br><span class="line"><span class="comment">// The appropriate parameters can be found in the pinout spreadsheet.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_SetupPinMux</span><span class="params">(Uint16 gpioNumber, Uint16 cpu, Uint16 muxPosition)</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Uint32 *gpioBaseAddr;</span><br><span class="line">    <span class="keyword">volatile</span> Uint32 *mux, *gmux, *csel;</span><br><span class="line">    Uint16 pin32, pin16, pin8;</span><br><span class="line"></span><br><span class="line">    pin32 = gpioNumber % <span class="number">32</span>;</span><br><span class="line">    pin16 = gpioNumber % <span class="number">16</span>;</span><br><span class="line">    pin8 = gpioNumber % <span class="number">8</span>;</span><br><span class="line">    gpioBaseAddr = (Uint32 *)&amp;GpioCtrlRegs + (gpioNumber/<span class="number">32</span>)*GPY_CTRL_OFFSET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Sanity check for valid cpu and peripheral values</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (cpu &gt; GPIO_MUX_CPU1CLA || muxPosition &gt; <span class="number">0xF</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Create pointers to the appropriate registers. This is a workaround</span></span><br><span class="line">    <span class="comment">// for the way GPIO registers are defined. The standard definition</span></span><br><span class="line">    <span class="comment">// in the header file makes it very easy to do named accesses of one</span></span><br><span class="line">    <span class="comment">// register or bit, but hard to do arbitrary numerical accesses. It&#x27;s</span></span><br><span class="line">    <span class="comment">// easier to have an array of GPIO modules with identical registers,</span></span><br><span class="line">    <span class="comment">// including arrays for multi-register groups like GPyCSEL1-4. But</span></span><br><span class="line">    <span class="comment">// the header file doesn&#x27;t define anything we can turn into an array,</span></span><br><span class="line">    <span class="comment">// so manual pointer arithmetic is used instead.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    mux = gpioBaseAddr + GPYMUX + pin32/<span class="number">16</span>;</span><br><span class="line">    gmux = gpioBaseAddr + GPYGMUX + pin32/<span class="number">16</span>;</span><br><span class="line">    csel = gpioBaseAddr + GPYCSEL + pin32/<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Now for the actual function</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EALLOW;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// To change the muxing, set the peripheral mux to 0/GPIO first to avoid</span></span><br><span class="line">    <span class="comment">// glitches, then change the group mux, then set the peripheral mux to</span></span><br><span class="line">    <span class="comment">// its target value. Finally, set the CPU select. This procedure is</span></span><br><span class="line">    <span class="comment">// described in the TRM. Unfortunately, since we don&#x27;t know the pin in</span></span><br><span class="line">    <span class="comment">// advance we can&#x27;t hardcode a bitfield reference, so there&#x27;s some tricky</span></span><br><span class="line">    <span class="comment">// bit twiddling here.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    *mux &amp;= ~(<span class="number">0x3</span>UL &lt;&lt; (<span class="number">2</span>*pin16));</span><br><span class="line">    *gmux &amp;= ~(<span class="number">0x3</span>UL &lt;&lt; (<span class="number">2</span>*pin16));</span><br><span class="line">    *gmux |= (Uint32)((muxPosition &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3</span>UL) &lt;&lt; (<span class="number">2</span>*pin16);</span><br><span class="line">    *mux |= (Uint32)(muxPosition &amp; <span class="number">0x3</span>UL) &lt;&lt; (<span class="number">2</span>*pin16);</span><br><span class="line"></span><br><span class="line">    *csel &amp;= ~(<span class="number">0x3</span>L &lt;&lt; (<span class="number">4</span>*pin8));</span><br><span class="line">    *csel |= (Uint32)(cpu &amp; <span class="number">0x3</span>L) &lt;&lt; (<span class="number">4</span>*pin8);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// WARNING: This code does not touch the analog mode select registers.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="引脚属性设置函数">引脚属性设置函数</h5>
<p>为指定的引脚设置输入/出，可以通过已定义的标志（flags）来设置，这些标志都是16位的掩码。</p>
<p>输入引脚可用的标志如：</p>
<blockquote>
<p><code>GPIO_PULLUP</code> 使能拉高</p>
<p><code>GPIO_INVERT</code> 输入极性翻转</p>
<p><code>GPIO_SYNC</code> 与PLLSYSCLK同步输入阀（这条是默认的，可以不单独设置）</p>
<p><code>GPIO_QUAL3</code> 使用3采样质量</p>
<p><code>GPIO_QUAL6</code> 使用6采样质量</p>
<p><code>GPIO_ASYNC</code> 不使用同步或质量</p>
</blockquote>
<p>输出引脚可用标志如下：</p>
<blockquote>
<p><code>GPIO_OPENDRAIN</code> 工作在输出开漏模式</p>
<p><code>GPIO_PULLUP</code> 输出置高，</p>
</blockquote>
<p>注意：如果输出开漏模式打开，也就自动打开了置高。输入配置里的 SYNC / QUAL3 / QUAL6 / ASYNC 只允许启用一个。</p>
<p><strong>默认输入状态</strong>：<strong>未同步</strong>（ASYNC）且无 <strong>置高</strong>（PULL-UP）和 <strong>极性翻转</strong>（INVERT）。</p>
<p><strong>默认输出状态</strong>：标准数字输出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_SetupPinOptions</span><span class="params">(Uint16 gpioNumber, Uint16 output, Uint16 flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Uint32 *gpioBaseAddr;</span><br><span class="line">    <span class="keyword">volatile</span> Uint32 *dir, *pud, *inv, *odr, *qsel;</span><br><span class="line">    Uint32 pin32, pin16, pinMask, qual;</span><br><span class="line"></span><br><span class="line">    pin32 = gpioNumber % <span class="number">32</span>;</span><br><span class="line">    pin16 = gpioNumber % <span class="number">16</span>;</span><br><span class="line">    pinMask = <span class="number">1UL</span> &lt;&lt; pin32;</span><br><span class="line">    gpioBaseAddr = (Uint32 *)&amp;GpioCtrlRegs + (gpioNumber/<span class="number">32</span>)*GPY_CTRL_OFFSET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Create pointers to the appropriate registers. This is a workaround</span></span><br><span class="line">    <span class="comment">// for the way GPIO registers are defined. The standard definition</span></span><br><span class="line">    <span class="comment">// in the header file makes it very easy to do named accesses of one</span></span><br><span class="line">    <span class="comment">// register or bit, but hard to do arbitrary numerical accesses. It&#x27;s</span></span><br><span class="line">    <span class="comment">// easier to have an array of GPIO modules with identical registers,</span></span><br><span class="line">    <span class="comment">// including arrays for multi-register groups like GPyQSEL1-2. But</span></span><br><span class="line">    <span class="comment">// the header file doesn&#x27;t define anything we can turn into an array,</span></span><br><span class="line">    <span class="comment">// so manual pointer arithmetic is used instead.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    dir = gpioBaseAddr + GPYDIR;</span><br><span class="line">    pud = gpioBaseAddr + GPYPUD;</span><br><span class="line">    inv = gpioBaseAddr + GPYINV;</span><br><span class="line">    odr = gpioBaseAddr + GPYODR;</span><br><span class="line">    qsel = gpioBaseAddr + GPYQSEL + pin32/<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    EALLOW;</span><br><span class="line"></span><br><span class="line">    *dir &amp;= ~pinMask;      <span class="comment">// Set the data direction</span></span><br><span class="line">    <span class="keyword">if</span> (output == <span class="number">1</span>)&#123;</span><br><span class="line">        *dir |= pinMask;   <span class="comment">// Output, with optional open drain mode and pull-up</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; GPIO_OPENDRAIN) *odr |= pinMask;  <span class="comment">// Enable open drain if necessary</span></span><br><span class="line">        <span class="keyword">else</span> *odr &amp;= ~pinMask;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; (GPIO_OPENDRAIN | GPIO_PULLUP)) *pud &amp;= ~pinMask;  <span class="comment">// Enable pull-up if necessary. Open drain mode must be active.</span></span><br><span class="line">        <span class="keyword">else</span> *pud |= pinMask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *dir &amp;= ~pinMask;        <span class="comment">// Input, with optional pull-up, qualification, and polarity inversion</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; GPIO_PULLUP) *pud &amp;= ~pinMask;     <span class="comment">// Enable pull-up if necessary</span></span><br><span class="line">        <span class="keyword">else</span> *pud |= pinMask;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; GPIO_INVERT) *inv |= pinMask;   <span class="comment">// Invert polarity if necessary</span></span><br><span class="line">        <span class="keyword">else</span> *inv &amp;= ~pinMask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Extract the qualification parameter and load it into the register.</span></span><br><span class="line">    <span class="comment">// This is also needed for open drain outputs, so we might as well do it</span></span><br><span class="line">    <span class="comment">// all the time.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    qual = (flags &amp; GPIO_ASYNC) / GPIO_QUAL3;</span><br><span class="line">    *qsel &amp;= ~(<span class="number">0x3</span>L &lt;&lt; (<span class="number">2</span> * pin16));</span><br><span class="line">    <span class="keyword">if</span> (qual != <span class="number">0x0</span>) *qsel |= qual &lt;&lt; (<span class="number">2</span> * pin16);</span><br><span class="line"></span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中断">中断</h2>
<p>此处的中断更多的是讲 <strong>外设中断</strong>，当然后面也会涉及到定时器中断部分，因此统称为中断了，阅读是需要加以区分。</p>
<p><mark>C28x系列芯片有14条外设中断可用，其中13和14中断被直接关联至CPU定时器1和定时器2。</mark> 从中断向量表里，也只能看到第1组到第12组中断向量，要绑定定时器1和定时器2的中断程序的话，需要绑定到（不存在与中断向量表）上的第13和第14中断。</p>
<p>剩余12条中断（就是第1~第12条中断）可以通过 <strong>增强型外围中断扩展</strong>（enhanced Peripheral Interrupt Expansion，ePIE)模块进行信号引导。<mark>本模块将最多16个外设中断复用到每个CPU中断线中，并扩展了向量表，允许每个中断有自己的ISR。</mark>允许芯片支持数量众多的外围设备。</p>
<p>中断路径一共有三个阶段—— <strong><em>外设中断阶段</em></strong>、<strong><em>PIE模块阶段</em></strong> 和 <strong><em>CPU阶段</em></strong>。每个阶段都有其使能和标志寄存器。本系统允许CPU在其他中断等待时处理一个中断，在软件中实现并优先处理嵌套中断，并在某些关键任务中禁用中断。</p>
<p>外部中断（external interrupt, XINT）电气特性数据和时序特性：</p>
<p><strong>表31</strong> 列出了外部中断的时间要求</p>
<p><strong>表32</strong> 列出了外部中断开断特性</p>
<p><strong>图25</strong> 展示了外部中断的时序</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210712083326344.png" alt="image-20210712083326344" /><figcaption aria-hidden="true">image-20210712083326344</figcaption>
</figure>
<h3 id="中断架构">中断架构</h3>
<p>下图展示了本系列芯片的中断架构。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210728111202805.png" alt="image-20210728111202805" /><figcaption aria-hidden="true">image-20210728111202805</figcaption>
</figure>
<h4 id="stage0---外设中断阶段">STAGE0 - 外设中断阶段</h4>
<p>每个外设都有其独立的中断配置，在每个设备的章节中都有描述。某些外设允许多种事件来触发相同的中断信号。例如，通信外设就可能使用相同的中断来检查数据是否被接收或者是否存在传输错误。中断的触发状态可以通过查看外设状态寄存器来确定。通常，在下一次中断生成前，需要手动清除前一次在状态寄存器上的数据位。</p>
<h4 id="stage1---pie阶段">STAGE1 - PIE阶段</h4>
<p>PIE控制器是指用于外围设备中断控制（Peripheral Interrupt Control）的寄存器。</p>
<p>PIE为每一个外设中断信号都提供了独立的标志和使能寄存器位，这些外设中断信号通常也被称为 <strong><em>PIE通道</em></strong>。这些通道根据关联的CPU中断（associated CPU interrupt）被进行绑定成 <strong>组</strong>（group）。每一个PIE组都拥有一个16bit的 <strong>使能寄存器</strong> <strong><em>PIEIERx</em></strong> 和 一个16bit的 <strong>标志寄存器</strong> <strong><em>PIEIFRx</em></strong> ，并且在PIE确认寄存器 <strong><em>PIEACK</em></strong> 中还有一个bit。<mark><strong><em>PIEACK</em></strong> register bit acts as a common interrupt mask for the entire <strong><em>PIE</em></strong> group.</mark></p>
<p>当CPU接收一个中断时，从PIE中查找到中断服务程序的地址（fetches the address of the ISR）。【因此写完中断服务程序时需要将程序的地址绑定到PIE上，如下面代码。】PIE返回组中 <strong>同时被使能且被标志了的</strong>（both flagged and enabled） <strong>最低数字的通道</strong>（lowest-numbered channel）的向量地址。在多数中断都被 <strong>阻塞</strong>（pending）时，这相当于给了低优先级中断一个较高的权限。</p>
<p>如果没有中断被同时标志和使能，PIE就会返回通道1的向量地址。这种情况通常不会发生，只有在 <strong>PIE改变状态时</strong> <strong>中断也同时</strong> 生成才会。（software changes the state of the PIE while an interrupt is propagating）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EALLOW;</span><br><span class="line">PieVectTable.ADCA1_INT = &amp;adcA1ISR;   <span class="comment">//为通道ADCA1绑定中断应用 adcA1ISR</span></span><br><span class="line">EDIS;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210728110450590.png" alt="image-20210728110450590" /><figcaption aria-hidden="true">image-20210728110450590</figcaption>
</figure>
<h4 id="stage2---cpu阶段">STAGE2 - CPU阶段</h4>
<p>和PIE相似，CPU 也为每一个中断提供了对应的标志和使能寄存器位。在CPU内部寄存器中，有一个 <strong>中断使能寄存器</strong>（<strong>IER</strong>）和一个 <strong>中断标志寄存器</strong>（<strong>IFR</strong>）。CPU内部还有一个由 <strong><em>ST1</em></strong> 寄存器下的 <strong><em>INTM</em></strong> 位 控制的 <strong>全局中断屏蔽</strong>（global interrupt mask），该屏蔽可以用CPU的 <code>SETC</code> 和 <code>CLRC</code> 指令进行进行设置和清除操作。对应到C语言的代码中，就是C2000套件的宏定义 <code>DINT</code> 和 <code>EINT</code> 。</p>
<p>对 <code>IER</code> 和 <code>INTM</code> 的写入都是原子操作。原则上，一旦设置了 <code>INTM</code> 位，队列（pipeline）里的下个指令将会在所有中断都被关闭的情况下运行，不需要软件延迟。</p>
<h3 id="中断顺序">中断顺序</h3>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210816112840611.png" alt="image-20210816112840611" /><figcaption aria-hidden="true">image-20210816112840611</figcaption>
</figure>
<p>当外设生成中断（在第x组PIE，第y通道）时，以下事件顺序将会触发：</p>
<ol type="1">
<li>中断被锁定在 <code>PIEIFRx.y</code></li>
<li>如果 <code>PIEIERx.y</code> 被设置 ，中断生成</li>
<li>如果 <code>PIEACK.x</code> 被清除，中断生成且 <code>PIEACK</code> 被设置</li>
<li>中断被锁定在 <code>IFR.x</code></li>
<li>如果 <code>IER.x</code> 被设置，中断生成</li>
<li>如果 <code>INTM</code> 被清除，CPU接收中断</li>
<li>任何在管道里的D2或更后面的阶段的指令将会运行到完成。更早阶段的指令将会被清除（flushed）。</li>
<li>CPU在堆（stack）上保存内容</li>
<li><code>IFR.x</code> 和 <code>IER.x</code> 被清除。<code>INTM</code> 被设置。<code>EALLOW</code> 被清除。</li>
<li>CPU中PIE中索引到ISR的地址。<code>PIEIFR.y</code> 被清除</li>
</ol>
<p>所谓中断延迟是指介于 <code>PIEIFRx.y</code> <strong>锁存中断</strong> 和 <strong>第一个ISR指令进入CPU队列的执行阶段</strong> 之间的时间。</p>
<p>最小的中断延迟时间是14个系统周期，在ISR或堆内存中的等待时间也会增加延迟。</p>
<p>外部中断为了 <strong>GPIO同步</strong> 和 <strong>输入限制</strong>（input qualification），增加了最少2个系统周期。</p>
<p>使用C28x <code>RPT</code> 指令创建的循环无法被中断。</p>
<h3 id="定时器中断">定时器中断</h3>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210830140222956.png" alt="image-20210830140222956" /><figcaption aria-hidden="true">image-20210830140222956</figcaption>
</figure>
<p>在 <code>cputimer.h</code> 头文件中，可以看到定时器配置的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CPUTIMER_REGS</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>   <span class="title">TIM_REG</span>                          <span class="title">TIM</span>;</span>                          <span class="comment">// CPU-Timer, Counter Register</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>   <span class="title">PRD_REG</span>                          <span class="title">PRD</span>;</span>                          <span class="comment">// CPU-Timer, Period Register</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>   <span class="title">TCR_REG</span>                          <span class="title">TCR</span>;</span>                          <span class="comment">// CPU-Timer, Control Register</span></span><br><span class="line">    Uint16                                   rsvd1;                        <span class="comment">// Reserved</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>   <span class="title">TPR_REG</span>                          <span class="title">TPR</span>;</span>                          <span class="comment">// CPU-Timer, Prescale Register</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>   <span class="title">TPRH_REG</span>                         <span class="title">TPRH</span>;</span>                         <span class="comment">// CPU-Timer, Prescale Register High</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>cputimervars.h</code> 头文件中，直接配置了如下结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// CPU Timer Support Variables:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CPUTIMER_VARS</span> &#123;</span></span><br><span class="line">   <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span>  <span class="title">CPUTIMER_REGS</span>  *<span class="title">RegsAddr</span>;</span></span><br><span class="line">   Uint32    InterruptCount;</span><br><span class="line">   <span class="keyword">float</span>   CPUFreqInMHz;</span><br><span class="line">   <span class="keyword">float</span>   PeriodInUSec;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过在结构体内声明寄存器指针，并在结构体外定义对应的结构体变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Globals</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CPUTIMER_VARS</span> <span class="title">CpuTimer0</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CPUTIMER_VARS</span> <span class="title">CpuTimer1</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CPUTIMER_VARS</span> <span class="title">CpuTimer2</span>;</span></span><br></pre></td></tr></table></figure>
<p>在对CPU定时器初始化时，则不是操作 <code>struct CPUTIMER_VARS</code> ，而是直接操作对应的三个定时器（timer0 ~ timer2）的寄存器。</p>
<p>在后续对定时器的配置中，也只是将 <strong>系统频率</strong> <code>CPUFreqInMHz</code> 和 <strong>定时器周期</strong> <code>PeriodInUSec</code> 的配置进行了较为方便的配置而已，书写成嵌套结构体的形式也节省了在函数内声明变量，方便了多个定时器不同配置的相似处理，在代码实际执行过程中，仍然是对寄存器进行直接操作。</p>
<p>定时器清空：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CpuTimer0.RegsAddr = &amp;CpuTimer0Regs;    <span class="comment">// 初始化地址指针指向对应的定时器寄存器</span></span><br><span class="line">CpuTimer0Regs.PRD.all  = <span class="number">0xFFFFFFFF</span>;    <span class="comment">// 初始化定时器周期至最大（PRD寄存器）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将定时器的预分频初始化并保持与系统时钟一致的速率</span></span><br><span class="line">CpuTimer0Regs.TPR.all  = <span class="number">0</span>;  <span class="comment">// 初始化预分频寄存器为0</span></span><br><span class="line">CpuTimer0Regs.TPRH.all = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化定时器控制寄存器</span></span><br><span class="line">CpuTimer0Regs.TCR.bit.TSS = <span class="number">1</span>;</span><br><span class="line">CpuTimer0Regs.TCR.bit.TRB = <span class="number">1</span>;    <span class="comment">// 使用周期值重新载入所有计数器寄存器</span></span><br><span class="line">CpuTimer0.InterruptCount = <span class="number">0</span>;    <span class="comment">// 复位中断计数器</span></span><br></pre></td></tr></table></figure>
<p>定时器配置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Uint32 temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化定时器周期</span></span><br><span class="line">Timer-&gt;CPUFreqInMHz = Freq;</span><br><span class="line">Timer-&gt;PeriodInUSec = Period;</span><br><span class="line">temp = (<span class="keyword">long</span>) (Freq * Period);</span><br><span class="line">Timer-&gt;RegsAddr-&gt;PRD.all = temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将定时器的预分频初始化并保持与系统时钟一致的速率</span></span><br><span class="line">Timer-&gt;RegsAddr-&gt;TPR.all  = <span class="number">0</span>;</span><br><span class="line">Timer-&gt;RegsAddr-&gt;TPRH.all  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化定时器控制寄存器</span></span><br><span class="line">Timer-&gt;RegsAddr-&gt;TCR.bit.TSS = <span class="number">1</span>;    <span class="comment">// 1 = Stop timer, 0 = Start/Restart Timer</span></span><br><span class="line">Timer-&gt;RegsAddr-&gt;TCR.bit.TRB = <span class="number">1</span>;    <span class="comment">// 1 = reload timer</span></span><br><span class="line">Timer-&gt;RegsAddr-&gt;TCR.bit.SOFT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Timer-&gt;RegsAddr-&gt;TCR.bit.FREE = <span class="number">0</span>;    <span class="comment">// Timer Free Run Disabled</span></span><br><span class="line">Timer-&gt;RegsAddr-&gt;TCR.bit.TIE = <span class="number">1</span>;    <span class="comment">// 0 = Disable 1 = Enable Timer Interrupt</span></span><br><span class="line">Timer-&gt;InterruptCount = <span class="number">0</span>;    <span class="comment">// Reset interrupt counter</span></span><br></pre></td></tr></table></figure>
<p>将定时器的清空和配置两个操作步骤类似，可以简单归纳成流程图形式：</p>
<pre class="mermaid">graph LR
初始化周期 --> 设定定时器速率 --> 设置定时器工作方式</pre>
<h3 id="配置方法">配置方法</h3>
<p>上电时，默认情况下任何中断都不被使能。PIEIER 寄存器和 IER寄存器被清除， INTM寄存器被设置。应用代码负责配置和使能所有外设中断。</p>
<h4 id="使能中断">使能中断</h4>
<p>以下为中断使能步骤：</p>
<ol type="1">
<li>全局性地关闭中断（<code>DINT</code> 或者 <code>SETC INTM</code>)</li>
<li>通过设置 <code>PIECTRL</code> 寄存器的 <code>ENPIE</code> 位来使能PIE。</li>
<li>为每个中断在PIE向量表里的对应位置上写ISR向量（中断服务程序地址），如下表3所示，注意下表是 EALLOW 保护的。</li>
</ol>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210817095119399.png" alt="image-20210817095119399" /><figcaption aria-hidden="true">image-20210817095119399</figcaption>
</figure>
<ol start="4" type="1">
<li>为每个中断设置对应的 <code>PIEIERx</code> 位。（不要使用直接连接至CPU的定时器1和定时器2）</li>
<li>为所有拥有已启用中断的PIE组（for any PIE group containing enabled interrupts）设置CPU的IER位</li>
<li>启用外设中断</li>
<li>全局性启动中断（<code>EINT</code> 或 <code>CLRC INTM</code>）</li>
</ol>
<p>上表中，横向为组，如 [x,y]，x为组。</p>
<p><mark>上方使能中断的流程，即中断初始化和配置的流程，重新用流程图的方式总结如下：</mark></p>
<pre class="mermaid">graph LR
初始化PIE --> 关闭所有中断 --> 清空PIE向量表 --> 将ISR绑定中断向量表 -->初始化CPU定时器 -->调整CPU定时器周期和工作方式 --> 打开对应的组中断 --> 打开对应的中断向量 --> 使能中断</pre>
<p>以下代码为上方流程的示例，部分代码也仅为函数封装，具体内容需要参考详细文档描述。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">InitPieCtrl();            <span class="comment">//初始化PIE（外设中断）模块</span></span><br><span class="line">ClearCPUInterrupt();      <span class="comment">//关闭并清除所有CPU中断</span></span><br><span class="line">InitPieVectTable();       <span class="comment">//清空PIE（外设中断）向量表</span></span><br><span class="line"></span><br><span class="line">EALLOW;  <span class="comment">//关闭中断向量表寄存器写保护</span></span><br><span class="line">PieVectTable.ADCA1_INT = &amp;adcA1ISR;   <span class="comment">//为ADCA的中断INT1（即ADCA1）绑定中断应用（的向量地址） &amp;adcA1ISR</span></span><br><span class="line">PieVectTable.ADCC2_INT = &amp;adcC2ISR;   <span class="comment">//绑定中断服务程序至中断向量表，C0通道和C2通道同用一个程序</span></span><br><span class="line">PieVectTable.TIMER0_INT = &amp;cpuTimer0ISR;   <span class="comment">// 将cpuTimer0ISR定时器0中断服务器程序绑定至对应的中断向量表</span></span><br><span class="line">EDIS;</span><br><span class="line"></span><br><span class="line">InitCpuTimers();  <span class="comment">//初始化CPU定时器</span></span><br><span class="line"></span><br><span class="line">ConfigCpuTimer(&amp;CpuTimer0, <span class="number">100</span>, TIMER0_PRD);   <span class="comment">//第一个参数填写定时器序号，第二个参数填写CPU主频，第三个参数填写定时器中断周期（微秒）</span></span><br><span class="line"></span><br><span class="line">CpuTimer0Regs.TCR.all = <span class="number">0x4000</span>;</span><br><span class="line"></span><br><span class="line">IER |= M_INT1;               <span class="comment">// 打开组1中断（group 1 interrupt）， ADC A模块 和 CPU定时器0 的 中断处理程序需要使用</span></span><br><span class="line">IER |= M_INT10;             <span class="comment">// 打开组10中断（group 10 interrupt），ADC C模块中断处理程序需要使用</span></span><br><span class="line"></span><br><span class="line">PieCtrlRegs.PIEIER1.bit.INTx1 = ON;  <span class="comment">//打开中断向量表中的1.1中断，其中PIEIER是中断使能寄存器，其后的数字1是组1，INTx1是指第一个中断</span></span><br><span class="line">PieCtrlRegs.PIEIER10.bit.INTx10 = ON;  <span class="comment">//打开ADCC2对应的中断向量</span></span><br><span class="line">PieCtrlRegs.PIEIER1.bit.INTx7 = ON;  <span class="comment">//打开定时器0对应的中断向量</span></span><br><span class="line"></span><br><span class="line">EINT;                               <span class="comment">// 使能中断</span></span><br><span class="line">ERTM;                             <span class="comment">// 打开调试模式</span></span><br></pre></td></tr></table></figure>
<h4 id="处理中断">处理中断</h4>
<p>ISR中断处理程序基本与普通程序一直，以下几点需要遵守：</p>
<ol type="1">
<li>保存和恢复特定的CPU寄存器状态（如果需要）</li>
<li>为中断组清除 <code>PIEACK</code> 位</li>
<li>使用 <code>IRET</code> 指令来返回</li>
</ol>
<p>如果函数定义时使用了 <code>__interrupt</code> 关键字，第一条和第三条会由C编译器自动处理。</p>
<p>与中断组相关的PIEACK 位必须在用户代码中手动清除，通常是在ISR的末尾执行该操作。如果PIEACK没有被清除，那么CPU将不会继续接收改组的中断。此处与不经过PIE的定时器中断有所不同。</p>
<p><mark>在使用了 <code>__interrupt</code> 关键字后，中断处理时，唯一需要注意的就是对该中断的组进行中断确认，如果没有确认，该中断只会被进行一次，确认组中断的代码如下：</mark></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;  <span class="comment">//确认组1的中断</span></span><br></pre></td></tr></table></figure>
<h4 id="关闭中断">关闭中断</h4>
<p>为关闭所有中断，需通过 <code>DINT</code> 和 <code>SETC INTM</code> 来设置CPU的全局中断屏蔽。不需要在设置 <code>INTM</code> 或 修改IER后添加 <code>NOP</code>，在中断关闭后会有下一条指令将被执行。</p>
<p>通过操作 <code>PIEIERx</code> 寄存器能够关闭独立中断，但需要避免竞争发生。当 <code>PIEIER</code> 写入完成时，如果中断信号准备好要生成，该中断信号将会直接到达CPU并且造成假中断的触发。为避免假中断的触发，应循以下步骤：</p>
<ol type="1">
<li>全局性禁止中断（<code>DINT</code> 或 <code>SETC INTM</code>）</li>
<li>为中断清除 <code>PIEIER</code> 位</li>
<li>等待5个周期（系统周期？）以确保任何已生成的中断能够到达CPU的IFR寄存器</li>
<li>为中断的PIE组清除CPU的IFR位 和 <code>PIEACK</code> 位</li>
<li>全局性启用中断（<code>EINT</code> 或 <code>CLRC INTM</code>）</li>
</ol>
<p>使用CPU的 <strong><em>IER</em></strong> 寄存器可以禁用中断组。此时不会产生竞争，因此无需特殊的程序进行处理。</p>
<p><code>PIEIER</code> 位不可以被软件清除（must never be cleared in software），因为 读/写/改 操作可能会对进入CPU的中断造成影响（may cause incoming interrupts to be lost）。唯一安全的清除 <code>PIEIER</code> 位的方法是让CPU处理该中断。以下程序步骤可以用于绕过普通ISR：</p>
<ol type="1">
<li>全局性禁止中断（<code>DINT</code> 或 <code>SETC INTM</code>）</li>
<li>修改PIE向量表以将 <code>PIEIFR</code> 位的中断向量映射至空的ISR上，该ISR将只包含一个来自中断指令 <code>IRET</code> 的返回（contain a return from interrupt instruction）</li>
<li>在外设寄存器上禁用中断</li>
<li>全局性启用中断（<code>EINT</code> 或 <code>CLRC INTM</code>）</li>
<li>等待空的ISR为阻塞中断服务</li>
<li>全局性禁止中断（<code>DINT</code> 或 <code>SETC INTM</code>）</li>
<li>修改PIE向量表以将中断向量映射回至其原始的ISR（original ISR）</li>
<li>为中断的PIE组清除 <code>PIEACK</code> 位</li>
<li>全局性启用中断（<code>EINT</code> 或 <code>CLRC INTM</code>）</li>
</ol>
<h4 id="嵌套式中断">嵌套式中断</h4>
<p>默认情况下，中断不会嵌套。通过软件操控 <code>IER</code> 和 <code>PIEIERx</code> 寄存器可以实现对中断的嵌套和优先级排序。详见 <a target="_blank" rel="noopener" href="https://processors.wiki.ti.com/index.php/Interrupt_Nesting_on_C28x">TI Wiki</a></p>
<h4 id="向量地址有效性检查">向量地址有效性检查</h4>
<p>ePIE向量表有两个备份，初级向量表地址在 <code>0xD00</code> 到 <code>0xEFF</code> 之间，冗余向量表的地址在 <code>0x01000D00</code> 到 <code>0x01000EFF</code> 之间。对初级向量表的写入时也将会对冗余向量表进行写入，对冗余向量表的写入仅对冗余向量表有效。读取时，两个向量表互相独立。</p>
<p>在向量地址获取时，ePIE将会对两个向量表的输出进行比较。如果没有差别，CPU会生成一个地址并存放到 <strong><em>PIEVERRADDR</em></strong> 寄存器中（the CPU branches to the address in the <strong><em>PIEVERRADDR</em></strong> register）并发送错误信号（trip signals）给PWM外设。如果 <strong><em>PIEVERRADDR</em></strong> 寄存器值没有被设置，地址 <code>0x003FFBE</code> 上用于默认启动的ROM句柄将会被使用。</p>
<h3 id="向量表">向量表</h3>
<p>《TRM》P89至P95.</p>
<h3 id="不可屏蔽中断和意外">不可屏蔽中断和意外</h3>
<h3 id="相关寄存器">相关寄存器</h3>
<p>下表来自《TRM》P506。下表中，寄存器分为4类：<strong>总控制</strong>、<strong>确认</strong>、<strong>使能</strong> 和 <strong>标志</strong>。</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210818103607977.png" alt="image-20210818103607977" /><figcaption aria-hidden="true">image-20210818103607977</figcaption>
</figure>
<h2 id="低电量模式">低电量模式</h2>
<p>本系列芯片拥有两种 时钟门（clock-gating） 低电量模式，分别是 HALT 和 IDLE，STANDARD 模式不支持进入低电量。</p>
<p>低电量模式的进入和退出代码，以及更多关于低电量模式的描述信息，需要参考《TRM》手册。</p>
<p>表33 描述了系统进入任何 时钟门 低电量模式后的影响</p>
<p>表34 列明了IDLE模式下的时序要求</p>
<p>表35 列明了IDLE模式下的开断特性</p>
<p>表36 列明了HALT模式下的时序要求</p>
<p>表37 列明了HALT模式下的开断特性</p>
<p>图26 展示了IDLE模式的时序框图</p>
<p>图27 展示了HALT模式的时序框图</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210712100908714.png" alt="image-20210712100908714" /><figcaption aria-hidden="true">image-20210712100908714</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210712101034377.png" alt="image-20210712101034377" /><figcaption aria-hidden="true">image-20210712101034377</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210712101211183.png" alt="image-20210712101211183" /><figcaption aria-hidden="true">image-20210712101211183</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210712101225955.png" alt="image-20210712101225955" /><figcaption aria-hidden="true">image-20210712101225955</figcaption>
</figure>
<h1 id="系统控制">系统控制</h1>
<h2 id="cla">CLA</h2>
<p>在涉及到一些需要使用浮点数计算的场景，就需要打开CLA。如果不打开，会发现32bit的系统上居然出现了int数据类型只有16bit的情况。</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210824202520424.png" alt="image-20210824202520424" /><figcaption aria-hidden="true">image-20210824202520424</figcaption>
</figure>
<p>控制律加速器(CLA)2型是一个独立的、完全可编程的、32位浮点数学处理器，它为C28x系列带来了并发的控制回路执行。CLA的低中断延迟允许它“及时”读取ADC示例。这显著减少了ADC样本的输出延迟，以实现更快的系统响应和更高的MHz控制回路。通过使用CLA服务于时间关键的控制回路，主CPU可以自由地执行其他系统任务，如通信和诊断。</p>
<p>CLA有以下特性：</p>
<ol type="1">
<li>C编译器适用于CLA软件开发</li>
<li>与主核心（SYSCLKOUT）频率一致</li>
<li>允许CLA算法独立于主核心执行的独立架构
<ul>
<li>完整总线架构
<ul>
<li>程序地址总线 和 程序数据总线</li>
<li>数据读取地址总线</li>
</ul></li>
</ul></li>
</ol>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210824203000371.png" alt="image-20210824203000371" /><figcaption aria-hidden="true">image-20210824203000371</figcaption>
</figure>
<h3 id="cla接口">CLA接口</h3>
<p>C28x的主芯片可以接入至CLA和vice versa。</p>
<p>CLA能够接入三种内存，包括：程序内存、数据内存和信息内存。每一种内存的行为和仲裁后续都会进行描述，CLA内存由DCSM模块（Dual Code Security Module，双代码安全模块）进行保护，可以参考系统控制和中断章节以获取更多安全计划相关的细节。</p>
<h3 id="cla-dma-cpu-仲裁">CLA / DMA / CPU 仲裁</h3>
<p>暂略</p>
<h3 id="cla-配置和调试">CLA 配置和调试</h3>
<p>暂略</p>
<h3 id="管道">管道</h3>
<p>暂略</p>
<h3 id="指令集">指令集</h3>
<p>暂略</p>
<h3 id="寄存器-1">寄存器</h3>
<p>暂略</p>
<h2 id="dma">DMA</h2>
<p>暂略</p>
<h1 id="模拟外设">模拟外设</h1>
<p>本系列芯片的模拟外设包含 <strong>ADC</strong> 、 <strong>PGA</strong> 、 <strong>DAC</strong> 和 <strong>CMPSS</strong>。</p>
<p>所有的模拟引脚一共有16个，包括ADC三个模块（module，A、B、C）、PGA、DAC等都是复用的。</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210805172817997.png" alt="image-20210805172817997" /><figcaption aria-hidden="true">image-20210805172817997</figcaption>
</figure>
<p>《TRM》P1420， 下表为模拟子系统寄存器详细：</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210809140243693.png" alt="image-20210809140243693" /><figcaption aria-hidden="true">image-20210809140243693</figcaption>
</figure>
<p>模拟子系统寄存器特征：（《TRM》P1410）</p>
<ul>
<li>灵活的电压基准
<ul>
<li>ADC模块使用 <code>VREFHIx</code> 和 <code>VSSA</code> 引脚提供电压参考</li>
<li>缓存DAC模块使用 <code>VREFHIx</code> 和 <code>VSSA</code> 引脚提供参考</li>
<li>比较器DAC模块使用 <code>VDDA</code> 和 <code>VSSA</code> 引脚提供参考</li>
</ul></li>
<li>灵活的针脚使用
<ul>
<li>缓存DAC输出、比较器子系统输入、PGA功能 和 数字输入 都与 ADC输入复用</li>
<li>Internal connection to VREFLO on all ADCs for offset self-calibration.</li>
</ul></li>
</ul>
<p>以下为64针封装芯片的模拟系统框图：</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210809142619290.png" alt="image-20210809142619290" /><figcaption aria-hidden="true">image-20210809142619290</figcaption>
</figure>
<h2 id="adc">ADC</h2>
<p>本系列芯片的ADC外设是 <strong>第5类</strong>（TYPE 5）ADC，只支持12位单端模式。以下讨论中可能会看到 ADCA / ADCB / ADCC 三种不同的描述，其实是ADC三个大的模块，模块下面又有很多个通道。</p>
<p><img src="https://pic.islet.space/2021/08/image-20210804113737347.png" alt="image-20210804113737347" style="zoom:67%;" /></p>
<p>单个ADC模块的简化示意图如下：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210730103920701.png" alt="image-20210730103920701" style="zoom:67%;" /></p>
<p>ADC模拟外设的内部架构如下：</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210730092532193.png" alt="image-20210730092532193" /><figcaption aria-hidden="true">image-20210730092532193</figcaption>
</figure>
<p>SOC和EOC的内部架构如下：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210730105429591.png" alt="image-20210730105429591" style="zoom:67%;" /></p>
<h3 id="adc特点">ADC特点</h3>
<ul>
<li>12bit 分辨率</li>
<li>VREFHI VREFLO</li>
<li>可选内部参考电压为 2.5V 或 3.3V</li>
<li>单端信号转换器</li>
<li>最多16个ADC通道</li>
<li>16个配置SOC（<code>ADCSOC0</code> ~ <code>ADCSOC15</code>）</li>
<li>16个独立的可寻址结果寄存器</li>
<li>四个高级的（flexible）外设中断（每个模块都有 <code>INT1</code> ~ <code>INT4</code>）</li>
<li>可配置的中断（interrupt placement）</li>
<li>可以设置爆发模式（Burst Mode）</li>
<li>多触发源
<ul>
<li>S/W ，软件立即启动</li>
<li>所有的ePWMs（<mark>只有ADC A 或 ADC B 所配置 SOC能够被触发</mark>）</li>
<li>GPIO XINT2</li>
<li>可以使用 CPU定时器 0/1/2触发</li>
<li>可以使用ADC A/B/C 的 INT1/2来配置触发SOC（<mark>可且仅可</mark>）</li>
</ul></li>
<li>四个PPB（post-processing blocks），每一个都有：
<ul>
<li>Saturating offset calibration</li>
<li>Error from setpoint calculation</li>
<li>High, low and zero-crossing compare, with interrupt and ePWM trip capability</li>
<li>Trigger-to-sample delay capture</li>
</ul></li>
</ul>
<h3 id="adc输入模型">ADC输入模型</h3>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210730091825651.png" alt="image-20210730091825651" /><figcaption aria-hidden="true">image-20210730091825651</figcaption>
</figure>
<p>每个通道的寄生电容</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210730093537064.png" alt="image-20210730093537064" /><figcaption aria-hidden="true">image-20210730093537064</figcaption>
</figure>
<h3 id="adc配置项">ADC配置项</h3>
<p>ADC模块的 配置项 分为 <strong>可配置</strong>（Configurable）、<strong>不可配置</strong>（Unconfigurable） 两种。可配置项又分为 <strong>可按模块独立配置</strong> 和 <strong>全局配置</strong>（Globally configurable） 两种。</p>
<table>
<thead>
<tr class="header">
<th>Options</th>
<th>Configurability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>时钟</strong> Clock</td>
<td>每个模块（A/B/C）</td>
</tr>
<tr class="even">
<td><strong>分辨率</strong> Resolution</td>
<td>不可配置（仅12bit）</td>
</tr>
<tr class="odd">
<td><strong>信号模式</strong> Signal mode</td>
<td>不可配置（仅单端（Single-ended））</td>
</tr>
<tr class="even">
<td><strong>参考电压源</strong> Reference voltage source</td>
<td>每个模块（外部或内部）</td>
</tr>
<tr class="odd">
<td><strong>触发源</strong> Trigger source</td>
<td>每个SOC</td>
</tr>
<tr class="even">
<td><strong>转换通道</strong> Converted Channel</td>
<td>每个SOC</td>
</tr>
<tr class="odd">
<td><strong>获取窗口期</strong> Acquisition window duration</td>
<td>每个SOC</td>
</tr>
<tr class="even">
<td><strong>EOC定位</strong> EOC location</td>
<td>每个模块</td>
</tr>
<tr class="odd">
<td><strong>爆发模式</strong> Burst mode</td>
<td>每个模块</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：这里的 <strong>SOC</strong> 是指 <strong>ADCSOC</strong>，start of conversion。</p>
<h4 id="时钟-1">时钟</h4>
<p>ADC基础时钟由系统时钟 <strong><em>SYSCLK</em></strong> 提供，用以生成ADC <strong>获取窗口</strong>（acquisition window）。寄存器 <strong><em>ADCCTL2</em></strong> 有一个决定ADC时钟 <strong><em>ADCCLK</em></strong> 的预分频（prescale）区域。<strong><em>ADCCLK</em></strong> 直接为转换器（converter）提供时钟信号。</p>
<p>转换核心需要约10.5个 <strong><em>ADCCLK</em></strong> 时钟周期来将 输入电压转换成 数字信号，因此需要自行决定和配置获取窗口所需要的周期大小。</p>
<p><img src="https://pic.islet.space/2021/08/image-20210805153739063.png" alt="image-20210805153739063" style="zoom: 67%;" /></p>
<h4 id="分辨率">分辨率</h4>
<p>ADC分辨率决定着最终模拟信号能够转换成的数值大小。本系列芯片支持12bit分辨率。</p>
<h4 id="参考电压源">参考电压源</h4>
<p>本系列芯片的第16、17引脚是ADC的参考电压：</p>
<ul>
<li>第16pin 是ADC A/B/C的高参考电压（Voltage Reference High） <strong><em>VREFHIx</em></strong></li>
<li>第17pin 是ADC A/B/C的低参考电压（Voltage Reference Low） <strong><em>VREFLOx</em></strong></li>
</ul>
<p>根据《TRM》P1442可知，每个ADC模块都可以配置一个单独的参考电压（包括 <strong>VREFHI</strong>和 <strong>VREFLO</strong>），参考电压源可以是内部或外部。需要注意的是，引脚数较少的封装可能在多个ADC之间共享一个VREFHI引脚。在这种情况下，共享一个参考引脚的ADC必须将它们的参考模式配置得完全一样。</p>
<h5 id="外部参考电源">外部参考电源</h5>
<p>在外部参考电压模式下，参考电压源的针脚被当做比率测量参考，以测定ADC转换的输入范围。</p>
<p>以下几点需要注意：</p>
<ul>
<li>如果没有连接到具体的外部 <strong><em>VREFLO</em></strong> 信号，需将 <strong><em>VREFLO</em></strong> 连接至 设备模拟地 <strong><em>VSSA</em></strong>。</li>
<li>外部参考电源（高/低）的输入范围：</li>
<li><strong><em>VREFHI</em></strong> 针脚要求外接电容。</li>
</ul>
<div style="text-align: center;">
<img src="https://pic.islet.space/2021/08/image-20210805090011967.png" alt="image-20210805090011967" style="zoom:70%;" /> <img src="https://pic.islet.space/2021/08/image-20210805090028640.png" alt="image-20210805090028640" style="zoom:70%;" />
</div>
<h5 id="内部参考电源">内部参考电源</h5>
<p>选择内部参考电源时，将由芯片设备来为 <strong><em>VREFHI</em></strong> 提供参考电源。 此电源电压可以被配置为 <code>2.5V</code> 或 <code>1.65V</code>，当配置 <code>1.65V</code> 时，模拟输入的范围最大为 <code>3.3V</code> 。</p>
<p><strong>注意</strong>：内部参考模式同样要求给 VREFHI针脚外接一个电容（具体电容值视具体情况而定）。</p>
<h5 id="ganged参考电源">Ganged参考电源</h5>
<p>某些封装中，多个ADC电压参考针脚可能被捆绑在了一起。这种情况下，当选择外部或内部参考模式，以及选择 <code>3.3V</code> 或 <code>2.5V</code> 内部参考电压范围时，有必要对ganged参考进行相同的配置。</p>
<p>例如，如果 ADC B 和 ADC C参考电源针脚被捆绑在一起，并且需要一个2.5V的内部参考电源时，以下配置代码可供参考：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ADCB VREFHI and ADCC VREFHI share a pin</span></span><br><span class="line"><span class="comment">//ADCB VREFLO and ADCC VREFLO share a pin</span></span><br><span class="line"><span class="comment">//Both references must be explicitly configured</span></span><br><span class="line"><span class="comment">//Both references must be configured identically</span></span><br><span class="line">SetVREF(ADC_ADCB, ADC_INTERNAL, ADC_VREF2P5);</span><br><span class="line">SetVREF(ADC_ADCC, ADC_INTERNAL, ADC_VREF2P5);</span><br></pre></td></tr></table></figure>
<p>内部硬件设备将确保相同针脚上的多个参考电源不会冲突。（ensure multiple references don't drive conflicting voltages onto the same pin）正因如此，参考电源可以被配置于任意顺序及任意时间。</p>
<h5 id="选择参考模式">选择参考模式</h5>
<p>电压参考模式可以用C2000套件提供的 <code>SetVREF()</code> 或 <code>ADC_setVREF()</code> 函数进行配置。使用这些函数时需确保 <strong>修正值</strong>（correct trim）已被载入 ADC trim 寄存器，需要确保设备复位后这些函数至少被调用一次，同时不要通过直接写入 <strong><em>ANAREFCTL</em></strong> 寄存器来配置电压参考模式。</p>
<h4 id="信号模式">信号模式</h4>
<p>本系列芯片支持单端模式，通过单根针脚 <code>ADCINx</code> 采样转换器的输入电压，参考点为 <code>VREFLO</code>。</p>
<h5 id="预期expected转换结果">预期（Expected）转换结果</h5>
<p>基于给定的模拟输入电压，预期情况下的数字转换结果如下表所示。小数部分省略。</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>模拟输入</th>
<th>数字输出</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>当输入电压低于参考低电压<br><strong><em>ADCINy</em></strong> ≤ <strong><em>VREFLO</em></strong></td>
<td><strong>最小量程</strong> <code>0x00</code></td>
</tr>
<tr class="even">
<td>当输入电压在高低参考电压之间<br><strong><em>VREFLO</em></strong> &lt; <strong><em>ADCINy</em></strong> &lt; <strong><em>VREFHI</em></strong></td>
<td><strong>最大量程</strong> <code>0xFFF</code> 和 <strong>输入电压差</strong> / <strong>参考电压差</strong> 之积<br>即 <code>0xFFF * (ADCINy - VREFLO) / (VREFHI - VREFLO)</code></td>
</tr>
<tr class="odd">
<td>当输入电压超过参考高电压<br><strong><em>ADCINy</em></strong> ≥ <strong><em>VREFHI</em></strong></td>
<td><strong>最大量程</strong> <code>0xFFF</code>（即 <code>2^(12)-1</code>）</td>
</tr>
</tbody>
</table>
<h5 id="解释interpreting转换结果">解释（Interpreting）转换结果</h5>
<p>基于给定的ADC数字转换结果，来反推理想的对应模拟输入的结果。公式就用上面的表格来反推就好了。</p>
<h3 id="adc寄存器">ADC寄存器</h3>
<p>寄存器这边除了描述最基本的 <strong>基地址</strong> （Base Address）以外，还有两类寄存器：<strong>结果寄存器</strong>（Result Register）和 <strong>控制寄存器</strong>（Control Register）。</p>
<p><img src="https://pic.islet.space/2021/08/image-20210805085945157.png" alt="image-20210805085945157" style="zoom: 85%;" /></p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210805090938982.png" alt="image-20210805090938982" /><figcaption aria-hidden="true">image-20210805090938982</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210805090858805.png" alt="image-20210805090858805" /><figcaption aria-hidden="true">image-20210805090858805</figcaption>
</figure>
<p><code>BSY</code> 即 <strong><em>busy</em></strong> ，繁忙状态。</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210809100855861.png" alt="image-20210809100855861" /><figcaption aria-hidden="true">image-20210809100855861</figcaption>
</figure>
<ul>
<li><code>ADCCTL1</code> 包括只读位和读写位。
<ul>
<li>只读位主要是涉及一些工作状态的读取，例如，<code>ADCBSY</code> 为 ADC是否正在工作，<code>ADCBSYCHN</code> 为 哪个通道在工作。</li>
<li>读写位涉及一些可操控的权限，例如 <code>ADCPWDNZ</code> 为 ADC的打开和关闭、<code>INTPULSEPOS</code> 为 ADC脉冲位置</li>
</ul></li>
<li><code>ADCCTL2</code> 目前仅有 一个可读写位，即 <code>PRESCALE</code> ，ADC模块的时钟预分频。</li>
</ul>
<h3 id="adc启动顺序">ADC启动顺序</h3>
<p>设备开启或系统级复位时，ADC会被断电禁用。为ADC上电启用时，请遵循以下顺序：</p>
<ol type="1">
<li>设置 <code>PCLKCR13</code> 寄存器中的指定位来启用所需 ADC 时钟</li>
<li>设置 <code>ADCCTL2</code> 寄存器中的 预分频 <code>PRESCALE</code> 位来设置 ADC的时钟分频</li>
<li>设置 <code>ADCCTL1</code> 寄存器中的 <code>ADCPWDNZ</code> 位来启用 ADC</li>
<li>采样前启用一个延迟（需要查询具体需要多长）</li>
</ol>
<p><strong>注意</strong>：如果多路ADC需要同步开启，第一步和第三步可以通过 <em>同一条写入指令</em>（in one write instruction）来进行配置。因此，也就可以用同一条延迟指令来等待ADC上电启动。</p>
<h3 id="adc时序">ADC时序</h3>
<p><img src="https://pic.islet.space/2021/08/image-20210807142240064.png" alt="image-20210807142240064" style="zoom:67%;" /></p>
<p><img src="https://pic.islet.space/2021/08/image-20210807142256816.png" alt="image-20210807142256816" style="zoom:67%;" /></p>
<p><img src="https://pic.islet.space/2021/08/image-20210807142458766.png" alt="image-20210807142458766" style="zoom:50%;" /></p>
<p><img src="https://pic.islet.space/2021/08/image-20210807142514410.png" alt="image-20210807142514410" style="zoom:50%;" /></p>
<h3 id="soc操作原则">SOC操作原则</h3>
<blockquote>
<p>Each SOC is a configuration set defining the single conversion of a single channel.</p>
</blockquote>
<p>注意上面这句话，<mark>每一个SOC都是一个定义着单通道转换器的配置集</mark>（Configuration Set）。</p>
<p>如果有需要，多个SOC可以配置于使用相同的触发器、通道 或 采样周期。使用相同的触发器来配置多个SOC的话，触发器可以生成一个转换序列（generate a sequence of conversions），同时相同的触发器和通道可以过采样（oversampling）。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210730094148462.png" alt="image-20210730094148462" style="zoom:80%;" /></p>
<p>在SOC配置集中有三个可配置项：</p>
<ul>
<li><code>ADCSOCFLG1</code> 启动转换的触发源（the trigger source that starts the conversion），操作某个bit可以启动某个SOC，详见《TRM》P1519</li>
<li><code>CHSEL</code> 转换通道（the channel to convert），可取值范围为 <code>0h</code> ~ <code>Fh</code>，代表 ADC0 ~ ADC15</li>
<li><code>ACQPS</code> 捕获窗口/采样周期（the acquisition window duration），可取值范围为 <code>000h</code> ~ <code>1FFh</code></li>
</ul>
<blockquote>
<p>Upon receiving the trigger configured for a soc, the wrapper will ensure that the specified channel is captured using the specified acquisition window duration.</p>
</blockquote>
<h4 id="acqps的计算">ACQPS的计算</h4>
<p><strong>注意</strong>：Acquisition Window 和 ACQPS 不是同一个概念，Acquisition Window 就是下方所述的 <strong><em>S</em> 和 <em>H</em> 的持续时间</strong>。</p>
<p>参考ADC输入模型简图：</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210730091825651.png" alt="image-20210730091825651" /><figcaption aria-hidden="true">image-20210730091825651</figcaption>
</figure>
<p>采样周期和 ACQPS的关系如下：</p>
<div style="text-align: center; font-weight: 900; font-style: italic;">
Acquisition window = (ACQPS + 1)∙(System Clock (SYSCLK) cycle time)
</div>
<p>以下案例在求解采样周期的基础上，倒推 ACQPS 的设置：</p>
<p>为了能够正确读取ADC数据，ADC输入信号必须有足够的时间为 <strong>采样和保持电容</strong> <code>Ch</code>（the sample and hold capacitor）充电。通常来说，<em>S</em> 和 <em>H</em> 的持续时间的选择是为了使采样电容被充电到最终值的 ½ LSB 或者 ¼ LSB ，具体取决于可容忍的 settling 误差（tolerable settling error）。</p>
<p>可以用 RC settling 模块来确定所需的 settling 时间近似值。具体时间常数模型如下方公式：</p>
<div style="text-align: center;">
<img src="https://pic.islet.space/2021/08/image-20210805180321634.png" alt="image-20210805180321634" style="zoom:100%;" />
</div>
<p>所需时间常数的数量也由下面等式给出：</p>
<div style="text-align: center;">
<img src="https://pic.islet.space/2021/08/image-20210805180508541.png" alt="image-20210805180508541" style="zoom:100%;" />
</div>
<p>最终<em>S</em> 和 <em>H</em> 的持续时间如下方公式所示：</p>
<div style="text-align: center;">
<img src="https://pic.islet.space/2021/08/image-20210805180522951.png" alt="image-20210805180522951" style="zoom:100%;" />
</div>
<blockquote>
<p>ADC输入模块需要提供以下参数：</p>
<ul>
<li><code>n</code> = ADC 分辨率 (in bits)</li>
<li><code>RON</code> = ADC 采样开关电阻 (in Ohms)</li>
<li><code>CH</code> = ADC 采样电容 (in pF)</li>
<li><code>Cp</code> = ADC 通道寄生输入电容 (in pF)</li>
</ul>
<p>以下参数则取决于应用（硬件/软件）设计： - settling error = tolerable settling error (in LSBs) - Rs = ADC 驱动电流源电阻值 (in Ohms) - CS = ADC 输入引脚上的 <strong><em>寄生电容值</em></strong> (in pF)</p>
</blockquote>
<p>通过以下参数来说明计算方式：</p>
<ul>
<li>n = 12-bits</li>
<li>RON = 500Ω</li>
<li>CH = 12.5pF</li>
<li>Cp = 12.7pF</li>
<li>settling error = ¼ LSB</li>
<li>Rs = 180Ω</li>
<li>Cs = 150pF</li>
</ul>
<p>时间常数计算如下：</p>
<div style="text-align: center;">
<img src="https://pic.islet.space/2021/08/image-20210805180544244.png" alt="image-20210805180544244" style="zoom:100%;" />
</div>
<p>所需时间常数的数量如下：</p>
<div style="text-align: center;">
<img src="https://pic.islet.space/2021/08/image-20210805180556088.png" alt="image-20210805180556088" style="zoom:100%;" />
</div>
<p>最终结果：</p>
<div style="text-align: center; font-weight: 900;">
37.8ns · 7.13 = 270ns
</div>
<p>如果系统时间 <strong><em>SYSCLK</em></strong> 为 <code>100 MHz</code> ，周期为 <code>10ns</code> ，则 S和H的持续时间应该是 <code>270 ns/10 ns = 27.0 SYSCLKs</code>，即27个系统时钟周期，为ADC输入信号所要提供的充足的ACQPS应该至少是 <code>CEILING(27.0) – 1 = 26</code></p>
<p>While this gives a rough estimate of the required acquisition window, a better method would be to setup a circuit with the ADC input model, a model of the source impedance/capacitance, and any board parasitics in SPICE (or similar software) and simulate to verify that the sampling capacitor settles to the desired accuracy.</p>
<p>参数计算代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * HEADER FILES</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * DATA TYPE DEFINITION</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> ADCPARAM;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * MACRO DEFINITION</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADC_RESOLUTION 12  <span class="comment">//定义分辨率为12位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSB 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * GLOBAL PARAMETERS</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">// r for Resistance , c for Capacitance </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">adc_parameters</span>&#123;</span></span><br><span class="line">    <span class="keyword">short</span> resolution;  <span class="comment">//分辨率</span></span><br><span class="line">    ADCPARAM r_on;  <span class="comment">// ADC采样开关电阻</span></span><br><span class="line">    ADCPARAM c_hold;   <span class="comment">// ADC采样和保持电容</span></span><br><span class="line">    ADCPARAM c_parasitic;   <span class="comment">// ADC通道寄生输入电容</span></span><br><span class="line"></span><br><span class="line">    ADCPARAM settling_error;  <span class="comment">//可容忍的沉降误差</span></span><br><span class="line">    ADCPARAM r_source;  <span class="comment">//ADC驱动电流源上的电阻值</span></span><br><span class="line">    ADCPARAM c_source;  <span class="comment">//ADC输入引脚上的寄生电容值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * FUNCTION DECLARATION</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function">ADCPARAM <span class="title">timeConstanceCalc</span><span class="params">(ADCPARAM, ADCPARAM, ADCPARAM, ADCPARAM, ADCPARAM)</span></span>;</span><br><span class="line"><span class="function">ADCPARAM <span class="title">numberCalc</span><span class="params">(ADCPARAM, ADCPARAM, ADCPARAM, ADCPARAM, ADCPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * MAIN FUNCTIONS</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注意： 所有电容值单位为 pF， 所有电阻值单位为 Ω</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adc_parameters</span> <span class="title">ADC1</span>;</span></span><br><span class="line">    ADC1.resolution = ADC_RESOLUTION;  <span class="comment">// 不可修改</span></span><br><span class="line">    ADC1.r_on = <span class="number">500</span>;  <span class="comment">//不变</span></span><br><span class="line">    ADC1.c_hold = <span class="number">12.5</span>;  <span class="comment">//不变</span></span><br><span class="line">    ADC1.c_parasitic = <span class="number">12.7</span>;  <span class="comment">//不变</span></span><br><span class="line"></span><br><span class="line">    ADC1.settling_error = <span class="number">1</span>/<span class="number">4.0</span> *LSB;  <span class="comment">//不要写1/4 *LSB，会得出无限大的数据（inf）</span></span><br><span class="line">    ADC1.r_source = <span class="number">1000</span>;   <span class="comment">//实际使用1kΩ，原180</span></span><br><span class="line">    ADC1.c_source = <span class="number">10000</span>;     <span class="comment">//带入0.1uF计算，原150</span></span><br><span class="line"></span><br><span class="line">    ADCPARAM result = <span class="number">0</span>;</span><br><span class="line">    result = <span class="built_in">timeConstanceCalc</span>(ADC1.r_source, ADC1.r_on, ADC1.c_hold, ADC1.c_source, ADC1.c_parasitic) * <span class="built_in">numberCalc</span>(ADC1.resolution, ADC1.settling_error, ADC1.c_source, ADC1.c_parasitic, ADC1.c_hold);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ADC采样和保持的时间为&quot;</span>  &lt;&lt; result &lt;&lt; <span class="string">&quot;ns&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * FUNCTION DEFINITIONS</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="function">ADCPARAM <span class="title">timeConstanceCalc</span><span class="params">(ADCPARAM Rs, ADCPARAM Ron, ADCPARAM Ch, ADCPARAM Cs, ADCPARAM Cp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( ( Rs + Ron ) * Ch + Rs * ( Cs + Cp ) ) /<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ADCPARAM <span class="title">numberCalc</span><span class="params">(ADCPARAM n, ADCPARAM se, ADCPARAM Cs, ADCPARAM Cp, ADCPARAM Ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">log</span>( <span class="built_in">exp2</span>(n) / se ) - <span class="built_in">log</span>( (Cs + Cp) / Ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="触发配置示例">触发配置示例</h4>
<p>官方SOC配置样例提供了四种：<strong>ePWM触发单次转换</strong>，<strong>ePWM触发超采样转换</strong>，<strong>CPU定时器触发多重转换</strong> 和 <strong>软件触发转换</strong></p>
<h5 id="epwm触发单次转换">ePWM触发单次转换</h5>
<p>当ePWM计时器到达周期时，为了配置好 ADCA模块，以生成通道 ADCIN1 上的单次转换，有以下步骤需要操作：</p>
<ol type="1">
<li>ePWM3必须被配置并生成一个SOCA 或 SOCB 信号（这种状态下，SOC的转换启动信号就由ePWM模块提供）。</li>
<li>以SOCB为例，使用SOC5，且选择任意16通道的其中一个。</li>
<li>假设在 系统频率为 100MHz时，需要100ns的采样周期，那么就需要AW（Acquisition Window）的持续时间为 <code>100ns / 10ns = 10 cycles</code>，<code>ACQPS</code> 需要设置为 <code>10 - 1 = 9</code> 。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AdcaRegs.ADCSOC5CTL.bit.CHSEL = <span class="number">1</span>; <span class="comment">//SOC5 will convert ADCINA1</span></span><br><span class="line">AdcaRegs.ADCSOC5CTL.bit.ACQPS = <span class="number">9</span>; <span class="comment">//SOC5 will use sample duration of 10 SYSCLK cycles </span></span><br><span class="line">AdcaRegs.ADCSOC5CTL.bit.TRIGSEL = <span class="number">10</span>; <span class="comment">//SOC5 will begin conversion on ePWM3 SOCB</span></span><br></pre></td></tr></table></figure>
<p>如上配置后，当ePWM3 到达其周期并生成一个SOCB信号，如果ADC此时处于空闲状态，ADC将会对通道 ADCINA1（SOC5） 立即进行采样；如果此时ADC繁忙，ADCINA1将会在SOC5获得权限后开始采样。ADC控制逻辑将会使用指定100ns的捕获窗口宽度对ADCINA1进行采样。在捕获完成后，ADC会立即开始转换采样电压为数字信号。当ADC转换完成时，结果将存放在 <code>ADCRESULT5</code> 寄存器。</p>
<h5 id="epwm触发超采样转换">ePWM触发超采样转换</h5>
<p>ADC可以配置超采样，即在相同的采样周期下，对同一个通道采样超过1次的采样方法。因为 SOC / 通道 / 触发 等配置参数可重复的特殊性，因此可以用于配置超采样。</p>
<p>为了配置ADC对通道 ADCINA1 超采样到达4次，此处使用和之前相同的配置，分别应用到 SOC5 / SOC6 / SOC7 和 SOC8 上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AdcaRegs.ADCSOC5CTL.bit.CHSEL = <span class="number">1</span>; <span class="comment">//SOC5 will convert ADCINA1</span></span><br><span class="line">AdcaRegs.ADCSOC5CTL.bit.ACQPS = <span class="number">9</span>; <span class="comment">//SOC5 will use sample duration of 10 SYSCLK cycles </span></span><br><span class="line">AdcaRegs.ADCSOC5CTL.bit.TRIGSEL = <span class="number">10</span>; <span class="comment">//SOC5 will begin conversion on ePWM3 SOCB</span></span><br><span class="line">AdcaRegs.ADCSOC6CTL.bit.CHSEL = <span class="number">1</span>; <span class="comment">//SOC6 will convert ADCINA1</span></span><br><span class="line">AdcaRegs.ADCSOC6CTL.bit.ACQPS = <span class="number">9</span>; <span class="comment">//SOC6 will use sample duration of 10 SYSCLK cycles </span></span><br><span class="line">AdcaRegs.ADCSOC6CTL.bit.TRIGSEL = <span class="number">10</span>; <span class="comment">//SOC6 will begin conversion on ePWM3 SOCB</span></span><br><span class="line">AdcaRegs.ADCSOC7CTL.bit.CHSEL = <span class="number">1</span>; <span class="comment">//SOC7 will convert ADCINA1</span></span><br><span class="line">AdcaRegs.ADCSOC7CTL.bit.ACQPS = <span class="number">9</span>; <span class="comment">//SOC7 will use sample duration of 10 SYSCLK cycles </span></span><br><span class="line">AdcaRegs.ADCSOC7CTL.bit.TRIGSEL = <span class="number">10</span>; <span class="comment">//SOC7 will begin conversion on ePWM3 SOCB</span></span><br><span class="line">AdcaRegs.ADCSOC8CTL.bit.CHSEL = <span class="number">1</span>; <span class="comment">//SOC8 will convert ADCINA1</span></span><br><span class="line">AdcaRegs.ADCSOC8CTL.bit.ACQPS = <span class="number">9</span>; <span class="comment">//SOC8 will use sample duration of 10 SYSCLK cycles </span></span><br><span class="line">AdcaRegs.ADCSOC8CTL.bit.TRIGSEL = <span class="number">10</span>; <span class="comment">//SOC8 will begin conversion on ePWM3 SOCB</span></span><br></pre></td></tr></table></figure>
<p>如上配置后，当ePWM3 到达其周期并生成一个SOCB信号，如果ADC此时处于空闲状态，ADC将会对通道 ADCINA1（SOC5） 立即进行采样；如果此时ADC繁忙，ADCINA1将会在SOC5获得权限后开始采样。一旦SOC5的转换完成，SOC5 的结果将会存放于 <code>ADCRESULT5</code> 寄存器，同时 SOC6 将会开始转换。该组转换（4个单次转换）将会依次完成（completed sequentially），转换结果也是依次存放于对应序号的寄存器中。</p>
<div style="color: red; font-weight: 900;">
采样转换结果存储的寄存器编号 与其 SOC编号一致，与SOC所选择的通道无关。
</div>
<p><strong>注意</strong>：ADC转换启动顺序可以设置为 SOC6 / SOC7 / SOC8 / SOC5，取决于接收ePWM触发时 round-robin 指针的位置，以上情况虽然可以实现，但没有必要这样搞。详见 13.5 部分。</p>
<h5 id="cpu定时器触发多重转换">CPU定时器触发多重转换</h5>
<p>基于不同的采样周期对多个信号进行采样。</p>
<p>CPU1 定时器2 被用以生成采样触发器（具体配置方法看《系统控制和中断（System Control and Interrupt）》章节的《CPU定时器（CPU Timer）》部分）</p>
<p>步骤如下：</p>
<ol type="1">
<li>当设置多重采样方法时，先列写出所有信号及其所需要的采样周期。</li>
<li>计算每个信号所需的系统时间 SYSCLK 周期 及其 ACQPS 寄存器值，如下表 13-5。</li>
<li>决策哪个ADC针脚连接到每个信号，取决于应用板的布局。一旦针脚选定，通道值就可以直接设定了，如下表13-6。</li>
</ol>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210807110435097.png" alt="image-20210807110435097" /><figcaption aria-hidden="true">image-20210807110435097</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210807110451836.png" alt="image-20210807110451836" /><figcaption aria-hidden="true">image-20210807110451836</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AdcaRegs.ADCSOC0CTL.bit.CHSEL = <span class="number">5</span>; <span class="comment">//SOC0 will convert ADCINA5</span></span><br><span class="line">AdcaRegs.ADCSOC0CTL.bit.ACQPS = <span class="number">23</span>; <span class="comment">//SOC0 will use sample duration of 24 SYSCLK cycles </span></span><br><span class="line">AdcaRegs.ADCSOC0CTL.bit.TRIGSEL = <span class="number">3</span>; <span class="comment">//SOC0 will begin conversion on CPU1 Timer 2</span></span><br><span class="line">AdcaRegs.ADCSOC1CTL.bit.CHSEL = <span class="number">0</span>; <span class="comment">//SOC1 will convert ADCINA0</span></span><br><span class="line">AdcaRegs.ADCSOC1CTL.bit.ACQPS = <span class="number">88</span>; <span class="comment">//SOC1 will use sample duration of 89 SYSCLK cycles </span></span><br><span class="line">AdcaRegs.ADCSOC1CTL.bit.TRIGSEL = <span class="number">3</span>; <span class="comment">//SOC1 will begin conversion on CPU1 Timer 2</span></span><br><span class="line">AdcaRegs.ADCSOC2CTL.bit.CHSEL = <span class="number">3</span>; <span class="comment">//SOC2 will convert ADCINA3</span></span><br><span class="line">AdcaRegs.ADCSOC2CTL.bit.ACQPS = <span class="number">21</span>; <span class="comment">//SOC2 will use sample duration of 22 SYSCLK cycles </span></span><br><span class="line">AdcaRegs.ADCSOC2CTL.bit.TRIGSEL = <span class="number">3</span>; <span class="comment">//SOC2 will begin conversion on CPU1 Timer 2</span></span><br><span class="line">AdcaRegs.ADCSOC3CTL.bit.CHSEL = <span class="number">2</span>; <span class="comment">//SOC3 will convert ADCINA2</span></span><br><span class="line">AdcaRegs.ADCSOC3CTL.bit.ACQPS = <span class="number">58</span>; <span class="comment">//SOC3 will use sample duration of 59 SYSCLK cycles </span></span><br><span class="line">AdcaRegs.ADCSOC3CTL.bit.TRIGSEL = <span class="number">3</span>; <span class="comment">//SOC3 will begin conversion on CPU1 Timer 2</span></span><br></pre></td></tr></table></figure>
<p>如上配置后，当CPU1 定时器2生成事件，SOC0 / SOC1 / SOC2 / SOC3 将会按顺序启动采样和转换。ADCIN5 的结果将会存放在 <code>ADCRESULT0</code> 中，其他采样结果也是依次存储。</p>
<div style="color: red; font-weight: 900;">
采样转换结果存储的寄存器编号 与其 SOC编号一致，与SOC所选择的通道无关。
</div>
<h5 id="软件触发转换">软件触发转换</h5>
<p>不论SOC是否配置具体的触发器，软件触发都可以让SOC实现转换。可以通过对 <code>ADCSOCFRC1</code> 寄存器写入来实现。</p>
<p>前述案例使用定时器2来触发转换，使用软件触发可以在不等待定时器的情况下实现立即采样和转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdcaRegs.ADCSOCFRC1.all = <span class="number">0x000F</span>; <span class="comment">//set SOC flags for SOC0 to SOC3</span></span><br></pre></td></tr></table></figure>
<h4 id="转换优先级">转换优先级</h4>
<p>当同一时间配置多重SOC标志时，多个SOC的优先级顺序有两种决定模式：<strong><em>Round-Robin 模式</em></strong> 和 <strong><em>High-Priority 模式</em></strong>。</p>
<p>默认优先级模式是 Round-Robin（后简称RR），这种模式下所有SOC优先级都一致。优先级由RR指针决定，RR指针 <code>RRPOINTER</code> 映射在 <code>ADCSOCPRIORITYCTL</code> 寄存器中，</p>
<blockquote>
<p>The <code>RRPOINTER</code> reflected in the <code>ADCSOCPRIORITYCTL</code> register points to the last SOC converted. ?????</p>
</blockquote>
<h3 id="eoc操作原则">EOC操作原则</h3>
<p>每一个SOC都有一个对应的EOC（End of Conversion）信号。EOC信号可以从来触发ADC中断。</p>
<p>ADC能够配置于在 <strong>捕获窗口期结束时</strong>（end of the acquisition window） 或 <strong>电压转换结束时</strong>（end of the voltage conversion） 生成EOC脉冲，使用 <code>ADCCTL1</code> 寄存器的 <code>INTPULSEPOS</code> 位来进行配置。</p>
<p>每个ADC模块都拥有4个可配置的ADC中断，这些中断能够被16个EOC的任意一个触发。每一个 <code>ADCINT</code> 的标志位都能够被直接读取，用以判断绑定的SOC是否完成或中断能否被传递至PIE。</p>
<p><strong>注意</strong>：<code>ADCCTL1.ADCBSY</code> 位被清除不代表一个SOC里的所有转换都完成了，只有ADC准备好处理下一次转换时才能说明上一次已经完成。为了确定一组SOC是否已经完成，将 <code>ADCINT</code> 标志连接到 队列中的上一个SOC里，并观察它。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210730105429591.png" alt="image-20210730105429591" style="zoom:67%;" /></p>
<h4 id="中断溢出">中断溢出</h4>
<p>如果EOC信号在 <code>ADCINTFLG</code> 寄存器中设置一个标志，但该位置上早已设置过标志了，就会出现中断溢出（interrupt overflow）。默认情况下，溢出中断不会被传递给PIE模块。当 <code>ADCINTFLG</code> 寄存器发生溢出时，对应的 <code>ADCINOVF</code> 寄存器就会被设置。<code>ADCINOVF</code> 寄存器上的标志位仅用于检测是否溢出，并不会阻止中断溢出到PIE模块。</p>
<p>当ADC中断溢出可能发生时，软件应该在ISR 或 后台循环 中检查 <code>ADCINOVF</code> 对应的标志位，并当检测到溢出时采取相应的措施。以下代码演示了如何在尝试清除 <code>ADCINT</code> 标志后，在ISR中检查 <code>ADCINOVF</code> 标志：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = <span class="number">1</span>; <span class="comment">//clear INT1 flag for ADC-A</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == AdcaRegs.ADCINTOVF.bit.ADCINT1)&#123; <span class="comment">//ADCINT overflow occurred</span></span><br><span class="line"> AdcaRegs.ADCINTOVFCLR.bit.ADCINT1 = <span class="number">1</span> <span class="comment">//Clear overflow flag </span></span><br><span class="line"> AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = <span class="number">1</span> <span class="comment">//Re-clear ADCINT flag</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="adc中断">ADC中断</h3>
<p>查询《TRM》第1496页可以看到有关ADC中断控制，主要有以下几个寄存器，涉及 <strong>中断标志设置</strong>、<strong>中断溢出设置</strong>、<strong>中断信号选择设置</strong>、<strong>中断SOC选择设置</strong> 和 <strong>SOC优先级控制</strong>。</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210809083644966.png" alt="image-20210809083644966" /><figcaption aria-hidden="true">image-20210809083644966</figcaption>
</figure>
<ul>
<li><code>ADCINTSELxNx</code> 是负责控制ADC中断输出的 <strong>模式</strong>（Mode）、<strong>使能</strong>（Enable） 和 <strong>触发源</strong>（Trigger Source）。
<ul>
<li><strong>模式</strong>：<u>手动清除<code>ADCINTFLG</code> 寄存器的 <code>ADCINTx</code> 位时生成ADC 中断脉冲</u> 或 <u>EOC脉冲生成时ADC中断脉冲</u></li>
<li><strong>使能</strong>：中断脉冲打开或关闭</li>
<li><strong>触发源</strong>：由 <code>EOCx</code> 触发 本中断</li>
</ul></li>
<li><code>ADCINTFLG</code> 是 <strong>只读</strong> 寄存器，每个ADC模块都有该寄存器，<code>0</code> 则代表 没有脉冲生成， <code>1</code> 则代表脉冲已生成</li>
<li><code>ADCINTFLGCLR</code> 是 <strong><em>只能写 <code>1</code></em></strong> 的寄存器，读取时会默认写0，在对应中断位写 <code>1</code> 时清除该中断 和 对应的中断结果标志</li>
<li><code>ADCINTOVF</code> 也是个 <strong>只读</strong> 的标志寄存器，检测是否有中断溢出。</li>
<li><code>ADCINTOVFCLR</code> 为中断溢出清除寄存器，同样也是 <strong><em>只能写 <code>1</code></em></strong> 的寄存器。</li>
<li><code>ADCINTSOCSELx</code> 为 ADC中断生成后是否会触发其他 SOC的设置寄存器，只有 第一中断（INT1）和第二中断（INT2）可以触发 SOC。</li>
<li><code>ADCSOCPRICTL</code> 为中断优先级寄存器，需要联系SOC的转换优先级和《TRM》P1513来查看。</li>
</ul>
<h3 id="配置样例">配置样例</h3>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210809100254146.png" alt="image-20210809100254146" /><figcaption aria-hidden="true">image-20210809100254146</figcaption>
</figure>
<h4 id="配置流程">配置流程</h4>
<p>在配置ADC时，需要思考好项目应用的具体场景和功能，设置哪个通道（Channel，如ADCA1）来检测信号，设置哪个模块的哪个SOC来绑定该通道（如ADCA的SOC1），SOC和EOC是一一对应的，接着需要设置EOC和哪个模块中断（<code>INTx</code>）进行绑定。</p>
<pre class="mermaid">graph TD
将通道中断/中断程序与中断向量表绑定 --> 设置参考电压VREF --> 配置Module --> 配置SOC --> 配置EOC/中断</pre>
<p>如果不涉及超采样、多重采样等模式，可以不考虑SOC的优先级配置。</p>
<h3 id="总结">总结</h3>
<p>外设ADC配置过程中，最容易将ADC模块（A/B/C）、SOC序号、EOC序号、通道序号 和 模块中断序号之间互相搞混，配置时需要先画草图理清思路再行配置。</p>
<p>启用多个ADC通道时，需要注意模拟外设的引脚有限，某些SOC、ADC模块会复用，画图工作量会大些。</p>
<figure>
<img src="I:\00.LEARNING\ADC模块理解_1.png" alt="ADC模块理解" /><figcaption aria-hidden="true">ADC模块理解</figcaption>
</figure>
<h1 id="控制外设">控制外设</h1>
<p>本系列芯片的控制外设包含 <strong>eCAP</strong>、<strong>HRCAP</strong>、<strong>ePWM</strong>、<strong>HRPWM</strong>、<strong>eQEP</strong> 和 <strong>SDFM</strong>。</p>
<p>根据《SPRU566N》表11 可知，ePWM 和 HRPWM 都是4型增强外设，具体功能可以参见《SPRUI33D》。</p>
<h2 id="epwm">ePWM</h2>
<p>ePWM是商业和工业控制电力系统的关键组成部分。这些系统包括 <u>数字电机控制</u>、<u>开关电源控制</u>、<u>不间断电源供应</u> 或 其他形式的电源转换。</p>
<p>ePWM这个大的外设模块（Module）组成，是由8个子模块（Submodule）构成的。所有的ePWM模块用数字尾缀来表示第几个ePWM模块，如 <code>ePWM1</code>、<code>ePWM3</code> 。每个ePWM模块又有两个输出，分别是 A 和 B，例如 <code>ePWM1A</code> 和 <code>ePWM1B</code> 。</p>
<p>ePWM模块通过一条时钟同步表（clock synchronization scheme）同步和串联在一起，形成可以统一操作的整体。此外，这个时钟同步表能够被扩展至 eCAP 外设使用。子模块的数量是由设备（设计）和实际使用需求决定的，每个子模块都能够支持单独操作。</p>
<p>ePWM 模块通过两个PWM输出（<code>EPWMxA</code> 和 <code>EPWMxB</code>）来组成一条完整的PWM通道。多路 ePWM被在一个设备内实现，几乎每一个ePWM通道实例都是相同的，只有一个例外。有些实例包括一个硬件扩展，可以更精确地控制PWM输出。这种扩展是高分辨率脉宽调制器（HRPWM），在第18.15节中有描述。每个ePWM模块都用一个以1开头的数值表示，例如，<code>ePWM1</code> 是系统中的第一个实例，<code>ePWM3</code> 是第三个实例，<code>ePWMx</code> 表示任何实例。</p>
<p>每一个ePWM模块都被连接至输入和输出信号。每一个ePWM模块都包含着8个子系统，并通过图18-2的方式连接至系统内部。</p>
<h3 id="图表">图表</h3>
<p><strong><em>表 5-57</em></strong> 展示了PWM的时间要求，主要是 同步（Sync）/非同步（Async）/带输入验证（With input qualifier）的 <strong><em>同步输入脉冲宽度</em></strong>（Sync Input Pulse Width）的三种时间</p>
<p><strong><em>表 5-58</em></strong> 展示了PWM的开关特性，包括最小脉冲周期，同步输出脉冲宽度 和 t<span style="font-size: 0.6rem;">d(TZ-PWM)</span></p>
<p><strong><em>表 5-59</em></strong></p>
<p><strong><em>表 18-21</em></strong> 展示了ePWM外设下的各寄存器（自《SPRUI33D》Page 1885）,<mark>约有81个寄存器</mark>。</p>
<p><strong><em>图 18-1</em></strong> 描述的是外围总线上的多个PWM模块，及输入信号和输出信号通路示例</p>
<p><strong><em>图 18-2</em></strong> 描述的是PWM模块下各子模块和信号连接方式（简图）</p>
<p><strong><em>图 5-58</em></strong> 描述的是ePWM内部的子模块和信号连接方式（结构图）</p>
<p><strong><em>图 5-59</em></strong></p>
<p><strong><em>图 5-60</em></strong> 为TB计数器同步链。</p>
<p><strong><em>图 5-61</em></strong> PWM高阻态时序特性</p>
<p><img src="https://pic.islet.space/2021/07/image-20210715140249937.png" alt="image-20210715140249937" style="zoom:80%;" /></p>
<p><img src="https://pic.islet.space/2021/07/image-20210715141719524.png" alt="image-20210715141719524" style="zoom:80%;" /></p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210712104641579.png" alt="image-20210712104641579" /><figcaption aria-hidden="true">image-20210712104641579</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210712104655718.png" alt="image-20210712104655718" /><figcaption aria-hidden="true">image-20210712104655718</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210712104857729.png" alt="image-20210712104857729" /><figcaption aria-hidden="true">image-20210712104857729</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210712104928659.png" alt="image-20210712104928659" /><figcaption aria-hidden="true">image-20210712104928659</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210723095251220.png" alt="image-20210723095251220" /><figcaption aria-hidden="true">image-20210723095251220</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210723095318306.png" alt="image-20210723095318306" /><figcaption aria-hidden="true">image-20210723095318306</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210723095334783.png" alt="image-20210723095334783" /><figcaption aria-hidden="true">image-20210723095334783</figcaption>
</figure>
<p>《TRM》P1841，简化过的ePWM模型：</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210802142302371.png" alt="image-20210802142302371" /><figcaption aria-hidden="true">image-20210802142302371</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210802142447715.png" alt="image-20210802142447715" /><figcaption aria-hidden="true">image-20210802142447715</figcaption>
</figure>
<h3 id="time-base-submodule">【#】Time-Base Submodule</h3>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210723083549303.png" alt="TB子模块的信号和寄存器" /><figcaption aria-hidden="true">TB子模块的信号和寄存器</figcaption>
</figure>
<p>PWM事件的周期被 <strong><em>TBPRD寄存器</em></strong> 和 <strong><em>TB计数器的模式</em></strong> 控制着。TB计数器的三种工作模式由 <strong><em>TB控制寄存器</em></strong> （<em>TBCTL</em>）控制，分别为 <strong>增计数</strong>（Up-Count）、<strong>减计数</strong>（Down-Count）和 <strong>增减计数</strong>（Up-Down-Count）。</p>
<p>影子周期寄存器（shadow period register）的内存地址（memory address）与活跃寄存器相同。<strong><em>TB控制寄存器</em></strong> （<em>TBCTL</em>）下的 <strong><em>PRDLD位</em></strong> 控制着要读写哪个寄存器，同时控制着是否使能影子寄存器，此时可分为 <strong><em>TB周期影子模式</em></strong>（Time-Base Period Shadow Mode） 或 <strong><em>TB周期即刻载入模式</em></strong>（Time-Base Period Immediate Load Mode）。</p>
<p>在TB计数器同步链中，<strong><em>EXTSYNC1</em></strong> 由 <strong><em>INPUTXBAR5</em></strong> 输入而得，<strong><em>EXTSYNC2</em></strong> 由 <strong><em>INPUTXBAR6</em></strong> 输入而得。而这些输入信号可以通过配置选择任意GPIO作为同步输入源。<mark>在使用 SYNCSEL 寄存器配置同步链传播路径时，应确保最长的路径不超过四个 ePWM/eCAP 模块。</mark></p>
<p>每个ePWM模块配置时都可以选择使用或者无视同步输入。如果 TBCTL[PHSEN] 位被设置了，且发生 <strong>同步输入脉冲</strong>（Synchronization Input Pulse）、 <strong>软件强制同步脉冲</strong>（Software Forced Synchronization Pulse） 或 <strong>数字比较事件同步脉冲</strong>（Digital Compare Event Synchronization Pulse） 三者之一的情况时，<strong>TB计数器</strong>（<strong>TBCTR</strong>）会自动加载 <strong>相位寄存器</strong>（<strong>TBPHS</strong>） 的内容。</p>
<h4 id="术语">术语</h4>
<p><em>Up-Down-Count Mode</em>: <strong>增减计数</strong>，TB计数器从0开始自增计数直到等于周期值（TBPRD值）。当与该值相等时，TB计数器会 <mark>逐步自减至0</mark>。接着周而复始，重新开始自增。</p>
<p><em>Up-Count Mode</em>: <strong>增计数</strong>，TB计数器从0开始自增计数直到等于周期值（TBPRD值）。当与该值相等时，TB计数器 <mark>直接归零</mark>，接着周而复始，重新开始自增。</p>
<p><em>Down-Count Mode</em>: <strong>减计数</strong>，TB计数器从周期值（TBPRD值）开始自减至0。当到达0值时，TB计数器直接重置TBPR值，接着周而复始，重新开始自减。</p>
<p><em>Active Register</em>: <strong>活跃寄存器</strong>，控制着硬件，并对硬件触发或调用（ causes or invokes）的事件进行响应。</p>
<p><em>Shadow Register</em>: <strong>影子寄存器</strong>，为活跃寄存器提供缓存，即临时存储空间（ temporary holding location）。不对任何控制硬件造成直接影响。 在关键时刻（at a strategic point in time ），影子寄存器的内容将会传递给活跃寄存器。可以避免因软件异步修改造成的崩溃或假操作（corruption or spurious operation）。</p>
<p><em>Time-Base Period Shadow Mode</em>: <strong>TB周期影子模式</strong>，当 <code>TBCTL[PRDLD]=0</code> 时，影子寄存器打开。对<strong><em>TBPRD</em></strong>内存地址的读写操作将会影响到影子寄存器。当TB计数器为零（<code>TBCTR=0x00</code>）时，影子寄存器的内容会被传输到活跃寄存器。<strong><em>TBCTL2</em></strong>[PRDLDSYNC] 位决定着同步时间。当且仅当 <strong><em>TBCTL</em></strong>[PRDLD] 值为0时，PRDLDSYNC位的值有效。默认情况下，影子寄存器开启。 通过配置 <strong>全局负载配置寄存器</strong>（<strong><em>GLDCFG</em></strong>）中对应的位，全局负载控制机制就能够和TB周期寄存器被一起使用。当全局复杂模式选通时，从影子寄存器到活跃寄存器的内容传输</p>
<p><em>Time-Base Period Immediate Load Mode</em>: <strong>TB周期即刻载入模式</strong>，当 <code>TBCTL[PRDLD]=1</code> 时，即刻载入模式开启。对TBPRD内存地址的读写操作将会直接载入到活跃寄存器。</p>
<p><em>Time-Base Clock Synchronization</em>: <strong>TB时钟同步</strong>，外设时钟使能寄存器（peripheral clock enable registers）里的 <strong><em>TBCLKSYNC</em></strong> 位 允许所有用户将所有已开启的ePWM模块同步至TB时钟（TBCLK）。开启时，所有已开启的模块时钟会与TBCLK的第一个上升沿对齐。为了完美地同步TBCLK，所有ePWM模块的预分频都要明确设置。</p>
<p><em>Time-Base Counter Synchronization</em>: <strong>TB计数同步</strong>，每个ePWM模块都有一个 <strong>同步输入</strong>（SYNCI）、一个 <strong>同步输出</strong>（SYNCO） 和 一个 <strong>外设同步输出</strong>（SYNCPER）。</p>
<p><em>Synchronization Input Pulse</em>: <strong>同步输入脉冲</strong>，当检测到输入同步脉冲时，相位寄存器的值被载入至计数器中。这个载入操作会在下一个有效的TB时钟（TBCLK）边沿发生。</p>
<p><em>Software Forced Synchronization Pulse</em>: <strong>软件强制同步脉冲</strong>，</p>
<p><em>Digital Compare Event Synchronization Pulse</em>: <strong>数字比较事件同步脉冲</strong>，</p>
<p>开启ePWM时钟的步骤如下：</p>
<ol type="1">
<li>在 PCLKCRx 寄存器里，使能ePWM模块时钟</li>
<li>设置 <code>TBCLKSYNC = 0</code></li>
<li>配置模块</li>
<li>设置 <code>TBCLKSYNC = 1</code></li>
</ol>
<blockquote>
<p>CTR，Counter的缩写。</p>
</blockquote>
<h4 id="图表-1">图表</h4>
<p><strong><em>图 18-6</em></strong> 展示了当TB计数器周期设置为4时，增计数、减计数 和 增减计数 三种模式下的PWM周期和频率的关系。时间自增的步长由从ePWM时钟分频而来的时基时钟（TBCLK）定义。</p>
<p><strong><em>表 18-2</em></strong> 是对关键TB信号的详细描述。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210723090439017.png" alt="image-20210723090439017"  /></p>
<div style="text-align: center;">
<img src="https://pic.islet.space/2021/07/image-20210723104144586.png" alt="image-20210723104144586" style="zoom:60%;" /><img src="https://pic.islet.space/2021/07/image-20210723104124781.png" alt="image-20210723104124781" style="zoom:66.6%;" />
</div>
<div style="text-align: center;">
<img src="https://pic.islet.space/2021/07/image-20210723104110747.png" alt="image-20210723104110747" style="zoom:63%;" /><img src="https://pic.islet.space/2021/07/image-20210723104533742.png" alt="image-20210723104533742" style="zoom:55%;" />
</div>
<p><img src="https://pic.islet.space/2021/07/image-20210723083704637.png" alt="image-20210723083704637" style="zoom:80%;" /></p>
<h3 id="counter-compare-submodule">【#】Counter Compare Submodule</h3>
<p>CC子模块， 以TB计数值为输入源。这个值被不断地拿来与CMPA/CMPB/CMPC/CMPD进行比较，当TB计数器的值与其中一个寄存器的值相等时CC子模块就会生成一个适当的事件。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210724100317179.png" alt="image-20210724100317179" /><figcaption aria-hidden="true">image-20210724100317179</figcaption>
</figure>
<p>CC子模块的作用：</p>
<ul>
<li>通过CMPA/CMPB/CMPC/CMPD寄存器，基于可编程时间戳生成时间
<ul>
<li>当 <code>CTR=CMPA</code> 时， TB计数器的值等于计数比较器A的值（TBCTR=CMPA）</li>
<li>当 <code>CTR=CMPB</code> 时， TB计数器的值等于计数比较器B的值（TBCTR=CMPB）</li>
<li>当 <code>CTR=CMPC</code> 时， TB计数器的值等于计数比较器C的值（TBCTR=CMPC）</li>
<li>当 <code>CTR=CMPD</code> 时， TB计数器的值等于计数比较器D的值（TBCTR=CMPD）</li>
</ul></li>
<li>如果用CMPA和CMPB对AQ子模块正确地配置，可以控制PWM的占空比</li>
<li>可以在PWM周期活跃时备份（shadows）新的比较值以防崩坏或错误</li>
</ul>
<p>CC子模块的内部信号通路结构示意如下图18-15。可以看出，CC子模块前一级是TB子模块，接收其时间信号。CC子模块不间断地对比 CMPx 和 TBCTR 的值，一旦符合要求，则输出结果给AQ子模块。所有CMPx的输出结果均会导向ET（事件触发器和中断），但是导向AQ子模块的只有 CMPA / CMPB。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210724102101254.png" alt="image-20210724102101254" /><figcaption aria-hidden="true">image-20210724102101254</figcaption>
</figure>
<h3 id="action-qualifier-submodule">【#】Action Qualifier Submodule</h3>
<p>AQ子模块在 <strong>波形结构</strong> 和 <strong>PWM生成</strong> 上扮演着重要的角色。它决定了哪个事件可以被转换为不同的动作类型（converted into various action types），进而产生 <strong><em>EPWMxA</em></strong> 和 <strong><em>EPWMxB</em></strong> 输出需要的开关波形（producing the required switched waveforms）。</p>
<p>AQ子模块控制着当特定事件发生时，ePWM外设的两条输出线（EPWMxA / EPWMxB）该如何进行输出。输入至AQ子模块的事件 会由 计数器方向（自增或自减）进一步限定。这允许在计数上升和计数下降阶段对输出进行独立操作。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210724082155433.png" alt="image-20210724082155433" /><figcaption aria-hidden="true">image-20210724082155433</figcaption>
</figure>
<p><strong>AQ子模块的作用</strong>：</p>
<ul>
<li>根据以下（特定）事件 <em>限定并生成</em>（qualifying and generating）动作（包括 <strong>设置</strong>、<strong>清除</strong> 和 <strong>标记</strong>）:
<ul>
<li>当 <code>CTR = PRD</code> ，TB计数器等于周期（TBCTR = TBPRD）</li>
<li>当 <code>CTR = ZERO</code> ，TB计数器等于0（TBCTR = 0x00）</li>
<li>当 <code>CTR = CMPA</code> ，TB计数器等于 计数比较器A （TBCTR = CMPA）</li>
<li>当 <code>CTR = CMPB</code> ，TB计数器等于 计数比较器B（TBCTR = CMPB）</li>
</ul></li>
<li>T1、T2事件：基于比较器（comparator）、跳闸（trip） 或 同步器（syncin）的触发事件</li>
<li>当这些事件同时发生时管理好它们的优先级</li>
<li>当TB计数器自增或自减时提供对事件的独立控制</li>
</ul>
<p>从下图18-21 或 表 18-3 中可以看出，AQ子模块的输入信号源除了TB时钟意外，剩下的触发事件有7种，分别是 PRD / ZERO / CMPA / CMPB / DIR / T1 / T2。只有前四种需要使用到TB计数器。软件强制动作（software forced action）是个非常有用的异步事件，由 <strong><em>AQSFRC</em></strong> 和 <strong><em>AQCSFRC</em></strong> 寄存器控制。</p>
<p><strong>注意</strong>：如果在影子模式下 <strong><em>CSFA</em></strong> 未被使用，必须配置 <strong><em>RLDCSF</em></strong> 位以关闭影子模式。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210724083434622.png" alt="image-20210724083434622" style="zoom: 80%;" /></p>
<p><img src="https://pic.islet.space/2021/07/image-20210724083824488.png" alt="image-20210724083824488" style="zoom:80%;" /></p>
<p>对输出（EPWMxA / EPWMxB）可能施加（imposed）的动作如下：</p>
<ul>
<li><strong>置高</strong>（Set High）：将输出置高。</li>
<li><strong>置低</strong>（Clear Low）：将输出置低。</li>
<li><strong>切换</strong>（Toggle）：如果任一输出（EPWMxA / EPWMxB）被同时置高，则将它们置低。如果任一输出被同时置低，则将它们置高。</li>
<li><strong>无视</strong>（Do Nothing）：让输出保持与当前相同的电平，不做处理。虽然“无视”选项阻止了事件对输出的可能动作，但是这些事件仍然可以去触发中断和ADC的开启。</li>
</ul>
<p>输出（EPWMxA / EPWMxB）的动作需要分别单独指定（specified independently）。在特定输出上，所有或任一事件都可以被配置以生成动作。</p>
<p>比如说，<code>CTR=CMPA</code> 和 <code>CTR=CMPB</code> 都可以被配置到 <strong><em>EPWMxA</em></strong> 上。所有限定动作都可以通过控制寄存器被配置。</p>
<p>每一个符号代表着一个动作，就像是时间上的标记。某些动作在时间上是固定的（如，0和周期），而CMPA和CMPB动作是非固定的（moveable）且其时间位置可以通过CMPA/B寄存器来编程。</p>
<p>使用 <strong>无视</strong> 操作可以关闭或无效某个动作，无视动作是复位后的默认值。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210724090622329.png" alt="image-20210724090622329" /><figcaption aria-hidden="true">image-20210724090622329</figcaption>
</figure>
<p>AQ触发事件源选择寄存器（AQTSRCSEL, Action Qualifier Trigger Event Source Selection register）被用于为T1/T2事件选择源。在AQ子模块中，一个trip/数字比较事件的T1/T2的选择和配置 与 Trip-zone子模块事件的配置 是相互独立的。特定的trip事件是不确定能否在TZ子模块里通过配置来触发trip动作的，但是相同事件是能够确定可以被配置于AQ子模块中，以生成T1/T2来控制PWM生成的。</p>
<p>PWM动作限定器（AQ）是可以在相同时间内接受一个以上事件的，此时，硬件会为事件排好优先级。优先级规则是，事件生成越晚，优先级越高，而且 <strong>软件强制事件</strong>（software forced event）拥有最高优先级。</p>
<p>增减计数模式下的动作限定事件优先级如下表18-4所示，优先级按数字从小到大依次递减，共分10级。</p>
<p><mark>优先级会因TB计数器的计数模式改变而改变。</mark> 但是从下表18-5和 18-6中可以看到，自增模式和自减模式下，只有7个优先级，在任一模式下，其相反动作的触发都不会被考虑，如在自减模式下，自增事件不会被考虑，自增模式下，自减事件不会被考虑。</p>
<p><strong>注意</strong>：CMPA或者CMPB是可以设置得比PRD还大的，此时需要考虑依据所处模式进行考虑，如表18-7所示。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210724092138218.png" alt="image-20210724092138218" /><figcaption aria-hidden="true">image-20210724092138218</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210724092919402.png" alt="image-20210724092919402" /><figcaption aria-hidden="true">image-20210724092919402</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210724092932350.png" alt="image-20210724092932350" /><figcaption aria-hidden="true">image-20210724092932350</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210724094334396.png" alt="image-20210724094334396" /><figcaption aria-hidden="true">image-20210724094334396</figcaption>
</figure>
<p>图18-25 展示了如何使用TBCTR的增减计数模式来生成一个symmetric PWM波形。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210724172530959.png" alt="image-20210724172530959" style="zoom:80%;" /></p>
<h3 id="dead-band-generator-submodule">【#】Dead-Band Generator Submodule</h3>
<p>下方为DB死区时间生成子系统的功能框图，主要是设置两个寄存器值 <code>DBFED</code> 和 <code>DBRED</code> ，需要注意的是，他们都是 14bit 的，传递数值的时候需要进行限定。</p>
<figure>
<img src="https://pic.islet.space/2021/10/20211008160842.png" alt="image-20211008160601600" /><figcaption aria-hidden="true">image-20211008160601600</figcaption>
</figure>
<h3 id="pwm-chopper-submodule">PWM Chopper Submodule</h3>
<p>暂略</p>
<h3 id="trip-zone-submodule">【#】Trip Zone Submodule</h3>
<p>TZ子模块，每个ePWM模块都连接了6个 TZ<em>n</em>（TZ1 ~ TZ6） 信号 ， 其中：</p>
<ul>
<li>前三个信号来自于GPIO 复用</li>
<li>TZ4 来自于 带有 EQEP 模块设备的 反转（inverted）的 <strong><em>EQEPxERR</em></strong> 信号</li>
<li>TZ5 连接至了系统时钟故障（fail）逻辑</li>
<li>TZ6 来自于 CPU 的 EMUSTOP 输出</li>
</ul>
<p>这些信号指示了外部的故障或跳闸情况，并且可以对ePWM的输出进行编程，以便在故障发生时作出相应的反应。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210724104412883.png" alt="image-20210724104412883" style="zoom:80%;" /></p>
<p>TZ子模块的特点：</p>
<ul>
<li>错误输入TZ1 ~ TZ6 能够被高级地（flexibly）路由至（mapped to）任何ePWM模块</li>
<li>在出现错误时，输出（EPWMxA / EPWMxB）状态可以被强制指定为其中之一：
<ul>
<li>置高</li>
<li>置低</li>
<li>高阻抗（High-impedance）</li>
<li>无动作（no action taken）</li>
</ul></li>
<li>为主要的 <strong>短路</strong> 或 <strong>过流</strong>（short circuits or over-current）提供 <strong>一次性错误</strong>（one-shot trip, OSHT）</li>
<li>为 <strong>限流操作</strong>（current limiting operation）提供 <strong>循环错误</strong>（cycle-by-cycle tripping）</li>
<li>基于 片上模拟比较模块输出 和/或 TZ1 至 TZ3 提供 <strong>数字比较错误</strong>（digital compare tripping）</li>
<li>每一个TZ输入和DC子模块 DCAEVT1/2 或 DCBEVT1/2 强制事件能够被定位于 一次性错误 或 循环错误上。</li>
<li>中断生成可用于任何一个TZ输入</li>
<li>软件强制错误也可用</li>
<li>如果不需要使用，TZ子模块也能够被完全屏蔽。</li>
</ul>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210824152702184.png" alt="image-20210824152702184" /><figcaption aria-hidden="true">image-20210824152702184</figcaption>
</figure>
<h3 id="event-trigger-submodule">Event Trigger Submodule</h3>
<p>如果需要使用ePWM的事件触发，则需要配置ET模块。</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210809171747297.png" alt="image-20210809171747297" /><figcaption aria-hidden="true">image-20210809171747297</figcaption>
</figure>
<p>例如，如果需要使用ePWM作为ADC_SOC的触发源，则需要使用以下配置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EPwm6Regs.ETSEL.bit.INTEN = ON;                <span class="comment">// 关闭EPWM外设的中断</span></span><br><span class="line">EPwm6Regs.ETSEL.bit.SOCAEN = ON;            <span class="comment">// 打开ePWM6dSOCA脉冲</span></span><br><span class="line">EPwm6Regs.ETSEL.bit.SOCASEL = <span class="number">0x02</span>;          <span class="comment">// TB计数器等予周期时触发事件</span></span><br><span class="line">EPwm6Regs.ETPS.bit.SOCAPRD = <span class="number">0x01</span>;          <span class="comment">// 在第一次事件时生成脉冲</span></span><br></pre></td></tr></table></figure>
<p>如果不需要，则使用以下配置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EPwm6Regs.ETSEL.bit.INTEN = OFF;                <span class="comment">// 关闭EPWM外设的中断</span></span><br></pre></td></tr></table></figure>
<h3 id="digital-compare-submodule">Digital Compare Submodule</h3>
<p>暂略</p>
<h2 id="ecap">eCAP</h2>
<p>本系列芯片使用的是第1类eCAP，特性如下所示：</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210818150848657.png" alt="image-20210818150848657" /><figcaption aria-hidden="true">image-20210818150848657</figcaption>
</figure>
<p>eCAP模块有如下特性：</p>
<ul>
<li>旋转机械的速度测量 （例如，通过霍尔传感器检测齿形链轮）</li>
<li>多个位置传感器脉冲的时间差测量</li>
<li>脉冲串（Pulse Train）信号的周期和占空比测量</li>
<li>将来自任务占空比解码的电流/电压传感器的电流/电压振幅进行解码</li>
</ul>
<p>后续会描述到的eCAP特性如：</p>
<ul>
<li>4个事件时间戳寄存器（每个32bit）</li>
<li>最多能够为四个顺序时间戳捕获事件的 <strong>边沿极性选择</strong>（edge polarity selection）</li>
<li>对四个时间的任何一个进行中断（interrupt on either of the four events）</li>
<li>单次捕获（Single-shot capture）最多可捕获4个事件的时间戳</li>
<li>在一个四层的环形缓冲器中连续捕获时间戳的模式</li>
<li>绝对时间戳捕获</li>
<li>差分（德尔塔）模式的时间戳捕获</li>
<li>当不启用捕获模式时，eCAP模块可以被配置为一个单通道的PWM输出</li>
</ul>
<p>第一类eCAP 较 第0类eCAP增加了以下特性：</p>
<ul>
<li>事件过滤器复位位（reset bit）</li>
<li>以计数器状态位为模</li>
<li>DMA触发源</li>
<li>输入多路器</li>
<li>EALLOW保护</li>
</ul>
<h3 id="配置引脚">配置引脚</h3>
<p>为了将设备输入引脚连接至模块，输入X-BAR必须要用上。设备上的任何GPIO都能够配置为输入。通过设置 <code>GPxQSELn</code> 寄存器位可以将GPIO输入验证（input qualification）设置为同步模式或异步模式。</p>
<p>使用同步输入能够有效提高抗噪性，但是让eCAP丢失±2个周期的精度。在 <code>GPyPUD</code> 寄存器中能够配置内部拉高。一旦GPIO模式开启，<code>GPyINV</code> 寄存器就能够倒置信号了（invert the signals）。</p>
<p>必须配置128:1的输入多路器也是一类eCAP模块的新特性。从下表19-1可以看出，该多路器能够配置不同的输入细节。</p>
<p>下图为《TRM》P966图9-1，可以看到eCAP的输入可以被配置为 <strong><em>INPUT[16:1]</em></strong> 或 <strong><em>Other Sources</em></strong> 。而 <strong><em>INPUT[16:1]</em></strong> 则是INPUTXBAR的16个可配置通道，</p>
<div style="text-align: center;">
<img src="https://pic.islet.space/2021/08/image-20210824090004384.png" alt="image-20210824090004384" style="zoom:100%;" /> <img src="https://pic.islet.space/2021/08/image-20210824090259786.png" alt="image-20210824090259786" style="zoom: 50%;" />
</div>
<p><img src="https://pic.islet.space/2021/08/image-20210818171451027.png" alt="image-20210818171451027" style="zoom:67%;" /></p>
<p><img src="https://pic.islet.space/2021/08/image-20210818171518769.png" alt="image-20210818171518769" style="zoom:67%;" /></p>
<p>输出X-BAR能够用于连接输出信号至 OUTPUTXBARx 输出定位（output location）。</p>
<p>从下表4-8可以看出，INPUT XBAR所有16个输入都可以被配置至其目的地为eCAP。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210712095346292.png" alt="image-20210712095346292" /><figcaption aria-hidden="true">image-20210712095346292</figcaption>
</figure>
<p>在配置引脚时有以下步骤：</p>
<ol type="1">
<li>将输入XBAR与对应的GPIO连接，连接时通过 <code>InputXbarRegs.INPUT10SELECT</code> 进行配置。</li>
<li>将eCAPx与对应的XBAR输入序号连接，连接时通过 <code>ECCTL0.INPUTSEL</code> 寄存器为进行配置。</li>
</ol>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210824093524933.png" alt="image-20210824093524933" /><figcaption aria-hidden="true">image-20210824093524933</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputXbarRegs.INPUT10SELECT = <span class="number">0xA</span>; <span class="comment">// 将GPIO10(0xA)与输入XBAR 10进行连接</span></span><br><span class="line">ECap1Regs.ECCTL0.bit.INPUTSEL = <span class="number">0xA</span>;    <span class="comment">//为eCAP1选择输入源为XBAR的INPUT10，参见《TRM》P2048</span></span><br></pre></td></tr></table></figure>
<h3 id="capture模式">Capture模式</h3>
<p>下图19-3展示了实现捕获功能的不同元件（various components）</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210819200405541.png" alt="image-20210819200405541" /><figcaption aria-hidden="true">image-20210819200405541</figcaption>
</figure>
<h4 id="事件分频器">事件分频器</h4>
<p>输入捕获信号（脉冲串）能够被N预分频（N的取值范围为[2,62]，所有可取值均为2的倍数），也可以绕过该预分频，在输入信号频率非常高时有用。</p>
<p>下图19-4 展示了事件预分频器的功能框图。</p>
<p>下图19-5 展示了分频功能的操作。</p>
<p>通过设置 <code>ECCTL2.CTRFILTRSET</code> 寄存器位即可让 事件分频器（Event Prescalar）复位。</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210819202019366.png" alt="image-20210819202019366" /><figcaption aria-hidden="true">image-20210819202019366</figcaption>
</figure>
<p><img src="https://pic.islet.space/2021/08/image-20210819202037557.png" alt="image-20210819202037557" style="zoom:80%;" /></p>
<h4 id="边沿极性选择和限定器">边沿极性选择和限定器</h4>
<p>功能和特性如下：</p>
<ul>
<li>四个独立边沿极性（上升沿/下降沿）选择复用（selection muxes are used），每一个边沿极性都可以对应一个捕捉事件（one for each capture event）。</li>
<li>每个边沿（最多4个）都是由 Modulo 4 序列器进行事件鉴定。（Each edge (up to 4) is event qualified by the Modulo4 sequencer.）</li>
<li>边沿事件通过Mod4计数器导向其各自对应的 <code>CAPx</code> 寄存器。<code>CAPx</code> 寄存器在下降沿时载入（loaded on the falling edge）。</li>
</ul>
<h4 id="连续一次性控制">连续/一次性控制</h4>
<p>在连续/一次性控制模式（Continuous / One-shot mode）下的eCAP操作：</p>
<ul>
<li>Mod4（2位）计数器通过边沿限定事件（edge qualified events）（CEVT1 ~ CEVT4）进行增加</li>
<li>Mod4计数器持续计数（0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 0）且往复循环永不停歇，除非被停下（wraps around unless stopped）</li>
<li>在一次操作模式过程中，会使用到一个2位停止寄存器（STOP_WRAP）来与Mod4计数输出进行比较，当数值相等时，停止Mod4计数器并阻止更多数据载入 <code>CAP1</code> ~ <code>CAP4</code> 寄存器。在本模式下，如果 TSCCTR 计数器通过配置 <code>ECCTL1.CTRRSTx</code> 位来 用于在捕获事件（<strong><em>CEVTx</em></strong>）上的复位，它将会在 <code>STOP_WRAP</code> 值满（reached）且 <strong>重新装载</strong>（re-arm，REARM）尚未发生时 在捕获事件是上对 TSCCTR 计数器一直复位（keep resetting the TSCCTR counter on capture event）。</li>
</ul>
<p>连续/一次性块 通过软件控制的能够触发 <strong>单次操作</strong>（mono-shot type of action）的 <strong>停值比较器</strong>（stop-value comparator）和 <strong>重新装载</strong>（re-armed） 控制着Mod4计数器的启动、停止和复位。</p>
<p>一旦装载，eCAP模块会 在冻结Mod4计数器和 <code>CAP1</code> ~ <code>CAP4</code> 寄存器（时间戳）之前 等待 1 ~ 4 个（由 <strong>停值</strong> 决定）捕获事件。</p>
<p>重新装载（re-arming）会将eCAP模块作为另一个捕获顺序的准备，同时清除（至0）Mod4计数器 并 允许再次装载（permits loading again） <code>CAP1</code> ~ <code>CAP4</code> 寄存器，前提是 <code>CAPLDEN</code> 位已经设置了。</p>
<p>在连续模式下，Mod4计数器连续运行（0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 0），一次性操作将会被忽略且捕获到的值会被以循环缓存顺序（circular buffer sequence）持续写入至<code>CAP1</code> ~ <code>CAP4</code> 寄存器。</p>
<p><img src="https://pic.islet.space/2021/08/image-20210819205730800.png" alt="image-20210819205730800" style="zoom:80%;" /></p>
<h4 id="位计数器和相位控制">32位计数器和相位控制</h4>
<p>本32位计数器为时间捕获提供TB，并通过系统时钟锁定（is locked via the system clock）。</p>
<p>相位寄存器的作用是通过硬件和软件强制同步（forced sync），完成与其他计数器的同步。在APWM模式下，当模块间需要相位偏移时比较有用。</p>
<p>对四个任一事件的装载而言，都有一个选项可以重置32bit计数器，对时差捕获有用。先是32位计数器值被捕获，接着被LD1 ~ LD4的任一信号复位为 <code>0</code>。</p>
<p><img src="https://pic.islet.space/2021/08/image-20210820093838065.png" alt="image-20210820093838065" style="zoom:80%;" /></p>
<h4 id="cap1-cap4寄存器">CAP1-CAP4寄存器</h4>
<p><code>CAP1</code>~<code>CAP4</code> 为32位的寄存器，由32位计数定时器总线和 <code>CTR[0-31]</code> 驱动（fed by the 32-bit counter timer bus, CTR[0-31]），并在对应的LD输入被触发（strobed）时被加载以捕获其时间戳。</p>
<p><code>CAPLDEN</code> 控制位能够抑制捕获寄存器的加载。在一次性捕获操作器件，当停止情况发生时（停值 = Mod4），该位会被自动清空（禁止载入）。</p>
<p>在APWM模式下，<code>CAP1</code> <code>CAP2</code> 寄存器对应地称为（活跃的）<strong>周期</strong> 和 <strong>比较</strong> 寄存器（the active period and compare register）,<code>CAP3</code> <code>CAP4</code> 成为了对应活跃寄存器的影子寄存器。</p>
<h4 id="ecap同步">eCAP同步</h4>
<p>eCAP模块能够通过选择相同的同步源（a common source） <code>SYNCIN</code> 来与其他模块同步。eCAP的同步源可以是软件同步源或者外部同步源，外部同步源信号能够来自 ePWM、eCAP或者X-BAR。</p>
<p>图19-7所示，eCAP模块的 <code>SWSYNC</code> 与 <code>SYNC</code> 信号进行逻辑 或（OR）。</p>
<p>图19-8所示，<code>SYNC</code> 信号是由 <code>SYNCSELECT[ECAPxSYNCIN]</code> 的选择来定义的。</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210822115215346.png" alt="image-20210822115215346" /><figcaption aria-hidden="true">image-20210822115215346</figcaption>
</figure>
<h5 id="使用软件同步-swsync">使用软件同步 SWSYNC</h5>
<p>按一下步骤进行操作可以实现对 ECAP1 和 ECAP3 的软件同步：</p>
<ol type="1">
<li>配置 <code>ECAP[1..3].ECCTL2.SYNCO_SEL = 0x0</code> ，以使能 同步输入（sync-in）事件成为同步输出（sync-out）信号的通道。</li>
<li>配置 <code>ECAP[2..3].ECCTL2.SWSYNC = 0x0</code>，以关断 ECAP2 和 ECAP3 的软件同步。</li>
<li>从 ePWM1配置默认的同步信号来源，如果 <code>TBCTL[SYNCOSEL]</code> 信号没有被正确配置，则可能对时间戳寄存器 <code>TSCTR</code> 造成意料之外的结果。在 <code>InputXbarRegs</code> 中选择一个没有使用过的GPIO并配置为输出模式，并往GPIO <code>DAT</code> 寄存器中写入 <code>0</code> 。默认情况下会配置为 GPIO0，但该针脚上的任何活动都会对 <code>SWSYNC</code> 造成影响。</li>
<li>配置 <code>SYNCSEL[ECAP1SYNCIN] = 0x5</code> ，将 <code>ECAPx.EXTSYNCIN</code> 外部同步输入关断。</li>
<li>配置 <code>ECAP1.ECCTL2.SWSYNC=0x1</code> ，强制开启 时间戳计数器 （<code>TSCTR</code> counter）的软件同步。</li>
</ol>
<p>为了将 <code>SWSYNC</code> 应用至其他 eCAP模块，需要确保前面的eCAP链条没有生成可能干扰软件同步的 <code>SYNCOUT</code> 信号。</p>
<h4 id="中断控制">中断控制</h4>
<p>eCAP中断控制的操作和特征如下：</p>
<ul>
<li>捕获事件（CEVT1 ~ CEVT4, CTROVF）或者APWM事件（<code>CTR = PRD</code>, <code>CTR=CMP</code>）都能够生成中断。</li>
<li>计数器溢出事件（<code>FFFFFFFF -&gt; 00000000</code>）也提供了中断源（CTROVF）。</li>
<li>这些捕获事件由对应的极性选择和Mod4门控的边缘和序列器进行限定（在时间上排序）。The capture events are edge and sequencer-qualified (ordered in time) by the polarity select and Mod4 gating, respectively.</li>
<li>这些事件任一能够被选择为中断源（从eCAPx 模块）以导向PIE和CLA。</li>
<li>七个中断事件（CEVT1 / CEVT2 / CEVT3 / CEVT4 / CNTOVF / CTR=PRD / CTR=CMP）都能够被生成。中断使能寄存器 <code>ECEINT</code> 被用于使能/禁止独立中断事件源。中断标志寄存器 <code>ECFLG</code> 鉴定是否有任何中断事件被锁定 并 维持着全局中断标志位 <code>INT</code> 。只有在任何中断事件被使能，其标志位为 <code>1</code> 且 <code>INT</code> 标志位为 <code>0</code> 时，中断脉冲会被生成并送至 PIE。中断服务程序必须清楚全局中断标志位 并 在任何其他中断脉冲生成前通过中断清除寄存器 <code>ECCLR</code> 服务事件。往 <code>ECCTL2[CLRFILTRESET]</code> 位 写 <code>1</code> 来对事件滤波器进行复位时，所有中断标志都会被清除。可以通过中断强制寄存器 <code>ECFRC</code> 来强制中断事件，对测试目的非常有效。</li>
</ul>
<p><strong>注意</strong>：CEVT1 / CEVT2 / CEVT3 / CEVT4 标志仅在捕获模式下可用（<code>ECCTL2[CAP/APWM==0]</code>）。CTR=PRD / CTR=CMP 标志仅在APWM模式下可用<code>ECCTL2[CAP/APWM==1]</code>。CNTOVF在两个模式下都可用。</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210822121542134.png" alt="image-20210822121542134" /><figcaption aria-hidden="true">image-20210822121542134</figcaption>
</figure>
<h4 id="dma中断">DMA中断</h4>
<p>在0类eCAP模块下，CPU被要求使用DAM来启动数据传输。</p>
<p>在1类eCAP模块下，分立式（separate）DMA触发器（<code>ECAP_DMA_INT</code>）通过使用DMA，控制着从eCAP寄存器 到 片上内存（on-chip memory）的捕获数据的不间断传输。</p>
<p>通过对 <code>ECCTL2[DMAEVTSEL]</code> 进行操控，可实现四个任一可用中断事件（CEVT1 / CEVT2 / CEVT3 / CEVT4 ）都可以被当做 <code>ECAP_DMA_INT</code> 的触发源。</p>
<h4 id="影子载入和锁定控制lockout-control">影子载入和锁定控制（lockout control）</h4>
<p>在捕获模式下，该逻辑禁止（锁定）任何从<code>APRD</code> 和 <code>ACMP</code> 到 <code>CAP1</code> 和 <code>CAP2</code> 的影子载入。</p>
<p>在APWM模式下，影子载入被激活，且有以下两个选择可用：</p>
<ul>
<li>立即——在写入新值时，<code>APRD</code> 或 <code>ACMP</code> 将会立即传输至 <code>CAP1</code> 或 <code>CAP2</code>。</li>
<li>在周期相等时（on period equal），<code>CTR[31:0] = PRD[31:0]</code></li>
</ul>
<h3 id="apwm操作模式">APWM操作模式</h3>
<p><strong><em>APWM</em></strong>，即 Asymmetrical Pulse Width Modulation，非对称脉冲宽度调制。</p>
<p>当eCAP模块没有被用来输入和捕捉信号时，可以改成单通道PWM生成器（32位分辨率）。计数器将工作在 <strong>增模式</strong> 下，为非对称脉冲宽度调制（APWM）提供TB（Time-base）。其中 <code>CAP1</code> 和 <code>CAP2</code> 寄存器 将被当做对应PWM中存放 <strong>周期</strong>（period） 和 <strong>比较</strong>（compare） 的寄存器，对应的 <code>CAP3</code> 和 <code>CAP4</code> 寄存器 将被当做 周期和比较的影子寄存器。</p>
<p>下图19-1捕获和辅助脉冲宽度调制器模式操作的高级视图</p>
<p><img src="https://pic.islet.space/2021/08/image-20210819195912993.png" alt="image-20210819195912993" style="zoom:67%;" /></p>
<p><img src="https://pic.islet.space/2021/08/image-20210819200302044.png" alt="image-20210819200302044" style="zoom:80%;" /></p>
<h3 id="ecap模块应用">eCAP模块应用</h3>
<p>eCAP模块的应用通过边沿可以分为两类：<strong>上升沿</strong>（rising edge） 和 <strong>上升下降沿</strong>（rising and falling edge）。通过操作方式也可以分为两类：<strong>时间戳</strong>（time stamp） 和 <strong>时间差</strong>（time difference）。</p>
<p>边沿和操作方式可以互相组合成共4中应用：<strong>时间戳上升沿操作</strong>、<strong>时间戳上升下降沿操作</strong>、<strong>时间差上升沿操作</strong> 和 <strong>时间差上升下降沿操作</strong>。</p>
<h4 id="时间戳上升沿操作">时间戳上升沿操作</h4>
<p>下图19-12中，为连续捕获操作（Mod4计数器周期翻转（wraps around））的例子</p>
<p>图表中， TSCTR 计数器在没有复位的情况下持续上升计数，捕获事件仅被限定在上升沿（注意观察图中所有CAPx旁边都有一个上升沿的标志，即所有CAPx都被设置为在MOD4的上升沿时才能出发CAPx PIN的输出）。从图中也可以看出周期和频率信息。</p>
<p><img src="https://pic.islet.space/2021/08/image-20210822144050400.png" alt="image-20210822144050400" style="zoom:67%;" /></p>
<p>在一个事件中，TSCTR内容（时间戳）被首先捕获，然后Mod4计数器进入下一阶段。当 TSCTR到达最大值 <code>FFFFFFFF</code> 时，翻转回 <code>00000000</code>，此时 计数器溢出标志 <code>CTROVF</code> 为 <code>1</code> ，中断（使能时）会生成。</p>
<p>被捕获的时间戳在图中所示的时间点上是有效的（在第4个事件之后），因此事件CEVT4可以方便地用来触发一个中断，CPU可以从 CAPx 寄存器中读取数据。</p>
<h4 id="时间戳上升下降沿操作">时间戳上升下降沿操作</h4>
<p>在19-13图中，eCAP操作模式几乎与 <strong>时间戳上升沿操作</strong> 一致，除了捕获事件限定在了上升下降沿。给出相同的周期和任务占空比信息：</p>
<ul>
<li><p>周期1 = t3 - t1，周期2 = t5 - t3 ......</p></li>
<li><p>任务占空比（高电平占比）1 = (t2-t1)/周期1 * 100% ，......</p></li>
<li><p>任务占空比（低电平占比）1 = (t3-t2)/周期1 * 100% ，......</p></li>
</ul>
<p><img src="https://pic.islet.space/2021/08/image-20210822144108477.png" alt="image-20210822144108477" style="zoom:67%;" /></p>
<h4 id="时间差上升沿操作">时间差上升沿操作</h4>
<p><img src="https://pic.islet.space/2021/08/image-20210822144128846.png" alt="image-20210822144128846" style="zoom:67%;" /></p>
<h4 id="时间差上升下降沿操作">时间差上升下降沿操作</h4>
<p><img src="https://pic.islet.space/2021/08/image-20210822144142670.png" alt="image-20210822144142670" style="zoom:67%;" /></p>
<h3 id="apwm模式应用">APWM模式应用</h3>
<p>通过APWMx 输出引脚生成简易单通道PWM波形。</p>
<p>The PWM polarity is active high, which means that the compare value (CAP2 reg is now a compare register) represents the on-time (high level) of the period. Alternatively, if the APWMPOL bit is configured for active low, then the compare value represents the off time.</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210822143359948.png" alt="image-20210822143359948" /><figcaption aria-hidden="true">image-20210822143359948</figcaption>
</figure>
<h3 id="寄存器-2">寄存器</h3>
<p>《TRM》P2041</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210819194706453.png" alt="image-20210819194706453" /><figcaption aria-hidden="true">image-20210819194706453</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210819195110220.png" alt="image-20210819195110220" /><figcaption aria-hidden="true">image-20210819195110220</figcaption>
</figure>
<h3 id="ecap配置流程">eCAP配置流程</h3>
<p>以下流程总结自C2000WareV3.4的driverlib样例代码：</p>
<ol type="1">
<li>禁用/复位所有捕获标志和中断</li>
<li>禁用CAP1~CAP4寄存器载入</li>
<li>配置eCAP
<ul>
<li>使能捕获模式</li>
<li>一次捕获模式，在事件4停止捕获</li>
<li>设置事件极性为上升沿/下降沿/上升沿/下降沿</li>
<li>设置为不同时间模式下的捕获（time difference mode）</li>
<li>从XBAR7选择输入</li>
<li>使能eCAP模块</li>
<li>使能中断</li>
</ul></li>
</ol>
<h3 id="ecap中断程序流程">eCAP中断程序流程</h3>
<ol type="1">
<li>获取捕获计数（捕获速度应为ePWM计数的2倍）</li>
<li>将获取到的捕获计数与周期值进行比较</li>
<li>追踪ePWM的方向，并相应地调整周期，以产生一个可变频率的PWM。</li>
<li>为正确的捕获进行计数</li>
<li>为更多中断清除中断标志</li>
<li>使能eCAP</li>
<li>为更多中断确认组中断</li>
</ol>
<h2 id="hrcap">HRCAP</h2>
<h3 id="hrcap时钟">HRCAP时钟</h3>
<p>与之前的0类HRCAP模块不同，1类eCAP具有HRCAP的功能但不要求二次PLL。然而本HRCAP模块仍然要求 SYSCLK 和 HRCLK 异步时钟源（Asynchronous clock source）。HRCLK对温度和电压的变化较为敏感。因此，当使用时间转换测量（time-converted measurements）时，要求定期进行持续性的校准（periodic continuous calibrations）。</p>
<h3 id="hrcap初始化顺序">HRCAP初始化顺序</h3>
<ol type="1">
<li>按需配置eCAP模块，包括中断</li>
<li>使用 <code>HRCAP_enableCalibrationInterrupt()</code> 使能中断</li>
<li>使用 <code>HRCAP_setCalibrationMode()</code> 使能校准</li>
<li>使用 <code>HRCAP_setCalibrationPeriod()</code> 配置周期性校准</li>
<li>使用 <code>HRCAP_enableHighResolution()</code> 使能HR模式</li>
<li>使用 <code>HRCAP_enableHighResolutioniClock()</code> 使能 HRCLK</li>
<li>延迟 1us</li>
<li>使用 <code>HRCAP_startCalibration()</code> 启动校准</li>
</ol>
<p>步骤 2、3、4 和 8 仅应用在时间转换的测量。当使用HRCAP来进行相关事件测量时仅需 1、5、6 和 7 即可。</p>
<h3 id="hrcap中断">HRCAP中断</h3>
<p>除了HRCALINT之外，HRCAP的增强功能还利用了现有的eCAP中断，该中断是由硬件校准块专门使用的。HRCALINT能够被以下情况触发：</p>
<ol type="1">
<li><code>SYSCLKCTR = HRCALIBPERIOD</code></li>
<li><code>SYSCLKCTR</code> / <code>HRCLKCTR</code> 处于溢出态（experience an overflow condition）</li>
</ol>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210823142406296.png" alt="image-20210823142406296" /><figcaption aria-hidden="true">image-20210823142406296</figcaption>
</figure>
<h1 id="通信外设">通信外设</h1>
<h2 id="spi">SPI</h2>
<p>本系列芯片的SPI具有如下特性：</p>
<ul>
<li>支持主模式或从模式</li>
<li>支持125种可编程速率，最高波特率（baud rate）由IO缓存的最大速度决定。</li>
<li>支持1~16比特数据传输</li>
<li>支持4种时钟模式</li>
<li>支持全双工通信（同时接受和发送），传输模式可以在软件中关闭</li>
<li>传输或接收操作通过 <strong>中断驱动</strong>（interrupt-driven）算法 或 <strong>轮询</strong>（polled）算法来完成</li>
<li>16级接收和传输FIFO</li>
<li>支持直接内存访问（DMA）</li>
<li>支持高速模式</li>
<li>延迟传输控制</li>
<li>支持3线模式</li>
<li>在有两个SPI模块的设备上实现数字音频接口接收模式的SPISTE反转（SPISTE inversion for digital audio interface receive mode on devices with two SPI modules）</li>
</ul>
<p><img src="https://pic.islet.space/2021/08/image-20210819084943717.png" alt="image-20210819084943717" style="zoom:67%;" /></p>
<p>下表为SPI模块的信号总结，其中有关中断信号和DMA触发的信号可能需要注意。</p>
<p><img src="https://pic.islet.space/2021/08/image-20210819090520768.png" alt="image-20210819090520768" style="zoom:67%;" /></p>
<h3 id="系统集成部分">系统集成部分</h3>
<h4 id="特别注意事项">特别注意事项</h4>
<p>在SPI处于从模式时，<strong>使能</strong>/<strong>片选</strong> 信号 <strong><em>SPISTE</em></strong> 为提供了阻挡假时钟信号和数据脉冲的作用。拉高使能信号时将不会允许从设备接收数据，同时也阻止了从设备从主设备那儿断开同步。这也是TI不推荐将使能信号一直绑定到拉高（active state）状态的原因。</p>
<p>如果从设备确实已经跟主设备断开同步，切换（toggling）寄存器 <code>SPISWRESET</code> 会像复位模块里的不同状态标志（various status flags）一样，将内部的 <strong>位计数器</strong>（internal bit counter）进行复位。将该位计数器复位后，SPI会将下一个时钟信号当做一个新传输的开始。</p>
<h4 id="引脚配置">引脚配置</h4>
<p>GPIO多路寄存器必须将外设和对应的针脚连接起来，为了避免连接时的电压尖峰出现，必须首先配置 <code>GPyGMUX</code> 位（当保持对应位为0时），向其写入对应的值。</p>
<p>某些IO口的功能由GPIO寄存器独立定义。对于输入信号，通过将对应的 <code>GPxQSELn</code> 寄存器位设置为 <code>11b</code> 可以将GPIO输入验证（input qualification）设置为异步模式。内部拉高可以在 <code>GPyPUD</code> 寄存器中进行设置。</p>
<h3 id="主从模式">主/从模式</h3>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210819113506076.png" alt="image-20210819113506076" /><figcaption aria-hidden="true">image-20210819113506076</figcaption>
</figure>
<h4 id="主模式">主模式</h4>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210819113451472.png" alt="image-20210819113451472" /><figcaption aria-hidden="true">image-20210819113451472</figcaption>
</figure>
<h4 id="从模式">从模式</h4>
<h3 id="数据格式">数据格式</h3>
<p>The four-bit SPICHAR register field specifies the number of bits in the data character (1 to 16). This information directs the state control logic to count the number of bits received or transmitted to determine when a complete character has been processed.</p>
<p>The following statements apply to characters with fewer than 16 bits:</p>
<ul>
<li><p>Data must be left-justified when written to SPIDAT and SPITXBUF.</p></li>
<li><p>Data read back from SPIRXBUF is right-justified.</p></li>
<li><p>SPIRXBUF contains the most recently received character, right-justified, plus any bits that remain from</p></li>
</ul>
<p>previous transmission(s) that have been shifted to the left (shown in Example 22-1).</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210819114723402.png" alt="image-20210819114723402" /><figcaption aria-hidden="true">image-20210819114723402</figcaption>
</figure>
<h3 id="波特率">波特率</h3>
<p>SPI支持125种不同的波特率和4种不同的时钟模式，取决于SPI的工作模式（主/从），SPICLK引脚是向外提供工作时钟还是接受外部时钟。</p>
<ul>
<li>从模式下，从SPICLK引脚接收外部时钟作为SPI时钟。</li>
<li>主模式下，SPI生成外部从设备所需时钟，由SPICLK引脚引出。</li>
</ul>
<p>以上所有模式下，SPICLK 的速率不能够大于 <code>LSPCLK</code> 的频率除以4。即</p>
<div style="text-align: center; font-size: 1.35rem; font-weight: 900; font-style: italic;">
F <span style="font-size: 0.7rem;">(SPICLK)</span> &lt; F <span style="font-size: 0.7rem;">(LSPCLK)</span> / 4
</div>
<p><strong>注意</strong>：所配置的波特率不应超过GPIO的最大切换频率（the maximum rated GPIO toggle frequency）。</p>
<h4 id="波特率公式">波特率公式</h4>
<p>在 SPIBRR 的可设置范围为<code>3</code> ~ <code>127</code> 时，其计算公式如下：</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210819151042265.png" alt="image-20210819151042265" /><figcaption aria-hidden="true">image-20210819151042265</figcaption>
</figure>
<p>在 SPIBRR 的可设置范围为 <code>0</code> 、<code>1</code> 或 <code>2</code> 时，其计算公式如下：</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210819151424040.png" alt="image-20210819151424040" /><figcaption aria-hidden="true">image-20210819151424040</figcaption>
</figure>
<p>其中：</p>
<ul>
<li>LSPCLK 为低速外设时钟频率</li>
<li>SPIBRR 为 SPI主机SPIBRR的内容</li>
</ul>
<p>为了确定SPIBRR应该载入何值，必须确定设备系统时钟（LSPCLK）频率 和 目标SPI时钟。</p>
<h4 id="波特率计算案例">波特率计算案例</h4>
<p>在标准SPI模式下（<strong>HS_MODE</strong> = 0）SPI模块的波特率计算，首先需要知道LSPCLK的控制寄存器，查找下图可知，对应LSPCLK由 LOSPCP 寄存器控制，该寄存器的信息在《TRM》P173 及 P185 可查询，如下表 3-40 和 表 3-51。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210710155206953.png" alt="image-20210710155206953" style="zoom: 70%;" /></p>
<p><img src="https://pic.islet.space/2021/08/image-20210819152113556.png" alt="image-20210819152113556" style="zoom: 67%;" /></p>
<p><img src="https://pic.islet.space/2021/08/image-20210819152141919.png" alt="image-20210819152141919" style="zoom:67%;" /></p>
<p><strong>如</strong>：</p>
<p>在 <code>SYSCLK = 100MHz</code> 时，设置 LOSPCP 寄存器下的 <code>LSPCLKDIV</code> 设置为 <code>001b</code> 或 <code>0x01</code> ，则对应的 LSPCLK = SYSCLK / LSPCLKDIV = 100MHz / 2 = 50MHz，此时，据前面SPI计算公式可知，SPI的波特率最高可为 <strong>LSPCLK</strong> / (<strong>SPIBRR</strong> +1) = 50000000 / (3+1) = 12500000Hz = <code>12.5MHz</code>。</p>
<p>在 <code>LSPCLKDIV</code> 为 <code>000b</code> 或 <code>0x00</code> 时，SPI的最高波特率为 <code>25MHz</code>。</p>
<h3 id="时钟时序">时钟/时序</h3>
<p>时钟极性选择位 <code>CLKPROLARITY</code> 和 时钟相位选择位 <code>CLK_PHASE</code> 控制 SPICLK 引脚上的 4个不同时钟模式，其中极性选择控制时钟的上升沿或者下降沿，相位延迟控制是否延迟半个时钟周期。</p>
<ul>
<li><strong>下降沿无相位延迟</strong>：在时钟 <strong>下降沿</strong> 传输数据，在时钟 <strong>上升沿</strong> 接收数据。</li>
<li><strong>下降沿有相位延迟</strong>：在时钟 <strong>下降沿</strong> 半个周期上传输数据，在时钟 <strong>下降沿</strong> 接收数据。</li>
<li><strong>上升沿无相位延迟</strong>：在时钟 <strong>上升沿</strong> 传输数据，在时钟 <strong>下降沿</strong> 接收数据。</li>
<li><strong>上升沿有相位延迟</strong>：在时钟 <strong>上升沿</strong> 半个周期上传输数据，在时钟 <strong>上升沿</strong> 接收数据。</li>
</ul>
<p><img src="https://pic.islet.space/2021/08/image-20210819084200284.png" alt="image-20210819084200284" style="zoom:67%;" /></p>
<p><img src="https://pic.islet.space/2021/08/image-20210819115248790.png" alt="image-20210819115248790" style="zoom: 80%;" /></p>
<p>只有当 <code>SPIBRR +1</code> 的值为偶数时， <code>SPICLK</code> 才能保持器对称性。当 <code>SPIBRR +1</code> 为奇数 且 <code>SPIBRR</code> 大于 <code>3</code>，<code>SPICLK</code> 则为非对称性。</p>
<p>当 <code>CLKPOLARITY</code> 为 <code>0</code> 时，<code>SPICLK</code> 的 <strong>低电平</strong>（low pulse） 会比 <strong>高电平</strong>（high pulse）长一个 <code>LSPCLK</code> 的宽度。</p>
<p>当 <code>CLKPOLARITY</code> 为 <code>1</code> 时，<code>SPICLK</code> 的 <strong>高电平</strong>（high pulse） 会比 <strong>低电平</strong>（low pulse）长一个 <code>LSPCLK</code> 的宽度。</p>
<p><img src="https://pic.islet.space/2021/08/image-20210819133534654.png" alt="image-20210819133534654" style="zoom: 80%;" /></p>
<h3 id="中断-1">中断</h3>
<p>SPI模块包含两条中断线： <code>SPIINT</code> / <code>SPIRXINT</code> 或 <code>SPITXINT</code>。</p>
<p>当工作在非FIFO模式时，所有可用中断都被路由到一起，并生成中断信号 <code>SPIINT</code> 。</p>
<p>当工作在FIFO模式下时，<code>SPIRXINT</code> 和 <code>SPITXINT</code> 都能够被生成。</p>
<h4 id="spiint-spirxint">SPIINT / SPIRXINT</h4>
<p>SPIINT会在非FIFO模式下出现。当FIFO增强开启时，会产生 SPIRXINT 中断，这两种中断会在PIE中共享同一个中断向量。</p>
<p>在非FIFO模式下，以下两种情况能够触发同一个中断，使用的同一个中断向量为 <code>SPIINT</code> 。</p>
<ul>
<li>传输完成（<code>INT_FLAG</code>）</li>
<li>接收超限（overrun in receiver）（<code>OVERRUN_FLAG</code>）</li>
</ul>
<p>传输完成标志 <code>INT_FLAG</code> 说明SPI已经完成发送或接收最后一个比特，并且准备好继续服务下一次传输了。在该标志为1时，说明接收到的数据已经被放在接收缓存 <code>SPIRXBUF</code> 中。如果 <code>SPIINTENA</code> 位设置过了，此时该标志位还会在中断向量表 的 <code>SPIINT</code> 上生成中断。</p>
<p>接收超限标志 <code>OVERRUN_FLAG</code> 说明在当前字符数据被从缓冲区读取出来之前，传输或者接收操作已经完成。如果<code>OVERRUNINTENA</code> 位为 <code>1</code> 且 <code>OVERRUN_FLAG</code> 已经被清除了，则该标志会在 <code>SPIINT</code> 向量上生成一个中断。</p>
<p>在FIFO模式下，SPI能够在 <strong>当前接收FIFO状态</strong>（RXFFST）和 <strong>接收FIFO中断水平</strong>（RXFFIL）之间的某个条件下中断CPU。如果 <code>RXFFST ≥ RXFFIL</code>，则 <strong>接收FIFO中断标志</strong> <code>RXFFINT</code> 将置 <code>1</code> ，如果<code>RXFFINT</code> 被置 <code>1</code> 且 <strong>接收FIFO中断</strong> （receive FIFO interrupt）被使能（<code>RXFFIENA</code> 为 <code>1</code>），则 <code>SPIRXINT</code> 将会被触发。</p>
<h4 id="spitxint">SPITXINT</h4>
<p>在非FIFO模式下，SPITXINT中断不可用。在FIFO模式下，SPITXINT 和 SPIRXINT 相近。</p>
<p>在FIFO模式下，SPI能够在 当前传输FIFO状态（TXFFST） 和 传输FIFO中断水平（TXFFIL）之间的某个条件下中断CPU。如果 <code>TXFFST ≤ TXFFIL</code> ，则 发送FIFO中断标志 <code>TXFFINT</code> 将置 <code>1</code>，如果 <code>TXFFINT</code> 被置 <code>1</code> 且 传输FIFO中断 被使能（<code>TXFFIENA</code> 为 <code>1</code>），则 <code>SPITXINT</code> 将会被触发。</p>
<p>下图 22-2 展示了上述这些控制位如何影响SPI的中断生成：</p>
<p><img src="https://pic.islet.space/2021/08/image-20210819110332529.png" alt="image-20210819110332529" style="zoom: 80%;" /></p>
<p><img src="https://pic.islet.space/2021/08/image-20210819110454056.png" alt="image-20210819110454056" style="zoom: 80%;" /></p>
<h3 id="dma支持">DMA支持</h3>
<p>CPU和DMA都可以通过内部外设总线来访问SPI数据的寄存器，最高可以读/写16bit的寄存器。每个SPI模块能够生成两个DMA事件 <code>SPITXDMA</code> 和 <code>SPIRXDMA</code> 。通过配置对应的 <code>SPIFFTX.TXFFIL</code> 和 <code>SPIFFRX.RXFFIL</code> 可以控制 DMA事件。当 <code>TXFFST ＜ TXFFIL</code> 时，<code>SPITXDMA</code> 激活。当 <code>RXFFST ≥ RXFFIL</code> 时，<code>SPIRXDMA</code> 激活。</p>
<p>必须先开启FIFO增强，才能让DMA触发生成。（The SPI must have FIFO enhancements enabled in order for the DMA triggers to be generated.）</p>
<p><img src="https://pic.islet.space/2021/08/image-20210819112140163.png" alt="image-20210819112140163" style="zoom:80%;" /></p>
<h3 id="高速模式">高速模式</h3>
<p>SPI的高速模式为所有GPIO多路器选项可用。为了开启 <strong>高速增强</strong>（High-Speed Enhancements），需要设置 <code>SPICCR.HS_MODE</code> 为 <code>1</code>。仍需确保针脚上的容性负载（capacitive loading ）不会超过（exceed）数据手册上的规定值（the value stated）。</p>
<p>当关闭高速模式，或当针脚上的容性负载超过规定值时，<code>SPICCR.HS_MODE</code> 需要被设置为 <code>0</code> 。</p>
<p>根据前面波特率计算案例可知，SPI最高能在 <code>LSPCLK == SYSCLK</code> 时达到其全双工通信最高速率 <code>25MHz</code> 。</p>
<h3 id="三线模式">三线模式</h3>
<p>三线模式在设备为主机或从机模式下时均可设置，都需要设置 <code>TRIWIRE</code> 位，此时SPI的全时双工将变为半时双工模式，以下为主/从机模式下使用三线半双工模式时引脚的功能转变情况：</p>
<p><strong>主机模式</strong>：<strong><em>SPISIMOx</em></strong> 则变成了 双向半双工（bi-directional, half-duplex） 的 <strong><em>SPIMOMIx</em></strong> 引脚，<strong><em>SPISOMIx</em></strong>则不再使用。</p>
<p><strong>从机模式</strong>： <strong><em>SPISOMIx</em></strong> 变成了 双向半双工（bi-directional, half-duplex） 的 <strong><em>SPISISOx</em></strong> 引脚，对应的 <strong><em>SPISIMOx</em></strong> 则不再使用。</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210819153841825.png" alt="image-20210819153841825" /><figcaption aria-hidden="true">image-20210819153841825</figcaption>
</figure>
<p>由于需要在同一根信号线上完成读取和写入操作，<code>TALK</code> 位起了决定作用。该数据位写入时将数据传送出去，擦除时则读取数据。</p>
<blockquote>
<p>In master mode, in order to initiate a read, the application software must write dummy data to the SPI data register (SPIDAT or SPIRXBUF) while the TALK bit is cleared (no data is transmitted out the SPIMOMI pin) before reading from the data register.</p>
</blockquote>
<p>在主机模式下，为了初始化读取操作，软件必须配置为 在 <strong><em>TALK</em></strong> 位 被清除的情况下 向SPI数据寄存器（<code>SPIDAT</code> 或者 <code>SPIRXBUF</code> ）写入假数据（实际上没有数据被传送到SPIMOMI引脚），然后再从数据寄存器中读取。</p>
<div style="text-align: center;">
<img src="https://pic.islet.space/2021/08/image-20210819154636295.png" alt="image-20210819154636295" style="zoom:67%;" /> <img src="https://pic.islet.space/2021/08/image-20210819154652213.png" alt="image-20210819154652213" style="zoom:67%;" />
</div>
<h3 id="程序配置">程序配置</h3>
<p>暂略</p>
<h2 id="sci">SCI</h2>
<p>SCI外设负责UART协议的编码部分，可以使用CH340芯片的串口助手进行读写测试。</p>
<p>SCI外设支持 <strong>单线模式</strong>（Idle-line Mode）或 <strong>网络模式</strong>（Address-bit Mode）。</p>
<blockquote>
<p>此处 Idle-line Mode 由本人意译为 UART/RS中仅有两个CPU通信的 <strong>单线模式</strong>，Address-bit Mode 由本人意译为 UART/RS中有多个CPU通信的 <strong>网络模式</strong>。</p>
</blockquote>
<h3 id="外设架构">外设架构</h3>
<p><img src="https://pic.islet.space/2021/09/image-20210910111251456.png" alt="image-20210910111251456" style="zoom:67%;" /></p>
<h3 id="通信数据格式">通信数据格式</h3>
<p>不管是单线模式还是网络模式，都有统一的通信数据格式。</p>
<p>SCI数据，包括接收和传输，都是 <strong>NRZ</strong> （non-return-to-zero）格式，该格式具有以下特点：</p>
<ol type="1">
<li>1个起始位，必不可少。</li>
<li>1~8个数据长度位，但一般传输都使用8bit，即一个字符大小，某些串口助手甚至不让发送低于5个bit的数据。</li>
<li>1个奇偶校验位（可选），即可选NONE / ODD / EVEN。</li>
<li>1个/2个停止位，必不可少。</li>
<li>1个额外的位来区分地址和数据（仅在地址位模式下），即不设置地址位模式则可以不用改数据位。</li>
</ol>
<p>数据的基础格式被称为字符（8 bits）或1~8个数据位的长度。每个字符型数据有 <strong>1个起始位</strong>、<strong>1~2个结束位</strong>、<strong>可选的校验位</strong> 和 <strong>地址位</strong>。字符型数据的格式称为 <strong>帧</strong>（frame），如下图23-3所示。</p>
<figure>
<img src="https://pic.islet.space/2021/09/image-20210910152755579.png" alt="image-20210910152755579" /><figcaption aria-hidden="true">image-20210910152755579</figcaption>
</figure>
<p>使用 <code>SCICCR</code> 寄存器即可编辑数据格式，编辑数据格式的寄存器位如下所示：</p>
<figure>
<img src="https://pic.islet.space/2021/09/image-20210913095605940.png" alt="image-20210913095605940" /><figcaption aria-hidden="true">image-20210913095605940</figcaption>
</figure>
<h3 id="引脚配置-1">引脚配置</h3>
<p>GPIO复用寄存器必须配置为从外设连接至设备引脚。为了避免引脚上的电流尖峰，<code>GPyGMUX</code> 寄存器位必须先配置（当对应的<code>GPyMUX</code> 寄存器位默认保持为 <code>0</code> 时），然后在对应 <code>GPyMUX</code> 位上载入数值。</p>
<p>某些IO口的功能由外设的GPIO寄存器独立设定。对于输入信号，GPIO输入限定器应该通过设置对应的 <code>GPxQSELn</code> 寄存器位为 <code>11b</code> 来设置为异步模式。内部拉高可以通过 <code>GPyPUD</code> 寄存器来设定。</p>
<figure>
<img src="https://pic.islet.space/2021/09/image-20210913094310841.png" alt="image-20210913094310841" /><figcaption aria-hidden="true">image-20210913094310841</figcaption>
</figure>
<h3 id="通信格式">通信格式</h3>
<p>SCI或者UART即使再不一样，都跟I2C一样，一次传送一个 <code>unsigned char</code> 字符。</p>
<p>SCI异步通信格式使用单线（单向）或者双线（双向）通信。在该模式下，帧内存在一个开始位，1~8位数据，一个可选的奇偶校验位 和 1~2个停止位，如下图23-7所示。</p>
<p>线路一直都是置高状态，每次都在收到开始位（拉低）时开始进行数据接收操作。一个有效的起始位由4个0bit的连续的 <code>SCICLK</code> 周期组成，一旦该低电平无法保持4个 <code>SCICLK</code> 周期，则将重头开始等待新的起始位。</p>
<p>为了能够成功采集到开始位之后的数据，处理器会对数据进行三次采样。这些采样发生在第四、第五和第六个SCICLK周期，比特值的确定是以 <strong>多数</strong>（Majority Vote）（三个中的两个）为基础，即如果该数据不能保持平稳（例如发送方波特率过高 或 噪声干扰等），可能会导致数据采样不稳。</p>
<figure>
<img src="https://pic.islet.space/2021/09/20210915203421.png" alt="image-20210915203147266" /><figcaption aria-hidden="true">image-20210915203147266</figcaption>
</figure>
<h3 id="多核工作模式">多核工作模式</h3>
<p>多核通信格式允许单个处理器在同一条串行链路（on the same serial link）上高效传输一组数据（blocks of data）给其他处理器。在单条 <strong>串行线</strong>（serial line）上，任一时刻只能有一种传输，换句话说就是任一时刻只有一个发送者和一个接受者，即 <strong>分时双工</strong> / <strong>半双工</strong>。</p>
<h4 id="地址字">地址字</h4>
<p>发送者（talker）发送的第一组数据（the first byte of a block of information）包含一个给所有接收者的地址字（address byte）。只有地址一致的接收者才会接收该地址后面传输的数据（can be interrupted by the data bytes that follow the address byte）。其他地址不一致的接收者在下一次收到地址一致的数据前都会保持原来的工作，不会被中断。</p>
<blockquote>
<p>注意，是地址字，不是地址位。</p>
</blockquote>
<h4 id="睡眠位">睡眠位</h4>
<p>在多个连接上的所有处理器都应该设置 SCI 睡眠位（<code>SCICTL1</code> 的第2位）为 <code>1</code> ，只有在检测到对应的地址位时才会被中断睡眠。当处理器读取到通过软件设置的对应CPU设备地址的地址块（a block address）时，程序必须清除睡眠位以使能SCI生成中断来接收数据位。</p>
<p>虽然睡眠位为 <code>1</code> 时，接收端仍然独立操作，但是不会设置 <code>RXRDY</code> 、<code>RXINT</code> 或其他接收错误状态位 为 <code>1</code>，除非地址位被检测到且接收到的帧的地址位为 <code>1</code>（地址位模式下可用）。</p>
<p><strong>注意</strong>：<mark>SCI外设不会自动切换 <code>SLEEP</code> 位的数据，必须手动切换。</mark>（The SCI does not alter the SLEEP bit; your software must alter the SLEEP bit.）</p>
<h4 id="地址字节确定">地址字节确定</h4>
<p>每个处理器确定地址字节都不同，取决于多个模式的选择。</p>
<ul>
<li>在IL模式下</li>
<li>在AB模式下</li>
</ul>
<h4 id="idle-line-多核模式">Idle-Line 多核模式</h4>
<p>在IL多核协议中（<code>ADDR</code> / <code>IDLE</code> 模式位为 <code>0</code>）</p>
<p>多个独立的帧块之间会有 <mark style="font-weight: 900;">10bit以上的空闲周期</mark>。</p>
<p>一次地址多帧数据</p>
<figure>
<img src="https://pic.islet.space/2021/09/image-20210913095703284.png" alt="image-20210913095703284" /><figcaption aria-hidden="true">image-20210913095703284</figcaption>
</figure>
<h4 id="地址位多核模式">地址位多核模式</h4>
<ul>
<li>多个帧块之间的空闲周期没有明显特征</li>
<li>地址帧上存在地址位。</li>
</ul>
<figure>
<img src="https://pic.islet.space/2021/09/image-20210913100054258.png" alt="image-20210913100054258" /><figcaption aria-hidden="true">image-20210913100054258</figcaption>
</figure>
<h3 id="sci中断">SCI中断</h3>
<p>SCI 的接受端和发送端都可以被中断控制。</p>
<ul>
<li><strong><em>SCICTL2</em></strong> 寄存器拥有 <strong>标志位</strong> 和 <strong>控制位</strong>，
<ul>
<li>控制位：使能接收缓存断点中断，<strong>RXBKINTENA</strong> 和 <strong>TXINTENA</strong></li>
<li>标志位：鉴定活跃中断情况 <strong><em>TXRDY</em></strong> ，该寄存器跟数据发送准备相关。</li>
</ul></li>
<li><strong><em>SCIRXST</em></strong> 寄存器仅拥有 <strong>标志位</strong>，且都是与接收状态有关的，其中2个可以生成中断。
<ul>
<li>拥有两个中断标志位 <strong><em>RXRDY</em></strong> 和 <strong><em>BRKDT</em></strong> ，加上一个能够对 <strong>FE</strong>、<strong>OE</strong>、<strong>BRKDT</strong> 和 <strong>PE</strong> 情况进行逻辑或并记录的 <strong>RX ERROR</strong> 中断标志。发送端和接收端都拥有独立的中断使能位，当中断未使能时，中断活动不会被启用（the interrupts are not asserted），但是情况标志仍然活跃（the condition flags remain active），时刻反映着传输和接收状况。</li>
</ul></li>
</ul>
<p>SCI的接收端和发送端都拥有独立外设中断向量。外设中断请求可以设置为高优先级或低优先级，通过从外设输出到PIE控制器上的优先级位进行鉴定。当RX和TX优先级一致时，接收端优先，以减少 <strong>接收端过载</strong>（receiver overrun）的可能性。</p>
<p>外设中断的操作在 《系统控制和中断》章节下的《外设中断》部分已经说明。</p>
<ul>
<li>如果RX/BK INT ENA 位（SCICTL2，位1）已经设置，当以下任意事件发生时，接收端外设中断请求活动会被启用：
<ul>
<li>SCI接收到完整的帧（complete frame）并将 <strong>RXSHF</strong> 寄存器中数据转移到 <strong>SCIRXBUF</strong> 寄存器。以上动作就会设置 RXRDY 标志（SCIRXST寄存器第6bit）并初始化生成一个中断。</li>
<li>断点检测情况（break detect condition）发生（SCIRXD 在丢失了结束位之后，置低了9.625个bit 周期），该动作会设置BRKDT标志位（SCIRXST寄存器第5bit）并初始化生成一个中断。</li>
</ul></li>
<li>如果TX INT ENA 位（SCICTL2 的第0位）被设置了，每当 <strong>SCITXBUF</strong> 中的数据被传输至 <strong>TXSHF</strong> 寄存器时，发送端外设中断请求会被断言（asserted)，表明CPU能够写入 <strong>SCITXBUF</strong> 了。该动作会设置 <strong>TXRDY</strong> 标志位（SCICTL2的第7位）并初始化一个中断。</li>
</ul>
<h3 id="波特率计算">波特率计算</h3>
<p>内部生成的串行时钟由 <strong>低速设备时钟</strong> <strong><em>LSPCLK</em></strong> 和 <strong>波特选择寄存器</strong>（baud-select registers）共同决定。SCI使用16 bit 的 波特选择寄存器在给定的 <strong>LSPCLK</strong> 值上 以选择一个可用的 <strong>64K差分串行时钟速率</strong>（one of the 64K different serial clock rates）。</p>
<p>查看寄存器信息和SCI异步波特率计算公式。下表展示了 <strong>通用SCI比特率</strong>（common SCI bit rates）的波特率选择值。<code>LSPCLK/16</code> 是最大的波特率，例如，<code>LSPCLK=100MHz</code> 时，波特率最大为 <code>6.25Mbps</code> 。</p>
<figure>
<img src="https://pic.islet.space/2021/09/image-20210913171945217.png" alt="image-20210913171945217" /><figcaption aria-hidden="true">image-20210913171945217</figcaption>
</figure>
<p>BRR等于高位寄存器 <code>SCIHBAUD</code> 左移8位和低位寄存器 <code>SCILBAUD</code> 的合成值。 <span class="math display">\[
BRR = (SCIHBAUD&lt;&lt;8)+(SCILBAUD) \tag{BRR计算公式}
\]</span> 异步波特率的计算公式为： <span class="math display">\[
F_{Asynchronous} = \frac{LSPCLK}{(BRR+1)·8} \tag{异步波特率计算公式}
\]</span> 同步波特率的计算公式为： <span class="math display">\[
F_{Synchronous}=\frac{LSPCLK}{16} \tag{同步波特率计算公式}
\]</span></p>
<p>下表23-3是 LSPCLK =100MHz时， <strong>常见的BRR配置值</strong> 和 <strong>误差情况</strong>。</p>
<figure>
<img src="https://pic.islet.space/2021/09/image-20210910161523738.png" alt="image-20210910161523738" /><figcaption aria-hidden="true">image-20210910161523738</figcaption>
</figure>
<h3 id="寄存器-3">寄存器</h3>
<figure>
<img src="https://pic.islet.space/2021/09/image-20210910111834789.png" alt="image-20210910111834789" /><figcaption aria-hidden="true">image-20210910111834789</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/09/image-20210910111903444.png" alt="image-20210910111903444" /><figcaption aria-hidden="true">image-20210910111903444</figcaption>
</figure>
<p>​</p>
<h2 id="i2c">I2C</h2>
<p>暂略，在ADI的21479开发笔记中有类似，可以参考。</p>
<h1 id="新建项目step-by-step">新建项目（Step by step)</h1>
<h2 id="新建c28xx项目">新建C28xx项目</h2>
<ol type="1">
<li>选择新建 CCS 项目</li>
</ol>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210719094604082.png" alt="image-20210719094604082" /><figcaption aria-hidden="true">image-20210719094604082</figcaption>
</figure>
<ol start="2" type="1">
<li>可暂时不选择具体芯片，选择 F28xx 系列即可，也可以选择 <code>28004x Piccolo</code>，在选择具体芯片。</li>
</ol>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210719094942412.png" alt="image-20210719094942412" /><figcaption aria-hidden="true">image-20210719094942412</figcaption>
</figure>
<ol start="3" type="1">
<li>设置项目名称并保存。</li>
</ol>
<p><img src="https://pic.islet.space/2021/07/image-20210719094813670.png" alt="image-20210719094813670" style="zoom: 80%;" /></p>
<h2 id="设置处理器选项">设置处理器选项</h2>
<p>C2000系列编译器中，关于处理器选项，需要设置 <code>CLA</code>、 <code>FPU</code>、 <code>TMU</code>、 <code>IDIV</code> 和 <code>VCU</code> 这几个参数，其中《spru566n》全文关于 <code>IDIV</code> 的描述仅有 F28002x 和 2838x 支持，此处就默认 28004x 不支持（暂时先留空），其余支持项均可以在《spru566n》表11中查找到。</p>
<ul>
<li><code>IDIV</code> 是指 <strong><em>增强型整数除法</em></strong> ，enhanced integer division，也是快速整数除法，fast integer division。</li>
<li><code>FPU</code> 有 FPU32 / FPU64 / SOFTLIB 三种选项，其中如果设置了 <code>TMU</code> 和 <code>VCU</code>，则默认设置为 FPU32。</li>
</ul>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210719091534852.png" alt="image-20210719091534852" /><figcaption aria-hidden="true">image-20210719091534852</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210719090718448.png" alt="image-20210719090718448" /><figcaption aria-hidden="true">image-20210719090718448</figcaption>
</figure>
<p>各选项设置如下：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210719094501999.png" alt="image-20210719094501999" style="zoom:67%;" /></p>
<h2 id="设置头文件选项">设置头文件选项</h2>
<p>向头文件包含设置中，添加几条 c2000Ware 套件安装包提供的支持库信息：</p>
<p><code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\driverlib\f28004x\driverlib</code></p>
<p><code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\device_support\f28004x\common\include</code></p>
<p><code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\device_support\f28004x\headers\include</code></p>
<p><strong>注意</strong>：以上路径信息仅供参考，具体路径仍需依据套件安装地址来修改。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210719095520123.png" alt="image-20210719095520123" style="zoom:80%;" /></p>
<p><img src="https://pic.islet.space/2021/07/image-20210719095713314.png" alt="image-20210719095713314" style="zoom:80%;" /></p>
<p>最后一共有4条信息：</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210719095934052.png" alt="image-20210719095934052" /><figcaption aria-hidden="true">image-20210719095934052</figcaption>
</figure>
<h2 id="设置文件搜索路径">设置文件搜索路径</h2>
<p>先在 <span style="font-style: italic; color: #aaa; font-weight: 900;">Add &lt;dir&gt; to library search path (--search_path, -i)</span> 中添加可以处理链接器的（.cmd）文件路径 <code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\device_support\f28004x\common\cmd</code>，然后将 <span style="font-style: italic; color: #aaa; font-weight: 900;">Include library file or command files as input (--input, -I)</span> 中的 <code>libc.a</code> 删除，添加具体的链接器全名 <code>28004x_generic_ram_lnk.cmd</code> 和 <code>rts2800_fpu32.lib</code> 。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210719100817504.png" alt="image-20210719100817504" style="zoom:80%;" /></p>
<h2 id="设置代码启动点">设置代码启动点</h2>
<p>此步骤为 <strong><em>可选</em></strong> 步骤，在 <span style="font-style: italic; color: #aaa; font-weight: 900;">Advance Options</span> 下的 <span style="font-style: italic; color: #aaa; font-weight: 900;">Symbol Management</span> 中设置 <em>程序入口点</em> <code>code_start</code> 。</p>
<p><strong>注意</strong>：本步骤是用于设置编译参数的，可以在完全新建项目的时候不操作本步骤，此时进行编译 <code>Build Project</code> 的话也是可以编译成功的。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210719101229117.png" alt="image-20210719101229117" style="zoom:80%;" /></p>
<blockquote>
<p><em>code_start</em> is the first code that is executed after exiting the boot ROM code for the example f28004x projects. The projects are setup such that the codegen entry point is also set to the code start label using linker options. The code start code will automatically re-direct the execution to <code>_c_init00</code>.</p>
</blockquote>
<h2 id="设置字体集">设置字体集</h2>
<p>此步骤为 <strong><em>可选</em></strong> 步骤，在 <span style="font-style: italic; color: #aaa; font-weight: 900;">Resource</span> 下可以设置 <em>字体编码</em> 和 <em>回行</em> 格式。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210719101527907.png" alt="image-20210719101527907" style="zoom:80%;" /></p>
<h2 id="添加文件">添加文件</h2>
<p>添加文件有两种形式，一种是以链接形式添加，编译时不会修改到源文件。另一种是直接添加至项目中（复制副本 或 新建文件）。</p>
<ol type="1">
<li>先用官方提供的文件进行预试添加和调试。在项目上右击选择 <code>Add Files</code> ，以 <strong><em>链接形式</em></strong> 添加文件：</li>
</ol>
<ul>
<li><code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\driverlib\f28004x\driverlib\ccs\Debug\driverlib.lib</code></li>
<li><code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\device_support\f28004x\common\source\device.c</code></li>
<li><code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\device_support\f28004x\common\source\f28004x_codestartbranch.asm</code></li>
</ul>
<ol start="2" type="1">
<li>在项目名上右键点击 Add Files。</li>
</ol>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210719102326890.png" alt="image-20210719102326890" /><figcaption aria-hidden="true">image-20210719102326890</figcaption>
</figure>
<ol start="3" type="1">
<li>选择对应路径文件。</li>
</ol>
<p><img src="https://pic.islet.space/2021/07/image-20210719102359274.png" alt="image-20210719102359274" style="zoom:80%;" /></p>
<ol start="4" type="1">
<li>选择添加方式 Link to files ，可以看到项目中已经添加了一个文件。</li>
</ol>
<div style="text-align: center;">
<img src="https://pic.islet.space/2021/07/image-20210719102420155.png" alt="image-20210719102420155" style="zoom:80%;" /> <img src="https://pic.islet.space/2021/07/image-20210719102438745.png" alt="image-20210719102438745" style="zoom:80%;" />
</div>
<ol start="5" type="1">
<li>到此处后仍不能进行 <code>Build Project</code> ，会报错 <code>error #10234-D: unresolved symbols remain c28</code>，需要执行下一步，将 <code>main.c</code> 以 <strong><em>新文件形式</em></strong> 添加进去。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;device.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize device clock and peripherals</span></span><br><span class="line">    Device_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize GPIO and configure the GPIO pin as a push-pull output</span></span><br><span class="line">    Device_initGPIO();</span><br><span class="line">    GPIO_setPadConfig(DEVICE_GPIO_PIN_LED1, GPIO_PIN_TYPE_STD);</span><br><span class="line">    GPIO_setDirectionMode(DEVICE_GPIO_PIN_LED1, GPIO_DIR_MODE_OUT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize PIE and clear PIE registers. Disables CPU interrupts.</span></span><br><span class="line">    Interrupt_initModule();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the PIE vector table with pointers to the shell Interrupt</span></span><br><span class="line">    <span class="comment">// Service Routines (ISR).</span></span><br><span class="line">    Interrupt_initVectorTable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable Global Interrupt (INTM) and realtime interrupt (DBGM)</span></span><br><span class="line">    EINT;</span><br><span class="line">    ERTM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop Forever</span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="comment">// Turn on LED</span></span><br><span class="line">        GPIO_writePin(DEVICE_GPIO_PIN_LED1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Delay for a bit.</span></span><br><span class="line">        DEVICE_DELAY_US(<span class="number">500000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Turn off LED</span></span><br><span class="line">        GPIO_writePin(DEVICE_GPIO_PIN_LED1, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Delay for a bit.</span></span><br><span class="line">        DEVICE_DELAY_US(<span class="number">500000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="项目编译">项目编译</h2>
<p>修改完之后进行编译 Build Project ，会报错 <strong><em>内存不足</em></strong>，信息如下：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:/ti/c2000Ware/C2000Ware_2_01_00_00/device_support/f28004x/common/<span class="built_in">cmd</span>/<span class="number">28004</span>x_generic_ram_lnk.<span class="built_in">cmd</span>&quot;, line <span class="number">81</span>: error #<span class="number">10099</span>-D: program will <span class="keyword">not</span> fit into available memory.  run placement with alignment/blocking fails <span class="keyword">for</span> section &quot;.stack&quot; size <span class="number">0</span>x400 page <span class="number">1</span>.  Available memory ranges:</span><br><span class="line">   RAMM1        size: <span class="number">0</span>x3f8        unused: <span class="number">0</span>x3f8        max hole: <span class="number">0</span>x3f8     </span><br></pre></td></tr></table></figure>
<p>以上错误信息的大意是，软件需要使用到的 <strong>堆</strong> <code>.stack</code> 的大小是 <code>0x400</code> 而 <code>RAMM1</code> 的大小只有 <code>0x3f8</code> 。</p>
<p>从错误提示中看到报错的文件名，打开在 <strong>设置文件搜索路径</strong> 中添加的 <code>28004x_generic_ram_lnk.cmd</code> 文件，已知TI公司利用 <code>.cmd</code> 文件来描述芯片内部地址，打开该文件并搜索可以看到 <code>RAMM1</code> 的确大小不足 <code>0x40</code>，且此时 <code>RAMM1_RSVD</code> 并未被使用，适当修改 <code>RAMM1</code> 的地址长度，注意不要和其他地址长度重叠即可。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210719110002751.png" alt="image-20210719110002751" style="zoom:80%;" /></p>
<p>重新编译即可成功。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210719111024816.png" alt="image-20210719111024816" /><figcaption aria-hidden="true">image-20210719111024816</figcaption>
</figure>
<h1 id="评估板硬件连接">评估板硬件连接</h1>
<p>TI官方的评估板型号为 LAUNCHXL-F280049C （如下示），支持使用JTAG连接与PC进行通信，关于评估板的手册文档如<a target="_blank" rel="noopener" href="https://www.ti.com/lit/spruii7">《SPRUII7》</a>所示。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210726152918902.png" alt="image-20210726152918902" /><figcaption aria-hidden="true">image-20210726152918902</figcaption>
</figure>
<p>连接完毕之后，设备管理器 会出现如下图所示硬件：</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210726154218244.png" alt="image-20210726154218244" /><figcaption aria-hidden="true">image-20210726154218244</figcaption>
</figure>
<div style="text-align: center; font-weight: 900;">
图 设备管理器界面
</div>
<p>本评估板自带了XDS110接口，只需要使用USB mini 线和PC进行，并在项目文件路径 <code>targetConfigs\TMS320F280049C_LaunchPad.ccxml</code> 文件下确保连接器和设备正确即可。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210726153612834.png" alt="image-20210726153612834" /><figcaption aria-hidden="true">image-20210726153612834</figcaption>
</figure>
<div style="text-align: center; font-weight: 900;">
图 Project Explorer窗口下的文件路径
</div>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210726153524140.png" alt="image-20210726153524140" /><figcaption aria-hidden="true">image-20210726153524140</figcaption>
</figure>
<div style="text-align: center; font-weight: 900;">
图 配置文件下的连接器配置
</div>
<p>在<code>.ccxml</code> 文件中进行修改，点击下方的 <em>Advanced</em>，然后选择 <code>cJTAG(1149.7)2-pin advance mode</code>，然后 <em>save</em> 保存即可。具体操作如下图：</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210726155434636.png" alt="image-20210726155434636" /><figcaption aria-hidden="true">image-20210726155434636</figcaption>
</figure>
<div style="text-align: center; font-weight: 900;">
图 选择cJTAG连接方式
</div>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210726160136365.png" alt="image-20210726160136365" /><figcaption aria-hidden="true">image-20210726160136365</figcaption>
</figure>
<div style="text-align: center; font-weight: 900;">
图 点击测试按钮进行连接测试
</div>
<h1 id="f28004x-api指南">F28004x API指南</h1>
<p>截止2020年7月21日，最新版 <a target="_blank" rel="noopener" href="https://code.islet.space/TI/f28004x/3_04/intro.html">F28004x API指南 3.04版</a> 已上传。可以直接在联网电脑上打开，使用Google chrome浏览器可以右键翻译查阅。</p>
<h2 id="文件组织概述">文件组织概述</h2>
<p>以下是外围驱动库源代码的组织概览。</p>
<ul>
<li>{driverlib} - 此目录包含驱动程序的源代码。</li>
<li>{driverlib/inc/} - 此目录包含用于直接寄存器访问编程模型的外设、中断和寄存器访问头文件。</li>
<li>{hw_*.h} - 头文件，每个外设一个，描述每个外设的所有寄存器和这些寄存器中的位域。驱动程序使用这些头文件直接访问外设，应用程序代码可以使用这些头文件绕过外设驱动程序库 API。</li>
</ul>
<h2 id="编程模型">编程模型</h2>
<p>外设驱动程序库支持两种编程模型：<strong><em>直接寄存器访问模型</em></strong> 和 <strong><em>软件驱动程序模型</em></strong>。根据应用程序的需要或开发人员所需的编程环境，每个模型都可以单独使用或组合使用。</p>
<p>每种编程模型都有优点和缺点。与使用软件驱动程序模型相比，<mark>使用直接寄存器访问模型通常会产生更小、更高效的代码</mark>。然而，直接寄存器访问模型<mark>需要详细了解每个寄存器和位域的操作，以及它们的相互作用和外围设备正常操作所需的任何顺序</mark>；<mark>软件驱动程序模型</mark>使开发人员与这些细节更加隔绝，<mark>通常需要更少的时间来开发应用程序</mark>。软件驱动程序模型还产生了<mark>更具可读性的代码</mark>。</p>
<h1 id="f28004x-伪操作">F28004x 伪操作</h1>
<p>在 <code>F28004x_device.h</code> 文件中包含一部分伪操作，参考《SPRU430F》做出解释</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  EINT   __asm(<span class="meta-string">&quot; clrc INTM&quot;</span>)   <span class="comment">//INTM置0，打开（enable）中断</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  DINT   __asm(<span class="meta-string">&quot; setc INTM&quot;</span>)   <span class="comment">//INTM置1，关闭（disable）中断</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ERTM   __asm(<span class="meta-string">&quot; clrc DBGM&quot;</span>)   <span class="comment">//打开调试模式（Debug Mode）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  DRTM   __asm(<span class="meta-string">&quot; setc DBGM&quot;</span>)   <span class="comment">//关闭调试模式（Debug Mode）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  EALLOW __asm(<span class="meta-string">&quot; EALLOW&quot;</span>)   <span class="comment">//打开保护区域写入权限（Enable Write Access to Protected Space）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  EDIS   __asm(<span class="meta-string">&quot; EDIS&quot;</span>)   <span class="comment">//关闭保护区域写入权限（Disable Write Access to Protected Space）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ESTOP0 __asm(<span class="meta-string">&quot; ESTOP0&quot;</span>)   <span class="comment">//Emulation Stop 0</span></span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>： 以上伪操作中，最常使用的 <code>EALLOW</code> 和 <code>EDIS</code> 会在操作某些 写保护的寄存器时使用，利用这两句伪操作来暂时关闭写保护，写完寄存器后再打开保护。</p>
<p>以下为《SPRU430F》第107 ~ 113页提供的伪操作指令合集。</p>
<div style="text-align: center;">
<img src="https://pic.islet.space/2021/07/image-20210721145040598.png" alt="image-20210721145040598" style="zoom: 67%;" /><img src="https://pic.islet.space/2021/07/image-20210721145100629.png" alt="image-20210721145100629" style="zoom:67%;" />
</div>
<div style="text-align: center;">
<img src="https://pic.islet.space/2021/07/image-20210721145123473.png" alt="image-20210721145123473" style="zoom:67%;" /><img src="https://pic.islet.space/2021/07/image-20210721145138283.png" alt="image-20210721145138283" style="zoom:67%;" />
</div>
<div style="text-align: center;">
<img src="https://pic.islet.space/2021/07/image-20210721145157425.png" alt="image-20210721145157425" style="zoom:67%;" /><img src="https://pic.islet.space/2021/07/image-20210721145226082.png" alt="image-20210721145226082" style="zoom:67%;" />
</div>
<div style="text-align: center;">
<img src="https://pic.islet.space/2021/07/image-20210721145242594.png" alt="image-20210721145242594" style="zoom:67%;" />
</div>
<h1 id="c2000ware">C2000Ware</h1>
<p>C2000Ware是C28系列芯片的IDE组成部分，开发过程一共安装了两个版本，2.01版与3.04版，<marK>两者的文件结构基本一致</mark>，包括 <u>样例应用</u>、<u>头文件存放路径</u> 等基本一致，不一致的地方是文件内容，包括 <u>例程的增删</u> 和 <u>说明文档的更新</u>。始终不变的是C2000Ware的例程类别，总共有两种，分别在两个路径下：</p>
<ul>
<li><code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\driverlib\f28004x\examples</code>，存放的是 <strong><em>驱动库样例应用</em></strong>（Driver Library Example Applications），是以驱动及其案例来进行代码编写的，每个project都可能会涉及许多外设，因此使用前需要先阅读相关文档去了解该案例的开发目标，再结合实际进行修改。</li>
<li><code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\device_support\f28004x\examples</code>， 存放的是 <strong><em>位域样例应用</em></strong>（Bit-Field Example Applications），是以最小外设功能为目标的代码编写过程，并不是以project作为分类单元的，而是以外设为分类方法，每个外设的某个细节功能作为代码间的区别。</li>
</ul>
<p><strong>例如</strong>：同样是了解PWM外设的使用案例，从 <strong><em>驱动库样例应用</em></strong>（3.04版） 中能找到的案例只有3个：<code>boostxl_afe031_f28004x_pwmmode</code>、<code>hrpwm</code> 和 <code>adc_ex1_soc_epwm</code>，具体如何使用，使用到PWM里的何种功能并不能从项目案例中直接看出来。但是从 <strong><em>位域样例应用</em></strong>（3.04版） 中，可以找到13个PWM下的应用：<code>trip_zone</code> / <code>updown_aq</code> / <code>synchronization</code> / <code>digital_compare</code> / <code>digital_compare_event_filter</code> / <code>valley_switching</code> / <code>edge_filter</code> / <code>deadband</code> / <code>dma</code> / <code>chopper</code> / <code>configure_signal</code> / <code>monoshot_mode</code> / <code>up_aq</code> 。</p>
<blockquote>
<p><em>PS</em>：以上信息因C2000Ware版本不同而不同。</p>
</blockquote>
<p>以上信息，从《F28004x_DEV_USER_GUIDE》中也可以查看到，理清套件下的文件结构需要阅读的文件有两个，但在3.04版本的C2000Ware中未提供：</p>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://code.islet.space/TI/f28004x/docs/F28004x_DriverLib_Users_Guide.pdf">《F28004x_DriverLib_Users_Guide》</a></li>
<li><a target="_blank" rel="noopener" href="https://code.islet.space/TI/f28004x/docs/F28004x_DEV_USER_GUIDE.pdf">《F28004x_DEV_USER_GUIDE》</a></li>
</ol>
<p>2.01与3.04版本都提供了网页版的手册，可以在对应 <code>\docs\</code> 文件夹下查阅。推荐使用网页版 <a target="_blank" rel="noopener" href="https://code.islet.space/TI/f28004x/3_04/index.html">API指南</a> 进行函数原型速查。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210721154709745.png" alt="image-20210721154709745" /><figcaption aria-hidden="true">image-20210721154709745</figcaption>
</figure>
<div style="text-align: center; font-weight: 900;">
图 3.04版本函数的搜索查阅
</div>
<h1 id="高频逆变器开发">高频逆变器开发</h1>
<p><strong>逆变器</strong>，即将直流DC变换为交流AC的过程。利用 DSP输出波形，控制接入高压直流电的（高位 和 地位）两个IGBT输出正向和反向两种电压，形成交流AC。</p>
<p>逆变电路根据直流侧电源的性质不同（电压源/电流源）分为两种类别： <strong>电压型逆变电路</strong> 和 <strong>电流型逆变电路</strong>。</p>
<blockquote>
<p>电压源逆变电路的特点：</p>
<ol type="1">
<li>直流侧为电压源，或并联有大电容，相当于电压源。直流侧电压基本无脉动，直流回路呈现低阻抗。</li>
<li>由于直流电压源的钳位作用，交流侧输出电压波形为矩形波，且与负载阻抗角无关。而交流侧输出电流波形与相位因负载阻抗情况的不同而不同。</li>
<li>当交流侧为阻感负载时需要提供无功功率，直流侧电容起缓冲无功能能量的作用。为了给交流侧向直流侧反馈的无功能量提供通道，逆变桥各臂都并联了 反馈二极管。</li>
</ol>
</blockquote>
<p><strong>单相电压型逆变电路</strong> 可以根据变换出来的波形分为 <strong>半桥</strong> 或 <strong>全桥</strong>，即 <strong>单相半桥变压型逆变电路</strong> 和 <strong>单相全桥变压型逆变电路</strong>。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210719162954288.png" alt="image-20210719162954288" /><figcaption aria-hidden="true">image-20210719162954288</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210719162958021.png" alt="image-20210719162958021" /><figcaption aria-hidden="true">image-20210719162958021</figcaption>
</figure>
<p><strong>具体为</strong>：利用型号为 <code>TMS320F280041</code> 芯片的GPIO（最高输出频率为25MHz）输出一个30KHz的PWM波形，需要使用到 ePWM外设。使用官方C2000套件示例中提供的 <code>ePWM6</code> 案例进行开发，输出高位和低位两个幅频合适的波形后，接到型号为 <code>2EDL05I06PF</code> 的驱动上，由驱动控制型号为 <code>IKW50N65WR5</code> 的IGBT 高频开断。</p>
<h2 id="工作目标">工作目标</h2>
<ol type="1">
<li>使用内源时钟，使芯片工作在100Mhz</li>
<li>输出占空比为50%的PWM波形，频率在30KHz</li>
<li>采集输出的波形和IGBT输出的波形（可能需要检测相位和波纹）</li>
<li>完成过零饱和电压检测</li>
</ol>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210719160255497.png" alt="image-20210719160255497" /><figcaption aria-hidden="true">image-20210719160255497</figcaption>
</figure>
<div style="text-align: center; font-weight: 900;">
图 占空比为20%的测试波形
</div>
<h2 id="工作流程">工作流程</h2>
<pre class="mermaid">graph TB
系统初始化 --> 使能PWM模块时钟 --> 初始化PWM模块 --> PWM工作</pre>
<h3 id="初始化pwm流程">初始化PWM流程</h3>
<pre class="mermaid">graph TB
配置TB子系统 --> 配置CMPA和CMPB --> 设置CMPC寄存器 --> 配置TZ子系统 --> 配置AQ子系统 --> 配置DB子系统 --> 配置ET子系统</pre>
<h2 id="pll设置">PLL设置</h2>
<ul>
<li><code>TMS320F280041</code> 的外部晶振输入频率 f<span style="font-size: 0.8rem;">XTAL</span> 在 10 ~ 20 MHz 之间，自身工作频率f<span style="font-size: 0.8rem;">SYSCLK</span> 在 2 ~ 100MHz之间。</li>
</ul>
<p>以下为工作频率设置的样例，利用内源时钟 <code>10MHz</code> ，产生芯片满负工作频率 <code>100MHz</code> ：</p>
<p><img src="https://pic.islet.space/2021/07/image-20210715170724177.png" alt="image-20210715170724177" style="zoom:67%;" /></p>
<p>本系统采用10MHz的内源时钟 <strong><em>INTOSC2</em></strong> 作为 <strong><em>OSCCLK</em></strong>，其配置方法（包括设置公式和函数原型）都已在前文详细描述和记录，请参考该代码。</p>
<h2 id="epwm-1">ePWM</h2>
<p>以下为两个版本下案例所给的 <code>main()</code>函数的流程对比。</p>
<p>左侧用的是Bitfield模式，右边用的是driver-lib模式。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210722084618101.png" alt="image-20210722084618101" /><figcaption aria-hidden="true">image-20210722084618101</figcaption>
</figure>
<div style="text-align: center; font-weight: 900;">
图 新旧版本main()函数流程对比
</div>
<p>同样是将中断重新映射至ISR函数里，下图左侧是2.01版本下的driver-lib模式，右侧是3.04bit-field模式。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210721154450124.png" alt="image-20210721154450124" /><figcaption aria-hidden="true">image-20210721154450124</figcaption>
</figure>
<div style="text-align: center; font-weight: 900;">
图 不同的调用配置方法
</div>
<h3 id="宏定义">宏定义</h3>
<h4 id="epwm外设定义">ePWM外设定义</h4>
<p>在Driver-Lib的 <code>&lt;f28004x_globalVariabledefs.c&gt;</code> 中，提供了ePWM下各模块的定义，如下面代码所示，定义了 外设 ePWM1所有的寄存器（结构体）<code>EPwm1Regs</code> ，是EPWM_REGS的结构体实例。</p>
<p><strong>使用方法</strong>：使用该外设下的寄存器时直接按照结构体变量的方法使用即可，如 <code>EPwm1Regs.TBPRD = EPWM1_TIMER_TBPRD</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> DATA_SECTION(<span class="meta-string">&quot;EPwm1RegsFile&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> DATA_SECTION(EPwm1Regs,<span class="meta-string">&quot;EPwm1RegsFile&quot;</span>);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">EPWM_REGS</span> <span class="title">EPwm1Regs</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> DATA_SECTION(<span class="meta-string">&quot;EPwm2RegsFile&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> DATA_SECTION(EPwm2Regs,<span class="meta-string">&quot;EPwm2RegsFile&quot;</span>);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">EPWM_REGS</span> <span class="title">EPwm2Regs</span>;</span></span><br></pre></td></tr></table></figure>
<h4 id="设置上下桥">设置上下桥</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> EPWM1_TIMER_TBPRD = <span class="number">800</span>; <span class="comment">// 设置PWM的周期PRD为1600</span></span><br><span class="line"><span class="keyword">int</span> EPWM1_CMPA = <span class="number">200</span>;  <span class="comment">//设置高边CMPA为800</span></span><br><span class="line"><span class="keyword">int</span> EPWM1_CMPB = <span class="number">200</span>;  <span class="comment">//设置低边CMPB为800</span></span><br><span class="line"><span class="keyword">int</span> EPWM1_DBRED = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> EPWM1_DBFED = <span class="number">35</span>;</span><br></pre></td></tr></table></figure>
<h4 id="初始化外设">初始化外设</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * 【函数】：void EPWM1_Init(void);</span></span><br><span class="line"><span class="comment"> * 【参数】：无</span></span><br><span class="line"><span class="comment"> * 【说明】：需要查阅《TRM》或开发文档相关说明</span></span><br><span class="line"><span class="comment"> *                     本代码文件中仅包含ePWM6模块的使用，其中ET开头的寄存器为事件</span></span><br><span class="line"><span class="comment"> *                     触发相关寄存器，用以触发ADC转换（SOC）</span></span><br><span class="line"><span class="comment"> *                     需要配置的寄存器有：</span></span><br><span class="line"><span class="comment"> * 【其他】：注意，EPWM设置时必须开着时钟（PCLKCR2）进行配置，否则配置</span></span><br><span class="line"><span class="comment"> *                     会失败</span></span><br><span class="line"><span class="comment"> * 【参考】：</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EPWM1_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    EALLOW;                                                           <span class="comment">//打开保护区域写入权限</span></span><br><span class="line">    CpuSysRegs.PCLKCR2.bit.EPWM1 = ON;           <span class="comment">// 打开CPUSYSREG 地址下PCLKCR2寄存器上的EPWM1位</span></span><br><span class="line">    CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = OFF;   <span class="comment">//关闭TBCLK时钟同步</span></span><br><span class="line">    EDIS;                                                                 <span class="comment">//关闭保护区域写入权限</span></span><br><span class="line"></span><br><span class="line">    EPwm1Regs.TBPRD = EPWM1_TIMER_TBPRD;       <span class="comment">// 设定定时器周期</span></span><br><span class="line">    EPwm1Regs.TBPHS.bit.TBPHS = <span class="number">0x0000</span>;                 <span class="comment">// 初始化相位</span></span><br><span class="line">    EPwm1Regs.TBCTR = <span class="number">0x0000</span>;                                  <span class="comment">// 初始化（清空）TB计数器</span></span><br><span class="line"></span><br><span class="line">    EPwm1Regs.CMPA.bit.CMPA = EPWM1_CMPA;    <span class="comment">// 设定高边值</span></span><br><span class="line">    EPwm1Regs.CMPB.bit.CMPB = EPWM1_CMPB;    <span class="comment">// 设定低边值</span></span><br><span class="line"></span><br><span class="line">    EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN;      <span class="comment">//设置TB计数器为增减计数模式</span></span><br><span class="line">    EPwm1Regs.TBCTL.bit.PHSEN = TB_DISABLE;                              <span class="comment">// 关闭相位载入</span></span><br><span class="line">    EPwm1Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_DISABLE;            <span class="comment">//关闭各PWM间的同步</span></span><br><span class="line">    EPwm1Regs.TBCTL.bit.HSPCLKDIV = TB_DIV1;                            <span class="comment">// 调节本值可以设置TB速率，详见开发文档</span></span><br><span class="line">    EPwm1Regs.TBCTL.bit.CLKDIV = TB_DIV2;                                   <span class="comment">// 调节本值可以设置TB速率，详见开发文档</span></span><br><span class="line">    EPwm1Regs.TBCTL.bit.FREE_SOFT = <span class="number">0x03</span>;                                   <span class="comment">//不停止，free-run 模式</span></span><br><span class="line"></span><br><span class="line">    EPwm1Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW;    <span class="comment">//打开CC子模块下的影子寄存器A</span></span><br><span class="line">    EPwm1Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW;</span><br><span class="line">    EPwm1Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO_PRD; <span class="comment">// Load on Zero</span></span><br><span class="line">    EPwm1Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO_PRD;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    EPwm1Regs.TZSEL.bit.OSHT1 = <span class="number">1</span>;   <span class="comment">//为PWM1使能单次事件触发TZ</span></span><br><span class="line">    EPwm1Regs.TZCTL.bit.TZA = <span class="number">2</span>;    <span class="comment">// EPWMA会被强制置低</span></span><br><span class="line">    EPwm1Regs.TZCTL.bit.DCAEVT1 = TZ_LOW_STATE;</span><br><span class="line">    EPwm1Regs.TZCTL.bit.DCAEVT2 = TZ_LOW_STATE;</span><br><span class="line"></span><br><span class="line">    EPwm1Regs.TZCTL.bit.TZB = <span class="number">2</span>;   <span class="comment">// EPWMB会被强制置低</span></span><br><span class="line">    EPwm1Regs.TZCTL.bit.DCBEVT1 = TZ_LOW_STATE;</span><br><span class="line">    EPwm1Regs.TZCTL.bit.DCBEVT2 = TZ_LOW_STATE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定事件触发结果，当CMPx == TBCTR时该如何动作，此处需要高边A和低边B的动作随着TB增减而相反</span></span><br><span class="line">    EPwm1Regs.AQCTLA.bit.CAU = AQ_SET;</span><br><span class="line">    EPwm1Regs.AQCTLB.bit.CBU = AQ_CLEAR;</span><br><span class="line">    EPwm1Regs.AQCTLA.bit.CAD = AQ_CLEAR;</span><br><span class="line">    EPwm1Regs.AQCTLB.bit.CBD = AQ_SET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死区控制</span></span><br><span class="line">    EPwm1Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE;   <span class="comment">//0x3   MODE2 AHC high level delay</span></span><br><span class="line">    EPwm1Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC;        <span class="comment">//0x2</span></span><br><span class="line">    EPwm1Regs.DBCTL.bit.IN_MODE = DBA_ALL;</span><br><span class="line">    EPwm1Regs.DBRED.all = <span class="number">120</span>;                        <span class="comment">// 上升沿延时   0us  0个(15MHz)   注意：只有10位，最大1023</span></span><br><span class="line">    EPwm1Regs.DBFED.all = <span class="number">120</span>;                        <span class="comment">// 下降沿延时   0us  (15MHz)   注意：只有10位，最大1023</span></span><br><span class="line"></span><br><span class="line">    EPwm1Regs.ETSEL.bit.INTEN = ON;                <span class="comment">// 关闭EPWM外设的中断</span></span><br><span class="line">    EPwm1Regs.ETSEL.bit.SOCAEN = ON;            <span class="comment">// 打开ePWM1的SOCA脉冲</span></span><br><span class="line">    EPwm1Regs.ETSEL.bit.SOCASEL = <span class="number">0x02</span>;          <span class="comment">// TB计数器等予周期时触发事件</span></span><br><span class="line">    EPwm1Regs.ETPS.bit.SOCAPRD = <span class="number">0x01</span>;          <span class="comment">// 在第一次事件时生成脉冲</span></span><br><span class="line"></span><br><span class="line">    EALLOW;</span><br><span class="line">    EPwm1Regs.TBCTL.bit.PHSEN = ON;                  <span class="comment">//打开从相位寄存器载入</span></span><br><span class="line">    EPwm1Regs.TBCTL.bit.SYNCOSEL = OFF;          <span class="comment">//同步输出源选择</span></span><br><span class="line">    EPwm1Regs.TBCTL.bit.SWFSYNC = OFF;           <span class="comment">//软件强制同步脉冲</span></span><br><span class="line">    CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = ON;   <span class="comment">//打开TBCLK时钟同步</span></span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码里总结出下面配置步骤：</p>
<pre class="mermaid">graph LR
配置开始 --> 配置TBCLK --> 配置影子寄存器ShadowRegister --> 配置CMP --> 配置TripZone --> 配置AactionQualifier --> 配置ePWM中断 --> 配置结束</pre>
<h3 id="epwmclk">EPWMCLK</h3>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210726110116356.png" alt="image-20210726110116356" /><figcaption aria-hidden="true">image-20210726110116356</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210802172012594.png" alt="image-20210802172012594" /><figcaption aria-hidden="true">image-20210802172012594</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210802171937172.png" alt="image-20210802171937172" /><figcaption aria-hidden="true">image-20210802171937172</figcaption>
</figure>
<p>通过配置下方代码中 <code>main()</code> 函数的参数，来对CPU 、ePWM的相关寄存器参数进行调节，可以实现目标PWM周期为30.8Khz的设置。</p>
<p>参数计算代码就不贴了，可以直接下载：<a target="_blank" rel="noopener" href="http://code.islet.space/VisualStudioStudio/F28004x_ParamsCalculate/main.cpp">main.cpp</a></p>
<p>从系统时钟设置到外设时钟设置过程中，需要设置的寄存器、位及其数值具体如下（仅供参考）：</p>
<ol type="1">
<li>设置时钟源。选择时钟源为 <strong><em>内源时钟2</em></strong>（INTOSC2），修改 <code>CLKSRCCTL1</code> 寄存器下的 <code>OSCCLKSRCSEL</code> 值为 <code>0x00</code> 。</li>
<li>设置系统PLL频率。需要分别设置整数分频、分数分频 和 系统分频，对应修改 <code>SYSPLLMULT</code> 寄存器下的 <code>IMULT</code> / <code>FMULT</code> / <code>ODIV</code> 值为 <code>0x13</code> / <code>0x3</code> / <code>0x1</code> （或使用十进制赋值 <code>19</code> / <code>3</code> / <code>1</code>）。</li>
<li>设置需要使用的PWM设备序号。打开对应控制的 <code>PCLKCRx</code> 寄存器下的对应位，参考《SPRUI33D》第195页相关寄存器说明。</li>
<li>设定PWMCLK频率。修改 <code>TBCTL</code> 寄存器下的 <code>HSPCLKDIV</code> 及 <code>CLKDIV</code> 为 <code>0x00</code>（<code>1</code>） 及 <code>0x01</code> （<code>2</code>）（默认情况下也是这个值），以获得 <strong>CPU时钟速率一半值的外设时钟</strong>。</li>
<li>设定TB计数器模式。修改 <code>TBCTL</code> 寄存器下的 <code>CTRMODE</code> 为 <code>0x2</code> ，打开 TB counter 的增减计数模式。</li>
<li>设定TB周期。修改 <code>TBPRD</code> 寄存器的值为十进制的 <code>1600</code> 。</li>
</ol>
<h4 id="公式总结">公式总结</h4>
<p><span class="math display">\[
F_{TBCLK} = {F_{EPWMCLK} \over HSPCLKDIV · CLKDIV} \tag{PWM工作频率公式}
\]</span></p>
<p><span class="math display">\[
T_{EPWM} = (TBPRD +1) · T_{TBCLK} =  {(TBPRD +1) · HSPCLKDIV · CLKDIV \over F_{EPWMCLK}} \tag{单个ePWM波周期公式}
\]</span> 根据《TRM》P1888，<strong>HSPCLKDIV</strong> 的可取值范围是 <span class="math inline">\(\{1,2,4,6,8,10,12,14\}\)</span> ，而 <strong>CLKDIV</strong> 的可取值范围是 <span class="math inline">\(\{1,2,4,8,16,32,64,128\}\)</span>​ 。</p>
<p>如果不修改 <strong>TBCTL</strong> 寄存器下的 <strong>HSPCLKDIV</strong> 和 <strong>CLKDIV</strong>，默认情况下这两个的乘积就是 <code>2</code>，而 <span class="math inline">\(F_{EPWMCLK} = 100MHz\)</span> ，也就是最终 <span class="math inline">\(T_{EPWM}\)</span> 的值完全由 <span class="math inline">\(T_{PRD}\)</span> 来决定。已知 <strong>TBPRD</strong> 寄存器是16位寄存器， 取值范围是 <span class="math inline">\([0,65535]\)</span> ，在本项目情况下，可以写成如下等式：</p>
<p>此处需要注意，因为设定的ePWM使用 <strong>增减计数模式</strong>，<strong>TBPRD</strong> 值实际上是设定值的两倍。</p>
<h2 id="死区时间设定">死区时间设定</h2>
<p>死区时间需要联系实际电路中的 <strong>IGBT</strong> 及其 <strong>驱动器</strong> 进行综合分析。</p>
<h3 id="igbt特性">IGBT特性</h3>
<p>下表为温度范围在 [25℃, 175℃] 时，IGBT开关特性和二极管特性表。</p>
<figure>
<img src="https://pic.islet.space/2021/09/image-20210907200102300.png" alt="image-20210907200102300" /><figcaption aria-hidden="true">image-20210907200102300</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/09/image-20210907200144294.png" alt="image-20210907200144294" /><figcaption aria-hidden="true">image-20210907200144294</figcaption>
</figure>
<p>已知死区时间最高需要达到 <span class="math inline">\(145ns\)</span>，而系统频率在100MHz时，<span class="math inline">\(T_{SYSCLK} = 10^{-8}s = 10ns\)</span>​​​​，而外设 ePWM1 的工作频率为50MHz，<span class="math inline">\(T_{ePWM} = 20ns\)</span>，也就是说，​​至少需要等待15个系统周期或 <span class="math inline">\([5.5,7.25]\)</span> 个PWM工作周期。</p>
<p>根据公式 $CMP = T_{HighLevel} / (T_{TBCLK} *2) $，已知所需</p>
<h3 id="驱动器特性">驱动器特性</h3>
<p>IGBT 驱动器内部有个 <strong>内部死区时间</strong>（Internal Deadtime） <span class="math inline">\(t_{DT(internal)} = 100ns\)</span></p>
<figure>
<img src="https://pic.islet.space/2021/09/image-20210908141224008.png" alt="image-20210908141224008" /><figcaption aria-hidden="true">image-20210908141224008</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/09/image-20210908142609386.png" alt="image-20210908142609386" /><figcaption aria-hidden="true">image-20210908142609386</figcaption>
</figure>
<h3 id="死区计算">死区计算</h3>
<p>根据 <strong>死区时间计算公式</strong> <span class="math inline">\(t_{DT} = [ (t_{d(off),max} + t_{f,max}-t_{d(on),min}) + (t_{PHL,max} - t_{PLH, min})] · S\)</span> ，代入计算​：</p>
<ul>
<li><span class="math inline">\(T_{vj} = 25℃\)</span>​ 时， $t_{DT} = (417ns+16ns-45ns) + (270ns - ns) · 150% = $​​</li>
</ul>
<h1 id="数模转换开发">数模转换开发</h1>
<p>首先需要弄明白以下几个问题：</p>
<ol type="1">
<li>ADC采样的信号有何种特征（ADCIN），此处所述为电气特性（电压、电流、频率等）</li>
<li>ADC采样所需要的最小精度应该是多少，即ADC模块应该多久转换一次采样电容的电压值来转换成数值，ADC模块读取转换电容的最小周期应该是多少最合适</li>
<li>CPU对数值的读取又是多久读取一次，每一次转换都读取还是间隔多次转换再读取（即，ADC采样触发的周期和数据读取的周期是分开配置的），可以配置为单次采样、超采样、多重采样 或 软触发采样。</li>
</ol>
<p>数模转换开发不同于ePWM配置开发，不仅信号输入和子模块配置方式上有许多不同点，最明显的不同是高频逆变器不需要使用到触发中断，但ADC模块不论是转换触发还是读取数值都需要中断来进行操作，即由外部中断脉冲输入ADC模块，促使ADC模块将电容电压依据参考电压转换为数值并存写到寄存器中，然后生成中断脉冲，触发中断程序来读取其中的数值。</p>
<h2 id="工作流程-1">工作流程</h2>
<pre class="mermaid">graph TB
进入ADC中断 --> 读取ADC寄存器数值并存储至全局变量 --> 交由主循环计算电压/电流/温度值并判断是否安全 --> id1[定时器中断检查开关/安全] --是--> 保持PWM开启
id1 --否--> 关闭PWM</pre>
<h3 id="adc配置流程">ADC配置流程</h3>
<pre class="mermaid">graph LR
系统初始化 --> 使能ADC模块时钟 --> 配置模块参考电压 --> 配置模块时钟 --> 配置SOC通道 --> 配置采样周期 --> 配置采样触发源 --> 配置EOC中断触发源</pre>
<h3 id="配置示例-1">配置示例</h3>
<p>ADC模块在功能描述上也有别于ePWM，ePWM采用许多子模块的描述方法，ADC则使用 <strong>通道</strong>（CHNL，或 channel）、<strong>SOC</strong>、<strong>EOC</strong>、<strong>INT</strong> 等描述词汇，需要区分理解，且ADC模块从顶自下参数都有许多配置限制，具体看前面的描述吧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * 【函数】：void ADC_Init(void);</span></span><br><span class="line"><span class="comment"> * 【参数】：无</span></span><br><span class="line"><span class="comment"> * 【说明】：配置ADC模块的电压、时钟、脉冲生成时间和开关</span></span><br><span class="line"><span class="comment"> * 【其他】：以下所有配置项（电压、时钟、脉冲生成时间和开关）都是以模块（A</span></span><br><span class="line"><span class="comment"> *                      /B/C）为最小单位进行配置的，需要启动ADCB和ADCC则需要在此处</span></span><br><span class="line"><span class="comment"> *                      进行相似配置</span></span><br><span class="line"><span class="comment"> * 【参考】：</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------------- */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    SetVREF(ADC_ADCA, ADC_EXTERNAL, ADC_VREF2P5);  <span class="comment">//为ADC A提供外部参考电压</span></span><br><span class="line"></span><br><span class="line">    EALLOW;</span><br><span class="line">    AdcaRegs.ADCCTL2.bit.PRESCALE = <span class="number">0x02</span>;         <span class="comment">//`0010`，ADCCLK = 输入时钟 / 2.0，即50MHz</span></span><br><span class="line">    AdcaRegs.ADCCTL1.bit.INTPULSEPOS = <span class="number">0x1</span>;    <span class="comment">// 写1的话，在ADC转换完成时（ADC捕获窗口周期结束时）生成脉冲中断</span></span><br><span class="line">                                               <span class="comment">// 写0的话，就是在窗口周期结束时加上一组系统时钟周期后再生成中断，具体看《TRM》P1499</span></span><br><span class="line">    AdcaRegs.ADCCTL1.bit.ADCPWDNZ = ON;     <span class="comment">// 打开ADC A 的所有模拟电路</span></span><br><span class="line">    EDIS;</span><br><span class="line"></span><br><span class="line">    DELAY_US(<span class="number">1000</span>);  <span class="comment">//延迟1ms</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * 【函数】：void ADC_SOC_Init(void);</span></span><br><span class="line"><span class="comment"> * 【参数】：无</span></span><br><span class="line"><span class="comment"> * 【说明】：配置ADC模块下的SOC，设置通道和中断相关内容</span></span><br><span class="line"><span class="comment"> * 【其他】：ADCINTSEL1N2寄存器是设置中断源相关的，</span></span><br><span class="line"><span class="comment"> * 【参考】：</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------------- */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_SOC_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    EALLOW;</span><br><span class="line">    AdcaRegs.ADCSOC0CTL.bit.CHSEL = <span class="number">0x1</span>;           <span class="comment">// channel select，为SOC0选择通道ADCA1，可设置范围为0~F</span></span><br><span class="line">    AdcaRegs.ADCSOC0CTL.bit.ACQPS = <span class="number">0x1FF</span>;      <span class="comment">// acquisition window, AW = (ACQPS+1) * SYSCLK，需要结合实际硬件设计进行计算，计算代码在文档中，1~511</span></span><br><span class="line">    AdcaRegs.ADCSOC0CTL.bit.TRIGSEL = <span class="number">0x0F</span>;      <span class="comment">// trigger select，触发源选择为ePWM6，每一次ePWM</span></span><br><span class="line">    AdcaRegs.ADCINTSEL1N2.bit.INT1SEL = <span class="number">0x0</span>;     <span class="comment">// 由EOC0来触发ADCA模块的第一个中断（INT1）</span></span><br><span class="line">    AdcaRegs.ADCINTSEL1N2.bit.INT1E = ON;        <span class="comment">// 打开ADCA模块的第一个中断（INT1）</span></span><br><span class="line">                                                 <span class="comment">// 此处没有设置ADC A的 中断生成模式（INT1CONT），默认为0x0，即手动清除中断标志时生成中断脉冲</span></span><br><span class="line">    AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = <span class="number">0x1</span>;   <span class="comment">//  清除ADC中断1的标志</span></span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * 【函数】：__interrupt void adcA1ISR(void);</span></span><br><span class="line"><span class="comment"> * 【参数】：无</span></span><br><span class="line"><span class="comment"> * 【说明】：ADC外设中断的处理程序</span></span><br><span class="line"><span class="comment"> * 【其他】：注意需要加 __interrupt 关键字，加了的话编译器会自动处理 保持和恢</span></span><br><span class="line"><span class="comment"> *                     复特定的CPU寄存器状态（如果需要）且在人为清除中断组PIEACK位</span></span><br><span class="line"><span class="comment"> *                     后会自动使用IRET指令来返回；如果不加，则保持和恢复工作 以及 返</span></span><br><span class="line"><span class="comment"> *                     回工作需要人为处理。</span></span><br><span class="line"><span class="comment"> * 【参考】：详见开发文档的处理中断部分，或《TRM》P85</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------------- */</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">adcA1ISR</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    sampleResult = AdcaResultRegs.ADCRESULT0;</span><br><span class="line"></span><br><span class="line">    AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = <span class="number">1</span>;   <span class="comment">// ADCA模块上的第一个中断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == AdcaRegs.ADCINTOVF.bit.ADCINT1)&#123;</span><br><span class="line">        AdcaRegs.ADCINTOVFCLR.bit.ADCINT1 = <span class="number">1</span>;  <span class="comment">//清除中断溢出</span></span><br><span class="line">        AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = <span class="number">1</span>;   <span class="comment">// ADCA模块上的第一个中断</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;    <span class="comment">// 确认中断</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="转换修正">转换修正</h3>
<p>ADC为12bit分辨率的电压转换外设，下面为读取数值和特定量程之间的电压转换代码，可以通过宏定义来修改最高量程、参考电压最高值 和 单个引脚的偏差值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    ADCDATA_OFFSET   40   <span class="comment">// ADC2通道的量程偏差</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    VOLTAGE_RANGE   3.30   <span class="comment">//电压量程3.3V</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    ADC_RANGE  4096   <span class="comment">//ADC量程4096</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * 【函数】：float AdcVoltage(ADCDATA regData);</span></span><br><span class="line"><span class="comment"> * 【参数】：1. 瞬时读取的ADC寄存器的值 regData</span></span><br><span class="line"><span class="comment"> * 【说明】：将ADC寄存器结果的值转换为对应量程电压的处理程序</span></span><br><span class="line"><span class="comment"> * 【其他】：</span></span><br><span class="line"><span class="comment"> * 【参考】：</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------------- */</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">AdcVoltage</span><span class="params">(ADCDATA regData)</span></span>&#123;</span><br><span class="line">    ADCDATA tempData = <span class="number">0</span>;    <span class="comment">//初始化中转变量 tempData</span></span><br><span class="line"></span><br><span class="line">    tempData = regData + ADCDATA_OFFSET ;  <span class="comment">//修正某个模拟端口的偏差值，偏差值可以人为修改（假设测试设备输出电压经过计量）</span></span><br><span class="line">    <span class="keyword">if</span>(tempData &lt;= <span class="number">0</span>) tempData = <span class="number">0</span>;   <span class="comment">//超量程偏差修正</span></span><br><span class="line">    <span class="keyword">if</span>(tempData &gt;=ADC_RANGE) tempData = ADC_RANGE;   <span class="comment">//超量程偏差修正</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">float</span>)tempData / ADC_RANGE * VOLTAGE_RANGE);   <span class="comment">//转换成电压值，返回浮点数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="温度传感">温度传感</h2>
<p>通过热敏电阻和普通10KΩ电阻的串联，施以3.3V电压，并在两个电阻之间引出导线接入ADC，ADC通过检测电压数值来输出对应 电压值。</p>
<p>由下方的热敏电阻 <strong>阻值特性表</strong> 可知，热敏电阻的温度升高和阻值之间并非线性关系。阻值偏差也在各温度间情况不同。</p>
<p><img src="https://pic.islet.space/2021/08/image-20210820212823758.png" alt="image-20210820212823758" style="zoom:77%;" /></p>
<p style="text-align: center; color: gray; font-size: 0.8rem; font-style: italic;">
中间部分省略......
</p>
<p><img src="https://pic.islet.space/2021/08/image-20210820212605911.png" alt="image-20210820212605911" style="zoom:80%;" /></p>
<p style="text-align: center; color: gray; font-size: 0.8rem; font-style: italic;">
中间部分省略......
</p>
<p><img src="https://pic.islet.space/2021/08/image-20210820212218560.png" alt="image-20210820212218560" style="zoom:105%;" /></p>
<h3 id="阻值与温度公式">阻值与温度公式</h3>
<p>已知热敏电阻的阻值和温度关系公式—— <strong>B常数求解公式</strong> ，如下式1： <span class="math display">\[
B = {ln(R_{T1}) - ln(R_{T2})\over {1 \over {T_1}} -{ 1 \over T_2}}
\]</span> 将阻值特性表中的目标温度 <code>110℃</code> <strong>安全限制温度</strong> 作为 $ T2 $​​​，其 <strong>热敏电阻值</strong>（均值） <code>2508Ω</code> 作为 $ R_{T2} <span class="math inline">\(​​​​，\)</span> T_1 <span class="math inline">\(​​​ 则为 `25℃` ，\)</span> R_{T1} $​​​​​​ （均值）为 <code>50000Ω</code>，代入进行计算，求得B常数为 <code>4021.84</code> 。</p>
<p>将B常数作为已知参数，将式1进行变换获得可求解实时温度的公式2： <span class="math display">\[
T_2 = {B · T_1 \over {T_1· (ln(R_{T2}/R_{T1}) + B} }
\]</span> 注意，以上的 $ T_1 $ 和 $ T_2 $ 指的是在绝对零度的基础上，即 <code>25℃ + 273.15</code> 才是 $ T_1 $​​ ，目标温度在公式计算出来之后也需要减去 <code>273.15</code> 。</p>
<h3 id="电压与阻值读数关系">电压与阻值读数关系</h3>
<p>已知ADC寄存器的度数结果为 $ ADC $​​​​，其读数最大值为 $ ADC_{MAX} $​​​​，对应的电压分别为 $ V_{ADC} $​​​​ 和 $ V_{REF} $​​​​ 。ADC模块的参考电压 <span class="math inline">\(V_{REF}\)</span>​​ 并不会收到外接ADC电路的影响，该参数是由参考电压和内部定义进行设置的，此处可以看做恒常 <code>3.3V</code> 。 <span class="math display">\[
{ADC \over ADC_{MAX} } ={V_{ADC} \over V_{REF}}
\]</span> 由 <strong>式3</strong> 可以变形成 <strong>式4</strong>，ADC是寄存器中容易读取的数值，公式变形如下： <span class="math display">\[
V_{ADC} = {ADC · V_{REF} \over {ADC_{MAX}}}
\]</span></p>
<h3 id="adc外接电路电压关系">ADC外接电路电压关系</h3>
<p><img src="https://pic.islet.space/2021/08/image-20210821150320248.png" alt="image-20210821150320248" style="zoom:80%;" /></p>
<p>已知上方电路图中的<span class="math inline">\(R_{76}\)</span>​​ 和 <span class="math inline">\(R_{78}\)</span>​​​ 的阻值均为 <code>10KΩ</code> ，用 <span class="math inline">\(R\)</span>​​​ 来表示，向ADC电路施加的 <code>3.3V</code> 电压用 <span class="math inline">\(V_{thermal}\)</span>​​​ 来表示，此时，ADC电路内的电压公式如下： <span class="math display">\[
V_{ADC} = {V_{thermal} \over {R_{thermal} + R}} · R
\]</span> 联立 <strong>式4</strong> 和 <strong>式5</strong> ，可得热敏电阻的实时电阻计算公式如下： <span class="math display">\[
R_{thermal} = {ADC_{MAX} · V_{thermal} · R \over ADC · V_{REF}} -R
\]</span> 若电路设计时，确保此处 <span class="math inline">\(V_{thermal}\)</span>​ 和 <span class="math inline">\(V_{REF}\)</span>​​ 一致，进行公式简化得： <span class="math display">\[
R_{thermal} = {ADC_{MAX} · 3.3 · R \over ADC · 3.3} - R = {ADC_{MAX}·R \over ADC} - R = {(ADC_{MAX}-ADC)·R \over ADC} ={ (4095-ADC)·10000 \over ADC}
\]</span> 热敏电阻的阻值实时求算公式与B常数、初始温度、初始阻值等无关，仅与外围电路的电阻 <span class="math inline">\(R\)</span>​ 有关。</p>
<h4 id="限温策略">限温策略</h4>
<p>有两种方法可以设定安全关断：</p>
<ol type="1">
<li>不要求计算B系数，但是只需要设置对应的安全温度阻值即可。即 <strong>式7</strong> 所示，当 <span class="math inline">\(R_{thermal}\)</span>​​​ 小于安全温度阻值时，即触发中断。</li>
<li>设置其安全温度，在上方步骤1 的基础联立公式2进一步求解，计算量会增加，而且并不是非常准确的。</li>
</ol>
<h2 id="数值转换程序">数值转换程序</h2>
<p>宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下方为ADC读值配置相关宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    ADCDATA_OFFSET   40   <span class="comment">// ADC2通道的量程偏差</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    ADC_RANGE  4096   <span class="comment">//ADC量程4096</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下方为热敏电阻电路相关宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    TEMPERATURE_RANGE    110  <span class="comment">//温度量程180（摄氏度）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    VOLTAGE_RANGE   3.30   <span class="comment">//电压量程3.3V</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    THM_ABSTEMP    273.15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    THM_BCONST    4021.84  <span class="comment">//根据阻值特性表和公式确定的，在T2 = 110摄氏度时的拟合B常数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    THM_T1    (25.0+THM_ABSTEMP)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    THM_RT1    50000.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    THM_R_SAFE    2550    <span class="comment">//确定安全温度对应的拟合公式内的RT2为2.55KΩ</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    THM_R    10000.0  <span class="comment">//设置外接ADC电路的电阻值（10KΩ，需转换成Ω）</span></span></span><br></pre></td></tr></table></figure>
<p>电压转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * 【函数】：ADC_RESULTDATA AdcVoltage(ADCDATA);</span></span><br><span class="line"><span class="comment"> * 【参数】：1. 瞬时读取的ADC寄存器的值 regData</span></span><br><span class="line"><span class="comment"> * 【说明】：将ADC寄存器结果的值转换为对应量程电压的处理程序</span></span><br><span class="line"><span class="comment"> * 【其他】：对应的12bit量程、参考电压和偏差值可以在本文件前方的宏定义处修改</span></span><br><span class="line"><span class="comment"> * 【参考】：</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------------- */</span></span><br><span class="line"><span class="function">ADC_RESULTDATA <span class="title">AdcVoltage</span><span class="params">(ADCDATA regData)</span></span>&#123;</span><br><span class="line">    ADCDATA tempData = <span class="number">0</span>;    <span class="comment">//初始化中转变量 tempData</span></span><br><span class="line"></span><br><span class="line">    tempData = regData + ADCDATA_OFFSET ;  <span class="comment">//修正某个模拟端口的偏差值，偏差值可以人为修改（假设测试设备输出电压经过计量）</span></span><br><span class="line">    <span class="keyword">if</span>(tempData &lt;= <span class="number">0</span>) tempData = <span class="number">0</span>;   <span class="comment">//超量程偏差修正</span></span><br><span class="line">    <span class="keyword">if</span>(tempData &gt;=ADC_RANGE) tempData = ADC_RANGE;   <span class="comment">//超量程偏差修正</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">float</span>)tempData / ADC_RANGE * VOLTAGE_RANGE);   <span class="comment">//转换成电压值，返回浮点数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>阻值转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * 【函数】：ADC_RESULTDATA AdcTemperature(ADCDATA);</span></span><br><span class="line"><span class="comment"> * 【参数】：1. 瞬时读取的ADC寄存器的值 regData</span></span><br><span class="line"><span class="comment"> * 【说明】：将ADC寄存器结果的值转换为对应量程温度的处理程序</span></span><br><span class="line"><span class="comment"> * 【其他】：函数中使用到的T1、RT1、BCONST等参数均可以在本文件前方的宏定</span></span><br><span class="line"><span class="comment"> *         义处找到</span></span><br><span class="line"><span class="comment"> * 【参考】：《F280041PM开发文档》下的温度传感</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------------- */</span></span><br><span class="line"><span class="function">ADC_RESULTDATA <span class="title">AdcTemperature</span><span class="params">(ADCDATA regData)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( (THM_BCONST * THM_T1)  /  (THM_T1 * <span class="built_in">log</span>( AdcResistance(regData)  /THM_RT1 )  + THM_BCONST) ) - THM_ABSTEMP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>温度转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * 【函数】：ADC_RESULTDATA AdcTemperature(ADCDATA);</span></span><br><span class="line"><span class="comment"> * 【参数】：1. 瞬时读取的ADC寄存器的值 regData</span></span><br><span class="line"><span class="comment"> * 【说明】：将ADC寄存器结果的值转换为对应量程温度的处理程序</span></span><br><span class="line"><span class="comment"> * 【其他】：函数中使用到的T1、RT1、BCONST等参数均可以在本文件前方的宏定</span></span><br><span class="line"><span class="comment"> *         义处找到</span></span><br><span class="line"><span class="comment"> * 【参考】：《F280041PM开发文档》下的温度传感</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------------- */</span></span><br><span class="line"><span class="function">ADC_RESULTDATA <span class="title">AdcTemperature</span><span class="params">(ADCDATA regData)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( (THM_BCONST * THM_T1)  /  (THM_T1 * <span class="built_in">log</span>( AdcResistance(regData)  /THM_RT1 )  + THM_BCONST) ) - THM_ABSTEMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="谐振检测开发">谐振检测开发</h1>
<p><strong>开发目标</strong>：实现对 <strong>PWM边沿</strong> 和 <strong>IGBT分压电流过零点</strong> 的相位时间差 <em>δt</em> 的检测，已达到是否达到谐振。</p>
<h2 id="工作流程-2">工作流程</h2>
<pre class="mermaid">graph TB
系统初始化 --> 使能ECAP模块时钟</pre>
<h1 id="项目flash烧录">项目FLASH烧录</h1>
<p>项目Flash烧录即将代码从Debug模式变成Release模式，将代码的存放区域从RAM变成FLASH。需要在项目属性中修改原有的Release配置，或者复制原有的调试模式进行部分修改。</p>
<p>在前方已经调试好项目的情况下，FLASH模式较调试时使用DEBUG模式需要增加以下内容或步骤：</p>
<ul>
<li>FLASH需要添加指定的标志（Symbol）</li>
<li>FLASH需要更换指定的 <code>.cmd</code> 内存文件</li>
<li>FLASH需要添加指定的命令行模式（Command-Line pattern）</li>
</ul>
<h2 id="新增配置">新增配置</h2>
<ol type="1">
<li>点击 <strong>项目属性</strong>（Properties），选择 <strong>编译器</strong>（C2000 Compiler），选择 <strong>管理配置</strong>（Manage Configurations）</li>
</ol>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210830113307673.png" alt="image-20210830113307673" /><figcaption aria-hidden="true">image-20210830113307673</figcaption>
</figure>
<ol start="2" type="1">
<li>选择 <strong>新建</strong>（New），然后在配置页面下填写新建的配置信息，选择需要基于哪个现有的配置项进行改动。在原有的调试模式上进行更改即可，这样头文件包含路径那些的就不用替换。</li>
</ol>
<div style="text-align: center;">
<p><img src="https://pic.islet.space/2021/08/image-20210830113400752.png" alt="image-20210830113400752" style="zoom:100%;" /> <img src="https://pic.islet.space/2021/08/image-20210830113441976.png" alt="image-20210830113441976" style="zoom:100%;" />&lt;/</p>
<ol start="3" type="1">
<li>将新建的配置项设置为 <strong>活跃</strong>（Active）。</li>
</ol>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210830113559386.png" alt="image-20210830113559386" /><figcaption aria-hidden="true">image-20210830113559386</figcaption>
</figure>
<h2 id="增加标志">增加标志</h2>
<p>向 <strong>预定义标志</strong>（Predefined Symbols）添加两个标志名称： <code>CPU1</code> 和 <code>_FLASH</code> 。</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210830113650241.png" alt="image-20210830113650241" /><figcaption aria-hidden="true">image-20210830113650241</figcaption>
</figure>
<p>添加成功时可以看到对应标志下的预编译被打开了，如下示：</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210830113803514.png" alt="image-20210830113803514" /><figcaption aria-hidden="true">image-20210830113803514</figcaption>
</figure>
<h2 id="增加命令行模式">增加命令行模式</h2>
<p>选择 <strong>编译器</strong>（C2000 Compiler），并在下方添加<code>$&#123;output_flags&#125; $&#123;output&#125;</code>，修改过后则变成了 <code>$&#123;command&#125; $&#123;flags&#125; $&#123;output_flags&#125; $&#123;output&#125; $&#123;inputs&#125;</code> 。如果只需要使用到调试模式（debug mode），就只需要原来的 <code>$&#123;command&#125; $&#123;flags&#125; $&#123;inputs&#125;</code> 即可。</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210830133549942.png" alt="image-20210830133549942" /><figcaption aria-hidden="true">image-20210830133549942</figcaption>
</figure>
<h2 id="更换内存文件">更换内存文件</h2>
<p>在 <code>D:\ti\CodeComposerStudio0930\ccs\ccs_base\c2000\include</code> 路径下查找到对应的 FLASH 内存文件，并在 <strong>通用页面</strong>（General）的 <strong>链接器命令文件</strong>（Linker command file）栏进行替换。</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210830134720224.png" alt="image-20210830134720224" /><figcaption aria-hidden="true">image-20210830134720224</figcaption>
</figure>
<h1 id="测试与优化">测试与优化</h1>
<p>硬件工作流程要求如下：</p>
<pre class="mermaid">graph LR
开机 --> id1[待机模式] --检测到工作设备--> id2[工作模式] --检测到设备离开--> id1</pre>
<h2 id="待机模式">待机模式</h2>
<p>开机后立即进入待机模式，对待机模式下的要求：</p>
<ol type="1">
<li>IGBT此时并不开启，即PWM外设暂不开启。</li>
<li>ADC外设需要时刻检测外面温度、电压和电流</li>
</ol>
<p>开机启动流程：</p>
<pre class="mermaid">graph
id1([开机启动]) --> id2[系统初始化/开启各外设时钟] --> 各外设寄存器清空并初始化 --> id3 --是--> id4([进入待机模式])</pre>
<p>待机工作流程：</p>
<pre class="mermaid">flowchart
id[定时器1启动]</pre>
<p>为了达到 <span class="math inline">\(4\mu s\)</span>​​ 的脉冲电路，需要设置<code>CMPA = 100</code> ，在 <code>TBCTR = 100</code> 且 <code>TBCTR DIRECTION = UP</code> 时</p>
<ol type="1">
<li>能通过直接关闭外设时钟来关闭外设吗？会否清除寄存器相关设置？重新启动时是否有延时？</li>
<li>读取GPIO 电平高低的状态寄存器，由其电平状态高低来确定外接硬开关是否按下，</li>
</ol>
<h3 id="工作设备检测">工作设备检测</h3>
<p>待机模式下IGBT并不工作，但仍需要对周围的设备进行检波和识别，检波方法：</p>
<ol type="1">
<li>每间隔几秒，PWM发射高电平时长为 <span class="math inline">\(4\mu s\)</span> 的脉冲；</li>
<li>由eCAP外设检测震荡过零的周期，以判断工作设备是否存在。</li>
</ol>
<p><strong>注意</strong>：过零检测时两个波形的过零允差需要在一定数值范围内，这个数值范围待测定。</p>
<p>若在工作设备检测下，检测到设备存在，则进入工作模式，否则维持待机模式，持续进行工作设备的检测。</p>
<p>已知PWM工作频率公式 和 单个ePWM波周期公式，可求得单个ePWM波的周期最大为： <span class="math display">\[
T_{ePWM\ Max} = (TBPRD_{MAX} +1) · T_{TBCLK} = (65535*2+1) · 0.00000002 = 2.6214 ms \tag{单ePWM最大周期计算}
\]</span> 已知： <span class="math display">\[
T_{TBCLK}={1s \over 50MHz} = {1 \over 50,000,000} = 2^{-8}s = 20ns\tag{系统时钟周期}
\]</span> 时间单位： <span class="math display">\[
1s = 10^{3}ms = 10^{6}\mu s=10^9ns \tag{时间单位}
\]</span> 反过来，如果已知高电平工作时长，需要求其CMP值，也可以代入 <span class="math inline">\(T_{TBCLK}\)</span>​​ ，求得上下边的 <strong>CMP</strong> 值应为100 <span class="math display">\[
CMP = T_{HighLevel} / (T_{TBCLK} *2) = 4*10^{-6}s/(2*2*10^{-8}s) = 100
\tag{已知高电平时长求CMP值}
\]</span></p>
<h2 id="工作模式">工作模式</h2>
<p>进入工作模式后，按照预设好的多个工作条件（PWM工作频率、占空比）进行（手动/自动）切换，以调节设备工作功率。</p>
<p><strong>注意</strong>：不论如何，占空比一定不能超过 50%。</p>
<h1 id="rs485通信开发">RS485通信开发</h1>
<p>编码工作由F280041芯片的SCI外设负责，需要在对应的代码中设置好一些参数（数据长度、校验位、停止位等），可以使用CH340芯片的串口助手进行读写测试。</p>
<p>全部的设置工作如下：</p>
<ol type="1">
<li>对应GPIO的设置</li>
<li>SCI的FIFO设置</li>
<li>SCI传输编码格式的设置</li>
<li>使用中断或者主程序对数据进行接收和解读</li>
</ol>
<h2 id="工作流程-3">工作流程</h2>
<pre class="mermaid">graph TB
系统初始化 --> 使能SCI通信模块时钟 --> 配置LSP时钟分频 --> 配置SCI模块 --> 使用中断或主程序接收处理上位机指令</pre>
<h3 id="sci配置流程">SCI配置流程</h3>
<pre class="mermaid">graph LR
配置SCIFIFO模块 --> 初始化SCI相关寄存器 --> 配置SCI相关寄存器</pre>
<p>配置SCI相关寄存器需要设置到以下几个参数位：</p>
<ul>
<li>单次通信传递字符数量 <code>SCICHAR</code></li>
<li>通信模式 <code>ADDRIDLE_MODE</code></li>
<li>数据校验位信息（校验使能 <code>PARITYENA</code> 、校验方式 <code>PARITY</code> ）</li>
<li>停止位信息 <code>STOPBITS</code></li>
<li>通信使能 （ 发送端使能 <code>TXENA</code>、接收端使能 <code>RXENA</code>）</li>
<li>睡眠模式 <code>SLEEP</code></li>
<li>中断使能（接收错误中断使能 <code>RXERRINTENA</code> 、接收brk中断使能 <code>RXBKINTENA</code> 、传输中断使能 <code>TXINTENA</code>）</li>
<li>波特率 <code>SCIHBAUD</code> 和 <code>SCILBAUD</code></li>
</ul>
<h2 id="pc-usb-ttl-f280041">PC-USB-TTL-F280041</h2>
<p>PC端使用CH340芯片的USB-TTL 转换器与芯片主板的 <code>RX</code> 口 和 <code>TX</code> 口直接通信，通信期间，PC端需要和发送端保持相同的设置，包括波特率、停止位大小、数据位、奇偶校验是否开启（开启的话为奇校验还是偶校验）等均需要保持一致。如下所示，左侧为上位机设置，右侧为SCI通信的设置。</p>
<p><mark style="font-weight: 900;">注意：测试设备端口上的 <code>RX</code> <code>TX</code> 端口要和 <code>TX</code> <code>RX</code> 相反连接，且需要共地。</mark></p>
<div style="text-align: center;">
<img src="https://pic.islet.space/2021/09/image-20210914111856207.png" alt="image-20210914111856207" style="zoom:120%;" /><img src="https://pic.islet.space/2021/09/image-20210914132833272.png" alt="image-20210914132833272" style="zoom:80%;" />
</div>
<p>下图为SCI_ECHOBACK功能效果演示：</p>
<figure>
<img src="https://pic.islet.space/2021/09/image-20210914132731428.png" alt="image-20210914132731428" /><figcaption aria-hidden="true">image-20210914132731428</figcaption>
</figure>
<p>如下所示，校验位设置错误时，数据乱码。</p>
<figure>
<img src="https://pic.islet.space/2021/09/image-20210914133403477.png" alt="image-20210914133403477" /><figcaption aria-hidden="true">image-20210914133403477</figcaption>
</figure>
<h2 id="pc-rs232-rs485-ttl-f280041">PC-RS232-RS485-TTL-F280041</h2>
<p>商用台式电脑主机主板背部自带DB9接口（RS232），使用RS232转RS485的转换器进行连接，然后使用双绞线连接被控设备对应的接口。需要注意的是，转换器上的RS485电路不具备供电接口， <code>VCC</code> / <code>GND</code> 同样需要进行连接，且需要由电气的隔离电路提供。</p>
<p>转换器与被控设备的引脚连接方式为：<code>T/R-</code> 连接 <code>IC_COM_MAX487EEPPA</code> 芯片上的 <code>B</code> 口；<code>T/R+</code> 连接 <code>IC_COM_MAX487EEPPA</code> 芯片上的 <code>A</code> 口；其中 <code>A</code> / <code>B</code> 口更多地被称为 <code>A+</code> / <code>B-</code> 口。</p>
<p>连接成功后，使用串口通信助手进行测试，并查看寄存器结果，看出数据传输成功。</p>
<figure>
<img src="https://pic.islet.space/2021/09/20210915170027.png" alt="image-20210915165949131" /><figcaption aria-hidden="true">image-20210915165949131</figcaption>
</figure>
<p>使用RS485的优势是，RS232/RS485转换器间存在电气隔离，RS485和TTL之间也存在电气隔离，一旦被控设备发生浪涌，不会损坏PC机。</p>
<h2 id="通信控制">通信控制</h2>
<p>通信控制相关流程如下：</p>
<pre class="mermaid">graph 
id1[等待上位机数据] --> 收到通信数据 --> id2{判断FLAG对应的位是否使能} --是--> 修改对应的数据 --> 结束
id2 --否--> id1</pre>
<p>传输时，需要注意对应的数据是否为 <code>16bit</code> 或 <code>8bit</code> ，如PWM周期值为 <code>16bit</code> 寄存器，而传输过程需要使用 <code>8bit</code> 的 <code>unsigned char</code> 字符进行传输，则需要下位机对收到的字符进行位移和按位或运算。</p>
<p><strong>通信格式约定如下</strong>：</p>
<ol type="1">
<li>第一个字符，即 <code>char0</code> 是 标志位之用 <code>flag</code>，将字符转换成二进制即为对应数据的修改使能控制，所有对数据的修改首先要求标志位（flag）对应位为1时才激活，如下表所示；</li>
<li>后续每两个或一个的char数据需要合成为对应的 <code>unit16_t</code> 数据；</li>
<li>通信传输时，需要使用16进制数据进行发送；</li>
<li>修改时会暂时关断PWM外设，修改完毕再开启。</li>
</ol>
<div style="font-weight: 900; font-size: 0.8rem; text-align: center;">
表 通信协议中第0个字符的位说明
</div>
<figure>
<img src="https://pic.islet.space/2021/09/20210924170147.png" alt="image-20210923143745959" /><figcaption aria-hidden="true">image-20210923143745959</figcaption>
</figure>
<div style="font-weight: 900; font-size: 0.8rem; text-align: center;">
表 通信协议各字符说明
</div>
<figure>
<img src="https://pic.islet.space/2021/09/20210924170150.png" alt="image-20210923143648999" /><figcaption aria-hidden="true">image-20210923143648999</figcaption>
</figure>
<p>8位数据合成为16位数据函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * 【函数】：uint16_t uchar2ushort(unsigned char, unsigned char);</span></span><br><span class="line"><span class="comment"> * 【参数】：1. 高8位数据 high8bit</span></span><br><span class="line"><span class="comment"> *         2. 低8位数据 low8bit</span></span><br><span class="line"><span class="comment"> * 【说明】：将两个非负整形8bit数拼成非负整形16bit数</span></span><br><span class="line"><span class="comment"> * 【其他】：</span></span><br><span class="line"><span class="comment"> * 【参考】：</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">uchar2ushort</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> high8bit, <span class="keyword">unsigned</span> <span class="keyword">char</span> low8bit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( (high8bit &lt;&lt; <span class="number">8</span>) | low8bit);  <span class="comment">//先左移8位然后进行按位或运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通信调试参数计算方法">通信调试参数计算方法</h2>
<ol type="1">
<li>死区时间计算</li>
</ol>
<p>从《TRM》P1814 中可知，（上升沿或下降沿的）死区时间大小都其自身的 <strong>寄存器设定值</strong>，以及 <span class="math inline">\(T_{TBCLK}\)</span> 有关，关系公式如下： <span class="math display">\[
\notag
FED = DBFED · T_{TBCLK}\\
RED = DBRED · T_{TBCLK}
\]</span></p>
<ol start="2" type="1">
<li>TBPRD寄存器值计算</li>
</ol>
<p>如果要改变 <span class="math inline">\(f_{EPWM}\)</span> 的值，则需要改变 <strong>TBPRD</strong> 的值，因为 <span class="math inline">\(T_{TBCLK}\)</span> 的值暂时不支持改变（因为涉及到两三个参数，太麻烦了，不想写代码），因此 <strong>TBPRD</strong> 和 <span class="math inline">\(f_{EPWM}\)</span> 的关系为： <span class="math display">\[ {align*}
TBPRD&amp;=&amp;\frac{1}{2}(\frac{T_{EPWM}}{T_{TBCLK}}-1)\\ 
&amp;=&amp;\frac{1}{2}(\frac{1}{T_{TBCLK}·F_{EPWM}}-1) \nonumber
\]</span></p>
<blockquote>
<p>所有计算单位都是 <code>Hz</code> 和 <code>s</code> z。</p>
<p>因为 <code>HSPCLKDIV=0x00, CLKDIV=0x01</code>，，<span class="math inline">\(F_{TBCLK} = F_{SYSCLK} /2 = 50MHz\)</span> ，得 <span class="math inline">\(T_{TBCLK} = 2*10^{-8}s\)</span> 。</p>
<p><span class="math inline">\(T_{EPWM} = 3.33*10^{-5}s\)</span> 时，其 <span class="math inline">\(TBPRD = 1/2 · (3.33*10^{-5} / 2*10^{-8} -1) = 832\)</span></p>
<p>当已知需要设置 epwm的目标频率为 <code>30Khz</code> 时，只需要代入公式即可： <span class="math display">\[
\notag
TBPRD = 1/2 * (\frac{1}{2e-8*3e4} -1)
\]</span></p>
</blockquote>
<ol start="3" type="1">
<li>占空比计算</li>
</ol>
<p><mark style="font-weight: 900;">占空比，实际上就是EPWM 在整个周期内部，高电平时长与周期长度的比值。</mark></p>
<p>占空比如果通过寄存器值来进行表达和设置，会出现误差，因为死区时间的寄存器值工作逻辑和原先设置的ePWM工作逻辑存在差异，存在错误的占空比关系公式： <span class="math display">\[
Duty \ Cycle &amp;=&amp; \frac{(TBPRD-CMP)·2-DB·2}{TBPRD·2}\\
&amp;=&amp; \frac{(TBPRD-CMP)-DB}{TBPRD}
\nonumber
\]</span></p>
<p>正确的方法就是去计算高电平的时长，然后除以整个任务周期时长： <span class="math display">\[
Duty \ Cycle = \frac {T_{High \ Level}}{T_{EPWM}}
\notag
\]</span> 在C++编写的RS485指令的代码中，则通过人为设定占空比来反向计算高电平时长。</p>
<p>在已知 死区时间 <strong>DBxED</strong> 寄存器数值、 <strong>TBPRD</strong> 周期寄存器数值 和 任务占空比 三个参数的情况下，目前使用的计算 CMP数值的算法如下： <span class="math display">\[
CMP = (1- Duty)·(TBPRD-DB)
\tag{CMP-A1}
\]</span></p>
<h2 id="通信调试数据">通信调试数据</h2>
<p>在使用上方 CMP-A1 算法公式的情况下，输入目标频率、死区时间 和 所要求的占空比大小，以获得RS485通信指令，如下：</p>
<figure>
<img src="https://pic.islet.space/2021/10/20211011172645.png" alt="image-20211009103727624" /><figcaption aria-hidden="true">image-20211009103727624</figcaption>
</figure>
<p>通信数据收到无误后会返回确认和执行字样：</p>
<figure>
<img src="https://pic.islet.space/2021/10/20211011172650.png" alt="image-20211009103755175" /><figcaption aria-hidden="true">image-20211009103755175</figcaption>
</figure>
<p>测试结果：</p>
<p><code>30 50 2.4</code></p>
<p><code>AB1F034001640164007700770050</code></p>
<figure>
<img src="https://pic.islet.space/2021/10/20211011172638.png" alt="image-20211009102908175" /><figcaption aria-hidden="true">image-20211009102908175</figcaption>
</figure>
<p><code>30 50 1.0</code></p>
<p><code>AB1F034001870187003200320050</code></p>
<figure>
<img src="https://pic.islet.space/2021/10/20211011172636.png" alt="image-20211009103114948" /><figcaption aria-hidden="true">image-20211009103114948</figcaption>
</figure>
<p><code>30 45 1.0</code></p>
<p><code>AB1F034001AE01AE003200320050</code></p>
<figure>
<img src="https://pic.islet.space/2021/10/20211011172634.png" alt="image-20211009103933753" /><figcaption aria-hidden="true">image-20211009103933753</figcaption>
</figure>
<p><code>30 45 2.4</code></p>
<p><code>AB1F034001880188007700770050</code></p>
<figure>
<img src="https://pic.islet.space/2021/10/20211011172632.png" alt="image-20211009104103063" /><figcaption aria-hidden="true">image-20211009104103063</figcaption>
</figure>
<p>开机默认波形如下：</p>
<p><code>30 30 5</code></p>
<p><code>AB1F03400198019800F900F90050</code></p>
<figure>
<img src="https://pic.islet.space/2021/10/20211011172628.png" alt="image-20211009110443081" /><figcaption aria-hidden="true">image-20211009110443081</figcaption>
</figure>
<h3 id="年10月11日更新信息">2021年10月11日更新信息</h3>
<p>经过了三天的努力，终于在10月11日完成了基于C++的 terminal串口通信。哈哈哈哈哈，可以成功实现通信啦~~</p>
<p>只要先在程序内选择指定接口，然后输入 <strong>目标工作频率</strong>、（下桥臂）<strong>任务占空比</strong> 和 （上桥臂）<strong>死区时间</strong> 就可以计算出指令并进行发送。</p>
<figure>
<img src="https://pic.islet.space/2021/10/20211011172910.png" alt="image-20211011172325394" /><figcaption aria-hidden="true">image-20211011172325394</figcaption>
</figure>
<p>可以从逻辑分析仪获得较为粗糙的波形信息，如下：</p>
<figure>
<img src="https://pic.islet.space/2021/10/20211011172557.png" alt="image-20211011172548527" /><figcaption aria-hidden="true">image-20211011172548527</figcaption>
</figure>
<h3 id="年10月13日更新信息">2021年10月13日更新信息</h3>
<p>之前输入任务占空比的时候，都是控制的EPWMB的任务占空比，每次输入 40%的任务占空比（死区时间为0）时，EPWMA的任务占空比都为 60%。再加上死区时间实际上是在已知EPWMB任务占空比的情况下去减小EPWMA的占空比的时间。经过简单的修改，可以实现输入目标任务占空比，可以实时控制EPWMA的实际占空比了，死区时间只对EPWMB有影响。</p>
<figure>
<img src="https://pic.islet.space/2021/10/20211013172224.png" alt="image-20211013163229517" /><figcaption aria-hidden="true">image-20211013163229517</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/10/20211013172222.png" alt="image-20211013163247274" /><figcaption aria-hidden="true">image-20211013163247274</figcaption>
</figure>
<h1 id="常见错误处理">常见错误处理</h1>
<h2 id="memory-range-has-already-been-specified">#10263 MEMORY RANGE HAS ALREADY BEEN SPECIFIED</h2>
<p><strong>错误提示</strong>：存储区域范围（Memory Range）重复声明。</p>
<p><strong>解释</strong>：在两个 <code>.cmd</code> 文件中，对 memory 的 page0 下的存储范围重复声明。</p>
<div style="text-align: center;">
<img src="https://pic.islet.space/2021/07/image-20210720171745641.png" alt="image-20210720171745641" style="zoom:80%;" /> <img src="https://pic.islet.space/2021/07/image-20210720171759718.png" alt="image-20210720171759718" style="zoom:80%;" />
</div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;..&#x2F;28004x_RAM_afe031_lnk.cmd&quot;, line 7: error #10263: BEGIN memory range has already been specified</span><br><span class="line">&quot;..&#x2F;28004x_RAM_afe031_lnk.cmd&quot;, line 7: error #10264: BEGIN memory range overlaps existing memory range BEGIN</span><br><span class="line">&quot;..&#x2F;28004x_RAM_afe031_lnk.cmd&quot;, line 8: error #10263: RAMM0 memory range has already been specified</span><br><span class="line">&quot;..&#x2F;28004x_RAM_afe031_lnk.cmd&quot;, line 8: error #10264: RAMM0 memory range overlaps existing memory range RAMM0</span><br><span class="line">&quot;..&#x2F;28004x_RAM_afe031_lnk.cmd&quot;, line 9: error #10263: RAMLS0 memory range has already been specified</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p><strong>解决办法</strong>：删除、移动 <code>28004x_RAM_afe031_lnk.cmd</code> ，或更改其后缀名；确保在 <em>项目属性</em>（Properties）中的 <strong>连接器命令文件</strong>（Linker Command File）为正确的 <code>280041_RAM_lnk.cmd</code> 。</p>
<p><img src="https://pic.islet.space/2021/07/image-20210720172450100.png" alt="image-20210720172450100" style="zoom:80%;" /></p>
<p><img src="https://pic.islet.space/2021/07/image-20210720172242634.png" alt="image-20210720172242634" style="zoom:80%;" /></p>
<h2 id="cannot-open-source-file">#1965 CANNOT OPEN SOURCE FILE</h2>
<p>无法找到指定头文件，报错如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:&#x2F;ti&#x2F;c2000Ware&#x2F;C2000Ware_2_01_00_00&#x2F;device_support&#x2F;f28004x&#x2F;common&#x2F;include&#x2F;F28x_Project.h&quot;, line 47: fatal error #1965: cannot open source file &quot;f28004x_device.h&quot;</span><br></pre></td></tr></table></figure>
<p>可以借助本地搜索工具everything进行文件搜索，将缺失的头文件的绝对路径复制，并粘贴至 头文件设置 下的搜索路径中。上方的错误缺失 <code>f28004x_device.h</code> ，添加 <code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\device_support\f28004x\headers\include</code> 绝对路径以供搜索，即可解决。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210721104533304.png" alt="image-20210721104533304" /><figcaption aria-hidden="true">image-20210721104533304</figcaption>
</figure>
<h2 id="d-unresolved-symbols-remain">#10234-D UNRESOLVED SYMBOLS REMAIN</h2>
<p>在将函数需要的头文件添加到项目后，进行 <em>build project</em> ，出现 “未能解决的标志存留” ，有2种可能原因：</p>
<ol type="1">
<li>输出格式（Output Format）不正确。</li>
<li>头文件缺少对应的 <code>.c</code> 文件。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> undefined        first referenced   </span><br><span class="line">  symbol              <span class="keyword">in</span> file        </span><br><span class="line"> ---------        ----------------   </span><br><span class="line"> _ClkCfgRegs      ./SystemControl.obj</span><br><span class="line"> _CpuSysRegs      ./SystemControl.obj</span><br><span class="line"> _Dcc0Regs        ./SystemControl.obj</span><br><span class="line"> _DcsmBank0Z1Regs ./SystemControl.obj</span><br><span class="line"> _DcsmBank0Z2Regs ./SystemControl.obj</span><br><span class="line"> _F28x_usDelay    ./SystemControl.obj</span><br><span class="line"> _Flash0CtrlRegs  ./SystemControl.obj</span><br><span class="line"> _Flash0EccRegs   ./SystemControl.obj</span><br><span class="line"> _WdRegs          ./SystemControl.obj</span><br><span class="line"> </span><br><span class="line">error <span class="comment">#10234-D: unresolved symbols remain</span></span><br><span class="line">error <span class="comment">#10010: errors encountered during linking; &quot;F28004x_WPT.out&quot; not built</span></span><br><span class="line"> </span><br><span class="line">&gt;&gt; Compilation failure</span><br><span class="line">makefile:143: recipe <span class="keyword">for</span> target <span class="string">&#x27;F28004x_WPT.out&#x27;</span> failed</span><br><span class="line">makefile:139: recipe <span class="keyword">for</span> target <span class="string">&#x27;all&#x27;</span> failed</span><br><span class="line">gmake[1]: *** [F28004x_WPT.out] Error 1</span><br><span class="line">gmake: *** [all] Error 2</span><br><span class="line"></span><br><span class="line">**** Build Finished ****</span><br></pre></td></tr></table></figure>
<p><strong>解决方法</strong>：</p>
<p>排除第一种情况后，找到 未定义符号（undefined symbol）对应的头文件 <code>f28004x_device.h</code> 和 <code>f28004x_sysctrl.h</code> 所在的文件路径 <code>D:\ti\c2000Ware\C2000Ware_2_01_00_00\device_support\f28004x\headers\include</code> ，注意到该头文件上一级有个 <code>source</code> 文件夹，存储着头文件对应的 <code>.c</code> 文件： <code>f28004x_globalvariabledefs.c</code> ，将该头文件以链接或复制的形式添加到项目文件中即可。</p>
<p><strong>注意</strong>：大部分情况下，header files 都会有其对应的 <code>.c</code> 或 <code>.asm</code> 文件，需要去相同的目录下方寻找即可。</p>
<div style="text-align: center;">
<img src="https://pic.islet.space/2021/07/image-20210727092820296.png" alt="image-20210727092820296" style="zoom:100%;" /><img src="https://pic.islet.space/2021/07/image-20210727094440528.png" alt="image-20210727094440528" style="zoom:100%;" />
</div>
<h2 id="sc_err_path_broken">SC_ERR_PATH_BROKEN</h2>
<p>在将评估板接到PC过程中，进行连接测试（Test Connection），报错如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">-----[Print the reset-command software log-file]-----------------------------</span><br><span class="line"></span><br><span class="line">This utility has selected a 100- or 510-class product.</span><br><span class="line">This utility will load the adapter <span class="string">&#x27;jioxds110.dll&#x27;</span>.</span><br><span class="line">The library build date was <span class="string">&#x27;Nov 25 2019&#x27;</span>.</span><br><span class="line">The library build time was <span class="string">&#x27;16:55:29&#x27;</span>.</span><br><span class="line">The library package version is <span class="string">&#x27;8.4.0.00006&#x27;</span>.</span><br><span class="line">The library component version is <span class="string">&#x27;35.35.0.0&#x27;</span>.</span><br><span class="line">The controller does not use a programmable FPGA.</span><br><span class="line">The controller has a version number of <span class="string">&#x27;5&#x27;</span> (0x00000005).</span><br><span class="line">The controller has an insertion length of <span class="string">&#x27;0&#x27;</span> (0x00000000).</span><br><span class="line">This utility will attempt to reset the controller.</span><br><span class="line">This utility has successfully reset the controller.</span><br><span class="line"></span><br><span class="line">-----[Print the reset-command hardware log-file]-----------------------------</span><br><span class="line"></span><br><span class="line">The scan-path will be reset by toggling the JTAG TRST signal.</span><br><span class="line">The controller is the XDS110 with USB interface.</span><br><span class="line">The link from controller to target is direct (without cable).</span><br><span class="line">The software is configured <span class="keyword">for</span> XDS110 features.</span><br><span class="line">The controller cannot monitor the value on the EMU[0] pin.</span><br><span class="line">The controller cannot monitor the value on the EMU[1] pin.</span><br><span class="line">The controller cannot control the timing on output pins.</span><br><span class="line">The controller cannot control the timing on input pins.</span><br><span class="line">The scan-path link-delay has been <span class="built_in">set</span> to exactly <span class="string">&#x27;0&#x27;</span> (0x0000).</span><br><span class="line"></span><br><span class="line">-----[An error has occurred and this utility has aborted]--------------------</span><br><span class="line"></span><br><span class="line">This error is generated by TI<span class="string">&#x27;s USCIF driver or utilities.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The value is &#x27;</span>-233<span class="string">&#x27; (0xffffff17).</span></span><br><span class="line"><span class="string">The title is &#x27;</span>SC_ERR_PATH_BROKEN<span class="string">&#x27;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The explanation is:</span></span><br><span class="line"><span class="string">The JTAG IR and DR scan-paths cannot circulate bits, they may be broken.</span></span><br><span class="line"><span class="string">An attempt to scan the JTAG scan-path has failed.</span></span><br><span class="line"><span class="string">The target&#x27;</span>s JTAG scan-path appears to be broken</span><br><span class="line">with a stuck-at-ones or stuck-at-zero fault.</span><br><span class="line"></span><br><span class="line">[End: Texas Instruments XDS110 USB Debug Probe_0]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为本开发板设计上使用两线制，为 <em>cJTAG</em>，而默认情况下是标准的 JTAG，只需要 TCK 和 TMS 两个信号（官方文档的常见问答部分有说明）。</p>
<p>在<code>.ccxml</code> 文件中进行修改，点击下方的 <em>Advanced</em>，然后选择 <code>cJTAG(1149.7)2-pin advance mode</code>，然后 <em>save</em> 保存即可。具体操作如下图：</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210726155434636.png" alt="image-20210726155434636" /><figcaption aria-hidden="true">image-20210726155434636</figcaption>
</figure>
<p>再次运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">-----[Print the reset-command software log-file]-----------------------------</span><br><span class="line"></span><br><span class="line">This utility has selected a 100- or 510-class product.</span><br><span class="line">This utility will load the adapter <span class="string">&#x27;jioxds110.dll&#x27;</span>.</span><br><span class="line">The library build date was <span class="string">&#x27;Nov 25 2019&#x27;</span>.</span><br><span class="line">The library build time was <span class="string">&#x27;16:55:29&#x27;</span>.</span><br><span class="line">The library package version is <span class="string">&#x27;8.4.0.00006&#x27;</span>.</span><br><span class="line">The library component version is <span class="string">&#x27;35.35.0.0&#x27;</span>.</span><br><span class="line">The controller does not use a programmable FPGA.</span><br><span class="line">The controller has a version number of <span class="string">&#x27;5&#x27;</span> (0x00000005).</span><br><span class="line">The controller has an insertion length of <span class="string">&#x27;0&#x27;</span> (0x00000000).</span><br><span class="line">This utility will attempt to reset the controller.</span><br><span class="line">This utility has successfully reset the controller.</span><br><span class="line"></span><br><span class="line">-----[Print the reset-command hardware log-file]-----------------------------</span><br><span class="line"></span><br><span class="line">The scan-path will be reset by toggling the JTAG TRST signal.</span><br><span class="line">The controller is the XDS110 with USB interface.</span><br><span class="line">The link from controller to target is direct (without cable).</span><br><span class="line">The software is configured <span class="keyword">for</span> XDS110 features.</span><br><span class="line">The controller cannot monitor the value on the EMU[0] pin.</span><br><span class="line">The controller cannot monitor the value on the EMU[1] pin.</span><br><span class="line">The controller cannot control the timing on output pins.</span><br><span class="line">The controller cannot control the timing on input pins.</span><br><span class="line">The scan-path link-delay has been <span class="built_in">set</span> to exactly <span class="string">&#x27;0&#x27;</span> (0x0000).</span><br><span class="line"></span><br><span class="line">-----[Perform the Integrity scan-test on the JTAG IR]------------------------</span><br><span class="line"></span><br><span class="line">This <span class="built_in">test</span> will use blocks of 64 32-bit words.</span><br><span class="line">This <span class="built_in">test</span> will be applied just once.</span><br><span class="line"></span><br><span class="line">Do a <span class="built_in">test</span> using 0xFFFFFFFF.</span><br><span class="line">Scan tests: 1, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0x00000000.</span><br><span class="line">Scan tests: 2, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0xFE03E0E2.</span><br><span class="line">Scan tests: 3, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0x01FC1F1D.</span><br><span class="line">Scan tests: 4, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0x5533CCAA.</span><br><span class="line">Scan tests: 5, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0xAACC3355.</span><br><span class="line">Scan tests: 6, skipped: 0, failed: 0</span><br><span class="line">All of the values were scanned correctly.</span><br><span class="line"></span><br><span class="line">The JTAG IR Integrity scan-test has succeeded.</span><br><span class="line"></span><br><span class="line">-----[Perform the Integrity scan-test on the JTAG DR]------------------------</span><br><span class="line"></span><br><span class="line">This <span class="built_in">test</span> will use blocks of 64 32-bit words.</span><br><span class="line">This <span class="built_in">test</span> will be applied just once.</span><br><span class="line"></span><br><span class="line">Do a <span class="built_in">test</span> using 0xFFFFFFFF.</span><br><span class="line">Scan tests: 1, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0x00000000.</span><br><span class="line">Scan tests: 2, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0xFE03E0E2.</span><br><span class="line">Scan tests: 3, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0x01FC1F1D.</span><br><span class="line">Scan tests: 4, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0x5533CCAA.</span><br><span class="line">Scan tests: 5, skipped: 0, failed: 0</span><br><span class="line">Do a <span class="built_in">test</span> using 0xAACC3355.</span><br><span class="line">Scan tests: 6, skipped: 0, failed: 0</span><br><span class="line">All of the values were scanned correctly.</span><br><span class="line"></span><br><span class="line">The JTAG DR Integrity scan-test has succeeded.</span><br><span class="line"></span><br><span class="line">[End: Texas Instruments XDS110 USB Debug Probe_0]</span><br></pre></td></tr></table></figure>
<h2 id="时钟初始化错误">时钟初始化错误</h2>
<p>时钟初始化错误是可能新建文件后可能会出现的隐形错误，因为程序编译的时候不报错，只报 WARNING ，因此很难察觉。</p>
<p>但是，能通过 Expression 界面输入寄存器名称，用以观察其是否被初始化，如下图示，为自建项目后初始化的寄存器数值，只运行第一步PLL初始化，可以观察到 <code>ClkCfgRegs</code> 并未被初始化。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210730170342194.png" alt="image-20210730170342194" /><figcaption aria-hidden="true">image-20210730170342194</figcaption>
</figure>
<p>同样使用官方样例代码进行仅一步的PLL初始化操作，可以发现初始化成功。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210730170350083.png" alt="image-20210730170350083" /><figcaption aria-hidden="true">image-20210730170350083</figcaption>
</figure>
<p>仔细对比和检查后发现，自建项目中缺少了几个，通过link方式或copy方式添加进来，再到项目属性下的 Symbol Management中，为输出模块添加代码入口点 <code>code_start</code> 即可。</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210730171218213.png" alt="image-20210730171218213" /><figcaption aria-hidden="true">image-20210730171218213</figcaption>
</figure>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210730171409142.png" alt="image-20210730171409142" /><figcaption aria-hidden="true">image-20210730171409142</figcaption>
</figure>
<h2 id="target-must-be-connected">TARGET MUST BE CONNECTED</h2>
<p>使用JTAG调试器XDS100 V2连接至目标设备上时，如果出现下图所示的 “Disconnected: Unknown”，说明目标MCU/DSP没有正确识别。</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210802160213827.png" alt="image-20210802160213827" /><figcaption aria-hidden="true">image-20210802160213827</figcaption>
</figure>
<p>首先应检查JTAG是否链接正常，打开“设备管理器”进行查看，如果设备连接器中出现了该JTAG设备，则进一步查看项目文件下的<code>.cxxm</code>l文件，该文件用于配置设备连接信息，包括芯片信号、JTAG调试器信号、通信方式、通信速率等。确保所有设置都正确以后进行全面断电、断开连接、重启CCS并重新尝试Debug，如果仍旧出现问题，请按以下步骤进行操作。</p>
<p>在Debug界面，点击目标CPU，点击 <code>Connect Target</code> 进行手动连接。</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210802160242203.png" alt="image-20210802160242203" /><figcaption aria-hidden="true">image-20210802160242203</figcaption>
</figure>
<p>连接正确后，手动导入 <code>Build</code> 完之后的 <code>.out</code> 文件，将该程序手动烧写至CPU的RAM/Flash中</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210802160456548.png" alt="image-20210802160456548" /><figcaption aria-hidden="true">image-20210802160456548</figcaption>
</figure>
<p>选择对应项目下生成的 <code>.out</code> 文件：</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210802160358841.png" alt="image-20210802160358841" /><figcaption aria-hidden="true">image-20210802160358841</figcaption>
</figure>
<p>可以在Console台（界面）观察到已经写入和初始化成功：</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210802154136487.png" alt="image-20210802154136487" /><figcaption aria-hidden="true">image-20210802154136487</figcaption>
</figure>
<h2 id="invalid-combination-of-type-specifiers">#85 INVALID COMBINATION OF TYPE SPECIFIERS</h2>
<p>出现以上错误时，我正打算新建函数，但是写到一半忘了，去忙别的，回头编译就出错了。找到最近的修改痕迹，然后果然发现自己只写了一个函数数据类型的声明，其他啥都没写，将其删除即可重新编译。</p>
<h1 id="常见警告处理">常见警告处理</h1>
<h2 id="object-file-specified-but-linking-not-enabled">Object file specified, but linking not enabled</h2>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210830135156509.png" alt="image-20210830135156509" /><figcaption aria-hidden="true">image-20210830135156509</figcaption>
</figure>
<h1 id="常见优化提示">常见优化提示</h1>
<h2 id="d-performance-use---fp_moderelaxed-to-enable-tmu-hardware-support-for-fp-division">#2614-D (Performance) Use --fp_mode=relaxed to enable TMU hardware support for FP division</h2>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210817085055902.png" alt="image-20210817085055902" /><figcaption aria-hidden="true">image-20210817085055902</figcaption>
</figure>
<p>上述提示标志为 <code>i</code> ，也就是有关于性能优化的提示，可以在项目属性的编译器中，打开对应的优化开关，如下图。</p>
<figure>
<img src="https://pic.islet.space/2021/08/image-20210817085234005.png" alt="image-20210817085234005" /><figcaption aria-hidden="true">image-20210817085234005</figcaption>
</figure>
<h1 id="术语-1">术语</h1>
<p><strong>LDO</strong>: Low dropout, A DC linear voltage regulator which can operate with a very small input/output differential voltage.</p>
<p><strong>V<span style="font-size: 0.8rem;">REG</span></strong>: Voltage Regulator. 稳压器。</p>
<p><strong>V<span style="font-size: 0.8rem;">REF</span></strong>: Voltage Reference. 参考电压</p>
<p><strong>ESD</strong>: Electrostatic Discharge, 静电放电。</p>
<p><strong>标志</strong>：flag，也可以被称作 操作信号 或其他。</p>
<p><strong>LSPCLK</strong>: Low-speed peripheral clock frequency of the device， 低速外设时钟频率</p>
<p><strong>IP</strong>: Internal Peripheral，内部外设。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://www.ti.com.cn/cn/lit/gpn/tms320f280049">《TMS320F28004x 微控制器》</a></li>
<li><a href="">《F28004x_DEV_USER_GUIDE.pdf》</a></li>
<li><a href="">《SPRU566N C2000 <strong><em>Real-Time Control MCU Peripherals</em></strong> Reference Guide》</a></li>
<li><a href="">《SPRUI33D TMS320F28004x <strong><em>Real-Time Microcontrollers</em></strong> Technical Reference Manual》</a></li>
<li><a href="">《SPRUHS1C TMS320C28x <strong><em>Extended Instruction Sets</em></strong> Technical Reference Manual》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docin.com/p-505058292.html">基于IGBT的DC-AC变换器设计</a></li>
<li><a target="_blank" rel="noopener" href="http://www.henlito.com/chinese/news/10/12717.html">IGBT模块单相半桥逆变电路设计与应用</a></li>
<li><a target="_blank" rel="noopener" href="https://code.islet.space/TI/f28004x/index.html">Texas Instruments F28004x Peripheral Driver Library</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Simon_cici/article/details/84951920">280049LaunchPad仿真器连接不上的问题解决办法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/dog_second/article/details/108382419">DSP 28335 编译过程中的#10234-D、#10010报错</a></li>
<li>《MCU025A(001)_BOM.xls》</li>
<li>《MCU025A(001)_Sch.pdf》</li>
<li>《MCU025A_PCB_LayerPlots.pdf》</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/06/Programming/C++/2021-07-06-Linux%E4%B8%8AC++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/06/Programming/C++/2021-07-06-Linux%E4%B8%8AC++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" class="post-title-link" itemprop="url">Linux上C++多线程报错解决办法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-07-06 01:01:51 / Modified: 01:16:47" itemprop="dateCreated datePublished" datetime="2021-07-06T01:01:51+08:00">2021-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="pthread报错">pthread报错</h1>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namespce std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello concurent world!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(hello)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个小例子直接用make编译是无法通过的。报错如下： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/tmp/ccYB66pt.o：在函数‘std::thread::thread&lt;void (&amp;)()&gt;(void (&amp;)())’中：</span><br><span class="line">1-1.cpp:(.text._ZNSt6threadC2IRFvvEJEEEOT_DpOT0_[_ZNSt6threadC5IRFvvEJEEEOT_DpOT0_]+0x21)：对‘pthread_create’未定义的引用</span><br><span class="line">collect2: 错误：ld 返回 1</span><br><span class="line">&lt;<span class="built_in">builtin</span>&gt;: recipe <span class="keyword">for</span> target <span class="string">&#x27;1-1&#x27;</span> failed</span><br><span class="line">make: *** [1-1] Error 1</span><br></pre></td></tr></table></figure></p>
<p>解决方法是在编译的时候加上 <code>-lpthread</code> 参数。这个类用到posix实现的线程了。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -o <span class="built_in">test</span> test.cpp -lpthread</span><br><span class="line">./<span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<p>结果输出： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello concurent world!</span><br></pre></td></tr></table></figure></p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wuhui20091515/article/details/52531202">c++使用thread类时编译出错，对‘pthread_create’未定义的引用</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/05/Programming/C++/2021-07-05-%E5%9C%A8linux%E4%B8%8A%E7%BC%96%E5%86%99%E6%B1%82%E8%A7%A3ADAU1772%E7%9A%84PLL%E7%B3%BB%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/05/Programming/C++/2021-07-05-%E5%9C%A8linux%E4%B8%8A%E7%BC%96%E5%86%99%E6%B1%82%E8%A7%A3ADAU1772%E7%9A%84PLL%E7%B3%BB%E6%95%B0/" class="post-title-link" itemprop="url">在linux上编写求解ADAU1772的PLL系数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-05 20:00:00" itemprop="dateCreated datePublished" datetime="2021-07-05T20:00:00+08:00">2021-07-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-07-06 01:01:05" itemprop="dateModified" datetime="2021-07-06T01:01:05+08:00">2021-07-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>通过在Linux上编写代码，计算求解ADAU1772在 <strong>输入时钟</strong>（MCLK Input）为16.6MHz时，如何设置内部的4个参数，以达到符合输出时钟要求的目的。</p>
<p>据《ADAU1772》和SigmaStudio，1772 Codec 内部可修改的参数有 <strong>输入时钟分频</strong>（Input Clock Divider）、<strong>整数设置</strong>（Integer Setting）、<strong>分子</strong>（Numerator） 和 <strong>分母</strong>（Denominator）四个。</p>
<p><strong>目标输出时钟</strong>（VCO Output） 是 24.576MHz。</p>
<h1 id="原公式">原公式</h1>
<p>以下为《ADAU1772》第30页中，关于PLL计算的公式描述：</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210706002255187.png" alt="image-20210706002255187" /><figcaption aria-hidden="true">image-20210706002255187</figcaption>
</figure>
<p>以下为SigmaStudio中的PLL设定界面参数设定：</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210706002412136.png" alt="image-20210706002412136" /><figcaption aria-hidden="true">image-20210706002412136</figcaption>
</figure>
<h1 id="代码编写">代码编写</h1>
<p>注意：本代码在Linux上，以C++17的版本进行编译运行。</p>
<p>编译代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -std=c++17 -lpthread</span><br></pre></td></tr></table></figure>
<p>在编写代码时，考虑到SigmaStudio和数据手册之间可能存在表述差异，因此计算PLL的源代码中，也包含了开启 <code>1/2</code> 系数的宏定义 <code>#define HALFCOFF 1</code> ，具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * HEADER FILES</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * MACRO DEFINITION</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACCURACY 1000000000   <span class="comment">//输出时钟精度，小数点后9个0</span></span></span><br><span class="line"><span class="comment">// #define HALFCOFF 1            //打开1/2系数进行计算，SigmaStudio图示中有该系数，但《ADAU1772》数据手册中没有该系数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * MACRO DEFINITION FOR DEBUG</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">// #define DEBUG_MODE         //Debug模式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * DATA TYPES</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> CLK;           <span class="comment">//数据类型_时钟</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> COFF;  <span class="comment">//数据类型_系数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * FILE DOMAIN DATA DECLARATION</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line">CLK CLK_IN = <span class="number">16.6</span>;            <span class="comment">//输入时钟</span></span><br><span class="line">CLK CLK_OUT = <span class="number">24.576</span>;         <span class="comment">//输出时钟</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TargetCofficient</span> &#123;</span></span><br><span class="line">    COFF Numerator;</span><br><span class="line">    COFF Denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">COFF Maxiator = <span class="number">65535</span>;</span><br><span class="line">COFF InputClockDivider = <span class="number">4</span>;</span><br><span class="line">COFF IntegerSetting = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * FUNCTIONS DECLARATION</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isSafe</span><span class="params">(COFF, COFF)</span></span>;      <span class="comment">//判断系数的分子和分母相除是否满足要求</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isOK</span><span class="params">(CLK)</span></span>;               <span class="comment">//判断输出结果是否符合输出时钟的精度要求</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CofficientCalculate</span><span class="params">(CLK, COFF, COFF)</span></span>;         <span class="comment">//计算</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD1</span><span class="params">(<span class="keyword">void</span>)</span></span>;             <span class="comment">//子线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD2</span><span class="params">(<span class="keyword">void</span>)</span></span>;             <span class="comment">//子线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD3</span><span class="params">(<span class="keyword">void</span>)</span></span>;             <span class="comment">//子线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD4</span><span class="params">(<span class="keyword">void</span>)</span></span>;             <span class="comment">//子线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysPrintf</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * MAIN FUNCTIONS</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;SYSTEM: Procedure starts.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">thread1</span><span class="params">(ICD1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread2</span><span class="params">(ICD2)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread3</span><span class="params">(ICD3)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread4</span><span class="params">(ICD4)</span></span>;</span><br><span class="line"></span><br><span class="line">    thread1.<span class="built_in">join</span>();</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">    thread3.<span class="built_in">join</span>();</span><br><span class="line">    thread4.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;SYSTEM: Procedure ends up.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * FUNCTIONS DEFINITION</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isSafe</span><span class="params">(COFF N, COFF D)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = (<span class="keyword">double</span>)N / (<span class="keyword">double</span>)D;</span><br><span class="line">    <span class="keyword">if</span>( (result &gt;= <span class="number">0.1</span>) &amp;&amp; (result &lt;= <span class="number">0.9</span>) ) <span class="keyword">return</span> <span class="number">1</span>;       <span class="comment">//判断系数是否满足要求，满足则返回1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isOK</span><span class="params">(CLK clock)</span></span>&#123;</span><br><span class="line">    CLK integerClock , fractClock;</span><br><span class="line">    fractClock = <span class="built_in">modf</span>(clock , &amp;integerClock);                <span class="comment">//分别取出整数和小数部分</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( ((<span class="keyword">int</span>)(fractClock * ACCURACY) == (<span class="keyword">int</span>)(<span class="number">576</span>/(<span class="keyword">double</span>)<span class="number">1000</span> * ACCURACY)) &amp;&amp; ((<span class="keyword">int</span>)integerClock == (<span class="keyword">int</span>)CLK_OUT) ) &#123;  <span class="comment">//如果小数点精度满足要求，且整数部分相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                                           <span class="comment">//则返回1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CofficientCalculate</span><span class="params">(CLK ClockInput, COFF ICD, COFF IS)</span></span>&#123;</span><br><span class="line">    CLK tempCLK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(COFF i = <span class="number">0</span>; i &lt; Maxiator; i++)&#123;                     <span class="comment">//分母</span></span><br><span class="line">        <span class="keyword">for</span>(COFF j = <span class="number">0</span>; j &lt; Maxiator; j++)&#123;                 <span class="comment">//分子</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isSafe</span>(j, i))&#123;</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">ifdef</span> HALFCOFF</span></span><br><span class="line">                tempCLK = ClockInput /(<span class="keyword">double</span>)ICD * ((<span class="keyword">double</span>)IS + ((<span class="keyword">double</span>)j/(<span class="keyword">double</span>)i)) *<span class="number">1</span>/<span class="number">2</span>;   <span class="comment">//有系数时</span></span><br><span class="line">                <span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line">                tempCLK = ClockInput /(<span class="keyword">double</span>)ICD * ((<span class="keyword">double</span>)IS + ((<span class="keyword">double</span>)j/(<span class="keyword">double</span>)i)) ;       <span class="comment">//无系数时</span></span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                <span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_MODE</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;SYSTEM:IDC = &quot;</span> &lt;&lt; ICD &lt;&lt; <span class="string">&quot;, IS = &quot;</span> &lt;&lt; IS &lt;&lt; hex &lt;&lt;<span class="string">&quot;, Numerator = 0x&quot;</span>&lt;&lt; j &lt;&lt; <span class="string">&quot;, Denominator = 0x&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, OutputClock = &quot;</span> &lt;&lt; tempCLK &lt;&lt; endl;</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">isOK</span>(tempCLK)) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;SYSTEM:IDC = &quot;</span> &lt;&lt; ICD &lt;&lt; <span class="string">&quot;, IS = &quot;</span> &lt;&lt; IS &lt;&lt; hex &lt;&lt;<span class="string">&quot;, Numerator = 0x&quot;</span>&lt;&lt; j &lt;&lt; <span class="string">&quot;, Denominator = 0x&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, OutputClock = &quot;</span> &lt;&lt; tempCLK &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * THREAD _ CALCULATOR</span></span><br><span class="line"><span class="comment"> *-------------------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD1</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(COFF enumIS = <span class="number">2</span>; enumIS &lt;= IntegerSetting; enumIS++) <span class="built_in">CofficientCalculate</span>(CLK_IN , <span class="number">1</span>, enumIS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD2</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(COFF enumIS = <span class="number">2</span>; enumIS &lt;= IntegerSetting; enumIS++) <span class="built_in">CofficientCalculate</span>(CLK_IN , <span class="number">2</span>, enumIS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD3</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(COFF enumIS = <span class="number">2</span>; enumIS &lt;= IntegerSetting; enumIS++) <span class="built_in">CofficientCalculate</span>(CLK_IN , <span class="number">3</span>, enumIS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ICD4</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(COFF enumIS = <span class="number">2</span>; enumIS &lt;= IntegerSetting; enumIS++) <span class="built_in">CofficientCalculate</span>(CLK_IN , <span class="number">4</span>, enumIS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysPrintf</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// while(1) cout &lt;&lt; &quot;Calculating...&quot;;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r\003&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="运行结果">运行结果</h1>
<p>通过自行编写的代码，遍历所有可更改的系数进行计算求解，取得小数点后9位精度，并且符合要求的系数如下（含1/2系数）：</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210706001243698.png" alt="image-20210706001243698" /><figcaption aria-hidden="true">image-20210706001243698</figcaption>
</figure>
<p>以下为不含1/2系数的结果：</p>
<figure>
<img src="https://pic.islet.space/2021/07/image-20210706001350802.png" alt="image-20210706001350802" /><figcaption aria-hidden="true">image-20210706001350802</figcaption>
</figure>
<p>经过手工计算，结果（小数点后9位）确实满足要求。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/07/02/Signal/2021-07-02-PCMWAV%E6%A0%BC%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/02/Signal/2021-07-02-PCMWAV%E6%A0%BC%E5%BC%8F/" class="post-title-link" itemprop="url">PCM/WAV格式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-02 10:10:00" itemprop="dateCreated datePublished" datetime="2021-07-02T10:10:00+08:00">2021-07-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-12-10 22:37:12" itemprop="dateModified" datetime="2021-12-10T22:37:12+08:00">2021-12-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Signal/" itemprop="url" rel="index"><span itemprop="name">Signal</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/renhui/p/12148330.html">cnblogs.com</a></p>
<h1 id="名词解析">名词解析</h1>
<p>PCM(Pulse Code Modulation)也被称为脉码编码调制，PCM中的声音数据没有被压缩，它是由模拟信号经过采样、量化、编码转换成的标准的数字音频数据。采样转换方式参考下图进行了解：</p>
<figure>
<img src="https://img2018.cnblogs.com/blog/682616/202001/682616-20200104125147149-1090015063.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>音频采样包含以下几大要素：</p>
<h2 id="采样率">采样率</h2>
<p>采样率表示音频信号每秒的数字快照数。该速率决定了音频文件的频率范围。采样率越高，数字波形的形状越接近原始模拟波形。低采样率会限制可录制的频率范围，这可导致录音表现原始声音的效果不佳。根据奈奎斯特采样定理，为了重现给定频率，采样率必须至少是该频率的两倍。例如，一般CD唱片的采样率为每秒 44,100 个采样，因此可重现最高为 22,050 Hz 的频率，此频率刚好超过人类的听力极限 20,000 Hz。</p>
<figure>
<img src="https://img2018.cnblogs.com/blog/682616/202001/682616-20200104124551841-1606892798.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>图中A是低采样率的音频信号，其效果已经将原始声波进行了扭曲，B则是完全重现原始声波的高采样率的音频信号。</p>
<p>数字音频常用的采样率如下：</p>
<figure>
<img src="https://img2018.cnblogs.com/blog/682616/202001/682616-20200104124756569-1015603325.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="位深度">位深度</h2>
<p>位深度决定动态范围。采样声波时，为每个采样指定最接近原始声波振幅的振幅值。较高的位深度可提供更多可能的振幅值，产生更大的动态范围、更低的噪声基准和更高的保真度。</p>
<figure>
<img src="https://img2018.cnblogs.com/blog/682616/202001/682616-20200104124916045-1853047547.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>位深度越高，提供的动态范围越大。</p>
<h1 id="pcm">PCM</h1>
<p>在上面的名词解析中我们应该对PCM有了一定的理解和认识，下面我们将对PCM做更多的讲解。</p>
<h2 id="pcm音频数据存储方式">PCM音频数据存储方式</h2>
<p>如果是单声道的文件，采样数据按时间的先后顺序依次存入。如果是单声道的音频文件，采样数据按时间的先后顺序依次存入（也可能采用 LRLRLR 方式存储，只是另一个声道的数据为 0）。</p>
<p>如果是双声道的话通常按照 LRLRLR 的方式存储，存储的时候还和机器的大小端有关。（关于字节序大小端的相关内容可参考《<a target="_blank" rel="noopener" href="https://www.cnblogs.com/renhui/p/13600572.html">字节序问题之大小端模式讲解</a>》进行了解）</p>
<p>PCM的存储方式为小端模式，存储Data数据排列如下图所示：</p>
<figure>
<img src="https://img2018.cnblogs.com/blog/682616/202001/682616-20200104112313716-290297915.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="pcm-音频数据的参数">PCM 音频数据的参数</h2>
<p>描述 PCM 音频数据的参数的时候有如下描述方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">44100HZ 16bit stereo: 每秒钟有 44100 次采样, 采样数据用 16 位（2 字节）记录, 双声道（立体声）</span><br><span class="line">22050HZ 8bit  mono: 每秒钟有 22050 次采样, 采样数据用 8 位（1 字节）记录, 单声道</span><br><span class="line">48000HZ 32bit 51ch: 每秒钟有 48000 次采样, 采样数据用 32 位（4 字节浮点型）记录, 5.1 声道</span><br></pre></td></tr></table></figure>
<p>44100Hz 指的是采样率，它的意思是每秒取样 44100 次。采样率越大，存储数字音频所占的空间就越大。</p>
<p>16bit 指的是采样精度，意思是原始模拟信号被采样后，每一个采样点在计算机中用 16 位（两个字节）来表示。采样精度越高越能精细地表示模拟信号的差异。</p>
<p>Stereo 指的是声道数，也即采样时用到的麦克风的数量，麦克风越多就越能还原真实的采样环境（当然麦克风的放置位置也是有规定的）。</p>
<h1 id="wav">WAV</h1>
<p>WAV 是 Microsoft 和 IBM 为 PC 开发的一种声音文件格式，它符合 RIFF（Resource Interchange File Format）文件规范，用于保存 Windows 平台的音频信息资源，被 Windows 平台及其应用程序所广泛支持。WAVE 文件通常只是一个具有单个 “WAVE” 块的 RIFF 文件，该块由两个子块（”fmt” 子数据块和 ”data” 子数据块），它的格式如下图所示：</p>
<figure>
<img src="https://img2018.cnblogs.com/blog/682616/202001/682616-20200104131622902-1855086338.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>WAV 格式定义</strong></p>
<p>该格式的实质就是在 PCM 文件的前面加了一个文件头，每个字段的的含义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    char          ChunkID[4]; &#x2F;&#x2F;内容为&quot;RIFF&quot;</span><br><span class="line">    unsigned long ChunkSize;  &#x2F;&#x2F;存储文件的字节数（不包含ChunkID和ChunkSize这8个字节）</span><br><span class="line">    char          Format[4];  &#x2F;&#x2F;内容为&quot;WAVE“</span><br><span class="line">&#125; WAVE_HEADER;</span><br><span class="line"> </span><br><span class="line">typedef struct &#123;</span><br><span class="line">   char           Subchunk1ID[4]; &#x2F;&#x2F;内容为&quot;fmt&quot;</span><br><span class="line">   unsigned long  Subchunk1Size;  &#x2F;&#x2F;存储该子块的字节数（不含前面的Subchunk1ID和Subchunk1Size这8个字节）</span><br><span class="line">   unsigned short AudioFormat;    &#x2F;&#x2F;存储音频文件的编码格式，例如若为PCM则其存储值为1。</span><br><span class="line">   unsigned short NumChannels;    &#x2F;&#x2F;声道数，单声道(Mono)值为1，双声道(Stereo)值为2，等等</span><br><span class="line">   unsigned long  SampleRate;     &#x2F;&#x2F;采样率，如8k，44.1k等</span><br><span class="line">   unsigned long  ByteRate;       &#x2F;&#x2F;每秒存储的bit数，其值 &#x3D; SampleRate * NumChannels * BitsPerSample &#x2F; 8</span><br><span class="line">   unsigned short BlockAlign;     &#x2F;&#x2F;块对齐大小，其值 &#x3D; NumChannels * BitsPerSample &#x2F; 8</span><br><span class="line">   unsigned short BitsPerSample;  &#x2F;&#x2F;每个采样点的bit数，一般为8,16,32等。</span><br><span class="line">&#125; WAVE_FMT;</span><br><span class="line"> </span><br><span class="line">typedef struct &#123;</span><br><span class="line">   char          Subchunk2ID[4]; &#x2F;&#x2F;内容为“data”</span><br><span class="line">   unsigned long Subchunk2Size;  &#x2F;&#x2F;接下来的正式的数据部分的字节数，其值 &#x3D; NumSamples * NumChannels * BitsPerSample &#x2F; 8</span><br><span class="line">&#125; WAVE_DATA;</span><br></pre></td></tr></table></figure>
<p><strong>WAV 文件头解析</strong></p>
<p>这里是一个 WAVE 文件的开头 72 字节，字节显示为十六进制数字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">52 49 46 46 | 24 08 00 00 | 57 41 56 45</span><br><span class="line">66 6d 74 20 | 10 00 00 00 | 01 00 02 00 </span><br><span class="line">22 56 00 00 | 88 58 01 00 | 04 00 10 00</span><br><span class="line">64 61 74 61 | 00 08 00 00 | 00 00 00 00 </span><br><span class="line">24 17 1E F3 | 3C 13 3C 14 | 16 F9 18 F9</span><br><span class="line">34 E7 23 A6 | 3C F2 24 F2 | 11 CE 1A 0D</span><br></pre></td></tr></table></figure>
<p>字段解析如下图：</p>
<figure>
<img src="https://img2018.cnblogs.com/blog/682616/202001/682616-20200104131832991-1533022058.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h1 id="pcm-wav-开发实践">PCM &amp; WAV 开发实践</h1>
<h2 id="pcm格式转为wav格式基于c语言">PCM格式转为WAV格式（基于C语言）</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">int simplest_pcm16le_to_wave(const char *pcmpath,int channels,int sample_rate,const char *wavepath)</span><br><span class="line">&#123;</span><br><span class="line">    typedef struct WAVE_HEADER&#123;  </span><br><span class="line">        char         fccID[4];        </span><br><span class="line">        unsigned   long    dwSize;            </span><br><span class="line">        char         fccType[4];    </span><br><span class="line">    &#125;WAVE_HEADER;  </span><br><span class="line">    typedef struct WAVE_FMT&#123;  </span><br><span class="line">        char         fccID[4];        </span><br><span class="line">        unsigned   long       dwSize;            </span><br><span class="line">        unsigned   short     wFormatTag;    </span><br><span class="line">        unsigned   short     wChannels;  </span><br><span class="line">        unsigned   long       dwSamplesPerSec;  </span><br><span class="line">        unsigned   long       dwAvgBytesPerSec;  </span><br><span class="line">        unsigned   short     wBlockAlign;  </span><br><span class="line">        unsigned   short     uiBitsPerSample;  </span><br><span class="line">    &#125;WAVE_FMT;  </span><br><span class="line">    typedef struct WAVE_DATA&#123;  </span><br><span class="line">        char       fccID[4];          </span><br><span class="line">        unsigned long dwSize;              </span><br><span class="line">    &#125;WAVE_DATA;  </span><br><span class="line">    if(channels&#x3D;&#x3D;0||sample_rate&#x3D;&#x3D;0)&#123;</span><br><span class="line">    channels &#x3D; 2;</span><br><span class="line">    sample_rate &#x3D; 44100;</span><br><span class="line">    &#125;</span><br><span class="line">    int bits &#x3D; 16;</span><br><span class="line">    WAVE_HEADER   pcmHEADER;  </span><br><span class="line">    WAVE_FMT   pcmFMT;  </span><br><span class="line">    WAVE_DATA   pcmDATA;  </span><br><span class="line"> </span><br><span class="line">    unsigned   short   m_pcmData;</span><br><span class="line">    FILE   *fp,*fpout;  </span><br><span class="line">    fp&#x3D;fopen(pcmpath, &quot;rb&quot;);</span><br><span class="line">    if(fp &#x3D;&#x3D; NULL) &#123;  </span><br><span class="line">        printf(&quot;open pcm file error\n&quot;);</span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;</span><br><span class="line">    fpout&#x3D;fopen(wavepath,   &quot;wb+&quot;);</span><br><span class="line">    if(fpout &#x3D;&#x3D; NULL) &#123;    </span><br><span class="line">        printf(&quot;create wav file error\n&quot;);  </span><br><span class="line">        return -1; </span><br><span class="line">    &#125;        </span><br><span class="line">    &#x2F;&#x2F;WAVE_HEADER</span><br><span class="line">    memcpy(pcmHEADER.fccID,&quot;RIFF&quot;,strlen(&quot;RIFF&quot;));                    </span><br><span class="line">    memcpy(pcmHEADER.fccType,&quot;WAVE&quot;,strlen(&quot;WAVE&quot;));  </span><br><span class="line">    fseek(fpout,sizeof(WAVE_HEADER),1); </span><br><span class="line">    &#x2F;&#x2F;WAVE_FMT</span><br><span class="line">    pcmFMT.dwSamplesPerSec&#x3D;sample_rate;  </span><br><span class="line">    pcmFMT.dwAvgBytesPerSec&#x3D;pcmFMT.dwSamplesPerSec*sizeof(m_pcmData);  </span><br><span class="line">    pcmFMT.uiBitsPerSample&#x3D;bits;</span><br><span class="line">    memcpy(pcmFMT.fccID,&quot;fmt &quot;,strlen(&quot;fmt &quot;));  </span><br><span class="line">    pcmFMT.dwSize&#x3D;16;  </span><br><span class="line">    pcmFMT.wBlockAlign&#x3D;2;  </span><br><span class="line">    pcmFMT.wChannels&#x3D;channels;  </span><br><span class="line">    pcmFMT.wFormatTag&#x3D;1;  </span><br><span class="line"> </span><br><span class="line">    fwrite(&amp;pcmFMT,sizeof(WAVE_FMT),1,fpout); </span><br><span class="line">    &#x2F;&#x2F;WAVE_DATA;</span><br><span class="line">    memcpy(pcmDATA.fccID,&quot;data&quot;,strlen(&quot;data&quot;));  </span><br><span class="line">    pcmDATA.dwSize&#x3D;0;</span><br><span class="line">    fseek(fpout,sizeof(WAVE_DATA),SEEK_CUR);</span><br><span class="line">    fread(&amp;m_pcmData,sizeof(unsigned short),1,fp);</span><br><span class="line">    while(!feof(fp))&#123;  </span><br><span class="line">        pcmDATA.dwSize+&#x3D;2;</span><br><span class="line">        fwrite(&amp;m_pcmData,sizeof(unsigned short),1,fpout);</span><br><span class="line">        fread(&amp;m_pcmData,sizeof(unsigned short),1,fp);</span><br><span class="line">    &#125;  </span><br><span class="line">    pcmHEADER.dwSize&#x3D;44+pcmDATA.dwSize;</span><br><span class="line">    rewind(fpout);</span><br><span class="line">    fwrite(&amp;pcmHEADER,sizeof(WAVE_HEADER),1,fpout);</span><br><span class="line">    fseek(fpout,sizeof(WAVE_FMT),SEEK_CUR);</span><br><span class="line">    fwrite(&amp;pcmDATA,sizeof(WAVE_DATA),1,fpout);</span><br><span class="line">    </span><br><span class="line">    fclose(fp);</span><br><span class="line">    fclose(fpout);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：函数里声明的数据类型unsigned long在有些C编译器上是64位的，这时候要改成unsigned int才可以，否则wav头有88bytes，标准的是44bytes，改完就正常了，对C还不熟悉的人小小的心得，另外，声道数和采样率也要注意，一般采样率有44100/16000/8000，要确认是哪个，声道是1还是2，这两个参数要设置好才会有正确的转换结果。</p>
<h2 id="pcm降低某个声道的音量基于c语言">PCM降低某个声道的音量（基于C语言）</h2>
<p>一般来说 PCM 数据中的波形幅值越大，代表音量越大，对于 PCM 音频数据而言，它的幅值（即该采样点采样值的大小）代表音量的大小。</p>
<p>如果我们需要降低某个声道的音量，可以通过减小某个声道的数据的值来实现降低某个声道的音量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int pcm16le_half_volume_left( char *url ) &#123;</span><br><span class="line">    FILE *fp_in &#x3D; fopen( url, &quot;rb+&quot; );</span><br><span class="line">    FILE *fp_out &#x3D; fopen( &quot;output_half_left.pcm&quot;, &quot;wb+&quot; );</span><br><span class="line">    unsigned char *sample &#x3D; ( unsigned char * )malloc(4); &#x2F;&#x2F; 一次读取一个sample，因为是2声道，所以是4字节 </span><br><span class="line">    while ( !feof( fp_in ) )&#123;</span><br><span class="line">        fread( sample, 1, 4, fp_in );</span><br><span class="line">        short* sample_num &#x3D; ( short* )sample; &#x2F;&#x2F; 转成左右声道两个short数据</span><br><span class="line">        *sample_num &#x3D; *sample_num &#x2F; 2; &#x2F;&#x2F; 左声道数据减半</span><br><span class="line">        fwrite( sample, 1, 2, fp_out ); &#x2F;&#x2F; L</span><br><span class="line">        fwrite( sample + 2, 1, 2, fp_out ); &#x2F;&#x2F; R</span><br><span class="line">    &#125;</span><br><span class="line">    free( sample );</span><br><span class="line">    fclose( fp_in );</span><br><span class="line">    fclose( fp_out );</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码做的事情是：在读出左声道的 2 Byte 的取样值之后，将其转成了 C 语言中的一个 short 类型的变量。将该数值除以 2 之后写回到了 PCM 文件中。</p>
<h2 id="分离pcm音频数据左右声道的数据">分离PCM音频数据左右声道的数据</h2>
<p>因为PCM音频数据是按照LRLRLR的方式来存储左右声道的音频数据的，所以我们可以通过将它们交叉的读出来的方式来分离左右声道的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int simplest_pcm16le_split(char *url) &#123;</span><br><span class="line">    FILE *fp&#x3D;fopen(url,&quot;rb+&quot;);</span><br><span class="line">    FILE *fp1&#x3D;fopen(&quot;output_l.pcm&quot;,&quot;wb+&quot;);</span><br><span class="line">    FILE *fp2&#x3D;fopen(&quot;output_r.pcm&quot;,&quot;wb+&quot;);</span><br><span class="line">    unsigned char *sample&#x3D;(unsigned char *)malloc(4);</span><br><span class="line">    while(!feof(fp))&#123;</span><br><span class="line">        fread(sample,1,4,fp);</span><br><span class="line">        &#x2F;&#x2F;L</span><br><span class="line">        fwrite(sample,1,2,fp1);</span><br><span class="line">        &#x2F;&#x2F;R</span><br><span class="line">        fwrite(sample+2,1,2,fp2);</span><br><span class="line">    &#125;</span><br><span class="line">    free(sample);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    fclose(fp1);</span><br><span class="line">    fclose(fp2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="从pcm16le单声道音频采样数据中截取一部分数据">从PCM16LE单声道音频采样数据中截取一部分数据</h2>
<p>本程序中的函数可以从PCM16LE单声道数据中截取一段数据，并输出截取数据的样值。函数的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Cut a 16LE PCM single channel file.</span><br><span class="line"> * @param url        Location of PCM file.</span><br><span class="line"> * @param start_num  start point</span><br><span class="line"> * @param dur_num    how much point to cut</span><br><span class="line"> *&#x2F;</span><br><span class="line">int simplest_pcm16le_cut_singlechannel(char *url,int start_num,int dur_num)&#123;</span><br><span class="line">    FILE *fp&#x3D;fopen(url,&quot;rb+&quot;);</span><br><span class="line">    FILE *fp1&#x3D;fopen(&quot;output_cut.pcm&quot;,&quot;wb+&quot;);</span><br><span class="line">    FILE *fp_stat&#x3D;fopen(&quot;output_cut.txt&quot;,&quot;wb+&quot;);</span><br><span class="line"> </span><br><span class="line">    unsigned char *sample&#x3D;(unsigned char *)malloc(2);</span><br><span class="line"> </span><br><span class="line">    int cnt&#x3D;0;</span><br><span class="line">    while(!feof(fp))&#123;</span><br><span class="line">        fread(sample,1,2,fp);</span><br><span class="line">        if(cnt&gt;start_num&amp;&amp;cnt&lt;&#x3D;(start_num+dur_num))&#123;</span><br><span class="line">            fwrite(sample,1,2,fp1);</span><br><span class="line"> </span><br><span class="line">            short samplenum&#x3D;sample[1];</span><br><span class="line">            samplenum&#x3D;samplenum*256;</span><br><span class="line">            samplenum&#x3D;samplenum+sample[0];</span><br><span class="line"> </span><br><span class="line">            fprintf(fp_stat,&quot;%6d,&quot;,samplenum);</span><br><span class="line">            if(cnt%10&#x3D;&#x3D;0)</span><br><span class="line">                fprintf(fp_stat,&quot;\n&quot;,samplenum);</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    free(sample);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    fclose(fp1);</span><br><span class="line">    fclose(fp_stat);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将pcm16le双声道音频采样数据转换为pcm8音频采样数据">将PCM16LE双声道音频采样数据转换为PCM8音频采样数据</h2>
<p>本程序中的函数可以通过计算的方式将PCM16LE双声道数据16bit的采样位数转换为8bit。函数的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Convert PCM-16 data to PCM-8 data.</span><br><span class="line"> * @param url  Location of PCM file.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int simplest_pcm16le_to_pcm8(char *url)&#123;</span><br><span class="line">    FILE *fp&#x3D;fopen(url,&quot;rb+&quot;);</span><br><span class="line">    FILE *fp1&#x3D;fopen(&quot;output_8.pcm&quot;,&quot;wb+&quot;);</span><br><span class="line"> </span><br><span class="line">    int cnt&#x3D;0;</span><br><span class="line"> </span><br><span class="line">    unsigned char *sample&#x3D;(unsigned char *)malloc(4);</span><br><span class="line"> </span><br><span class="line">    while(!feof(fp))&#123;</span><br><span class="line"> </span><br><span class="line">        short *samplenum16&#x3D;NULL;</span><br><span class="line">        char samplenum8&#x3D;0;</span><br><span class="line">        unsigned char samplenum8_u&#x3D;0;</span><br><span class="line">        fread(sample,1,4,fp);</span><br><span class="line">        &#x2F;&#x2F;(-32768-32767)</span><br><span class="line">        samplenum16&#x3D;(short *)sample;</span><br><span class="line">        samplenum8&#x3D;(*samplenum16)&gt;&gt;8;</span><br><span class="line">        &#x2F;&#x2F;(0-255)</span><br><span class="line">        samplenum8_u&#x3D;samplenum8+128;</span><br><span class="line">        &#x2F;&#x2F;L</span><br><span class="line">        fwrite(&amp;samplenum8_u,1,1,fp1);</span><br><span class="line"> </span><br><span class="line">        samplenum16&#x3D;(short *)(sample+2);</span><br><span class="line">        samplenum8&#x3D;(*samplenum16)&gt;&gt;8;</span><br><span class="line">        samplenum8_u&#x3D;samplenum8+128;</span><br><span class="line">        &#x2F;&#x2F;R</span><br><span class="line">        fwrite(&amp;samplenum8_u,1,1,fp1);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Sample Cnt:%d\n&quot;,cnt);</span><br><span class="line"> </span><br><span class="line">    free(sample);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    fclose(fp1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PCM16LE格式的采样数据的取值范围是-32768到32767，而PCM8格式的采样数据的取值范围是0到255。所以PCM16LE转换到PCM8需要经过两个步骤：第一步是将-32768到32767的16bit有符号数值转换为-128到127的8bit有符号数值，第二步是将-128到127的8bit有符号数值转换为0到255的8bit无符号数值。在本程序中，16bit采样数据是通过short类型变量存储的，而8bit采样数据是通过unsigned char类型存储的。</p>
<h2 id="将pcm16le双声道音频采样数据的声音速度提高一倍">将PCM16LE双声道音频采样数据的声音速度提高一倍</h2>
<p>本程序中的函数可以通过抽象的方式将PCM16LE双声道数据的速度提高一倍，采用采样每个声道奇(偶)数点的样值的方式，函数的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Re-sample to double the speed of 16LE PCM file</span><br><span class="line"> * @param url  Location of PCM file.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int simplest_pcm16le_doublespeed(char *url)&#123;</span><br><span class="line">    FILE *fp&#x3D;fopen(url,&quot;rb+&quot;);</span><br><span class="line">    FILE *fp1&#x3D;fopen(&quot;output_doublespeed.pcm&quot;,&quot;wb+&quot;);</span><br><span class="line"> </span><br><span class="line">    int cnt&#x3D;0;</span><br><span class="line"> </span><br><span class="line">    unsigned char *sample&#x3D;(unsigned char *)malloc(4);</span><br><span class="line"> </span><br><span class="line">    while(!feof(fp))&#123;</span><br><span class="line"> </span><br><span class="line">        fread(sample,1,4,fp);</span><br><span class="line"> </span><br><span class="line">        if(cnt%2!&#x3D;0)&#123;</span><br><span class="line">            &#x2F;&#x2F;L</span><br><span class="line">            fwrite(sample,1,2,fp1);</span><br><span class="line">            &#x2F;&#x2F;R</span><br><span class="line">            fwrite(sample+2,1,2,fp1);</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Sample Cnt:%d\n&quot;,cnt);</span><br><span class="line"> </span><br><span class="line">    free(sample);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    fclose(fp1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考">参考</h1>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/leixiaohua1020/article/details/50534316">视音频数据处理入门：PCM音频采样数据处理</a> --&gt; 致敬雷神！</p>
<p>​</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/06/30/Hardware/DSP/2021-06-30-ADSP%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/30/Hardware/DSP/2021-06-30-ADSP%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">ADSP混合编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-30 14:00:00" itemprop="dateCreated datePublished" datetime="2021-06-30T14:00:00+08:00">2021-06-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-07-01 01:31:56" itemprop="dateModified" datetime="2021-07-01T01:31:56+08:00">2021-07-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hardware/" itemprop="url" rel="index"><span itemprop="name">Hardware</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="伪操作和伪指令">伪操作和伪指令</h1>
<p><strong><em>Directives</em></strong>，即 <strong>伪操作</strong>，是汇编语言中的特殊指令助记符。主要作用是为完成汇编程序做各种准备。伪操作仅是在源程序进行汇编时由汇编程序处理，而不是在计算机运行期间由机器执行的指令。即，伪操作只在汇编时起作用，一旦汇编结束，其使命也就结束了。</p>
<p><strong><em>Pseudo-Instruction</em></strong>，即 <strong><em>伪指令</em></strong>，是汇编语言程序里的特殊指令助记符，不是 真指令。伪指令在汇编时被替换成合适的机器指令（根据芯片架构而定，不同芯片架构之间指令可能不同），故其也只在汇编时其作用，不在机器运行期间由机器执行。</p>
<h1 id="adi汇编文件样式">ADI汇编文件样式</h1>
<p>.asm 文件具有以下样式，包含 <strong><em>预处理指令</em></strong>（主要是C/C++宏定义）、汇编伪操作类别（assembler direcitives）、数据块、代码块、条件编译预处理 和 汇编标签。</p>
<figure>
<img src="https://pic.islet.space/2021/06/image-20210630170546778.png" alt="image-20210630170546778" /><figcaption aria-hidden="true">image-20210630170546778</figcaption>
</figure>
<h2 id="混合编程">混合编程</h2>
<h3 id="使用asm">使用asm()</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> img288; <span class="comment">//定义C语言变量</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;ax0 = 0x5C;&quot;</span>);</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;dm(img288_) = ax0;&quot;</span>);  <span class="comment">//用汇编语言赋值时，变量需要加后置下划线？？？</span></span><br><span class="line">img288 = <span class="number">0x5C</span>;  <span class="comment">//直接用C语言赋值</span></span><br></pre></td></tr></table></figure>
<p>以上C语言与汇编代码经过编译后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ax0 &#x3D; 0x5C;</span><br><span class="line">dm(img288_) &#x3D; ax0;</span><br><span class="line">my1 &#x3D; 92;</span><br><span class="line">dm(img288_) &#x3D; my1;</span><br></pre></td></tr></table></figure>
<p><mark>此处可否把 <code>dm()</code> 当成一个类似于指针的东西</mark></p>
<h3 id="使用汇编子程序">使用汇编子程序</h3>
<p>使用汇编子程序是C语言程序与汇编语言接口的另一种方法。<mark>用户定义的子程序放在单独的汇编文件中，或是做成二进制的库文件，并将子程序的定义用GLOBEL输出，汇编后就可以供C语言程序调用</mark>。下面是一个不需要参数的子程序的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.MODULE&#x2F;RAM_delay_;</span><br><span class="line">.external del_cycle;  &#x2F;&#x2F;声明del_cycle是外部变量</span><br><span class="line">.global delay;  &#x2F;&#x2F;声明delay是全局变量</span><br><span class="line"></span><br><span class="line">delay_:</span><br><span class="line">function_entry;  &#x2F;&#x2F;子程序开始标志，必不可少</span><br><span class="line">ar &#x3D; dm(del_cycle_);</span><br><span class="line">cntr &#x3D; ar;</span><br><span class="line">do d_loop until ce;</span><br><span class="line">d_loop:nop;</span><br><span class="line">exit;  &#x2F;&#x2F;子程序结束标志，必不可少</span><br><span class="line">.ENDMOD;</span><br></pre></td></tr></table></figure>
<p>注意：以上代码源自参考链接4，实际上代码中的关键字相差可能较大，需要根据实际情况进行改动。</p>
<p>比如，21479系列芯片与ADAU1939芯片一同工作，其ADC采样代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.section&#x2F;pm seg_pmco;  &#x2F;&#x2F;程序代码块，procedure memory section</span><br><span class="line"></span><br><span class="line">_Receive_ADC_Samples:  &#x2F;*应该类似于 &#123; *&#x2F;</span><br><span class="line">.global _Receive_ADC_Samples;  &#x2F;&#x2F;定义自己为全局函数</span><br><span class="line"></span><br><span class="line">	r1 &#x3D; -31;     </span><br><span class="line">	r0 &#x3D; dm(_rx1a_buf + Internal_ADC_L1);	</span><br><span class="line">	f0 &#x3D; float r0 by r1;	</span><br><span class="line">	dm(_Left_Channel_In1) &#x3D; r0;</span><br><span class="line">  </span><br><span class="line">	r0 &#x3D; dm(_rx1a_buf + Internal_ADC_R1);	</span><br><span class="line">	f0 &#x3D; float r0 by r1;	</span><br><span class="line">	dm(_Right_Channel_In1) &#x3D; r0;			</span><br><span class="line"></span><br><span class="line">	r0 &#x3D; dm(_rx1b_buf + Internal_ADC_L2);	</span><br><span class="line">	f0 &#x3D; float r0 by r1;	</span><br><span class="line">	dm(_Left_Channel_In2) &#x3D; r0;	</span><br><span class="line">	</span><br><span class="line">	r0 &#x3D; dm(_rx1b_buf + Internal_ADC_R2);	</span><br><span class="line">	f0 &#x3D; float r0 by r1;	</span><br><span class="line">	dm(_Right_Channel_In2) &#x3D; r0;			</span><br><span class="line"></span><br><span class="line">	r0 &#x3D; DM(AD1939_audio_frame_timer);</span><br><span class="line">	r0 &#x3D; r0 + 1;</span><br><span class="line">	DM(AD1939_audio_frame_timer) &#x3D; r0;</span><br><span class="line">	</span><br><span class="line">	leaf_exit;  &#x2F;&#x2F;程序结束标志，应该类似于return;吧</span><br><span class="line">_Receive_ADC_Samples.end:  &#x2F;*应该类似于 &#125;*&#x2F;</span><br></pre></td></tr></table></figure>
<h1 id="dual-memory-support-keywords-dm-pm">Dual Memory Support Keywords (dm / pm)</h1>
<p>This section describes <strong><em>cc21k</em></strong> language extension keywords to C and C++ that support the dual-memory space, modified Harvard architecture of the ADSP-21xxx processors. There are two keywords used to designate memory space: <strong><em>dm</em></strong> and <strong><em>pm</em></strong>. They can be used to specify the location of a static or global variable or to qualify a pointer declaration.</p>
<p>以下规则适用于两种内存关键字（dm/pm）：</p>
<ul>
<li>The memory space keyword (dm or pm) refers to the expression to the right of the keyword.</li>
<li>You can specify a memory space for each level of pointer. This corresponds to one memory space for each * in the declaration.</li>
<li>The compiler uses <strong><em>Data Memory</em></strong> (DM) as the default memory space for all variables. All undeclared spaces for data are Data Memory spaces.</li>
<li>The compiler always uses <strong><em>Program Memory</em></strong> (PM) as the memory space for functions. Function pointers always point to Program Memory.</li>
<li>You cannot assign memory spaces to <strong><em>automatic variables</em></strong>. <mark>All automatic variables reside on the stack, which is always in Data Memory</mark>.</li>
<li>Literal character strings always reside in Data Memory.</li>
</ul>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《<a target="_blank" rel="noopener" href="https://www.analog.com/media/en/dsp-documentation/software-manuals/50_21k_cc_mn_rev_1.5.pdf">VisualDSP++ 5.0 C/C++ Compiler Manual for SHARC Processors</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://www.analog.com/media/en/dsp-documentation/processor-manuals/236999443isr_21xxx.pdf">ADSP-21160 SHARC DSP Instruction Set Reference</a>》</li>
<li>《嵌入式系统原理与应用设计》王光学，电子工业出版社</li>
<li><a target="_blank" rel="noopener" href="http://www.gzweix.com/article/sort0250/sort0251/sort0288/info-228197_2.html">嵌入式C语言开发ADSP21XX系列</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备19004822号 </a>
  </div>

<div class="copyright">
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liewzheng</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@8.12.0/dist/mermaid.min.js","integrity":"sha256-0dD7vUjUCTGJjeLnPotQQJIcSzug5fO6WDMYYyNIX4c="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  <script src="/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":"enable","tags":"all","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
