<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;islet.space&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script>
<meta name="description" content="笔记分享的旮旯孤岛而已">
<meta property="og:type" content="website">
<meta property="og:title" content="Coder的孤岛">
<meta property="og:url" content="http://islet.space/page/3/index.html">
<meta property="og:site_name" content="Coder的孤岛">
<meta property="og:description" content="笔记分享的旮旯孤岛而已">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liewzheng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://islet.space/page/3/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;en&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;3&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Coder的孤岛</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Coder的孤岛</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">islet of the coder</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-文章"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>文章</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liewzheng</p>
  <div class="site-description" itemprop="description">笔记分享的旮旯孤岛而已</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">109</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="mailto:liewzheng@qq.com" title="E-Mail → mailto:liewzheng@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/21/Signal/What%20is%20a%20Bypass%20Capacitor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/21/Signal/What%20is%20a%20Bypass%20Capacitor/" class="post-title-link" itemprop="url">What is a Bypass Capacitor?</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-21 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-21T23:58:32+08:00">2021-04-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-29 00:50:14" itemprop="dateModified" datetime="2021-04-29T00:50:14+08:00">2021-04-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Signal/" itemprop="url" rel="index"><span itemprop="name">Signal</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="http://www.learningaboutelectronics.com/Articles/What-is-a-bypass-capacitor.html">learningaboutelectronics.com</a></p>
<h1 id="What-is-a-Bypass-Capacitor"><a href="#What-is-a-Bypass-Capacitor" class="headerlink" title="What is a Bypass Capacitor?"></a>What is a Bypass Capacitor?</h1><p><img src="http://www.learningaboutelectronics.com/images/Bypass-capacitor.png" alt="Bypass capacitor"></p>
<p>A bypass capacitor is a capacitor that shorts AC signals to ground, so  that any AC noise that may be  present on a DC signal is removed, producing a much cleaner and pure DC signal.</p>
<p>A bypass capacitor essentially bypasses  AC noise that may be on a DC signal, filtering out the AC, so that a clean, pure DC signal goes through without any AC ripple. </p>
<p>For example, you may want a pure DC signal from a power source. </p>
<p>Below is a transistor circuit. A transistor is an active device, so in order to work, it needs DC power. This power source is  VCC. In this case, VCC equals 15 volts. </p>
<p><img src="http://www.learningaboutelectronics.com/images/DC-power-source-transistor.png" alt="DC Power Source for Transistor"></p>
<p>This 15 volts provides power to the transistor so that the transistor can  amplify signals. We want this signal to be as purely DC as possible. Although we obtain our DC voltage, VCC, from a DC power  source such as a power supply, the voltage isn’t always purely DC. In  fact, many times the  voltage is very noisy and contains a lot of AC ripple on it, especially  at the 60Hz frequency because this is the frequency at which AC signals  run in many countries. </p>
<p>So although we want a pure DC signal, such as below:</p>
<p><img src="http://www.learningaboutelectronics.com/images/Pure-DC-voltage.png" alt="Pure DC Voltage"></p>
<p>Many times, we get a noisy signal that looks like:</p>
<p><img src="http://www.learningaboutelectronics.com/images/Noisy-dc-signal.png" alt="Noisy DC Voltage Signal"></p>
<p>A DC signal such as this is actually very common. This is undesired  because it adds noise to the transistor circuit. Therefore, this  noisy DC signal will be imposed on the AC signal. So the AC signal which may have music or some type of recording will now have much more noise. </p>
<p>This noise which is on the signal is AC ripple. Many  times when using a DC power supply connected to an AC power outlet, it  will  have some of the AC noise transfer to the DC power voltage. AC ripple  can also appear from other sources, so even batteries can produce noise. </p>
<p>To eliminate this AC ripple, we use a bypass  capacitor. So our transistor circuit above will have a bypass capacitor  added to it:</p>
<p><img src="http://www.learningaboutelectronics.com/images/Bypass-capacitor-transistor-circuit.png" alt="Bypass Capacitor for a Transistor Circuit"></p>
<p>A capacitor is a device that offers a tremendously high resistance for  signals of low frequencies. Therefore, signals at low frequencies will  not go through them. This is because  signals (current) always takes the path of least resistance. Therefore,  they will instead go through the resistor, RE. Remember, again, this is for low frequency signals, which is  basically DC signals. </p>
<p>However, capacitors offer much less resistance at higher frequencies (AC signals). So AC signals will go through the  capacitor and then to gorund. Therefore, DC signals will go  through the resistor, RE, while AC signals will go  through the capacitor, getting shunted to ground. So AC signals get  shunted to ground. This is how we have a clean DC signal  across our circuit, while AC noise imposed on it is bypassed to ground. </p>
<p><img src="http://www.learningaboutelectronics.com/images/How-a-bypass-capacitor-works.png" alt="How a Bypass Capacitor Works"></p>
<p>So a bypass capacitor blocks the DC from entering it by the great  resistance it offers to the signal but accepts the AC noise that may be  on the DC line and shunts or bypasses it to ground.  This is how bypass capacitors work.</p>
<h1 id="How-to-Choose-the-Value-of-the-Bypass-Capacitor"><a href="#How-to-Choose-the-Value-of-the-Bypass-Capacitor" class="headerlink" title="How to Choose the Value of the Bypass Capacitor"></a>How to Choose the Value of the Bypass Capacitor</h1><p>Now that you know conceptually what a bypass capacitor is, the next step is to know how to select the value of the  bypass capacitor. </p>
<p>And selecting the value is pretty straightforward. </p>
<p>The value of the bypass capacitor should be at least 1/10th of the resistance across the emitter resistance,  RE at the lowest frequency intended to be bypassed.</p>
<p>Because capacitors are reactive devices, they have different resistances to signals based on the signal’s frequency.  This is referred to as the capacitor’s reactance, which can be seen as the resistance it offers. We want the capacitor to have  1/10th of the resistance to the flow of current than what the resistor offers for the frequency signal that we want to bypass. </p>
<p>If you visualize the current moving through the transistor, it can take one of 2 paths once it passes the collector and  moves through the emitter. Current can either go the resistor, RE or current can flow through the bypass capacitor.  Current always takes the path of least resistance. Therefore, current  will take the path of the lower resistance.  This is why you want  the value of the resistance of the bypass capacitor to be at least  1/10th the value of the emitter resistor or, even better, less than  one-tenth. We want the AC current to flow through the least resistance  path, which is the bypass capacitor if the correct value is  chosen. </p>
<p>However, DC signals do not see it as AC. To DC, the capacitor has infinite resistance.  So DC will automatically go through the RE resistor, which offers lower resistance by far to the infinite resistance  of the capacitor. </p>
<p>AC, however, does not see infinite resistance for the capacitor. If we choose the value correctly for the capacitor,  we can make the capacitor a much lower-resistance path to ground, thus shorting out the AC signal to ground. </p>
<p>So let’s go over a practical example of how we would select the bypass capacitor value.</p>
<p>Let’s say we want to bypass the lowest possible frequency of 50Hz, because the frequency of AC voltages worldwide are 50-60Hz. Therefore, this frequency can be a very problematic because often there is AC ripple at this frequency. </p>
<p>Remember, when we said we bias the value of the bypass capacitor based on the lowest frequency that we want to bypass.  So by selecting the frequency of 50Hz, this blocks frequencies from 50Hz and higher; so it covers 60Hz. As frequency of an AC signal  increases, the resistance of the capacitor decreases and decreases with  each increase. Therefore, all the frequencies above the  frequency value that we choose get bypassed easier and easier. We’ll  demonstrate this all mathematically. </p>
<p>So we decided we want to bypass AC signals 50Hz or higher to ground. </p>
<p>The typical value of an emitter resistor is 400-500‎Ω. The resistance is kept low so that gain on the transistor isn’t  lowered too much. </p>
<p>So let’s say we choose an emitter resistor of 470‎Ω. </p>
<p>This means that we want the reactance of the capacitor to be one-tenth of 470‎Ω or less, which is 47‎Ω or lower.  So this is our target. </p>
<p>The formula for the reactance of a capacitor is, XC= 1/2πfc= 1/2(3.14)(50Hz)(C)=47Ω. Solving for the  capacitance, C, we get the value of approximately 67μF. So we need a  capacitor of at least 67μF to get a resistance of one-tenth  the value of 470Ω resistor. </p>
<p>Since a 67μF capacitor isn’t readily available, we can round up to 100μF, which is readily available and easy to obtain.  This is even better, because with a larger capacitance, the capacitor  offers even less resistance to the AC signal. If we plug a  100μF capacitor into the same capacitor reactance formula, we get XC= 1/2πfc= 1/2(3.14)(50Hz)(100μF)=31.8Ω. This is much  lower than 1/10 of the 470Ω resistor that we have in parallel. So it  will act effectively to short all AC signals 50Hz or higher  to ground to clean up the DC signal. </p>
<p>Even if you wanted, you could increase the  capacitance even more to allow for less AC noise on the signal. But a  lot  of times, this will not be done for cost and size constraints reasons.  The larger the size a capacitor is, the more it costs per unit. Also the larger the size of a capacitor, the larger physically is. Therefore, if a company is designing a product, the size of the capacitor could be a problem if there are size constraint issues. The way things are going in electronics, companies want  products to be as small and concise as possible. So due to reasons such  as these, larger value capacitors won’t always be chosen, but  theoretically, they would increase the purity of the DC signal, by  allowing more AC to ground. </p>
<p>So again, this is a summary of what a bypass capacitor is and how to select the value of them based on the lowest  AC signal desired to be filtered out and the value of the resistance in parallel with the capacitor. </p>
<p>You can check out our <a target="_blank" rel="noopener" href="http://www.learningaboutelectronics.com/Articles/Bypass-capacitor-calculator.php">bypass capacitor calculator</a> to calculate  the value of a bypass capacitor based on the input AC signal frequency and the value of the resistor in parallel. </p>
<p>Related Resources</p>
<p>​          </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/20/Networking/Networking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/20/Networking/Networking/" class="post-title-link" itemprop="url">Networking</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-20 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-20T23:58:32+08:00">2021-04-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-26 00:14:57" itemprop="dateModified" datetime="2021-04-26T00:14:57+08:00">2021-04-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Networking/" itemprop="url" rel="index"><span itemprop="name">Networking</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><blockquote>
<p><em>内容分发网络（Content Delivery Network，CDN）是建立并覆盖在承载网上，由不同区域的服务器组成的分布式网络。将源站资源缓存到全国各地的边缘服务器，供用户就近获取，降低源站压力。</em></p>
<p>——阿里云</p>
<p>*CDN是构建在现有网络基础之上的智能虚拟网络，依靠 <strong>部署在各地的边缘服务器</strong>，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。*</p>
<p>——百度百科</p>
</blockquote>
<p>个人理解，实际部署CDN中最重要的概念即 <strong>节点</strong>、<strong>缓存服务器</strong> 和 <strong>中心平台</strong>。</p>
<ul>
<li>节点是指在足够广的范围内识别出合适数量的网络拓扑节点，这些节点往往处在网络所及最远之处的各地，能够有效分摊用户访问对主干网络的压力；</li>
<li>而缓存服务器即“部署在各地的边缘服务器”，是指能够 <strong>制定规则</strong> <strong>自动识别并缓存数据</strong> 以供用户快速访问，分担主干网络压力的实体。</li>
<li>中心平台可以对缓存服务器实现负载均衡、内容分发和调度等功能。</li>
</ul>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><blockquote>
<p>假设您的加速域名为<code>www.a.com</code>，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下图所示。</p>
<ol>
<li>当终端用户（北京）向<code>www.a.com</code>下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。                  </li>
<li>LDNS检查缓存中是否有<code>www.a.com</code>的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。                  </li>
<li>当授权DNS解析<code>www.a.com</code>时，返回域名CNAME <code>www.a.tbcdn.com</code>对应IP地址。                  </li>
<li>域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。</li>
<li>LDNS获取DNS返回的解析IP地址。</li>
<li>用户获取解析IP地址。</li>
<li>用户向获取的IP地址发起对该资源的访问请求。                                                           <ul>
<li>如果该IP地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤7和8，请求结束。</li>
<li>如果该IP地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。配置缓存策略的操作方法，请参见<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/27136.htm?spm=a2c4g.11186623.2.3.694925b3RabzbR#concept-f24-32d-xdb">缓存配置</a>。                        </li>
</ul>
</li>
</ol>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/p4886.png" alt="img" style="zoom: 67%;" />

<p>——阿里云</p>
</blockquote>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="场景概述"><a href="#场景概述" class="headerlink" title="场景概述"></a>场景概述</h5><p>CDN的业务使用场景分为 <strong>静态内容加速</strong>、<strong>动态内容加速</strong> 和 <strong>安全加速</strong> 。</p>
<blockquote>
<p><strong>静态内容（静态资源）</strong></p>
<p>静态内容是指在不同请求中访问到的数据都相同的静态文件。例如：图片、视频、网站中的文件（html、css、js）、软件安装包、apk文件、压缩包文件等。</p>
<p>CDN加速的本质是 <strong>缓存加速</strong>。将您服务器上存储的静态内容缓存在阿里云CDN节点上，当您访问这些静态内容时，无需访问服务器源站，就近访问阿里云CDN节点即可获取相同内容。从而达到加速的效果，同时减轻服务器源站的压力。</p>
<p><strong>动态内容（动态资源）</strong></p>
<p>动态内容是指在不同请求中访问到的数据不相同的动态内容。例如：网站中的文件（asp、jsp、php、perl、cgi）、API接口、数据库交互请求等。</p>
<p><strong>当您访问这些动态内容时，每次都需要访问您的服务器，由服务器动态生成实时的数据并返回给您。</strong>因此CDN的缓存加速不适用于加速动态内容，CDN无法缓存实时变化的动态内容。对于动态内容请求，CDN节点只能转发回您的服务器源站，没有加速效果。</p>
<p>如果您的网站或App应用有较多动态内容，例如需要对各种API接口进行加速，则需要使用 <a target="_blank" rel="noopener" href="https://www.alibabacloud.com/zh/product/dcdn">阿里云全站加速</a> 产品。全站加速能同时加速动态和静态内容，加速方式如下：                                                                     </p>
<ul>
<li>静态内容使用CDN加速。</li>
<li>动态内容通过阿里云的 <strong>路由优化</strong>、<strong>传输优化</strong> 等动态加速技术以最快的速度访问您的服务器源站获取数据。从而达到全站加速的效果。</li>
</ul>
<p>——阿里云</p>
</blockquote>
<h5 id="全站加速"><a href="#全站加速" class="headerlink" title="全站加速"></a>全站加速</h5><blockquote>
<p>全站加速（Dynamic Route for Content Delivery  Network）是阿里云自主研发的融合了动态加速和静态加速技术的CDN产品。该产品一站式解决了页面动静态资源混杂、跨运营商、网络不稳定、单线源站、突发流量、网络拥塞等诸多因素导致的响应慢、丢包、服务不稳定的问题，提升全站性能和用户体验。</p>
<p><strong>工作原理</strong></p>
<p>阿里云全站加速通过智能路由区分客户请求内容，实现动静态加速。通过架构图，您可以了解全站加速的工作原理。</p>
<img src="https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/5931788951/p6063.png" style="zoom: 40%;" />

<ul>
<li>智能区分动静态内容：域名接入阿里云全站加速后，通过域名访问的动静态内容将被智能识别并区分。</li>
<li>动静态内容同时加速：静态内容使用阿里云CDN加速，缓存在CDN节点上，供您就近访问。动态内容通过 <strong>智能路由优化</strong>、<strong>协议优化</strong> 等动态加速技术快速回源获取。</li>
</ul>
<p><strong>全站加速与CDN对比</strong></p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210414100053078.png" alt="image-20210414100053078" style="zoom: 80%;" />


</blockquote>
<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>SSH is a program for logging into a remote machine and for excuting commands on a remote machine.</p>
<p>It’s intended to provide secure encrypted communications between two untrusted hosts over and insecure network.</p>
<p>X11 connections, arbitrary TCP ports and UNIX-domain sockets can also be forwarded over the secure channel.</p>
<h4 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h4><p>The OpenSSH SSH client supports SSH protocol 2.</p>
<p>Five available authentication methods: GSSAPI-based / host-based / public key / challenge-response and password.</p>
<h5 id="Host-based"><a href="#Host-based" class="headerlink" title="Host-based"></a>Host-based</h5><p>If the machine the user logs in from is listed in <code>/etc/hosts.equiv</code> or <code>/etc/ssh/shosts.equiv</code> on the remote machine, the user is non-root and the user names are the same on both sides, or if the files <code>~/.rhosts</code> or <code>~/.shosts</code> exist in the user’s home directory on the remote machine and contain a line containing the name of the client machine and the name of the user on that machine, the user is considered for login.  Additionally, the server must be able to verify the client’s host key (see the description of <code>/etc/ssh/ssh_known_hosts</code> and <code>~/.ssh/known_hosts</code>, below) for login to be permitted.  This authentication method closes security holes due to IP spoofing, DNS spoofing, and routing spoofing.  </p>
<p>[<strong>Note to the administrator</strong>: <code>/etc/hosts.equiv</code>, <code>~/.rhosts</code>, and the rlogin/rsh protocol in general, are inherently insecure and should be disabled if security is desired.]</p>
<h5 id="Public-key"><a href="#Public-key" class="headerlink" title="Public key"></a>Public key</h5><p>The scheme is based on public-key cryptography, using cryptosystems where encryption and decryption are done using separate keys, and it is unfeasible to derive the decryption key from the encryption key.  The idea is that each user creates a public/private key pair for authentication purposes. </p>
<p><em><strong>The server knows the public key, and only the user knows the private key.</strong></em>  ssh implements public key authentication protocol automatically, using one of the <strong>DSA</strong>, <strong>ECDSA</strong>, <strong>Ed25519</strong> or <strong>RSA</strong> algorithms.  The HISTORY section of ssl(8) <a target="_blank" rel="noopener" href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&sektion=8#HISTORY">[i]</a> on non-OpenBSD systems contains a brief discussion of the DSA and RSA algorithms.</p>
<p>The file <code>~/.ssh/authorized_keys</code> lists the public keys that are permitted for logging in.  When the user logs in, the ssh program tells the server which key pair it would like to use for authentication.  The client proves that it has access to the private key and the server checks that the corresponding public key is authorized to accept the account.</p>
<p>The user should then <mark>copy the public key to <code>~/.ssh/authorized_keys</code> in his/her home directory on the remote machine.</mark>  The authorized_keys file corresponds to the conventional <code>~/.rhosts</code> file, and has one key per line, though the lines can be very long. After this, the user can log in without giving the password.</p>
<h6 id="ssh-keygen"><a href="#ssh-keygen" class="headerlink" title="ssh-keygen"></a>ssh-keygen</h6><p>To generate a public key for ssh, we need to use:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-kegen -t rsa</span><br></pre></td></tr></table></figure>

<p>The terminal will ask if <code>/root/.ssh/id_rsa</code> the file you save the key:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;root&#x2F;.ssh&#x2F;id_rsa):</span><br></pre></td></tr></table></figure>

<p>The terminal will require you to enter the <em>passphrase</em> twice.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure>

<p><em><strong>Identification</strong></em> is the private key used by the server(the remote machine). And the <em><strong>public key</strong></em> is generated for the client to authenticate while logging in the server.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Your identification has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">Your public key has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256: *******</span><br><span class="line">The key&#39;s randomart imge is:</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The user creates his/her key pair by running ssh-keygen(1).  </p>
<p>This stores the <em><strong>private key</strong></em> in <code>~/.ssh/id_dsa</code> (DSA), <code>~/.ssh/id_ecdsa</code> (ECDSA), <code>~/.ssh/id_ecdsa_sk</code> (authenticator-hosted ECDSA), <code>~/.ssh/id_ed25519</code> (Ed25519), <code>~/.ssh/id_ed25519_sk</code> (authenticator-hosted Ed25519), or <code>~/.ssh/id_rsa</code> (RSA) .</p>
<p>The the <em><strong>public key</strong></em> stores in <code>~/.ssh/id_dsa.pub</code> (DSA), <code>~/.ssh/id_ecdsa.pub</code> (ECDSA), <code>~/.ssh/id_ecdsa_sk.pub</code> (authenticator-hosted ECDSA), <code>~/.ssh/id_ed25519.pub</code> (Ed25519), <code>~/.ssh/id_ed25519_sk.pub</code> (authenticator-hosted Ed25519), or <code>~/.ssh/id_rsa.pub</code> (RSA) in the <strong>user’s home directory</strong>.</p>
</blockquote>
<p>Check and copy your <code>.pub</code> file to the local computer.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh/</span><br><span class="line">vim id_rsa.pub</span><br></pre></td></tr></table></figure>



<h6 id="Permissions-0644"><a href="#Permissions-0644" class="headerlink" title="Permissions 0644"></a>Permissions 0644</h6><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210423135807684.png" alt="image-20210423135807684" style="zoom: 80%;" />

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 0600 ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>













<h4 id="Login-Format"><a href="#Login-Format" class="headerlink" title="Login Format"></a>Login Format</h4><p><code>user@hostname</code> : <code>root@qq.com</code></p>
<p><code>ssh://root@hostname:port</code> : <code>ssh://root@qq.com:666</code></p>
<h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p>基于 SSL 证书，可将站点由 HTTP（Hypertext Transfer Protocol）切换到 HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer），即基于安全套接字层（SSL）进行安全数据传输的加密版 HTTP 协议。</p>
<h4 id="SSL优势"><a href="#SSL优势" class="headerlink" title="SSL优势"></a>SSL优势</h4><ul>
<li><p><strong>防流量劫持：</strong>全站 HTTPS 是根治运营商、中间人流量劫持的解决方案，不仅可以杜绝网页中显示的小广告，更可以保护用户隐私安全。</p>
</li>
<li><p><strong>提升搜索排名：</strong>采用 HTTPS 可以帮忙搜索排名的提升，提高站点的可信度和品牌形象。</p>
</li>
<li><p><strong>杜绝钓鱼网站：</strong>HTTPS 地址栏绿色图标可以帮助用户识别出钓鱼网站，保障用户和企业的利益不受损害，增强用户信任。</p>
</li>
</ul>
<h4 id="SSL证书签发"><a href="#SSL证书签发" class="headerlink" title="SSL证书签发"></a>SSL证书签发</h4><p>域名型证书由以下品牌提供自动审核认证，快速签发。</p>
<ul>
<li><strong>SecureSite</strong>：全球最大的信息安全厂商和服务商，最权威的数字证书颁发机构，为企业、个人用户和服务供应商提供广泛的内容和网络安全解决方案，全球500强中有93%选择了 VeriSign SSL 数字证书，目前均由 SecureSite 提供服务。</li>
<li><strong>TrustAsia®（亚洲诚信）</strong>：亚数信息科技（上海）有限公司应用于信息安全领域的品牌，是 SecureSite 的白金合作伙伴，专业为企业提供包含数字证书在内的所有网络安全服务。</li>
<li><strong>GeoTrust</strong>：GeoTrust  是全球第二大数字证书颁发机构（CA），也是身份认证和信任认证领域的领导者，该公司各种先进的技术使得任何大小的机构和公司都能安全地低成本地部署  SSL 数字证书和实现各种身份认证。从2001年成立到2006年占领全球市场25%的市场份额，VeriSign 于2006年5月 -  2006年9月以1.25亿美元收购 GeoTrust，目前也同为 SecureSite 旗下 SSL 证书的<strong>性价比高</strong>的品牌。</li>
<li><strong>GlobalSign</strong>： GlobalSign 成立于1996年，是一家声誉卓著，备受信赖的 CA  中s心和 SSL 数字证书提供商，在全球总计颁发超过2000万张数字证书。GlobalSign  的专业实力获得中国网络市场众多服务器、域名注册商、系统服务供应商的青睐，成为其数字证书服务的合作伙伴。</li>
<li><strong>WoTrus（沃通）</strong>：沃通电子认证服务有限公司（WoTrus CA Limited）是同时获得国内电子认证服务许可证（由工信部颁发）和通过国际认证的证书颁发机构（CA）。专业为企业提供权威第三方数字身份认证服务，颁发全球信任的各种数字证书产品。</li>
<li><strong>DNSPod 品牌国密标准（SM2）证书</strong>：DNSPod 为腾讯云自有品牌，采用国密标准，并且是纯国产数字证书，由国内知名 CA 机构提供基础设置支撑，敏捷高效，同时满足国家监管需求。</li>
</ul>
<h4 id="SSL证书品牌差异"><a href="#SSL证书品牌差异" class="headerlink" title="SSL证书品牌差异"></a>SSL证书品牌差异</h4><p>不同品牌的证书在浏览器地址栏、加密强度、赔付保障上均存在差异，最重要的差异点在于根证书。</p>
<p>例如，GeoTrust 通配符是 GeoTrust 根证书签发的，而 SecureSite 通配符是 SecureSite 根证书签发的。<mark>Digicert  根证书可以兼容市面上所有的浏览器，对移动端的支持也是最好的</mark>，而 Trustasia 通配符也是 Digicert  根证书签发的，GlobalSign 通配符是 GlobalSign 的根证书签发的，DNSPod 是由 Wotrus  的根证书签发的，Wotrus 通配符是 Sectigo 的根证书签发的。</p>
<blockquote>
<p><strong>通配符：</strong></p>
<p><strong>根证书：</strong></p>
</blockquote>
<p>单纯从技术角度，SecureSite（原 Verisign）和 GeoTrust 的区别如下：</p>
<ul>
<li>算法支持上 SecureSite（支持 RSA、DSA、ECC 三种算法）优于 GeoTrust（支持 RSA、DSA 两种算法）。</li>
<li>兼容性 SecureSite 优于 GeoTrust，SecureSite 可兼容市面上所有的浏览器，对移动端的支持也是极好的。</li>
<li>OCSP 响应速度上 SecureSite 优于 GeoTrust。</li>
<li>CA 安全性方面 SecureSite 优于 GeoTrust，SecureSite 是国际知名安全厂商，CA 的安全级别也是国际第一的安全系数。</li>
<li>SecureSite 证书除实现加密传输以外，还另外有恶意软件扫描和漏洞评估的附加功能。</li>
<li>SecureSite 对证书有商业保险赔付保障，金额最高为175万美金，GeoTrust 最高为150万美金。</li>
</ul>
<h4 id="SSL证书格式"><a href="#SSL证书格式" class="headerlink" title="SSL证书格式"></a>SSL证书格式</h4><p>SSL证书分为 <code>pem</code> 和 <code>key</code>  这两种格式，分别存储的是 <strong>证书base64加密</strong> 和 <strong>私钥base64加密</strong> 还有 格式分割符，也就是说pem存的是证书，key 存的是私钥。</p>
<p>如pem中的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">略</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure>

<p> <code>-----BEGIN CERTIFICATE-----</code>  和 <code>-----END CERTIFICATE-----</code> 为分割分，表示在这两个中间存的是证书的base64编码</p>
<p>备注：</p>
<p>如key中的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">略</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>

<p><code>-----BEGIN RSA PRIVATE KEY-----</code> 和 <code>-----END RSA PRIVATE KEY-----</code> 为分割符号，表示在这两个中间存的是私钥的base64编码</p>
<p>备注：CERTIFICATE 单词代表证书的意思；PRIVATE KEY 单词代表 私钥、秘钥的意思。</p>
<h4 id="SSL证书配置"><a href="#SSL证书配置" class="headerlink" title="SSL证书配置"></a>SSL证书配置</h4><p>以下以“阿里云OSS”及“腾讯云COS”的对象存储（bucket）与域名（name）绑定过程中，对SSL证书的配置为例，进行解释和说明，不对详细步骤进行描述，仅解释原理。</p>
<h5 id="域名及Bucket绑定"><a href="#域名及Bucket绑定" class="headerlink" title="域名及Bucket绑定"></a>域名及Bucket绑定</h5><p>阿里云及腾讯云都可以申请对象存储和域名，所申请的域名按正规流程均需要经过挂载至某个服务器进行备案（国内公安要求）后才可以与对象存储绑定，进而颁发证书给挂载至对象存储的域名。</p>
<h5 id="SSL证书申请及配置"><a href="#SSL证书申请及配置" class="headerlink" title="SSL证书申请及配置"></a>SSL证书申请及配置</h5><p>若域名互相绑定后未配置SSL则会导致https访问失败，配置SSL需要给自己的域名申请免费SSL证书，阿里云及腾讯云都可以免费申请为期一年的证书，按流程填写信息并等待审核下发即可；获得证书后需要选择“其他”类型的证书进行下载。证书中需要的 <strong>公钥</strong> 即 <code>.pem</code> 格式文件，而 <strong>私钥</strong> 即 <code>.key</code> 格式文件，分别填写到Bucket的域名管理页面内下的 <strong>证书上传</strong> 中。</p>
<p>流程大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	开始 --&gt; Bucket申请--可选CDN加速开启--&gt; 获得Bucket域名或CDN加速域名 --CNAME解析--&gt;域名绑定--&gt;结束</span><br><span class="line">	开始 --&gt; 域名申请 --&gt; 域名备案 --CNAME解析--&gt; 域名绑定</span><br><span class="line">	域名申请 --&gt; SSL证书申请 --&gt; 下载证书 --复制粘贴至Bucket的域名管理页面--&gt; 证书上传--&gt; 结束</span><br></pre></td></tr></table></figure>

<h3 id="DDos"><a href="#DDos" class="headerlink" title="DDos"></a>DDos</h3><h4 id="常见流量攻击"><a href="#常见流量攻击" class="headerlink" title="常见流量攻击"></a>常见流量攻击</h4><h5 id="SYN-Flood"><a href="#SYN-Flood" class="headerlink" title="SYN Flood"></a>SYN Flood</h5><p>Flood即洪水之意，SYN是指TCP通信中用于建立连接时标志位之一。</p>
<p>此时需要用到 TCP Three-way Handshake的知识点，当需要建立连接时：</p>
<ul>
<li>Client向Server <mark>发去SYN标志</mark></li>
<li>Server收到后向Client <mark>回复SYN和ACK标志</mark></li>
<li>Client收到由Server发过来的SYN和ACK后 <mark>回复一个ACK标志</mark></li>
</ul>
<p>以上即为三次握手协议的主要流程，其实只有Server收到该ACK时，才标志着双方建立连接。以下介绍几种”意外“情况。</p>
<p><strong>情况一：</strong>当Client第一次收到SYN和ACK时，Client就单方面“认为”自己已经和Server建立连接了。但网络通信时并不能百分百保证可靠，假如Client发了ACK，但Server并未收到，则Server就并不”认为“自己与Client建立了连接。Server和Client都有自己的定时器，在发送数据之后就开始计时，不管如何，此时Client都已经发了ACK了，“觉得”自己已经建立了连接，而Server不然，Server就会再次发送SYN和ACK以请求Client的确认。</p>
<p><strong>情况二：</strong>多个Client向Server同时发送SYN请求，Server收到信息后立即回复SYN和ACK，并且需要为每一个Client设立一个计时器以等待他们的ACK信息。假如此刻Client的数量非常多且每一个都发送了一次SYN请求，则Server的计时器则会立刻被用光，导致任何正常请求都无法连接。（针对此种攻击方式，提出了二次SYN当成一次SYN的防攻击手段，即Client需要连续发两次SYN在标明自己是真的“有意”连接，不是恶意发送攻击的，但此类二次验证方式比较简单，仍然容易被模仿）</p>
<h5 id="ICMP-Flood"><a href="#ICMP-Flood" class="headerlink" title="ICMP Flood"></a>ICMP Flood</h5><p>ICMP也算是网络层协议的一员，封装在IP协议中，是IP协议的附属协议，可以直接被用户进程直接使用。</p>
<p>此处的ICMP Flood指的是利用集群设备在同一时间使用 ping 功能对目标主机发起请求，强制主机进行回复，致使目标主机瘫痪。</p>
<p>以下为ping的英文解释</p>
<blockquote>
<p><em>PING - Send ICMP ECHO_REQUEST to network hosts</em></p>
<p><em>Ping uses the ICMP protocol’s mandatory ECHO_REQUEST datagram to elicit  an ICMP ECHO_RESPONSE from a host or gateway.</em></p>
<p>—— from ‘manual of ping’ in linux</p>
</blockquote>
<h3 id="选择数据库服务器的五个原则"><a href="#选择数据库服务器的五个原则" class="headerlink" title="选择数据库服务器的五个原则"></a>选择数据库服务器的五个原则</h3><h4 id="1-高性能原则"><a href="#1-高性能原则" class="headerlink" title="1)高性能原则"></a>1)高性能原则</h4><p>保证所选购的服务器，不仅能够满足运营系统的运行和业务处理的需要，而且能够满足一定时期业务量的增长。一般可以根据经验公式计算出所需的服务器TpmC值(Tpmc是衡量计算机系统的事务处理能力的程序)，然后比较各服务器厂商和TPC组织公布的TpmC值，选择相应的机型。同时，用服务器的市场价/报价除去计算出来的TpmC值得出单位TpmC值的价格，进而选择高性能价格比的服务器。</p>
<p><strong>结论：</strong>服务器处理器性能很关键，CPU的主频要高，要有较大的缓存</p>
<h4 id="2-可靠性原则"><a href="#2-可靠性原则" class="headerlink" title="2)可靠性原则"></a>2)可靠性原则</h4><p>可靠性原则是所有选择设备和系统中首要考虑的，尤其是在大型的、有大量处理要求的、需要长期运行的系统上。考虑服务器系统的可靠性，不仅要考虑服务器单个节点的可靠性或稳定性，而且要考虑服务器与相关辅助系统之间连接的整体可靠性，如：网络系统、安全系统、远程打印系统等。在必要时，还应考虑对关键服务器采用集群技术，如：双机热备份或集群并行访问技术，甚至采用可能的完全容错机。</p>
<p><strong>结论：</strong>服务器要具备冗余技术，同时像硬盘、网卡、内存、电源此类设备要以稳定耐用为主，性能其次。</p>
<h4 id="3-可扩展性原则"><a href="#3-可扩展性原则" class="headerlink" title="3)可扩展性原则"></a>3)可扩展性原则</h4><p>保证所选购的服务器具有优秀的可扩展性原则。因为服务器是所有系统处理的核心，要求具有大数据吞吐速率，包括：I/O速率和网络通讯速率，而且服务器需要能够处理一定时期的业务发展所带来的数据量，需要服务器能够在相应时间对其自身根据业务发展的需要进行相应的升级，如：CPU型号升级、内存扩大、硬盘扩大、更换网卡、增加终端数目、挂接磁盘阵列或与其他服务器组成对集中数据的并发访问的集群系统等。这都需要所选购的服务器在整体上具有一个良好的可扩充余地。一般数据库和计费应用服务器在大型计费系统的设计中就会采用集群方式来增加可靠性，其中挂接的磁盘存储系统，根据数据量和投资考虑，可以采用DAS、NAS或SAN等实现技术。</p>
<p><strong>结论：</strong>服务器的IO要高，否则在CPU和内存都是高性能的情况下，会出现瓶颈。除此之外，服务器的扩展性要好，为的是满足企业在日后发展的需要。</p>
<h4 id="4-安全性原则"><a href="#4-安全性原则" class="headerlink" title="4)安全性原则"></a>4)安全性原则</h4><p>服务器处理的大都是相关系统的核心数据，其上存放和运行着关键的交易和重要的数据。这些交易和数据对于拥有者来说是一笔重要的资产，他们的安全性就非常敏感。服务器的安全性与系统的整体安全性密不可分，如：网络系统的安全、数据加密、密码体制等。服务器需要在其自身，包括软硬件，都应该从安全的角度上设计考虑，在借助于外界的安全设施保障下，更要保证本身的高安全性。</p>
<p><strong>结论：</strong>首先从服务器的材料上来说要具备高硬度高防护性等条件，其次服务器的冷却系统和对环境的适应能力要强，这样才能够在硬件上满足服务器安全的要求。</p>
<h4 id="5-可管理性原则"><a href="#5-可管理性原则" class="headerlink" title="5)可管理性原则"></a>5)可管理性原则</h4><p>服务器既是核心又是系统整体中的一个节点部分，就像网络系统需要进行管理维护一样，也需要对服务器进行有效的管理。这需要服务器的软硬件对标准的管理系统支持，尤其是其上的操作系统，也包括一些重要的系统部件。</p>
<p><strong>结论：</strong>尽量选择支持系统多的服务器，因为服务器兼容的系统越多，你就可以拥有更大选择空间。</p>
<p><strong>总结：</strong>首先数据库服务器的性能要求很高，所以在CPU，内存，以及硬盘等方面都有很高的要求，其次是存储，存储要具备良好的稳定性，来满足长期运作的服务器随时读取写入等操作不会出现错误。最后希望通过总结的以上五点，帮助你挑选你所需要的数据库服务器。</p>
<h3 id="服务器产品结构"><a href="#服务器产品结构" class="headerlink" title="服务器产品结构"></a>服务器产品结构</h3><p>U是厚度要求，是一种表示服务器外部尺寸的单位，是unit的缩略语，详细的尺寸由作为业界团体的美国电子工业协会（EIA）所决定。 <code>1U=4.445cm</code> ， 1U至7U的产品结构是指外形满足EIA规格、厚度为4.445cm-31.115cm的服务器。</p>
<p>多少U是指服务器的尺寸大小。在专业机房，托管的服务器一般是放在机柜里面的，机柜从上到下有很多单位格，我们叫一格为1U(U是unit的意思)。如果一个机柜是42U高，如果每2个服务器中间留1U空间，那么可以放21个1U的主机。同样情况放2U主机就只能放14台了。</p>
<p>很多机房托管费用会按所占U的多少来收费的。</p>
<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>NAT（Network Address Translation，网络地址转换）是1994年提出的。</p>
<p>当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。<br>这种方法需要在专用网（私网IP）连接到因特网（公网IP）的路由器上 <mark>安装NAT软件</mark> 。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址（公网IP地址）。</p>
<p>这样，所有使用本地地址（私网IP地址）的主机在和外界通信时，都要在 <strong>NAT路由器</strong> 上将其本地地址转换成全球IP地址，才能和因特网连接。<br>另外，这种通过使用少量的全球IP地址（公网IP地址）代表较多的私有IP地址的方式，将有助于减缓可用的IP地址空间的枯竭。在RFC 2663中有对NAT的说明。</p>
<p><strong>举例</strong>：</p>
<blockquote>
<p>在内网下 <code>192.168.0.100</code> 这台电脑上开了一个http网站服务，那么端口默认是 <code>80</code>，在内网下你直接通过浏览器输入 <code>http://192.168.0.100</code> 直接打开网站，这个内网链接地址在外是打不开的。<br>通过内网穿透后平台 <strong>分配</strong> 一个公网地址（给内网的设备）,比如 <code>http://test123k.nat.nsloop.com</code> 用户在外时就可以通过这个公网地址打开网站。</p>
</blockquote>
<p>要使用内网穿透服务，需要先确定好 <mark>内网要映射的IP和端口</mark> ，穿透成功后内网的IP+端口，映射成为公网的域名+端口（如需要IP，可以在CMD命令下PING 服务器的IP地址）<br>穿透前: 访问IP地址 <code>192.168.0.100</code> 端口 <code>3389</code> 穿透后：访问地址 <code>s0.nsloop.com</code> 端口 <code>12843</code> 。</p>
<p>内网穿透是通过服务器中继转发数据来实现的将内网端口映射到公网，速度上没有P2P直连的快。</p>
<h3 id="异地组网"><a href="#异地组网" class="headerlink" title="异地组网"></a>异地组网</h3><h3 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h3><p>内网穿透（Intranet penetration），也即 NAT 穿透，进行 NAT 穿透是为了使具有某一个特定源 IP 地址和源端口号的数据包 <mark>不被 NAT 设备屏蔽而正确路由到内网主机</mark> 。</p>
<p>UDP 内网穿透的实质是利用路由器上的NAT 系统。NAT 是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型 Internet 接入方式和各种类型的网络中。<mark>NAT可以完成重用地址，并且对于内部的网络结构可以实现对外隐蔽</mark>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/20/Networking/Unix%20domain%20socket%20%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/20/Networking/Unix%20domain%20socket%20%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Unix domain socket 简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-20 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-20T23:58:32+08:00">2021-04-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-29 00:52:30" itemprop="dateModified" datetime="2021-04-29T00:52:30+08:00">2021-04-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Networking/" itemprop="url" rel="index"><span itemprop="name">Networking</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sparkdev/p/8359028.html">cnblogs.com</a></p>
<p><strong>Unix domain socket 又叫 IPC(inter-process communication 进程间通信) socket，用于实现同一主机上的进程间通信。</strong>socket 原本是为网络通讯设计的，但后来在 socket 的框架上发展出一种 IPC 机制，就是 UNIX domain socket。虽然网络  socket 也可用于同一台主机的进程间通讯(通过 loopback 地址 127.0.0.1)，但是 UNIX domain socket  用于 IPC  更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。这是因为，IPC  机制本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。<br>UNIX domain socket 是全双工的，API 接口语义丰富，相比其它 IPC 机制有明显的优越性，目前已成为使用最广泛的 IPC 机制，比如 X Window 服务器和 GUI 程序之间就是通过 UNIX domain socket 通讯的。<br>Unix domain socket 是 POSIX 标准中的一个组件，所以不要被名字迷惑，linux 系统也是支持它的。</p>
<p>下面通过一个简单的 demo 来理解相关概念。程序分为服务器端和客户端两部分，它们之间通过 unix domain socket 进行通信。</p>
<h1 id="服务器端程序"><a href="#服务器端程序" class="headerlink" title="服务器端程序"></a>服务器端程序</h1><p>下面是一个非常简单的服务器端程序，它从客户端读字符，然后将每个字符转换为大写并回送给客户端：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stddef.h&gt;  </span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;  </span><br><span class="line">#include &lt;sys&#x2F;un.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;ctype.h&gt;   </span><br><span class="line"> </span><br><span class="line">#define MAXLINE 80  </span><br><span class="line"> </span><br><span class="line">char *socket_path &#x3D; &quot;server.socket&quot;;  </span><br><span class="line"> </span><br><span class="line">int main(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_un serun, cliun;  </span><br><span class="line">    socklen_t cliun_len;  </span><br><span class="line">    int listenfd, connfd, size;  </span><br><span class="line">    char buf[MAXLINE];  </span><br><span class="line">    int i, n;  </span><br><span class="line"> </span><br><span class="line">    if ((listenfd &#x3D; socket(AF_UNIX, SOCK_STREAM, 0)) &lt; 0) &#123;  </span><br><span class="line">        perror(&quot;socket error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    memset(&amp;serun, 0, sizeof(serun));  </span><br><span class="line">    serun.sun_family &#x3D; AF_UNIX;  </span><br><span class="line">    strcpy(serun.sun_path, socket_path);  </span><br><span class="line">    size &#x3D; offsetof(struct sockaddr_un, sun_path) + strlen(serun.sun_path);  </span><br><span class="line">    unlink(socket_path);  </span><br><span class="line">    if (bind(listenfd, (struct sockaddr *)&amp;serun, size) &lt; 0) &#123;  </span><br><span class="line">        perror(&quot;bind error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">    printf(&quot;UNIX domain socket bound\n&quot;);  </span><br><span class="line">      </span><br><span class="line">    if (listen(listenfd, 20) &lt; 0) &#123;  </span><br><span class="line">        perror(&quot;listen error&quot;);  </span><br><span class="line">        exit(1);          </span><br><span class="line">    &#125;  </span><br><span class="line">    printf(&quot;Accepting connections ...\n&quot;);  </span><br><span class="line"> </span><br><span class="line">    while(1) &#123;  </span><br><span class="line">        cliun_len &#x3D; sizeof(cliun);         </span><br><span class="line">        if ((connfd &#x3D; accept(listenfd, (struct sockaddr *)&amp;cliun, &amp;cliun_len)) &lt; 0)&#123;  </span><br><span class="line">            perror(&quot;accept error&quot;);  </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        while(1) &#123;  </span><br><span class="line">            n &#x3D; read(connfd, buf, sizeof(buf));  </span><br><span class="line">            if (n &lt; 0) &#123;  </span><br><span class="line">                perror(&quot;read error&quot;);  </span><br><span class="line">                break;  </span><br><span class="line">            &#125; else if(n &#x3D;&#x3D; 0) &#123;  </span><br><span class="line">                printf(&quot;EOF\n&quot;);  </span><br><span class="line">                break;  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            printf(&quot;received: %s&quot;, buf);  </span><br><span class="line"> </span><br><span class="line">            for(i &#x3D; 0; i &lt; n; i++) &#123;  </span><br><span class="line">                buf[i] &#x3D; toupper(buf[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">            write(connfd, buf, n);  </span><br><span class="line">        &#125;  </span><br><span class="line">        close(connfd);  </span><br><span class="line">    &#125;  </span><br><span class="line">    close(listenfd);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>简单介绍一下这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int family, int type, int protocol);</span><br></pre></td></tr></table></figure>

<p>使用 UNIX domain socket 的过程和网络 socket 十分相似，也要先调用 socket() 创建一个 socket 文件描述符.<br><strong>family</strong> 指定为 AF_UNIX，使用 AF_UNIX 会在系统上创建一个 socket 文件，不同进程通过读写这个文件来实现通信。<br><strong>type</strong> 可以选择 SOCK_DGRAM 或 SOCK_STREAM。SOCK_STREAM 意味着会提供按顺序的、可靠、双向、面向连接的比特流。SOCK_DGRAM 意味着会提供定长的、不可靠、无连接的通信。<br><strong>protocol</strong> 参数指定为 0 即可。<br>UNIX domain socket 与网络 socket 编程最明显的不同在于地址格式不同，用结构体 sockaddr_un 表示，网络编程的  socket 地址是 IP 地址加端口号，而 UNIX domain socket 的地址是一个 socket  类型的文件在文件系统中的路径，这个 socket 文件由 bind() 调用创建，如果调用 bind() 时该文件已存在，则 bind()  错误返回。因此，一般在调用 bind() 前会检查 socket 文件是否存在，如果存在就删除掉。<br>网络 socket 编程类似，在 bind 之后要 listen，表示通过 bind 的地址（也就是 socket 文件）提供服务。<br>接下来必须用 accept() 函数初始化连接。accept() 为每个连接创立新的套接字并从监听队列中移除这个连接。</p>
<h1 id="客户端程序"><a href="#客户端程序" class="headerlink" title="客户端程序"></a>客户端程序</h1><p>下面是客户端程序，它接受用户的输入，并把字符串发送给服务器，然后接收服务器返回的字符串并打印：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stddef.h&gt;  </span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;  </span><br><span class="line">#include &lt;sys&#x2F;un.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line"> </span><br><span class="line">#define MAXLINE 80  </span><br><span class="line"> </span><br><span class="line">char *client_path &#x3D; &quot;client.socket&quot;;  </span><br><span class="line">char *server_path &#x3D; &quot;server.socket&quot;;  </span><br><span class="line"> </span><br><span class="line">int main() &#123;  </span><br><span class="line">    struct  sockaddr_un cliun, serun;  </span><br><span class="line">    int len;  </span><br><span class="line">    char buf[100];  </span><br><span class="line">    int sockfd, n;  </span><br><span class="line"> </span><br><span class="line">    if ((sockfd &#x3D; socket(AF_UNIX, SOCK_STREAM, 0)) &lt; 0)&#123;  </span><br><span class="line">        perror(&quot;client socket error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F; 一般显式调用bind函数，以便服务器区分不同客户端  </span><br><span class="line">    memset(&amp;cliun, 0, sizeof(cliun));  </span><br><span class="line">    cliun.sun_family &#x3D; AF_UNIX;  </span><br><span class="line">    strcpy(cliun.sun_path, client_path);  </span><br><span class="line">    len &#x3D; offsetof(struct sockaddr_un, sun_path) + strlen(cliun.sun_path);  </span><br><span class="line">    unlink(cliun.sun_path);  </span><br><span class="line">    if (bind(sockfd, (struct sockaddr *)&amp;cliun, len) &lt; 0) &#123;  </span><br><span class="line">        perror(&quot;bind error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    memset(&amp;serun, 0, sizeof(serun));  </span><br><span class="line">    serun.sun_family &#x3D; AF_UNIX;  </span><br><span class="line">    strcpy(serun.sun_path, server_path);  </span><br><span class="line">    len &#x3D; offsetof(struct sockaddr_un, sun_path) + strlen(serun.sun_path);  </span><br><span class="line">    if (connect(sockfd, (struct sockaddr *)&amp;serun, len) &lt; 0)&#123;  </span><br><span class="line">        perror(&quot;connect error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    while(fgets(buf, MAXLINE, stdin) !&#x3D; NULL) &#123;    </span><br><span class="line">         write(sockfd, buf, strlen(buf));    </span><br><span class="line">         n &#x3D; read(sockfd, buf, MAXLINE);    </span><br><span class="line">         if ( n &lt; 0 ) &#123;    </span><br><span class="line">            printf(&quot;the other side has been closed.\n&quot;);    </span><br><span class="line">         &#125;else &#123;    </span><br><span class="line">            write(STDOUT_FILENO, buf, n);    </span><br><span class="line">         &#125;    </span><br><span class="line">    &#125;   </span><br><span class="line">    close(sockfd);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>与网络 socket 编程不同的是，UNIX domain socket 客户端一般要显式调用 bind  函数，而不依赖系统自动分配的地址。客户端 bind 一个自己指定的 socket 文件名的好处是，该文件名可以包含客户端的 pid  等信息以便服务器区分不同的客户端。</p>
<h1 id="运行上面的程序"><a href="#运行上面的程序" class="headerlink" title="运行上面的程序"></a>运行上面的程序</h1><p>分别把服务器端程序和客户端程序保存为 server.c 和 client.c 文件，并编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc server.c -o server</span><br><span class="line">$ gcc client.c -o client</span><br></pre></td></tr></table></figure>

<p>先启动服务器端程序，然后启动客户端程序输入字符串并回车：</p>
<p><img src="https://images2017.cnblogs.com/blog/952033/201801/952033-20180126125928506-239880118.png" alt="img"></p>
<p>还不错，客户端得到了服务器端返回的大写字符串。接下来看看当前目录下的文件：</p>
<p><img src="https://images2017.cnblogs.com/blog/952033/201801/952033-20180126125951834-1641586991.png" alt="img"></p>
<p>哈哈，多了两个 socket 文件。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Unix domain socket 主要用于同一主机上的进程间通信。与主机间的进程通信不同，它不是通过 “IP地址 + TCP或UDP端口号” 的方式进程通信，而是使用 socket 类型的文件来完成通信，因此在稳定性、可靠性以及效率方面的表现都很不错。</p>
<p><strong>参考：</strong><br><a target="_blank" rel="noopener" href="http://docs.linuxtone.org/ebooks/C&CPP/c/ch37s04.html">UNIX Domain Socket IPC</a><br>[<a target="_blank" rel="noopener" href="http://blog.csdn.net/tzshlyt/article/details/53391655">linux] unix domain socket 例子</a></p>
<p>​          </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/19/Signal/MIC%20LEVEL%20vs%20LINE%20LEVEL%20Audio%20Levels%20Explained/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/19/Signal/MIC%20LEVEL%20vs%20LINE%20LEVEL%20Audio%20Levels%20Explained/" class="post-title-link" itemprop="url">MIC LEVEL vs LINE LEVEL--Audio Levels Explained</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-19 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-19T23:58:32+08:00">2021-04-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-29 00:54:07" itemprop="dateModified" datetime="2021-04-29T00:54:07+08:00">2021-04-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Signal/" itemprop="url" rel="index"><span itemprop="name">Signal</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://audiouniversityonline.com/mic-level-vs-line-level-audio-levels-explained/">audiouniversityonline.com</a></p>
<p>In this post, you’ll learn the difference between microphone level  and line level, as well as other levels commonly used in professional  audio such as instrument level and speaker level.</p>
<p>What is the difference between microphone level and line level?</p>
<p><strong>Microphones and instruments output very low signal voltages,  while +4dBu is the line level is the standard voltage level for  professional audio equipment.</strong></p>
<p><strong>In pro audio, you’ll generally be dealing with four types of  audio signals: Mic Level, Instrument Level, Line Level, and Speaker  Level</strong></p>
<h1 id="Microphone-Level"><a href="#Microphone-Level" class="headerlink" title="Microphone Level"></a>Microphone Level</h1><p>A microphone captures sound by converting pressure changes in the air into electrical currents in a wire. The electrical currents created by  these pressure changes are very subtle. That’s why we use a microphone  preamp – to amplify the signal to a more usable level.</p>
<p>A microphone preamp takes in a mic level signal, amplifies it, and  outputs a line level signal. This is controlled by the gain knob on your mixing console, audio interface, or outboard mic pre.</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Mic-Level-Chart-900.jpg" alt="img" style="zoom:50%;" />

<h1 id="Instrument-Level"><a href="#Instrument-Level" class="headerlink" title="Instrument Level"></a>Instrument Level</h1><p>The pickups of an electric guitar convert the vibrations of the  strings into electrical currents. Similar to those from a microphone,  the electrical currents from a guitar pickup are very weak.</p>
<p>A preamp can also be used to boost instrument level signals to line level.</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Instrument-Level-Chart-900.jpg" alt="img" style="zoom: 50%;" />

<p>Once an input signal is brought up to line level, it is optimized for use with professional audio equipment, such as mixing consoles,  outboard effects, and amplifiers.</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Line-Level-Chart-900.jpg" alt="img" style="zoom:50%;" />

<h1 id="Professional-vs-Consumer-Line-Level"><a href="#Professional-vs-Consumer-Line-Level" class="headerlink" title="Professional vs Consumer Line Level"></a>Professional vs Consumer Line Level</h1><p>There are two standards for line level: +4 dBu (professional) and -10 dBV (consumer).</p>
<p>Watch this video to learn the difference between professional and consumer line level. I also wrote a post on <a target="_blank" rel="noopener" href="https://audiouniversityonline.com/consumer-vs-professional-audio-levels-what-is-the-difference/">professional vs consumer audio levels</a> that will help you understand the difference.</p>
<h1 id="Speaker-Level"><a href="#Speaker-Level" class="headerlink" title="Speaker Level"></a>Speaker Level</h1><p>Line level is adequate for sending signals between devices, but not  strong enough to power a speaker.In order to power a speaker, the line  level signal needs to be amplified again. </p>
<p>This can be done with a power amplifier. A power amp takes in a line  level signal, amplifies it, and outputs a speaker level signal that is  strong enough to power a speaker.</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Speaker-Level-Chart-900.jpg" alt="img" style="zoom:50%;" />

<h1 id="A-Complete-Audio-System"><a href="#A-Complete-Audio-System" class="headerlink" title="A Complete Audio System"></a>A Complete Audio System</h1><p>In a complete system, you might run a microphone through a preamp and an electric guitar through another preamp.</p>
<p>Once those signals are at line level, you can send them through  outboard effects and eventually to an amplifier, which will add enough  gain to the signal to power a speaker.</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Complete-Chart-900.jpg" alt="img" style="zoom:50%;" />




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/04/11/Web/JavaScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/11/Web/JavaScript/" class="post-title-link" itemprop="url">Javascript</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-11 23:58:32" itemprop="dateCreated datePublished" datetime="2021-04-11T23:58:32+08:00">2021-04-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-26 00:13:21" itemprop="dateModified" datetime="2021-04-26T00:13:21+08:00">2021-04-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Networking/" itemprop="url" rel="index"><span itemprop="name">Networking</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="对象的抽象"><a href="#对象的抽象" class="headerlink" title="对象的抽象"></a>对象的抽象</h2><p><strong>抽象</strong> 是指一种归纳或总结，<strong>对象</strong> 是现实世界物体特征的实体。万事万物不论大小皆可看做对象， <strong>类</strong> 则是对各种不同对象的 <em>归纳总结</em>，类是对象的 <em>抽象表示形式</em>。</p>
<blockquote>
<p>例如，男演员Jack可以看做是一个对象，女演员Rose也可以看过是一个对象，而两者会被统一归纳为Person或者Human的类（或抽象）。每一个对象都有其独特的属性（Property）或功能（Function），而归纳总结出来的类则具有不同对象的相同属性或功能。</p>
</blockquote>
<p>基于类的面向对象语言是面向对象世界里的主流。虽然大多数面向对象开发语言都使用类来完成面向对象编程，但类不是面向对象编程的实质内涵。面向对象的实质内涵是将所有业务逻辑单元都视为一个对象（即，对象是目的或结果），且类不是唯一用来完成面向对象编程的方法。</p>
<p>面向对象不能被当做面向类，否则会进入误区。对象和类的关系相当于一般程序设计语言中的 <strong>变量</strong> 和 <strong>变量类型</strong> 的关系。所以，有时类也被称为是一种数据类型，可以看做抽象数据类型的具体实现。此时的数据类型则是 **数据 **和 <strong>操作</strong> 的集合。</p>
<h2 id="面向对象与面向过程的区别"><a href="#面向对象与面向过程的区别" class="headerlink" title="面向对象与面向过程的区别"></a>面向对象与面向过程的区别</h2><p>面向过程程序设计，即结构化程序设计，诸如Pascal、C。</p>
<p>面向对象程序设计解决了结构化程序设计代码复用的难题，如C++、C#、Java、JavaScript、Python等都是。</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/image-20210413144641711.png" alt="image-20210413144641711" style="zoom: 67%;" />

<p>面向过程也是把程序定义为“数据+作用于数据的操作算法”，但最重要的区别是：面向过程编程 <mark>使用过程操作数据结构</mark>， 而面向对象编程将过程和数据结构捆绑，使对象 <mark>操作自己的数据结构</mark>。</p>
<h1 id="JavaScript的类"><a href="#JavaScript的类" class="headerlink" title="JavaScript的类"></a>JavaScript的类</h1><h2 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h2><p>JavaScript可以用关键字 <code>class</code> 进行赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一：参数赋值法，间接调用构造器赋值</span></span><br><span class="line"><span class="keyword">var</span> oRectangle = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：生成对象后单独调用赋值</span></span><br><span class="line"><span class="comment">// var oRectangle = new Rectangle();</span></span><br><span class="line"><span class="comment">// oRectangle.height = 10;</span></span><br><span class="line"><span class="comment">// oRectangle.width = 30;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(oRectangle.height, oRectangle.width)</span><br></pre></td></tr></table></figure>



<p>在MDN Web Docs中，对JavaScript类的定义如下：</p>
<blockquote>
<p>实际上，类是“特殊的函数”，就像你能够定义的函数表达式和函数声明一样，类语法有两个组成部分：**类表达式 **和 <strong>类声明</strong>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloWrold</span>(<span class="params"></span>)</span>&#123;    <span class="comment">//To use keyword `function` instead of `class` to define a class</span></span><br><span class="line">    <span class="built_in">this</span>.printInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hi! JavaScript!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> oHelloWorld = <span class="keyword">new</span> HelloWorld();    <span class="comment">// Make a new object of the class named `HelloWorld`</span></span><br><span class="line"><span class="keyword">var</span> result = oHelloWorld.printInfo();    <span class="comment">//Call the method of the object to assign</span></span><br><span class="line"><span class="built_in">document</span>.write(result);</span><br></pre></td></tr></table></figure>



<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p><strong>构造器（Constructor）</strong>，或称 <strong>构造方法</strong>，一种用于创建和初始化<code>class</code>创建的对象的特殊 <strong>方法（Methods）</strong>。<code>constructor([arguments]) &#123; ... &#125;</code>， 其中 <code>arguments</code> 看情况而定，可以省略。</p>
<p><strong>注意</strong>：</p>
<ol>
<li>在一个类中只能有一个名为 <code>constructor</code> 的特殊方法。 一个类中出现多次构造函数 (constructor)方法将会抛出一个 <code>SyntaxError</code> 错误。</li>
<li>在一个构造方法中可以使用 <code>super</code> 关键字来 <mark>调用一个父类的构造方法</mark>。</li>
<li>如果没有显式指定构造方法，则会添加默认的 constructor 方法。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">arg0, arg1</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Polygon&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.body = arg0 + arg1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> poly1 = <span class="keyword">new</span> Polygon(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(poly1.name, poly1.body);</span><br><span class="line"><span class="comment">// expected output: &quot;Polygon&quot; 30</span></span><br></pre></td></tr></table></figure>










      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/03/25/Hardware/TI/2021-03-25-TI-%E5%A4%9A%E6%A0%B8%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/25/Hardware/TI/2021-03-25-TI-%E5%A4%9A%E6%A0%B8%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">TI-Multicore 开发笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-25 23:58:32" itemprop="dateCreated datePublished" datetime="2021-03-25T23:58:32+08:00">2021-03-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-26 00:17:11" itemprop="dateModified" datetime="2021-04-26T00:17:11+08:00">2021-04-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hardware/" itemprop="url" rel="index"><span itemprop="name">Hardware</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>多核开发涉及多核通信及任务分配管理的问题，任何多核通信都需要针对具体芯片的型号及系统特性去设计。多核通信包括资源共享、竞争、同步、异步等问题；多核任务分配则关系着各核心任务均衡和RTOS系统能否及时响应的问题。</p>
<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><h2 id="并发、并行、异步、同步、共享、互斥、进程、线程"><a href="#并发、并行、异步、同步、共享、互斥、进程、线程" class="headerlink" title="并发、并行、异步、同步、共享、互斥、进程、线程"></a>并发、并行、异步、同步、共享、互斥、进程、线程</h2><h3 id="Concurrency-并发"><a href="#Concurrency-并发" class="headerlink" title="Concurrency 并发"></a>Concurrency 并发</h3><p>仅表示计算机可以同时执行多项任务，以至于如何实现“同时”执行，则有许多不同形式。</p>
<p>如，单核处理器可以通过分配时间片，轮询任务来达到多任务并发。系统让一个任务运行一段时间，在切换到另一个任务运行，如此循环往复，此过程也被称为 线程的<strong>上下文切换（Context Switching）</strong>。</p>
<h3 id="Parallelism-并行"><a href="#Parallelism-并行" class="headerlink" title="Parallelism 并行"></a>Parallelism 并行</h3><p>多个任务于同一时刻在不同的和核心上进行处理，称为并行</p>
<h3 id="Synchronization-同步"><a href="#Synchronization-同步" class="headerlink" title="Synchronization 同步"></a>Synchronization 同步</h3><p>指程序任务间的先后关系，后面一个程序必须等前一个任务执行完毕方可启动。因此，在同步中，并无并发或并行概念</p>
<h3 id="Asynchronization-异步"><a href="#Asynchronization-异步" class="headerlink" title="Asynchronization 异步"></a>Asynchronization 异步</h3><p>指不同的任务之间不会相互等待</p>
<p>对于I/O资源访问频繁的系统，宜使用异步编程，</p>
<h3 id="Mutual-Exclusion-互斥"><a href="#Mutual-Exclusion-互斥" class="headerlink" title="Mutual Exclusion 互斥"></a>Mutual Exclusion 互斥</h3><p>程序内存开销 及 线程切换开销</p>
<h2 id="堆、栈"><a href="#堆、栈" class="headerlink" title="堆、栈"></a>堆、栈</h2><p>题目所指的 heap 和 stack 在 C++ 标准中相对的术语分别是<strong>自由存储</strong>（free store，即用<code>new</code>创建对象时所分配的空间）和<strong>自动变量</strong>（automatic variable，或称为局部变量，不要与 C++11 的<code>auto</code>混淆）。</p>
<p>编程角度，要分开两者，是因为两者的生命周期不一样。</p>
<p>如果只需要在作用域内维持变量的生命周期，最好就用自动变量，这样是最简单方便高效的。其他情况可考虑用自由存储、静态局部／全局变量，或类的（静态）成员变量。它们各有不同特点，不在此答案详述。另外，由于 C++ 不支持可变长数组（VLA），不可以定义动态长度的自动变量（成员变量也不行），这个情况下也需要用 new[] 来创建动态长度的数组。</p>
<p>自动变量会在作用域（如函数作用域、块作用域等）结束后析构、释放内存。因为分配和释放的次序是刚好完全相反的，所以可用到堆栈先进后出（first-in-last-out, FILO）的特性，而 C++ 语言的实现一般也会使用到调用堆栈（call stack）来分配自动变量（但非标准的要求）。<br>自由存储可以在函数结束后继续生存，所以也需要配合 delete 来手动析构、释放内存（也可使用智能指针避免手动 delete）。由于分配和释放次序没有限制，不能使用堆栈这种数据结构做分配，实现上可能采用自由链表（free list）或其他动态内存分配机制。</p>
<p><strong>堆</strong>，英文是 heap，在内存管理的语境下，指的是动态分配内存的区域。这个堆跟数据结构里的堆不是一回事。这里的内存，被分配之后需要手工释放，否则，就会造成内存泄漏。</p>
<p>C++ 标准里一个相关概念是自由存储区(free store)，特指使用 <code>new</code> 和 <code>delete</code> 来分配和释放内存的区域。一般而言，free store是堆(heap)的一个子集，原因如下：</p>
<ul>
<li><code>new</code> 和 <code>delete</code> 操作的区域是 free store；<code>malloc</code> 和 <code>free</code> 操作的区域是 heap</li>
<li><code>new</code> 和 <code>delete</code> 通常底层使用 <code>malloc</code> 和 <code>free</code> 来实现</li>
</ul>
<p><strong>栈</strong>，英文是 stack，在内存管理的语境下，指的是函数调用过程中产生的本地变量和调用数据的区域。这个栈和数据结构里的栈高度相似，都满足“后进先出”（last-in-first-out 或 LIFO）。</p>
<p><strong>RAII</strong>，完整的英文是 Resource Acquisition Is Initialization，是 C++ 所特有的资源管理方式。有少量其他语言，如 D、Ada 和 Rust 也采纳了 RAII，但主流的编程语言中， C++ 是唯一一个依赖 RAII 来做资源管理的。</p>
<p>RAII 依托栈和析构函数，来对所有的资源——包括堆内存在内——进行管理。对 RAII 的使用，使得 C++ 不需要类似于 Java 那样的垃圾收集方法，也能有效地对内存进行管理。RAII 的存在，也是垃圾收集虽然理论上可以在 C++ 使用，但从来没有真正流行过的主要原因。 </p>
<p>嵌入式的设备如DSP上的栈空间是Kb级别，在函数内定义数组或申请空间都不能像linux下那样直接定义和申请，要么定义成全局的，要么指向一块划分好的空间，否则就会造成覆盖代码段等的问题。</p>
<p>DSP的所有变量，函数，以及程序员定义的地址都保存在这三片空间上，程序员在定义变量时，若没有特殊规定，则编译器自动把变量分配到可读写空间上的任意位置，所以当程序员使用 <code>int *p = 0x00810000</code> ；这种语法的时候，很有可能会覆盖掉程序保存变量和函数的空间，导致程序运行异常，因此需要一个 <code>.cmd</code> 文件来约束，哪些地方用来给程序员自己定义变量地址用，哪些地方用来给程序为变量和函数申请内存来用。</p>
<h1 id="2-多核通信模块"><a href="#2-多核通信模块" class="headerlink" title="2. 多核通信模块"></a>2. 多核通信模块</h1><blockquote>
<p><em>IPC Modules can be used in a variety of combinations.</em> </p>
</blockquote>
<p>以上即是说，各类IPC模块可以根据需要进行组合混用。</p>
<p>IPC以独立插件的形式进行安装与使用，使用时可能需要手动挂载至项目属性中。</p>
<p>Here are some introductions about heap in the &lt;SPRUEX3K.pdf&gt; as follows: </p>
<blockquote>
<p>SYS/BIOS provides the following Heap implementations:</p>
<ul>
<li><strong>HeapMem.</strong> Allocate variable-size blocks. Section 6.8.1</li>
<li><strong>HeapBuf.</strong> Allocate fixed-size blocks. Section 6.8.2</li>
<li><strong>HeapMultiBuf.</strong> Specify variable-size allocation, but internally allocate from a variety of fixed-size<br>blocks. Section 6.8.3</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>Module</th>
<th>Module Path</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>GateMP（门）</td>
<td><code>GateMP</code></td>
<td>Manages gates for mutual exclusion of shared resources by multiple processors and threads. <br/><em>See Section 2.6.</em></td>
</tr>
<tr>
<td>HeapBufMP（堆缓存）</td>
<td><code>ti.sdo.ipc.heaps.HeapBufMP</code></td>
<td>Fixed-sized shared memory Heaps. Similar to SYS/BIOS’s <code>ti.sysbios.heaps.HeapBuf </code> module, but with some configuration differences. <br/><em>See Section 2.5.</em></td>
</tr>
<tr>
<td>HeapMemMP（堆储存）</td>
<td><code>ti.sdo.ipc.heaps.HeapMemMP</code></td>
<td>Variable-sized shared memory Heaps. <br/><em>See Section 2.5.</em></td>
</tr>
<tr>
<td>HeapMultiBufMP（堆混合缓存）</td>
<td><code>ti.sdo.ipc.heaps.HeapMultiBufMP</code></td>
<td>Multiple fixed-sized shared memory Heaps. <br/><em>See Section 2.5.</em></td>
</tr>
<tr>
<td>Ipc（核间通信）</td>
<td><code>ti.sdo.ipc.Ipc</code></td>
<td>Provides <code>Ipc_start()</code> function and allows startup sequence configuration. <br/><em>See Section 2.2.</em></td>
</tr>
<tr>
<td>ListMP（列表）</td>
<td><code>ti.sdo.ipc.ListMP</code></td>
<td>Doubly-linked list for shared-memory, multi-processor applications. Very similar to the ti.sdo.utils.List module. <br/><em>See Section 2.4.</em></td>
</tr>
<tr>
<td>MessageQ （Q报文）</td>
<td><code>ti.sdo.ipc.MessageQ</code></td>
<td>Variable size messaging module. 可拥有不同大小的信息模块。<br/><em>See Section 2.3.</em></td>
</tr>
<tr>
<td>TransportShm（运输表）</td>
<td><code>ti.sdo.ipc.transports.TransportShm</code></td>
<td>Transport used by MessageQ for remote communication with other processors via shared memory. <br/><em>See Section 2.3.11.</em></td>
</tr>
<tr>
<td>Notify （通知）</td>
<td><code>ti.sdo.ipc.Notify</code></td>
<td>Low-level interrupt mux/demuxer module. <br/><em>See Section 2.7.</em></td>
</tr>
<tr>
<td>NotifyDriverShm（通知驱动表）</td>
<td><code>ti.sdo.ipc.notifyDrivers.NotifyDriverShm</code></td>
<td>Shared memory notification driver used by the Notify module to communicate between a pair of processors. <br/><em>See Section 2.7.</em></td>
</tr>
<tr>
<td>SharedRegion （共享区域）</td>
<td><code>ti.sdo.ipc.SharedRegion</code></td>
<td>Maintains shared memory for multiple shared regions. <br/><em>See Section 2.8.</em></td>
</tr>
</tbody></table>
<h2 id="Header-Files-included"><a href="#Header-Files-included" class="headerlink" title="Header Files included"></a>Header Files included</h2><p>除了<code> &lt;ipc_install_dir&gt;/packages/ti/ipc/</code> 路径下可以找到IPC必须的头文件外， <code>&lt;ipc_install_dir&gt;/packages/ti/sdo/ipc/</code> 路径下同样有IPC的头文件，但是请勿直接引用至 <code>.c</code>文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/std.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/* ---- XDC.RUNTIME module Headers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/runtime/Memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/runtime/System.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/runtime/IHeap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/runtime/Timestamp.h&gt;</span>    <span class="comment">//not officially included</span></span></span><br><span class="line"><span class="comment">/* ----- IPC module Headers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/ipc/GateMP.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/ipc/Ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/ipc/MessageQ.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/ipc/HeapBufMP.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/ipc/MultiProc.h&gt;</span></span></span><br><span class="line"><span class="comment">/* ---- BIOS6 module Headers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/sysbios/BIOS.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/sysbios/knl/Task.h&gt;</span></span></span><br><span class="line"><span class="comment">/* ---- Get globals from .cfg Header */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/cfg/global.h&gt;</span></span></span><br></pre></td></tr></table></figure>



<h2 id="Standard-IPC-Function-Call-Sequence"><a href="#Standard-IPC-Function-Call-Sequence" class="headerlink" title="Standard IPC Function Call Sequence"></a>Standard IPC Function Call Sequence</h2><p>Standard IPC Function Call Sequence，即标准IPC函数的调用顺序。</p>
<blockquote>
<p> <em><strong>MODULE</strong></em> 在本处指任一类型的IPC调用（如，GateMP、IPC、MessageQ等），如  <code>MODULE_Open()</code> 即可替换成 <code>MessageQ_Open()</code> ，具体实参见对应的头文件。</p>
</blockquote>
<p>An application that uses IPC APIs—such as <code>MessageQ</code>, <code>GateMP</code>, and <code>ListMP</code>—**must include the Ipc module header file and call <code>Ipc_start()</code> in the <code>main()</code> function. ** <code>Ipc_start()</code> does the following:</p>
<ul>
<li>初始化：Initializes a number of objects and modules used by IPC.</li>
<li>同步：Synchronizes multiple processors so they can boot in any order.</li>
</ul>
<p><strong>NOTES:</strong> If the <code>main()</code> function calls any IPC APIs, the call to <code>Ipc_start()</code> must be placed before any calls to IPC modules.</p>
<h3 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h3><ul>
<li>Firstly, initialize a <code>MODULE_Params</code> structure to its default values via a <code>MODULE_Params_init() </code> function.  The creator thread can then set individual parameter fields in this structure as needed.</li>
<li>Secondly, calls the <code>MODULE_create()</code> function to creates the instance and initializes any shared memory used by the instance. <em>If the instance is to be opened remotely, a unique name must be supplied in the parameters.</em></li>
<li>Other threads can access this instance via the <code>MODULE_open()</code> function, which <strong>returns a handle with access to the instance.</strong> The name that was used for instance creation must be used in the <code>MODULE_open()</code> function.</li>
<li>Finally, the thread that called <code>MODULE_create()</code> can call <code>MODULE_delete()</code> to free the memory used by the instance.</li>
</ul>
<blockquote>
<ul>
<li>首先，使用 <code>MODULE_Params_init() </code> 来初始化 <code>MODULE_Params</code> 结构。（创建它的线程）可以根据需要单独调整结构体内的个别参数。</li>
<li>然后，调用 <code>MODULE_create()</code> 函数来创建对象实例，并初始化其内存。如果该对象在别处被打开，需要给被调用的参数取好名字防止重复。</li>
<li>接着， 其他线程可以通过 <code>MODULE_open()</code>  函数接入该对象，并返回一个对应的句柄。该对象的创建名称必须与打开名称保持一致。</li>
<li>最后，调用 <code>MODULE_create()</code> 来创建对象实例的线程就可以调用 <code>MODULE_delete()</code> 来释放被对象占用的内存。</li>
</ul>
</blockquote>
<p><strong>注意：</strong> </p>
<blockquote>
<p><em>All threads that opened an instance must close that instance before the thread that created it can delete it.</em> <em>Also, a thread that calls <code>MODULE_create()</code> cannot call <code>MODULE_close()</code>.</em> <em>Likewise, a thread that calls <code>MODULE_open()</code> cannot call <code>MODULE_delete()</code>.</em></p>
<p>在由创建者删除（delete）某IPC对象时，由谁使用（open）就由谁关闭（close）。且决不能由创建者来调用关闭函数，否则创建者无法删除该对象。（顺序如下图所示）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stateDiagram-v2</span><br><span class="line">	[*] --&gt; Core0</span><br><span class="line">	[*] --&gt; Core1</span><br><span class="line">	Core0 --&gt; IPC_Start()</span><br><span class="line">	IPC_Start() --&gt; Module_Create()</span><br><span class="line">	IPC_Start() --&gt; Core1 : Wait for Sychronization</span><br><span class="line">	Core1 --&gt; UsersProgram()</span><br><span class="line">	UsersProgram() --&gt; Module_Open()</span><br><span class="line">	Module_Open() --&gt; Module_Close()</span><br><span class="line">	Module_Create() --&gt; Module_Delete()</span><br><span class="line">	Module_Close() --&gt; Module_Delete() : Closed by who opens</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="Ipc-Start-使用示例"><a href="#Ipc-Start-使用示例" class="headerlink" title="Ipc_Start() 使用示例"></a>Ipc_Start() 使用示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ti/ipc/Ipc.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="function">Int <span class="title">main</span><span class="params">(Int argc, Char* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     Int status;</span><br><span class="line">     <span class="comment">/* Call Ipc_start() */</span></span><br><span class="line">     status = Ipc_start();</span><br><span class="line">     <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         System_abort(<span class="string">&quot;Ipc_start failed\n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     BIOS_start();</span><br><span class="line">     <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="MessageQ-Create-使用示例"><a href="#MessageQ-Create-使用示例" class="headerlink" title="MessageQ_Create() 使用示例"></a>MessageQ_Create() 使用示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">messageQ = MessageQ_create(DSP_MESSAGEQNAME, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (messageQ == <span class="literal">NULL</span>) &#123;   <span class="comment">//an error occurred when creating the object</span></span><br><span class="line">	System_abort(<span class="string">&quot;MessageQ_create failed\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Error-Handling-in-IPC"><a href="#Error-Handling-in-IPC" class="headerlink" title="Error Handling in IPC"></a>Error Handling in IPC</h2><p>Success codes always have values greater or equal to zero. The Failure codes are always negative.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MessageQ_Msg msg; </span><br><span class="line">MessageQ_Handle messageQ;</span><br><span class="line">Int status;</span><br><span class="line">...</span><br><span class="line">status = MessageQ_get(messageQ, &amp;msg, MessageQ_FOREVER);</span><br><span class="line"><span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	System_abort(<span class="string">&quot;Should not happen\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="IPC-Module-Configuration"><a href="#IPC-Module-Configuration" class="headerlink" title="IPC Module Configuration"></a>IPC Module Configuration</h2><p>Configure how the IPC module synchronizes processors by configuring the <code>Ipc.procSync</code> property. For example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CONFIGURATION ABOUT INTER-PROCESS COMMUNICATION */</span></span><br><span class="line">var Ipc = xdc.useModule(&#x27;ti.sdo.ipc.Ipc&#x27;);</span><br><span class="line">Ipc.procSync = Ipc.ProcSync_ALL;</span><br></pre></td></tr></table></figure>

<p>Here are three options: <code>Ipc.ProcSync_ALL</code> | <code>Ipc.ProcSync_PAIR</code> | <code>Ipc.ProcSync_NONE</code></p>
<table>
<thead>
<tr>
<th>Options</th>
<th>Conditions</th>
<th>Specialties</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Ipc.ProcSync_ALL</strong></td>
<td>- IPC processors on a device start up at the same time<br/>- Connections should be established between every possible pair of processors</td>
<td>- <code>Ipc_start() API</code> automatically attaches to and synchronizes all remote processors.  <br/>- Application <em><strong>should never call</strong></em> <code>Ipc_attach()</code>.</td>
</tr>
<tr>
<td><strong>Ipc.ProcSync_PAIR</strong> <em>(Default Mode)</em></td>
<td><em>One of the following is true:</em><br>- You need to control when synchronization with each remote processor occurs.<br/>- Useful work can be done while trying to synchronize with a remote processor by yielding a thread after each attempt to Ipc_attach() to the processor. <br/> - Connections to some remote processors are unnecessary and should be made selectively to save memory.</td>
<td>- Must explicitly call <code>Ipc_attach()</code> to attach to a specific remote processor. <br/>- <code>Ipc_start()</code> performs system-wide IPC initialization, but does not <strong>make connections to remote processors</strong>.</td>
</tr>
<tr>
<td><strong>Ipc.ProcSync_NONE</strong></td>
<td><em>Use this option with caution.</em> <br/>It is intended for use in cases where the application performs its own synchronization and you want to avoid a potential deadlock situation with the IPC synchronization.</td>
<td><code>Ipc_start()</code> doesn’t synchronize any processors before setting up the objects needed by other modules.</td>
</tr>
</tbody></table>
<h4 id="Attach-and-Detach-（依附与分离）"><a href="#Attach-and-Detach-（依附与分离）" class="headerlink" title="Attach and Detach （依附与分离）"></a>Attach and Detach （依附与分离）</h4><p>In addition to the default actions performed when attaching to or detaching from a remote processor, You can configure a function to perform custom actions. </p>
<p>Attach and Detach are provided for the processor synchronization:</p>
<ul>
<li><p><code>Ipc_attach()</code> Creates a connection to the specified remote processor. </p>
</li>
<li><p><code>Ipc_detach()</code> Deletes the connection to the specified remote processor.</p>
</li>
</ul>
<p>在 <code>.cfg</code> 文件中以下为两个互相依赖和两个互相分离的函数配置，每一组函数都会传递一个不同的参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Ipc = xdc.useModule(&#x27;ti.sdo.ipc.Ipc&#x27;);</span><br><span class="line"></span><br><span class="line">var fxn = <span class="keyword">new</span> Ipc.UserFxn;</span><br><span class="line">fxn.attach = &#x27;&amp;userAttachFxn1&#x27;;</span><br><span class="line">fxn.detach = &#x27;&amp;userDetachFxn1&#x27;;</span><br><span class="line">Ipc.addUserFxn(fxn, <span class="number">0x1</span>);</span><br><span class="line"></span><br><span class="line">fxn.attach = &#x27;&amp;userAttachFxn2&#x27;;</span><br><span class="line">fxn.detach = &#x27;&amp;userDetachFxn2&#x27;;</span><br><span class="line">Ipc.addUserFxn(fxn, <span class="number">0x2</span>);</span><br></pre></td></tr></table></figure>

<p><em><strong>These functions run near the end of <code>Ipc_attach()</code> and near the beginning of <code>Ipc_detach()</code> , respectively.</strong></em></p>
<p><em><strong>Such functions must be non-blocking and must run to completion. 这些被定义的函数必须为非阻塞且（一旦开始就）运行到底。</strong></em></p>
<p><strong>注意：</strong> Call <code>Ipc_attach()</code> to the processor that owns shared memory region 0 (usually the processor with id = 0) before making a connection to any other remote processor. For example, if there are three processors configured with <em><strong>MultiProc</strong></em>, #1 should attach to #0 before it can attach to #2.</p>
<h1 id="3-多核任务分配"><a href="#3-多核任务分配" class="headerlink" title="3. 多核任务分配"></a>3. 多核任务分配</h1><blockquote>
<p>如果多个核共享一个工程及相同的bios 配置文件，是不能指定某一个任务到特定的core上，如果某个任务只有某个core才会运行，可以在任务中区分core运行。如果多个core分别有不同的工程，则没有“多核任务分配”的问题，每个工程可以根据各自core的应用创建各自的任务，不需要软件区分core。</p>
</blockquote>
<blockquote>
<p>单核可以是一个out生成最终的bin文件烧写在flash，多核如果存在多个out文件，可以把out文件合并成一个bin烧写，或者多个bin分开烧写均可。bin文件中都有程序的地址及长度信息，在多个bin时，也是一样可以由core0负责对flash的程序文件解析，将程序搬移到相应的地址上，最后core0再向其他core magic address写入入口地址，并发送ipc触发即可。</p>
</blockquote>
<blockquote>
<p>这个并非由SYS/BIOS分配，需要开发者指定。</p>
<p>可以根据core number来做判断，然后确认该任务是否运行在该核上。 </p>
</blockquote>
<h1 id="4-Chip-Support-Library"><a href="#4-Chip-Support-Library" class="headerlink" title="4. Chip Support Library"></a>4. Chip Support Library</h1><p>CSL，即芯片支持库( Chip Support Library)。在程序设计过程中利用CSL库函数可以方便地访问 <strong>DSP的寄存器和硬件资源</strong>，提高DSP软件的开发效率和速度。</p>
<p>CSL库包含了对INTC、Boot Configuration、BWMNGMT、CACHE、CHIP、CPINTC、EDMA3、EMAC、EMIF4F、GPIO、IDMA、IPC、MDIO、MEMPROT、MPU、MSMC、PLLC、PSC、Semaphore、SGMII、SRIO、TIMER、TSC、VCP2、XMC、CGEM、CPPI、QMSS、CPPI_LLD_SYMBOL 及 CPPI_LLD_ENUM共30种模块的支持。</p>
<h2 id="Cache-Module"><a href="#Cache-Module" class="headerlink" title="Cache Module"></a>Cache Module</h2><p>位于 <code>ti\pdk_C6657_1_1_2_6\packages\ti\csl\</code> 下的头文件 <code>&lt;csl_cacheAux.h&gt;</code> 提供了缓存（Cache）配置相关的CSL功能层API。</p>
<blockquote>
<p>This is the CACHE Auxilary Header File which exposes the <em><strong>various CSL Functional Layer API</strong></em>‘s to <em><strong>configure the CACHE Module</strong></em>.</p>
</blockquote>
<blockquote>
<p>Cache API包含了对L1D（L1 Data Cache）、L1P 及 L2的各种操作。关于L1D、L1P及L2 的详细文件参考《SPRS814D》第193页。</p>
</blockquote>
<p>该头文件中对三种缓存的可操作方式如下示：</p>
<table>
<thead>
<tr>
<th>OPERATION</th>
<th>L1D</th>
<th>L1P</th>
<th>L2</th>
</tr>
</thead>
<tbody><tr>
<td>setSize</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>getSize</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>freeze</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>unfreeze</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>getPrevMode<br/><em>– get the previous operating state</em></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>invAllWait<br/><em>– wait for the cache global invalidate operation to complete</em></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>invAll<br/><em>– globally invalidate cache</em></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>wbAllWait<br/><em>– wait for the cache writeback operation to complete</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>wbAll<br/><em>– writeback the dirty lines of the cache</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>wbInvAllWait<br/><em>– wait for the cache writeback invalidate operation to complete</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>wbInvAll<br/><em>– invalidate and writeback the dirty lines of the cache</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>invWait<br/><em>– wait for the cache invalidate block operation to complete</em></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>inv<br/><em>– to invalidate a block in cache</em></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>wbWait<br/><em>– wait for the cache writeback block operation to complete</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>wb<br/><em>– writeback the dirty lines of the block address</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>wbInvWait<br/><em>– wait for the cache invalidate/writeback block operation to complete</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>wbInv<br/><em>– invalidate and writeback the dirty lines of the block address</em></td>
<td>√</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="IPC-Module"><a href="#IPC-Module" class="headerlink" title="IPC Module"></a>IPC Module</h2><p>IPC，即进程间通信（Inter-process communication）。</p>
<p>位于 <code>ti\pdk_C6657_1_1_2_6\packages\ti\csl\</code> 下的头文件 <code>&lt;csl_ipcAux.h&gt;</code> 提供了<strong>查询定义</strong> 和 <strong>控制函数</strong>。IPC API包含了对 NMI、GEM、Host的各种操作。其中 <strong>GEM</strong> 对 IPCGRx 及 IPCARx 进行操作；而 <strong>Host</strong> 对 IPCGRH 及 IPCARH 进行操作。</p>
<p><strong>注意：</strong> 下文中， <code>index</code> 和 <code>srcId</code> 均是函数形参，如在<code>CSL_IPC_isGEMInterruptAckSet（uint32 index, uint32 srcId)</code>中：<code>index</code> 指需要检查IPCARx寄存器的GEM编号。<code>srcId</code> 指示在指定的索引对应的IPCARx寄存器中需要读取0-27 SRCCx位中的哪一个。</p>
<blockquote>
<p><strong>NMI</strong>，即 <strong>不可屏蔽中断</strong>（Non Maskable Interrupt）。<strong>NMIG</strong>，即 <strong>不可屏蔽中断产生寄存器</strong>（NMI Generation Register *(NMIGRx)*）。NMIGRx registers are used for generating NMI events to the corresponding CorePac. The C6657 has two NMIGRx registers (NMIGR0 and NMIGR1). The NMIGR0 register generates an NMI event to CorePac0, and the NMIGR1 register generates an NMI event to CorePac1.Writing 1 to the NMIG field generates an NMI pulse. Writing 0 has no effect and reads return 0 and have no other effect.</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_09-00-03.png" style="zoom:50%;" />

<p><strong>IPCGRx</strong>，即 <strong>进程间通信产生寄存器</strong>（IPC interrupt generation register）。IPCGRx are to facilitate inter CorePac interrupts. The C6657 has two IPCGRx registers (IPCGR0 and IPCGR1). These registers can be used by external hosts or CorePacs to generate interrupts to other CorePacs. A write of 1to the IPCG field of the IPCGRx register will generate an interrupt pulse to CorePacx (0 &lt;= x &lt;= 1).</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_08-54-09.png" style="zoom:50%;" />

<p><strong>IPCARx</strong>，即 <strong>IPC中断确认寄存器</strong>（IPC interrupt-acknowledgement registers）。IPCARx are to facilitate inter-CorePac core interrupts. The C6657 has two IPCARx registers (IPCAR0 and IPCAR1). These registers also provide a <em>Source ID facility</em> by which up to 28 different sources of interrupts can be identified. Allocation of source bits to source processor and meaning is entirely based on software convention. The register field descriptions are shown in the following tables. Virtually anything can be a source for these registers as this is completely controlled by software. Any master that has access to BOOTCFG module space can write to these registers.</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_08-57-22.png" style="zoom:50%;" />

<p><strong>IPCGRH</strong>，即 <strong>主机IPC产生寄存器</strong>（IPC Generation Host）。The IPCGRH register facilitates interrupts to external hosts. Operation and use of the IPCGRH register is the same as for other IPCGR registers. The interrupt output pulse created by the IPCGRH register appears on device pin HOUT. <mark><i>The host interrupt output pulse should be stretched. It should be asserted for 4 bootcfg clock cycles (CPU/6) followed by a deassertion of 4 bootcfg clock cycles. Generating the pulse will result in 8 CPU/6 cycle pulse blocking window. </i></mark>Write to IPCGRH with IPCG bit (bit 0) set will only generate a pulse if they are beyond 8 CPU/6 cycle period. </p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_09-33-14.png" style="zoom:50%;" />

<p><strong>IPCARH</strong>，即 <strong>主机IPC确认寄存器</strong>（Host IPC Acknowledgment Register）。</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/Snipaste_2021-04-08_14-57-07.png" style="zoom: 67%;" />
</blockquote>
<p>该头文件中的可操作方式如下示：</p>
<table>
<thead>
<tr>
<th></th>
<th>NMI</th>
<th>GEM</th>
<th>Host</th>
</tr>
</thead>
<tbody><tr>
<td>genEvent</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>genInterrupt<br><em>– generate an interrupt pulse</em></td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>isInterruptSourceSet</td>
<td></td>
<td>√<br><em>– checks if the SRCSx bit of the <strong>IPCGRx</strong> register is set</em></td>
<td>√<br><em>– checks if the SRCSx bit of the <strong>IPCGRH</strong> register is set</em></td>
</tr>
<tr>
<td>isInterruptAckSet</td>
<td></td>
<td>√<br><em>– checks if the SRCCx bit of the <strong>IPCARx</strong> register is set.</em></td>
<td>√<br><em>– checks if the SRCCx bit of the <strong>IPCARH</strong> register is set.</em></td>
</tr>
<tr>
<td>clearInterruptSource</td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p><code>isGEMInterruptSourceSet()</code> returns 1 if the <u>SRCCx bit corresponding to the <strong>srcId</strong> is set</u> in the IPCARx register corresponding to the index specified. 如果与srcId对应的SRCCx位在与指定索引对应的IPCARx寄存器中被设置，则返回1。</p>
<blockquote>
<p><code>CSL_IPC_clearGEMInterruptSource()</code> clears the interrupt source IDs by setting the <strong>SRCCx bit of IPCARx</strong> and <strong>SRCSx bit of IPCGRx</strong> corresponding to the GEM index and Source ID specified.  </p>
<p><code>CSL_IPC_clearGEMInterruptSource()</code> 通过设置 <em><strong>GEM 索引</strong></em> 和 <em><strong>指定源 ID</strong></em> 对应的 <strong>IPCARx寄存器上的SRCCx位</strong> 和 <strong>IPCGRx寄存器上的SRCSx位</strong> 来清除 中断源ID 。</p>
</blockquote>
<blockquote>
<p><code>CSL_IPC_clearHostInterruptSource()</code> function clears the interrupt source IDs by setting the <strong>SRCCx bit of IPCARH</strong> and <strong>SRCSx bit of IPCGRH</strong> corresponding to the Source ID specified.  </p>
<p><code>CSL_IPC_clearHostInterruptSource()</code> 通过设置 <em><strong>指定源ID</strong></em> 对应的 <strong>IPCARH上的SRCCx位</strong> 和 <strong>IPCGRH上的SRCSx位</strong> 来清楚中断源ID。</p>
</blockquote>
<h3 id="CACHE-wbInvL1d"><a href="#CACHE-wbInvL1d" class="headerlink" title="CACHE_wbInvL1d()"></a>CACHE_wbInvL1d()</h3><p>This function is used to <mark><strong>invalidate and writeback</strong> the <em>dirty lines</em> of the block address</mark>.  </p>
<p>Although the block size can be specified in the number of bytes, the cache controller operates on whole cache lines. </p>
<p>To prevent unintended behavior “blockPtr” should be aligned on the cache line size and “byteCnt” should be a multiple of the cache line size.</p>
<h3 id="CACHE-invL1d"><a href="#CACHE-invL1d" class="headerlink" title="CACHE_invL1d ()"></a>CACHE_invL1d ()</h3><p>This function is used to <mark><strong>invalidate</strong> a <em>block</em> in the L1D Cache</mark>. </p>
<p>Although the block size can be specified in the number of bytes, the cache controller operates on whole cache lines. </p>
<p>To prevent unintended behavior “blockPtr” should be aligned on the cache line size and “byteCnt” should be a multiple of the cache line size.</p>
<h2 id="Chip-Module"><a href="#Chip-Module" class="headerlink" title="Chip Module"></a>Chip Module</h2><p><code>#include &lt;csl_chipAux.h&gt;</code></p>
<p>本头文件是以C( <code>extern &quot;C&quot;</code> )的方式来书写的，包含芯片读取与写入相关操作的API，名称以 <code>CSL_chipRead</code> 或 <code>CSL_chipWrite</code> 开头，所有函数均以静态内联（static inline，重定义成 <code>CSL_IDEF_INLINE</code> ）32位非负整数（Uint32）的方式定义，如 <code>CSL_IDEF_INLINE Uint32 CSL_chipRead***();</code> 。</p>
<p><code>&lt;csl_chipAux.h&gt;</code> 提供了26个读取寄存器相关的函数，函数定义均是对寄存器的读取并返回数值，某些读取函数需要注意 <em>前置条件</em>（Pre-condition）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CSL_chipReadAMR();    <span class="comment">//Addressing Mode control register 寻址模式控制寄存器</span></span><br><span class="line">CSL_chipReadCSR();    <span class="comment">//Control Status register 控制状态寄存器</span></span><br><span class="line">CSL_chipReadIFR();    <span class="comment">//Interrupt Flag register 中断标志寄存器</span></span><br><span class="line">CSL_chipReadIER();    <span class="comment">//Interrupt Enable register 中断使能寄存器</span></span><br><span class="line">CSL_chipReadISTP();    <span class="comment">//Interrupt Service Table Pointer register 中断服务表指针寄存器</span></span><br><span class="line">CSL_chipReadIRP();    <span class="comment">//Interrupt Return Pointer register 中断返回指针寄存器</span></span><br><span class="line">CSL_chipReadNRP();    <span class="comment">//Nonmaskable Interrupt Return Pointer register </span></span><br><span class="line">CSL_chipReadERP();    <span class="comment">//Exception Return Pointer register 异常返回指针寄存器</span></span><br><span class="line">CSL_chipReadTSCL();    <span class="comment">//Time Stamp Counter Lower Order 32-bits register 时间戳计数器低32位</span></span><br><span class="line">CSL_chipReadTSCH();    <span class="comment">//Time Stamp Counter Higer Order 32-bits register 时间戳计数器高32位</span></span><br><span class="line">CSL_chipReadARP();    <span class="comment">//Analysis Return Pointer register </span></span><br><span class="line">CSL_chipReadILC();    <span class="comment">//Inner Loop SPL buffer Counter(ILC) register</span></span><br><span class="line">CSL_chipReadRILC();    <span class="comment">//Reload Inner Loop SPL buffer Counter(RILC) register</span></span><br><span class="line">CSL_chipReadREP();    <span class="comment">//Restricted Entry Point Address register</span></span><br><span class="line">CSL_chipReadPCE1();    <span class="comment">//Program Counter, E1 Phase register E1字段程序计数器</span></span><br><span class="line">CSL_chipReadDNUM();    <span class="comment">//DSP Core Number register 核心数寄存器</span></span><br><span class="line">CSL_chipReadSSR();    <span class="comment">//Saturation Status Register 饱和状态寄存器</span></span><br><span class="line">CSL_chipReadGPLYA();    <span class="comment">//GMPY A-side polynomial register </span></span><br><span class="line">CSL_chipReadGPLYB();    <span class="comment">//GMPY B-side polynomial register</span></span><br><span class="line">CSL_chipReadGFPGFR();    <span class="comment">//Golios Field Multiply Control Register</span></span><br><span class="line">CSL_chipReadDIER();    <span class="comment">//Debug Interrupt Enable Register 调试中断使能寄存器</span></span><br><span class="line">CSL_chipReadTSR();    <span class="comment">//Task State Register 任务状态寄存器</span></span><br><span class="line">CSL_chipReadITSR();    <span class="comment">//Interrupt Task State Register 中断任务状态寄存器</span></span><br><span class="line">CSL_chipReadNTSR();    <span class="comment">//NMI/Exception Task State Register 异常任务状态寄存器</span></span><br><span class="line">CSL_chipReadEFR();    <span class="comment">//Exception Flag Register 异常标志寄存器</span></span><br><span class="line">CSL_chipReadIERR();    <span class="comment">//Internal Exception Report Register 内部异常报告寄存器</span></span><br></pre></td></tr></table></figure>



<p><code>&lt;csl_chipAux.h&gt;</code> 提供了24个写入寄存器相关的函数，且与读取寄存器相关函数并不呈现一一对应关系。函数定义均是将一个Uint32类型（重定义为 <code>CSL_Reg32</code> ）的新值赋值给寄存器，并将旧值返回，写入寄存器均不需要注意 前置条件，部分需要注意后置条件（Post-condition）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CSL_chipWriteAMR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteCSR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteISR(CSL_Reg32  val);    <span class="comment">//Interrupt Set Register 中断设置寄存器</span></span><br><span class="line">CSL_chipWriteICR(CSL_Reg32  val);    <span class="comment">//Interrupt Clear Register 中断清除寄存器</span></span><br><span class="line">CSL_chipWriteIER(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteISTP(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteIRP(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteNRP(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteERP(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteTSCL(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteARP(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteILC(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteRILC(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteREP(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteSSR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteGPLYA(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteGPLYB(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteGFPGFR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteDIER(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteTSR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteITSR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteNTSR(CSL_Reg32  val);</span><br><span class="line">CSL_chipWriteECR(CSL_Reg32  val);    <span class="comment">//Exception Clear Register 异常清除寄存器</span></span><br><span class="line">CSL_chipWriteIERR(CSL_Reg32  val);</span><br></pre></td></tr></table></figure>



<p>共30个寄存器涉及是否可读写：</p>
<table>
<thead>
<tr>
<th>Register</th>
<th>Read</th>
<th>Write</th>
</tr>
</thead>
<tbody><tr>
<td>AMR</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>CSR</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>IFR</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>ISR</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>ICR</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>IER</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>ISTP</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>IRP</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>NRP</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>ERP</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>TSCL</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>TSCH</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>ARP</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>ILC</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>RILC</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REP</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>PCE1</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>DNUM</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>SSR</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>GPLYA</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>GPLYB</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>GFPGFR</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>DIER</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>TSR</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>ITSR</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>NTSR</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>ECR</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>EFR</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>IERR</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<h2 id="IPC-HW-Example-in-ANC"><a href="#IPC-HW-Example-in-ANC" class="headerlink" title="IPC_HW Example in ANC"></a>IPC_HW Example in ANC</h2><p><strong>硬件（中断）层核间通信</strong>（不需要修改）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ipc_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Hwi_Params params;    <span class="comment">//创建HWI对象</span></span><br><span class="line">	Error_Block eb;    <span class="comment">//创建错误块处理对象</span></span><br><span class="line"></span><br><span class="line">	Error_init(&amp;eb);    <span class="comment">//初始化错误块</span></span><br><span class="line">	Hwi_Params_init(&amp;params);    <span class="comment">//初始化HWI对象</span></span><br><span class="line">	params.eventId = <span class="number">90</span>;    <span class="comment">//IPC INT	/* Set the event ID of the associated host interrupt */</span></span><br><span class="line">	params.enableInt = TRUE;    <span class="comment">//打开中断</span></span><br><span class="line"></span><br><span class="line">	Hwi_create(<span class="number">5</span>, &amp;IpcIsr, &amp;params, &amp;eb);    <span class="comment">//INT5	/* Create Hwi thread Hwi function is CpIntc_dispatch */</span></span><br><span class="line">	Hwi_enable();    <span class="comment">//打开中断</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(CSL_chipReadDNUM() == <span class="number">0</span>)&#123;     <span class="comment">//core0	//检测运行前触发的ipc，因为运行前写入的ipc无法触发中断</span></span><br><span class="line">		<span class="keyword">if</span>(CSL_IPC_isGEMInterruptAckSet(<span class="number">0</span>,<span class="number">2</span>))&#123;    <span class="comment">//判断索引为0对应的IPCARx中的第2位是否为中断确认位</span></span><br><span class="line">			CSL_IPC_clearGEMInterruptSource(<span class="number">0</span>,<span class="number">2</span>);    <span class="comment">//是则清除</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;    <span class="comment">//core1</span></span><br><span class="line">		<span class="keyword">if</span>(CSL_IPC_isGEMInterruptAckSet(<span class="number">1</span>,<span class="number">2</span>))&#123;    <span class="comment">//判断索引为1对应的IPCARx中的第2位是否为中断确认位</span></span><br><span class="line">			CSL_IPC_clearGEMInterruptSource(<span class="number">1</span>,<span class="number">2</span>);   <span class="comment">//是则清除</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>核心同步</strong>（不需要修改）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ipc_CoreSync</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(CSL_chipReadDNUM() == <span class="number">0</span>)&#123;    <span class="comment">//core0</span></span><br><span class="line">                CSL_IPC_genGEMInterrupt(<span class="number">1</span>,<span class="number">1</span>);    <span class="comment">//IPC_IPCGR_SRCS1 = 1;</span></span><br><span class="line">                <span class="keyword">while</span>(!CSL_IPC_isGEMInterruptAckSet(<span class="number">0</span>,<span class="number">1</span>));    <span class="comment">//等待core1启动</span></span><br><span class="line">                CSL_IPC_clearGEMInterruptSource(<span class="number">0</span>,<span class="number">1</span>);    <span class="comment">//core1启动成功，清除标志</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;    <span class="comment">//core1</span></span><br><span class="line">		CSL_IPC_genGEMInterrupt(<span class="number">0</span>,<span class="number">1</span>);    <span class="comment">//IPC_IPCGR_SRCS1 = 1;</span></span><br><span class="line">		<span class="keyword">while</span>(!CSL_IPC_isGEMInterruptAckSet(<span class="number">1</span>,<span class="number">1</span>));    <span class="comment">//等待core0启动</span></span><br><span class="line">		CSL_IPC_clearGEMInterruptSource(<span class="number">1</span>,<span class="number">1</span>);    <span class="comment">//core0启动成功，清除标志</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>核间IPC信号发送</strong>（可根据需要进行修改）</p>
<p>可定义多个IPC核间通信函数，但是要区分得清各函数在何时何处被调用到，否则将会引起混乱。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ipc_Core0ToCore1</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 可自定义区域 */</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line">		ptr0[i] = adData[i];</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* 可自定义区域 */</span></span><br><span class="line">	CACHE_wbInvL1d(ptr0,<span class="number">64</span>,CACHE_WAIT);<span class="comment">//L1D line size 64bytes</span></span><br><span class="line">	CSL_IPC_genGEMInterrupt(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">////ipcgr1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ipc_Core1ToCore0</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 可自定义区域 */</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		ptr1[i] = daData[i];</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* 可自定义区域 */</span></span><br><span class="line">	CACHE_wbInvL1d(ptr1,<span class="number">64</span>,CACHE_WAIT);                 <span class="comment">//L1D line size 64bytes</span></span><br><span class="line">	CSL_IPC_genGEMInterrupt(<span class="number">0</span>,<span class="number">2</span>);                               <span class="comment">//ipcgr0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>核间通信中断函数</strong>（可根据需要进行修改）</p>
<p><strong>注意：</strong>实际使用时，并不需要在某处调用 <code>IpcIsr()</code> 函数，即实际上是被硬件中断进行控制的，在 <code>HWI_Create()</code> 函数中被使用到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IpcIsr</span><span class="params">(UArg arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(CSL_chipReadDNUM() == <span class="number">0</span>) &#123;                      <span class="comment">// core0</span></span><br><span class="line">		<span class="keyword">if</span>(CSL_IPC_isGEMInterruptAckSet(<span class="number">0</span>,<span class="number">2</span>))&#123;                      <span class="comment">//ipcgr0</span></span><br><span class="line">			CSL_IPC_clearGEMInterruptSource(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">			CACHE_invL1d(ptr1,<span class="number">64</span>,CACHE_WAIT);</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">				daData[i] = ptr1[i];</span><br><span class="line">			&#125;</span><br><span class="line">			Semaphore_post(sem0_da);    <span class="comment">//执行发送程序，将数据通过SPI发送到DA：通过semaphore切换task</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;	<span class="comment">// core1</span></span><br><span class="line">		<span class="keyword">if</span>(CSL_IPC_isGEMInterruptAckSet(<span class="number">1</span>,<span class="number">2</span>))&#123;                          <span class="comment">//ipcgr1</span></span><br><span class="line">			CSL_IPC_clearGEMInterruptSource(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">			CACHE_invL1d(ptr0,<span class="number">64</span>,CACHE_WAIT);</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line">				adData[i] = ptr0[i];</span><br><span class="line">			&#125;</span><br><span class="line">			Semaphore_post(sem1_anc);    <span class="comment">//执行core1的计算步骤，计算完后应该通知core0的ipc启动结果发送程序：通过semaphore切换task</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="5-C6657特性"><a href="#5-C6657特性" class="headerlink" title="5. C6657特性"></a>5. C6657特性</h1><h2 id="L2缓存"><a href="#L2缓存" class="headerlink" title="L2缓存"></a>L2缓存</h2><p>Debug模式下，程序文件都写在L2缓存中。而C6657总共有 <code>2048KB</code> 大小的L2 缓存，其中每个核心分配到 <code>1024KB</code> ，缓存起始地址为 <code>0x00800000</code> 。</p>
<p>在仿真器中分配内存大小一致，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">    L2SRAM (RWX) : org = <span class="number">0x800000</span>, len = <span class="number">0x100000</span></span><br><span class="line">    MSMCSRAM (RWX) : org = <span class="number">0xc000000</span>, len = <span class="number">0x100000</span></span><br><span class="line">    DDR3 (RWX) : org = <span class="number">0x80000000</span>, len = <span class="number">0x20000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Written in &lt;*TMS320C6655/57 DataManual*&gt;:</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/02/10/Programing/CSS/2021-02-10-CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/10/Programing/CSS/2021-02-10-CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">CSS学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-10 09:07:00" itemprop="dateCreated datePublished" datetime="2021-02-10T09:07:00+08:00">2021-02-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-20 22:31:23" itemprop="dateModified" datetime="2021-05-20T22:31:23+08:00">2021-05-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/WebPrograming/" itemprop="url" rel="index"><span itemprop="name">WebPrograming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h1><p><strong>书写方式：</strong> <code>CSS属性:</code>   <code>属性值;</code></p>
<h2 id="1-CSS-类命名规则"><a href="#1-CSS-类命名规则" class="headerlink" title="1. CSS 类命名规则"></a>1. CSS 类命名规则</h2><h3 id="公共命名规则"><a href="#公共命名规则" class="headerlink" title="公共命名规则"></a>公共命名规则</h3><table>
<thead>
<tr>
<th align="left">CSS样式命名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">wrapper</td>
<td align="left">页面外围控制整体布局宽度</td>
</tr>
<tr>
<td align="left">container或content</td>
<td align="left">容器,用于最外层</td>
</tr>
<tr>
<td align="left">layout</td>
<td align="left">布局</td>
</tr>
<tr>
<td align="left">head, header</td>
<td align="left">页头部分</td>
</tr>
<tr>
<td align="left">foot, footer</td>
<td align="left">页脚部分</td>
</tr>
<tr>
<td align="left">nav</td>
<td align="left">主导航</td>
</tr>
<tr>
<td align="left">subnav</td>
<td align="left">二级导航</td>
</tr>
<tr>
<td align="left">menu</td>
<td align="left">菜单</td>
</tr>
<tr>
<td align="left">submenu</td>
<td align="left">子菜单</td>
</tr>
<tr>
<td align="left">sideBar</td>
<td align="left">侧栏</td>
</tr>
<tr>
<td align="left">sidebar_a, sidebar_b</td>
<td align="left">左边栏或右边栏</td>
</tr>
<tr>
<td align="left">main</td>
<td align="left">页面主体</td>
</tr>
<tr>
<td align="left">tag</td>
<td align="left">标签</td>
</tr>
<tr>
<td align="left">msg message</td>
<td align="left">提示信息</td>
</tr>
<tr>
<td align="left">tips</td>
<td align="left">小技巧</td>
</tr>
<tr>
<td align="left">vote</td>
<td align="left">投票</td>
</tr>
<tr>
<td align="left">friendlink</td>
<td align="left">友情连接</td>
</tr>
<tr>
<td align="left">title</td>
<td align="left">标题</td>
</tr>
<tr>
<td align="left">summary</td>
<td align="left">摘要</td>
</tr>
<tr>
<td align="left">loginbar</td>
<td align="left">登录条</td>
</tr>
<tr>
<td align="left">searchInput</td>
<td align="left">搜索输入框</td>
</tr>
<tr>
<td align="left">hot</td>
<td align="left">热门热点</td>
</tr>
<tr>
<td align="left">search</td>
<td align="left">搜索</td>
</tr>
<tr>
<td align="left">search_output</td>
<td align="left">搜索输出和搜索结果相似</td>
</tr>
<tr>
<td align="left">searchBar</td>
<td align="left">搜索条</td>
</tr>
<tr>
<td align="left">search_results</td>
<td align="left">搜索结果</td>
</tr>
<tr>
<td align="left">copyright</td>
<td align="left">版权信息</td>
</tr>
<tr>
<td align="left">branding</td>
<td align="left">商标</td>
</tr>
<tr>
<td align="left">logo</td>
<td align="left">网站LOGO标志</td>
</tr>
<tr>
<td align="left">siteinfo</td>
<td align="left">网站信息</td>
</tr>
<tr>
<td align="left">siteinfoLegal</td>
<td align="left">法律声明</td>
</tr>
<tr>
<td align="left">siteinfoCredits</td>
<td align="left">信誉</td>
</tr>
<tr>
<td align="left">joinus</td>
<td align="left">加入我们</td>
</tr>
<tr>
<td align="left">partner</td>
<td align="left">合作伙伴</td>
</tr>
<tr>
<td align="left">service</td>
<td align="left">服务</td>
</tr>
<tr>
<td align="left">regsiter</td>
<td align="left">注册</td>
</tr>
<tr>
<td align="left">arr/arrow</td>
<td align="left">箭头</td>
</tr>
<tr>
<td align="left">guild</td>
<td align="left">指南</td>
</tr>
<tr>
<td align="left">sitemap</td>
<td align="left">网站地图</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left">列表</td>
</tr>
<tr>
<td align="left">homepage</td>
<td align="left">首页</td>
</tr>
<tr>
<td align="left">subpage</td>
<td align="left">二级页面子页面</td>
</tr>
<tr>
<td align="left">tool, toolbar</td>
<td align="left">工具条</td>
</tr>
<tr>
<td align="left">drop</td>
<td align="left">下拉</td>
</tr>
<tr>
<td align="left">dorpmenu</td>
<td align="left">下拉菜单</td>
</tr>
<tr>
<td align="left">status</td>
<td align="left">状态</td>
</tr>
<tr>
<td align="left">scroll</td>
<td align="left">滚动</td>
</tr>
<tr>
<td align="left">.tab</td>
<td align="left">标签页</td>
</tr>
<tr>
<td align="left">.left .right .center</td>
<td align="left">居左、中、右</td>
</tr>
<tr>
<td align="left">.news</td>
<td align="left">新闻</td>
</tr>
<tr>
<td align="left">.download</td>
<td align="left">下载</td>
</tr>
<tr>
<td align="left">.banner</td>
<td align="left">广告条(顶部广告条)</td>
</tr>
</tbody></table>
<h3 id="其他DIV命名规则"><a href="#其他DIV命名规则" class="headerlink" title="其他DIV命名规则"></a>其他DIV命名规则</h3><p>　　登录条:loginBar</p>
<p>　　标志:logo</p>
<p>　　侧栏:sideBar</p>
<p>　　广告:banner</p>
<p>　　导航:nav</p>
<p>　　子导航:subNav</p>
<p>　　菜单:menu</p>
<p>　　子菜单:subMenu</p>
<p>　　搜索:search</p>
<p>　　滚动:scroll</p>
<p>　　页面主体:main</p>
<p>　　内容:content</p>
<p>　　标签页:tab</p>
<p>　　文章列表:list</p>
<p>　　提示信息:msg</p>
<p>　　小技巧:tips</p>
<p>　　栏目标题:title</p>
<p>　　友情链接:friendLink</p>
<p>　　页脚:footer</p>
<p>　　加入:joinus</p>
<p>　　指南:guild</p>
<p>　　服务:service</p>
<p>　　热点:hot</p>
<p>　　新闻:news</p>
<p>　　下载:download</p>
<p>　　注册:regsiter</p>
<p>　　状态:status</p>
<p>　　按钮:btn</p>
<p>　　投票:vote</p>
<p>　　合作伙伴:partner</p>
<p>　　版权:copyRight</p>
<h2 id="2-选择器"><a href="#2-选择器" class="headerlink" title="2. 选择器"></a>2. 选择器</h2><h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><p>选择器按作用大小（从小到大）分为  <code>ID选择器(使用井字符做特殊标注：#)</code> 、<code>类选择器（使用英文点号做特殊标注：.）</code> 、 <code>标签选择器</code> 及 <code>通配符选择器（使用英文星号做特殊标注：*）</code>。</p>
<table>
<thead>
<tr>
<th>选择器类型</th>
<th>选择器特性</th>
<th>style书写方式</th>
<th>style应用方式</th>
</tr>
</thead>
<tbody><tr>
<td>ID选择器</td>
<td>1. 与其他选择器类型一致，特殊之处是大部分情况作JavaScript调用<br/>2. 需要编写唯一id不可重复使用</td>
<td>#DivStyle { color: red; }</td>
<td>id=”DivStyle”</td>
</tr>
<tr>
<td>类选择器</td>
<td>1. 作用于使用class属性的一类标签，同面向对象的其他语言特性一致<br/>2. 单个标签可以使用多个类，中间以空格隔开</td>
<td>.ClassStyle { color: black;}</td>
<td>Class=”ClassStyle …..”</td>
</tr>
<tr>
<td>标签选择器</td>
<td>作用于所有使用本标签的标签</td>
<td>div { color: blue; }</td>
<td>/</td>
</tr>
<tr>
<td>通配符选择器</td>
<td>作用于所有标签</td>
<td>* { clolor: pink; }</td>
<td>/</td>
</tr>
</tbody></table>
<h3 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h3><table>
<thead>
<tr>
<th>复合选择器类型</th>
<th>选择器特性</th>
<th>style书写方式</th>
</tr>
</thead>
<tbody><tr>
<td>后代选择器</td>
<td>1. 可以选择<strong>某个</strong>父标签下的<strong>某个</strong>全部子标签，不管其是否在同一个层级<br/>2. 当标签发生嵌套时，内层标签就称为外层标签的后代<br/>3. 浏览器按照标签层级的关系进行查找，并<u>对最内层标签进行修改</u>，因此可以定义多重标签选择，如可以使用基础选择器（类选择器及ID选择器）进行组合使用<br/>4. 内外层选择器之间 <mark>以空格隔开</mark></td>
<td>外层标签 内层标签 {属性}<br/>ol li { color: #000; }<br/>ol li a { color: #777; }<br/>.nav li a { color: pruple;}</td>
</tr>
<tr>
<td>子代选择器</td>
<td>1. 即与后代选择器不同，仅对父级标签下的某一类选择器进行操作，不会作用于其他子代的同类标签<br/>2. 使用符号 <code>&gt;</code> 进行操作</td>
<td>.nav&gt;a {color: pink;}</td>
</tr>
<tr>
<td>集选择器（相邻选择器）</td>
<td>1. 在两个没有从属关系（子代或后代）和相同特点（如同类标签）的同级不同类标签中，定义一个相同的样式<br/>2. 多个标签进行选择时使用英文逗号 <code>,</code> 进行并列选择<br/>3. 并集选择器内可使用 <strong>简单选择器</strong> 和 <strong>复合选择器</strong>（如 后代选择器 和 子代选择器），竖向书写选择器</td>
<td>div, p {color: pink; }</td>
</tr>
<tr>
<td>伪类选择器</td>
<td>1. 用于给某些选择器添加特殊效果（如给链接添加特殊效果），或者选择某个元素<br/>2. 结构伪类、链接伪类、表单伪类<br/>3. 伪类选择器其实更像是一个行为选择器（或状态选择器），它定义了一个/类标签在不同状态下的样式，书写形式如：<code>标签</code>: <code>状态/行为</code> <code>&#123;属性&#125;</code></td>
<td>.OnlineTitle:link {<br/>    color: #222222;<br/>    text-decoration: none;<br/>}</td>
</tr>
</tbody></table>
<p><strong>并集选择器</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">如要求将下方熊大、熊二及佩奇一家都改为粉色，则按照&lt;style&gt;中的方式进行书写</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">            //在两个没有从属关系（子代或后代）和相同特点（如同类标签）的同级不同类标签中，定义一个相同的样式</span><br><span class="line"><span class="css">            <span class="selector-tag">div</span>,</span></span><br><span class="line"><span class="css">            <span class="selector-tag">p</span>,</span></span><br><span class="line"><span class="css">            <span class="selector-class">.pig</span> <span class="selector-tag">li</span> &#123;                //类选择器</span></span><br><span class="line"><span class="css">                <span class="attribute">color</span>: pink;</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>熊大<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>熊二<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>关头强<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;pig&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>PIG 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>PIG 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>PIG 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>链接伪类选择器</strong></p>
<p>四个使用方式: link / visited / hover / active</p>
<ol>
<li>为了确保生效，应按照LVHA的顺序进行声明。</li>
<li><code>&lt;a&gt;</code> 链接在浏览器中具有默认样式，不会因为在<code>&lt;body&gt;</code>中而随之改变，实际工作中需要给链接单独指定样式。</li>
<li>使用时，加上冒号 <code>:</code> 与 四种<code>状态</code>之一 即可</li>
</ol>
<p>举例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="attribute">background-color</span>:yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当鼠标经过父级元素时，显示子元素的遮罩层：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tudou</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.mask</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: block;      <span class="comment">/* 显示遮罩层 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>最小盒子：</strong>即只能存放文字了，不能再存放其他标签/元素，如 <code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code>等文字块级标签；</p>
<h3 id="元素显示模式"><a href="#元素显示模式" class="headerlink" title="元素显示模式"></a>元素显示模式</h3><p>是指在页面上的元素以 <strong>块状模式</strong> 、 <strong>行内模式</strong> 或 <strong>行内块模式</strong> 进行显示。元素按显示模式可以分为 <strong>块状（级）元素</strong> 及 <strong>行内元素（内联元素）</strong> 及 <strong>行内块元素</strong> 三种类型。</p>
<table>
<thead>
<tr>
<th>元素类型</th>
<th>典型标签</th>
<th>特点</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>块状元素</td>
<td><code>&lt;h1&gt;</code>~`<h6><code>、</code><p><code>、 </code><div> <code>、</code><ul> <code>、</code><ol><code>、</code> <li>`……</td>
<td>1. 即使设置标签宽度，也是独占一行<br/>2. 高、宽、外边距及内边距可调节<br/>3. 默认宽度是父级宽度的100%<br/>4. 是一个容器及盒子，可以放任何标签</td>
<td>文字类的标签内不可以存放块元素</td>
</tr>
<tr>
<td>行内元素（内联元素）</td>
<td><code>&lt;a&gt;</code>、 <code>&lt;strong&gt;</code>、<code>&lt;b&gt;</code>、 <code>&lt;em&gt;</code>、<code>&lt;i&gt;</code> ……</td>
<td>1. 相邻行内元素在一行上，一行可以显示多个<br/>2. 直接设置宽高无效，可以间接设置<br/>3. 默认宽度就是其内容宽度<br/>4. 行内元素只能容纳文本及其他行内元素</td>
<td>1. 链接中不允许再放其他链接<br/>2. <code>&lt;a&gt;</code>中可以放置块元素，但是转换成块级元素最安全</td>
</tr>
<tr>
<td>行内块元素</td>
<td><code>&lt;input&gt;</code>、 <code>&lt;image&gt;</code>、<code>&lt;td&gt;</code>……</td>
<td>1. 同时具有块元素及行内元素的特定<br/>2. 和相邻行内元素（行内块）在一行上，但是有空白缝隙，可以一行显示多个<br/>3. 默认宽度即内容宽度<br/>4. 高度、行高、外边距及内边距可控制</td>
<td></td>
</tr>
</tbody></table>
<p><strong>元素显示模式的转换</strong></p>
<p>即一个模式的元素需要另一个模式的特性，可以通过在CSS的标签样式属性中添加display语句进行转换。</p>
<p>转换为块级元素： <em><code>display: block;</code></em> </p>
<p>转换为行内元素： <em><code>display: inline;</code></em> </p>
<p>转换为行内块元素： <em><code>display: inline-block;</code></em> </p>
<h3 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h3><table>
<thead>
<tr>
<th>选择器类型</th>
<th>权重</th>
</tr>
</thead>
<tbody><tr>
<td>继承</td>
<td>无</td>
</tr>
<tr>
<td>通配符选择器、子代选择器、相邻选择器（并集选择器）</td>
<td>0,0,0,0</td>
</tr>
<tr>
<td>元素选择器、伪元素选择器</td>
<td>0,0,0,1</td>
</tr>
<tr>
<td>类选择器、伪类选择器、属性选择器</td>
<td>0,0,1,0</td>
</tr>
<tr>
<td>ID选择器</td>
<td>0,1,0,0</td>
</tr>
<tr>
<td>内联选择器</td>
<td>1,0,0,0</td>
</tr>
<tr>
<td>!IMPORTANT</td>
<td>无限</td>
</tr>
</tbody></table>
<p>选择器的加权结果并非二进制，而是在各个数位上进行单独相加，例如元素选择器与类选择器的加权结果为 <code>0,0,1,1</code>，左侧数位的数值越大，权重越高。</p>
<h2 id="3-List"><a href="#3-List" class="headerlink" title="3. List"></a>3. List</h2><p><code>list-style</code> CSS 属性是一个简写对属性集合，包括<code>list-style-type</code>, <code>list-style-image,</code> 和 <code>list-style-position</code>。</p>
<p><code>list-style: none | circle | square inside ;</code>表示<code>&lt;ul&gt;</code> 下 <code>&lt;li&gt;</code> 前的小点样式，如“无、圆圈、实心方形”。</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>List Item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>List Item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>List Item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">List 2</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>List Item A<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>List Item B<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>List Item C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>及</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: circle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: square inside;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="4-Background"><a href="#4-Background" class="headerlink" title="4. Background"></a>4. Background</h2><p><code>background-color</code> 可以设置为 <code>transparent</code>，即透明的，不可视的。</p>
<p><code>background-image</code> 可以设置为 <code>none</code>，也可以跟上一个 <code>url()</code> 链接。如：<code>background-image: url(http://xxxxxx.com/123.jpg)</code></p>
<p><code>background-repeat: repeat | no-repea | repeat-x | repeat-y</code> ，分别是指 重复（平铺）、不平铺、在x轴上平铺 及 在y轴上平铺 。</p>
<p><code>background-position: top | bottom | left | right | center;</code> 除了可以使用类似于左侧的方位词定位，还可以使用坐标轴数值定位。</p>
<h2 id="5-Font"><a href="#5-Font" class="headerlink" title="5. Font"></a>5. Font</h2><p><strong>FONT-FAMILY 字体族</strong></p>
<p>通用属性之一，用于设置网页显示字体，font-family的使用方式为 <code>font-family=&quot; &quot;</code> ，双引号内可以书写多个字体，引擎会按顺序搜索本地字体并使用，如果都没有则使用本地字体。</p>
<p><strong>注意：</strong>建议使用字体的全英文进行书写，如 <strong>微软雅黑</strong> 全英文为 <strong>Microsoft YaHei</strong>，英文书写时有空格的应用单引号<code>‘’</code> 进行包裹。</p>
<p><strong>FONT-SIZE 字体大小</strong></p>
<p>通常用于对body标签内所有正文字体大小的设置，对标题（如<code>h3</code>）大小的设置仍需另起样式。</p>
<p><strong>复合写法</strong></p>
<p><code>font: font-style font-weight font-size/line-height font-family;</code></p>
<p><code>font-size</code> 和 <code>font-family</code> 不可缺省</p>
<h2 id="6-Text"><a href="#6-Text" class="headerlink" title="6. Text"></a>6. Text</h2><p><strong>文本属性</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>书写方式</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>color<br/>颜色</td>
<td>1. 常见英文表示法，直接书写该颜色英文即可，如 pink \ red \ blue \ purple<br/>2. 16进制表示法，用#号进行书写，如#FF00FF<br/>3. RGB表示法，如rgb(0,0,255)</td>
<td>16进制简写为#fff<br/>实际开发中用16进制</td>
</tr>
<tr>
<td>text-align<br/>文本对齐</td>
<td>仅有左、中、右三种表示方式，用英文 left \ center \ right 进行书写</td>
<td></td>
</tr>
<tr>
<td>text-indent<br/>文本缩进</td>
<td>缩进可以用2种方式表示：<br/>1. 精准缩进：即直接使用 <code>px</code> 单位进行书写，表示缩进多少像素点，缺点是容易出现问题<br/>2. 字符单位缩进：即按照字符大小，自适应缩进字符距离，单位是em，如 <code>2em</code>，可以缩进2个字符</td>
<td></td>
</tr>
<tr>
<td>text-decoration<br/>文本修饰</td>
<td>常见的修饰类型有四种：无（none）、上划线（overline）、下划线（underline）、删除线（line-through）</td>
<td></td>
</tr>
<tr>
<td>line-height</td>
<td>行高=上行距+下行距+字高，且上行距=下行距</td>
<td></td>
</tr>
</tbody></table>
<h2 id="7-Box-Module"><a href="#7-Box-Module" class="headerlink" title="7. Box Module"></a>7. Box Module</h2><p>盒子模型主要分三部分：<strong>border</strong>（边框）、<strong>padding</strong>（内边距）及 <strong>margin</strong>（外边距）。</p>
<h3 id="Border"><a href="#Border" class="headerlink" title="Border"></a>Border</h3><p>边框主要有一下三种参数：粗细、颜色及样式</p>
<ul>
<li>粗细(border-width: 5px;)</li>
<li>颜色(boder-color: #555) （<em>注意：如果这个值没有设置，它的默认值是元素的 color属性值（是文字颜色而非背景色）</em>），可以定义为transparent（透明的）</li>
<li>样式(boder-style: none | hidden | dotted | dashed | solid | double(双层线) | groove(内雕刻) | ridge(外浮雕) | inset(内凹陷) | outset(外凹陷) ) </li>
</ul>
<p>border属性之可以在中间添加上、下、左、右四个方位词和三参数之一，如 border-top-color | border-bottom-style ….</p>
<p>边框使用时会影响盒子大小，需要注意调整。</p>
<p><strong>复合写法</strong> </p>
<p><code>border: [border-width ||border-style ||border-color |inherit] ;</code></p>
<h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><p>内边距涉及到的参数包括 上下左右四边的边距。</p>
<p>在未设置内盒子的width时，设置padding对内盒子实际显示大小不起影响，一旦设置width，则会让盒子的width在显示时超过设置参数的大小。</p>
<h3 id="Margin"><a href="#Margin" class="headerlink" title="Margin"></a>Margin</h3><p>外边距同内边距。</p>
<p>在标准流下，设置块级盒子width参数后，设置margin左右为auto，可以让盒子实现居中效果。（以下三种写法，推荐第一个，第一个参数表示上下，第二个参数表示左右）</p>
<p><code>margin: 0 auto;</code></p>
<p><code>margin: auto;</code></p>
<p><code>margin-left: auto; margin-right: auto;</code></p>
<h3 id="Q-A"><a href="#Q-A" class="headerlink" title="Q/A"></a>Q/A</h3><p><strong>盒子塌陷的解决方案</strong></p>
<p>以下为两个盒子嵌套，同时设置上边距导致塌陷问题的解决方案：</p>
<ul>
<li>可以为父元素定义上边框/上内边距</li>
<li>可以为父元素添加 <code>overflow: hidden;</code></li>
<li>利用浮动、固定、绝对定位解决</li>
</ul>
<h2 id="8-Float"><a href="#8-Float" class="headerlink" title="8. Float"></a>8. Float</h2><p>浮动最初的开发目的是让图片和文字产生环绕效果的，浮动可以让多个块级元素在一行内显示。</p>
<p><code>float: none | left | right;</code></p>
<p><strong>注意：</strong>两个行内块元素中间会有空白间隙存在，如果父级元素设定了宽度，会让元素存放不下。需要给此类行内块元素设定浮动</p>
<p><strong>浮动特性：</strong></p>
<ul>
<li><p>脱标</p>
</li>
<li><p>顶端对齐</p>
</li>
<li><p>具有行内块元素特性</p>
</li>
</ul>
<p><strong>外边距合并</strong></p>
<blockquote>
<p>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p>
</blockquote>
<p><strong>注释：</strong>只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。</p>
<p>在标准流中嵌套一个带有外边距的浮动框，不会让他们产生外边距合并。</p>
<h2 id="9-Clean-Float"><a href="#9-Clean-Float" class="headerlink" title="9. Clean Float"></a>9. Clean Float</h2><p>清除浮动也叫闭合浮动，是指在未指定父级元素高度而子级元素为浮动时，会对父级元素同级的标准流造成影响，因而需要清除该类浮动造成的弊端的情况。</p>
<p>清除浮动的四种方式：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>写法</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>额外标签</td>
<td>[w3c推荐]也称隔墙法，指在浮动的块（行内块）级元素后面新增一个带有<code>clear: both;</code>属性的额外标签（要求是块级元素）来屏蔽浮动的影响。</td>
<td><code>clear: both;</code></td>
<td>弊端是增加了额外标签，对H5结构造成负担；<br/>要求新增的标签不能是行内元素</td>
</tr>
<tr>
<td>父级添加overflow</td>
<td>仅给父级元素添加overflow，添加hidden、auto、scroll皆可。</td>
<td>`overflow: hidden</td>
<td>auto</td>
</tr>
<tr>
<td>:after伪元素</td>
<td>额外标签法的升级版，利用CSS样式添加额外标签<br/>仅给父级元素添加</td>
<td>见下方</td>
<td>没有增加额外标签，样式写法较为复杂；</td>
</tr>
<tr>
<td>双伪元素</td>
<td>在子级前后各添加一个伪元素</td>
<td>见下方</td>
<td>代码简洁，照顾低版本。</td>
</tr>
</tbody></table>
<p><strong>:after伪元素代码示例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:after &#123;</span><br><span class="line">	content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="attribute">display</span>: block;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">clear</span>: both;</span><br><span class="line">	<span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;       <span class="comment">/* IE6、7专有 */</span></span><br><span class="line">	*zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><strong>双伪元素代码示例：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:before, .clearfix:after&#123;</span><br><span class="line">	content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span>:after&#123;</span><br><span class="line">	clear: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">	*zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="10-Position"><a href="#10-Position" class="headerlink" title="10. Position"></a>10. Position</h2><h3 id="定位的意义"><a href="#定位的意义" class="headerlink" title="定位的意义"></a>定位的意义</h3><p>让盒子自由地在某个盒子中移动或固定在屏幕中的某个位置，并且可以压住其他盒子。</p>
<p><strong>注意：</strong>对于标准流和浮动，不可以使用定位。</p>
<h3 id="定位模式"><a href="#定位模式" class="headerlink" title="定位模式"></a>定位模式</h3><p><code>position: static | relative | absolute | fixed ;</code></p>
<table>
<thead>
<tr>
<th>定位分类</th>
<th>脱标</th>
<th>使用情况</th>
<th>参考系</th>
<th>其他特点</th>
</tr>
</thead>
<tbody><tr>
<td>静态定位 <code>static</code></td>
<td>否，不能使用边偏移</td>
<td>很少</td>
<td>无，不设置边偏移</td>
<td>按照标准流特性摆放位置</td>
</tr>
<tr>
<td>相对定位 <code>relative</code></td>
<td>否，占用标准流的位置</td>
<td>常用</td>
<td>自身原来的位置</td>
<td>相对于自身原来的位置来移动<br/>设置相对定位后，后面的标准流<strong>不会脱标</strong>，不会让身后的标准流往前挤或往后挤；<br/>通常是给绝对定位当父级元素的属性</td>
</tr>
<tr>
<td>绝对定位 <code>absolute</code></td>
<td>是，不占用标准流的位置</td>
<td>常用</td>
<td>最近一级父级以上带有定位的盒子（子绝父相）</td>
<td>如果没有已定位的父级元素，则以浏览器进行绝对定位</td>
</tr>
<tr>
<td>固定定位 <code>fixed</code></td>
<td>是，不占用标准流的位置</td>
<td>常用</td>
<td>浏览器的可视窗口</td>
<td>与父级元素无关，不随窗口滚动条滚动<br/></td>
</tr>
<tr>
<td>粘性定位 <code>sticky</code></td>
<td>否，占用标准流的位置</td>
<td>很少</td>
<td>浏览器的可视窗口</td>
<td>相对定位和固定定位的混合体，具有两者的某些特点<br/>必须添加至少一个边偏移参数<br/>需与滚动搭配使用，对IE兼容性差，类似粘性定位的做法通常用JavaScript来做</td>
</tr>
</tbody></table>
<h3 id="边偏移"><a href="#边偏移" class="headerlink" title="边偏移"></a>边偏移</h3><p>相对于父级盒子（或者有定位的祖辈盒子）的边线偏移量（偏移量可以为负值）。</p>
<p>需要在设置好定位模式后边偏移才能生效。</p>
<p><strong>四种偏移：</strong>top、bottom、right、left；</p>
<p><strong>例：</strong><code>top: 10px; right: 20px;</code></p>
<p><strong>如何将内容固定到版心右侧？</strong></p>
<p>使用固定定位至左侧的50%，在调整<code>margin-left</code>值至版心宽度的一般（直接书写数值px）。</p>
<p><strong>如何让内容固定到屏幕正中心？</strong></p>
<p>使用固定定位至左侧和顶部的50%，再使用<code>margin-left</code>和<code>margin-right</code>的负值来抵消自身宽高的一半。</p>
<h3 id="定位显示优先级"><a href="#定位显示优先级" class="headerlink" title="定位显示优先级"></a>定位显示优先级</h3><p>定位显示优先级，即定位叠放顺序，是指 <strong>具有定位属性的盒子</strong>（类似于PS图层）在Z轴上的显示优先级，数值越大则优先级越高。</p>
<p>如果设置为<code>auto</code>，则按照H5结构书写顺序以“后来居上”的原则显示。</p>
<p>如果设置为数值，则比auto优先级更高，但是不能写单位。</p>
<p><code>z-index: (number) | auto;</code></p>
<h3 id="定位的特殊性质"><a href="#定位的特殊性质" class="headerlink" title="定位的特殊性质"></a>定位的特殊性质</h3><ul>
<li>给行内元素添加绝对或者固定定位后，可以设置宽度和高度（不等同于与块级元素互换特性？）</li>
<li>给块级元素添加绝对或者固定宽度后，不设置宽高也可以则应用内容的大小</li>
</ul>
<h2 id="11-显示与隐藏"><a href="#11-显示与隐藏" class="headerlink" title="11. 显示与隐藏"></a>11. 显示与隐藏</h2><p>显示与隐藏的三种方式：display（显示隐藏）、visibility（显示隐藏）、overflow （溢出显示隐藏）</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>用法</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>display（显示隐藏）</td>
<td>该属性本来是设置元素如何显示的；<br /><code>display: none;</code> 用于隐藏对象；<br /><code>display: block;</code> 除了用于转换成块级元素，还可以用于显示元素；</td>
<td>隐藏元素后，不再占有其原位置；<br />应用广泛，搭配js做网页特效用；</td>
</tr>
<tr>
<td>visibility（显示隐藏）</td>
<td>用于设置元素的可见性；<br />`visibility: visible</td>
<td>hidden</td>
</tr>
<tr>
<td>overflow （溢出显示隐藏）</td>
<td>仅针对溢出元素框的部分进行显示或隐藏；<br /><code>overflow: visible;</code> 设置时<code>clip</code>属性设置将失效；<br /><code>overflow: hidden;</code> 不显示超过对象尺寸的内容；<br /><code>overflow: scroll;</code> 以滚动条形式显示，不管是否内容是否溢出；<br /><code>overflow: auto; </code> 自动判断内容长度，按需添加滚动条；</td>
<td>如果带有定位属性，应慎用 <code>overflow: hidden;</code> ，会隐藏多余的部分</td>
</tr>
</tbody></table>
<h2 id="12-布局"><a href="#12-布局" class="headerlink" title="12. 布局"></a>12. 布局</h2><h3 id="常见的布局形式"><a href="#常见的布局形式" class="headerlink" title="常见的布局形式"></a>常见的布局形式</h3><p><strong>传统布局方式：</strong>普通流（文档流、标准流）、浮动、定位。</p>
<p><strong>通栏：</strong>是指和浏览器一样宽。</p>
<p><strong>布局设计准则：</strong></p>
<ul>
<li><p>纵向块级元素用标准流，横向块级元素用浮动。</p>
</li>
<li><p>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置，复合网页布局第一准则。</p>
</li>
<li><p>浮动的盒子只会影响浮动盒子后方的标准流，不影响前方的标准流。</p>
</li>
<li><p>应首先采用“一浮全浮”设计原则。</p>
</li>
<li><p>在产品列表数量众多、文字数量众多等不能明确盒子高度的情况下不应指定父级盒子的高度， 否则会出现父级盒子因高度限制而出现子元素无法显示的情况，应让子元素撑开父元素。</p>
</li>
<li><p>当给父元素设置标准流却未设置高度，而子元素为浮动时，父元素会高度塌陷。因浮动的子元素不占有高度，因此子元素浮动会会导致无高度的标准流父级元素高度塌陷，影响后续布局。</p>
</li>
</ul>
<h3 id="CSS属性书写建议"><a href="#CSS属性书写建议" class="headerlink" title="CSS属性书写建议"></a>CSS属性书写建议</h3><ol>
<li>布局定位属性：display / position / float / clear / visibility / overflow (建议display第一个写)</li>
<li>自身属性：width / height / margin / padding / border / background</li>
<li>文本属性：color / font / text-decoration / text-align / vertical-align / white-space / break-word</li>
<li>其他属性：content / cursor / border-radius / box-shadow / text-shadow / background:liner-gradient ….</li>
</ol>
<h3 id="页面布局的整体思路"><a href="#页面布局的整体思路" class="headerlink" title="页面布局的整体思路"></a>页面布局的整体思路</h3><ol>
<li>确定版心，即可视区</li>
<li>分析行、块 以及 块中的列模块</li>
<li>列模块经常浮动布局，确定列大小后确定列的位置</li>
<li>先结构，后样式</li>
</ol>
<h3 id="关于导航栏"><a href="#关于导航栏" class="headerlink" title="关于导航栏"></a>关于导航栏</h3><p>实际开发中，不会直接只用<code>&lt;a&gt;</code>来制作导航栏，而是用<code>&lt;li&gt;</code>包含链接的<code>&lt;li&gt;</code>+<code>&lt;a&gt;</code>来制作。</p>
<p><code>&lt;li&gt;</code>+<code>&lt;a&gt;</code>语义更加清晰，更为有条理的列表型内容。如果直接用<code>&lt;a&gt;</code>，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字存在被搜索引擎降权的风险），从而影响网站排名。</p>
<h2 id="13-特殊符号"><a href="#13-特殊符号" class="headerlink" title="13. 特殊符号"></a>13. 特殊符号</h2><p>小于号 &lt; <code>&amp;lt;</code></p>
<p>大于号 &gt; <code>&amp;gt;</code></p>
<h1 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h1><p>目标：</p>
<ul>
<li><p>能够使用精灵图</p>
</li>
<li><p>能够使用字体图标</p>
</li>
<li><p>能够写出CSS三角</p>
</li>
<li><p>能够写出常见的CSS用户界面样式</p>
</li>
<li><p>能够说出常见的布局技巧</p>
</li>
</ul>
<h2 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h2><p>CSS精灵技术的目的：减少客户端向服务器的请求次数，减小服务器的压力，提高网页的加载速度。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/01/15/Networking/2021-01-15-C-Socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/15/Networking/2021-01-15-C-Socket/" class="post-title-link" itemprop="url">C socket</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-15 23:58:32" itemprop="dateCreated datePublished" datetime="2021-01-15T23:58:32+08:00">2021-01-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-20 22:49:04" itemprop="dateModified" datetime="2021-05-20T22:49:04+08:00">2021-05-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Networking/" itemprop="url" rel="index"><span itemprop="name">Networking</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>在TCP/IP协议族中，网络层IP提供的是一种不可靠的服务。也就是说，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。而另一方面，TCP在不可靠的IP层上提供了一个可靠的运输层。为了提供这种可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。由此可见，运输层和网络层分别负责不同的功能。</p>
<p>在四层网络结构，由下之上分别是：<code>数据链路层</code>、<code>网络层</code>、<code>传输层</code>及<code>应用层</code>。</p>
<p>**数据链路层 **协议典型如：Ethernet、ARP、ICMP</p>
<p><strong>网络层</strong> 协议典型如：IP</p>
<p>**传输层 **协议典型如：TCP、UDP</p>
<p><strong>应用层</strong> 协议典型如：HTTP、FTP等</p>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/TCPIP-01.png" alt="TCPIP-01"></p>
<p style="text-align: center; color: #999; font-weight: 600;">图1-4 TCP/IP协议族中不同层次的协议</p>

<p>为协议ICMP和IGMP定位一直是一件很棘手的事情。在图1-4中，把它们与IP放在同一层上，那是因为事实上它们是IP的附属协议。但是在这里，又把它们放在IP层的上面，这是因为ICMP和IGMP报文都被封装在IP数据报中。</p>
<p>使用TCP/IP协议的应用程序通常采用两种应用编程接口（API）：socket和TLI（运输层接口：Transport Layer Interface）。前者有时称作“Berkeley Socket”，表明它是从 <strong>伯克利</strong> 版发展而来的。后者起初是由AT&amp;T开发的，有时称作XTI（X/Open运输层接口），以承认X/Open这个自己定义标准的国际计算机生产商所做的工作。XTI实际上是TLI的一个超集。</p>
<h2 id="TCP-Introduce"><a href="#TCP-Introduce" class="headerlink" title="TCP Introduce"></a>TCP Introduce</h2><p>TCP(Transmission Control Protocol)传输控制协议，是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。</p>
<h3 id="TCP-Structure"><a href="#TCP-Structure" class="headerlink" title="TCP Structure"></a>TCP Structure<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/20210218-03.png" alt="20210218-03"></h3><p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/20210218-02.png" alt="20210218-02"></p>
<table>
<thead>
<tr>
<th align="left">Definitions</th>
<th align="left">Length</th>
<th>Explain</th>
</tr>
</thead>
<tbody><tr>
<td align="left">源端口 Source Port</td>
<td align="left">16bits（2bytes）</td>
<td></td>
</tr>
<tr>
<td align="left">目的端口 Destination Port</td>
<td align="left">16bits（2bytes）</td>
<td></td>
</tr>
<tr>
<td align="left"><strong>序号 Sequence Number</strong></td>
<td align="left">32bits（4bytes）</td>
<td>指定了当前数据分片中分配给 <mark>第一字节数据</mark> 的序列号。<em><strong>在TCP传输流中每一个字节为一个序号</strong></em>。如果TCP报文中flags标志位为SYN，该序列号表示 ***初始化序列号(ISN)***，此时第一个数据应该是从序列号ISN+1开始。</td>
</tr>
<tr>
<td align="left"><strong>确认号 Acknowledgement Number</strong></td>
<td align="left">32bits（4bytes）</td>
<td>表示TCP发送者期望接受下一个数据分片的序列号。该序号在TCP分片中Flags标志位为ACK时生效。序列号分片的方向和流的方向同方向，而确认序列号分片方向和流方向反方向。</td>
</tr>
<tr>
<td align="left"><em>偏移量 Data-Offset</em></td>
<td align="left">4bits</td>
<td>数据偏移也叫首部长度。<br/>因为首部长度实际也说明了数据区在分片中的起始偏移值。它表示TCP头包含了多少个32-bit的words。因为4bits在十进制中能表示的最大值为15，32bits表示4个字节，那么Data Offset的最大可表示<code>15*4=60</code>个字节（bytes）。<br />所以TCP报头长度最大为60字节。如果<code>options field</code>为0的话，报文头长度为20个字节。</td>
</tr>
<tr>
<td align="left"><em>保留域 Reserved field</em></td>
<td align="left">3bits（或6bits）</td>
<td>值全为零</td>
</tr>
<tr>
<td align="left"><strong>标志位 Flags</strong></td>
<td align="left">9bits（或6bits）</td>
<td>表示TCP包特定的连接状态，一个标签位占一个bit。</td>
</tr>
<tr>
<td align="left">窗口 Window</td>
<td align="left">16bits（2bytes）</td>
<td>表示滑动窗口的大小，用来告诉发送端接收端的buffer space的大小。接收端buffer大小用来控制发送端的发送数据数率，从而达到流量控制。最大值为65535.</td>
</tr>
<tr>
<td align="left">检验和 Checksum</td>
<td align="left">16bits（2bytes）</td>
<td>用来检查TCP头在传输中是否被修改。</td>
</tr>
<tr>
<td align="left">紧急指针 Urgent Pointer</td>
<td align="left">16bits（2bytes）</td>
<td>表示TCP片中第一个紧急数据字节的指针。只有当URG标志置1时紧急指针才有效。</td>
</tr>
<tr>
<td align="left"><em><strong>可变部分 Options Field</strong></em> 和 <em><strong>填充部分 Padding Field</strong></em></td>
<td align="left">可变长度。</td>
<td>表示TCP可选选项以及填充位。当选项不足32bits时，填充字段加入额外的0填充。</td>
</tr>
</tbody></table>
<h3 id="TCP-Flags"><a href="#TCP-Flags" class="headerlink" title="TCP Flags"></a>TCP Flags</h3><p>对于旧版本的TCP头定义，Flags有6bits，新版TCP头对flags扩展了3bits。每个TCP flag对应于1bit 。所以旧版TCP头flags值有6个，新版扩展了3个值。</p>
<p>从低位到高位分别是：</p>
<table>
<thead>
<tr>
<th>Definition</th>
<th>Declaration</th>
</tr>
</thead>
<tbody><tr>
<td><strong>FIN</strong><br/> (finished 结束)</td>
<td>表示发送者以及发送完数据。通常用在发送者发送完数据的最后一个包中。</td>
</tr>
<tr>
<td><strong>SYN</strong><br/> (synchronous 建立联机)</td>
<td></td>
</tr>
<tr>
<td><strong>RST</strong><br/>(reset 重置)</td>
<td>重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。<br />或者发送包发送到一个不是期望的目的主机时，接收端发送reset 重置连接标志的包。</td>
</tr>
<tr>
<td><strong>PSH</strong><br/> (push 传送)</td>
<td>通知接收端处理接收的报文，而不是将报文缓存到buffer中。</td>
</tr>
<tr>
<td><strong>ACK</strong><br/>(acknowledgement 确认)</td>
<td></td>
</tr>
<tr>
<td><strong>URG</strong><br/> (urgent 紧急)</td>
<td>通知接收端处理在处理其他包前优先处理接收到的紧急报文。</td>
</tr>
<tr>
<td><strong>ECE</strong><br/> (Explicit Congestion Notification Echo) 【新】</td>
<td>表示TCP peer有ECN能力。</td>
</tr>
<tr>
<td><strong>CWR</strong><br/>(Congestion Window Reduced)【新】</td>
<td>发送者在接收到一个带有ECE flag包时，将会使用CWR flag。</td>
</tr>
<tr>
<td><strong>NS</strong><br/> (Nonce Sum)【新】</td>
<td>该标签用来保护不受发送者发送的突发的恶意隐藏报文的侵害。</td>
</tr>
</tbody></table>
<p>TCP 连接的建立都是采用<code>客户-服务器(Client-Server)</code>方式：</p>
<ul>
<li>主动发起连接建立的应用进程叫做客户(client)。</li>
<li>被等待连接建立的应用进程叫做服务器(server)。</li>
</ul>
<p>传输连接就有三个阶段，即：<strong>连接建立</strong>、<strong>数据传输</strong> 和 <strong>连接释放</strong> 。</p>
<p>TCP 采用全双工模式，在连接建立后和连接释放前进行数据传输。数据传输是单向的，从发送端传输给接受端。TCP通过序列号能够保证数据被接受端接受。TCP建立连接是通过三次握手的方式来建立连接的。</p>
<h2 id="TCP-Three-Way-Handshake"><a href="#TCP-Three-Way-Handshake" class="headerlink" title="TCP Three-Way Handshake"></a>TCP Three-Way Handshake</h2><blockquote>
<p><strong>注意</strong>： 不管是大小写，<code>ack</code>  ( 或 <code>Ack</code> )和 <code>ACK</code> 都是 <strong>确认</strong> 的意思， 不同之处在于：</p>
<ul>
<li>在TCP首部中，<code>ACK</code>为确认标志位 ——占 1 字节，只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。；</li>
<li><code>Ack</code>为确认号字段（Ack Number）——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。</li>
</ul>
</blockquote>
<h3 id="The-Steps-of-Three-Way-Handshake"><a href="#The-Steps-of-Three-Way-Handshake" class="headerlink" title="The Steps of Three-Way Handshake"></a>The Steps of Three-Way Handshake</h3><p><strong>第一次握手：</strong>Client发送位码为<code>SYN＝1</code> ，随机产生 <code>seq number=1234567</code> 的数据包到服务器，Server收到 <code>SYN=1</code>，知道Client要求建立联机；</p>
<p><strong>第二次握手：</strong>Server收到请求后要确认联机信息，向Client发送<code>ack number=(Client的seq+1)</code>，<code>SYN=1</code>， <code>ACK=1</code> ，随机产生 <code>seq number=7654321</code> 的包；</p>
<p><strong>第三次握手：</strong>Client 收到后检查 <code>ack number</code> 是否正确，即第一次发送的seq number+1，以及位码 <code>ACK</code>是否为 1，若正确，Client 会再发送 <code>ack number=(主机B的seq+1)</code> ，<code>ACK=1</code>，Server 收到后确认<code>seq number</code> 值与<code>ACK=1</code>则连接建立成功。</p>
<p>完成三次握手，主机A与主机B开始传送数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">Client -&gt;&gt; Server: SYN&#x3D;1  [seq number&#x3D;1234567]</span><br><span class="line">Server --&gt;&gt; Client: SYN &#x3D; 1, ACK &#x3D; 1  [ack number &#x3D; 1234568，seq number &#x3D; 7654321]</span><br><span class="line">Client -&gt;&gt; Server: ACK &#x3D; 1 [ack number &#x3D; 7654322]</span><br></pre></td></tr></table></figure>



<p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。<br><strong>第一次握手：</strong>建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；<br><strong>第二次握手：</strong>服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br><strong>第三次握手：</strong>客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据.</p>
<h3 id="The-Meaning-of-Three-way-handshake"><a href="#The-Meaning-of-Three-way-handshake" class="headerlink" title="The Meaning of Three-way handshake"></a>The Meaning of Three-way handshake</h3><p>向客户端确认这个请求，这两个数据包（前两次握手）足以证明客户端与服务器之间的网络是畅通的，并且协商数据通信所需要的参数。比如协商接收窗口大小，所支持的数据包最大字节数等。</p>
<p>如果没有最后一个数据包确认（第三次握手），A先发出一个建立连接的请求数据包，由于网络原因绕远路了。A经过设定的超时时间后还未收到B的确认数据包，于是发出第二个建立连接的请求数据包，这次网路通畅，数据包很快到达B，B的确认数据包也很快就到达A。于是A与B开始传输数据，过了一会A第一次发出的建立连接的请求数据包到达了B，B以为是再次建立连接，所以又发出一个确认数据包。由于A已经收到了一个确认数据包，所以会忽略B发来的第二个确认数据包，但是B发出确认数据包之后就要一直等待A的回复，而A永远也不会回复。由此造成服务器资源浪费，这种情况多了B计算机可能就停止响应了。</p>
<p>第三次握手（第三个数据包）作用在于，告诉B计算机，B第二次握手发给A的确认数据包A收到了，是有效的。避免B计算机等待造成资源浪费。随后A与B可进行下一步的通信。</p>
<p>**连接建立 **过程中要解决以下三个问题：</p>
<ul>
<li>要使每一方能够确知对方的存在。</li>
<li>要允许双方协商一些参数（如 <code>最大报文段长度</code>，<code>最大窗口大小</code>，<code>服务质量</code> 等）。</li>
<li>能够对运输实体资源（如 <code>缓存大小</code>，<code>连接表中的项目</code> 等）进行分配。</li>
</ul>
<p><strong>连接建立过程中，客户端存在以下状态：</strong></p>
<p><strong>SYN-SENT：</strong>在未与目标服务器建立连接之前始终处于此状态，并将不断向目标服务器发送请求，直到 <code>收到</code> 并 <code>回复</code> 来自服务器的信息后，方进入下一个状态。<br><strong>ESTABLISHED：</strong>稳定连接状态。</p>
<p><strong>连接建立过程中，服务器存在以下状态：</strong></p>
<p><strong>LISTEN：</strong> 在未与客户端建立连接之前，始终处于此状态，在收到客户端的连接请求后答复其请求，并进入下一个状态。<br><strong>SYN-RCVD：</strong> 等待SYN信息到达后进入下一个状态。<br><strong>ESTABLISHED：</strong>稳定连接状态。</p>
<p><img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/20210218-01.png" alt="20210218-01"></p>
<p><strong>连接建立文字图解：</strong></p>
<blockquote>
<p>Client 发出 <code>同步数据包（请求建立连接的数据包）</code> 并进入SYN-SENT状态。</p>
<ul>
<li>SYN = 1， 表示该为一个连接建立请求数据包；</li>
<li>ACK = 0，说明数据包确认号无效，省略；</li>
<li>Seq=x，x为所传送数据的第一个字节的序号。</li>
</ul>
<p>Server 收到Client发出的 <code>同步数据包</code> 后结束LISTEN状态，进入SYN-RCVD状态并向A发出 <code>确认同步数据包 </code>。</p>
<ul>
<li>SYN=1；</li>
<li>ACK=1；</li>
<li>seq=y，y的值由B指定表示B发送数据时的 <em><strong>第一个数据字节的序号</strong></em> ；</li>
<li>ack=x+1，表示已经收到A发送的x个字节数据，并告诉A下次应从数据的第x+1个字节开始发送。</li>
</ul>
<p>Client 收到<code>确认同步数据包 </code>之后，向B答复 <code>确认数据包</code> ，结束 SYN-SENT 状态，进入 ESTABLISHED 状态。</p>
<ul>
<li>SYN=0，表示双方已同意建立连接；</li>
<li>ACK=1，表示收到B的确认数据包；</li>
<li>seq=x+1，表示发出的数据包就是数据的第x+1个字节；</li>
<li>ack=y+1，表示收到了B发送y字节数据，并告诉B下次应从数据的第y+1个字节开始发送。</li>
</ul>
<p>Server 收到 Client 的 <code>确认数据包</code> 之后，结束SYN-RCVD状态，进入ESTABLISHED状态。</p>
</blockquote>
<h2 id="TCP-Four-Way-Wavehand"><a href="#TCP-Four-Way-Wavehand" class="headerlink" title="TCP Four-Way-Wavehand"></a>TCP Four-Way-Wavehand</h2><p>结束连接时，不管是Client或Server均可以主动发起结束信标FIN或RST。此处称主动发起结束信标的一方为主动方，另一方为被动方。</p>
<h3 id="The-Meaning-of-Four-Way-Wavehand"><a href="#The-Meaning-of-Four-Way-Wavehand" class="headerlink" title="The Meaning of Four-Way-Wavehand"></a>The Meaning of Four-Way-Wavehand</h3><p>当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。</p>
<p>但未必被动方所有的数据都完整的发送给了主动方，所以 <mark>被动方不会马上关闭SOCKET</mark>，它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。</p>
<h3 id="The-Steps-of-Four-Way-Wavehand"><a href="#The-Steps-of-Four-Way-Wavehand" class="headerlink" title="The Steps of Four-Way-Wavehand"></a>The Steps of Four-Way-Wavehand</h3><ol>
<li><p> <strong>第一次挥手：</strong>Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入 <code>FIN_WAIT_1</code> 状态。</p>
</li>
<li><p> <strong>第二次挥手：</strong>Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入``CLOSE_WAIT` 状态。</p>
</li>
<li><p> <strong>第三次挥手：</strong>Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入 <code>LAST_ACK</code> 状态。</p>
</li>
<li><p> <strong>第四次挥手：</strong>Client收到FIN后，Client进入``TIME_WAIT<code>状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入</code>CLOSED` 状态，完成四次挥手</p>
</li>
</ol>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/70.jpg" style="zoom:50%;" />





<h3 id="RST"><a href="#RST" class="headerlink" title="RST"></a>RST</h3><h4 id="Differences-between-FIN-and-RST"><a href="#Differences-between-FIN-and-RST" class="headerlink" title="Differences between FIN and RST"></a>Differences between FIN and RST</h4><blockquote>
<p><strong>关键字：</strong> 主动释放、有序释放、终止释放</p>
</blockquote>
<p><strong>释放</strong> 即发送方和接收方终止连接，解除连接状态。</p>
<p>发送方和接收方均可主动释放。最常见的是，主动释放端会发送<code>FIN</code>包，并且因为TCP是双工的， 仅关闭一个方向上的数据流，从而TCP连接处于<strong>半关闭状态</strong>，继续完成四次挥手完成连接释放。</p>
<p>上述挥手是一种 <strong>有序释放</strong> ， 即，标志位为<code>FIN</code>的TCP报文会在之前所有排队的数据发送完之后，才会发送，在socket缓冲区和窗口中的数据也能保证发送成功。</p>
<p>通常我们调用 <code>shutdown()</code> , <code>close()</code> 函数后， TCP会发送<code>FIN</code>报文。</p>
<blockquote>
<p>shutdown 和 close 的区别：</p>
<ul>
<li>shutdown是关闭一个socket， 可以关闭读、写、读写；</li>
<li>close是关闭一个linux系统的文件描述符fd。</li>
</ul>
</blockquote>
<p>除了“有序释放”， 还有一种 <strong>终止释放</strong> ，比如进程异常退出，用来关闭异常连接使用，是通过 <code>RST</code> 标志位实现的。 标志位为 <code>RST</code> 的TCP报文，会立即发送，<u>而之前所有在缓存区排队的数据都将被RST发送方丢弃。</u></p>
<p><mark>FIN报文需要应答 <code>ACK</code> , RST报文不需要应答 <code>ACK</code>。</mark></p>
<p><strong>半开连接</strong>：如果发生断点，或网络条件很差，其中一端发送 <code>RST</code> 后会立马关闭连接；而另一端可能感知不到，仍然认为连接正常，造成一种半开连接的状态。</p>
<h4 id="Why-do-we-send-RST"><a href="#Why-do-we-send-RST" class="headerlink" title="Why do we send RST?"></a>Why do we send RST?</h4><p>RST标志位被发送，通常是因为一下几种原因：</p>
<blockquote>
<ol>
<li>A向B发起连接，但B之上并没有应用监听相应的端口，这时B操作系统上的TCP处理程序会发RST包。</li>
<li>请求超时，即由于主动连接端连接请求超时，主动发起RST关闭连接。</li>
<li>在一个已关闭的socket上收到数据</li>
<li>字节流接收不完全</li>
</ol>
</blockquote>
<p><strong>情况二：</strong><br>有89、27两台主机。主机89向主机27发送了一个SYN，表示希望连接8888端口，主机27回应了主机89一个SYN表示可以连接。但是主机89却很不友好，莫名其妙的发送了一个RST表示我不想连接你了。<br>后来经过排查发现，在主机89上的程序在建立了socket之后，用setsockopt的SO_RCVTIMEO选项设置了recv的超时时间为100ms。而我们看上面的抓包结果表示，从主机89发出SYN到接收SYN的时间多达110ms。（从15:01:27.799961到15:01:27.961886， 小数点之后的单位是微秒）。因此主机89上的程序认为接收超时，所以发送了RST拒绝进一步发送数据。</p>
<p><strong>情况三：</strong><br>比如，AB正常建立连接了，正在通讯时，A向B发送了FIN包要求关连接，B发送ACK后，网断了，A通过若干原因排查后放弃了这个连接（例如进程重启）。网通了后，B又开始发数据包，A收到后表示压力很大，不知道这野连接哪来的，就发了个RST包强制把连接关了，B收到后会出现connect reset by peer错误。</p>
<h1 id="Wireshark-Tutorial"><a href="#Wireshark-Tutorial" class="headerlink" title="Wireshark Tutorial"></a>Wireshark Tutorial</h1><p>Wireshark是一款可以监听和捕捉网络通信数据的软件，对捕获的数据自下而上进行解码和分析至已知协议。如(Ethernet II – IP – TCP 或 Ethernet II – IP – TCP – HTTP)。</p>
<p>Wireshark主要通过 <strong>捕获过滤</strong> 和 <strong>显示过滤</strong> 对所有数据进行 <strong>捕获时过滤</strong> 或 <strong>捕获后显示过滤</strong>。</p>
<h2 id="Capturing-Filters-捕获过滤"><a href="#Capturing-Filters-捕获过滤" class="headerlink" title="Capturing Filters 捕获过滤"></a>Capturing Filters 捕获过滤</h2><h3 id="Filtering-packets-while-capturing-捕获时可用的过滤组件"><a href="#Filtering-packets-while-capturing-捕获时可用的过滤组件" class="headerlink" title="Filtering packets while capturing 捕获时可用的过滤组件"></a>Filtering packets while capturing 捕获时可用的过滤组件</h3><p>Capture Filters are used to filter out uninteresting packets already at capture time. This is done to reduce the size of the resulting capture (file) and is especially useful on high traffic networks or for long term capturing.  </p>
<p>Wireshark uses the pcap (libpcap/WinPcap) filter language for capture filters. This language is explained in the tcpdump man page under “expression” (<a target="_blank" rel="noopener" href="http://www.tcpdump.org/">http://www.tcpdump.org</a> and search for “selects which”).</p>
<p>Note: This capture filter language is different from the one used for the Wireshark display filters!</p>
<p>捕获过滤器的使用方式为：菜单栏上的 <code>捕获</code> –&gt; <code>选项</code> –&gt; <code>所选择接口的捕获过滤器</code> 中输入对应的过滤条件。</p>
<hr>
<h4 id="Some-common-examples-一些通用示例"><a href="#Some-common-examples-一些通用示例" class="headerlink" title="Some common examples 一些通用示例"></a>Some common examples 一些通用示例</h4><p><strong>Example Ethernet:</strong> capture all traffic to and from the Ethernet address 08:00:08:15:ca:fe</p>
<p>ether <code>host 08:00:08:15:ca:fe</code></p>
<p><strong>Example IP:</strong> capture all traffic to and from the IP address 192.168.0.10</p>
<p><code>host 192.168.0.10</code></p>
<p><strong>Example TCP:</strong> capture all traffic to and from the TCP port 80 (http) of all machines</p>
<p><code>tcp port 80</code></p>
<p><strong>Examples combined:</strong> capture all traffic to and from 192.168.0.10 except http</p>
<p><code>host 192.168.0.10 and not tcp port 80</code></p>
<p>Beware: if you capture TCP/IP traffic with the primitives “host” or “port”, you will not see the ARP traffic belonging to it!</p>
<hr>
<h4 id="Capture-Filter-Syntax-捕获过滤器标志"><a href="#Capture-Filter-Syntax-捕获过滤器标志" class="headerlink" title="Capture Filter Syntax 捕获过滤器标志"></a>Capture Filter Syntax 捕获过滤器标志</h4><p>The following is a short description of the capture filter language syntax. For a further reference, have a look at: <a target="_blank" rel="noopener" href="http://www.tcpdump.org/tcpdump_man.html">http://www.tcpdump.org/tcpdump_man.html</a></p>
<p>A capture filter takes the form of a series of <strong>primitive expressions</strong>, connected by conjunctions (and/or) and optionally preceded by not:</p>
<p><strong>[not] primitive [and|or [not] primitive …]</strong></p>
<p>A primitive is simply one of the following:</p>
<p><strong>[src|dst] host <host></strong></p>
<p>This primitive allows you to filter on a host IP address or name. You can optionally precede the primitive with the keyword <code>src|dst</code> to specify that you are only interested in source or destination addresses. If these are not present, packets where the specified address appears as either the source or the destination address will be selected.</p>
<p><strong>ether [src|dst] host <ehost></strong></p>
<p>This primitive allows you to filter on Ethernet host addresses. You can optionally include the keyword <code>src|dst</code> between the keywords ether and host to specify that you are only interested in source or destination addresses. If these are not present, packets where the specified address appears in either the source or destination address will be selected.</p>
<p><strong>gateway host <host></strong></p>
<p>This primitive allows you to filter on packets that used host as a gateway. That is, where the Ethernet source or destination was host but neither the source nor destination IP address was host.</p>
<p><strong>[src|dst] net <net> [{mask <mask>}|{len <len>}]</strong></p>
<p>This primitive allows you to filter on network numbers. You can optionally precede this primitive with the keyword <code>src|dst</code> to specify that you are only interested in a source or destination network. If neither of these are present, packets will be selected that have the specified network in either the source or destination address. In addition, you can specify either the netmask or the <strong>CIDR</strong> <em>(Classless Inter-Domain Routing)</em> prefix for the network if they are different from your own.</p>
<p><strong>[tcp|udp] [src|dst] port <port></strong></p>
<p>This primitive allows you to filter on TCP and UDP port numbers. You can optionally precede this primitive with the keywords src|dst and tcp|udp which allow you to specify that you are only interested in source or destination ports and TCP or UDP packets respectively. The keywords tcp|udp must appear before src|dst.<br>If these are not specified, packets will be selected for both the TCP and UDP protocols and when the specified address appears in either the source or destination port field.</p>
<p><strong>less|greater <length></strong></p>
<p>This primitive allows you to filter on packets whose length was less than or equal to the specified length, or greater than or equal to the specified length, respectively.</p>
<p><strong>ip|ether proto <protocol></strong></p>
<p>This primitive allows you to filter on the specified protocol at either the Ethernet layer or the IP layer.</p>
<p>ether|ip broadcast|multicast</p>
<p>This primitive allows you to filter on either Ethernet or IP broadcasts or multicasts.</p>
<p><strong><expr> relop <expr></strong></p>
<p>This primitive allows you to create complex filter expressions that select bytes or ranges of bytes in packets. Please see the tcpdump man pages for more details.</p>
<h2 id="Capturing-捕获"><a href="#Capturing-捕获" class="headerlink" title="Capturing 捕获"></a>Capturing 捕获</h2><p>This section will explain the capturing options and give hints on what to do in some special cases.</p>
<h3 id="Capture-options-捕获设置"><a href="#Capture-options-捕获设置" class="headerlink" title="Capture options 捕获设置"></a>Capture options 捕获设置</h3><p>The capture options can be logically divided into the following categories:</p>
<p>-input<br>-filtering<br>-stop conditions<br>-storing<br>-display while capturing</p>
<h3 id="Input-options-输入设置"><a href="#Input-options-输入设置" class="headerlink" title="Input options 输入设置"></a>Input options 输入设置</h3><p><strong>-Interface</strong>: You have to choose which interface (network card) will be used to capture packets from. Be sure to select the correct one, as it’s a common mistake to select the wrong interface.</p>
<p><strong>-Link-layer header type</strong>: unless you are in the rare case that you will need this, just keep the default.</p>
<h3 id="Filtering-options-过滤设置"><a href="#Filtering-options-过滤设置" class="headerlink" title="Filtering options 过滤设置"></a>Filtering options 过滤设置</h3><p><strong>-Capture packets in promiscuous mode</strong>: Usually a network card will only capture the traffic to its own network address. If you want to capture all traffic that the network card can “see”, mark this option. See the FAQ for some more details of capturing packets from a switched network.</p>
<p><strong>-Limit each packet to xy bytes</strong>: Will limit the maximum size to be captured of each packet, this includes the link-layer header and all subsequent headers. This can be useful when an error is known to be in the first 20 bytes of a packet, for example, as the size of the resulting capture file will be reduced.</p>
<p><strong>-Capture Filter</strong>: Use a capture filter to reduce the amount of packets to be captured. See “Capture Filters” in this help for further information how to use it.</p>
<h3 id="Storing-options-存储设置"><a href="#Storing-options-存储设置" class="headerlink" title="Storing options 存储设置"></a>Storing options 存储设置</h3><p><strong>-File</strong>: You can choose the file to which captured data will be written. If you don’t enter something here a temporary file will be used.</p>
<p><strong>-Use multiple files</strong>: Instead of using a single capture file, multiple files will be created. The generated filenames will contain an incrementing number and the start time of the capture. For example, if you choose “/foo.cap” in the “File” field, files like “/foo_00001_20040205110102.cap”, “/foo_00002_20040205110102.cap”, … will be created.<br>This feature can be useful if you do long term capturing, as working with a single capture file of several GB usually isn’t very fast.</p>
<h3 id="Stop-condition-options-终止设置"><a href="#Stop-condition-options-终止设置" class="headerlink" title="Stop condition options 终止设置"></a>Stop condition options 终止设置</h3><p>These three fields should be obvious; the capture process will be automatically stopped if one of the selected conditions is exceeded.</p>
<h3 id="Display-while-capturing-options"><a href="#Display-while-capturing-options" class="headerlink" title="Display while capturing options"></a>Display while capturing options</h3><p>-Update list of packets in real time: Using this will show the captured packets immediately on the main screen.<br>Please note: this will slow down capturing, so increased packet drops might appear.</p>
<p>-Automatic scrolling in live capture: This will scroll the “Packet List” automatically to the latest captured packet, when the “Update List of packets in real time” option is used.</p>
<p>-Name resolution: perform the corresponding name resolution while capturing.</p>
<h3 id="High-performance-capturing-高性能模式捕获"><a href="#High-performance-capturing-高性能模式捕获" class="headerlink" title="High performance capturing 高性能模式捕获"></a>High performance capturing 高性能模式捕获</h3><p>When your network traffic is high, you might need to take some steps to ensure Wireshark doesn’t get behind on its capture, particularly if you’re running it on a slow computer.</p>
<p>When Wireshark cannot keep up, packets are dropped. To help avoid this as much as possible:</p>
<p>a) Don’t use the “Update list of packets in real time” option (see above). This has a significant performance penalty.</p>
<p>b) Close other programs that might slow down your system, such as virus scanner software, server processes, etc.</p>
<p>c) It might be a good idea not to use a capture filter. This will depend on the task you have to do.<br>As a rule of thumb: if you want to see most of the packets and only filter a small number out, don’t use a capture filter (you can use a display filter later). If you only want to capture a small proportion of the packets, it might be better to set a capture filter, as this will reduce the number of packets that have to be saved.</p>
<p>d) If you still get packet drops, it might be an idea to use a tool dedicated to packet capturing and only use Wireshark for displaying and analyzing the packets.</p>
<p>Have a look at tshark, the command line variant of wireshark, which is included in this package.<br>XXX: add a list of possibly useful standalone capture programs.</p>
<h3 id="Long-term-capturing-长期捕获"><a href="#Long-term-capturing-长期捕获" class="headerlink" title="Long term capturing 长期捕获"></a>Long term capturing 长期捕获</h3><p>By “Long term capturing”, it’s meant to capture data from a network for several hours or even days. Long term capturing will usually result in huge capture files, being hundreds of MB’s or even several GB’s in size!</p>
<p>Before doing a long term capture, get familiar with the options to use for it, as you might not get what you desire. Doing a long term capture not getting the results needed, is usually wasting a lot of time. ;-)</p>
<p>Rules of thumb for this task:<br>-Use the ring buffer feature when you expect very large capture files.<br>-Don’t use the “Update list of packets in real time” option.<br>-Set an appropriate capture filter, when you are only interested in some special packets from the net.</p>
<h2 id="Display-Filter-显示过滤器"><a href="#Display-Filter-显示过滤器" class="headerlink" title="Display Filter 显示过滤器"></a>Display Filter 显示过滤器</h2><h3 id="Filtering-packets-while-viewing-观察时的过滤器组件"><a href="#Filtering-packets-while-viewing-观察时的过滤器组件" class="headerlink" title="Filtering packets while viewing 观察时的过滤器组件"></a>Filtering packets while viewing 观察时的过滤器组件</h3><p>After capturing packets or loading some network traffic from a file, Wireshark will display the packet data immediately on the screen.</p>
<p>Using display filters, you can choose which packets should (not) be shown on the screen. This is useful to reduce the “noise” usually on the network, showing only the packets you want to. So you can concentrate on the things you are really interested in. </p>
<p>The display filter will not affect the data captured, it will only select which packets of the captured data are displayed on the screen.</p>
<p>Every time you change the filter string, all packets will be reread from the capture file (or from memory), and processed by the display filter “machine”. Packet by packet, this “machine” is asked, if this particular packet should be shown or not.</p>
<p>Wireshark offers a very powerful display filter language for this. It can be used for a wide range of purposes, from simply: “show only packets from a specific IP address”, or on the other hand, to very complex filters like: “find all packets where a special application specific flag is set”.</p>
<p>Note: This display filter language is different from the one used for the Wireshark capture filters!</p>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><h4 id="constains-和-matches"><a href="#constains-和-matches" class="headerlink" title="constains 和 matches"></a>constains 和 matches</h4><p><strong>contains</strong> 用来判断是否包含一个值，<strong>matches</strong> 用来判断是否匹配一个表达式</p>
<hr>
<h3 id="Some-common-examples-一些通用示例-1"><a href="#Some-common-examples-一些通用示例-1" class="headerlink" title="Some common examples 一些通用示例"></a>Some common examples 一些通用示例</h3><p><strong>Example Ethernet</strong>: display all traffic to and from the Ethernet address 08.00.08.15.ca.fe</p>
<p><code>eth.addr==08.00.08.15.ca.fe</code></p>
<p><strong>Example IP</strong>: display all traffic to and from the IP address 192.168.0.10</p>
<p><code>ip.addr==192.168.0.10</code></p>
<p><strong>Example TCP</strong>: display all traffic to and from the TCP port 80 (http) of all machines</p>
<p><code>tcp.port==80</code></p>
<p><strong>Examples combined</strong>: display all traffic to and from 192.168.0.10 except http</p>
<p><code>ip.addr==192.168.0.10 &amp;&amp; tcp.port!=80</code></p>
<p>Beware: The filter string builds a logical expression, which must be true to show the packet. The &amp;&amp; is a “logical and”, “A &amp;&amp; B” means: A must be true AND B must be true to show the packet (it doesn’t mean: A will be shown AND B will be shown). </p>
<hr>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>Filtering can lead to side effects, which are sometimes not obvious at first sight. Example: If you capture TCP/IP traffic with the primitive “ip”, you will not see the ARP traffic belonging to it, as this is a lower protocol layer than IP!</p>
<h2 id="WIRESHARK中的各种标志（TCP）"><a href="#WIRESHARK中的各种标志（TCP）" class="headerlink" title="WIRESHARK中的各种标志（TCP）"></a>WIRESHARK中的各种标志（TCP）</h2><h3 id="OUT-OF-ORDER"><a href="#OUT-OF-ORDER" class="headerlink" title="OUT OF ORDER"></a>OUT OF ORDER</h3><p><code>TCP Out-of-Order</code> </p>
<p><strong>正常情况：</strong>在TCP传输过程中，同一台主机发出的数据段应该是连续的，即后一个包的 <code>Seq</code> 号等于前一    个包的 <code>Seq</code> + <code>Len</code> （三次握手和四次挥手是例外）。</p>
<p>异常情况：当Wireshark发现后一个包的 <code>Seq</code> 号 <mark>小于</mark> 前一个包的 <code>Seq</code> + <code>Len</code> 时，就会认为是乱序了，因此提示 <code>TCP Out-of-Order</code> 。</p>
<h3 id="Previous-segment-not-captured"><a href="#Previous-segment-not-captured" class="headerlink" title="Previous segment not captured"></a>Previous segment not captured</h3><p><code>Previous segment not capturedd</code> ，即报文缺失，指存在未抓取的数据包</p>
<p><strong>正常情况：</strong>在TCP传输过程中，同一台主机发出的数据段应该是连续的，即后一个包的 <code>Seq</code> 号等于前一个包的 <code>Seq</code> + <code>Len</code> （三次握手和四次挥手是例外）。</p>
<p><strong>异常情况：</strong>如果Wireshark发现后一个包的 <code>Seq</code> 号大于前一个包的 <code>Seq</code> + <code>Len</code> ，就知道中间缺失了一段数据。假如缺失的那段数据在整个网络包中都找不到（即排除了乱序），就会提示<code>TCP Previous segment not captured</code> 。</p>
<blockquote>
<p><strong>TCP Previous segment lost</strong> - Occurs when a packet  arrives with a sequence number greater than the “next expected sequence  number” on that connection, indicating that one or more packets prior to the flagged packet did not arrive. This event is a good indicator of  packet loss and will likely be accompanied by “TCP Retransmission”  events.</p>
<p>– Wireshark</p>
</blockquote>
<h3 id="TCP-DUP-ACK"><a href="#TCP-DUP-ACK" class="headerlink" title="TCP DUP ACK"></a>TCP DUP ACK</h3><p><code>Tcp Dup Ack xxx#y</code> ，即重复确认。</p>
<p>当乱序或者丢包发生时，接收方会收到一些Seq号比期望值大的包。</p>
<p><u>接收方每收到一个这种包就会进行答复，<code>Ack</code> 一次期望的 <code>Seq</code> 值，以此方式来提醒发送方，于是就产生了一些重复的 <code>Ack</code> 。</u> </p>
<p>Wireshark会在这种重复的Ack上标记 <code>TCP Dup ACK</code> ，代表了数据段丢失 TCP 状态，<code>xxx</code> 代表数据丢失的位置， <code>y</code> 后代表第几次丢失报文。</p>
<h3 id="TCP-Fast-Retransmission"><a href="#TCP-Fast-Retransmission" class="headerlink" title="TCP Fast Retransmission"></a>TCP Fast Retransmission</h3><p>快速重传，当发送方收到来自接收方的3个或以上<code>TCP Dup ACK</code> ，就意识到之前发的包可能丢了，于是发送方快速重传该数据（这是RFC的规定）。</p>
<h3 id="TCP-Spurious-Retransmission"><a href="#TCP-Spurious-Retransmission" class="headerlink" title="TCP Spurious Retransmission"></a>TCP Spurious Retransmission</h3><h3 id="TCP-Retransmission"><a href="#TCP-Retransmission" class="headerlink" title="TCP Retransmission"></a>TCP Retransmission</h3><p>超时重传。</p>
<p>如果一个包真的丢了，且无后续包，则可以在接收方触发 <code>Dup Ack</code> ，就不会快速重传。</p>
<p>这种情况下发送方只好等到超时了再重传，此类重传包就会被Wireshark标上 <code>TCP Retransmission</code> 。</p>
<h3 id="TCP-ACKed-unseen-segment"><a href="#TCP-ACKed-unseen-segment" class="headerlink" title="TCP ACKed unseen segment"></a>TCP ACKed unseen segment</h3><p>抓取遗漏。</p>
<p>当Wireshark发现被Ack的那个包没被抓到，就会提示 <code>TCP ACKed unseen  segment</code>， 即此为由于抓包不到造成的报错。</p>
<p><em>这可能是最常见的Wireshark提示了，幸好它几乎是永远可以忽略的。</em></p>
<p>以图3为例，32号包的<code>Seq=6889</code>  <code>Len=1448</code> ，相加得 8337，说明服务器发出的下一个包应该是 <code>Seq=8337</code>。而我们看到的却是35号包的<code>Seq=11233</code>，这意味着 8337～11232 这段数据没有被抓到。这段数据本应该出现在34号之前，所以Wireshark提示了<code>TCP ACKed unseen segment</code>。</p>
<img src="http://tc.sinaimg.cn/maxwidth.2048/tc.service.weibo.com/community_emc_com/8ccefb660da3f07e9a83e0625c6c7f19.png" style="zoom:150%;" />



<h3 id="TCP-Zerowindow"><a href="#TCP-Zerowindow" class="headerlink" title="TCP Zerowindow"></a>TCP Zerowindow</h3><p>窗口清零。</p>
<p>TCP包中的 <code>win=</code> 代表接收窗口的大小，即表示这个包的发送方当前还有多少缓存区可以接收数据。</p>
<p>当Wireshark在一个包中发现 <code>win=0</code> 时，就会给它打上 <code>TCP  zerowindow</code> 的标志，表示缓存区已满，不能再接受数据了。下图就是服务器的缓存区已满，所以通知客户端不要再发数据了。我们甚至可以在3258～3263这几个包中看出它的窗口逐渐减少的过程，即从 <code>win=15872</code> 减小到 <code>win=1472</code> 。</p>
<img src="http://tc.sinaimg.cn/maxwidth.2048/tc.service.weibo.com/community_emc_com/1b59377ebee4107bed8557a6a4a9d35f.png" style="zoom:150%;" />



<h3 id="TCP-Window-Update"><a href="#TCP-Window-Update" class="headerlink" title="TCP Window Update"></a>TCP Window Update</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Sockets API和Internet在许多 <em><strong>竞争性协议族</strong></em>（包括 <em>IPX</em>、<em>AppleTalk</em>、<em>DECNet</em>、<em>OSI</em>、<em>SNA</em> 及 <em>TCP</em>/IP）的世界中逐渐成长起来，并且 <mark>Sockets被设计成支持所有这些协议</mark> 。</p>
<h3 id="IPv4映射"><a href="#IPv4映射" class="headerlink" title="IPv4映射"></a>IPv4映射</h3><p>IPv4映射的地址是通过在IPv4地址前添加4个字节的前缀 <code>::fff:</code> 而构成。</p>
<p>如，<code>132.3.23.7 </code> 的IPv4地址映射至IPv6即 <code>::ffff:132.3.32.7</code> 。</p>
<p>协议互操作性</p>
<h3 id="回送地址"><a href="#回送地址" class="headerlink" title="回送地址"></a>回送地址</h3><p>IPv4的回送地址是<code>127.0.0.1</code></p>
<p>IPv6的回送地址是 <code>0:0:0:0:0:0:0:1</code></p>
<h3 id="专用网络地址"><a href="#专用网络地址" class="headerlink" title="专用网络地址"></a>专用网络地址</h3><p>以 <code>10</code> 、<code>192.168</code> 、<code>172.16</code>~`172.31`开头的地址最初被指定在不属于全球Internet的专用网络中使用。</p>
<h3 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h3><p>Hostname是指 <em>计算机名称</em> ，Domain Name是指 <em>域名</em> 。</p>
<p>通常情况下，一个name都是指Hostname。</p>
<h1 id="C-Socket-in-TI"><a href="#C-Socket-in-TI" class="headerlink" title="C Socket in TI"></a>C Socket in TI</h1><h2 id="NETCTRL-H-及-SOCKET-H"><a href="#NETCTRL-H-及-SOCKET-H" class="headerlink" title="NETCTRL.H 及 SOCKET.H"></a>NETCTRL.H 及 SOCKET.H</h2><p>以下两句话是TI官方对<code>&lt;netctrl.h&gt;</code> 的描述，即简易控制网络开断的包装函数，以此类方法实现接口的目的是隐藏可以被调用的HAL/STACK功能</p>
<blockquote>
<ul>
<li>Shell functions for simplified net startup and shutdown</li>
<li>The idea behind this API is to hide the user callable HAL/STACK functions</li>
</ul>
</blockquote>
<p><code>&lt;netctrl.h&gt;</code> 是用于初始化和维护服务的。为了完成此功能，其调用了NETTOOLS库提供的配置管理器。要注意的是，此处的配置定义和结构声明是对针对NETCTRL 的，而不是针对 CONFIG。</p>
<blockquote>
<p>NETCTRL is used to initialize the stack and maintain services. To accomplish this, it makes use of the configuration manager provided in the NETTOOLS library. Note that the configuration definitions and structures defined here are specific to NETCTRL, not CONFIG.</p>
</blockquote>
<h3 id="NETCTRL-API"><a href="#NETCTRL-API" class="headerlink" title="NETCTRL API"></a>NETCTRL API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化运行环境</span></span><br><span class="line"><span class="function">_extern <span class="keyword">int</span>  <span class="title">NC_SystemOpen</span><span class="params">( <span class="keyword">int</span> Priority, <span class="keyword">int</span> OpMode )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数可选择任务等级高或任务等级低</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_PRIORITY_LOW             OS_SCHEDULER_LOWPRI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_PRIORITY_HIGH            OS_SCHEDULER_HIGHPRI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义打开模式为POLLING或中断</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPMODE_POLLING           1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPMODE_INTERRUPT         2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NC_SystemOpen()的返回结果</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPEN_SUCCESS             0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPEN_ILLEGAL_PRIORITY    -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPEN_ILLEGAL_OPMODE      -2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPEN_MEMINIT_FAILED      -3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC_OPEN_EVENTINIT_FAILED    -4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭运行环境</span></span><br><span class="line"><span class="function">_extern <span class="keyword">void</span> <span class="title">NC_SystemClose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用提供的配置信息开启网络</span></span><br><span class="line"><span class="function">_extern <span class="keyword">int</span> <span class="title">NC_NetStart</span><span class="params">( HANDLE hCfg, <span class="keyword">void</span> (*NetStart)(),</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">void</span> (*NetStop)(), <span class="keyword">void</span> (*NetIP)(IPN,uint,uint) )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开网络</span></span><br><span class="line"><span class="function">_extern <span class="keyword">void</span> <span class="title">NC_NetStop</span><span class="params">( <span class="keyword">int</span> rc )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当Boot线程完成时被调用</span></span><br><span class="line"><span class="function">_extern <span class="keyword">void</span> <span class="title">NC_BootComplete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当IP地址被添加或移除时被调用</span></span><br><span class="line"><span class="function">_extern <span class="keyword">void</span> <span class="title">NC_IPUpdate</span><span class="params">( IPN IPAddr, uint IfIdx, uint fAdd )</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="SOCKET-API"><a href="#SOCKET-API" class="headerlink" title="SOCKET API"></a>SOCKET API</h2><h3 id="UNIVERSAL-TCP"><a href="#UNIVERSAL-TCP" class="headerlink" title="UNIVERSAL_TCP"></a>UNIVERSAL_TCP</h3><h4 id="defined-in-lt-ws2def-h-gt"><a href="#defined-in-lt-ws2def-h-gt" class="headerlink" title="defined in &lt;ws2def.h&gt;"></a>defined in <code>&lt;ws2def.h&gt;</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                 ai_flags;       <span class="comment">// AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST</span></span><br><span class="line">    <span class="keyword">int</span>                 ai_family;      <span class="comment">// PF_xxx</span></span><br><span class="line">    <span class="keyword">int</span>                 ai_socktype;    <span class="comment">// SOCK_xxx</span></span><br><span class="line">    <span class="keyword">int</span>                 ai_protocol;    <span class="comment">// 0 or IPPROTO_xxx for IPv4 and IPv6</span></span><br><span class="line">    <span class="keyword">size_t</span>              ai_addrlen;     <span class="comment">// Length of ai_addr</span></span><br><span class="line">    <span class="keyword">char</span> *              ai_canonname;   <span class="comment">// Canonical name for nodename</span></span><br><span class="line">    _Field_size_bytes_(ai_addrlen) <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *   <span class="title">ai_addr</span>;</span>        <span class="comment">// Binary address</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *   <span class="title">ai_next</span>;</span>        <span class="comment">// Next structure in linked list</span></span><br><span class="line">&#125;</span><br><span class="line">ADDRINFOA, *PADDRINFOA;</span><br></pre></td></tr></table></figure>



<h4 id="defined-in-TI-lt-socket-h-gt"><a href="#defined-in-TI-lt-socket-h-gt" class="headerlink" title="defined in TI &lt;socket.h&gt;"></a>defined in <em><strong>TI</strong></em> <code>&lt;socket.h&gt;</code></h4><h5 id="IPv4套接字地址数据结构"><a href="#IPv4套接字地址数据结构" class="headerlink" title="IPv4套接字地址数据结构"></a>IPv4套接字地址数据结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AF_INET family (IPv4) Socket address data structure.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    UINT8   sin_len;            <span class="comment">// total length</span></span><br><span class="line">    UINT8   sin_family;         <span class="comment">// address family</span></span><br><span class="line">    UINT16  sin_port;           <span class="comment">// port</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span></span><br><span class="line">    INT8    sin_zero[<span class="number">8</span>];        <span class="comment">// fixed length address value</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="内核用地址存储数据结构"><a href="#内核用地址存储数据结构" class="headerlink" title="内核用地址存储数据结构"></a>内核用地址存储数据结构</h5><p>这个套娃里还有个套娃 <code>in_addr</code> ，这个结构体供内核调用，以储存更多地址数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Structure used by kernel to store most addresses.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    UINT32  s_addr;             <span class="comment">// 32 bit long IP address, net order</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="通用套接字地址储存数据结构"><a href="#通用套接字地址储存数据结构" class="headerlink" title="通用套接字地址储存数据结构"></a>通用套接字地址储存数据结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generic Socket address storage data structure.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    UINT8    sa_len;            <span class="comment">// Length </span></span><br><span class="line">    UINT8    sa_family;         <span class="comment">// address family</span></span><br><span class="line">    <span class="keyword">char</span>     sa_data[<span class="number">14</span>];       <span class="comment">// socket data</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>      <span class="title">SA</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>      *<span class="title">PSA</span>;</span></span><br></pre></td></tr></table></figure>









<p>以下为Socket <strong>接口协议簇</strong> 、 <strong>接口类型</strong>、 <strong>接口协议</strong> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Socket address families</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_TASK         1               <span class="comment">// Intertask Communication</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_INET         2               <span class="comment">// Internet: UDP, TCP, etc.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_INET6        10              <span class="comment">// IPV6</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _INCLUDE_NIMU_CODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_RAWETH       12              <span class="comment">// Raw Ethernet Protocol</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Socket Types</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_STREAM     1               <span class="comment">// stream socket</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_DGRAM      2               <span class="comment">// datagram socket</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_RAW        3               <span class="comment">// raw-protocol interface</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_STREAMNC   4               <span class="comment">// non-copy stream socket</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _INCLUDE_NIMU_CODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_RAWETH     5               <span class="comment">// non-copy raw eth socket</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Protocols</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_IP      0               <span class="comment">// IP Placeholder</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_ICMP    1               <span class="comment">// ICMP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_IGMP    2               <span class="comment">// IGMP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_TCP     6               <span class="comment">// TCP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_UDP     17              <span class="comment">// UDP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_IPV6    41              <span class="comment">// IPV6 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_ICMPV6  58              <span class="comment">// ICMPV6 Header.</span></span></span><br></pre></td></tr></table></figure>



<p>以下Socket接口均以Ti NDK为载体，以C为实现方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Socket Oriented Functions</span></span><br><span class="line"><span class="function">SOCKET <span class="title">accept</span><span class="params">( SOCKET s, PSA pName, <span class="keyword">int</span> *plen )</span></span>;	<span class="comment">//接受一个套接字的连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">bind</span><span class="params">( SOCKET s, PSA pName, <span class="keyword">int</span> len )</span></span>;	<span class="comment">//给套接字绑定一个名字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">connect</span><span class="params">( SOCKET s, PSA pName, <span class="keyword">int</span> len )</span></span>;		<span class="comment">//在一个套接字上初始化连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">getpeername</span><span class="params">( SOCKET s, PSA pName, <span class="keyword">int</span> *plen )</span></span>;	<span class="comment">//在已连接的peer上返回名称地址</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">getsockname</span><span class="params">( SOCKET s, PSA pName, <span class="keyword">int</span> *plen )</span></span>;	<span class="comment">//返回套接字的本地名称地址</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">getsockopt</span><span class="params">( SOCKET s, <span class="keyword">int</span> level, <span class="keyword">int</span> op, <span class="keyword">void</span> *pbuf, <span class="keyword">int</span> *pbufsize )</span></span>;	<span class="comment">//获取套接字设置信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">listen</span><span class="params">( SOCKET s, <span class="keyword">int</span> maxcon )</span></span>;		<span class="comment">//监听数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">recv</span><span class="params">( SOCKET s, <span class="keyword">void</span> *pbuf, <span class="keyword">int</span> size, <span class="keyword">int</span> flags )</span></span>;		<span class="comment">//接收数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">recvfrom</span><span class="params">( SOCKET s, <span class="keyword">void</span> *pbuf, <span class="keyword">int</span> size, <span class="keyword">int</span> flags, PSA pName, <span class="keyword">int</span> *plen )</span></span>;		<span class="comment">//从指定对象处接收信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">recvnc</span><span class="params">( SOCKET s, <span class="keyword">void</span> **ppbuf, <span class="keyword">int</span> flags, HANDLE *pHandle )</span></span>;	<span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">recvncfrom</span><span class="params">( SOCKET s, <span class="keyword">void</span> **ppbuf, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                           PSA pName, <span class="keyword">int</span> *plen, HANDLE *pHandle )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">recvncfree</span><span class="params">( SOCKET Handle )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">send</span><span class="params">( SOCKET s, <span class="keyword">void</span> *pbuf, <span class="keyword">int</span> size, <span class="keyword">int</span> flags )</span></span>;		<span class="comment">//发送信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">sendto</span><span class="params">( SOCKET s, <span class="keyword">void</span> *pbuf, <span class="keyword">int</span> size, <span class="keyword">int</span> flags, PSA pName, <span class="keyword">int</span> len )</span></span>;	<span class="comment">//在未连接的套接字上往指定目的地发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">setsockopt</span><span class="params">( SOCKET s, <span class="keyword">int</span> level, <span class="keyword">int</span> op, <span class="keyword">void</span> *pbuf, <span class="keyword">int</span> bufsize )</span></span>;	<span class="comment">//设置套接字设置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">shutdown</span><span class="params">( SOCKET s, <span class="keyword">int</span> how )</span></span>;	<span class="comment">//关闭一半的套接字连接</span></span><br><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">( <span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol )</span></span>;	<span class="comment">//创建套接字</span></span><br></pre></td></tr></table></figure>



<h3 id="SOCKET-API-IN-CLIENT"><a href="#SOCKET-API-IN-CLIENT" class="headerlink" title="SOCKET API IN CLIENT"></a>SOCKET API IN CLIENT</h3><hr>
<div class="Step" style="font-size: 20px; font-weight: 700;">第一步 创建套接字</div>

<p><code>SOCKET socket( int domain, int type, int protocol );</code> </p>
<p>如果创建成功，则返回一个代表套接字的文件描述符。否则就返回一个 <code>INVALID_SOCKET </code> 值，并且可以调用 <code>fdError()</code> 来诊断错误原因。</p>
<blockquote>
<p><code>domain</code>是指链路层类型IPv4还是IPv6，分别书写为 <strong>AF_INET</strong> | <strong>AF_INET6</strong></p>
<p><code>type</code>是指传输层套接字类型，共有 <strong>报文数据</strong>、<strong>流式数据</strong>、<strong>原始数据</strong> 三种可选，分别是 <strong>SOCK_DGRAM</strong> | <strong>SOCK_STREAM</strong> | <strong>SOCK_RAW</strong></p>
<p><code>protocol</code>是指网络层协议类型，IPPROTO_TCP | IPPROTO_UDP，在套接字类型是原始数据时可以任意指定，如果是套接字类型是 <strong>SOCK_STREAM</strong>，则协议需要指定为 <strong>IPPROTO_TCP</strong></p>
</blockquote>
<div class="Step" style="font-size: 20px; font-weight: 700;">第二步 设定套接字参数</div>

<p>通常在套接字创建之后，使用Pv4套接字地址数据结构 <code>sockaddr_in</code>设定参数，以下实例是下位机做客户端时的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bzero(&amp;sin1, <span class="keyword">sizeof</span>(struct sockaddr_in));            <span class="comment">/* Set Port, IP address = IPAddrSend */</span></span><br><span class="line">sin1.sin_family = AF_INET;</span><br><span class="line">sin1.sin_len    = <span class="keyword">sizeof</span>(sin1);</span><br><span class="line">sin1.sin_addr.s_addr = inet_addr(REMOTE_IPADDR_STRING);          <span class="comment">//连接服务器的地址</span></span><br><span class="line">sin1.sin_port   = htons(TCP_CLIENT_PORT);</span><br></pre></td></tr></table></figure>



<div class="Step" style="font-size: 20px; font-weight: 700;">第三步 连接</div>

<p><code>int    connect( SOCKET s, PSA pName, int len );</code></p>
<blockquote>
<p><code>PSA</code> 是 <code>sockaddr </code> 结构体的 <em><strong>指针</strong></em> 对象类型，定义为 <code>typedef struct sockaddr      *PSA;</code></p>
<p>另，<code>SA</code> 是 <code>sockaddr </code> 结构体的对象类型。</p>
</blockquote>
<p><code>sockaddr</code> 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用套接字地址存储数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    UINT8    sa_len;            <span class="comment">//套接字长度</span></span><br><span class="line">    UINT8    sa_family;         <span class="comment">//套接字类型，AF_INET</span></span><br><span class="line">    <span class="keyword">char</span>     sa_data[<span class="number">14</span>];       <span class="comment">//套接字数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实际连接时，通常设置一定时间的任务休眠以等待网络稳定后再行连接，且连接次数自定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(count = <span class="number">0</span>; count &lt; <span class="number">30</span>; count ++)&#123;</span><br><span class="line">        res = connect(stcp, (PSA) &amp;sin1, <span class="keyword">sizeof</span>(sin1));</span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            ConsoleWarning(<span class="string">&quot;网络连接失败！\n&quot;</span>);</span><br><span class="line">            TaskSleep(SLEEPTIME);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ConsoleWarning(<span class="string">&quot;网络连接成功！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过特定配置设置，打开网络。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_extern <span class="keyword">int</span> <span class="title">NC_NetStart</span><span class="params">( HANDLE hCfg,   <span class="keyword">void</span> (*NetStart)(),   <span class="keyword">void</span> (*NetStop)(),    <span class="keyword">void</span> (*NetIP)(IPN,uint,uint) )</span></span>;</span><br></pre></td></tr></table></figure>





<h4 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h4><p>HANDLE  is a <em>void pointer*</em> defined in the <code>&lt;usertype.h&gt;</code>.</p>
<blockquote>
<p>在<code>&lt;socket.h&gt;</code>中，<strong>SOCKET</strong>类型其实是个HANDLE，而<strong>HANDLE</strong>其实是<code>void*</code>数据。</p>
<p><code>typedef HANDLE           SOCKET;          // OS Socket Type</code></p>
<p><code>typedef void *         HANDLE;    </code></p>
</blockquote>
<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><blockquote>
<p>文件描述符，即 <em><strong>File Descriptor</strong></em>，其实一个是 <code>void* </code>类型</p>
</blockquote>
<h5 id="FD集"><a href="#FD集" class="headerlink" title="FD集"></a>FD集</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Select uses bit masks of file descriptors.  These macros</span></span><br><span class="line"><span class="comment">// manipulate handle lists. FD_SETSIZE can be modified as</span></span><br><span class="line"><span class="comment">// needed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_SETSIZE      16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fd_set</span> &#123;</span></span><br><span class="line">    uint    count;</span><br><span class="line">    HANDLE  fd[FD_SETSIZE];</span><br><span class="line">&#125; fd_set;</span><br></pre></td></tr></table></figure>





<h4 id="字节顺序转换函数"><a href="#字节顺序转换函数" class="headerlink" title="字节顺序转换函数"></a>字节顺序转换函数</h4><p>在C/C++写网络程序的时候，往往会遇到字节的网络顺序和主机顺序的问题。这是就可能用到<code>htons()</code> ,  <code>ntohl()</code> ,  <code>ntohs()</code>，<code>htons()</code>这4个函数。</p>
<p>网络字节顺序与本地字节顺序之间的转换函数：</p>
<blockquote>
<p><code>htonl()</code>–”Host to Network Long”<br><code>ntohl()</code>–”Network to Host Long”<br><code>htons()</code>–”Host to Network Short”<br><code>ntohs()</code>–”Network to Host Short”</p>
</blockquote>
<p><em><strong>网络字节顺序(NBO, Network Byte Order):</strong></em> 按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。</p>
<p><em><strong>主机字节顺序(HBO, Host Byte Order):</strong></em> 不同的机器HBO不相同，与CPU设计有关，数据的顺序是由cpu决定的,而与操作系统无关。</p>
<blockquote>
<p>如 Intel x86结构下, short型数 <code>0x1234</code> 表示为<code>34 12</code>, int型数 <code>0x12345678</code> 表示为<code> 78 56 34 12</code></p>
<p>如 IBM power PC结构下, short型数<code>0x1234</code> 表示为 <code>12 34</code> , int型数 <code>0x12345678</code> 表示为 <code>12 34 56 78</code></p>
</blockquote>
<p>由于这个原因不同体系结构的机器之间无法通信,所以要转换成一种约定的数序,也就是网络字节顺序,其实就是如同power pc那样的顺序. 在PC开发中有ntohl和htonl函数可以用来进行网络字节和主机字节的转换.</p>
<h4 id="timeval结构体"><a href="#timeval结构体" class="headerlink" title="timeval结构体"></a>timeval结构体</h4><blockquote>
<p>Ti SysBios中，<code>timeval</code> 是在 <code>&lt;SOCKET.H&gt;</code> 中被定义，被 <code>fdSelect()</code> 使用的；</p>
</blockquote>
<p>结构体定义与Linux C中的一致</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    INT32 tv_sec;	<span class="comment">//Second Level</span></span><br><span class="line">    INT32 tv_usec;	<span class="comment">//Microsecond Level</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 <em><strong>Linux C</strong></em> 中，<code>timeval</code> 与 <code>timezone</code> 结构体都隶属于 <code>sys/time.h</code> 头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> tz_minuteswest;</span><br><span class="line"><span class="keyword">int</span> tz_dsttime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Linux C 中对 TIMEVAL 使用的补充资料：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct timeval*tv, struct timezone *tz)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其参数tv是保存获取时间结果的结构体，参数tz用于保存时区结果，tz 参数若不使用则传入NULL即可。</p>
<p><code>gettimeofday()</code> 使用举例-1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv_begin</span>, <span class="title">tv_end</span> ;</span></span><br><span class="line">gettimeofday(&amp;tv_begin, <span class="literal">NULL</span>);</span><br><span class="line">foo();</span><br><span class="line">gettimeofday(&amp;tv_end, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>



<p><code>gettimeofday()</code> 使用举例-2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;time %u:%u\n&quot;</span>,tv.tv_sec,tv.tv_usec);</span><br><span class="line">      sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><em>源自：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/Neddy/archive/2012/01/31/2332957.html">http://www.cnblogs.com/Neddy/archive/2012/01/31/2332957.html</a></em></p>
<h3 id="SOCKET-API-IN-SERVER"><a href="#SOCKET-API-IN-SERVER" class="headerlink" title="SOCKET API IN SERVER"></a>SOCKET API IN SERVER</h3><div class="Step" style="font-size: 20px; font-weight: 700;">第一步 创建套接字</div>

<p>同client，略</p>
<div class="Step" style="font-size: 20px; font-weight: 700;">第二步 监听套接字</div>

<p><code>int    listen( SOCKET s, int maxcon );</code>    </p>
<blockquote>
<p> <code>maxcon</code> 参数用于定义最大的阻塞数，如果阻塞值最高，则会发送一个 <code>ECONNREFUSED</code> 错误给客户端</p>
</blockquote>
<ul>
<li><p><code>listen()</code> 监听套接字上的连接请求。为了连接请求，需要先由<code>socket()</code> 函数创建套接字。</p>
</li>
<li><p><code>listen()</code> 函数用于等待设备接入并声明有限接入数的队列。</p>
</li>
<li><p>新连接接入时需要调用 <code>accept()</code> 函数。</p>
</li>
</ul>
<div class="Step" style="font-size: 20px; font-weight: 700;">第三步 从套接字接收数据</div>

<p><code>int    recv( SOCKET s, void *pbuf, int size, int flags );</code></p>
<blockquote>
<p><code>pbuf</code> 参数用于储存数据</p>
<p><code>size</code> 为欲接收数据的大小</p>
<p><code>flags</code> 为接收不到数据时的行为定义</p>
</blockquote>
<table>
<thead>
<tr>
<th>FLAGS</th>
<th>CONDITIONS</th>
</tr>
</thead>
<tbody><tr>
<td>MSG_DONTWAIT</td>
<td>Requests that the operation not block when no data is available</td>
</tr>
<tr>
<td>MSG_OOB</td>
<td>Requests receipt of out-of-band data that would not be received in the normal data stream. Some protocols place expedited data at the head of the normal data queue, and thus, this flag cannot be used with such protocols.</td>
</tr>
<tr>
<td>MSG_PEEK</td>
<td>Causes the receive operation to return data from the beginning of the receive queue without removing that data from the queue. Thus, a subsequent receive call will return the same data.</td>
</tr>
<tr>
<td>MSG_WAITALL</td>
<td>Requests that the operation block until the full request is satisfied. However, the call may still return less data than requested if an error or disconnect occurs, or the next data to be received is of a different type than that returned.</td>
</tr>
</tbody></table>
<h3 id="SOCKET-API-IN-SERVER-LINUX-C"><a href="#SOCKET-API-IN-SERVER-LINUX-C" class="headerlink" title="SOCKET API IN SERVER (LINUX C)"></a>SOCKET API IN SERVER (LINUX C)</h3><div class="Step" style="font-size: 20px; font-weight: 700;">第一步 创建套接字</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> servSock;  <span class="comment">//Socket descriptor for server</span></span><br><span class="line"><span class="keyword">if</span>( ( servSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP ) ) &lt; <span class="number">0</span> ) <span class="built_in">printf</span>(<span class="string">&quot;socket() failed.\n&quot;</span>);</span><br></pre></td></tr></table></figure>



<div class="Step" style="font-size: 20px; font-weight: 700;">第二步 套接字地址初始化</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servAddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;servAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>( servAddr ) );</span><br><span class="line">servAddr.sin_family = AF_INET;</span><br><span class="line">servAddr.sin_addr.s_addr = htonl( INADDR_ANY );</span><br><span class="line">servAddr.sin_port = htons( servPort );</span><br></pre></td></tr></table></figure>



<div class="Step" style="font-size: 20px; font-weight: 700;">第三步 绑定套接字</div>

<p><strong>注意：</strong> <strong>客户端</strong>把服务器的地址提供给 <code>connect()</code> 以供连接至服务器，而 <strong>服务器</strong> 必须将自己的地址指定给 <code>bind()</code> 进行绑定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( ( bind( servSock, (struct sockaddr*) &amp;servAddr, <span class="keyword">sizeof</span>( servAddr ) ) ) &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;bind() failed.\n&quot;</span>);</span><br></pre></td></tr></table></figure>



<div class="Step" style="font-size: 20px; font-weight: 700;">第四步 监听套接字</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> MAXPENDING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span>( ( listen( servSock, MAXPENDING ) ) &lt; <span class="number">0</span> ) <span class="built_in">printf</span>(<span class="string">&quot;listen() failed.\n&quot;</span>);</span><br></pre></td></tr></table></figure>



<div class="Step" style="font-size: 20px; font-weight: 700;">第四步 处理程序 <div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaaddr_in</span> <span class="title">cintAddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clntAddrLen = <span class="keyword">sizeof</span>( clntAddr );</span><br><span class="line">    <span class="keyword">int</span> clntSock = accept( servSock, (struct sockaddr*)&amp;clntAddr, &amp;clntAddrLen );</span><br><span class="line">    <span class="keyword">if</span>( clntSock &lt; <span class="number">0</span> ) <span class="built_in">printf</span>(<span class="string">&quot;accept() failed.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> clntName[ INET_ADDRSTRLEN ];</span><br><span class="line">    <span class="keyword">if</span>( inet_ntop( AF_INET, &amp;clntAddr.sin_addr.s_addr, clntName, <span class="keyword">sizeof</span>( clntName ) ) != <span class="literal">NULL</span> ) <span class="built_in">printf</span>(<span class="string">&quot;Handling client %s/%d.\n&quot;</span>, clntName, ntohs( clntAddr.sin_port ));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Unable to get client address.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    HandleTCPClient(clntSock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="Daemon-API"><a href="#Daemon-API" class="headerlink" title="Daemon API"></a>Daemon API</h3><p>DAEMON，即TCP/UDP Server Daemon Support。</p>
<p>A server daemon is a <strong>single network task</strong> that <strong>monitors the socket status of multiple network servers</strong>. When activity is detected, the <strong>daemon creates a task thread specifically to handle the new activity</strong>. This is more efficient than having multiple servers, <strong>each with their own listening thread</strong>.</p>
<p>要使用服务器守护，首先要创建入口(entry)，创建成功时会返回一个句柄，失败则返回NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">DaemonNew</span><span class="params">(<span class="keyword">uint32_t</span> Type, <span class="keyword">uint32_t</span> LocalAddress, <span class="keyword">uint32_t</span> LocalPort, <span class="keyword">int</span>(*pCb)(SOCKET,<span class="keyword">uint32_t</span>), </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">uint32_t</span> Priority, <span class="keyword">uint32_t</span> StackSize, <span class="keyword">uint32_t</span> Argument, <span class="keyword">uint32_t</span> MaxSpawn)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Type</code> Socket type (SOCK_STREAM, SOCK_STREAMNC, or SOCK_DGRAM)<br><code>LocalAddress</code> Local IP address (set to NULL for wildcard)<br><code>LocalPort</code> Local Port to serve (cannot be NULL)<br><code>pCb</code> Pointer to callback to handle server event (connection or activity)<br><code>Priority</code> Priority of new task to create for callback function<br><code>StackSize</code> Stack size of new task to create for callback function<br><code>Argument</code> Argument (besides socket) to pass to callback function<br><code>MaxSpawn</code> Maximum number of callback function instances (must be 1 for UDP)</p>
</blockquote>
<p>在TCP环境中，当新连接稳定时，新任务线程会被创建，套接字Session会被打开。在新的任务线程上，用户的回调函数会被调用以供新连接上的套接字和调用的指定参数使用。回调函数可以一直维护套接字和任务线程。一旦完成连接它将从回调任务中返回。该任务能够判断是否关闭套接字（或翻译成：该任务能够在需要时关闭套接字）。</p>
<p>In the case of TCP, when a new connection is established, a new task thread is created, and a socket session is opened. Then the user’s callback function is called on the new task thread, being supplied with both the socket to the new connection and the caller specified argument (as supplied to DaemonNew()). The callback function can keep the socket and task thread for as long as necessary. It returns from the callback once it is done with the connection. The function can choose to close the socket if desired. The return code informs the daemon whether the socket has been closed (0) or is still open (1).</p>
<h2 id="NETCFG-H"><a href="#NETCFG-H" class="headerlink" title="NETCFG.H"></a>NETCFG.H</h2><blockquote>
<p><code>CI</code> means <code>Configuration Item</code> , and <code>CFG</code> means <code>Configuration</code> .</p>
</blockquote>
<p>Data-type <code>UINT32</code> and <code>IPN</code> are both defined in the header file <code>&lt;usertype.h&gt;</code> .</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>   UINT32;</span><br><span class="line"><span class="keyword">typedef</span> UINT32         IPN;             <span class="comment">// IP Address in NETWORK format</span></span><br></pre></td></tr></table></figure>

<p>Structure  <code>CI_IPNET</code>  and structure  <code>CI_ROUTE</code>  are different from each other. </p>
<p>Structure  <code>CI_IPNET</code>  is as follow:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPNet Instance</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ci_ipnet</span> &#123;</span></span><br><span class="line">        uint    NetType;                <span class="comment">// 网络地址类型标志</span></span><br><span class="line">        IPN     IPAddr;                 <span class="comment">// 32bits地址((2^8)*4)</span></span><br><span class="line">        IPN     IPMask;                 <span class="comment">// 子网掩码</span></span><br><span class="line">        HANDLE  hBind;                  <span class="comment">// 绑定句柄</span></span><br><span class="line">        <span class="keyword">char</span>    Domain[CFG_DOMAIN_MAX]; <span class="comment">// 域名</span></span><br><span class="line">        &#125; CI_IPNET;</span><br></pre></td></tr></table></figure>



<p>Structure  <code>CI_ROUTE</code>  is as follow:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Route Instance</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ci_route</span> &#123;</span></span><br><span class="line">        IPN     IPDestAddr;             <span class="comment">// 目的地址</span></span><br><span class="line">        IPN     IPDestMask;             <span class="comment">// 目的地址掩码</span></span><br><span class="line">        IPN     IPGateAddr;             <span class="comment">// 默认网关地址</span></span><br><span class="line">        HANDLE  hRoute;                 <span class="comment">// Route handle (resets to NULL)</span></span><br><span class="line">        &#125; CI_ROUTE;</span><br></pre></td></tr></table></figure>





<h2 id="CONFIGIF-H"><a href="#CONFIGIF-H" class="headerlink" title="CONFIGIF.H"></a>CONFIGIF.H</h2><p>请先阅读 <em>&lt;spru524k.pdf&gt;</em></p>
<h3 id="Configuration-特性"><a href="#Configuration-特性" class="headerlink" title="Configuration 特性"></a>Configuration 特性</h3><ul>
<li>任何对（已激活）配置的作用都将立即生效。</li>
</ul>
<blockquote>
<p><em>The configuration is based on an active database. That is, any change to the database can cause an immediate reaction in the system. For example, if a route is added to the configuration, it is added to the system route table. If the route is then removed from the configuration, it is removed from the system route table.</em></p>
</blockquote>
<ul>
<li>配置存在激活与失效两种状态。</li>
</ul>
<blockquote>
<p><em>Configurations can be set active or inactive. When a configuration is active, any change to the configuration results in a change in the system. When a configuration is inactive, it behaves like a standard database. Part of the main initialization sequence is to make the system configuration active, and then inactive when shutting down.</em></p>
</blockquote>
<ul>
<li>配置(Configurations)和配置入口(Configuration Entries)都使用句柄(handle)来映射，但不同的是，配置使用CfgHandle，而配置入口使用Cfg<em>Entry</em>Handle，所以不能混淆。</li>
</ul>
<blockquote>
<p><em>Both the configurations and configuration entries are referenced by a generic handle. Configuration functions (named as <code>CfgXxx()</code>) take a configuration handle parameter, while configuration entry functions (name as <code>CfgEntryXxx()</code>) take a configuration entry handle parameter. These handles are not interchangeable.</em></p>
</blockquote>
<ul>
<li>配置条目(Entry)包含着*(contains)* 一个内部引用计数(Internal Reference Count)，即如果有任务想使用它，它就不能被其他任务销毁。配置条目被引用一次，引用计数就会加一。</li>
</ul>
<blockquote>
<p><em>Configuration entry handles are referenced. This means that each handle contains an internal reference count so that the handle is not destroyed by one task while another task expects it to stay valid. Functions that return a configuration entry handle supply a referenced handle in that its reference count has already been incremented for the caller.</em></p>
</blockquote>
<ul>
<li>理论上句柄能够被无限持有，一旦释放则将被dereference。</li>
</ul>
<blockquote>
<p><em>The caller can hold this handle indefinitely, but should dereference it when it is through.</em></p>
</blockquote>
<p><code>IF</code> 是指 Interface。<code>ifconfig</code> 是unix系统上的ip接口查看语句。而 <code>CONFIGIF</code> 是配置管理接口的意思。</p>
<p><code>DeRef</code> ，即 <em>Dereference</em> 之意。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_extern <span class="keyword">int</span>  <span class="title">CfgAddEntry</span><span class="params">( HANDLE hCfg, uint Tag, uint Item, uint Mode, <span class="keyword">int</span> Size, UINT8 *pData, HANDLE *phCfgEntry )</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>HANDLE hCfg</code></p>
<p><code>uint Tag</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Defined Configuration Tags</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_OS               0x0001          <span class="comment">// OS Configuration</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_IP               0x0002          <span class="comment">// IP Stack Configuration</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_SERVICE          0x0003          <span class="comment">// Service</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_IPNET            0x0004          <span class="comment">// IP Network</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_ROUTE            0x0005          <span class="comment">// Gateway Route</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_CLIENT           0x0006          <span class="comment">// DHCPS Client</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_SYSINFO          0x0007          <span class="comment">// System Information</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGTAG_ACCT             0x0008          <span class="comment">// User Account</span></span></span><br></pre></td></tr></table></figure>

<p><code>uint Item</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Currently Used DHCP Compatible Items</span></span><br><span class="line"><span class="comment">// Multiple instances are always to be stored as multiple config entries, not a concatenated byte string in a single config entry.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_DHCP_DOMAINNAMESERVER   6       <span class="comment">// Stack&#x27;s DNS servers</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_DHCP_HOSTNAME           12      <span class="comment">// Stack&#x27;s host name</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_DHCP_NBNS               44      <span class="comment">// Stack&#x27;s NBNS servers</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_DHCP_CLIENT_OPTION		61		<span class="comment">// Stack DHCP Client Identifier</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_SYSINFO_REALM1          256     <span class="comment">// Realm Name 1 (max 31 chars)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_SYSINFO_REALM2          257     <span class="comment">// Realm Name 2 (max 31 chars)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_SYSINFO_REALM3          258     <span class="comment">// Realm Name 3 (max 31 chars)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_SYSINFO_REALM4          259     <span class="comment">// Realm Name 4 (max 31 chars)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_SYSINFO_REALMPPP        260     <span class="comment">// Realm Name PPP (max 31 chars)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFGITEM_SYSINFO_EVALCALLBACK    261    <span class="comment">// Callback function to notify</span></span></span><br><span class="line">                                               <span class="comment">// application 5 min before</span></span><br><span class="line">                                               <span class="comment">// end of stack evaluation period         </span></span><br></pre></td></tr></table></figure>

<p><code>uint Mode</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add Entry Flags</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFG_ADDMODE_UNIQUE      0x0001  <span class="comment">// Replace all previous instances</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFG_ADDMODE_DUPLICATE   0x0002  <span class="comment">// Allow duplicate data entry</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CFG_ADDMODE_NOSAVE      0x0004  <span class="comment">// Don&#x27;t include this entry in CfgSave</span></span></span><br></pre></td></tr></table></figure>


</blockquote>
<h1 id="WINDOW-SOCKET"><a href="#WINDOW-SOCKET" class="headerlink" title="WINDOW SOCKET"></a>WINDOW SOCKET</h1><p>Windows Sockets可以保证应用程序在任何支持Windows Sockets API 的网络内正常通信。</p>
<p>流式Socket：基于TCP，数据无差错且无重复发送；</p>
<p>数据报Socket：基于UDP，不能保证数据按发送顺序接收，可能丢失或重复。</p>
<p>真正与客户端Socket对象通信都不是服务器 Socket对象，而是新创建的“临时”Socket对象</p>
<blockquote>
<p>构造函数：CAsyncSocket();</p>
<p>Create();【成功返回非0，失败返回0】            //SOCK_DGRAM 数据报</p>
<p>GetSockName();                //用于获取Socket对象的本地名称（自己的信息），ip地址及端口号，或</p>
<p>GetPeerName();                //用于获取连接的Socket对象名称（对方的信息）</p>
<p>Listen();                              //面向流式使用，参数范围1~5，表示等待连接队列的最大长度</p>
<p>Accept();                            //用以接收等待队列中存在的连接请求</p>
<p>Connect();                         //建立连接请求函数</p>
<p>Send();                              //</p>
</blockquote>
<p>除字符型与布尔型外，其余整型用于表示（可能）不同尺寸的整数。</p>
<p>C++规定一个int（最小16bit）至少和一个short（16bit）一样大，一个long（最小32bit）至少和一个int一样大，一个long long（64bit）至少和一个long一样大。</p>
<p>其中，long long 是在C++ 11中新定义的。</p>
<p>尽管字符型char有三种（char、signed char、unsigned char），但是字符的表现形式只有2种，signed或unsigned。类型char实际上会表现为其中一种，具体由编译器决定。</p>
<p>字面值常量</p>
<blockquote>
<p>20           //十进制</p>
<p>020        //0开头的为8进制</p>
<p>0x20      //0x开头的为16进制</p>
</blockquote>
<h1 id="SEND-BLOCKING"><a href="#SEND-BLOCKING" class="headerlink" title="SEND() BLOCKING"></a>SEND() BLOCKING</h1><blockquote>
<p>In some cases where send() would block, it instead returns without copying all of the data as requested.</p>
<p>In this case, the return value of send() indicates how many bytes were actually copied. One example of this is if your program is blocking on send() and then receives a signal from the operating system.</p>
<p>In these cases, it is up to caller to try again with any remaining data.</p>
</blockquote>
<h1 id="套接字及流输入输出接口-IO"><a href="#套接字及流输入输出接口-IO" class="headerlink" title="套接字及流输入输出接口(IO)"></a>套接字及流输入输出接口(IO)</h1><p><strong>TOPIC</strong></p>
<blockquote>
<ul>
<li>文件描述符环境</li>
<li>文件描述符编程接口</li>
<li>套接字编程接口</li>
<li>元以太网套接字编程接口</li>
<li>全双工管道编程接口</li>
<li>因特网群组管理协议(IGMP)</li>
</ul>
</blockquote>
<p>在各嵌入式系统中，对文件描述符的支持都大相径庭。大部分情况，都只支持基本功能（bare minimum functionality）， 通常都以通用名称命名和提供被修剪过的函数(trimmed down support functions)。</p>
<p>TI NDK支持标准套接字接口函数，这些函数也要求文件描述符的支持，堆栈提供一个小型文件系统。</p>
<p>在堆栈代码内部的基本构建块是一个对象句柄。在其内部，套接字和管道都通过对象句柄寻址。然而，在应用层，套接字和管道都被当做文件描述符看待。文件描述符内涵附加状态信息（additional state information），允许根据套接字活动阻塞和解除阻塞任务。</p>
<p><strong>注意：</strong>尽管文件描述符能够在传统函数中使用，如select()， 但在这种实现方式中，他们仍然是句柄，而不是整型。</p>
<p>出于兼容性考虑，网络程序必须使用NDK头文件，然后使用INVALID_SOCKET作为错误情况判定，并且在检查SOCKET有效性时，不要直接与（&lt;0）比较。</p>
<p>使用文件描述符前，需要一个任务首先创建一个文件描述符表格（FD table / session）。只需要在应用层调用文件描述符函数 <code>fdOpenSession()</code> 来完成。</p>
<p>当任务结束使用FD接口，或被关闭时，调用 <code>fdCloseSession()</code> 。</p>
<p>为确保堆栈操作正确，每个任务在使用FD相关的函数前，都应创建FD session，在使用完毕后关闭它。</p>
<h2 id="Open-FD-Session"><a href="#Open-FD-Session" class="headerlink" title="Open FD Session"></a>Open FD Session</h2><ol>
<li><p>最简单的方式就是用 <code>TaskCreate()</code> ，他可以（自动）在内部打开和关闭FD session。</p>
</li>
<li><p>另一种方式就是在函数调用的最开头进行session创建，在函数结束的末尾进行session关闭。如下：</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">socket_task</span><span class="params">(<span class="keyword">int</span> IPAddr, <span class="keyword">int</span> TcpPort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        SOCKET s;</span><br><span class="line">        <span class="comment">// Open the file session</span></span><br><span class="line">        fdOpenSession(TaskSelf());</span><br><span class="line">       <span class="comment">// &lt; socket application code &gt;</span></span><br><span class="line">        <span class="comment">// Close the file session</span></span><br><span class="line">        fdCloseSession(TaskSelf());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>另一种方式就是创建子线程。注意的是，父线程需要保证子线程的任务被执行前打开子线程的session。可通过任务优先级或信标来完成，但会增加任务创建复杂度，并不是理想方案。</li>
<li>也可以通过让子任务调用session创建函数，并且由父线程来监控和关闭子线程门。</li>
</ol>
<p>栈库支持一些通常被认为是文件函数的功能，因此套接字应用程序可以在更传统的意义上编程。</p>
<blockquote>
<p>The stack library supports a handful of what are normally considered file functions, so that sockets applications can be programmed in a more traditional sense.</p>
</blockquote>
<p><code>fdPoll()</code> 远比 <code>fdSelect()</code> 来得更有效率。它轮询提供的套接字列表，并指定以毫秒为单位的超时(或使用<em>POLLINFTIM</em> 来设置无限超时)。拥有 <code>fdSelect()</code> 的优点，即对原始文件描述符列表（或者套接字）的检验不会被结果所改写，因此可以不用重建便多次使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fdpollitem</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *fd;  <span class="comment">//the fd or socket to check</span></span><br><span class="line">    <span class="keyword">uint16_t</span> eventsRequested;  <span class="comment">//a set of flags for requested events</span></span><br><span class="line">    <span class="keyword">uint16_t</span> eventsDetected;  <span class="comment">//a set of resulting flags for a detected event</span></span><br><span class="line">&#125; FDPOLLITEM;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/01/05/Programing/C++/2021-01-05-C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/05/Programing/C++/2021-01-05-C++/" class="post-title-link" itemprop="url">C++</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-05 23:58:32" itemprop="dateCreated datePublished" datetime="2021-01-05T23:58:32+08:00">2021-01-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-21 00:05:03" itemprop="dateModified" datetime="2021-05-21T00:05:03+08:00">2021-05-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programing/" itemprop="url" rel="index"><span itemprop="name">Programing</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="C-语法及基础"><a href="#C-语法及基础" class="headerlink" title="C++语法及基础"></a>C++语法及基础</h1><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>杂项运算符</li>
</ul>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p>
<table>
<thead>
<tr>
<th>p</th>
<th>q</th>
<th>p &amp; q</th>
<th>p | q</th>
<th>p ^ q</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：</p>
<blockquote>
<p>A = 0011 1100</p>
<p>B = 0000 1101</p>
</blockquote>
<p>-—————-</p>
<blockquote>
<p>A&amp;B = 0000 1100</p>
<p>A|B = 0011 1101</p>
<p>A^B = 0011 0001</p>
<p>~A = 1100 0011</p>
</blockquote>
<p>下表显示了 C 语言支持的位运算符。假设变量 <strong>A</strong> 的值为 60，变量 <strong>B</strong> 的值为 13，则：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与操作，按二进制位进行”与”运算。运算规则： <code>0&amp;0=0;    0&amp;1=0;     1&amp;0=0;      1&amp;1=1;</code></td>
<td>(A &amp; B) 将得到 12，即为 0000 1100</td>
</tr>
<tr>
<td>|</td>
<td>按位或运算符，按二进制位进行”或”运算。运算规则： `0</td>
<td>0=0;    0</td>
</tr>
<tr>
<td>^</td>
<td>异或运算符，按二进制位进行”异或”运算。运算规则： <code>0^0=0;    0^1=1;    1^0=1;   1^1=0;</code></td>
<td>(A ^ B) 将得到 49，即为 0011 0001</td>
</tr>
<tr>
<td>~</td>
<td>取反运算符，按二进制位进行”取反”运算。运算规则： <code>~1=-2;    ~0=1;</code></td>
<td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</td>
<td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</td>
<td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td>
</tr>
</tbody></table>
<h2 id="Mangling"><a href="#Mangling" class="headerlink" title="Mangling"></a>Mangling</h2><p><strong>重载</strong>，包括 <strong>函数重载</strong> 和 <strong>操作符重载</strong> 。</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><blockquote>
<p><strong>函数重载</strong> 也叫 <strong>方法重载</strong>。是编译器通过把原方法名称与其参数相结合产生一个独特的内部名字来取代原方法名称的技术。</p>
<p>基本上，支持函数重载的语言都需要进行Name Mangling。Mangling的目的就是为了给重载的函数不同的签名，以避免调用时的二义性调用。</p>
</blockquote>
<p><strong>Name Mangling</strong> 不是一个非常新的技术，在C语言中也有，<em><strong>在汇编C语言时经常看到的以 下划线“_”开头的函数名，其实就是C编译器将函数名进行了 Name Mangling</strong></em> 。</p>
<p>但是在C++中Name-mangling要复杂的多。 因为C++中支持 <em><strong>overload</strong></em> 和 <em><strong>override</strong></em> ，这就导致了C++编译器必须要有完成的Name-mangling把函数名或者变量名进行调整。 </p>
<p>在面向对象编程语言出现之前，如果你想要打印不同类型的数据,需要写多个方法 ,象是 <code>PrintInteger(int i)</code> ，<code>PrintString(string s)</code>  和 <code>PrintFloat(float f)</code> 。也就是说必须<strong>通过命名来区别行为和数据类型</strong>，因为 OOP语言出现前，任一语言都（像是C）不允许使用相同的名字命名函数， 即使参数类型不同。</p>
<p>但在C++中，像是 Print(int i)、Print(string s) 和 Print(float  f)，编译器自会准确调用特定的Print方法。当调用 <code>Print(1)</code> 的时候, 编译器可能在内部用源于参数类型的前缀重命名Print方法，这样一来 <code>Print(1)</code> 可能就变成  <code>i_Print (1)</code> 。</p>
<p> 下面是更详细的例子：</p>
<p> C++编译器实际上将下面这些重载函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">float</span> f)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>* s)</span></span>;</span><br></pre></td></tr></table></figure>

<p>编译为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_print_int</span><br><span class="line">_print_char</span><br><span class="line">_print_float</span><br><span class="line">_pirnt_string</span><br></pre></td></tr></table></figure>

<p> 这样的函数名，来唯一标识每个函数。</p>
<p><strong>注：</strong>不同的编译器实现可能不一样，但是都是利用这种机制。所以当连接是调用 <code>print(3)</code> 时，它会去查找 <code>_print_int(3)</code> 这样的函数。下面说个题外话，正是因为这点，重载被认为不是多态，多态是运行时动态绑定（“一种接口多种实现”），<strong>如果硬要认为重载是多态，它顶多是编译时“多态”。</strong></p>
<p>C++中的变量，编译也类似，如全局变量可能编译g_xx，类变量编译为c_xx等。连接是也是按照这种机制去查找相应的变量。</p>
<blockquote>
<p><code>方法重载</code> 仅是多态性的一种情形。 </p>
<p><code>名称重整</code> 是一种支持方法重载的机制。更普遍的情况下，多态性是与继承相联系。 </p>
</blockquote>
<h2 id="Inherit"><a href="#Inherit" class="headerlink" title="Inherit"></a>Inherit</h2><blockquote>
<p>继承就是一个新类 (称为子类) 从被继承类（称为父类或超类）取得自身的部分定义同时增加一些自己的新的信息。</p>
</blockquote>
<p>如果你在相同的类中重载方法, 数据类型必须是不同的。如果你在继承关系下重载方法, 子类与父类的方法可能完全相同，而且名称重整器生成同样的重整名称。</p>
<p> 举例来说，假设一个超类定义一个 <code>Print(int i)</code> 方法而一个从它继承的子类也定义了一个 <code>Print(int i)</code> 方法。当你有一个子类的实例时，运用多态性调用 <code>Child.Print(int)</code> ；而当你产生一个父类的实例时运用多态性调用 <code>Parent.Print(int)</code> 。这就是继承多态性：相同的名字和签字但是类却不同。</p>
<p><code>继承多态性</code> 是通过使用一种与名称重整相关的另外一种机制实现的。编译器把方法放置在一个被称为虚拟方法表（其实是一个方法数组）的地方。每一个方法在VMT中都有一个索引, 如此当 <code>Print(int)</code> 被调用的时候, 编译器将被路由到VMT处找寻Print方法和类的内在索引。这样一来，编译器就可以调用正确的方法实现。由编译器负责管理所有的VMT索引和类偏移量。</p>
<p> 简言之，多态性使你能够用非常相似的名字定义许多方法，这里的名字往往都是直观易记的。 OOP编译器自会根据调用者类理解到底该调用哪个方法。</p>
<p>Only one version of an overloaded function can appear within the  extern C block. The code in the following example would result in an error.</p>
<p>While you can use name overloading in your SYS/BIOS C++ applications, only one version of the overloaded function can be called from the configuration.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> “C” &#123; <span class="comment">// Example causes ERROR</span></span><br><span class="line">	<span class="function">Int <span class="title">addNums</span><span class="params">(Int x, Int y)</span></span>;</span><br><span class="line">	<span class="function">Int <span class="title">addNums</span><span class="params">(Int x, Int y, Int z)</span></span>; <span class="comment">// error, only one version of addNums is allowed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Inline-Function"><a href="#Inline-Function" class="headerlink" title="Inline Function"></a>Inline Function</h2><p>**内联方法 **即内联函数，成员函数，inline functions，是指定义在类体内的函数。</p>
<p>该函数可以在类体内被声明和定义，也可以在类体内声明同时在体外使用 <code>inline</code> 关键字进行定义，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">angle</span>&#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">double</span> value;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">SetValue</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">angle::SetValue</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;                <span class="comment">//定义内联函数</span></span><br><span class="line">	value = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>内联函数无法递归。</p>
<h2 id="Constructor-and-Destructor"><a href="#Constructor-and-Destructor" class="headerlink" title="Constructor and Destructor"></a>Constructor and Destructor</h2><p><strong>构造函数(Constructor Function)</strong> 在调用时会为对象开辟储存空间、作初始化 及 其他管理操作。</p>
<ul>
<li>如果为编写，则系统默认生成</li>
<li>可以接受参数不能有返回值</li>
<li>可以有多个构造函数，因此可以接受名称重载（Name Mangling）。</li>
</ul>
<p><strong>析构函数(Destructor Function)</strong> 仅在释放对象的内存空间时使用，如 <em><strong>程序超出类对象的作用域</strong></em> 或 <em><strong>类指针运行delete运算符</strong></em>  时。</p>
<h2 id="Friend-Function"><a href="#Friend-Function" class="headerlink" title="Friend Function"></a>Friend Function</h2><p><strong>友元函数</strong> 是指 <code>在类内部声明</code>，可以 <code>自由访问该类的私有部分</code> 并且 <code>不属于类成员</code> 的 <strong>函数</strong>或<strong>类</strong>。</p>
<p>在友元函数声明时定义一个该类的对象，可以通过引用该对象作为参数进行对类的访问。</p>
<p>为了确保数据完整性并遵循数据封装和隐藏的原则，因尽量少用或不用友元。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Student;</span><br><span class="line">class Teacher&#123;</span><br><span class="line">	public:</span><br><span class="line">		&#x2F;&#x2F;....</span><br><span class="line">&#125;</span><br><span class="line">	protected:</span><br><span class="line">		int NoOfStudent;</span><br><span class="line">		Student * pList[100];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Student&#123;</span><br><span class="line">	public:</span><br><span class="line">		friend class Teacher;             &#x2F;&#x2F;友元类声明</span><br><span class="line">		&#x2F;&#x2F;....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Preprocessing"><a href="#Preprocessing" class="headerlink" title="Preprocessing"></a>Preprocessing</h2><p><strong>定义</strong></p>
<p>预处理是指将源文件的文本作为翻译的第一阶段操作的文本处理步骤。 预处理不会分析源文本，但会为了查找宏调用而将源文本细分为标记。 主要包括了下面三个方面：</p>
<ul>
<li>预处理指令</li>
<li>预处理运算符</li>
<li>预定义宏，这个有很多了，比如__FILE__、__LINE__和__DATA__等。</li>
</ul>
<p><strong>常识</strong></p>
<ul>
<li>预处理并不是编译，也不是“预编译”</li>
<li>预处理并不是每个语言都有</li>
<li>C/C++预处理仅仅是把源程序划分和整理成一个个的段（phase），并不进行编译。</li>
<li>预处理器在UNIX传统中通常缩写为PP，在自动构建脚本中C预处理器被缩写为CPP的宏指代。为了不造成歧义，C++(c-plus-plus) 经常并不是缩写为CPP，而改成CXX</li>
</ul>
<h3 id="Preprocessing-Directives"><a href="#Preprocessing-Directives" class="headerlink" title="Preprocessing Directives"></a>Preprocessing Directives</h3><p>以下为常见的C/C++预处理指令：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>#include</td>
<td>#import</td>
<td>#using</td>
<td>#progma</td>
</tr>
<tr>
<td>#if</td>
<td>#ifdef</td>
<td>#ifndef</td>
<td>#elif</td>
</tr>
<tr>
<td>#lese</td>
<td>#endif</td>
<td>#define</td>
<td>#undef</td>
</tr>
<tr>
<td>#error</td>
<td>#line</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="预处理运算符号"><a href="#预处理运算符号" class="headerlink" title="预处理运算符号"></a>预处理运算符号</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>字符串化运算符（#）</td>
<td>导致对应的实参括在双引号内</td>
</tr>
<tr>
<td>Charizing运算符（#@）</td>
<td></td>
</tr>
<tr>
<td>标记粘贴运算符（##）</td>
<td></td>
</tr>
<tr>
<td>定义的运算符</td>
<td></td>
</tr>
</tbody></table>
<h4 id="字符串化运算符"><a href="#字符串化运算符" class="headerlink" title="字符串化运算符"></a>字符串化运算符</h4><p><code>#</code> 除了是 <em><strong>预处理符号</strong></em>，也是一种 <strong>运算符</strong> ，即 <strong>字符串化运算符</strong>，只能出现在带参的宏的替换文本中，<strong>将跟在后面的参数转换成一个字符串常量</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_INT(i) printf(#i<span class="meta-string">&quot;=%d\n&quot;</span>,i)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">100</span>;</span><br><span class="line">    PF_INT(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预处理后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span><span class="string">&quot;=%d\n&quot;</span>,x);</span><br></pre></td></tr></table></figure>

<p>C语言常将相邻的字符串合并处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d\n&quot;</span>,x);</span><br></pre></td></tr></table></figure>



<h4 id="标记粘贴运算符"><a href="#标记粘贴运算符" class="headerlink" title="标记粘贴运算符"></a>标记粘贴运算符</h4><p><code>##</code> 是一种 <strong>运算符</strong> ，即 <strong>标记粘贴运算符</strong>，是将两个 <strong>运算对象</strong> 连接（拼接）在一起，只能出现在带参宏定义的替换文本中。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM(h,t,u)  h##t##u</span></span><br></pre></td></tr></table></figure>

<p>假设u代表个位，t代表十位，h代表百位，则x=NUM(1,2,3)后,x=123。</p>
<p><strong>注：</strong><code>##</code>也可以用于拼接一些开头一样，尾巴不一样的宏，这样的宏一般用于描述代表特定意义的对象的不同状态等。宏开头固定，根据不同条件则选择拼接不同尾巴，最后拼接的字符串代表一个具体的状态等。</p>
<h2 id="Differences-between-C-amp-C"><a href="#Differences-between-C-amp-C" class="headerlink" title="Differences between C &amp; C++"></a>Differences between C &amp; C++</h2><ul>
<li>从语法要求来说，C++的语法要求更为严格，编译器对参数变量的检查要求更高，更容易报错；很多在C中可以被顺利编译的语句，在C++中会被严厉拒绝，例如，在C++中，当形参为unsigned char，而实参为const char时会报错。</li>
<li>C是面向过程语言，代码复用复杂。C++是面向对象语言。</li>
</ul>
<h1 id="常见问题及错误"><a href="#常见问题及错误" class="headerlink" title="常见问题及错误"></a>常见问题及错误</h1><h2 id="C-常见的内存错误及解决方法"><a href="#C-常见的内存错误及解决方法" class="headerlink" title="C++常见的内存错误及解决方法"></a>C++常见的内存错误及解决方法</h2><p><strong>（1）内存分配未成功，却使用了它。</strong></p>
<blockquote>
<p>在使用内存之前先检查指针是否是NULL。如果是用malloc来申请内存，应该用if(p == NULL)或if（p != NULL）进行防错处理。如果是new来申请内存，申请失败会抛出异常，所以应该捕捉异常来进行防错处理。</p>
</blockquote>
<p><strong>（2）内存虽然分配成功，但尚未初始化就引用它。</strong></p>
<blockquote>
<p>尽管有时候缺省时会自动初始化，但无论什么时候创建对象均要对其进行初始化，即使是赋0值也是不可忽略的。</p>
</blockquote>
<p><strong>（3）内存分配成功，但访问越界</strong></p>
<blockquote>
<p>对数组for循环时要把握越界，否则可能会导致数组越界。</p>
</blockquote>
<p><strong>（4）忘记释放内存，导致内存泄漏</strong></p>
<blockquote>
<p>动态内存的申请和释放必须配对，new-delete和malloc-free其使用次数必须相等。</p>
</blockquote>
<p><strong>（5）已经释放内存还在使用它</strong></p>
<blockquote>
<p>free或delete后 ，没有将指针设为NULL，产生“野指针”。</p>
</blockquote>
<h2 id="C-中struct与class的区别是什么？"><a href="#C-中struct与class的区别是什么？" class="headerlink" title="C++中struct与class的区别是什么？"></a>C++中struct与class的区别是什么？</h2><p>如果没有多态和虚拟继承，在C++中，struct和class的存取效率完全相同，存取class的数据成员与非虚函数效率和struct完全相同，不管该数据成员是定义在基类还是派生类。</p>
<p>class的数据成员在内存中的布局不一定是数据成员的声明顺序，C++只保证处于同一个access section的数据成员按照声明顺序排列。</p>
<p>C++中，class和struct做类型定义是只有两点区别：</p>
<ul>
<li>默认继承权限不同，<strong>class继承默认是private继承，而struct默认是public继承</strong>。</li>
<li>class还可用于定义模板参数，像typename，但是关键字struct不能同于定义模板参数。</li>
</ul>
<p>C++保留struct关键字，原因：</p>
<ul>
<li>保证与C语言的向下兼容性，C++必须提供一个struct。</li>
<li>C++中的struct定义必须百分百地保证与C语言中的struct的向下兼容性，把C++中的最基本的对象单元规定为class而不是struct，就是为了避免各种兼容性要求的限制。</li>
<li>对struct定义的扩展使C语言的代码能够更容易的被移植到C++中。</li>
</ul>
<h2 id="如何将结构体传递给函数？"><a href="#如何将结构体传递给函数？" class="headerlink" title="如何将结构体传递给函数？"></a>如何将结构体传递给函数？</h2><p>与类对象一样，结构体变量也可以通过值、引用和常量引用传递给函数。</p>
<p>默认情况下，它们通过值传递，这意味着需要生成整个原始结构的副本并传递给函数。</p>
<p>因为不希望浪费时间来复制整个结构体，所以，除非结构很小，否则一般会通过 <strong>引用</strong> 将结构体传递给函数。但是，这样意味着函数可以访问原始结构的成员变量，从而可能更改它们。</p>
<p>如果不想让函数更改任何成员变量值，那么可以考虑将结构体变量作为一个 <strong>常量引用</strong> 传递给函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Invltem</span>                       // <span class="title">Holds</span> <span class="title">data</span> <span class="title">for</span> <span class="title">an</span> <span class="title">inventory</span> <span class="title">item</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> partNum;                     <span class="comment">// Part number</span></span><br><span class="line">    <span class="built_in">string</span> description;              <span class="comment">// Item description</span></span><br><span class="line">    <span class="keyword">int</span> onHand;                      <span class="comment">// Units on hand</span></span><br><span class="line">    <span class="keyword">double</span> price;                    <span class="comment">// Unit price</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Function prototypes</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getltemData</span><span class="params">(InvItem &amp;)</span> </span>;        <span class="comment">//普通引用，函数可能会对结构体数据造成影响</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showItem</span><span class="params">(<span class="keyword">const</span> InvItem &amp;)</span></span>;      <span class="comment">//常量引用，不会让函数对结构体造成数据变化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InvItem part;                    <span class="comment">// Define an Invltem structure variable.</span></span><br><span class="line">    getItemData(part);</span><br><span class="line">    showItem(part);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getItemData</span><span class="params">(InvItem &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the part number: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; item.partNum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the part description: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">    getline (<span class="built_in">cin</span>, item.description);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the quantity on hand: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; item.onHand;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the unit price: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; item.price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showItem</span><span class="params">(<span class="keyword">const</span> InvItem &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Part Number : &quot;</span> &lt;&lt; item.partNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Description : &quot;</span> &lt;&lt; item.description &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Units On Hand : &quot;</span> &lt;&lt; item.onHand &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Price : $&quot;</span> &lt;&lt; item.price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Enter the part number: 800</span><br><span class="line">Enter the part description: Screwdriver</span><br><span class="line">Enter the quantity on hand: 135</span><br><span class="line">Enter the unit price: 1.25</span><br><span class="line"></span><br><span class="line">Part Number : 800</span><br><span class="line">Description : Screwdriver</span><br><span class="line">Units On Hand: 135</span><br><span class="line">Price : $1.25</span><br></pre></td></tr></table></figure>



<h2 id="如何从函数返回一个结构体？"><a href="#如何从函数返回一个结构体？" class="headerlink" title="如何从函数返回一个结构体？"></a>如何从函数返回一个结构体？</h2><p> 也可以从函数返回结构体变量。在这种情况下，函数的返回类型是结构体的名称。可以改写程序 1 以允许 getItemData 函数创建 Invltem 结构体的局部实例，将数据值放入其成员变量中，然后将其传递回 main，而不是将其作为引用变量从 main 接收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InvItem <span class="title">getItemData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InvItem item;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the part number:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; item.partNum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the part description: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">    getline(<span class="built_in">cin</span>, item.description);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the quantity on hand: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; item.onHand;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the unit price: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; item.price;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是从 main 中调用它的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">part = getItemData();</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> <em>C++ 只允许从函数返回单个值。然而，结构体提供了解决这一限制的方法。即使一个结构体可能有几个成员，它在技术上还是一个单一的对象。通过在结构体中打包多个值，可以从函数返回任意数量的值。</em></p>
<h2 id="gt-符号区分？"><a href="#gt-符号区分？" class="headerlink" title=". | -&gt; | :: | :符号区分？"></a>. | -&gt; | :: | :符号区分？</h2><ol>
<li><p>A.B则A为对象或者结构体；</p>
</li>
<li><p>A-&gt;B则A为指针，-&gt;是成员提取，A-&gt;B是提取A中的成员B，A只能是指向类、结构、联合的指针；</p>
</li>
<li><p>:: 是作用域运算符，A::B表示作用域A中的名称B，A可以是名字空间、类、结构；</p>
</li>
<li><p>: 一般用来表示继承；</p>
</li>
</ol>
<h2 id="计算机上正在运行的句柄、线程、进程分别是什么意思？"><a href="#计算机上正在运行的句柄、线程、进程分别是什么意思？" class="headerlink" title="计算机上正在运行的句柄、线程、进程分别是什么意思？"></a>计算机上正在运行的句柄、线程、进程分别是什么意思？</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bluestorm/p/5712238.html">https://www.cnblogs.com/bluestorm/p/5712238.html</a></p>
<blockquote>
<p>所谓 <code>句柄</code> 实际上是一个数据，是一个Long (整长型)的数据。</p>
<p>句柄是WONDOWS用来标识被应用程序所建立或使用的对象的唯一整数，WINDOWS使用各种各样的句柄标识诸如应用程序实例，窗口，控制，位图，GDI对象等等。WINDOWS句柄有点像C语言中的文件句柄。 </p>
</blockquote>
<p>从上面的定义中的我们可以看到，句柄是一个 <code>标识符</code>，是拿来标识对象或者项目的，它就像我们的姓名一样，每个人都会有一个，不同的人的姓名不一样，但是，也可能有一个名字和你一样的人。从数据类型上来看它只是一个 <strong>16位的无符号整数</strong> 。<em><strong>应用程序几乎总是通过调用一个WINDOWS函数来获得一个句柄，之后其他的WINDOWS函数就可以使用该句柄，以引用相应的对象。</strong></em></p>
<p>句柄是一种 <code>指向指针的指针</code>。所谓指针是一种内存地址。应用程序启动后，组成这个程序的各对象是驻留在内存的。如果简单地理解，似乎只要获知这个内存的首地址，那么就可以随时用这个地址访问对象。但是非也，<strong>Windows是一个以虚拟内存为基础的操作系统</strong>。在这种系统环境下，Windows内存管理器经常在内存中来回移动对象，依此来满足各种应用程序的内存需要。对象被移动意味着它的地址变化了。如果地址总是如此变化，该到哪里去找该对象呢?</p>
<p>为了解决这个问题，Windows操作系统为各应用程序腾出一些 <code>内存储地址</code>，用来专门登记各应用对象在内存中的地址变化，而这个<strong>地址(存储单元的位置)本身是不变的</strong>。<strong>Windows内存管理器在移动对象在内存中的位置后，把对象新的地址告知这个句柄地址来保存。这样我们只需记住这个句柄地址就可以间接地知道对象具体在内存中的哪个位置。</strong>这个地址是在对象装载(Load)时由系统分配给的，当系统卸载时(Unload)又释放给系统。</p>
<p>句柄地址(稳定)→记载着对象在内存中的地址→对象在内存中的地址(不稳定)→实际对象</p>
<p><strong>本质：</strong>WINDOWS程序中并不是用物理地址来标识一个内存块，文件，任务或动态装入模块的，相反的，WINDOWS API给这些项目分配确定的句柄，并将句柄返回给应用程序，然后通过句柄来进行操作。 </p>
<p>但是必须注意的是程序每次从新启动，系统不能保证分配给这个程序的句柄还是原来的那个句柄，而且绝大多数情况的确不一样的。假如我们把进入电影院看电影看成是一个应用程序的启动运行，那么系统给应用程序分配的句柄总是不一样，这和每次电影院售给我们的门票总是不同的一个座位是一样的道理。</p>
<p><code>线程</code> 是指程序的一个指令执行序列，WIN32 平台支持多线程程序，允许程序中存在多个线程。 在单 CPU 系统中，系统把 CPU 的时间片按照调度算法分配给各个线程，因此各线程实际上是分时执行的，在多 CPU 的 Windows NT 系统中， 同一个程序的不同线程可以被分配到不同的 CPU 上去执行。<em>由于一个程序的各线程是在相同的地址空间运行的，因此设及到了如何共享内存， 如何通信等问题，这样便需要处理各线程之间的同步问题，这是多线程编程中的一个难点。</em></p>
<blockquote>
<p>线程,也被称为轻量进程（lightweight processes）。计算机科学术语，指运行中的程序的调度单位。</p>
<p>线程是进程中的实体，一个进程可以拥有多个线程，一个线程必须有一个父进程。线程不拥有系统资源，只有运行必须的一些数据结构；它与父进程的其它线程共享该进程所拥有的全部资源。线程可以创建和撤消线程，从而实现程序的并发执行。一般，线程具有 <code>就绪</code> 、 <code>阻塞</code> 和 <code>运行</code> 三种基本状态。</p>
</blockquote>
<p>在多中央处理器的系统里，不同线程可以同时在不同的中央处理器上运行，甚至当它们属于同一个进程时也是如此。<em><strong>大多数支持多处理器的操作系统都提供编程接口来让进程可以控制自己的线程与各处理器之间的关联度（affinity）。</strong></em></p>
<p><code>进程</code> 是程序在一个数据集合上运行的过程(注:一个程序有可能同时属于多个进程),它是操作系统进行资源分配和调度的一个独立单位,进程可以简单的分为 <code>系统进程</code> (包括一般Windows程序和服务进程)和 <code>用户进程</code> 。</p>
<h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><h3 id="Error"><a href="#Error" class="headerlink" title="#Error"></a>#Error</h3><h4 id="Encountered-with-text"><a href="#Encountered-with-text" class="headerlink" title="Encountered with text"></a>Encountered with text</h4><p>错误信息会在预编译期遇到错误的时候停止并给出，也就是错误信息的上一条执行代码出现了错误。</p>
<p>而上一条代码是 <code>#if !defined( __BYTE_ADDRESSING__ ) &amp;&amp; defined ( __ADSPSHARC__ )</code> ，需要综合给出的错误提示 “Only Byte addressing mode is supported” 。</p>
<p><img src="https://pic.islet.space/2021/05/20210520154529.png" alt="image-20210520154525815"></p>
<p><img src="https://pic.islet.space/2021/05/20210520154609.png" alt="image-20210520154603077"></p>
<h3 id="Null未定义"><a href="#Null未定义" class="headerlink" title="Null未定义"></a>Null未定义</h3><p><img src="https://pic.islet.space/2021/05/20210520154637.png" alt="image-20210520154631949"></p>
<p><img src="https://pic.islet.space/2021/05/image-20210520232442191.png" alt="image-20210520232442191"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2020/12/26/Hardware/TI/2020-12-26-Ti%C2%A0SysBIOS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/26/Hardware/TI/2020-12-26-Ti%C2%A0SysBIOS/" class="post-title-link" itemprop="url">Ti SysBios</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-26 23:58:32" itemprop="dateCreated datePublished" datetime="2020-12-26T23:58:32+08:00">2020-12-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-09 13:20:14" itemprop="dateModified" datetime="2021-05-09T13:20:14+08:00">2021-05-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hardware/" itemprop="url" rel="index"><span itemprop="name">Hardware</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[TOC]</p>
<h1 id="SYS-BIOS"><a href="#SYS-BIOS" class="headerlink" title="SYS/BIOS"></a>SYS/BIOS</h1><ul>
<li><p>The Ethernet Media Access Controller (EMAC) module provides an efficient interface between the device core processor and the networked community.</p>
</li>
<li><p>The EMAC controls the flow of packet data from the processor to the PHY. The MDIO module controls PHY configuration and status monitoring.</p>
</li>
<li><p>Both the EMAC and the MDIO modules interface to the DSP through a custom interface that allows efficient data transmission and reception. </p>
</li>
<li><p>This custom interface is referred to as the EMAC control module, and is considered integral to the EMAC/MDIO peripheral.</p>
</li>
<li><p>The EMAC control, EMAC, and MDIO modules all have control registers. These registers are memory <strong>mapped into device memory space</strong> via the device configuration bus.【EMAC控制器、EMAC、MDIO模块都有控制寄存器，寄存器地址通过设备控制总线写入设备内存空间。】</p>
</li>
<li><p>【Descriptor 不存储任何缓冲数据，仅仅作为数据描述包而存在。主要结构为pNext、pBuffer、Buffer Offset、Buffer Length、Flags和Packet Length。其中，pBuffer是指向数据包Packet的指针存储块。】</p>
</li>
</ul>
<h2 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h2><h3 id="IDE-Installation"><a href="#IDE-Installation" class="headerlink" title="IDE Installation"></a>IDE Installation</h3><h4 id="SETUP"><a href="#SETUP" class="headerlink" title="SETUP"></a>SETUP</h4><h4 id="CONFIGURATIONS"><a href="#CONFIGURATIONS" class="headerlink" title="CONFIGURATIONS"></a>CONFIGURATIONS</h4><h3 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h3><h4 id="开发及编译环境"><a href="#开发及编译环境" class="headerlink" title="开发及编译环境"></a>开发及编译环境</h4><ol>
<li>CSS安装</li>
<li>TI编译工具安装</li>
<li>SYS/BIOS安装</li>
<li>BIOS-MCSDK软件包安装</li>
<li>BIOS-MCSDK软件包<em>补丁</em>安装</li>
<li>XDC-Tools安装</li>
<li>pdk_C6657软件包</li>
</ol>
<table>
<thead>
<tr>
<th>安装流程</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CCS安装</strong></td>
<td>CCS工程操作本体软件</td>
</tr>
<tr>
<td><strong>TI编译工具安装</strong></td>
<td>TI某型号设备编译软件，一定要确保是否安装，没有的话无法生成工程文件</td>
</tr>
<tr>
<td><strong>SYS/BIOS安装</strong></td>
<td>SYS/BIOS RTOS系统（可能安装BIOS_MCSDK时自带）</td>
</tr>
<tr>
<td><strong>BIOS-MCSDK软件包安装</strong></td>
<td>安装时会生成 <code>ndk_2_21_01_38</code>，需要删除，不删除会导致后面无法安装其他软件包</td>
</tr>
<tr>
<td><strong>BIOS-MCSDK软件包<em>补丁</em>安装</strong></td>
<td>必须安装，否则会出错</td>
</tr>
<tr>
<td><strong>XDC-Tools安装</strong></td>
<td>装CSS的时候就已经能自带XDC-Tools了，也可以单独更新版本</td>
</tr>
<tr>
<td><strong>pdk_C6657软件包</strong></td>
<td>安装BIOS_MCSDK时自带</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<ul>
<li>部分SDK、组件包可能会线下兼容，但是版本包带不带特殊标识，如XDCTOOLS个别版本带 <code>_core</code> 的，可能会导致不兼容<code>gr</code> platform。</li>
<li>组件包安装完毕之后需要在 CCS 的 <code>Products and Repositories</code> 中进行挂载和选择。</li>
</ul>
<h4 id="工程生成、导入与重编"><a href="#工程生成、导入与重编" class="headerlink" title="工程生成、导入与重编"></a>工程生成、导入与重编</h4><p>工程的生成、导入与重编主要是针对他人写的代码，未针对我的硬件生成对应的工程文件，因而需要按照我的编译环境和硬件生成对应的工程文件，进而应用到我的硬件上。</p>
<h5 id="工程生成"><a href="#工程生成" class="headerlink" title="工程生成"></a>工程生成</h5><p>通过执行命令行工具 <code>pdksetupenv.bat</code> 和 <code>pdkProjectCreate.bat</code> 在对应的工程文件包生成工程文件夹 <code>project</code> 。</p>
<p><strong>注意事项：</strong> </p>
<blockquote>
<p><em>命令行工具中设置了一些关于路径的变量，如果安装了更新版本的软件包则因进入命令行文件对相应的文件路径进行修改。</em> 如下，XDC-TOOLS 可能因为版本问题而导致 <code>XDC_INSTALL_PATH</code> 变量出错，各变量也应一一对照安装路径的文件夹名称进行审核。</p>
<p><code>pdksetupenv.bat</code> 文件下的变量设置：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> MCSDK_INSTALL_PATH=D:\TexasInstruments\</span><br><span class="line"><span class="built_in">set</span> XDC_INSTALL_PATH=<span class="variable">%MCSDK_INSTALL_PATH%</span>\xdctools_3_25_06_96</span><br></pre></td></tr></table></figure>

<p><code>pdkProjectCreate.bat</code> 文件下的变量设置如下：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">@REM 需修改成实际安装路径</span></span><br><span class="line"><span class="built_in">set</span> CCS_INSTALL_PATH=&quot;D:\ti\ccsv7&quot;</span><br><span class="line"></span><br><span class="line"><span class="comment">@REM 以下各文件版本需要根据当前最新使用的软件包版本来调整</span></span><br><span class="line"><span class="built_in">set</span> CGT_VERSION=<span class="number">8</span>.<span class="number">3</span>.<span class="number">8</span></span><br><span class="line"><span class="built_in">set</span> XDC_VERSION=<span class="number">3</span>.<span class="number">32</span>.<span class="number">2</span>.<span class="number">25</span>_core</span><br><span class="line"><span class="built_in">set</span> BIOS_VERSION=<span class="number">6</span>.<span class="number">33</span>.<span class="number">06</span>.<span class="number">50</span></span><br><span class="line"><span class="built_in">set</span> IPC_VERSION=<span class="number">1</span>.<span class="number">24</span>.<span class="number">03</span>.<span class="number">32</span></span><br><span class="line"><span class="built_in">set</span> EDMA_VERSION=<span class="number">02</span>.<span class="number">11</span>.<span class="number">05</span>.<span class="number">02</span></span><br><span class="line"><span class="built_in">set</span> NDK_VERSION=<span class="number">2</span>.<span class="number">21</span>.<span class="number">02</span>.<span class="number">43</span></span><br><span class="line"><span class="built_in">set</span> PDK_VERSION=<span class="number">1</span>.<span class="number">1</span>.<span class="number">2</span>.<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>在以上文件都设置好以后，还需要进入CCS，点击 <code>WINDOWS</code> -&gt; <code>PREFERENCES</code> -&gt; <code>CODE COMPOSER STUDIO</code> -&gt; <code>PRODUCTS</code> , 在 <code>INSTALLED PRODUCTS</code> 面板下找到已安装的软件包，如果未找到，点击 <code>INSTALL</code> , 选择 <code>/ti</code> 路径进行软件包安装。</p>
<p>如未挂载软件包，可能会出现错误提示如：<code>!ERROR: Unknown product-type ID &#39;com.ti.sdo.edma3&#39;!</code></p>
</blockquote>
<p>找到示例文件，在示例文件的 <code>/src/</code> 文件夹下，按住 <code>shift键</code> 并 点击鼠标右键，选择 <code>在此处打开Powershell窗口</code> ，输入绝对路径和文件名称并按回车运行，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\ti\pdk_C6657_1_1_2_6\packages\ti\drv\pdksetupenv.bat</span><br><span class="line">D:\ti\pdk_C6657_1_1_2_6\packages\ti\drv\pdkProjectCreate.bat</span><br></pre></td></tr></table></figure>

<p>成功时结果如下示：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PDK_SHORT_NAME: <span class="title">I</span>:\03.<span class="title">TexasInstruments_Workspace</span>\<span class="title">tl</span>-<span class="title">led</span>-<span class="title">flash</span>\<span class="title">src</span></span></span><br><span class="line"><span class="function">*****************************************************************************</span></span><br><span class="line"><span class="function"><span class="title">Detecting</span> <span class="title">UnitTest</span> <span class="title">Projects</span> <span class="title">in</span> <span class="title">PDK</span> <span class="title">and</span> <span class="title">importing</span> <span class="title">them</span> <span class="title">in</span> <span class="title">the</span> <span class="title">workspace</span> &quot;<span class="title">I</span>:\03.<span class="title">TexasInstruments_Workspace</span>\<span class="title">tl</span>-<span class="title">led</span>-<span class="title">flash</span>\<span class="title">src</span>\<span class="title">project</span>&quot;</span></span><br><span class="line"><span class="function">找不到文件</span></span><br><span class="line"><span class="function">*****************************************************************************</span></span><br><span class="line"><span class="function"><span class="title">Detecting</span> <span class="title">Example</span> <span class="title">Projects</span> <span class="title">in</span> <span class="title">PDK</span> <span class="title">and</span> <span class="title">importing</span> <span class="title">them</span> <span class="title">in</span> <span class="title">the</span> <span class="title">workspace</span> &quot;<span class="title">I</span>:\03.<span class="title">TexasInstruments_Workspace</span>\<span class="title">tl</span>-<span class="title">led</span>-<span class="title">flash</span>\<span class="title">src</span>\<span class="title">project</span>&quot;</span></span><br><span class="line"><span class="function">找不到文件</span></span><br><span class="line"><span class="function">*****************************************************************************</span></span><br><span class="line"><span class="function"><span class="title">Detecting</span> <span class="title">TL</span> <span class="title">Projects</span> <span class="title">and</span> <span class="title">importing</span> <span class="title">them</span> <span class="title">in</span> <span class="title">the</span> <span class="title">workspace</span> &quot;<span class="title">I</span>:\03.<span class="title">TexasInstruments_Workspace</span>\<span class="title">tl</span>-<span class="title">led</span>-<span class="title">flash</span>\<span class="title">src</span>\<span class="title">project</span>&quot;</span></span><br><span class="line"><span class="function"><span class="title">Detected</span> <span class="title">Example</span> <span class="title">Project</span>: <span class="title">tl</span>-<span class="title">led</span>-<span class="title">flash</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="title">Creating</span> <span class="title">project</span> &#x27;<span class="title">tl</span>-<span class="title">led</span>-<span class="title">flash</span>&#x27;...</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Done</span>!</span></span><br><span class="line"><span class="function"><span class="title">Copying</span> <span class="title">macros.ini</span></span></span><br><span class="line"><span class="function">已复制         1 个文件。</span></span><br></pre></td></tr></table></figure>



<p>遇到关于 的问题</p>
<p><code>D:\ti\ccsv7\tools\compiler\ti-cgt-c6000_8.2.2\lib</code></p>
<h2 id="XDC-STD"><a href="#XDC-STD" class="headerlink" title="XDC/STD"></a>XDC/STD</h2><h3 id="DETAILS"><a href="#DETAILS" class="headerlink" title="DETAILS"></a>DETAILS</h3><p>In addition to the interfaces specified below, this package  also supplies a C/C++ header, <code>std.h</code> that facilitates the creation of  portable sources. This header defines a set of “base” types that enable the  creation of C-code that is portable between any two targets. C source code that  relies exclusively on these types is portable to all targets and platforms.  Where appropriate, the types defined below are related to the types defined in  the library headers prescribed by the C99 standard (ISO/IEC 9899:1999).</p>
<p>Why not simply use the C99 types? Having a unique set of  names provides <strong>a layer of insulation between a portable code base and a  particular compiler</strong>; e.g., even if a compiler does not support the C99 types or  defines them inappropriately for a particular device, it is possible to use the  compiler without changing the code base. Thus, the developer is not forced to  choose the lesser of two evils: waiting for a change to the compiler or forking  the code base for a particular compiler device combination.</p>
<p>There are several situations where a small separate set of  <strong>portable types</strong> can help the maintainability of a code base.</p>
<ul>
<li>not all of the types described in the C99 standard are required to be  defined by conformant implementations nor is it possible for all devices to  implement some of the types specified (e.g., <code>int8_t</code> is not implemented  on C54 devices); so it is difficult to identify non-portable source code. </li>
<li>not all compilers provide C99 type support; if XDC supplies the type  definition and the compiler is updated to include C99 types, a compilation error  will occur if the source includes the C99 headers. </li>
<li>not all compiler and device combinations are conformant; even high quality  compilers may not properly define the types for each device supported by  compiler. </li>
</ul>
<h3 id="USAGE"><a href="#USAGE" class="headerlink" title="USAGE"></a>USAGE</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xdc/std.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>To compile sources that include <code>xdc/std.h</code>, <strong>two  symbols must be defined</strong> before including this header:</p>
<ul>
<li><p><code>xdc_target_types__</code></p>
<p>the package qualified path of the target’s standard types header; e.g.,  <code>ti/targets/std.h</code>. This value is specified in the target’s  <code>stdInclude</code> config parameter; see <code>xdc.bld.ITarget.stdInclude</code> </p>
</li>
<li><p><code>xdc_target_name__</code></p>
<p>the target’s module name without the package prefix; e.g., <code>C64</code>  rather than <code>ti.targets.C64</code>. </p>
</li>
</ul>
<p>For example, to compile sources for the  <code>ti.targets.C64</code> target using TI’s <code>cl6x</code> compiler, the following  command line is sufficient:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl6x -Dxdc_target_types__&#x3D;ti&#x2F;targets&#x2F;std.h -Dxdc_target_name__&#x3D;C64</span><br></pre></td></tr></table></figure>

<p>Each of the type names below has an equivalent “long name”;  i.e., a name that has an “<code>xdc_</code>“ prefix. For example, the type  <code>Bool</code> can also be written as “<code>xdc_Bool</code>“. <strong>Long names exist to  avoid conflicts with names defined or used by existing code bases.</strong></p>
<p>In the event that one of the short type names below  conflicts with another type name (that can not be changed), it is possble to  disable the short names by defining the symbol <code>xdc__nolocalnames</code> before  including <code>xdc/std.h</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define xdc__nolocalnames</span><br><span class="line">#include &lt;xdc&#x2F;std.h&gt;</span><br></pre></td></tr></table></figure>



<h3 id="STANDARD-TYPES"><a href="#STANDARD-TYPES" class="headerlink" title="STANDARD TYPES"></a>STANDARD TYPES</h3><p>This header may be included multiple times and defines the  following target-dependent types:</p>
<ul>
<li><p><code>Bool</code></p>
<blockquote>
<p>this type is large enough to hold the values <code>0</code> or <code>1</code>. The  constants TRUE and FALSE are of this type; see below. </p>
</blockquote>
</li>
<li><p><code>String</code></p>
<blockquote>
<p>this type is defined to be a <code>char *</code> and exists to allow code to  distinguish between pointers to buffers of raw data and ‘\0’ terminated strings. </p>
</blockquote>
</li>
<li><p><code>CString</code></p>
<blockquote>
<p>this type is defined to be a <code>const char *</code> and exists to allow code  to distinguish between pointers to a modifiable ‘\0’ terminated sequence of  characters (i.e., a <code>String</code>) and one that is not modifiable (e.g., a  literal string such as <code>&quot;hello world\n&quot;</code>). </p>
</blockquote>
</li>
<li><p><code>Int</code>n, where n = 8, 16, or 32</p>
<blockquote>
<p>signed integer type that is large enough to hold n bits; the actual target  type may by be larger than n. This type is equivalent to one of the C99 types  <code>int_least</code>n<code>_t</code> or <code>int_fast</code>n<code>_t</code>; see Section  7.18. </p>
</blockquote>
</li>
<li><p><code>UInt</code>n, where n = 8, 16, or 32</p>
<blockquote>
<p>unsigned integer type that is large enough to hold n bits; the actual target  type may by be larger than n. This type is equivalent to one of the C99 types  <code>uint_least</code>n<code>_t</code> or <code>uint_fast</code>n<code>_t</code>; see ISO/IEC  9899:1999 Section 7.18. </p>
</blockquote>
</li>
<li><p><code>Bits</code>n, where n = 8, 16, or 32</p>
<blockquote>
<p>unsigned integer type that is precisely n bits. Not all targets support all  values of n; if the target does not support an exact size the corresponding type  is not defined. This type is equivalent to the corresponding C99 type  <code>uint</code>n<code>_t</code>; see ISO/IEC 9899:1999 Section 7.18. </p>
</blockquote>
</li>
<li><p><code>Fxn</code></p>
<blockquote>
<p>this type is a pointer to code; it can hold a pointer to any function. </p>
</blockquote>
</li>
<li><p><code>Ptr</code></p>
<blockquote>
<p>this type is a pointer to data; it can hold a pointer to any data structure. </p>
</blockquote>
</li>
<li><p><code>IArg</code></p>
<blockquote>
<p>this integer type is large enough to hold a <code>Fxn</code>, <code>Ptr</code>, or  <code>Int</code>. </p>
</blockquote>
</li>
<li><p><code>UArg</code></p>
<blockquote>
<p>this unsigned integer type is large enough to hold a <code>Fxn</code>,  <code>Ptr</code>, or <code>Int</code>. </p>
</blockquote>
</li>
<li><p><code>LLong</code></p>
<blockquote>
<p>this long integer type is large enough to hold a <code>Long</code> and is  defined as a ‘long long’ type on targets that support this type; otherwise, it  is simply a <code>Long</code>. Note that C99 requires the <code>long long</code> type to  be at least 64-bits wide (See ISO/IEC 9899:1999 Section 5.2.4.2.1). But some  compilers do not support 64-bit integral types and some don’t support the  <code>long long</code> even though they do support 64-bit integral types. Since  these variations limit the portability of valid C sources, the LLong type is  always defined, is always at least as wide as the <code>Long</code> type, and is at  least 64-bits wide for targets that support 64-bit integral types. </p>
</blockquote>
</li>
<li><p><code>ULLong</code></p>
<blockquote>
<p>this unsigned long integer type is large enough to hold a <code>ULong</code> and  is defined as a ‘unsigned long long’ type on targets that support this type;  otherwise, it is simply a <code>ULong</code>. </p>
</blockquote>
</li>
</ul>
<p>The <code>xdc/std.h</code> header also defines the following  aliases for the base C types. These aliases exist so that C sources can  consistently follow a naming convention in which all type names are written in  camel-case.</p>
<ul>
<li><p><code>Char</code> and <code>UChar</code></p>
<blockquote>
<p>aliases for <code>char</code> and <code>unsigned char</code>, respectively </p>
</blockquote>
</li>
<li><p><code>Short</code> and <code>UShort</code></p>
<blockquote>
<p>aliases for <code>short</code> and <code>unsigned short</code>, respectively </p>
</blockquote>
</li>
<li><p><code>Int</code> and <code>UInt</code></p>
<blockquote>
<p>aliases for <code>int</code> and <code>unsigned int</code>, respectively </p>
</blockquote>
</li>
<li><p><code>Long</code> and <code>ULong</code></p>
<blockquote>
<p>aliases for <code>long</code> and <code>unsigned long</code>, respectively </p>
</blockquote>
</li>
<li><p><code>Double</code> and <code>LDouble</code></p>
<blockquote>
<p>aliases for <code>double</code> and <code>long double</code>, respectively </p>
</blockquote>
</li>
<li><p><code>SizeT</code></p>
<blockquote>
<p>alias for <code>size_t</code> </p>
</blockquote>
</li>
<li><p><code>VaList</code></p>
<blockquote>
<p>alias for <code>va_list</code> </p>
</blockquote>
</li>
</ul>
<p>The types above are defined for all targets. Some targets  can support the following additional types. Since these types are not always  supported by a target, these types should only be used when no other type  sufficies.</p>
<ul>
<li><p><code>Bits</code>n, where n = 8, 16, or 32</p>
<blockquote>
<p>this unsigned integer type is precisely n-bits wide. This type is equivalent  to the optional C99 type <code>uint</code>n<code>_t</code>; see ISO/IEC 9899:1999  Section 7.18.1.1. This type is defined if and only if the preprocessor macro  <code>xdc__BITS</code>n<code>__</code> is defined. </p>
</blockquote>
</li>
</ul>
<h3 id="64-BIT-TYPES"><a href="#64-BIT-TYPES" class="headerlink" title="64 BIT TYPES"></a>64 BIT TYPES</h3><p>Although the C99 standard requires support for 64-bit types,  not all compiler/device combinations can usefully support them. As a result, the  64-bit types described here may not be defined for all targets. For each type  there is a corresponding pre-processor macro which is defined if and only if the  type is supported.</p>
<ul>
<li><p><code>Int64</code></p>
<blockquote>
<p>signed integer type that is large enough to hold 64 bits; the actual target  type may by be wider than 64 bits. This type is equivalent to one of the C99  types <code>int_least64_t</code> or <code>int_fast64_t</code>; see Section 7.18. This  type is defined if and only if the preprocessor macro <code>xdc__INT64__</code> is  defined. </p>
</blockquote>
</li>
<li><p><code>UInt64</code></p>
<blockquote>
<p>unsigned integer type that is large enough to hold n bits; the actual target  type may by be wider than 64 bits. This type is equivalent to one of the C99  types <code>uint_least64_t</code> or <code>uint_fast64_t</code>; see ISO/IEC 9899:1999  Section 7.18. This type is defined if and only if the preprocessor macro  <code>xdc__INT64__</code> is defined. </p>
</blockquote>
</li>
<li><p><code>Bits64</code></p>
<blockquote>
<p>unsigned integer type that is precisely 64 bits wide. If the target does not  support an exact 64-bit size, this type is not defined. This type is equivalent  to the corresponding C99 type <code>uint64_t</code>; see ISO/IEC 9899:1999 Section  7.18. This type is defined if and only if the preprocessor macro  <code>xdc__BITS64__</code> is defined. </p>
</blockquote>
</li>
</ul>
<p><em>The table below is from <strong>Log_print6()</strong> in the <strong>XDC/RUNTIME/LOG.H</strong>.</em></p>
<p>However, because the declared type of the arguments is <code>IArg</code>, all pointer  arguments must be cast to an <code>IArg</code> type.<code>IArg</code> is an integral type large enough to hold any pointer or an  <code>int</code>. So, casting a pointer to an <code>IArg</code> does not cause any loss  of information and C’s normal integer conversions make the cast unnecessary for  integral arguments.</p>
<p>The format string can use the following conversion  characters. However, it is important to recall that all arguments referenced by  these conversion characters have been converted to an <code>IArg</code> prior to  conversion; so, the use of “length modifiers” should be avoided.</p>
<table>
<thead>
<tr>
<th>Conversion Character</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>%c</td>
<td>Character</td>
</tr>
<tr>
<td>%d</td>
<td>Signed integer</td>
</tr>
<tr>
<td>%u</td>
<td>Unsigned integer</td>
</tr>
<tr>
<td>%x</td>
<td>Unsigned hexadecimal integer</td>
</tr>
<tr>
<td>%o</td>
<td>Unsigned octal integer</td>
</tr>
<tr>
<td>%s</td>
<td>Character string</td>
</tr>
<tr>
<td>%p</td>
<td>Pointer</td>
</tr>
<tr>
<td>%f</td>
<td>Single precision floating point (float)</td>
</tr>
</tbody></table>
<p><code>usertype.h</code> 中的定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>           INT8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">short</span>          INT16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>            INT32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>  UINT8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> UINT16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>   UINT32;</span><br></pre></td></tr></table></figure>



<h2 id="SYS-BIOS-RTOS"><a href="#SYS-BIOS-RTOS" class="headerlink" title="SYS/BIOS RTOS"></a>SYS/BIOS RTOS</h2><p>我们依赖操作系统来提供底层和中间件的服务，如让设备启动，处理基本IO口，允许多个程序并行运行，为多个正在运行的程序分配内存和磁盘空间，以及通过USB和以太网口等通讯堆栈来实现更多复杂的IO口通讯。</p>
<h3 id="RTOS的优点"><a href="#RTOS的优点" class="headerlink" title="RTOS的优点"></a>RTOS的优点</h3><ul>
<li>模块化设计，线程的使用使各任务得到最大化独立；</li>
<li>提供模块及接口以方便地驱动外设；</li>
<li>代码可移植性/脱离于内核处理器；</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li>线程是一组存储在存储器的代码，一旦寄存器被正确初始化，CPU就会执行这些代码。</li>
<li>定义和管理任何需要被操作的内容<ul>
<li>包括程序指针、堆栈和寄存器等值</li>
<li>这些被统称“上下文”【每个线程都会被定义上下文，包括<code>程序计数器</code>、<code>堆栈</code>和<code>关键寄存器</code>的信息】</li>
<li>会有一系列的线程需要在指定时间被执行，RTOS会按一定标准在指定时间选择线程执行。</li>
</ul>
</li>
<li>线程可以使任何类型的，SYS/BIOS定义了四种线程类型（优先级降序排列）：<ul>
<li>硬件中断</li>
<li>软件中断</li>
<li>任务</li>
<li>空闲</li>
</ul>
</li>
<li>各线程有 隐式的(implicity) 和 显示的(explicity)（可能有）优先级<ul>
<li>隐式的优先级由线程类型决定</li>
<li>显式的优先级由软件编程者决定</li>
</ul>
</li>
<li>允许抢占（或者上下文切换）<ul>
<li>基于优先级的调度管理机制保证了最高优先级的线程能够在第一时间被执行</li>
</ul>
</li>
<li>线程之间的交互<ul>
<li>阻断</li>
<li>通信</li>
<li>同步</li>
</ul>
</li>
</ul>
<h3 id="TIMER-and-CLOCK"><a href="#TIMER-and-CLOCK" class="headerlink" title="TIMER and CLOCK"></a>TIMER and CLOCK</h3><ul>
<li><strong>定时器模块 TIMER</strong></li>
<li>管理定时器外设</li>
<li>提供虚拟的目标/设备概念<ul>
<li>【通过操作定时器模块而不是硬件外设，开发人员能够更轻松更直观地管理定时器，且在多个不同TI芯片中移植式，代码更具可移植性】</li>
<li>【对于SYS/BIOS而言，可以产生无限数量的定时器】</li>
</ul>
</li>
<li><strong>时钟模块 CLOCK</strong><ul>
<li>管理BIOS的“心脏节拍“</li>
<li>在指定时间触发功能（单次或周期性）</li>
<li>使用定时器模块或者应用层模块的“节拍”来处理输入事件</li>
<li>【时钟模块所在的层位于定时器之上】</li>
<li>【时钟模块可以通过定时器模块将系统中的外部事件引入作为输入事件，或者使用定时器模块产生的周期性节拍，基于这些输入事件，时钟模块可以产生软件中断，或者时钟模块还能提供一种服务，以便一次性或者周期性地触发任意数量的不同函数】</li>
<li>【时钟实例中包含了对两个时间段的定义，第一个时间段的定义称为<code>超时时间量</code>，它定义了时钟实例的启动和首次触发相关函数的时间量，通常会在应用程序中，通过显示的调用时钟来启动一个时钟实例，如果创建时钟实例时，标志为TRUE，则实例会在创建后立即启动；第二个时间段的定义标志了相关函数首次调用和后续调用之间<code>持续时间量</code>；对于一次性的时钟实例，只需定义超时时间量，持续时间量将为0；相关函数都是由时钟实例的中断来调用的，这意味着必须在同一线程中启动或停止时钟，而不能在其他线程中任意启动或停止时钟】</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动/停止时钟实例，仅能通过时钟SWI调用</span></span><br><span class="line">Clock_start()</span><br><span class="line">Clock_stop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动/停止定时器底层产生时间节拍</span></span><br><span class="line"><span class="comment">// 【`时钟停止启动` 和 `时钟节拍停止`，用来为驱动时钟模块提供底层定时器】</span></span><br><span class="line">Clock_tickStart()</span><br><span class="line">Clock_tickStop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改停止的时钟实例</span></span><br><span class="line"><span class="comment">// 【设置 `时钟周期`、`超时`、`功能` 函数，用于修改时钟实例的参数】</span></span><br><span class="line">Clock_setPeriod()</span><br><span class="line">Clock_setTimeout()</span><br><span class="line">Clock_setfunc()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许修改时钟实例的参数，基于新的定时器频率</span></span><br><span class="line"><span class="comment">// 当CPU的频率发生变化时，可以通过此函数对时钟进行重新配置</span></span><br><span class="line">Clock_tickReconfig()</span><br></pre></td></tr></table></figure>

<ul>
<li>时间戳模块<ul>
<li>为代码的基准测试提供便捷的时间戳服务</li>
<li>允许时间戳记录RTA日志</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*前两个变量的类型由时钟模块定义*/</span></span><br><span class="line">Clock_Params clockParams;               <span class="comment">//用于容纳所有的时钟实例参数</span></span><br><span class="line">Task_Handle myClock;                    <span class="comment">//用于存储将要创建的时钟实例的句柄</span></span><br><span class="line">Error_block eb;                         <span class="comment">//错误块变量，若创建失败可以获取失败原因的信息</span></span><br><span class="line"></span><br><span class="line">Clock_Params_init(&amp;clockParams);        <span class="comment">//时钟实例初始化参数，已默认值填充参数结构</span></span><br><span class="line"><span class="comment">/*下两句分别更新与默认值不同的参数*/</span></span><br><span class="line">clockParams.period = <span class="number">4</span>;                 <span class="comment">//Every 4 Clock ticks</span></span><br><span class="line">ClockParams.startFlag = TRUE;           <span class="comment">//Start immediately</span></span><br><span class="line">Error_init(&amp;eb);                        <span class="comment">//错误块变量，若创建失败可以获取失败原因的信息</span></span><br><span class="line"></span><br><span class="line">myClock = Clock_create((Clock_FuncPtr)clockHandler,<span class="number">4</span>,&amp;clockParams,&amp;eb); <span class="comment">//三参数，时钟实例创建，并返回句柄给myClock</span></span><br></pre></td></tr></table></figure>



<p><strong>在XGCONF中配置时钟参数：</strong></p>
<table>
<thead>
<tr>
<th>NAME</th>
<th>VALUE</th>
</tr>
</thead>
<tbody><tr>
<td>tickSource</td>
<td><code>tickSource_TIMER</code> ：选择定时器（周期性调用Clock_tick)； <code>tickSource_User</code>：选择外部中断触发调用Clock_tick；<code>tickSource_NULL</code>：没有时钟API，没有超时【由信号量写入的调用不能具有超时值】</td>
</tr>
<tr>
<td>timerId</td>
<td>【用于指定芯片实际使用的定时器外设】<code>-1</code>：默认定时器</td>
</tr>
<tr>
<td>swiPiority</td>
<td>【时钟模块是由底层定时器模块触发软件中断来调用的，因此其SWI的优先级可以设置】默认值 <code>15</code></td>
</tr>
<tr>
<td>tickPeriod</td>
<td>【系统节拍的周期】默认值 <code>1000</code> usec</td>
</tr>
</tbody></table>
<p><strong>时钟实例化参数：</strong></p>
<table>
<thead>
<tr>
<th>NAME</th>
<th>VALUE</th>
</tr>
</thead>
<tbody><tr>
<td>clockFxn</td>
<td>[Creat Args]【需要被调用的实例函数在clockfxn字段中】</td>
</tr>
<tr>
<td>timeout</td>
<td>[Creat Args]【从时钟开始运行到相关函数被首次调用的初始时间值】</td>
</tr>
<tr>
<td>startFlag</td>
<td>[Params]【将指定时钟是在BIOS的调度程序开始运行时立即启动，还是由应用程序调用时钟的启动API】<code>true</code>：立即启动；<code>false</code>：调用；<code>Clock_start()</code> ：后启动</td>
</tr>
<tr>
<td>period</td>
<td>[Params]【在首次调用函数后，需要确定后续函数调用的间隔】<code>0</code>：单次调用；</td>
</tr>
<tr>
<td>arg</td>
<td>[Params] argument to clockFxn【用户可以将静态变量传递给相关函数，这样做可以将多个时钟实例共同使用单一函数，由于每个实例都可以向被调用的函数传递一个不同的值，因此在实现函数时可以根据调用到的时钟采取不同的操作】</td>
</tr>
</tbody></table>
<h3 id="HWI-and-Idle"><a href="#HWI-and-Idle" class="headerlink" title="HWI and Idle"></a>HWI and Idle</h3><p>嵌入式硬件中断的原理：前台/后台调度（主要由低优先级任务、无线循环任务和ISR构成，复杂性较低，存在不足）</p>
<ul>
<li>应用程序循环处理由硬件中断服务程序职位的标志位</li>
<li>ISR抢断主循环，执行中断服务【ISR 被称为前台进程】</li>
</ul>
<p>SYS/BIOS在BIOS之上实行 <code>Idle loop</code> + <code>Hwi</code> + <code>main()</code> 的方式：</p>
<ul>
<li>空闲循环是优先级最低的无限循环（并不代表优先级不重要），所执行的是一系列静态配置的后台程序</li>
<li>典型应用：用户界面，内置的系统测试，测量，以及低功耗模式</li>
<li>被最高优先级线程抢断/从被抢断的地方恢复运行</li>
<li><strong>ISR以HWI线程的方式运行，任意HWI都能抢断空闲循环</strong></li>
</ul>
<p><strong>后台空闲循环（线程）</strong></p>
<blockquote>
<p>The <strong>background Idle Loop</strong> is the thread with the lowest priority of all. It runs in a loop when the CPU is not busy running another thread. </p>
</blockquote>
<ul>
<li><p>When tasks are enabled, the Idle Loop is implemented as the only task running at priority 0. </p>
</li>
<li><p>When tasks are disabled, the Idle Loop is fallen into after the application’s “main()” function is called.（空闲循环会在应用程序main()函数被调用后陷入？）</p>
</li>
</ul>
<p><strong>HWI的中断及恢复流程（中断调度流程）：</strong></p>
<ol>
<li>屏蔽任务调度【HWI是被视为隐式的较高优先级线程，因此不希望所有目前最高优先级的线程抢断HWI线程，如果应用程序没有启用任务模块，该段启动任务调度的程序将被优化出中断调度程序，以便确保中断调度程序能够高效执行】</li>
<li>转向ISR堆栈（如果没有指向该堆栈）【如果当前指针指向任务堆栈，则此时会切换到中断堆栈】</li>
<li>保存中断返回地址【中断调度程序将存储该指针，以防用户使用IRP的API来检索该返回地址，如果不需要使用该API则被优化】</li>
<li>屏蔽SWI调度【如任务模块一样未被开启，则自动优化出中断调度程序】</li>
<li>调用HWI挂钩启动函数【<strong>附加</strong>挂钩函数】</li>
<li>如果允许自动嵌套：允许全局中断【有更高优先级的硬件中断来临时，打开中断屏蔽，使能全局中断】</li>
<li>调用ISR服务程序【真正的硬件中断程序开始执行】</li>
<li>屏蔽全局中断</li>
<li>调用HWI挂钩结束函数</li>
<li>运行SWI调度</li>
<li>切换回任务堆栈</li>
<li>运行任务调度</li>
</ol>
<p><strong>SYS/BIOS中断管理的优势：</strong></p>
<ol>
<li>降低代码量</li>
<li>提供中断堆栈，降低任务堆栈大小</li>
<li>管理中断嵌套</li>
<li>在ISR任务中禁止调度中断</li>
<li>运行由ISR程序递交的SWI程序</li>
<li>管理任务抢断</li>
<li>提供监测</li>
<li>灵活性：仍然允许不执行中断调度</li>
</ol>
<p><strong>注意：</strong> <em>HWI不需要使用编译器认可的中断关键字！SYS/BIOS的中断调度会自动保存堆栈相关数据，如果使用会导致灾难性的运行故障发生！</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hwi_Params hwiParams;              <span class="comment">//硬件中断参数结构体实例</span></span><br><span class="line">Hwi_Handle hwi0;                   <span class="comment">//硬件中断句柄</span></span><br><span class="line">Error_block eb;</span><br><span class="line"></span><br><span class="line">Hwi_Params_init(&amp;hwiParams);       <span class="comment">//参数初始化</span></span><br><span class="line">hwiParams.arg = <span class="number">5</span>;                 <span class="comment">//更新参数</span></span><br><span class="line">hwi0 = Hwi_create(id,hwiFunc,&amp;hwiParams,&amp;eb);  <span class="comment">//四参数，前两个未知</span></span><br></pre></td></tr></table></figure>



<h3 id="SWI"><a href="#SWI" class="headerlink" title="SWI"></a>SWI</h3><ul>
<li>一般伴随着硬件中断的发生而发生，以便最灵活地处理中断事务</li>
<li>优先级共16级：0-15</li>
<li>寄存器的保护/恢复由SYS/BIOS系统自动处理</li>
<li>单堆栈模式：增加优先级将增加堆栈的开销</li>
</ul>
<ul>
<li>【与任务的处理方式不同，SWI在单个堆栈上运行，同时兼具优点与局限性，能使SWI以非常低的内存消耗来运行，但也不允许他们被挂起（即SWI必须运行到结束）】</li>
<li>【SWI通常由HWI调用，系统产生了一个外设的中断，从而触发了HWI线程，而HWI处理的都是需要紧急实时响应的事务，HWI线程需要尽可能快速处理完毕，并且处理HWI时会屏蔽其他中断，因此为了让HWI处理尽可能少的操作，一些不太需要紧急实时处理的任务会放到SWI中处理。】</li>
<li>【因此当HWI将中断发布到SWI时，SWI会立即处理】</li>
<li>【HWI通常是突发而紧急的，SWI通常较为灵活、常态而平稳】</li>
<li>【HWI通常以微秒计时，SWI通常以毫秒计时】</li>
<li>【HWI和SWI都只会运行一次，不管该线程在运行前被发布了多少次】</li>
<li>【具有相同优先级的两个SWI线程不会抢占对方，会以FIFO的方式先后运行两个线程，即使第二个线程已经被发布，但直到第一个线程运行完毕，第二个线程都在持续等待】</li>
<li>【如果使用ISR来发布更高优先级的SWI，或者说在使用ISR时发布SWI，则可能使得SWI立即抢占ISR的线程，造成数据丢失，BIOS更推荐使用HWI来发布SWI】</li>
<li>【同一个SWI线程不论在运行前被发布了多少次，都只会运行一次】</li>
</ul>
<table>
<thead>
<tr>
<th>API</th>
<th>Allows you to :</th>
</tr>
</thead>
<tbody><tr>
<td>Swi_inc()</td>
<td>知道SWI在运行前被发布了多少次——N：自加计数</td>
</tr>
<tr>
<td>Swi_dec()</td>
<td>需要发布N次SWI，才能运行SWI——N：自减计数</td>
</tr>
<tr>
<td>Swi_or()</td>
<td>在发布发出一个有用的信号——签名</td>
</tr>
<tr>
<td>Swi_andn()</td>
<td>只有在所需要的发布都已经发布后才会发布</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>Bitmask</th>
<th>Counter</th>
<th>Not Used</th>
</tr>
</thead>
<tbody><tr>
<td>无条件发布</td>
<td>Swi_or()</td>
<td>Swi_inc()</td>
<td>Swi_post()</td>
</tr>
<tr>
<td>仅在触发值为0时发布</td>
<td>Swi_andn()</td>
<td>Swi_dec()</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>If trigger value is needed by the Swi, use <code>Swi_getTrigger()</code> which returns the value of the trigger when the Swi function starts running.</li>
<li>After each posting, the trigger is reset to the initial condition specified in the Swi object.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Swi_Params swiParams;</span><br><span class="line">Swi_Handle mySwi;</span><br><span class="line">Error_Block eb;    <span class="comment">//创建错误块结构体实例</span></span><br><span class="line"></span><br><span class="line">Swi_Params_init(&amp;swiParams);</span><br><span class="line">swiParams.priority = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">Error_init(&amp;eb);   <span class="comment">//初始化错误块结构体</span></span><br><span class="line"></span><br><span class="line">mySwi = Swi_create(swiFunc, &amp;swiParams, &amp;eb);    <span class="comment">//三参数</span></span><br></pre></td></tr></table></figure>



<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><h4 id="SYS-BIOS-TASK"><a href="#SYS-BIOS-TASK" class="headerlink" title="SYS/BIOS-TASK"></a>SYS/BIOS-TASK</h4><p><strong>任务创建函数原型Task_create(Task_FuncPtr, Const*, Error_Block*)</strong></p>
<p><strong>注意：</strong>要与 <code>TaskCreate(void*(), char*, int, uint, UINT32, UINT32, UINT32)</code>; 做区分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Task_create(Task_FuncPtr fxn,</span><br><span class="line">            <span class="keyword">const</span> Task_Params *params, </span><br><span class="line">            Error_Block *eb);</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Task_Params taskParams;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create task with priority 15 </span></span><br><span class="line">Task_Params_init(&amp;taskParams);</span><br><span class="line">taskParams.stackSize = <span class="number">512</span>;</span><br><span class="line">taskParams.priority = <span class="number">15</span>;</span><br><span class="line">Task_create((Task_FuncPtr)myFxn, &amp;taskParams, &amp;eb);</span><br></pre></td></tr></table></figure>

<p><strong>任务特性</strong></p>
<ul>
<li>任务调度使用更先进的调度技术 <ul>
<li>每个任务在创建时都会设立独立堆栈，任务访问共享资源时可能会因为等待而被挂起</li>
<li>任务会被其他更高优先级的线程打断（SWI、HWI），HWI 及 SWI不可挂起（SWI是需要退出和返回）；</li>
</ul>
</li>
<li>任务的数量、状态及优先级都可以在程序执行时动态改变</li>
<li>【两个任务可以调用同一函数（主要该函数是可以重入？的函数），即该函数在执行完毕之前可被安全地二次调用，任务在调用函数时可携带参数，使函数知晓是被哪个实例调用】</li>
</ul>
<p><strong>任务间时间切片。</strong></p>
<blockquote>
<p>任务在正常情况下是个看似 “无限循环” 的进程，只有在整个系统停止后才会结束；但在未被挂起的情况下，任务在被CPU分时间调度的过程中，任务会重新从头开始运行，即不会停留在上一次的位置。任务看似一次被执行就一直被无限调度，实际上是在时间分片中快速切换。</p>
</blockquote>
<p><strong>任务与Semaphore。</strong></p>
<blockquote>
<p>在使用Semaphore作为同步方式的任务调度中，如果一个任务等级较高，且 <code>Semaphore_pend()</code> 时，设置了第二个参数为 <code>BIOS_NO_WAIT</code> ，即该任务会被立即循环执行。如果参数设置为  <code>BIOS_WAIT_FOREVER</code> ，则该程序将会一直等待，直到它的信号量被post出来。</p>
<p style="font-style: italic; color: #ccc;">原文：A timeout value of BIOS_WAIT_FOREVER causes the task to wait indefinitely for its semaphore to be posted. A timeout value of BIOS_NO_WAIT causes Semaphore_pend to return immediately.</p>

<p><strong>注意</strong>：互相形成依赖的任务（如嵌套）不要用同一个信号量，会发生冲突、堆栈溢出或死锁等现象。尽量一个任务关联一个信号量。</p>
</blockquote>
<p><strong>注意：</strong>如果有堆栈溢出，应优先检查task和semaphore的初始化情况。</p>
<table>
<thead>
<tr>
<th>Functions</th>
<th>explaination</th>
</tr>
</thead>
<tbody><tr>
<td><code>Task_construct (Task_Struct *structP, Task_FuncPtr fxn, const Task_Params *params, Error_Block *eb);</code></td>
<td>// <em><strong>Initialize</strong></em> a new instance object inside the provided  structure <br />在提供的结构中<strong>创建</strong>一个新的实体对象</td>
</tr>
<tr>
<td><code>Task_create(Task_FuncPtr fxn, const Task_Params *params, Error_Block *eb);</code></td>
<td>// <em><strong>Allocate and initialize</strong></em> a new instance object and return its handle<br />开辟内存并初始化一个新的实体对象并返回其句柄</td>
</tr>
<tr>
<td><code>Task_delete(Task_Handle *handleP);</code></td>
<td>// <em><strong>Finalize and free</strong></em> this previously allocated instance object, setting the referenced handle to NULL<br />终结一个已存在的实体对象，并释放内存，设置其句柄为空</td>
</tr>
<tr>
<td><code>Task_destruct(Task_Struct *structP);</code></td>
<td>// Finalize the instance object inside the provided structure<br />在提供的结构中<strong>创建</strong>一个新的实体对象</td>
</tr>
<tr>
<td><code>Task_disable();</code></td>
<td>// Disable the task scheduler<br />使任务（列表）功能关闭</td>
</tr>
<tr>
<td><code>Task_exit();</code></td>
<td>// 5Terminate execution of the current task<br />终结现在正在运行的任务</td>
</tr>
<tr>
<td><code>Task_getEnv(Task_Handle handle);</code></td>
<td>// Get task environment pointer<br />获取任务环境指针</td>
</tr>
<tr>
<td><code>Task_getIdleTask();</code></td>
<td>// returns a handle to idle task object<br />返回一个句柄给空闲任务对象</td>
</tr>
<tr>
<td><code>Task_getMode(Task_Handle handle);</code></td>
<td>// Retrieve the Mode of a task<br />获取任务的句柄</td>
</tr>
<tr>
<td><code>Task_getPri(Task_Handle handle);</code></td>
<td>// Get task priority<br />获取任务的优先级</td>
</tr>
<tr>
<td><code>Task_Params_init(Task_Params *params);</code></td>
<td>// Initialize this config-params structure with supplier-specified defaults before instance creation<br />在实例创建前使用指定默认值初始化配置参数结构</td>
</tr>
<tr>
<td><code>Task_restore(UInt key);</code></td>
<td>// Restore Task scheduling state储存任务调度状态</td>
</tr>
<tr>
<td><code>Task_self();</code></td>
<td>// Returns a handle to the currently executing Task object<br />返回一个句柄给当前执行中的任务对象</td>
</tr>
<tr>
<td><code>Task_selfMacro();</code></td>
<td>// Returns a handle to the currently executing Task object<br />返回一个句柄给当前执行中的任务对象</td>
</tr>
<tr>
<td><code>Task_setEnv(Task_Handle handle, Ptr env);</code></td>
<td>// Set task environment<br />设置任务环境</td>
</tr>
<tr>
<td><code>Task_setHookContext(Task_Handle handle, Int id, Ptr hookContext);</code></td>
<td>// Set hook instance’s context for a task<br />为任务设置hook实例的</td>
</tr>
<tr>
<td><code>Task_setPri(Task_Handle handle, Int newpri);</code></td>
<td>// Set a task’s priority<br />设置任务优先级</td>
</tr>
<tr>
<td><code>Task_sleep(UInt nticks);</code></td>
<td>// Delay execution of the current task<br />延迟当前任务的执行时间</td>
</tr>
<tr>
<td><code>Task_stat(Task_Handle handle, Task_Stat *statbuf);</code></td>
<td>// Retrieve the status of a task<br />获取任务状态</td>
</tr>
<tr>
<td><code>Task_yield();</code></td>
<td>// Yield processor to equal priority task<br />在两个相同等级的任务间切换处理器使用权<br />同等级任务切换函数</td>
</tr>
</tbody></table>
<h5 id="任务测试"><a href="#任务测试" class="headerlink" title="任务测试"></a>任务测试</h5><table>
<thead>
<tr>
<th></th>
<th>priority</th>
<th>task_yield()</th>
<th>ISR Post Sem</th>
<th>任务内任务</th>
<th>是否执行</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>更高</td>
<td>存在</td>
<td>存在</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td></td>
<td>相同</td>
<td>存在</td>
<td>存在</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>Table 3-1. Comparison of Thread Characteristics</strong></p>
<table>
<thead>
<tr>
<th><strong>Characteristic</strong></th>
<th><strong>Hwi</strong></th>
<th><strong>Swi</strong></th>
<th><strong>Task</strong></th>
<th><strong>Idle</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Priority</strong></td>
<td>Highest</td>
<td>2nd Highest</td>
<td>2nd lowest</td>
<td>Lowest</td>
</tr>
<tr>
<td><strong>Number of priority levels</strong></td>
<td>family/device-specific</td>
<td>Up to 32; Periodic functions run at the priority of the Clock Swi.</td>
<td>Up to 32; This includes 1 for the Idle Loop.</td>
<td>1</td>
</tr>
<tr>
<td><strong>Can yield and pend</strong></td>
<td>No, runs to completion except for preemption</td>
<td>No, runs to completion except for preemption</td>
<td>Yes</td>
<td>Should not pend. <em><strong>Pending would disable all registered Idle threads.</strong></em></td>
</tr>
<tr>
<td><strong>Execution states</strong></td>
<td>Inactive, ready, running</td>
<td>Inactive, ready, running</td>
<td>Ready, running, blocked, terminated</td>
<td>Ready, running</td>
</tr>
<tr>
<td><strong>Thread scheduler disabled by</strong></td>
<td><code>Hwi_disable()</code></td>
<td><code>Swi_disable()</code></td>
<td><code>Task_disable()</code></td>
<td>Program exit</td>
</tr>
<tr>
<td><strong>Posted or made ready to run by</strong></td>
<td>Interrupt occurs</td>
<td><code>Swi_post()</code> , <code>Swi_andn()</code> , <code>Swi_dec()</code> , <code>Swi_inc()</code> , <code>Swi_or()</code></td>
<td><code>Task_create()</code> and various task synchronization mechanisms <em>(Event, Semaphore, Mailbox)</em></td>
<td><code>main()</code> exits and no other thread is currently running</td>
</tr>
<tr>
<td><strong>Stack used</strong></td>
<td>System stack (1 per program)</td>
<td>System stack (1 per program)</td>
<td>Task stack (1 per program)</td>
<td><strong>Task stack used by default</strong></td>
</tr>
<tr>
<td><strong>Context saved when preempts other thread</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Context saved when blocked</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>share data with thread via</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Synchronize with thread via</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Function hooks</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Static creation</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Dynamic creation</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Dynamically change priority</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Implicit logging</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Implicit statistics</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="OSIF-TASK"><a href="#OSIF-TASK" class="headerlink" title="OSIF-TASK"></a>OSIF-TASK</h4><p><code>&lt;osif.h&gt;</code> 文件提供系统级接口函数，与SYS/BIOS提供的相似任务函数具有不一样的函数定义。所有任务相关函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下功能可能需要被链接或移植</span></span><br><span class="line"><span class="function">_extern <span class="keyword">void</span>   <span class="title">TaskBlock</span><span class="params">(HANDLE h)</span></span>;</span><br><span class="line"><span class="function">_extern HANDLE <span class="title">TaskCreate</span><span class="params">( <span class="keyword">void</span>(*pFun)(), <span class="keyword">char</span> *Name, <span class="keyword">int</span> Priority, uint StackSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          UINT32 Arg1, UINT32 Arg2, UINT32 Arg3 )</span></span>;</span><br><span class="line"><span class="function">_extern <span class="keyword">void</span>   <span class="title">TaskDestroy</span><span class="params">( HANDLE h )</span></span>;</span><br><span class="line"><span class="function">_extern <span class="keyword">void</span>   <span class="title">TaskExit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">_extern HANDLE <span class="title">TaskGetEnv</span><span class="params">( HANDLE h, <span class="keyword">int</span> Slot )</span></span>;</span><br><span class="line"><span class="function">_extern <span class="keyword">int</span>    <span class="title">TaskGetPri</span><span class="params">(HANDLE h)</span></span>;</span><br><span class="line"><span class="function">_extern HANDLE <span class="title">TaskSelf</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">_extern <span class="keyword">void</span>   <span class="title">TaskSetEnv</span><span class="params">( HANDLE h, <span class="keyword">int</span> Slot, HANDLE hEnv )</span></span>;</span><br><span class="line"><span class="function">_extern <span class="keyword">int</span>    <span class="title">TaskSetPri</span><span class="params">(HANDLE h, <span class="keyword">int</span> priority)</span></span>;</span><br><span class="line"><span class="function">_extern <span class="keyword">void</span>   <span class="title">TaskSleep</span><span class="params">(UINT32 delay)</span></span>;</span><br><span class="line"><span class="function">_extern <span class="keyword">void</span>   <span class="title">TaskYield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>**任务创建函数 TaskCreate(void*(), char*, int, uint, UINT32, UINT32, UINT32); **</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_extern HANDLE <span class="title">TaskCreate</span><span class="params">( <span class="keyword">void</span>(*pFun)(), <span class="keyword">char</span> *Name, <span class="keyword">int</span> Priority, uint StackSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          UINT32 Arg1, UINT32 Arg2, UINT32 Arg3 )</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>TaskCreate();</code> 的使用方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( <span class="keyword">void</span> ) TaskCreate ( TCP_Perform_Server , <span class="string">&quot;TCPBenchmarkRX&quot;</span> , OS_TASKPRIHIGH , <span class="number">0x1400</span> , <span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> );</span><br></pre></td></tr></table></figure>

<p>关于任务优先级Priority的定义存在同一头文件中，具体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Equates used in code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBG_PRINT_LEVEL         (_oscfg.DbgPrintLevel)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBG_ABORT_LEVEL         (_oscfg.DbgAbortLevel)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_TASKPRILOW           (_oscfg.TaskPriLow)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_TASKPRINORM          (_oscfg.TaskPriNorm)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_TASKPRIHIGH          (_oscfg.TaskPriHigh)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_TASKPRIKERN          (_oscfg.TaskPriKern)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_TASKSTKLOW           (_oscfg.TaskStkLow)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_TASKSTKNORM          (_oscfg.TaskStkNorm)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_TASKSTKHIGH          (_oscfg.TaskStkHigh)</span></span><br></pre></td></tr></table></figure>





<p>以下出自 <em><strong>&lt;spru523h.pdf&gt;</strong></em>  <em>Chapter 3.3 Creating a Task</em></p>
<blockquote>
<p>The process of creating a sockets application begins with the creation of a SYS/BIOS Task thread. You can use XGCONF to statically configure Tasks or use the standard SYS/BIOS API or the provided Task abstraction to dynamically create Tasks. For example, the following C code creates a basic Task:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Task_Params taskParams;</span><br><span class="line">Task_Handle hMyTask;</span><br><span class="line">Error_Block eb;</span><br><span class="line">Error_init(&amp;eb);</span><br><span class="line"></span><br><span class="line">Task_Params_init(&amp;taskParams);</span><br><span class="line">taskParams.stackSize = <span class="number">4096</span>;</span><br><span class="line">taskParams.priority = <span class="number">5</span>;             <span class="comment">/* Create a Task with priority 5 */</span></span><br><span class="line">hMyTask = Task_create((Task_FuncPtr)entrypoint, &amp;taskParams, &amp;eb);</span><br><span class="line"><span class="keyword">if</span> (hMyTask == <span class="literal">NULL</span>) &#123;</span><br><span class="line">System_abort(<span class="string">&quot;Task create failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The same Task can be created via the <code>TaskCreate()</code>  function in the Task abstraction API. The abstracted function is a little more restrictive. It creates a Task thread with exactly 3 parameters (they do not all have to be used). For example, the following call would create a Task similar to that shown above: </p>
<p><code>hMyTask = TaskCreate( entrypoint, &quot;TaskName&quot;, OS_TASKPRINORM, stacksize, arg1, arg2, arg3 );</code></p>
<p>In both cases, <code>hMyTask</code> is a handle to a SYS/BIOS Task thread.</p>
</blockquote>
<h3 id="Synchronization"><a href="#Synchronization" class="headerlink" title="Synchronization"></a>Synchronization</h3><p>SYS/BIOS内的同步类型分为 <strong>进程同步</strong> 和 <strong>核同步</strong> ；同步方式共5种：<strong>Semaphore</strong>(信号量) / <strong>Event</strong>(事件) / <strong>Gate</strong>(门) / <strong>Mailbox</strong>(邮箱) / <strong>Queue</strong>(队列)</p>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>信号量可分为 <strong>互斥型</strong> 和 <strong>计数型</strong> 两种。</p>
<p><strong>互斥型信号量</strong></p>
<blockquote>
<p>也称为为互斥量、二进制型信号量。可以理解为只能维护资源数量为1的二值计数信号量（值为0或1），但是互斥信号量又不同于计数信号量，因为它还具有 <strong>优先级继承</strong> 的机制。</p>
<p>优先级继承机制是RTOS中为了避免出现 <strong>优先级翻转</strong> 问题而做的处理方式。简单来说就是如果低优先级持有互斥信号量那么高优先级任务想访问互斥量就会失败而挂起等待互斥量被释放，此时反而是低优先级任务在运行，这就出现了优先级翻转。为了避免该情况RTOS处理方式是把正在持有互斥量运行的低优先级任务的优先级提高到与等待访问互斥资源的高优先级任务同等优先级，这就是优先级继承。等互斥量被释放后RTOS会将该任务恢复到之前的低优先级。</p>
</blockquote>
<p><strong>特性：</strong></p>
<ul>
<li><p>信号量是指系统当前可用资源的数值，当资源超过1时，为 <code>计数型信号量</code> ；当资源仅为1和0时，为 <code>二进制型信号量</code>；因为资源总为1及以上，因此不论是计数型还是二进制型，可用的信号量始终≥0。</p>
</li>
<li><p>信号量用于标识和实现任务的 <code>挂起</code> 和 <code>发布</code></p>
<ul>
<li><strong>发布</strong> 指任务正在处于结束状态，<code>Semaphore_post()</code> 将使信号量递增</li>
<li><strong>挂起</strong> 指任务正在处于运行状态，<code>Semaphore_pend()</code> 将使信号量递减</li>
<li>使用 <code>Semaphore_pend()</code> 以使用资源，使用 <code>Semaphore_post()</code> 以离开资源</li>
</ul>
</li>
<li><p>计数型信号量用来进行多任务管理</p>
<ul>
<li><code>多任务信号量</code>的初始值将为可同时进行任务的最大值</li>
<li>当达到最大可运行任务量时，信号量值为0，即信号阻塞</li>
</ul>
</li>
<li><p>当信号量为0时，即系统资源被占满，如果此时出现最高优先级任务，系统将抢断低优先级任务从而使高优先级任务进行工作</p>
</li>
</ul>
<p><strong>任务与调用任务</strong></p>
<blockquote>
<p>在调用任务时，不需要特意调高被调用任务的等级。</p>
<p>在被调用任务的等级等于本任务时，使用<code>Semaphore_post();</code> 并使用 <code>task_yeild();</code> ，即可顺利将任务切换到被调用任务。(如下 <strong>SEM-1</strong> 示)</p>
<p>在被调用任务的等级低于本任务时，使用 <code>Semaphore_post();</code> 并使用 <code>task_sleep();</code> ，即可让低等级任务在本任务休眠期间执行。(如下 <strong>SEM-2</strong> 示)</p>
</blockquote>
<p><strong>SEM-1</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_core0TCPService</span><span class="params">(UArg a0, UArg a1)</span> </span>&#123;                                      <span class="comment">//Core0执行TCP信息接收任务</span></span><br><span class="line">    <span class="keyword">short</span> rx_length = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Semaphore_pend( sem0_TcpReceive, BIOS_WAIT_FOREVER );</span><br><span class="line">        TcpReceive(ReceiveBuffer, RECEIVEBUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span>(rx_length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ReceiveBufferTemp[<span class="number">0</span>]==<span class="number">0xf5</span>)&#123;</span><br><span class="line">                <span class="keyword">switch</span>(ReceiveBufferTemp[<span class="number">2</span>])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x01</span>:</span><br><span class="line">                    <span class="keyword">if</span>(ReceiveBufferTemp[<span class="number">3</span>] == <span class="number">0x01</span>)&#123;                                                     </span><br><span class="line">                        Semaphore_post(sem0_ad);                    <span class="comment">//post同等级任务的信号量</span></span><br><span class="line">                        Task_yield();                               <span class="comment">//调用任务切换函数</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_core0AdcRead</span><span class="params">(UArg a0, UArg a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;                                                                                               </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Semaphore_pend(sem0_ad,BIOS_WAIT_FOREVER);</span><br><span class="line">        <span class="keyword">while</span>(ADC_Cnt &lt;= ADC_MICROSECOND)&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Int <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Task_Handle task;                                              <span class="comment">//创建空任务句柄</span></span><br><span class="line">    Task_Params param;                                             <span class="comment">//创建空任务参数</span></span><br><span class="line">    Error_Block eb;                                                <span class="comment">//创建空错误块</span></span><br><span class="line">	Error_init(&amp;eb);                                               <span class="comment">//初始化错误块参数</span></span><br><span class="line">    Task_Params_init(&amp;param);                                      <span class="comment">//初始化任务参数</span></span><br><span class="line">    uart_init();                                                   <span class="comment">//串口初始化</span></span><br><span class="line">    uart_set_baudrate(<span class="number">115200</span>);                                     <span class="comment">//设置波特率</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(CSL_chipReadDNUM() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	SemInit_Core0();                                            <span class="comment">//配置semaphore，sem0_ad,sem0_da</span></span><br><span class="line">    	FanLed_Init();                                              <span class="comment">//点亮LED3，开启FAN</span></span><br><span class="line">    	Sgmii_Init();                                               <span class="comment">//外设初始化</span></span><br><span class="line">        ADS8568_Init();                   <span class="comment">//INT6</span></span><br><span class="line">        DAC8565_Init();                   <span class="comment">//INT7</span></span><br><span class="line">    	Timer3_Init();                    <span class="comment">//INT4</span></span><br><span class="line"></span><br><span class="line">        task = Task_create(task_core0Init, &amp;param, &amp;eb);</span><br><span class="line">        TaskSuccess(&amp;task,<span class="string">&quot;任务创建失败：task_core0Init\n&quot;</span>); </span><br><span class="line"></span><br><span class="line">        param.priority=<span class="number">10</span>;</span><br><span class="line">        task = Task_create(task_core0TCPService, &amp;param, &amp;eb); </span><br><span class="line">        TaskSuccess(&amp;task,<span class="string">&quot;任务创建失败：task_core0TCPListenAndReceive!\n&quot;</span>); </span><br><span class="line"></span><br><span class="line">        param.priority = <span class="number">10</span>;</span><br><span class="line">        task = Task_create(task_core0AdcRead, &amp;param, &amp;eb);           <span class="comment">//读取AD任务</span></span><br><span class="line">        TaskSuccess(&amp;task,<span class="string">&quot;任务创建失败：task_core0AdcRead\n&quot;</span>);                 </span><br><span class="line">    &#125;</span><br><span class="line">    BIOS_start();</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>SEM-2</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">lowPriTask</span><span class="params">(UArg arg0, UArg arg1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		Semaphore_pend(mySem, BIOS_WAIT_FOREVER); <span class="comment">//挂起任务</span></span><br><span class="line">		resource += <span class="number">1</span>;                  <span class="comment">//do work on locked resource</span></span><br><span class="line">		Semaphore_post(mySem);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Void <span class="title">hiPriTask</span><span class="params">(UArg arg0, UArg arg1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		Semaphore_pend(mySem, BIOS_WAIT_FOREVER);</span><br><span class="line">		resource += <span class="number">1</span>;                  <span class="comment">//do work on locked resource</span></span><br><span class="line">		Semaphore_post(mySem);</span><br><span class="line">		Task_sleep(<span class="number">5</span>);                 <span class="comment">//allow low pri taks to work</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>任务与信号量之间的关系？</strong></p>
<ul>
<li><p>任务的顺利执行，需要经过 <strong>任务新建</strong>、<strong>信号量新建</strong>、<strong>信号量阻塞</strong> 和 <strong>信号量发布</strong> 四个流程。任务不是在被发布后就立即执行的，他需要等待信号量的到来。</p>
</li>
<li><p>先pend后post，即任务执行必须由对应的信号量进行排队（阻塞）和准备（发布），如果其中任何一个步骤缺省都无法执行任务。</p>
</li>
<li><p>pend要在该任务被执行时使用，放置在任务最开始的一句话中；post可以放置在别的任务或 <strong>IRS</strong> 中断里，由别的任务或函数来启动本任务。</p>
</li>
<li><p>信号量使用须统一为计数型或二进制型？</p>
</li>
</ul>
<h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><h2 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h2><h3 id="EMAC"><a href="#EMAC" class="headerlink" title="EMAC"></a>EMAC</h3><p>EMAC驱动程序提供了一个定义良好的API层，允许应用程序使用EMAC外设来控制从处理器到PHY的数据包数据流，并使用MDIO模块来控制PHY配置和状态监控。</p>
<p>EMAC驱动程序的设计要求如下:</p>
<ul>
<li>每个核支持多个EMAC端口(如果设备上可用)。</li>
<li>每个核支持多个通道/MAC地址。</li>
<li>支持多个内核在同一个EMAC端口上使用不同的通道。</li>
<li>驱动程序是独立于操作系统的，通过OSAL操作系统层暴露所有的操作系统callout。</li>
<li>EMAC示例测试应用程序提供了标准配置，并演示了可度量的基准测试。</li>
</ul>
<p>EMAC驱动程序的架构图如下:</p>
<img src="https://liewpicturestorage-20210408-1251513394.cos.ap-guangzhou.myqcloud.com/2021/04/wps1.png" alt="img" style="zoom:67%;" />

<p><strong>1.EMAC设备驱动程序</strong></p>
<p>设备驱动程序公开了一组定义良好的API，应用层使用它通过EMAC外围设备发送和接收数据包，并通过MDIO外围设备配置和监视PHY。驱动程序还公开了一组定义良好的操作系统抽象API，用于确保驱动程序是操作系统独立的和可移植的。EMAC驱动程序对所有EMAC MMR访问使用CSL EMAC功能层。</p>
<p><strong>2.应用程序代码</strong></p>
<p>这是EMAC驱动程序的用户，它与驱动程序的接口是通过定义良好的API集实现的。应用程序用户使用EMAC驱动程序API通过EMAC外围设备发送和接收数据包。</p>
<p><strong>3.操作系统抽象层</strong></p>
<p>EMAC LLD是独立于操作系统的，并通过这个层公开所有的操作系统调出。</p>
<p><strong>4.CSL功能层</strong></p>
<p>EMAC驱动程序使用CSL EMAC功能层通过访问MMR来对设备IP进行编程。</p>
<p><strong>5.注册层</strong></p>
<p>寄存器层是由IP所有者生成的IP块内存映射寄存器。EMAC驱动程序不直接访问MMR寄存器，而是使用EMAC CSL功能层实现这个目的。</p>
<h3 id="SOCKET"><a href="#SOCKET" class="headerlink" title="SOCKET"></a>SOCKET</h3><p>在C++/MFC中有Window Socket，作为TCP/UDP数据传输的接口工具。</p>
<p>在C#/WPF中也有Socket，作用同上。</p>
<p>在C++/TI.SYSBIOS的NDK套件中也有Socket作为沟通套接的工具。</p>
<p>TI.SYSBIOS的NDK套件中，常用的函数如下：</p>
<p><strong>NDK_accept()</strong> </p>
<blockquote>
<p>Accept a connection on a socket</p>
<p><code>SOCKET NDK_accept(SOCKET s, struct sockaddr *pName, int *plen);</code></p>
</blockquote>
<p><strong>NDK_bind</strong>() </p>
<blockquote>
<p>Bind a name to a socket</p>
<p><code>int NDK_bind(SOCKET s, struct sockaddr *pName, int len);</code></p>
</blockquote>
<p><strong>NDK_connect</strong>() </p>
<blockquote>
<p>Initiate a connection on a socket</p>
<p><code>int NDK_connect(SOCKET s, struct sockaddr *pName, int len);</code></p>
</blockquote>
<p><strong>NDK_getpeername()</strong> </p>
<blockquote>
<p>Return name (address) of connected peer</p>
<p><code>int NDK_getpeername(SOCKET s, struct sockaddr *pName, int *plen);</code></p>
</blockquote>
<p><strong>NDK_getsockname()</strong> </p>
<blockquote>
<p>Return the local name (address) of the socket</p>
<p><code>int NDK_getsockname(SOCKET s, struct sockaddr *pName, int *plen);</code></p>
</blockquote>
<p><em><strong>NDK_getsockopt()</strong></em> </p>
<blockquote>
<p>Get the value of a socket option</p>
<p><code>int NDK_getsockopt(SOCKET s, int level, int op, void *pbuf, int *pbufsize);</code></p>
</blockquote>
<p><strong>NDK_listen</strong>() </p>
<blockquote>
<p>Listen for connection requests on a socket</p>
<p><code>int NDK_listen(SOCKET s, int maxcon);</code></p>
</blockquote>
<p><strong>NDK_recv()</strong> </p>
<blockquote>
<p>Receive data from a socket</p>
<p><code>int NDK_recv(SOCKET s, void *pbuf, int size, int flags);</code></p>
</blockquote>
<p><strong>NDK_recvfrom()</strong> </p>
<blockquote>
<p>Receive data from a socket with the senders name (address)</p>
<p><code>int NDK_recvfrom(SOCKET s, void *pbuf, int size, int flags, struct sockaddr *pName, int *plen);</code></p>
</blockquote>
<p><strong>NDK_send()</strong> </p>
<blockquote>
<p>Send data to a connected socket</p>
<p><code>int NDK_send(SOCKET s, void *pbuf, int size, int flags);</code></p>
</blockquote>
<p><strong>NDK_sendto()</strong> </p>
<blockquote>
<p>Send data to a specified destination on an unconnected socket</p>
<p><code>int NDK_sendto(SOCKET s, void *pbuf, int size, int flags, struct sockaddr *pName, int len);</code></p>
</blockquote>
<p><strong>NDK_setsockopt()</strong> </p>
<blockquote>
<p>Set the value of a socket option</p>
<p><code>int NDK_setsockopt(SOCKET s, int level, int op, void *pbuf, int bufsize);</code></p>
</blockquote>
<p><strong>NDK_shutdown</strong>() </p>
<blockquote>
<p>Close one half of a socket connection</p>
<p><code>int NDK_shutdown(SOCKET s, int how)</code></p>
</blockquote>
<p><strong>NDK_socket</strong>() </p>
<blockquote>
<p>Create a socket</p>
<p><code>SOCKET NDK_socket(int domain, int type, int protocol);</code></p>
</blockquote>
<p><strong>NDK_socketpair()</strong> </p>
<blockquote>
<p>Create socket pair. Redundant; see Section 3.5, <em>Full Duplex Pipes</em> <em>Programming Interface</em>.</p>
</blockquote>
<blockquote>
<p>The domain parameter specifies a communications domain within which communication will take place;<br>域参数指定通信将在其中发生的通信域;</p>
</blockquote>
<h1 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h1><p><strong>EMAC</strong></p>
<blockquote>
<p>Ethernet Media Access Controller</p>
</blockquote>
<p><strong>MDIO</strong></p>
<blockquote>
<p>Management Data Input/Output</p>
</blockquote>
<p><strong>PHY</strong></p>
<blockquote>
<p>Physical Layer</p>
</blockquote>
<p><strong>Purpose of the Peripheral</strong></p>
<blockquote>
<p>The EMAC module is used on the device to move data between the device and another host connected to the same network, in compliance with the Ethernet protocol.</p>
</blockquote>
<p><strong>PLL</strong></p>
<blockquote>
<p><strong>Phase-Locked Loop 锁相环</strong> </p>
<p>**锁相环路 **是一种反馈控制电路，简称锁相环。</p>
<p><strong>锁相环</strong> 的特点是：利用外部输入的参考信号控制环路内部振荡信号的频率和相位。因锁相环可以实现输出信号频率对输入信号频率的自动跟踪，所以锁相环通常用于闭环跟踪电路。</p>
<p>锁相环在工作的过程中，当输出信号的频率与输入信号的频率相等时，输出电压与输入电压保持固定的相位差值，即输出电压与输入电压的相位被锁住，这就是锁相环名称的由来。</p>
<p>锁相环通常由<strong>鉴相器</strong>（PD,Phase Detector）、<strong>环路滤波器</strong>（LF,Loop Filter）和 <strong>压控振荡器</strong>（VCO,Voltage Controlled Oscillator）三部分组成。</p>
</blockquote>
<p><strong>MII</strong></p>
<blockquote>
<p>以太网媒体接口有：MII、RMII、SMII、GMII </p>
<p><strong>Media Independent Interface</strong></p>
<p>称为 <strong>介质无关接口</strong> 或 <strong>媒体独立接口</strong>，它是 <strong>IEEE-802.3</strong> 定义的以太网行业标准。</p>
<ul>
<li>它包括一个 <strong>数据接口</strong> 和一个 <strong>MAC</strong> 和 <strong>PHY</strong> 之间的管理接口。<strong>数据接口</strong> 包括分别用于 <strong>发送器</strong> 和 <strong>接收器</strong> 的两条独立信道，每条信道都有自己的 数据、时钟 和 控制信号 。MII数据接口总共需要16个信号。</li>
<li>管理接口是个双信号接口：一个是时钟信号，另一个是数据信号。通过管理接口，上层能监视和控制PHY。</li>
<li>MII标准接口用于连接 <strong>Fast Ethernet MAC-block</strong> 与 <strong>PHY</strong>。表明在不对MAC硬件重新设计或替换的情况下，任何类型的PHY设备都可以正常工作。</li>
<li>在其他速率下工作的与MII等效的接口有：<strong>AUI</strong>（10M　以太网）、<strong>GMII</strong>（Gigabyte　以太网）和<strong>XAUI</strong>（10-Gigabit　以太网）。</li>
<li>MII支持10兆和100兆的操作，一个接口由14根线组成，它的支持还是比较灵活的，但是有一个<strong>缺点是因为它一个端口用的信号线太多</strong>，如果一个8端口的交换机要用到112根线，16端口就要用到224根线，到32端口的话就要用到448根线，一般按照这个接口做交换机，是不太现实的，所以现代的交换机的制作都会用到由MII简化而来的标准，如 <strong>RMII</strong>、<strong>SMII</strong>、<strong>GMII</strong> 等。<ul>
<li>RMII（Reduced MII）是简化的MII接口，在数据的收发上它比MII接口少了一倍的信号线，所以它一般要求是50兆的总线时钟。RMII一般用在多端口的交换机，它不是每个端口安排收、发两个时钟，而是所有的数据端口公用一个时钟用于所有端口的收发，这里就节省了不少的端口数目。RMII的一个端口要求7个数据线，比MII少了一倍，所以交换机能够接入多一倍数据的端口。和MII一样，RMII支持10兆和100兆的总线接口速度。</li>
<li>SMII（Serial MII）是由思科提出的一种媒体接口，它有比RMII更少的信号线数目，S表示串行的意思。因为它只用一根信号线传送发送数据，一根信号线传输接受数据，所以在时钟上为了满足100的需求，它的时钟频率很高，达到了125兆，为什么用125兆，是因为数据线里面会传送一些控制信息。SMII一个端口仅用4根信号线完成100信号的传输，比起RMII差不多又少了一倍的信号线。SMII在工业界的支持力度是很高的。同理，所有端口的数据收发都公用同一个外部的125M时钟。</li>
<li>GMII（Gigabyte MII）是千兆网的MII接口，这个也有相应的RGMII接口，表示简化了的GMII接口。</li>
</ul>
</li>
</ul>
<p><em>MII （Management interface）只有两条信号线。</em></p>
</blockquote>
<p><strong>SGMII</strong></p>
<blockquote>
<p>Serial Gigabit Media Independent Interface</p>
</blockquote>
<p><strong>SerDes</strong></p>
<blockquote>
</blockquote>
<p><strong>ESD</strong></p>
<blockquote>
<p>Electrostatic discharge</p>
</blockquote>
<p><strong>STATS</strong></p>
<blockquote>
</blockquote>
<p><strong>SOP</strong></p>
<blockquote>
<p>Start of Packet, the first fragment of packet</p>
</blockquote>
<p><strong>EOP</strong></p>
<blockquote>
<p>End of Packet, the last fragment of packet</p>
</blockquote>
<p><strong>EOQ</strong></p>
<blockquote>
<p>end-of-queue</p>
</blockquote>
<p><strong>LSB</strong></p>
<blockquote>
<p>least-significant bit</p>
</blockquote>
<p><strong>HDP</strong></p>
<blockquote>
<p>head descriptor pointer</p>
</blockquote>
<p><strong>DMA</strong></p>
<blockquote>
</blockquote>
<p><strong>TXnHDP</strong></p>
<blockquote>
<p>Transmit Channel <em>n</em> DMA Head Descriptor Pointer Register</p>
</blockquote>
<p><strong>RXnHDP</strong></p>
<blockquote>
<p>Receive Channel <em>n</em> DMA Head Descriptor Pointer Register</p>
</blockquote>
<p><strong>Swi</strong></p>
<blockquote>
<p>Software Interrupt</p>
</blockquote>
<p><strong>Hwi</strong></p>
<blockquote>
<p>Hardware Interrupt</p>
</blockquote>
<p><strong>ISR</strong></p>
<blockquote>
<p>中断服务程序</p>
</blockquote>
<p><strong>C99</strong></p>
<blockquote>
<p><strong>C99</strong> （以前称为<strong>C9X</strong> ）是<strong>ISO / IEC 9899：1999</strong>的非正式名称，在1999年推出，被ANSI于2000年3月采用。它是C编程语言标准的过去版本。 它扩展了以前的版本（ C90 ），增加了语言和标准库的新功能，并帮助实现更好地利用可用的计算机硬件，如IEEE  754-1985浮点运算和编译器技术，最主要的增强在数值处理上。 2011年发布的C编程语言标准的C11版本取代了C99。</p>
<p>C99是在C89/90的基础上发展起来的，增加了基本数据类型、关键字和一些系统函数等。</p>
<p>C99有一部分是对于增加了宽字符集，还加入了一些库函数，是继C89标准之后的第二个C语言官方标准。第一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/C%2B%2B">C++</a>语言官方标准C++98标准，就是基于C89编写的，因此C99标准新增的语法特性在C++的编译器中就或多或少地支持了，而完全或几乎完全支持C99标准的主流编译器有：GCC 、Clang 、Intel C++ Compiler 等。另外，Visual Studio 2013也部分支持了C99语法特征 。</p>
<p>C99标准的<strong>草案</strong>是免费的 [6] </p>
</blockquote>
<p><strong>初始化列表</strong></p>
<blockquote>
<p>初始化列表是用于初始化一组（结构体）内存位置的值列表。</p>
<p>例如，假设已经声明了以下 Date 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span>&#123;</span><span class="keyword">int</span> day, month, year;&#125;;</span><br></pre></td></tr></table></figure>

<p>定义和初始化 Date 变量的方式是：先指定变量名，后接赋值运算符和初始化列表，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date birthday = &#123;<span class="number">23</span>, <span class="number">8</span>, <span class="number">1983</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>该声明定义 birthday 是一个 Date 结构体的变量，大括号内的值按顺序分配给其成员。</p>
<p>也可以仅初始化结构体变量的部分成员。例如，如果仅知道要存储的生日是8月23日， 但不知道年份，则可以按以下方式定义和初始化变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date birthday = &#123;<span class="number">23</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这里只有 day 和 month 成员被初始化，year 成员未初始化。但是，如果某个结构成员未被初始化，则所有跟在它后面的成员都需要保留为未初始化。使用初始化列表时，<a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 不提供跳过成员的方法。以下语句试图跳过 month 成员的初始化。这是不合法的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date birthday &#x3D; &#123;23,1983&#125;; &#x2F;&#x2F;非法</span><br></pre></td></tr></table></figure>

<p>还有一点很重要，不能在结构体声明中初始化结构体成员，因为结构体声明只是创建一个新的数据类型，还不存在这种类型的变量。因为<strong>结构体声明只声明一个结构体“看起来是什么样子的”，所以不会在内存中创建成员变量。</strong>只有通过定义该结构体类型的变量来实例化结构体，才有地方存储初始值。</p>
</blockquote>
<p><strong>构造函数</strong></p>
<blockquote>
<p>虽然初始化列表易于使用，但它有两个缺点：</p>
<ol>
<li>如果有某个成员未被初始化，那么在这种情况下，跟随在该成员后面的成员都不能初始化。</li>
<li>如果结构体包括任何诸如字符串之类的对象，那么在许多编译器上它都将无法运行。</li>
</ol>
<p>在这些情况下，可以使用构造函数来初始化结构体成员变量，这和初始化类成员变量是相同的。与类构造函数一样，结构体的构造函数必须是与结构体名称相同的公共成员函数，并且没有返回类型。因为默认情况下，所有结构体成员都是公开的，所以不需要使用关键字 public。</p>
<p>以下是一个名为 Employee 的结构体的声明语句，它包含一个具有两参数的构造函数，以便在创建一个 Employee 变量而不向其传递任何参数时，提供默认值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;    <span class="comment">// 员工姓名</span></span><br><span class="line">    <span class="keyword">int</span> vacationDays,    <span class="comment">// 允许的年假</span></span><br><span class="line">    daysUsed;    <span class="comment">//已使用的年假天数</span></span><br><span class="line">    Employee (<span class="built_in">string</span> n =<span class="string">&quot;&quot;</span>,<span class="keyword">int</span> d = <span class="number">0</span>)    <span class="comment">// 构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        vacationDays = <span class="number">10</span>;</span><br><span class="line">        daysUsed = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>Const in C++</strong></p>
<blockquote>
<ol>
<li><p><strong>const与#define</strong></p>
<p>两者都可以用来定义常量，但是const定义时，定义了常量的类型，所以更精确一些。</p>
<p>#define只是简单的文本替换，除了可以定义常量外，还可以用来定义一些简单的函数，有点类似内联函数(Inline)。</p>
<p>const和define定义的常量可以放在头文件里面。（小注：可以多次声明，但只能定义一次）</p>
</li>
<li><p><strong>const与指针和引用</strong></p>
<ul>
<li><p>const与指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> me;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p1 = &amp;me;<span class="comment">//p1可变，*p1不可变，此时不能用*p1来修改，但是p1可以转向</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p2 = &amp;me;<span class="comment">//p2不可变，*p2可变，此时允许*p2来修改其值，但是p2不能转向。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p3 = &amp;me;<span class="comment">//p3不可变，*p3也不可变，此时既不能用*p3来修改其值，也不能转向</span></span><br></pre></td></tr></table></figure></li>
<li><p>指针和引用的区别很简单，就是引用更简洁，更安全。因为引用声明时必须初始化。 引用更接近const指针，一旦与某个变量关联，就将一直效忠于他。</p>
</li>
<li><p><strong>const指针可以接受const和非const地址，但是非const指针只能接受非const地址</strong>。所以const指针的能力更强一些，所以尽量多用const指针，这是一种习惯。</p>
</li>
</ul>
</li>
<li><p>const与函数</p>
</li>
</ol>
<ul>
<li><p>由于2.3，所以经常把函数的形参类型设为const，而且多为<strong>const 引用</strong>。但是这里有一个限制，<strong>不能把不是左值的地址传递给引用</strong>。（左值包括变量，数组元素，结构成员，引用，被解除引用的指针等）。 形参是const类型的，说明该函数将不会修改其值，该函数便为const函数。</p>
</li>
<li><p>const与类成员函数。先看看下面这段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Stock land = Stock(<span class="string">&quot;hyd&quot;</span>);</span><br><span class="line">land.show();</span><br></pre></td></tr></table></figure>

<p>land 是常量，但是类成员函数show()无法保证不修改land，所以编译器将拒绝执行该段代码。除非你能保证show像const函数一样，但这需要另外一种语法，即：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::show</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;&#125; <span class="comment">//定义</span></span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<p><strong>内联函数</strong></p>
<blockquote>
<p>Inline Functions</p>
</blockquote>
<p><strong>超级循环</strong></p>
<blockquote>
</blockquote>
<p><strong>ANC</strong></p>
<blockquote>
</blockquote>
<p><strong>IPC</strong></p>
<blockquote>
<p>Inter-Processor Communication</p>
<p>内部处理器通信</p>
</blockquote>
<p><strong>NDK</strong></p>
<blockquote>
<p>Network Development Kit</p>
<p>网络开发套件</p>
</blockquote>
<p><strong>GPIO</strong></p>
<blockquote>
<p>General Purpose Input/Output</p>
<p>通用型之输入输出的简称，功能类似8051的P0—P3，其接脚可以供使用者由程控自由使用，PIN脚依现实考量可作为通用输入（GPI）或通用输出（GPO）或通用输入与输出（GPIO），如当clk generator, chip select等。</p>
<p>既然一个引脚可以用于输入、输出或其他特殊功能，那么一定有寄存器用来选择这些功能。对于输入，一定可以通过读取某个寄存器来确定引脚电位的高低；对于输出，一定可以通过写入某个寄存器来让这个引脚输出高电位或者低电位；对于其他特殊功能，则有另外的寄存器来控制它们。</p>
</blockquote>
<p><strong>EMIFA</strong></p>
<blockquote>
</blockquote>
<p><strong>SRIO</strong></p>
<blockquote>
<p>高速串行IO口</p>
</blockquote>
<p><strong>Hyperlink</strong></p>
<blockquote>
<p>超链接</p>
</blockquote>
<p><strong>JTAG</strong></p>
<blockquote>
</blockquote>
<p><strong>Warm reset</strong> </p>
<blockquote>
<p> 软复位</p>
</blockquote>
<p><strong>LLD</strong></p>
<blockquote>
<p>Low Level Driver</p>
</blockquote>
<p><strong>HAL</strong></p>
<blockquote>
<p>Hardware Adaption Layer硬件适应层</p>
</blockquote>
<p><strong>IGMP</strong></p>
<blockquote>
<p>Internet Group Management Protocol</p>
<p>Internet Group Management Protocol (IGMP) is designed to help routers in routing IP multicast traffic. Each router can have multiple ports, and it is inefficient for the router to replicate every IP multicast packet out of each active port. Using the IGMP protocol, the multicast router is able to keep track of which IP multicast addresses need to be routed to each individual port. This allows the router to limit IP multicast transmission to only those ports that require the multicast traffic.<br>IGMP 是用来帮助路由器路由IP组播流量的。每个路由器可以有多个端口，并且路由器从每个活动端口复制每个IP组播包是低效的。使用IGMP协议，组播路由器能够跟踪哪些IP组播地址需要被路由到每个单独的端口。这允许路由器将IP组播传输限制为仅需要组播流量的端口。</p>
<p>The IGMP protocol assumes a client/server relationship between endpoints. The IGMP server is run by the multicast router to get IP multicast information about all the client on each of its individual ports. The IGMP client is only concerned with communicating its own multicast requirements to the local IGMP server, so that it will get the IP multicast packets that it requires.<br>IGMP协议假定端点之间存在客户端/服务器关系。IGMP服务器由组播路由器运行，以获得关于每个单独端口上的所有客户端的IP组播信息。IGMP客户端只关心把它自己的组播要求传达给本地IGMP服务器，这样它就会得到它所需要的IP组播包。</p>
</blockquote>
<h1 id="Vocabulary"><a href="#Vocabulary" class="headerlink" title="Vocabulary"></a>Vocabulary</h1><ol>
<li><p>granularity n. 间隔尺寸，[岩] 粒度</p>
<blockquote>
<p>the quality of being composed of relatively large particles</p>
</blockquote>
</li>
<li><p>be patched with 用**修补</p>
<blockquote>
<p><strong>patched</strong> <em>/pætʃt/</em>  </p>
<p>adj. 打补丁的  v. 打补丁；遮盖（视力好的眼）促进弱视眼看；（用补丁对程序）改错（patch 的过去式和过去分词）</p>
</blockquote>
</li>
<li><p>an entire contiguous Ethernet packet 一个完整连续的以太网包</p>
</li>
<li><p>byte-aligned memory address 字节内存地址</p>
<blockquote>
<p><strong>aligned</strong> [əˈlaɪnd] </p>
<p>v. 结盟；支持；使成一直线；校准；安放，排列；使一致（align 的过去式和过去分词）</p>
</blockquote>
</li>
<li><p>prior <em>[ˈpraɪər]</em> adj. （时间、顺序等）先前的；优先的</p>
</li>
<li><p>indicate vt. 表明；指出；预示；象征</p>
</li>
<li><p>prologue <em>/prəʊlɒg/</em> n. 开场白</p>
</li>
<li><p>auxiliary definitions 辅助定义</p>
<blockquote>
<p><strong>auxiliary</strong> [ɔːɡˈzɪliəri] </p>
<p>adj. 辅助的；副的；附加的；（发动机、设备等）备用的</p>
</blockquote>
</li>
<li><p>static inline 静态内联</p>
</li>
<li><p>volatile unsigned int</p>
<blockquote>
<p><strong>volatile</strong> [ˈvɒlətaɪl] </p>
<p>adj. [化学] 挥发性的；不稳定的；爆炸性的；反复无常的</p>
<p>n. 挥发物；有翅的动物</p>
</blockquote>
</li>
<li><p>heap n. 信号量</p>
</li>
<li><p>explicity and implicity 显性和隐性</p>
<blockquote>
<p><strong>explicitly</strong>  [ɪkˈsplɪsɪtli]</p>
<p>adv. 明确地；明白地</p>
<p><strong>implicitly</strong>  [ɪmˈplɪsɪtli]</p>
<p>adv. 含蓄地；暗中地</p>
</blockquote>
</li>
<li><p>assertion check 断言检查</p>
<blockquote>
<p><strong>assertion</strong> [əˈsɜːʃn]</p>
<p>n. 断言，声明；主张，要求；坚持；认定</p>
<p>assert</p>
<p>internal asserts</p>
</blockquote>
</li>
<li><p>wrapper function 包装函数</p>
</li>
<li><p>name mangling （函数）命名重整</p>
<blockquote>
<p><strong>mangle</strong> <em>/mæŋgl/</em></p>
<p>vt. 乱砍、损坏</p>
<p> The process of encoding the signature into the link name is referred to as <strong>name mangling</strong>.  对链接名称解码签名的过程被称为命名重整。</p>
<p>Since function overloading is accomplished through <strong>name mangling</strong>, function overloading has limitations for functions that are called from the configuration. 由于函数重载是通过命名重整完成的，因此函数重载对从配置中调用的函数有限制。</p>
</blockquote>
</li>
<li><p>periodic <em>/periɒdik/</em> adj. 周期的</p>
<blockquote>
<p><strong>period</strong> n. 周期</p>
</blockquote>
</li>
<li><p>instantiation of clock 时钟实例化</p>
</li>
<li><p>advancing the connected timer by one second 将连接的时钟向前推进1秒</p>
<blockquote>
<p>advance at different rates 以不同的速率前进</p>
</blockquote>
</li>
<li><p>the attached clock 附带的时钟</p>
</li>
<li><p>results in an accurate clock 产生了（导致、致使）一个精确的时钟</p>
</li>
<li><p>constructor n. 构造函数；构造器；建造者</p>
</li>
<li><p>destructor n. 析构函数</p>
</li>
<li><p>millenium n. 千年；千禧年</p>
</li>
<li><p>leap year 闰年</p>
</li>
<li><p>millisecond [ˈmɪlisekənd] n. 毫秒；千分之一秒</p>
<blockquote>
<p>microsecond 微秒</p>
</blockquote>
</li>
<li><p>semaphore  [ˈseməfɔːr] n. 信号标，旗语；臂板信号装置 v. 打旗语，发信号</p>
</li>
<li><p>diagnostics n. 诊断学（用作单数）</p>
</li>
<li><p>declaration <em>/,deklə’reiʃən/</em> n. （纳税品等的）申报；宣布；公告；申诉书；声明；</p>
</li>
<li><p>prefix n. 前缀 vt. 加前缀；将某事物加在前面</p>
</li>
<li><p>assembly source 汇编源代码</p>
<blockquote>
<p>assembly code 汇编码</p>
</blockquote>
</li>
<li><p>toggle split editor 切换分屏编辑器</p>
<blockquote>
<p><strong>toggle</strong> [ˈtɒɡl]</p>
<p>n. 拴扣；切换键，开关；套索钉</p>
<p>v. 切换；拴牢，系紧</p>
<p><strong>split</strong> [splɪt]</p>
<p>vt. 分离；使分离；劈开；离开；分解<br>vi. 离开；被劈开；断绝关系<br>n. 劈开；裂缝<br>adj. 劈开的</p>
<p>toggle full screen 切换全屏幕</p>
<p>toggle funciton</p>
</blockquote>
</li>
<li><p>perspective n. 观点；远景；透视图 adj. 透视的</p>
<blockquote>
<p>customize perspective </p>
</blockquote>
</li>
<li><p>energia [e’nə:dʒiə] n. (Energia) 能源（火箭名）</p>
<blockquote>
<p>energia sketch 能源草图？</p>
</blockquote>
</li>
<li><p>specifications for benchmark tests 基准测试规范</p>
<blockquote>
<p><strong>specification</strong></p>
<p>​    a detailed description of design criteria for a piece of work</p>
<p>​    n. 规范</p>
<p><strong>benchmark</strong> </p>
<p>​    a standard by which something can be measured or judged</p>
<p>​    n. 参考标准，基准</p>
</blockquote>
</li>
<li><p>target-specific functions 目标特定的功能</p>
<blockquote>
<p>device-specific functions 设备特定的功能</p>
</blockquote>
</li>
<li><p>implementation of the IGateProvider interface     IGateProvider 接口的实现</p>
<blockquote>
<p><strong>implement</strong></p>
<p>​    apply in a manner consistent with its purpose or design</p>
<p>​    v. 实现</p>
</blockquote>
</li>
<li><p>fixed-size buffers 固定大小缓冲</p>
<blockquote>
<p><strong>fixed</strong></p>
<p>​    adj. 固定的</p>
<p>variable-sized buffers 可变大小缓冲</p>
</blockquote>
</li>
<li><p> dynamic memory allocation and deallocation 动态内存分配和回收</p>
</li>
<li><p>reentrant versions 可重入版本</p>
<blockquote>
<p>SYS/BIOS provides reentrant versions of malloc() and free() that internally use the xdc.runtime.</p>
<p>SYS/BIOS为内部使用XDC.RUNTIME的 malloc() 和 free() 提供了可重入版本。</p>
</blockquote>
</li>
<li><p>formal parameter 形式参数</p>
<blockquote>
<p>C++ allows you to specify default values for formal parameters within the function declaration. </p>
<p>C++允许你在函数声明中指定形参的默认值。</p>
</blockquote>
</li>
<li><p>invoke the class member function 调用类成员函数</p>
<blockquote>
<p>By writing a wrapper function which accepts a class instance as a parameter, you can invoke the class member function from within the wrapper. 通过编写以类实例作为参数的包装函数，你可以在包装函数中调用其类成员函数。</p>
</blockquote>
</li>
<li><p>context of a software interrupt 软件中断的上下文</p>
<blockquote>
<p>Memory allocation APIs such as <code>Memory_alloc()</code> and <code>Memory_calloc()</code> cannot be called from within the context of a software interrupt.内存分配接口如A和B不能够在软件中断的上下文中被调用。</p>
</blockquote>
</li>
<li><p>initial commit message 初始提交消息</p>
<blockquote>
<p><strong>commit</strong> [kəˈmɪt]</p>
<p>​    vt. 犯罪；把…交托给；指派…作战；使…承担义务；（公开地）表示意见</p>
<p>​    vi. 忠于（某个人、机构等）；承诺</p>
<p>amend last commit 修改上一次提交（的数据）</p>
</blockquote>
</li>
<li><p>stage changed （确认）暂存（数据）已变化</p>
</li>
<li><p>device endianness  设备字节顺序</p>
</li>
<li><p>preempt 抢占</p>
<blockquote>
<p> All Clock functions run at the same Swi priority, so one Clock function cannot preempt another. 所有的时钟函数都运行在相同的SWI优先级，所以一个时钟函数不能抢占另一个时钟函数。</p>
</blockquote>
</li>
<li><p>terminate <em>/ˈtɜːmɪneɪt/</em>   vi./vt. 使终止；使结束；解雇</p>
</li>
<li><p>Event Combiner 事件组合器</p>
</li>
<li><p>optimal isolation 最佳隔离？？？</p>
<blockquote>
<p>As previously stated, the stack has been designed for optimal isolation, and so that it may seamlessly plug in to varying run-time environments. </p>
</blockquote>
</li>
<li><p>octet /ɔk’tet/ 八重、八位（计算机语境下，基本与byte同意）</p>
</li>
<li><p>configuration entry 配置条目</p>
</li>
<li><p>is independent of 独立于……；相对于……独立</p>
</li>
<li><p>Parsing CGI Form Data 解析CGI结构的数据</p>
<blockquote>
<p>parse <em>/‘pɑːz/</em> v.理解，从语法上分析</p>
</blockquote>
</li>
<li></li>
</ol>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="http://www.digoboy.com/">www.digoboy.com</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备19004822号 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liewzheng</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
