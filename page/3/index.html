<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;islet.space&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script>
<meta name="description" content="笔记分享的旮旯孤岛而已">
<meta property="og:type" content="website">
<meta property="og:title" content="Coder的孤岛">
<meta property="og:url" content="http://islet.space/page/3/index.html">
<meta property="og:site_name" content="Coder的孤岛">
<meta property="og:description" content="笔记分享的旮旯孤岛而已">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liewzheng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://islet.space/page/3/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;en&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;3&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Coder的孤岛</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Coder的孤岛</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">islet of the coder</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-首页"><a href="https://islet.space/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-文章"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>文章</a></li>
        <li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-目录"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-zplusplus"><a href="https://zplusplus.cn/" rel="noopener" target="_blank"><i class="fa fa-user fa-fw"></i>ZPLUSPLUS</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liewzheng</p>
  <div class="site-description" itemprop="description">笔记分享的旮旯孤岛而已</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">82</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">155</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="mailto:liewzheng@qq.com" title="E-Mail → mailto:liewzheng@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/24/Programming/C/2021-05-24-ISO-IEC_9899-2011-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/24/Programming/C/2021-05-24-ISO-IEC_9899-2011-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">ISO-IEC_9899-2011 学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-24 00:12:00" itemprop="dateCreated datePublished" datetime="2021-05-24T00:12:00+08:00">2021-05-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-26 00:26:57" itemprop="dateModified" datetime="2021-05-26T00:26:57+08:00">2021-05-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="C标准库"><a href="#C标准库" class="headerlink" title="C标准库"></a>C标准库</h2><p><img src="https://pic.islet.space/2021/05/image-20210524001458724.png" alt="image-20210524001458724"></p>
<h3 id="文本流"><a href="#文本流" class="headerlink" title="文本流"></a>文本流</h3><p><img src="https://pic.islet.space/2021/05/image-20210524001643408.png" alt="image-20210524001643408"></p>
<h3 id="二进制流"><a href="#二进制流" class="headerlink" title="二进制流"></a>二进制流</h3><p><img src="https://pic.islet.space/2021/05/image-20210524001722423.png" alt="image-20210524001722423"></p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="字符集和字符编码"><a href="#字符集和字符编码" class="headerlink" title="字符集和字符编码"></a>字符集和字符编码</h2><p><a target="_blank" rel="noopener" href="https://unicode.org/">UNICODE主页</a></p>
<p><img src="https://pic.islet.space/2021/05/image-20210524002528437.png" alt="image-20210524002528437"></p>
<h3 id="字符集对内存的影响"><a href="#字符集对内存的影响" class="headerlink" title="字符集对内存的影响"></a>字符集对内存的影响</h3><p>字符集涉及编码规则，包括单个字符所占用的空间大小，进而影响数据在硬件中的内存占用。</p>
<img src="https://pic.islet.space/2021/05/image-20210526002443105.png" alt="image-20210526002443105"  />





<p>如果将UTF-8转换成更为精简的GBK字符集，则会输出不同的结果。</p>
<p><img src="https://pic.islet.space/2021/05/image-20210526002630693.png" alt="image-20210526002630693"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/23/Programming/2021-05-23-POSIX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/23/Programming/2021-05-23-POSIX/" class="post-title-link" itemprop="url">POSIX</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-23 22:05:00 / Modified: 22:17:37" itemprop="dateCreated datePublished" datetime="2021-05-23T22:05:00+08:00">2021-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><em>可移植操作系统接口（英语：Portable Operating System Interface，缩写为POSIX）是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，而国际标准名称为ISO/IEC 9945。此标准源于一个大约开始于1985年的项目。POSIX这个名称是由理查德·斯托曼（RMS）应IEEE的要求而提议的一个易于记忆的名称。它基本上是Portable Operating System Interface（可移植操作系统接口）的缩写，而X则表明其对Unix API的传承。</em></p>
<p><em>Linux基本上逐步实现了POSIX兼容，但并没有参加正式的POSIX认证。[1]</em></p>
<p><em>微软的Windows NT声称部分实现了POSIX标准。</em></p>
<p><em>当前的POSIX主要分为四个部分[2]：Base Definitions、System Interfaces、Shell and Utilities和Rationale。</em> </p>
<p>——Wikipedia.org的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3">可移植操作系统接口</a></p>
</blockquote>
<blockquote>
<p><em>一般情况下，应用程序通过应用编程接口(API)而不是直接通过系统调用来编程。这点很重要，因为应用程序使用的这种编程接口实际上并不需要和内核 提供的系统调用对应。一个API定义了一组应用程序使用的编程接口。它们可以实现成一个系统调用，也可以通过调用多个系统调用来实现，而完全不使用任何系 统调用也不存在问题。实际上，API可以在各种不同的操作系统上实现，给应用程序提供完全相同的接口，而它们本身在这些系统上的实现却可能迥异。</em></p>
<p><em>在Unix世界中，最流行的应用编程接口是基于POSIX标准的。从纯技术的角度看，POSIX是由IEEE的一组标准组成，其目标是提供一套大体上基于Unix的可移植操作系统标准。Linux是与POSIX兼容的。</em></p>
<p><em>POSIX是说明API和系统调用之间关系的一个极好例子。在大多数Unix系统上，根据POSIX而定义的API函数和系统调用之间有着直接关 系。实际上，POSIX标准就是仿照早期Unix系统的界面建立的。另一方面，许多操作系统，像Windows NT，尽管和Unix没有什么关系，也提供了与POSIX兼容的库。</em></p>
<p><em>Linux的系统调用像大多数Unix系统一样，作为C库的一部分提供如图5-1所示。如图5-1所示C库实现了Unix系统的主要API，包括标 准C库函数和系统调用。所有的C程序都可以使用C库，而由于C语言本身的特点，其他语言也可以很方便地把它们封装起来使用。此外，C库提供了POSIX的 绝大部分API。</em></p>
<p><em>从程序员的角度看，系统调用无关紧要；他们只需要跟API打交道就可以了。相反，内核只跟系统调用打交道；库函数及应用程序是怎么使用系统调用不是内核所关心的。</em></p>
<p>——《Linux内核设计与实现（第2版）》第5章</p>
</blockquote>
<p><strong>简单总结</strong></p>
<p>完成同一功能，不同内核提供的系统调用（也就是一个函数）是不同的，例如创建进程，linux下是fork函数，windows下是creatprocess函数。好，我现在在linux下写一个程序，用到fork函数，那么这个程序该怎么往windows上移植？我需要把源代码里的fork通通改成creatprocess，然后重新编译…</p>
<p>posix标准的出现就是为了解决这个问题。linux和windows都要实现基本的posix标准，linux把fork函数封装成posix_fork（随便说的），windows把creatprocess函数也封装成posix_fork，都声明在unistd.h里。这样，程序员编写普通应用时候，只用包含unistd.h，调用posix_fork函数，程序就在源代码级别可移植了</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/23/Programming/C++/2021-05-23-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/23/Programming/C++/2021-05-23-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E4%B8%8E-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">基本数据类型 与 构造数据类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-23 19:21:00 / Modified: 23:50:04" itemprop="dateCreated datePublished" datetime="2021-05-23T19:21:00+08:00">2021-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[cnblogs.com](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ybtools/p/6432464.html#:~:text=%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%8C%87%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%85%B6%E4%BB%96%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E6%9E%84%E9%80%A0%EF%BC%8C%E5%8F%AF%E7%94%B1%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E5%AE%9A%E4%B9%89%EF%BC%8C%E6%95%85%E5%8F%88%E7%A7%B0%E4%B8%BA">https://www.cnblogs.com/ybtools/p/6432464.html#:~:text=构造数据类型指可以通过其他的数据类型进行构造，可由程序员自定义，故又称为</a> “,自定义数据类型 “。 基本数据类型包括整型（short%2Cint%2Clong）、实型（又称浮点型）（float和double）、字符型char、布尔型bool等，他们都可以用于定义常量和变量。)</p>
<p>PS：本文以C++为例介绍数据类型。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>从广义上根据量的值是否可变，可分为<strong>常量</strong>和<strong>变量</strong>两种数据类型。</p>
<p>根据数据复杂程度，划分为<strong>基本数据类型</strong>和<strong>构造数据类型</strong>这两大类。</p>
<p><strong>基本数据类型</strong> 包括：整型（short,int,long）、实型（又称浮点型）（float和double）、字符型char、布尔型bool等。</p>
<p><strong>构造数据类型</strong> 包括：数组类型、枚举类型enum、指针类型、引用类型、结构体struct、联合体union（又称联合，共用体）、类class等。</p>
<p>构造数据类型指可以通过其他的数据类型进行构造，可由程序员自定义，故又称为 “<strong>自定义数据类型</strong>“。</p>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>基本数据类型包括整型（short,int,long）、实型（又称浮点型）（float和double）、字符型char、布尔型bool等，他们都可以用于定义常量和变量。</p>
<p>基本数据类型，也叫做基础类型，或内置类型。</p>
<p><strong>1、整型（short,int,long）</strong></p>
<p>整型量，包括短整型short、整型int、长整型long，而且3种类型都可以分别再细分为：有符号(signed)以及无符号(unsigned)。 </p>
<p><strong>2、实型（又称浮点型）（float和double）</strong></p>
<p>实型，又称为浮点型，它包括两种数据类型：单精度浮点数float和双精度浮点数double。他们都是有符号数据类型。如果一个数值常量，包含小数点、指数部分（字符e），则为浮点数。</p>
<p>双精度浮点型，还可细分为双精度（double型）、长双精度（long double）</p>
<p><strong>3、字符型char</strong></p>
<p>字符型char类型定义的常量，必须要用单括号括起来。</p>
<p>例如：char ch=’a’ ; //把字符常量’a’存储到ch中。</p>
<p>字符型char类型量也可以细分为有符号(char)和无符号(unsigned char)。</p>
<p><strong>4、布尔型bool</strong></p>
<p>布尔型的取值为true或者false。</p>
<p>布尔型变量的说明：例：bool flag，则布尔型数据的变量flag取值：只有 false 和 true 两个值，即分别是0和1。</p>
<h1 id="构造数据类型"><a href="#构造数据类型" class="headerlink" title="构造数据类型"></a>构造数据类型</h1><p>有些比较复杂的数据，单纯用基本数据类型未能表示，在C++中程序员可以用基本数据类型来自定义构造出新的数据类型，称构造数据类型，也称作 <em><strong>构造类型</strong></em>、<em><strong>构造数据类型</strong></em>。</p>
<p>构造数据类型除了可以用常见的如int、float和double、char、bool等基本数据类型进行构造，也可以包含其他构造类型的数据。</p>
<p>构造数据类型包括：数组类型、枚举类型enum、指针类型、引用类型、结构体struct、联合体union（又称联合，共用体）、class类等，他们可以通过其他的数据类型进行构造，由程序员自定义，所以又称为自定义数据类型。</p>
<p>参考：<a target="_blank" rel="noopener" href="http://blog.csdn.net/u013174689/article/details/17484223">http://blog.csdn.net/u013174689/article/details/17484223</a></p>
<p>​          </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/23/Programming/C++/2021-05-23-enum-in-CC++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/23/Programming/C++/2021-05-23-enum-in-CC++/" class="post-title-link" itemprop="url">enum in C/C++</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-23 18:22:00 / Modified: 22:03:34" itemprop="dateCreated datePublished" datetime="2021-05-23T18:22:00+08:00">2021-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>enum</code> 是 Enumeration // 的缩写，是C/C++中的 <strong>枚举</strong> 关键字。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>符合以下场景时可能需要使用到枚举：</p>
<ul>
<li>需要使用到的变量 <strong>数量较大</strong>，通过枚举以简写代码，提高代码可读性</li>
<li>使用整形（integer）进行定义（但不同于直接定义成 <code>int</code> 的 <strong>显式整形</strong>，使用枚举类型定义的话会变成 <strong>隐式整形</strong>）</li>
<li>所有值都是有固定范围的，是可人为预设的。</li>
<li>具有常量的特性（主要特点是：不可在定义之外的地方被修改）</li>
</ul>
<p>注意：</p>
<ul>
<li><em>在所有枚举值都未被赋值的情况下</em>，枚举值默认从 0 开始，往后逐个加 1（递增）。</li>
</ul>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>枚举格式</strong>：一般为 <code>enum 枚举名&#123; 枚举值表 &#125;;</code> ，也可以省略枚举名，写成如下格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">typeName</span>&#123;</span> valueName1, valueName2, valueName3, ...... &#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>enum</code> 定义 <strong>枚举类型的关键字</strong>；</p>
<p><code>typeName</code>是 枚举类型的名称，即 <strong>枚举名</strong>。</p>
<p><code>valueName1, valueName2, valueName3, ......</code>是每个值对应的名字的列表，所有元素集合即为 <strong>枚举值表</strong></p>
<p>注意：最后的<code>;</code>不能少。</p>
</blockquote>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><h2 id="起始值赋值"><a href="#起始值赋值" class="headerlink" title="起始值赋值"></a>起始值赋值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">cats</span> &#123;</span></span><br><span class="line">    juran = <span class="number">3</span>,</span><br><span class="line">    guoran,</span><br><span class="line">    dala,</span><br><span class="line">    baomei,</span><br><span class="line">    baodi,</span><br><span class="line">    zhaofeng,</span><br><span class="line">    ainiao</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">juran = 3</span><br><span class="line">guoran = 4</span><br><span class="line">dala = 5</span><br><span class="line">ainiao = 9</span><br></pre></td></tr></table></figure>



<h2 id="值表中途赋值"><a href="#值表中途赋值" class="headerlink" title="值表中途赋值"></a>值表中途赋值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">cats</span> &#123;</span></span><br><span class="line">    juran,</span><br><span class="line">    guoran,</span><br><span class="line">    dala = <span class="number">0</span>,</span><br><span class="line">    baomei,</span><br><span class="line">    baodi,</span><br><span class="line">    zhaofeng,</span><br><span class="line">    ainiao</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>给出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">juran = 0</span><br><span class="line">guoran = 1</span><br><span class="line">dala = 0</span><br><span class="line">ainiao = 4</span><br></pre></td></tr></table></figure>



<h1 id="Typedef-enum"><a href="#Typedef-enum" class="headerlink" title="Typedef enum"></a>Typedef enum</h1><p>Typedef enum 的用法一般如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>....&#125; a; </span><br></pre></td></tr></table></figure>

<p>enum 的用法一般如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span>....&#125; a;</span><br></pre></td></tr></table></figure>

<p>前者是将 <code>enum&#123;….&#125;</code> 定义成一个 <em><strong>a类型</strong></em>，声明变量的时候可以用 <code>a b</code> 格式;可以理解为类似 <code>int i</code>;</p>
<p>后者是将 <code>enum&#123;….&#125;</code> 声明了一个 <em><strong>变量</strong></em><code>a</code>。</p>
<h1 id="枚举遍历"><a href="#枚举遍历" class="headerlink" title="枚举遍历"></a>枚举遍历</h1><p> 在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。</p>
<p>不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span>&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历枚举元素</span></span><br><span class="line">    <span class="keyword">for</span> (day = MON; day &lt;= SUN; day++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;枚举元素：%d \n&quot;</span>, day);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h1><p>以下错误示范给出的提示均由 Linux的 <em><strong>GNU</strong></em> 编译器 及 Mac的 <em><strong>Clang</strong></em>（*Apple clang version 11.0.0 (clang-1100.0.33.17)*）编译器给出。</p>
<h2 id="重复定义"><a href="#重复定义" class="headerlink" title="重复定义"></a>重复定义</h2><p>不允许 <strong>在同一个作用域内</strong> 定义 <strong>一样的枚举名称</strong> ；也不允许 <strong>在同一个作用域内</strong> 的不同枚举变量中定义 <strong>名称一样的元素</strong>。</p>
<p><img src="https://pic.islet.space/2021/05/image-20210523204125878.png" alt="image-20210523204125878"></p>
<p><img src="https://pic.islet.space/2021/05/image-20210523204041715.png" alt="image-20210523204041715"></p>
<p>以上两种情况的错误提示如下：</p>
<p><img src="https://pic.islet.space/2021/05/image-20210523182310296.png" alt="image-20210523182310296"></p>
<p><img src="https://pic.islet.space/2021/05/image-20210523204224839.png" alt="image-20210523204224839"></p>
<p>也就是说 <strong>枚举名称和枚举元素都要绝对唯一</strong>。</p>
<h2 id="数值更改"><a href="#数值更改" class="headerlink" title="数值更改"></a>数值更改</h2><p>枚举类数据不允许更改数值（包括自增和赋值都不允许），有点类似于常量（const）。</p>
<p>枚举中的元素自增时的错误提示：</p>
<p><img src="https://pic.islet.space/2021/05/image-20210523202049638.png" alt="image-20210523202049638"></p>
<p>枚举中的元素赋值时的错误提示：</p>
<p><img src="https://pic.islet.space/2021/05/image-20210523202501260.png" alt="image-20210523202501260"></p>
<blockquote>
<p>根据 <a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/142755629.html">网友的回答</a> : </p>
<p>C支持枚举类型的自增操作，但C++不支持。</p>
</blockquote>
<p>以下为常量自增时给出的错误提示：</p>
<p><img src="https://pic.islet.space/2021/05/image-20210523202757582.png" alt="image-20210523202757582"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/23/Programming/C++/2021-05-23-Difference-between-GCC,-gcc-and-g++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/23/Programming/C++/2021-05-23-Difference-between-GCC,-gcc-and-g++/" class="post-title-link" itemprop="url">Difference between GCC, gcc and g++</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-23 17:00:00 / Modified: 20:07:33" itemprop="dateCreated datePublished" datetime="2021-05-23T17:00:00+08:00">2021-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>gcc 和 GCC 是两个不同的东西。</p>
<blockquote>
<p><strong>GCC</strong>：GNU Compiler Collection(GUN 编译器集合)，它可以编译C、C++、JAV、Fortran、Pascal、Object-C、Ada等语言。</p>
<p><strong>gcc</strong>：GCC中的GUN C Compiler（C 编译器）</p>
<p>**g++**：GCC中的GUN C++ Compiler（C++编译器）</p>
</blockquote>
<p>一个有趣的事实就是，就本质而言，gcc和g++并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件的类型，调用对应的GUN编译器而已，比如，用gcc编译一个c文件的话，会有以下几个步骤：</p>
<blockquote>
<p>Step1：Call a preprocessor, like cpp.</p>
<p>Step2：Call an actual compiler, like cc or cc1.</p>
<p>Step3：Call an assembler, like as.</p>
<p>Step4：Call a linker, like ld</p>
</blockquote>
<p>由于编译器是可以更换的，所以gcc不仅仅可以编译C文件</p>
<p>所以，更准确的说法是：gcc调用了C compiler，而g++调用了C++ compiler</p>
<h1 id="gcc和g-的主要区别"><a href="#gcc和g-的主要区别" class="headerlink" title="gcc和g++的主要区别"></a>gcc和g++的主要区别</h1><ol>
<li><p>对于 <em>.c和</em>.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）</p>
</li>
<li><p>对于 <em>.c和</em>.cpp文件，g++则统一当做cpp文件编译</p>
</li>
<li><p>使用g++编译文件时，<strong>g++会自动链接标准库STL，而gcc不会自动链接STL</strong></p>
</li>
<li><p>gcc在编译C文件时，可使用的预定义宏是比较少的</p>
</li>
<li><p>gcc在编译cpp文件时/g++在编译c文件和cpp文件时（这时候gcc和g++调用的都是cpp文件的编译器），会加入一些额外的宏，这些宏如下：</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __GXX_WEAK__ 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __cplusplus 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __DEPRECATED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __GNUG__ 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __EXCEPTIONS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __private_extern__ extern</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在用gcc编译c++文件时，为了能够使用STL，需要加参数 –lstdc++ ，但这并不代表 gcc –lstdc++ 和 g++等价，它们的区别不仅仅是这个</li>
</ol>
<p>其主要参数：</p>
<blockquote>
<p>-g - turn on debugging (so GDB gives morefriendly output)</p>
<p>-Wall - turns on most warnings</p>
<p>-O or -O2 - turn on optimizations</p>
<p>-o - name of the output file</p>
<p>-c - output an object file (.o)</p>
<p>-I - specify an includedirectory</p>
<p>-L - specify a libdirectory</p>
<p>-l - link with librarylib.a</p>
</blockquote>
<p>使用示例：<code>g++ -ohelloworld -I/homes/me/randomplace/include helloworld.C</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/22/Linux/2021-05-21-Equipments_in_debian_linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/22/Linux/2021-05-21-Equipments_in_debian_linux/" class="post-title-link" itemprop="url">Equipments in Debian Linux(KALI)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-22 20:30:00" itemprop="dateCreated datePublished" datetime="2021-05-22T20:30:00+08:00">2021-05-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-23 23:51:40" itemprop="dateModified" datetime="2021-05-23T23:51:40+08:00">2021-05-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>作为一个日常开发的程序员，三大平台都在日常使用的软件（生产力工具及娱乐工具）如下：</p>
<ul>
<li>utools</li>
<li>typora</li>
<li>visual studio code</li>
<li>picgo</li>
<li>sogou pinyin</li>
<li>snipaste(win) / flameshot(linux) / ishot(mac)</li>
<li>cosbrowser</li>
<li>nodejs 及 npm</li>
<li>hexo</li>
<li>qqmusic</li>
</ul>
<p>win和mac安装软件都相对简单，linux安装需要使用者自身具有一定的耐心和排除困难的经验，为了更好地体验linux的方便，这里对linux装机后的生产力工具安装做个简单记录，以下安装均在 <strong>KALI</strong> （Kali也属于Debian系Linux）上进行。</p>
<p>使用Linux系统的最大好处是 “一个终端即可解决即可开启大部分软件和解决日常事务，最多再开启一个utools”。</p>
<p>Linux上的软件安装方式通常分为四种方式：</p>
<ul>
<li>通过 <code>dpkg</code> 命令安装 <code>.deb</code> 文件</li>
<li>通过 <code>apt</code> 或其他软件的软件安装命令（如，<code>npm</code> 和 <code>pip</code>）来安装</li>
<li>通过 <code>ln</code> 链接将程序绑定至全局变量来 “安装” 和使用</li>
<li>通过直接调用 <code>AppImage</code> 的方式直接使用软件，此类方式需要一般需要手动双击执行</li>
</ul>
<p>其中前三种方式的困难因系统而异，所说的困难是可能出现所安装的软件依赖不存在，需要使用者自行去定位（包括下载和添加源）和安装，或者链接方式错误等。而Linux源众多，每个节点的速度及其更新情况都不太一样，需要使用者判断。</p>
<h1 id="uTools-amp-Flameshot"><a href="#uTools-amp-Flameshot" class="headerlink" title="uTools &amp; Flameshot"></a>uTools &amp; Flameshot</h1><p><a target="_blank" rel="noopener" href="https://res.u-tools.cn/currentversion/utools_1.3.5_amd64.deb">uTools</a> 使用的是 <code>.deb</code> 安装包安装，flameshot 使用 <code>apt</code> 命令进行安装。</p>
<p><strong>依赖文件</strong>：</p>
<ol>
<li><code>libspdlog1-fmt7</code> 是 flameshot所需文件</li>
<li><code>libappindicator3-1</code> 是 utools所需文件</li>
</ol>
<h2 id="libspdlog1"><a href="#libspdlog1" class="headerlink" title="libspdlog1"></a>libspdlog1</h2><p>尝试安装utools和flameshot后，apt会提示缺少文件。使用 <code>sudo apt-get install libspdlog1-fmt7</code> 来安装 <code>libspdlog1-fmt7</code> 。</p>
<p>如果触发安装破损修复，使用<code>apt --fix-broken install</code> 可以让apt自动修复安装错误，自动补全依赖文件。</p>
<h2 id="libappindicator3"><a href="#libappindicator3" class="headerlink" title="libappindicator3"></a>libappindicator3</h2><p><code>libappindicator3-1</code> 文件需要使用者往 <code>/etc/apt/source.list</code> 中添加debian源，需要使用者掌握基本的 <code>vim</code> 软件使用方法（包括插入、保存和退出）。</p>
<ul>
<li><p>使用 <code>sudo vim /etc/apt/sources.list</code> 命令打开 <code>source.list</code> 。</p>
</li>
<li><p>按 <code>i</code> 进入 <strong>插入模式</strong>，复制粘贴 <code>deb http://ftp.de.debian.org/debian sid main</code> 至空白处，按 <code>ESC</code> 键，再依次输入 <code>:wq</code> 进行保存和退出。</p>
</li>
<li><p>在终端输入 <code>sudo apt-get update</code> 进行源库软件列表更新，再次尝试 <code>sudo apt-get install libappindicator3</code> 来安装</p>
<p> <code>libappindicator3-1</code> and <code>libappindicator3-7</code> 。</p>
</li>
</ul>
<p>最后再次尝试以下两条语句即可成功安装 utools 和 flameshot 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i utools_1.3.5_amd64.deb</span><br><span class="line">sudo apt-get install flameshot</span><br></pre></td></tr></table></figure>





<h1 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h1><p><a target="_blank" rel="noopener" href="https://tyopra.io/">TYPORA.IO</a> 官方提供的安装代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span><br><span class="line">sudo add-apt-repository <span class="string">&#x27;deb https://typora.io/linux ./&#x27;</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install typora</span><br></pre></td></tr></table></figure>



<p>其中，向apt中添加源的第二条语句 <code>add-apt-repository</code> 会因缺乏 <code>PPA</code> 而无法执行，可以参考 <a target="_blank" rel="noopener" href="https://ywnz.com/linuxjc/7953.html#:~:text=%E6%9C%89%E4%BA%9B%E7%94%A8%E6%88%B7%E5%9C%A8UOS%E3%80%81Deepin%E7%AD%89%E6%9F%90%E4%BA%9BLinux%E5%8F%91%E8%A1%8C%E7%89%88%E7%BB%88%E7%AB%AF%E4%B8%AD%E8%BE%93%E5%85%A5PPA%E5%91%BD%E4%BB%A4%E6%97%B6%E4%BC%9A%E6%8F%90%E7%A4%BA%E2%80%9Csudo%3A%20add-apt-repository%EF%BC%9A%E6%89%BE%E4%B8%8D%E5%88%B0%E5%91%BD%E4%BB%A4%EF%BC%88command,not%20found%EF%BC%89%E2%80%9D%EF%BC%8C%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BA%E6%B2%A1%E6%9C%89%E5%AE%89%E8%A3%85PPA%E6%89%80%E8%87%B4%EF%BC%8C%E6%8A%8A%E5%AE%83%E5%AE%89%E8%A3%85%E4%B8%8A%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%B8%AD%E8%BF%90%E8%A1%8C%E4%B8%89%E6%9D%A1%E5%91%BD%E4%BB%A4%E3%80%82">sudo: add-apt-repository：找不到命令的解决方法</a> 进行安装。</p>
<p>也可以参考 <code>libappindicator3</code> 的源添加方法，往 <code>source.list</code> 文件中添加 <code>deb https://typora.io/linux ./</code> 来添加源。</p>
<p>添加成功后即可成功安装tyopra。</p>
<h1 id="Sogou-Pinyin"><a href="#Sogou-Pinyin" class="headerlink" title="Sogou Pinyin"></a>Sogou Pinyin</h1><p> 从搜狗官方下载的 <a target="_blank" rel="noopener" href="https://ime.sogoucdn.com/dl/index/1612260778/sogoupinyin_2.4.0.3469_amd64.deb?st=USANnSZV6afzzi2u6c8J-g&e=1621603885&fn=sogoupinyin_2.4.0.3469_amd64.deb">Sogou</a> 安装包，需要用 <code>sudo dpkg -i sogoupinyin_2.4.0.3469_amd64.deb</code> 命令进行安装，会遇到以下缺乏库的提示，主要是因为缺少 <code>fcitx</code> 的提示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">dpkg: 依赖关系问题使得 sogoupinyin 的配置工作不能继续：</span><br><span class="line"> sogoupinyin 依赖于 fcitx (&gt;= 1:4.2.8)；然而：</span><br><span class="line">  未安装软件包 fcitx</span><br><span class="line"> sogoupinyin 依赖于 fcitx-frontend-gtk2；然而：</span><br><span class="line">  未安装软件包 fcitx-frontend-gtk2。</span><br><span class="line"> sogoupinyin 依赖于 fcitx-frontend-gtk3；然而：</span><br><span class="line">  未安装软件包 fcitx-frontend-gtk3。</span><br><span class="line"> sogoupinyin 依赖于 fcitx-frontend-qt5；然而：</span><br><span class="line">  未安装软件包 fcitx-frontend-qt5。</span><br><span class="line"> sogoupinyin 依赖于 fcitx-module-kimpanel；然而：</span><br><span class="line">  未安装软件包 fcitx-module-kimpanel。</span><br><span class="line"> sogoupinyin 依赖于 fcitx-module-x11；然而：</span><br><span class="line">  未安装软件包 fcitx-module-x11。</span><br><span class="line"> sogoupinyin 依赖于 im-config；然而：</span><br><span class="line">  未安装软件包 im-config。</span><br><span class="line"> sogoupinyin 依赖于 fcitx-libs | libfcitx-config4；然而：</span><br><span class="line">  未安装软件包 fcitx-libs。</span><br><span class="line">  未安装软件包 libfcitx-config4。</span><br><span class="line"> sogoupinyin 依赖于 fcitx-libs | libfcitx-qt0；然而：</span><br><span class="line">  未安装软件包 fcitx-libs。</span><br><span class="line">  未安装软件包 libfcitx-qt0。</span><br><span class="line"> sogoupinyin 依赖于 fcitx-libs | libfcitx-utils0；然而：</span><br><span class="line">  未安装软件包 fcitx-libs。</span><br><span class="line">  未安装软件包 libfcitx-utils0。</span><br><span class="line"> sogoupinyin 依赖于 fcitx-ui-classic；然而：</span><br><span class="line">  未安装软件包 fcitx-ui-classic。</span><br><span class="line"> sogoupinyin 依赖于 libqt5quickwidgets5；然而：</span><br><span class="line">  未安装软件包 libqt5quickwidgets5。</span><br><span class="line"> sogoupinyin 依赖于 qml-module-qtquick2；然而：</span><br><span class="line">  未安装软件包 qml-module-qtquick2。</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Fcitx[ˈfaɪtɪks]是 (Free Chinese Input Toy for X) 的英文缩写，中文名为小企鹅输入法，是一个以 GPL 方式发布的输入法框架， 编写它的目是为桌面环境提供一个灵活的输入方案，彻底解决在GNU/Linux下没有一个好的中文输入法的问题。</p>
</blockquote>
<h2 id="FCITX"><a href="#FCITX" class="headerlink" title="FCITX"></a>FCITX</h2><p>通过输入 <code>sudo apt-get install fcitx</code> 来尝试安装，会触发 apt fix broken install， 此时只要再次输入 <code>sudo apt --fix-broken install</code> 来修复。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">下列软件包有未满足的依赖关系：</span><br><span class="line"> fcitx : 依赖: fcitx-bin 但是它将不会被安装</span><br><span class="line">         依赖: fcitx-data 但是它将不会被安装</span><br><span class="line">         依赖: fcitx-modules 但是它将不会被安装</span><br><span class="line">         推荐: fcitx-config-gtk 但是它将不会被安装 或</span><br><span class="line">                 kde-config-fcitx 但是它将不会被安装</span><br><span class="line">         推荐: fcitx-frontend-all 但是它将不会被安装 或</span><br><span class="line">                 fcitx-frontend-fbterm 但是它将不会被安装</span><br><span class="line">         推荐: fcitx-ui-classic 但是它将不会被安装 或</span><br><span class="line">                 fcitx-ui-light 但是它将不会被安装</span><br><span class="line">         推荐: im-config (&gt;= 0.5) 但是它将不会被安装</span><br><span class="line"> sogoupinyin : 依赖: fcitx-frontend-gtk2 但是它将不会被安装</span><br><span class="line">               依赖: fcitx-frontend-gtk3 但是它将不会被安装</span><br><span class="line">               依赖: fcitx-frontend-qt5 但是它将不会被安装</span><br><span class="line">               依赖: fcitx-module-kimpanel 但是它将不会被安装</span><br><span class="line">               依赖: fcitx-module-x11 但是它将不会被安装</span><br><span class="line">               依赖: im-config 但是它将不会被安装</span><br><span class="line">               依赖: fcitx-libs 但是它将不会被安装 或</span><br><span class="line">                       libfcitx-config4 但是它将不会被安装</span><br><span class="line">               依赖: fcitx-libs 但是它将不会被安装 或</span><br><span class="line">                       libfcitx-qt0 但无法安装它</span><br><span class="line">               依赖: fcitx-libs 但是它将不会被安装 或</span><br><span class="line">                       libfcitx-utils0 但是它将不会被安装</span><br><span class="line">               依赖: fcitx-ui-classic 但是它将不会被安装</span><br><span class="line">               依赖: libqt5quickwidgets5 但是它将不会被安装</span><br><span class="line">               依赖: qml-module-qtquick2 但是它将不会被安装</span><br><span class="line">E: 有未能满足的依赖关系。请尝试不指明软件包的名字来运行“apt --fix-broken install”(也可以指定一个解决办法)。</span><br></pre></td></tr></table></figure>



<h2 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功"></a>安装成功</h2><p>FIX-BROKEN 成功后，再次尝试安装 FCITX 就可以提示成功；接着安装sogou即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install fcitx                   </span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树... 完成</span><br><span class="line">正在读取状态信息... 完成                 </span><br><span class="line">fcitx 已经是最新版 (1:4.2.9.8-3)。</span><br><span class="line">fcitx 已设置为手动安装。</span><br><span class="line">升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 136 个软件包未被升级。</span><br><span class="line"></span><br><span class="line">$ sudo dpkg -i sogoupinyin_2.4.0.3469_amd64.deb</span><br><span class="line">(正在读取数据库 ... 系统当前共安装有 270000 个文件和目录。)</span><br><span class="line">准备解压 sogoupinyin_2.4.0.3469_amd64.deb  ...</span><br><span class="line">正在解压 sogoupinyin (2.4.0.3469) 并覆盖 (2.4.0.3469) ...</span><br><span class="line">正在设置 sogoupinyin (2.4.0.3469) ...</span><br><span class="line">正在处理用于 mailcap (3.69) 的触发器 ...</span><br><span class="line">正在处理用于 desktop-file-utils (0.26-1) 的触发器 ...</span><br><span class="line">正在处理用于 hicolor-icon-theme (0.17-2) 的触发器 ...</span><br></pre></td></tr></table></figure>





<h2 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h2><p>sogou输入法依赖库具体如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">下列【新】软件包将被安装：</span><br><span class="line">  dbus-x11 fcitx fcitx-bin fcitx-config-common fcitx-config-gtk fcitx-data</span><br><span class="line">  fcitx-frontend-all fcitx-frontend-gtk2 fcitx-frontend-gtk3</span><br><span class="line">  fcitx-frontend-qt5 fcitx-libs fcitx-module-dbus fcitx-module-kimpanel</span><br><span class="line">  fcitx-module-lua fcitx-module-x11 fcitx-modules fcitx-ui-classic</span><br><span class="line">  fcitx5-module-quickphrase-editor im-config libfcitx-config4</span><br><span class="line">  libfcitx-core0 libfcitx-gclient1 libfcitx-qt5-1 libfcitx-qt5-data</span><br><span class="line">  libfcitx-utils0 libgettextpo0 libpresage-data libpresage1v5</span><br><span class="line">  libqt5qmlworkerscript5 libqt5quickwidgets5 libtinyxml2.6.2v5 presage</span><br><span class="line">  qml-module-qtquick2</span><br></pre></td></tr></table></figure>



<h1 id="NodeJS-amp-Hexo"><a href="#NodeJS-amp-Hexo" class="headerlink" title="NodeJS &amp; Hexo"></a>NodeJS &amp; Hexo</h1><p>使用 <code>sudo apt-get install nodejs</code> 或 <code>sudo apt-get install node.js</code> 均可以实现node.js 的安装，但是只能安装V12版。</p>
<p>可以在官方下载 <a target="_blank" rel="noopener" href="https://nodejs.org/dist/v16.2.0/node-v16.2.0-linux-x64.tar.xz">node-v16.2.0-linux-x64.tar.xz</a> ，并使用以下命令进行解压：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xz -d node-v16.2.0-linux-x64.tar.xz</span><br><span class="line">tar -xvf node-v16.2.0-linux-x64.tar</span><br></pre></td></tr></table></figure>

<p>解压完毕之后，以管理员身份将该文件移动至 <code>/usr/local/node</code> ，以下命令将 <code>node-v16.2.0-linux-x64</code> 拷贝的同时进行了 <strong>重命名</strong> 操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /home/XXX/downloads/node-v16.2.0-linux-x64 /usr/<span class="built_in">local</span>/node</span><br></pre></td></tr></table></figure>

<p style="color: gray; font-style: italic;">注：XXX是用户名</p>

<p>然后进行软连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/node/bin/node /usr/<span class="built_in">local</span>/bin</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/node/bin/npm /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Linux ln（英文全拼：link files）命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。</p>
<p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p>
</blockquote>
<p>以上是 <code>ln</code> 链接命令的解释，实际最重要的作用是将某个已下载的软件及其命令定义至全局，在终端的任意一个目录位置都可以使用该软件。</p>
<h2 id="“安装”-成功"><a href="#“安装”-成功" class="headerlink" title="“安装” 成功"></a>“安装” 成功</h2><p>实际上新版的nodejs并不涉及 前述 <code>dpkg</code> 或 <code>apt</code> 命令的安装，但软连接该文件目录至 <code>/usr/local/bin</code> 后，能实现安装效果，使用 <code>node -v</code> 及 <code>npm -v</code> 命令即可进行测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v16.2.0</span><br><span class="line"></span><br><span class="line">$ npm -v                   </span><br><span class="line">7.14.0</span><br></pre></td></tr></table></figure>



<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>对于使用此类安装方式进行安装的 依赖于nodejs的应用如果需要在全局进行使用可能也需要进行软连接，如 hexo。</p>
<p>使用 <code>npm install hexo-cli -g</code> 成功安装hexo后提示如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ whereis hexo</span><br><span class="line">hexo:</span><br></pre></td></tr></table></figure>



<p>此时需要将 <code>/usr/local/node/bin</code> 文件夹下安装的程序也拉到全局变量中 <code>/usr/local/bin</code> 中。再次使用 <code>whereis</code> 命令检测时即可成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ln -s /usr/<span class="built_in">local</span>/node/bin/hexo /usr/<span class="built_in">local</span>/bin/hexo</span><br><span class="line">                                                                             </span><br><span class="line">$ whereis hexo</span><br><span class="line">hexo: /usr/<span class="built_in">local</span>/bin/hexo</span><br></pre></td></tr></table></figure>



<h1 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h1><p>VS code安装使用 <code>dpkg</code> 命令，最大的问题是微软的源下载太慢，以下提供个人下载点，安装过程不再记录。</p>
<p>个人下载点： <a target="_blank" rel="noopener" href="https://storage.islet.space/02_Softwares/02_Microsoft/VisualStudioCode/Linux/code_1.55.2-1618307277_amd64.deb">Visual Studio Code Linux (deb)</a></p>
<h1 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h1><p><a target="_blank" rel="noopener" href="https://support.typora.io/Upload-Image/#picgo-core-command-line-opensource">Typora_Picgo</a> 有 command-line 版 和 app 版，参考 <a target="_blank" rel="noopener" href="https://picgo.github.io/PicGo-Doc/zh/">PicGo官方文档</a> （GFW封锁了<em><strong>github.io</strong></em>域名后缀，需要梯子）进行安装吧。</p>
<h1 id="QQmusic-amp-cosbrowser"><a href="#QQmusic-amp-cosbrowser" class="headerlink" title="QQmusic &amp; cosbrowser"></a>QQmusic &amp; cosbrowser</h1><p>这两个软件都是腾讯家产品，下载、安装和使用都很方便。</p>
<p>其中，QQMusic使用 <code>dpkg</code> 命令进行安装即可， <code>cosbrowser</code> 是 <code>AppImage</code> 格式文件，直接打开即可使用，无需安装。</p>
<p><strong>彩蛋</strong>：<code>sudo apt-get install cmatrix</code></p>
<p>—EOF—</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/21/Programming/C++/2021-05-21-How-to-Use-the-C-Preprocessors-#error-Directive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/21/Programming/C++/2021-05-21-How-to-Use-the-C-Preprocessors-#error-Directive/" class="post-title-link" itemprop="url">How to Use the C Preprocessor's error Directive</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-21 23:40:32" itemprop="dateCreated datePublished" datetime="2021-05-21T23:40:32+08:00">2021-05-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-23 20:06:47" itemprop="dateModified" datetime="2021-05-23T20:06:47+08:00">2021-05-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://barrgroup.com/embedded-systems/how-to/c-preprocessor-error-directive">barrgroup.com</a></p>
<p>One of the least used but potentially most useful features of the C  preprocessor is the <em><strong>ANSI-specified #error directive</strong></em>. Here’s a look at a couple of clever uses for <code>#error</code> that have proven invaluable in embedded software development.</p>
<p>The syntax of <code>#error</code> is very straightforward:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">&lt;writer supplied error message&gt;</span>  <span class="comment">//开发者提供的错误信息</span></span></span><br></pre></td></tr></table></figure>

<p><code>&lt;writer supplied error message&gt;</code> 中可包含任何可显示的文本，甚至不需要使用双引号 <code>&quot;&quot;</code> 。</p>
<blockquote>
<p>The <code> &lt;writer supplied error message&gt;</code> can consist of any  printable text. You don’t even have to enclose the text in quotes.  (Technically, the message is optional–though it rarely makes sense to omit it.)</p>
</blockquote>
<p>当C预处理器遇到 <code>#error</code> 语句时，会将停止编译，并将错误信息输出至 <code>stderr</code> 文件。C编译器的典型错误信息如下：</p>
<blockquote>
<p>When the C preprocessor encounters a <code>#error</code> statement, it causes  compilation to terminate and the writer-supplied error message to be  printed to <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Standard_streams">stderr (link is external)</a>. A typical error message from a C compiler looks like this:</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Filename(line_number): Error! </span><br><span class="line">Ennnn: &lt;writer supplied error message&gt; </span><br></pre></td></tr></table></figure>

<p>where Filename is the source file name, <code>line_number</code> is the line  number where the <code>#error</code> statement is located, and <code>Ennnn</code> is a  compiler-specific error number. Thus, the <code>#error</code> message is basically  indistinguishable from ordinary compiler error messages.</p>
<p>“Wait a minute,” you might say. “I spend enough time trying to get  code to compile and now he wants me to do something that causes more  compiler errors?” Absolutely! The essential point is that code that compiles but is incorrect is worse than useless. I’ve found three  general areas in which this problem can arise and <code>#error</code> can help. Read  on and see if you agree with me.</p>
<h2 id="Incomplete-code"><a href="#Incomplete-code" class="headerlink" title="Incomplete code"></a>Incomplete code</h2><p>I tend to code using a step-wise refinement approach, so it isn’t  unusual during development for me to have functions that do nothing, for loops that lack a body, and so forth. Consequently, I often have files  that are compilable but lack some essential functionality. Working this  way is fine, until I’m pulled off to work on something else (an  occupational hazard of being in the consulting business). Because these  distractions can occasionally run into weeks, I sometimes return to the  job with my memory a little hazy about what I haven’t completed. In the  worst-case scenario (which has occurred), I perform a make, which runs  happily, and then I attempt to use the code. The program, of course,  crashes and burns, and I’m left wondering where to start.</p>
<p>In the past, I’d comment the file to note what had been done and what was still needed. However, I found this approach to be rather weak  because I then had to read all my comments (and I comment heavily) in  order to find what I was looking for. Now I simply enter something like  the following in an appropriate place in the file:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#error *** Nigel - Function incomplete. Fix before using *** </span><br></pre></td></tr></table></figure>

<p>Thus, if I forget that I haven’t done the necessary work, an  inadvertent attempt to use the file will result in just about the most  meaningful compiler message I’ll ever receive. Furthermore, it saves me  from having to wade through pages of comments, trying to find what work I haven’t finished.</p>
<h2 id="Compiler-dependent-code"><a href="#Compiler-dependent-code" class="headerlink" title="Compiler-dependent code"></a>Compiler-dependent code</h2><p>As much as I strive to write portable code, I often find myself  having to trade off performance for portability - and in the embedded  world, performance tends to win. However, what happens if a few years  later I reuse some code without remembering that the code has <em><strong>compiler-specific peculiarities</strong></em>? The result is a much longer debug  session than is necessary. But a <em><strong>judicious</strong></em> <code>#error</code> statement can prevent a lot of grief. A couple of examples may help.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><p>Some floating-point code requires at least 12 digits of resolution to return the correct results. Accordingly, the various variables are defined as type long double. But <em><strong>ISO C</strong></em> only requires that <em><u>a long double have 10 digits of resolution</u></em>. Thus on certain machines, a long double may be <em><strong>inadequate</strong></em> to do the job. To protect against this, I would  include the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;float.h&gt;</span><br><span class="line">#if (LDBL_DIG &lt; 12) </span><br><span class="line">	#error *** long doubles need 12 digit resolution.</span><br><span class="line">	Do not use this compiler! *** </span><br><span class="line">#endif </span><br></pre></td></tr></table></figure>

<p>This approach works by examining the value of an ANSI-mandated constant found in <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Float.h">float.h (link is external)</a>.</p>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><p>An amazing amount of code makes invalid assumptions about the  underlying size of the various integer types. If you have code that has to use an int (as opposed to a user-specified data type such as <code>int16</code>),  and the code assumes that an int is 16 bits, you can do the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;limits.h&gt;</span><br><span class="line">#if (INT_MAX !&#x3D; 32767) </span><br><span class="line">	#error *** This file only works with 16-bit int.</span><br><span class="line">	Do not use this compiler! *** </span><br><span class="line">#endif </span><br></pre></td></tr></table></figure>

<p>Again, this works by checking the value of an ANSI-mandated constant. This time the constant is found in the file <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Limits.h">limits.h (link is external)</a>. This approach is a lot more useful than putting these limitations  inside a big comment that someone may or may not read. After all, you have to read the compiler error messages.</p>
<h2 id="Conditionally-compiled-code"><a href="#Conditionally-compiled-code" class="headerlink" title="Conditionally-compiled code"></a>Conditionally-compiled code</h2><p>Since conditionally compiled code seems to be a necessary evil in embedded programming, it’s common to find code sequences such as the  following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if defined OPT_1 </span><br><span class="line">	&#x2F;* Do option_1 *&#x2F; </span><br><span class="line">#else </span><br><span class="line">	&#x2F;* Do option_2 *&#x2F; </span><br><span class="line">#endif </span><br></pre></td></tr></table></figure>

<p>As it is written, this code means the following: if and only if OPT_1 is defined, we will do option_1; otherwise we’ll do option_2. The  problem with this code is that a user of the code doesn’t know (without explicitly examining the code) that OPT_1 is a valid compiler switch.  Instead, the naive user will simply compile the code without defining OPT_1 and get the alternate implementation, irrespective of whether  that is what’s required or not. A more considerate coder might be aware  of this problem, and instead do the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if defined OPT_1 </span><br><span class="line">	&#x2F;* Do option 1 *&#x2F; </span><br><span class="line">#elif defined OPT_2 </span><br><span class="line">	&#x2F;* Do option 2*&#x2F; </span><br><span class="line">#endif </span><br></pre></td></tr></table></figure>

<p>In this case, failure to define either OPT_1 or OPT_2 will typically  result in an obscure compiler error at a point later in the code. The  user of this code will then be stuck with trying to work out what must  be done to get the module to compile. This is where #error comes in.  Consider the following code sequence:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if defined OPT_1 </span><br><span class="line">	&#x2F;* Do option_1 *&#x2F; </span><br><span class="line">#elif defined OPT_2 </span><br><span class="line">	&#x2F;* Do option_2 *&#x2F; </span><br><span class="line">#else </span><br><span class="line">	#error *** You must define one of OPT_1 or OPT_2 *** </span><br><span class="line">#endif </span><br></pre></td></tr></table></figure>

<p>Now the compilation fails, but at least it tells the user explicitly  what to do to make the module compile. I know that if this procedure had been adopted universally, I would have saved a lot of time over the  years trying to reuse other people’s code.</p>
<p>So there you have it. Now tell me, don’t you agree that <code>#error</code> is a  really useful part of the preprocessor, worthy of your frequent use-and  occasional praise?</p>
<p>​          </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/19/Web/2021-05-19-What-is-the-meaning-of--savefor-NPM-install-/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/19/Web/2021-05-19-What-is-the-meaning-of--savefor-NPM-install-/" class="post-title-link" itemprop="url">What is the meaning of '-save' for NPM install ?</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-19 20:10:00" itemprop="dateCreated datePublished" datetime="2021-05-19T20:10:00+08:00">2021-05-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-08-07 00:03:57" itemprop="dateModified" datetime="2021-08-07T00:03:57+08:00">2021-08-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Networking/" itemprop="url" rel="index"><span itemprop="name">Networking</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/what-is-the-meaning-of-save-for-npm-install/">geeksforgeeks.org</a></p>
<p><strong><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/node-js-npm-node-package-manager/">NPM (Node Package Manager)</a></strong> is the default package manager employed in JavaScript runtime environment in Node.js. It has a very frequently used command <strong>npm install [Package Name] –save</strong>. But the fact is there is no difference between <strong>npm install [Package Name]</strong> and <strong>npm install [Package Name] –save</strong> in the later version after npm 5.0.0 onwards.</p>
<p>Before npm 5.0.0, it was necessary to add <code>--save</code> after package name because it will save the installed package to  package.json file in the dependency section. If you are using a recent  version of npm save yourself from unnecessary typing and use <strong>npm install [Package Name]</strong> instead of <strong>npm install [Package Name] <code>--save</code></strong> by default it will add the installed package to the dependency list in the package.json file.</p>
<p><strong>NPM has several commands which are listed below:</strong></p>
<ol>
<li><p>–save or -S:</p>
<p> When the following command is used with npm install this will save all  your installed core packages into the dependency section in the  package.json file. Core dependencies are those packages without which  your application will not give desired results. But as mentioned  earlier, it is an unnecessary feature in the npm 5.0.0 version onwards.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save</span><br></pre></td></tr></table></figure></li>
<li><p>–save-prod or -P:</p>
<p> The following command is introduced in the later version of npm it will perform the same task as the </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--save</span><br></pre></td></tr></table></figure>

<p> command unless any other command such as </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-D</span><br></pre></td></tr></table></figure>

<p> or </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-O</span><br></pre></td></tr></table></figure>

<p> is present.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-prod</span><br></pre></td></tr></table></figure></li>
<li><p>–save-dev or -D:</p>
<p> With </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--save-dev</span><br></pre></td></tr></table></figure>

<p> or </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-D</span><br></pre></td></tr></table></figure>

<p> command your installed packages will be added to devDependency section  of the package.json file. Development dependencies are those packages  which only meant for development purpose it will not affect the  application’s result.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev</span><br></pre></td></tr></table></figure></li>
<li><p>–save-optional or -O:</p>
<p> When this command is used the install the that packages will be listed  under the optional Dependency section of the package.json file. Optional dependencies are those packages which are only used when a particular  feature of the application is used and will not be required if that  functionality isn’t used.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-optional</span><br></pre></td></tr></table></figure></li>
<li><p>–no-save:</p>
<p> When this command is used with npm install it will not allow the  installed packages from being saved into the dependency section.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --no-save</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>Note:</strong> NPM provides two additional options to save dependencies into package.json file.</p>
<ol>
<li><p>–save-exact or -E:</p>
<p> This is an additional or optional command provided by the npm that will save the exact version of the installed packages which are configured  at the time of development. It will not download the dependencies from  npm’s default server range operator.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-exact</span><br></pre></td></tr></table></figure></li>
<li><p>–save-bundle or -B:</p>
<p> The following command is also an optional command when </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--save-bundle</span><br></pre></td></tr></table></figure>

<p> or </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-B</span><br></pre></td></tr></table></figure>

<p> is used. This will also add the saved dependencies under the bundleDependency list.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-bundle</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​          </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/17/Computer/2021-05-17-%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E5%AF%B9%E9%BD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/17/Computer/2021-05-17-%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E5%AF%B9%E9%BD%90/" class="post-title-link" itemprop="url">内存地址对齐</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-17 20:10:00 / Modified: 20:32:07" itemprop="dateCreated datePublished" datetime="2021-05-17T20:10:00+08:00">2021-05-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mhq-martin/p/11537873.html">cnblogs.com</a></p>
<h1 id="对齐定义"><a href="#对齐定义" class="headerlink" title="对齐定义"></a>对齐定义</h1><p>内存地址对齐，是一种在计算机内存中排列数据、访问数据的一种方式。</p>
<h1 id="对齐分类"><a href="#对齐分类" class="headerlink" title="对齐分类"></a>对齐分类</h1><p>内存地址对齐包含了两种相互独立又相互关联的部分：<strong>基本数据对齐</strong> 和 <strong>结构体数据对齐</strong>。</p>
<p>当今的计算机在计算机内存中读写数据时都是 <mark>按字(word)大小块来进行操作</mark> 的。在32位系统中，数据总线宽度为32位，每次能读取4bytes，地址总线宽度为32，因此最大的寻址空间为2^32^bits=4GB，但是最低2位A[0]、A[1]是不用于寻址，A[2-31]才能存储器相连，因此只能访问4的倍数地址空间，但是总的寻址空间还是2^30^bits字长=4GB，因此在 <mark>内存中所有存放的基本类型数据的首地址的最低两位都是0，除结构体中的成员变量</mark> 。</p>
<blockquote>
<p>基本类型数据对齐就是数据在内存中的 <mark>偏移地址必须等于一个字的倍数</mark>，按这种存储数据的方式，可以提升系统在读取数据时的性能。<mark>为了对齐数据，可能必须在上一个数据结束和下一个数据开始的地方插入一些没有用处字节，这就是结构体数据对齐</mark>。</p>
</blockquote>
<h2 id="基本数据对齐示例"><a href="#基本数据对齐示例" class="headerlink" title="基本数据对齐示例"></a>基本数据对齐示例</h2><p>例如，假设计算机的字大小为4bytes，因此变量在内存中的首地址都是满足4地址对齐，CPU只能对4的倍数的地址进行读取，而每次能读取4个字节大小的数据。</p>
<p>假设有一个整型的数据a的首地址不是4的倍数(如下图所示)，不妨设为 <code>0X00FFFFF3</code>，则该整型数据存储在地址范围为<code>0X00FFFFF3</code> ~`0X00FFFFF6<code>的存储空间中，而CPU每次只能对4的倍数内存地址进行读取，因此想读取a的数据，CPU要分别在 </code>0X00FFFFF0<code>和</code>0X00FFFFF4` 进行两次内存读取，而且还要对两次读取的数据进行处理才能得到a的数据，而一个程序的瓶颈往往不是CPU的速度，而是取决于内存的带宽，因为CPU得处理速度要远大于从内存中读取数据的速度，因此减少对内存空间的访问是提高程序性能的关键。从上例可以看出，采取内存地址对齐策略是提高程序性能的关键。</p>
<p><mark>也就是说，不对齐内存地址的话会造成CPU对内存中数据访问范围的增大，造成性能浪费。</mark></p>
<h2 id="结构体对齐示例"><a href="#结构体对齐示例" class="headerlink" title="结构体对齐示例"></a>结构体对齐示例</h2><p>首先我们先看看下面的C语言的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct MemAlign</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b[3];</span><br><span class="line">    int c;</span><br><span class="line">&#125;MemAlign;</span><br></pre></td></tr></table></figure>

<p>以上这个结构体占用内存多少空间呢？</p>
<p>也许你会说，这个简单，计算每个类型的大小，将它们相加就行了，以32bit平台为例，int类型占4bytes，char占用1byte，所以：4 + 3 + 4 =  11bytes，那么这个结构体一共占用11字节空间。</p>
<p>实际上用sizeof运算符来求出这个结构体占用内存空间大小，sizeof(MemAlign)，出乎意料的是，结果居然为12？</p>
<p>是因为这个结构体被优化了，这个优化有个另外一个名字叫“对齐”，那么这个对齐到底做了什么样的优化呢。</p>
<p><img src="https://pic.islet.space/2021/05/1231881-20190917224404418-1265388453.png" alt="img"></p>
<p>相信学过汇编的朋友都很熟悉这张图，这张图就是CPU与内存如何进行数据交换的模型，其中，左边蓝色的方框是CPU，右边绿色的方框是内存，内存上面的0～3是内存地址。</p>
<p>上图以32位CPU作为代表，<mark>32位CPU是以双字（DWORD）为单位进行数据传输的</mark>，因此 <mark>在32位系统中，无论是8位、16位还是32位都是以双字进行数据传输</mark> 。</p>
<h2 id="非32位数据非对齐传输示例"><a href="#非32位数据非对齐传输示例" class="headerlink" title="非32位数据非对齐传输示例"></a>非32位数据非对齐传输示例</h2><p>8位或16位一样可以传输，但是事情并非像我们想象的那么简单。</p>
<p>一个int类型4字节的数据如果放在上图内存地址1开始的位置，那么这个数据占用的内存地址为1～4，那么这个数据就被分为了2个部分，一个部分在地址0～3中，另外一部分在地址4～7中，又由于32位CPU以双字进行传输，所以，CPU会分2次进行读取，一次先读取地址0～3中内容，再一次读取地址4～7中数据，最后CPU提取并组合出正确的int类型数据，舍弃掉无关数据。那么反过来，如果我们把这个int类型4字节的数据放在上图从地址0开始的位置会怎样呢？读到这里，也许你明白了，CPU只要进行一次读取就可以得到这个int类型数据了。没错，就是这样，这次CPU只用了一个周期就得到了数据，由此可见，对内存数据的摆放是多么重要啊，<mark>摆放正确位置可以减少CPU的使用资源</mark>。</p>
<h1 id="对齐原则"><a href="#对齐原则" class="headerlink" title="对齐原则"></a>对齐原则</h1><ul>
<li><p>第一个成员的首地址为0</p>
</li>
<li><p>每个成员的首地址是自身大小的整数倍</p>
<ul>
<li>以4bytes对齐为例，如果自身大小大于4bytes，都以4bytes整数倍为基准对齐。</li>
</ul>
</li>
<li><p>最后以结构总体对齐。</p>
<ul>
<li>以4字节bytes为例，取结构体中最大成员类型倍数，如果超过4字节，都以4字节整数倍为基准对齐。（其中这一条还有个名字叫：“补齐”，补齐的目的就是多个结构变量挨着摆放的时候也满足对齐的要求。）</li>
</ul>
</li>
</ul>
<h2 id="基本数据对齐与结构补齐示例"><a href="#基本数据对齐与结构补齐示例" class="headerlink" title="基本数据对齐与结构补齐示例"></a>基本数据对齐与结构补齐示例</h2><p>上述的三原则听起来还是比较抽象，那么接下来我们通过一个例子来加深对内存对齐概念的理解，下面是一个结构体，我们动手算出下面结构体一共占用多少内存？假设我们以32位平台并且以4字节对齐方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma pack(4)</span><br><span class="line">typedef struct MemAlign</span><br><span class="line">&#123;</span><br><span class="line">    char a[18];</span><br><span class="line">    double b;    </span><br><span class="line">    char c;</span><br><span class="line">    int d;    </span><br><span class="line">    short e;    </span><br><span class="line">&#125;MemAlign;</span><br></pre></td></tr></table></figure>

<p>下图为对齐后结构如下：</p>
<p><img src="https://pic.islet.space/2021/05/1231881-20190917224631323-2009020349.png" alt="img"></p>
<p>我们就以这个图来讲解是如何对齐的：</p>
<p>第一个成员（char a[18]）：首先，假设我们把它放到内存开始地址为0的位置，由于第一个成员占18个字节，所以第一个成员占用内存地址范围为0～18。</p>
<p>第二个成员（double b）：由于double类型占8字节，又因为8字节大于4字节，所以就以4字节对齐为基准。由于第一个成员结束地址为18，那么地址18并不是4的整数倍，我们需要再加2个字节，也就是从地址20开始摆放第二个成员。</p>
<p>第三个成员（char c）：由于char类型占1字节，任意地址是1字节的整数倍，所以我们就直接将其摆放到紧接第二个成员之后即可。</p>
<p>第四个成员（int d）：由于int类型占4字节，但是地址29并不是4的整数倍，所以我们需要再加3个字节，也就是从地址32开始摆放这个成员。</p>
<p>第五个成员（short e）：由于short类型占2字节，地址36正好是2的整数倍，这样我们就可以直接摆放，无需填充字节,紧跟其后即可。</p>
<p>这样我们内存对齐就完成了。但是离成功还差那么一步，那是什么呢？对，是对整个结构体补齐，接下来我们就补齐整个结构体。那么，先让我们回顾一下补齐的原则：“以4字节对齐为例，取结构体中最大成员类型倍数，如果超过4字节，都以4字节整数倍为基准对齐。”在这个结构体中最大类型为double类型（占8字节），又由于8字节大于4字  节，所以我们还是以4字节补齐为基准，整个结构体结束地址为38，而地址38并不是4的整数倍，所以我们还需要加额外2个字节来填充结构体，如下图红色的就是补齐出来的空间：</p>
<p><img src="https://pic.islet.space/2021/05/1231881-20190917224653471-2076639760.png" alt="img"></p>
<p> 到此为止，我们内存对齐与补齐就完毕了！接下来我们用实验来证明真理，程序如下：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;memory.h&gt;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 由于VS2010默认是8字节对齐，我们</span><br><span class="line">&#x2F;&#x2F; 通过预编译来通知编译器我们以4字节对齐</span><br><span class="line">#pragma pack(4)</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 用于测试的结构体</span><br><span class="line">typedef struct MemAlign</span><br><span class="line">&#123;</span><br><span class="line">    char a[18];    &#x2F;&#x2F; 18 bytes</span><br><span class="line">    double b;    &#x2F;&#x2F; 08 bytes    </span><br><span class="line">    char c;        &#x2F;&#x2F; 01 bytes</span><br><span class="line">    int d;        &#x2F;&#x2F; 04 bytes</span><br><span class="line">    short e;    &#x2F;&#x2F; 02 bytes</span><br><span class="line">&#125;MemAlign;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 定义一个结构体变量</span><br><span class="line">    MemAlign m;</span><br><span class="line">    &#x2F;&#x2F; 定义个以指向结构体指针</span><br><span class="line">    MemAlign *p &#x3D; &amp;m;</span><br><span class="line">    &#x2F;&#x2F; 依次对各个成员进行填充，这样我们可以</span><br><span class="line">    &#x2F;&#x2F; 动态观察内存变化情况</span><br><span class="line">    memset( &amp;m.a, 0x11, sizeof(m.a) );</span><br><span class="line">    memset( &amp;m.b, 0x22, sizeof(m.b) );</span><br><span class="line">    memset( &amp;m.c, 0x33, sizeof(m.c) );</span><br><span class="line">    memset( &amp;m.d, 0x44, sizeof(m.d) );</span><br><span class="line">    memset( &amp;m.e, 0x55, sizeof(m.e) );</span><br><span class="line">    &#x2F;&#x2F; 由于有补齐原因，所以我们需要对整个</span><br><span class="line">    &#x2F;&#x2F; 结构体进行填充，补齐对齐剩下的字节</span><br><span class="line">    &#x2F;&#x2F; 以便我们可以观察到变化</span><br><span class="line">    memset( &amp;m, 0x66, sizeof(m) );</span><br><span class="line">    &#x2F;&#x2F; 输出结构体大小</span><br><span class="line">    printf( &quot;sizeof(MemAlign) &#x3D; %d&quot;, sizeof(m) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>程序运行过程中，查看内存如下：</p>
<p><img src="https://pic.islet.space/2021/05/1231881-20190917225512389-1581088258.png" alt="img"></p>
<p>其中，各种颜色带下划线的代表各个成员变量，蓝色方框的代表为内存对齐时候填补的多余字节，由于这里看不到补齐效果，我们接下来看下图，下图篮框包围的字节就是与上图的交集以外的部分就是补齐所填充的字节。</p>
<p><img src="https://pic.islet.space/2021/05/1231881-20190917225534651-684741719.png" alt="img"></p>
<p> 在最后，我在谈一谈关于补齐的作用，<mark>补齐其实就是为了让这个结构体定义的数组变量时候，数组内部，也同样满足内存对齐的要求</mark>，为了更好的理解这点，我做了一个跟本例子相对照的图：</p>
<p><img src="https://pic.islet.space/2021/05/1231881-20190917225553591-1418591054.png" alt="img"></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/donkeylong/article/details/4909720">https://blog.csdn.net/donkeylong/article/details/4909720</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cyousui/article/details/17655051">https://blog.csdn.net/cyousui/article/details/17655051</a></p>
<p>​          </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://islet.space/2021/05/17/Computer/2021-05-17-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liewzheng">
      <meta itemprop="description" content="笔记分享的旮旯孤岛而已">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder的孤岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/17/Computer/2021-05-17-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">汇编语言</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-17 20:00:00" itemprop="dateCreated datePublished" datetime="2021-05-17T20:00:00+08:00">2021-05-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-20 22:50:31" itemprop="dateModified" datetime="2021-05-20T22:50:31+08:00">2021-05-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="X86指令集介绍"><a href="#X86指令集介绍" class="headerlink" title="X86指令集介绍"></a>X86指令集介绍</h1><h2 id="X86指令集的基本特色"><a href="#X86指令集的基本特色" class="headerlink" title="X86指令集的基本特色"></a>X86指令集的基本特色</h2><ul>
<li>向下兼容</li>
<li>变长指令<ul>
<li>1-15字节，多为2-3字节长度</li>
</ul>
</li>
<li>多种寻址方式（可访问不对齐内存地址）</li>
</ul>
<p><img src="https://pic.islet.space/2021/05/image-20210517203416861.png" alt="image-20210517203416861"></p>
<h2 id="X86寄存器"><a href="#X86寄存器" class="headerlink" title="X86寄存器"></a>X86寄存器</h2><p>指令集的通用寄存器个数有限</p>
<blockquote>
<p>X86-32下指令集通用寄存器数量为8个，x86-64下为16个</p>
</blockquote>
<p>至多只有一个操作数在内存中，另一个操作数为立即数或寄存器</p>
<p><img src="https://pic.islet.space/2021/05/image-20210517204354665.png" alt="image-20210517204354665"></p>
<p><img src="https://pic.islet.space/2021/05/image-20210517204446891.png" alt="image-20210517204446891"></p>
<p><em>源自 网络PDF</em>——<a target="_blank" rel="noopener" href="https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwimmc7O39DwAhV5yYsBHdS2CHMQFjAAegQIAxAD&url=http://images.china-pub.com/ebook4930001-4935000/4934543/ch02.pdf&usg=AOvVaw0yJuRWmzjtj41FR6ld_Vmm">X86处理器架构</a></p>
<h1 id="SHARC汇编"><a href="#SHARC汇编" class="headerlink" title="SHARC汇编"></a>SHARC汇编</h1><p><a href="">《Assembler and Preprocessor Manual(including the ADSP-BFxxx, ADSP-21xxx, ADSP-TSxxx)》</a></p>
<h2 id="VisualDSP"><a href="#VisualDSP" class="headerlink" title="VisualDSP++"></a>VisualDSP++</h2><p>以下是ADI官网对VisualDSP++（以下简称VDSP）的解释，本质上是个集成软件开发和调试环境（IDDE）。</p>
<p><img src="https://pic.islet.space/2021/05/image-20210520005659254.png" alt="image-20210520005659254"></p>
<p>汇编器的操作取决于两种类型的控制：汇编器指令和汇编器开关。</p>
<blockquote>
<p>Assembler operations depend on two types of controls: <strong>assembler directives</strong> and <strong>assembler switches</strong>.</p>
</blockquote>
<p>VDSP支持以下三种不同的汇编器：</p>
<img src="https://pic.islet.space/2021/05/image-20210520010438229.png" alt="image-20210520010438229" style="zoom: 67%;" />



<p>DSP汇编开发者需要先熟悉以下内容：</p>
<blockquote>
<ul>
<li><p>“<em>Writing Assembly Programs</em>” on page 1-3</p>
</li>
<li><p> “<em>Using Assembler Support for C Structs</em>” on page 1-21</p>
</li>
<li><p> “<em>Preprocessing a Program</em>” on page 1-24</p>
</li>
<li><p>“<em>Using Assembler Feature Macros</em>” on page 1-25</p>
</li>
<li><p>“<em>Generating Make Dependencies</em>” on page 1-37</p>
</li>
<li><p>“<em>Reading a Listing File</em>” on page 1-38</p>
</li>
<li><p>“<em>Enabling Statistical Profiling for Assembly Functions</em>” on page 1-38</p>
</li>
<li><p>“*Specifying Assembler Options in VisualDSP++*” on page 1-173</p>
</li>
</ul>
</blockquote>
<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>汇编器 将 <strong>汇编源(.asm)<strong>、</strong>数据(.dat)</strong> 和 <strong>头文件(.h)</strong> 三者整理成可执行可链接的格式（ELF），也就是一个标准的 **二进制文件(.doj)**。</p>
<p>另外，汇编器还将生成一个 **列表文件(.lst)**，展示二进制文件和源文件之间的联系。</p>
<p>也就是说，编译成功后，.doj和.lst文件就是其编译结果。</p>
<img src="https://pic.islet.space/2021/05/image-20210520011656751.png" alt="image-20210520011656751" style="zoom:67%;" />

<blockquote>
<p>Figure 1-1 shows a graphical overview of the assembly process. The figure shows the preprocessor processing the assembly source (.asm) and header (.h) files.</p>
<p>By default, the assembler processes an intermediate file to produce a binary object file (.doj) and an optional listing file (.lst). </p>
</blockquote>
<img src="https://pic.islet.space/2021/05/image-20210520012328329.png" alt="image-20210520012328329" style="zoom:67%;" />



<h2 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h2><ul>
<li><p>Assembler directives are coded in assembly source files. </p>
</li>
<li><p>The directives allow you to <strong>define variables</strong>, <strong>set up hardware features</strong>, and <strong>identify program sections</strong> for placement within processor memory. </p>
</li>
<li><p>The assembler uses directives for guidance as it translates a source program into object code. </p>
</li>
</ul>
<p>注意：</p>
<blockquote>
<ul>
<li><p>Do not use a <em><strong>word processor</strong></em> that embeds special control codes in the text. </p>
</li>
<li><p>Use an <code>.asm</code> extension to source file names to identify them as assembly source files.</p>
</li>
</ul>
</blockquote>
<p>可以使用像 <code>batch-file</code> 和 <code>makefile</code> 这样的命令行工具来汇编你的源文件。</p>
<p>列表文件还提供了关于导入的C语言数据结构的信息。</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p><strong>现象</strong>：出现如下图所示的头文件缺少</p>
<p><img src="https://pic.islet.space/2021/05/20210520095711.png" alt="image-20210520090023689"></p>
<p><strong>原因</strong>：<code>.boj </code>文件和其所依赖的 <code>.h</code> 头文件相对路径不一致，或项目文件的绝对路径与原来创建时不一致。</p>
<p><strong>例如</strong>：从文件 <code>Debug/system/startup_Idf/app_IVT.doj</code> 中可以看出，该文件的创作者是将其放置在 <code>D:\ADSP\workspace\LED_test\Debug</code> 下的，因此需要改变该项目文件的位置。</p>
<p><strong>解决方法</strong>：在原创作者的绝对路径下放置该项目文件。</p>
<p><img src="https://pic.islet.space/2021/05/20210520095708.png" alt="image-20210520090936369"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备19004822号 </a>
  </div>

<div class="copyright">
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liewzheng</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
